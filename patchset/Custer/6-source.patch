From: Horst Beepmanh <>
Subject: Source

---
diff --git a/DeclData/DeclData.make b/DeclData/DeclData.make
--- a/DeclData/DeclData.make
+++ b/DeclData/DeclData.make
@@ -30,14 +30,6 @@ PDMMaceDir	=	{MaceDir}PDMMaceEnet:
 #include {PDMMaceDir}PDMEnet.Make
 
 DeclResources =	"{RsrcDir}DeclData.rsrc"					∂
-				"{RsrcDir}PrimaryInit.rsrc"					∂
-				"{RsrcDir}SecondaryInit.rsrc"				∂
-				"{RsrcDir}SuperInit.rsrc"					∂
-				"{RsrcDir}DeclDataMace.rsrc"				∂
-				"{RsrcDir}DeclDataPDMMace.rsrc"				∂
-				"{RsrcDir}DeclDataSonic.rsrc"				∂
-				"{RsrcDir}DeclDataVideo.rsrc"				∂
-				"{RsrcDir}Gamma.rsrc"				
 
 DeclHeaders	=	"{ObjDir}StandardEqu.d"						∂
 				"{AIncludes}GestaltEqu.a"					∂
diff --git a/DeclData/DeclData.r b/DeclData/DeclData.r
--- a/DeclData/DeclData.r
+++ b/DeclData/DeclData.r
@@ -765,6 +765,24 @@ resource 'sdir' (160, "_sRsrcBFBasedDir") {{
 }};
 
 
+//-------------------------------------------------------------
+//           TNT sRsrc Directory
+//-------------------------------------------------------------
+
+resource 'sdir' (170, "_sRsrcTNTDir") {{
+  $3E,              l{"_sRsrc_TNT"};			// Minimal board sRsrc directory.
+  $FD,              l{"_sRsrc_OpenTxpt"};		// Open Transport functional sRsrc
+}};
+
+
+resource 'boar' (150, "_sRsrc_TNT") {{
+  sRsrcType,        l{"_BoardType"};			// Minimal board sRsrc.
+  sRsrcName,        c{"Macintosh 4A"};
+  BoardId,          d{$670};
+  VendorInfo,       l{"_VendorInfo"};
+}};
+
+
 //-------------------------------------------------------------
 //
 //           sRsrc_Board Lists
@@ -1121,9 +1139,9 @@ resource 'styp' (535, "_BoardType") {CatBoard, TypBoard, 0, 0};
 //-------------------------------------------------------------
 
 resource 'vend' (540, "_VendorInfo") {{
-  VendorId,         c{"Copyright © 1986-1993 by Apple Computer, Inc.  All Rights Reserved."};
-  RevLevel,         c{"Macintosh CPU Family 5.1"};     // offset to revision 
-  PartNum,          c{"Universal DeclROM"};            // offset to part number descriptor
+  VendorId,         c{"Copyright © 1986-1998 by Apple Computer, Inc.  All Rights Reserved."};
+  RevLevel,         c{"Macintosh CPU Family 6.0"};     // offset to revision 
+  PartNum,          c{"DeclROM for OpenTxpt"};         // offset to part number descriptor
   Date,             c{$$Date};                  	   // offset to ROM build date descriptor
 }};
 
@@ -2899,6 +2917,14 @@ resource 'srsc' (1575, "_sRsrc_Mace") {{
 }};
 
 
+resource 'srsc' (1576, "_sRsrc_OpenTxpt") {{
+  sRsrcType,        l{"_NetOpenTxpt"};			// Network type descriptor
+  sRsrcName,        l{"_NetOpenTxptName"};		// offset to name string
+  sRsrcFlags,       d{0};						// don't open this device at start
+  sRsrcHWDevId,     d{2};						// the second of many onboard Ethernet chips
+}};
+
+
 //----------------------------------
 
 resource 'srsc' (1580, "_sRsrc_DoubleExposure") {{
@@ -2927,6 +2953,7 @@ resource 'styp' (1605, "_VideoTypeApollo") 	{CatDisplay, TypVideo, DrSwApple, Dr
 resource 'styp' (1610, "_VideoTypeGSC") 	{CatDisplay, TypVideo, DrSwApple, DrHwGSC};
 resource 'styp' (1625, "_NetSonic")       	{CatNetwork, TypEthernet, DrSwApple, DrHwSonic};
 resource 'styp' (1630, "_NetMace")  		{CatNetwork, TypEthernet, DrSwApple, DrHwMace};
+resource 'styp' (1631, "_NetOpenTxpt")  	{CatNetwork, TypEthernet, DrSwApple, 4};
 resource 'styp' (1635, "_CPUDblExp") 		{CatCPU, 	 TypAppleII, DrSwAppleIIe, DrHwDblExp};
 resource 'styp' (1636, "_SCSITransport") 	{CatIntBus,  TypXPT, DrSwApple, sRsrc_BdCyclone};
 
@@ -2945,6 +2972,7 @@ resource 'cstr' (1660, "_VideoNameApollo") {"Display_Video_Apple_Apollo"};
 resource 'cstr' (1665, "_VideoNameGSC")    {"Display_Video_Apple_DBLite"};
 resource 'cstr' (1680, "_NetSonicName")    {"Network_Ethernet_Apple_Sonic"};
 resource 'cstr' (1685, "_NetMaceName")     {"Network_Ethernet_Apple_Mace"};
+resource 'cstr' (1686, "_NetOpenTxptName") {"Network_Ethernet_Apple_OpenTransport"};
 
 #endif
 
@@ -9483,10 +9511,8 @@ resource 'long' (2657, "_timingApple16")		{timingApple16};
 //               Extended Format/Header Block
 //-------------------------------------------------------------
                 
-resource 'xfrm' (6000, "Root") {
-	l{"_sSuperInitRec"},
-	l{"_sRsrcSuperDir"},
-	l{"_sRsrcUnknownDir"},
+resource 'form' (6000, "Root") {
+	l{"_sRsrcTNTDir"},
 	1,								// RomRevision
 	appleFormat,
 	0,
diff --git a/Drivers/EDisk/EDiskDriver.a b/Drivers/EDisk/EDiskDriver.a
--- a/Drivers/EDisk/EDiskDriver.a
+++ b/Drivers/EDisk/EDiskDriver.a
@@ -113,8 +113,6 @@
 		
 		MACHINE	MC68020
 
-NewEdiskProt	EQU		1
-
 _TestManager		OPWORD  	$A06B
 
 		macro
@@ -138,7 +136,7 @@ EDiskDRVRflags	SET	EDiskDRVRflags!1<<dStatEnable
 EDiskDRVRflags	SET	EDiskDRVRflags!1<<dNeedLock
 
 		dc.b	EDiskDRVRflags,0		; drvFlags (upper byte)
-		dc.w	0						; drvDelay, no delay
+		dc.w	60						; drvDelay, accRun every second
 		dc.w	0						; drvEMask, no event mask
 		dc.w	0						; drvMenu, no menu
 		dc.w	EDiskOpen-EDiskDRVR		; drvOpen,   offset of OPEN routine
@@ -190,6 +188,9 @@ ControlDecode
 		dc.w	ctlDriveInfo-(*+4)
 		dc.w	infoCC					; Drive Info control call
 
+		dc.w	ctlPeriodic-(*+4)
+		dc.w	accRun					; SystemTask periodic run call
+
 		dc.w	-1						; indicate end of control decode table
 		dc.w	ControlErr				; return ControlErr if unknown csCode
 		title	'EDisk Driver - Open processing'
@@ -224,22 +225,7 @@ ControlDecode
 
 InitTable
 		dc.l	0						; RamDisk doesn't have poll pointer
-		dc.w	RAMDiskHandler-(*+2)	; RamDisk function handler
-		dc.w	RAMDiskMediaIcon-(*+2)	; RamDisk media icon pointer
-		dc.w	RAMDiskDriveIcon-(*+2)	; RamDisk drive icon pointer
-		dc.w	RAMDiskName-(*+2)		; RamDisk drive name pointer
-		dc.l	(1<<15)+\				; volatile media
-				(0<<11)+\				; primary
-				(1<<10)+\				; fixed
-				(0<<9)+\				; iwm (not SCSI)
-				(0<<8)+\				; internal
-				ramDiskType				; RAM disk
-		dc.b	(1<<CreateWithXSums)	; flags
-		dc.b	$48						; DiskInPlaceInit = non-ejectable, re-mount
-
-InitTablePPC
-		dc.l	0						; RamDisk doesn't have poll pointer
-		dc.w	RAMDiskHandlerPPC-(*+2)	; RamDisk function handler for PowerPC
+		dc.w	RAMDiskHandler-(*+2)	; RamDisk function handler for PowerPC
 		dc.w	RAMDiskMediaIcon-(*+2)	; RamDisk media icon pointer
 		dc.w	RAMDiskDriveIcon-(*+2)	; RamDisk drive icon pointer
 		dc.w	RAMDiskName-(*+2)		; RamDisk drive name pointer
@@ -251,35 +237,7 @@ InitTablePPC
 				ramDiskType				; RAM disk
 		dc.b	(0<<CreateWithXSums)	; flags
 		dc.b	$48						; DiskInPlaceInit = non-ejectable, re-mount
-
-PrimaryROMdisk
-		dc.l	0						; RomDisk doesn't have poll pointer
-		dc.w	ROMDiskHandler-(*+2)	; RomDisk function handler
-		dc.w	ROMDiskMediaIcon-(*+2)	; RomDisk media icon pointer
-		dc.w	ROMDiskDriveIcon-(*+2)	; RomDisk drive icon pointer
-		dc.w	ROMDiskName-(*+2)		; RomDisk drive name pointer
-		dc.l	(0<<11)+\				; primary
-				(1<<10)+\				; fixed
-				(0<<9)+\				; iwm (not SCSI)
-				(0<<8)+\				; internal
-				romDiskType				; ROM disk
-		dc.b	(1<<CreateWithXSums)	; flags
-		dc.b	$08						; DiskInPlaceInit = non-ejectable
-InitEntrySize	equ		*-PrimaryROMdisk		; size of an initialization table entry
-
-SecondaryROMdisk
-		dc.l	0						; RomDisk doesn't have poll pointer
-		dc.w	ROMDiskHandler-(*+2)	; RomDisk function handler
-		dc.w	ROMDiskMediaIcon-(*+2)	; RomDisk media icon pointer
-		dc.w	ROMDiskDriveIcon-(*+2)	; RomDisk drive icon pointer
-		dc.w	ROMDiskName-(*+2)		; RomDisk drive name pointer
-		dc.l	(1<<11)+\				; secondary
-				(1<<10)+\				; fixed
-				(0<<9)+\				; iwm (not SCSI)
-				(0<<8)+\				; internal
-				romDiskType				; ROM disk
-		dc.b	(1<<CreateWithXSums)	; flags
-		dc.b	$08						; DiskInPlaceInit = non-ejectable
+InitEntrySize	equ		*-InitTable		; size of an initialization table entry
 
 EDiskOpen								; all regs saved by Device Manager
 		move.l	a0,-(sp)				; save pointer to I/O param block
@@ -303,43 +261,17 @@ EDiskOpen								; all regs saved by Device Manager
 
 		lea		InitTable,a6			; a6 := assume pointer to 68k initial values	<2>
 
-	IF newEdiskProt THEN
-		cmpi.b	#EMMU1,MMUType			; check for an emulated MMU
-		bne.s	@NoEMMU
-		lea		InitTablePPC,a6			; a6 := pointer to PowerPC initial values
-@NoEMMU
-	ENDIF
-
 		move.l	BootGlobPtr,a2			; get ptr to BootGlobs							<T2>
-		move.l	sgRamDiskBase(a2),d2	; base of RAM disk								<T4>
-		move.l	d2,d3					; get a copy in d3								<T4>
+		move.l	sgRamDiskBase(a2),d1	; base of RAM disk								<T4>
+		move.l	d1,d3					; get a copy in d3								<T4>
 		add.l	sgRamDiskSize(a2),d3	; end of ram disk in d3							<T4>
 
 		suba.l	a2,a2					; a2 := HeaderInfoPtr (none for RamDisk)		<2>
-		move.l	d2,d1					; get start addr in d2							<T4>
 		moveq.l	#0,d2					; DataStartPtr := 0								<2>
 		cmp.l	d1,d3					; see if it has any bytes
 		bsr		CreateEDrive			; create the RAM disk
 @noDisk									; ENDIF
 
-;	search for, and install ROM disks
-
-		movea.l	RomBase,a2				; start searching at the base of ROM
-@RomDiskLoop							;
-		bsr.w	CheckForRomDisk			; see if it is a ROM disk
-		bne.s	@NextRomDisk			; if not, try the next block
-
-		moveq.l	#0,d1					; assume no checksums unless header says otherwise
-		move.l	a2,d2					; DataStartPtr := base of rom disk for now
-		move.l	a2,d3					; DataEndPtr := base of rom disk for now
-		bsr.s	CreateEDrive			; create the RAM disk
-		lea		SecondaryROMdisk,a6		; all future ROM disks are secondary
-
-@NextRomDisk							;
-		adda.l	#RomDiskAlign,a2		; point to next block to check
-		cmpa.l	#RomSpaceEnd,a2			; see if end reached
-		blo.s	@RomDiskLoop			; search the entire space
-
 ;	see if we have any EDisks to drive, abort OPEN if none.
 
 		moveq.l	#OpenErr,d0				; if no drives found, return OpenErr
@@ -362,20 +294,6 @@ EDiskOpen								; all regs saved by Device Manager
 		move.w	@RTS,FindDqePatch(a2)	; initialize FindDQE patch routine
 		move.w	@RTS,PrimePatch(a2)		; initialize Prime patch routine
 
-;	Install the VBL task to look for SLIM insertions and removals
-
-		lea		EDiskPollTask,a4		; get the task address
-		moveq.l	#8-1,d4					; loop counter (8 times)
-@InitPolling
-		lea		VTask(a2),a0			; a0 := pointer to VTask
-		jsr		(a4)					; poll 8 times to init inserted status
-		dbra	d4,@InitPolling			; and mount drives, and compute sizes
-
-		lea		VTask(a2),a0			; a0 <- VBL task
-		addq.w	#vType,qType(a0)		; initialize qType field
-		move.l	a4,vblAddr(a0)			; initialize vblAddr field
-		_VInstall						; install the VBL task
-
 		moveq.l	#NoErr,d0				; no error
 @OpenDone
 		movea.l	(sp)+,a0				; restore pointer to I/O param block
@@ -413,7 +331,7 @@ CreateEDrive
 		_NewPtr	,Sys,Clear				; allocate the drive info
 		bne.s	@Done					; if can't allocate, don't create drive
 
-		add.l	#DQE-SLIMRegPtr,a0		; point to the drive queue entry				<T6>
+		lea		DQE-SLIMRegPtr(a0),a0	; point to the drive queue entry				<T6>
 
 		movea.l	a6,a3					; a3 := running pointer to init table entry
 		move.l	(a3)+,SLIMRegPtr(a0)	; initialize the SLIMRegPtr						<T6>
@@ -443,7 +361,7 @@ CreateEDrive
 		move.l	d3,RamDiskSize(a0)		; store it in globals							<T6>
 
 		addq.w	#1,qType(a0)			; use long drive size format
-		addq.w	#1,Installed(a0)		; mark the drive as installed
+		addq.b	#1,Installed(a0)		; mark the drive as installed
 		move.l	d7,d0					; get disk drive number, and refNum
 		swap	d0						; move to high word, refNum to low word
 		move.l	a0,a3					; make a copy of ptr to info
@@ -452,82 +370,12 @@ CreateEDrive
 		move.l	d1,a0					; get ptr to base of Edisk data
 		move.l	d3,d1					; get RamDiskSize
 		moveq.l	#DisableEDiskWrites,d0	; always disable writes at startup
-		bsr.w	HWDependent				; disable writing to the EDisk
+		bsr		HWDependent				; disable writing to the EDisk
+		bsr		EDiskPollTask
 
 @Done	addq.w	#1,d7					; update drive number
 		adda.w	#InitEntrySize,a6		; point to next drive init entry
 		rts								; EDisk drive is installed
-		title	'EDisk Driver - Check for ROM Disk'
-
-;_______________________________________________________________________
-;
-;  Routine:		CheckForRomDisk
-;  Inputs:		A2 - HeaderInfoPtr
-;				D7.hi - EDisk Driver RefNum
-;  Outputs:		D0 - zero if valid ROM disk header, else non-zero
-;				ccr.z - bne if invalid header
-;  Destroys:	D0, D1, A0, A3, A4
-;  Calls:		none
-;  Called by:	EDiskOpen
-;
-;  Function:	Checks the EDisk header to see if it exists (no bus error),
-;				and has a valid signature.  If it is valid, compares it
-;				against all other ROM Disks found, and if it's header block
-;				is not identical to any other ROM Disk (in case address
-;				wrap around causes repeated images), returns a result
-;				indicating that it should be created.
-;
-;_______________________________________________________________________
-
-		with	EDiskHeader
-CheckForRomDisk
-		move.w	sr,-(sp)				; save old interrupt mask
-		ori.w	#HiIntMask,sr			; disable interrupts (stealing BusErrVct)
-		move.l	BusErrVct,-(sp)			; save old bus error vector
-		lea		@NotFound,a0			; new handler address
-		move.l	a0,BusErrVct			; setup bus error handler
-		movea.l	sp,a4					; mark the stack
-
-		lea		HeaderTemplate,a3		; point to expected values
-		lea		HdrBlockSize(a2),a0		; point to header data
-		moveq.l	#(HdrDeviceSize-HdrBlockSize)/4-1,d0	; loop counter
-@SigCmpLoop
-		cmpm.l	(a0)+,(a3)+				; compare the values
-		dbne	d0,@SigCmpLoop			; compare the blocks
-@NotFound
-		movea.l	a4,sp					; pop stack in case of bus error
-		move.l	(sp)+,BusErrVct			; restore bus error vector
-		move.w	(sp)+,sr				; restore interrupt mask
-		addq.w	#1,d0					; see if we had a match
-		bne.s	@Done					; exit if not
-
-;	valid header found, now let's see if it's unique.
-
-		move.l	d7,d1					; get driver ref num
-		swap	d1						; d1.low := driver ref num
-		lea		DrvQHdr+QHead-QLink,a0	; point to the drive queue head
-@CheckNeXTDrive
-		move.l	QLink(a0),d0			; check next drive queue element
-		beq.s	@Done					; if not found, it's unique (d0=0)
-		movea.l	d0,a0					; a0 := drive queue element
-		cmp.w	dQRefNum(a0),d1			; is this one of ours
-		bne.s	@CheckNeXTDrive			; if not, check the NeXT one	
-		cmpi.b	#romDiskType,\			; it's one of ours
-				DriveInfo+3(a0)			; is it a ROM disk
-		bne.s	@CheckNeXTDrive			; if not, check the NeXT one	
-
-
-		moveq.l	#EDiskHeaderSize/4-1,d0	; compare the entire header
-		movea.l	a2,a3					; point to our header
-		movea.l	HeaderInfoPtr(a0),a4	; point to existing drive's header
-@HdrCmpLoop
-		cmpm.l	(a3)+,(a4)+				; compare the values
-		dbne	d0,@HdrCmpLoop			; compare the blocks
-		bne.s	@CheckNeXTDrive			; if not the same, check the NeXT one	
-
-@Done	tst.l	d0						; set ccr based on D0
-		rts								; all done
-		endwith
 		title	'EDisk Driver - Close processing'
 
 ;_______________________________________________________________________
@@ -667,7 +515,7 @@ EDiskPrime								; all regs saved by Device Manager
 
 @ReadWrite
 		move.l	d1,d0					; get the byte count
-		_BlockMove						; move the data
+		_BlockMoveData					; move the data
 		move.l	d1,d4					; indicate all bytes moved
 		bra.s	@PrimeDone				; return with success
 		title	'EDisk Driver - Read processing'
@@ -857,11 +705,10 @@ HandleControlStatus
 
 		swap	d0						; get offset of routine
 		pea		(a2,d0.w)				; push address of the routine
-		bra.w	FindDQE					; find the DQE before calling routine
+		bra		FindDQE					; find the DQE before calling routine
 
 @exit	movea.l	dCtlStorage(a1),a2		; a2 := pointer to EDiskVars
-		addq.l	#4,sp					;											<SM4>
-		bra.w	EDiskDone2				; return through EDiskDone2					<SM4>
+		rts
 
 
 ctlKillIO
@@ -875,17 +722,15 @@ ctlEject
 		move.l	d1,d0					; get found status, ignore offline
 		bne.s	@EjectErr				; return error if not found
 		bclr.b	#MountedFlag,Flags(a3)	; mark it as not mounted
-		move.b	DiskInPlace(a3),d0		; see if any disk
-		ble.s	@EjectDone				; if no disk, just ignore it
-
-		subq.b	#8,d0					; see if ejectable
+		cmp.b	#8,-3(a3)
 		beq.s	@EjectDone				; if not ejectable, just ignore it
 
 ;	if disk in place was $48 (non-ejectable, but call driver anyway) we will force a
 ;	disk in place event to be posted by the polling task, to re-mount the volume.
 
 		moveq.l	#EjectEDisk,d0			; hardware dependent function code
-		bsr.w	HWDependent				; start the eject, update DiskInPlace
+		bsr		HWDependent				; start the eject, update DiskInPlace
+		bset.b	#5,dCtlFlags(a1)		; flag DNeedTime
 @EjectDone
 		moveq.l	#noErr,d0				; return with success
 @EjectErr
@@ -958,12 +803,10 @@ ctlFormat
 		cmpa.l	a1,a4					; see if all blocks cleared
 		bhi.s	@NextBlock				; loop through all of the blocks
 @done	move.l	d0,d2					; save error code
-	IF newEdiskProt THEN
 		; d1 := byte count
 		; a0 := source address
 		; a3 := ptr to drive queue element
 		movem.l	(sp)+,a0/d1				; restore size, length for disabling the disk
-	ENDIF
 		moveq.l	#DisableEDiskWrites,d0	; hardware dependent function code
 		bsr.w	HWDependent				; disable writing to the EDisk
 		move.l	d2,d0					; restore error code
@@ -1026,7 +869,7 @@ statDrvSts
 		clr.w	(a1)+					; return zero for track
 		lea		WriteProtected(a3),a0	; start copy with write protected flag
 		moveq.l	#(DQE-WriteProtected)+dQDrvSz2+2,d0	; number of bytes to copy
-		_BlockMove						; copy the drive info, and return noErr
+		_BlockMoveData					; copy the drive info, and return noErr
 @Done	rts								; all done
 
 
@@ -1070,7 +913,7 @@ IconCommon
 		lea		IconBuffer(a2),a1		; get buffer address (dest address)
 		move.l	a1,(a4)					; return buffer pointer
 		move.l	#IconAndMaskSize,d0		; setup byte count for icon and mask
-		_BlockMove						; copy the icon into the buffer
+		_BlockMoveData					; copy the icon into the buffer
 
 ;	copy the "Where String" into the buffer
 
@@ -1085,9 +928,39 @@ IconCommon
 		bls.s	@CopyString				; if in range just copy it
 		moveq.l	#WhereStringSize,d0		; otherwise truncate to max size
 @CopyString
-		_BlockMove						; copy the string into the buffer
+		_BlockMoveData					; copy the string into the buffer
 
 @Done	rts								; all done (d0 is noErr from _BlockMove)
+		title	'EDisk Driver - ctlPeriodic'
+
+;_______________________________________________________________________
+;
+;  Routine:		ctlPeriodic
+;
+;_______________________________________________________________________
+
+ctlPeriodic
+		bclr.b	#5,dCtlFlags(a1)		; test & clear DNeedTime
+		bz.s	@return					; probable spurious call?
+
+		move	dCtlRefNum(a1),d1		; search the File Manager's
+		lea		DrvQHdr+QHead,a3		; drive queue for this EDisk
+@search	move.l	(a3),d2
+		beq.s	@return					; (end of queue)
+		move.l	d2,a3
+		cmp		dQRefNum(a3),d1
+		bne.s	@search
+		btst.b	#0,-12(a3)				; crazy meddling with
+		bne.s	@search					; private structures!!
+		bsr		Mount
+		btst.b	#0,-12(a3)
+		bne.s	@search
+		bset.b	#5, dCtlFlags(a1)		; re-flag DNeedTime
+		bra.s	@search
+
+@return	moveq.l	#0,d0
+		rts
+
 		title	'EDisk Driver - FindDQE - Find Drive Queue Element'
 
 ;_______________________________________________________________________
@@ -1111,8 +984,8 @@ IconCommon
 
 FindDQE									; find the drive queue element
 		movea.l	dCtlStorage(a1),a2		; a2 := pointer to EDiskVars
-		addq.b	#1,Active(a2)			; request in progress, exclude polling	<1.2>
 		jsr		FindDqePatch(a2)		; allow patching here
+		lea		csParam(a0),a4			; point to param area
 		lea		DrvQHdr+QHead-QLink,a3	; get the drive queue head
 		move.w	IODrvNum(a0),d2			; d2 := drive number
 		bpl.s	@search					; start searching if drivenum is positive
@@ -1131,29 +1004,12 @@ FindDQE									; find the drive queue element
 		bne.s	@search					; if not for our driver
 
 		moveq.l	#noErr,d1				; indicate drive is found
-
-;	now check to see if it is really present (onLine)
-
-		tst.b	DiskInPlace(a3)			; is there a disk
-		ble.s	@offLine				; return off line error if not
-
-		moveq.l	#CheckEDiskInserted,d0	; hardware dependent function code
-		bsr.s	HWDependent				; see if disk is inserted
-		beq.s	@offLine				; if not, return offline error
-		moveq.l	#noErr,d0				; indicate no disk-in-place
-
-@Done	lea		csParam(a0),a4			; point to param area
 		rts								; return with success (d0 = 0 = noErr)
 
-@offLine
-		moveq.l	#offLinErr,d0			; indicate no disk-in-place
-		bra.s	@Done					; return with error
-
-
 @notFound
 		moveq.l	#NSDrvErr,d1			; indicate no such drive error
 		moveq.l	#NSDrvErr,d0			; indicate no such drive error
-		bra.s	@Done					; return with error
+		rts
 		title	'EDisk Driver - EDiskDone - Command Completion'
 
 ;_______________________________________________________________________
@@ -1171,8 +1027,6 @@ FindDQE									; find the drive queue element
 ;_______________________________________________________________________
 
 EDiskDone
-		subq.b	#1,Active(a2)			; request complete, allow polling		<1.2>
-EDiskDone2								;										<H6><SM4>
 		movea.l	DCEpointer(a2),a1		; setup DCE pointer in a1 for JIODone
 		btst.b	#NoQueueBit-8,(sp)+		; check for immediate request			<1.2>
 		bne.s	@immed					; if immediate, don't use jIODone		<1.2>
@@ -1201,54 +1055,10 @@ HWDependent
 		move.l	HWDepProcPtr(a3),-(sp)	; get the handler address
 		rts								; jump to it
 
-RAMDiskHandler
-		move.b	@decode(pc,d0.w),d0		; get the routine offset
-		jmp		@decode(pc,d0.w)		; jump to it
-@decode
-		assert	(*-@decode)=CheckEDiskInserted
-		dc.b	@checkInserted-@decode
-		assert	(*-@decode)=CheckEDiskReadOnly
-		dc.b	@checkReadOnly-@decode
-		assert	(*-@decode)=EnableEDiskWrites
-		dc.b	@enableWrites-@decode
-		assert	(*-@decode)=DisableEDiskWrites
-		dc.b	@disableWrites-@decode
-		assert	(*-@decode)=EjectEDisk
-		dc.b	@eject-@decode
-		align	2
-
-@checkInserted
-		moveq.l	#-1,d0					; always inserted
-		rts
-@checkReadOnly
-		moveq.l	#0,d0					; never read only
-@enableWrites
-		movem.l	a0-a1/d1,-(sp)			; save registers								<T5>
-		moveq	#8,d0					; _EDiskProtect selector						 |
-		move.l	CheckSumPtr(a3),a0		; put base addr of ram disk in a0				 v
-		move.l	#0,a1					; indicate we want to unprotect edisk
-		_HwPriv							; unprotect the disk
-		movem.l	(sp)+,a0-a1/d1
-		bclr	#EDiskProtect,Flags(a3)	; indicate the disk is not protected
-		rts
-@disableWrites
-		movem.l	a0-a1/d1,-(sp)			; save registers
-		moveq	#8,d0					; _EDiskProtect selector
-		move.l	CheckSumPtr(a3),a0		; put base addr of ram disk in a0
-		move.l	#1,a1					; indicate we want to protect edisk
-		_HwPriv							; write-protect the disk						 ^
-		movem.l	(sp)+,a0-a1/d1			; restore registers								 |
-		bset	#EDiskProtect,Flags(a3)	; indicate the disk is protected
-		rts								;												<T5>
-@eject	clr.b	DiskInPlace(a3)			; mark it as offline
-@done	rts
-
-
-	IF newEdiskProt THEN
 ;—————————————————————————
 ; PowerPC Edisk Routines
 ;—————————————————————————
-RAMDiskHandlerPPC
+RAMDiskHandler
 		move.b	@decode(pc,d0.w),d0		; get the routine offset
 		jmp		@decode(pc,d0.w)		; jump to it
 @decode
@@ -1269,6 +1079,7 @@ RAMDiskHandlerPPC
 		rts
 @checkReadOnly
 		moveq.l	#0,d0					; never read only
+		rts
 @enableWrites
 	; a3 = ptr to driveQElement
 	; d1 = transfer length
@@ -1305,36 +1116,7 @@ RAMDiskHandlerPPC
 		bset	#EDiskProtect,Flags(a3)	; indicate the disk is protected
 		rts								;
 
-@eject	clr.b	DiskInPlace(a3)			; mark it as offline
-@done	rts
-
-	ENDIF
-
-ROMDiskHandler
-		move.b	@decode(pc,d0.w),d0		; get the routine offset
-		jmp		@decode(pc,d0.w)		; jump to it
-@decode
-		assert	(*-@decode)=CheckEDiskInserted
-		dc.b	@checkInserted-@decode
-		assert	(*-@decode)=CheckEDiskReadOnly
-		dc.b	@checkReadOnly-@decode
-		assert	(*-@decode)=EnableEDiskWrites
-		dc.b	@enableWrites-@decode
-		assert	(*-@decode)=DisableEDiskWrites
-		dc.b	@disableWrites-@decode
-		assert	(*-@decode)=EjectEDisk
-		dc.b	@eject-@decode
-		align	2
-
-@checkInserted
-@checkReadOnly
-		moveq.l	#-1,d0					; always inserted, always read only
-@enableWrites
-@disableWrites
-		rts
-
-@eject	clr.b	DiskInPlace(a3)			; mark it as offline
-@done	rts
+@eject	rts
 		title	'EDisk Driver - EDiskPollTask - Drive Polling Task'
 
 ;_______________________________________________________________________
@@ -1352,98 +1134,9 @@ ROMDiskHandler
 ;_______________________________________________________________________
 
 EDiskPollTask							; a0-a3/d0-d3 saved by int handler
-		lea		EDiskVars-VTask(a0),a2	; a2 := pointer to EDiskVars
-		lea		DrvQHdr+QHead-QLink,a3	; get the drive queue head
-		movea.l	DCEpointer(a2),a1		; get DCE pointer
-		move.w	dCtlRefNum(a1),d3		; d3 := driver refnum
-
-		tst.b	Active(a2)				; see if request in progress
-		beq.s	@next					; if not, start searching the drive queue
-
-		addq.w	#1,VTask+vblCount(a2)	; if active, try again real soon
-		rts								; return
-
-@search	movea.l	d2,a3					; a3 := DriveQElement
-		cmp.w	dQRefNum(a3),d3			; see if we are the driver
-		beq.s	@CheckDrive				; check our drives
-@next	move.l	QLink(a3),d2			; check next drive queue element
-		bne.s	@search					; search until end of drive queue
-
-		move.w	#EDiskPollRate,VTask+vblCount(a2)	; re-initialize the VBL count
-		rts								; return
-
-
-@CheckDrive
-		moveq.l	#CheckEDiskInserted,d0	; hardware dependent function code
-		bsr.w	HWDependent				; see if disk is inserted
-		addq.w	#1,d0					; ccr.x := 1 if EDisk inserted
-		move.b	InsertedStatus(a3),d1	; prepare to shift in new inserted status
-		addx.b	d1,d1					; shift in new inserted status
-		move.b	d1,InsertedStatus(a3)	; update inserted status
-		moveq.l	#InsertedMask,d0		; prepare to de-bounce, and test inserted
-
-		and.b	d0,d1					; see if offline, without bounce
-		bne.s	@CheckOnLine			; if not offline, check online or bounce
-
-@OffLine
-		tst.b	DiskInPlace(a3)			; check online status
-		bpl.s	@next					; if not ejecting, do nothing
-		clr.b	DiskInPlace(a3)			; now mark it offline (ejected)
-		bra.s	@next					; eject complete, check next drive
-
-
-@CheckOnLine
-		cmp.b	d0,d1					; see if online, without bounce
-		bne.s	@next					; if bouncing, ignore it until it stops
-		tst.b	DiskInPlace(a3)			; check online status
-		bmi.s	@next					; if ejecting, do nothing
-		beq.s	@OnLine					; if was offline, and just went online
-
-@mount	btst.b	#MountedFlag,Flags(a3)	; see if it was mounted
-		bne.s	@next					; if already mounted, don't do it again
-		moveq.l	#DiskInsertEvt,d0		; disk inserted event (zero high word)
-		movea.l	d0,a0					; disk inserted event passed in a0
-		move.w	DQDrive(a3),d0			; disk drive number in low word
-		_PostEvent						; post the disk inserted event
-		bne.s	@next					; if error, don't mark as mounted
-		bset.b	#MountedFlag,Flags(a3)	; mark it as mounted
-@toNext	bra.s	@next					; check the next drive
-
-@OnLine
-@SetupDriveInfo
 		move.b	DiskInPlaceInit(a3),\
 				DiskInPlace(a3)			; mark it as inserted
 		clr.b	WriteProtected(a3)		; mark it as writeable (assume RAM)
-		move.l	HeaderInfoPtr(a3),d0	; see if it supports headers
-		beq.s	@SetupRAMDisk			; if no headers, must be a RAM based disk
-
-		with	EDiskHeader
-		movea.l	d0,a0					; a0 points to device header
-		move.l	HdrFormatTime(a0),\
-				FormatTime(a3)			; get the unique ID from the header
-		move.l	HdrFormatTicks(a0),\
-				FormatTicks(a3)			; get the unique ID from the header
-
-;	see if device is ROM or RAM
-
-		moveq.l	#CheckEDiskReadOnly,d0	; hardware dependent function code
-		bsr.w	HWDependent				; see if disk is read only
-		move.b	d0,WriteProtected(a3)	; setup the RAM=$00 / ROM=$FF flag
-		bne.s	@SetupROMDisk			; if ROM disk, all info comes from header
-
-		tst.l	SLIMRegPtr(a3)			; see if this is a SLIM (which needs to be sized)
-		beq.s	@SetupRAMDisk			; if not, base and end must already be valid
-
-		moveq.l	#EnableEDiskWrites,d0	; hardware dependent function code
-		bsr.w	HWDependent				; allow writes while sizing
-		bsr.w	ComputeSLIMSize			; see how big the SLIM card is
-		add.l	a0,d0					; compute end ptr
-		move.l	d0,DataEndPtr(a3)		; setup pointer to end of device data
-		adda.w	#EDiskHeaderSize,a0		; point past the header
-		move.l	a0,CheckSumPtr(a3)		; checksums start just after the header
-		moveq.l	#DisableEDiskWrites,d0	; hardware dependent function code
-		bsr.w	HWDependent				; no writes now
-		endwith
 
 @SetupRAMDisk
 		movem.l	CheckSumPtr(a3),d0/d1/d2; get checksum/start/end ptrs
@@ -1475,133 +1168,17 @@ EDiskPollTask							; a0-a3/d0-d3 saved by int handler
 @DriveSizeOK
 		rol.l	#16-9,d2				; convert to blocks, and swap halves
 		move.l	d2,dqDrvSz(a3)			; fill in the drive size (in blocks)
-		bra.w	@mount					; now mount the drive
 
+Mount	btst.b	#MountedFlag,Flags(a3)	; see if it was mounted
+		bne.s	@done					; if already mounted, don't do it again
+		moveq.l	#DiskInsertEvt,d0		; disk inserted event (zero high word)
+		movea.l	d0,a0					; disk inserted event passed in a0
+		move.w	DQDrive(a3),d0			; disk drive number in low word
+		_PostEvent						; post the disk inserted event
+		bne.s	@done					; if error, don't mark as mounted
+		bset.b	#MountedFlag,Flags(a3)	; mark it as mounted
 
-@SetupROMDisk
-		move.l	a0,d0					; remember header address
-		lea		HeaderTemplate,a1		; point to expected values
-		with	EDiskHeader
-		lea		HdrBlockSize(a0),a0		; point to header data
-		moveq.l	#(HdrDeviceSize-HdrBlockSize)/4-1,d2	; loop counter
-@cmpLoop
-		cmpm.l	(a0)+,(a1)+				; compare the values
-		dbne	d2,@cmpLoop				; compare the blocks
-		beq.s	@SigOK					; get header info if signature valid
-
-		move.l	d0,d1					; start ptr is header ptr
-		move.l	d1,d2					; end ptr is start ptr
-		bra.s	@UpdateBasePtrs			; create an empty ROM disk (pretty useless)
-
-@SigOK	move.l	(a0)+,d0				; get device size
-		addq.w	#HdrCheckSumOff-HdrFormatTime,a0	; point to checksum offset in header
-		lea		CheckSumPtr(a3),a1		; point to checksum ptr in drive info
-
-		moveq.l	#(HdrMediaIconOff-\
-				HdrCheckSumOff)/4-1,d2	; loop for next 3 fields
-
-		tst.l	SLIMRegPtr(a3)			; see if this is a SLIM (which is ejectable)
-		bne.s	@offsetLoop				; if ejectable, don't get the icon info
-
-		moveq.l	#(HdrDriveInfo-\
-				HdrCheckSumOff)/4-1,d2	; loop for next 6 fields
-
-		move.l	HdrDriveInfo-HdrCheckSumOff(a0),d1	; get drive info
-		beq.s	@offsetLoop				; if none specified, use default
-		move.l	d1,DriveInfo(a3)		; setup new drive info
-@offsetLoop
-		addq.l	#4,a1					; leave pointer alone, assume default
-		move.l	(a0)+,d1				; get the offset
-		beq.s	@nextOffset				; if none, ignore it
-		cmp.l	d0,d1					; see if offset is reasonable
-		bhi.s	@nextOffset				; if offset past end of device, ignore it
-		add.l	HeaderInfoPtr(a3),d1	; add device base to offset
-		move.l	d1,-4(a1)				; update the pointer
-@nextOffset
-		dbra	d2,@offsetLoop			; loop through all of the fields
-
-		movem.l	DataStartPtr(a3),d1/d2	; get start/end ptrs
-		bra.s	@SetupDriveSize			; setup the drive queue size info
-		endwith
-		title	'EDisk Driver - ComputeSLIMSize - Get Signature Information'
-
-;_______________________________________________________________________
-;
-;  Routine:		ComputeSLIMSize
-;  Inputs:		A0 - pointer to base of SLIM address space for this card
-;  Outputs:		D0 - Device Size in bytes
-;  Destroys:	A1, D1, D2
-;  Calls:		none
-;  Called by:	
-;
-;  Function:	Returns the device size for the specified SLIM card.
-;
-;_______________________________________________________________________
-
-SegmentSize	equ	512*1024				; slims have up to 4 512K byte segments
-
-ComputeSLIMSize
-		adda.l	#4*SegmentSize,a0		; point past end of last segment
-		movea.l	a0,a1					; save copy of end address
-		moveq.l	#%0000,d0				; assume all 4 segments are missing
-		move.l	#'Gary',d1				; rotating pattern
-		moveq.l	#4-1,d2					; loop counter
-@FillLoop
-		suba.l	#SegmentSize,a0			; point to base of previous segment
-		move.l	(a0),-(sp)				; save the old contents
-		rol.l	#8,d1					; change the pattern
-		move.l	d1,(a0)					; write to the ram
-		cmp.l	(a0),d1					; see if we can read it back
-		bne.s	@NotRAM1				; if not, it's not RAM
-		not.l	d1						; complement the pattern
-		move.l	d1,(a0)					; write to the ram
-		cmp.l	(a0),d1					; see if we can read it back
-		bne.s	@NotRAM2				; if not, it's not RAM
-		bset.l	d2,d0					; indicate that the segment is RAM
-@NotRAM2
-		not.l	d1						; restore pattern
-@NotRAM1
-		dbra	d2,@FillLoop			; loop through all 4 segments
-
-		not.l	d1						; get expected pattern
-		moveq.l	#4-1,d2					; loop counter
-@CheckLoop
-		suba.l	#SegmentSize,a1			; point to base of previous segment
-		rol.l	#8,d1					; change the pattern
-		cmp.l	(a1),d1					; see if we can read it back
-		beq.s	@IsRAM					; if so, it's RAM that didn't wrap around
-		bclr.l	d2,d0					; indicate that the segment isn't RAM
-@IsRAM
-		dbra	d2,@CheckLoop			; loop through all 4 segments
-
-		moveq.l	#4-1,d2					; loop counter
-@RestoreLoop
-		move.l	(sp)+,(a1)				; restore the old contents
-		adda.l	#SegmentSize,a1			; point to base of next segment
-		dbra	d2,@RestoreLoop			; loop through all 4 segments
-
-		move.b	@SizesTable(d0.w),d0	; encode the segment present bits
-		moveq.l	#19,d1					; shift amount
-		lsl.l	d1,d0					; convert segment count to byte count
-		rts								; all done
-
-@SizesTable	
-		dc.b	0						; 0000 - RAM, 0.0MB, 0 segments
-		dc.b	1						; 0001 - RAM, 0.5MB, 1 segment
-		dc.b	0						; 0010 - RAM, illegal configuration
-		dc.b	2						; 0011 - RAM, 1.0MB, 2 segments
-		dc.b	0						; 0100 - RAM, illegal configuration
-		dc.b	0						; 0101 - RAM, illegal configuration
-		dc.b	0						; 0110 - RAM, illegal configuration
-		dc.b	3						; 0111 - RAM, 1.5MB, 3 segments
-		dc.b	0						; 1000 - RAM, illegal configuration
-		dc.b	0						; 1001 - RAM, illegal configuration
-		dc.b	0						; 1010 - RAM, illegal configuration
-		dc.b	0						; 1011 - RAM, illegal configuration
-		dc.b	0						; 1100 - RAM, illegal configuration
-		dc.b	0						; 1101 - RAM, illegal configuration
-		dc.b	0						; 1110 - RAM, illegal configuration
-		dc.b	4						; 1111 - RAM, 2.0MB, 4 segments
+@done	rts
 		title	'EDisk Driver - CreateEDiskHeader - Create Header Information'
 
 ;_______________________________________________________________________
@@ -1671,29 +1248,12 @@ HeaderTemplate
 
 		string	pascal					; name strings have leading length byte
 
-	IF not padForOverPatch THEN			; removing string to adjust for mods	<H1>
-		align	2
-SlimDrive0Name
-		dc.b	'Upper SLIM Drive'
-	ENDIF
-
-		align	2
-SlimDrive1Name
-		dc.b	'Lower SLIM Drive'
-
-		align	2
-ROMDiskName
-		dc.b	'Internal ROM Disk'
-
 		align	2
 RAMDiskName
 		dc.b	'Internal RAM Disk'
 
 		align	2
-		title	'EDisk Driver - RAM / ROM Disk Icons'
-
-ROMDiskMediaIcon
-ROMDiskDriveIcon
+		title	'EDisk Driver - RAM Disk Icons'
 
 RAMDiskMediaIcon
 RAMDiskDriveIcon
diff --git a/Interfaces/AIncludes/GestaltEqu.a b/Interfaces/AIncludes/GestaltEqu.a
--- a/Interfaces/AIncludes/GestaltEqu.a
+++ b/Interfaces/AIncludes/GestaltEqu.a
@@ -606,4 +606,14 @@ gestaltInternalDisplay		EQU		'idsp'			; slot number of internal display location
 	
 	
 	
+gestaltPowerPCProcessorFeatures	EQU		'ppcf'				; Optional PowerPC processor features 
+gestaltPowerPCHasGraphicsInstructions EQU 0					; has fres, frsqrte, and fsel instructions 
+gestaltPowerPCHasSTFIWXInstruction EQU	1					; has stfiwx instruction 
+gestaltPowerPCHasSquareRootInstructions EQU 2				; has fsqrt and fsqrts instructions 
+gestaltPowerPCHasDCBAInstruction EQU	3					; has dcba instruction 
+gestaltPowerPCHasVectorInstructions EQU	4					; has vector instructions 
+gestaltPowerPCHasDataStreams	EQU		5					; has dst, dstt, dstst, dss, and dssall instructions 
+
+
+
 	ENDIF	; ...already included 
\ No newline at end of file
diff --git a/Interfaces/AIncludes/Processes.a b/Interfaces/AIncludes/Processes.a
--- a/Interfaces/AIncludes/Processes.a
+++ b/Interfaces/AIncludes/Processes.a
@@ -202,7 +202,8 @@ processAppSpec			EQU			56
 
 	MACRO
 	_GetFrontProcess
-	PEA			$FFFFFFFF
+	MOVEQ.L		#$FFFFFFFF,D0
+	MOVE.L		D0,-(SP)
 	MOVE.W		#$39,-(SP)
 	_OSDispatch
 	ENDM
diff --git a/Interfaces/AIncludes/SysEqu.a b/Interfaces/AIncludes/SysEqu.a
--- a/Interfaces/AIncludes/SysEqu.a
+++ b/Interfaces/AIncludes/SysEqu.a
@@ -674,7 +674,7 @@ btQType			EQU			21						; B*Tree Manager
 ; Device Control Entry Definition
 ;dCtlEntrySize used to be only 40 bytes!
 
-dCtlEntrySize 	EQU 		$34   					; length of a DCE [52 bytes]
+dCtlEntrySize 	EQU 		$38   					; length of a DCE [56 bytes]
 dCtlDriver		EQU 		0 						; driver [handle]
 dCtlFlags 		EQU 		4 						; flags [word]
 dCtlQueue 		EQU 		6 						; queue header
diff --git a/Interfaces/CIncludes/Events.h b/Interfaces/CIncludes/Events.h
--- a/Interfaces/CIncludes/Events.h
+++ b/Interfaces/CIncludes/Events.h
@@ -56,6 +56,8 @@ Created: Saturday, July 27, 1991 at 3:22 PM
 #include "ROMFastTraps.h"
 #endif
 
+typedef UInt16                          EventKind; /* from UI 3.4 */
+typedef UInt16                          EventMask;
 enum {
 
  nullEvent = 0,
@@ -81,6 +83,7 @@ enum {
  highLevelEventMask = 1024,
  osMask = -32768
 };
+typedef UInt16                          EventModifiers;
 enum {
  everyEvent = -1,
 
@@ -124,11 +127,11 @@ enum {
 };
 
 struct EventRecord {
- short what;
- long message;
- long when;
- Point where;
- short modifiers;
+  EventKind           what;
+  UInt32              message;
+  UInt32              when;
+  Point               where;
+  EventModifiers      modifiers;
 };
 
 typedef struct EventRecord EventRecord;
diff --git a/Interfaces/CIncludes/Files.h b/Interfaces/CIncludes/Files.h
--- a/Interfaces/CIncludes/Files.h
+++ b/Interfaces/CIncludes/Files.h
@@ -856,168 +856,168 @@ typedef DrvQEl *DrvQElPtr;
 #ifdef __cplusplus
 extern "C" {
 #endif
-pascal OSErr PBOpen(ParmBlkPtr paramBlock,Boolean async); 
+#define PBOpen(pb, async) ((async) ? PBOpenAsync(pb) : PBOpenSync(pb)) 
 #pragma parameter __D0 PBOpenSync(__A0)
 pascal OSErr PBOpenSync(ParmBlkPtr paramBlock)
  = 0xA000; 
 #pragma parameter __D0 PBOpenAsync(__A0)
 pascal OSErr PBOpenAsync(ParmBlkPtr paramBlock)
  = 0xA400; 
-pascal OSErr PBClose(ParmBlkPtr paramBlock,Boolean async); 
+#define PBClose(pb, async) ((async) ? PBCloseAsync(pb) : PBCloseSync(pb)) 
 #pragma parameter __D0 PBCloseSync(__A0)
 pascal OSErr PBCloseSync(ParmBlkPtr paramBlock)
  = 0xA001; 
 #pragma parameter __D0 PBCloseAsync(__A0)
 pascal OSErr PBCloseAsync(ParmBlkPtr paramBlock)
  = 0xA401; 
-pascal OSErr PBRead(ParmBlkPtr paramBlock,Boolean async); 
+#define PBRead(pb, async) ((async) ? PBReadAsync(pb) : PBReadSync(pb)) 
 #pragma parameter __D0 PBReadSync(__A0)
 pascal OSErr PBReadSync(ParmBlkPtr paramBlock)
  = 0xA002; 
 #pragma parameter __D0 PBReadAsync(__A0)
 pascal OSErr PBReadAsync(ParmBlkPtr paramBlock)
  = 0xA402; 
-pascal OSErr PBWrite(ParmBlkPtr paramBlock,Boolean async); 
+#define PBWrite(pb, async) ((async) ? PBWriteAsync(pb) : PBWriteSync(pb)) 
 #pragma parameter __D0 PBWriteSync(__A0)
 pascal OSErr PBWriteSync(ParmBlkPtr paramBlock)
  = 0xA003; 
 #pragma parameter __D0 PBWriteAsync(__A0)
 pascal OSErr PBWriteAsync(ParmBlkPtr paramBlock)
  = 0xA403; 
-pascal OSErr PBGetVInfo(ParmBlkPtr paramBlock,Boolean async); 
+#define PBGetVInfo(pb, async) ((async) ? PBGetVInfoAsync(pb) : PBGetVInfoSync(pb)) 
 #pragma parameter __D0 PBGetVInfoSync(__A0)
 pascal OSErr PBGetVInfoSync(ParmBlkPtr paramBlock)
  = 0xA007; 
 #pragma parameter __D0 PBGetVInfoAsync(__A0)
 pascal OSErr PBGetVInfoAsync(ParmBlkPtr paramBlock)
  = 0xA407; 
-pascal OSErr PBGetVol(ParmBlkPtr paramBlock,Boolean async); 
+#define PBGetVol(pb, async) ((async) ? PBGetVolAsync(pb) : PBGetVolSync(pb)) 
 #pragma parameter __D0 PBGetVolSync(__A0)
 pascal OSErr PBGetVolSync(ParmBlkPtr paramBlock)
  = 0xA014; 
 #pragma parameter __D0 PBGetVolAsync(__A0)
 pascal OSErr PBGetVolAsync(ParmBlkPtr paramBlock)
  = 0xA414; 
-pascal OSErr PBSetVol(ParmBlkPtr paramBlock,Boolean async); 
+#define PBSetVol(pb, async) ((async) ? PBSetVolAsync(pb) : PBSetVolSync(pb)) 
 #pragma parameter __D0 PBSetVolSync(__A0)
 pascal OSErr PBSetVolSync(ParmBlkPtr paramBlock)
  = 0xA015; 
 #pragma parameter __D0 PBSetVolAsync(__A0)
 pascal OSErr PBSetVolAsync(ParmBlkPtr paramBlock)
  = 0xA415; 
-pascal OSErr PBFlushVol(ParmBlkPtr paramBlock,Boolean async); 
+#define PBFlushVol(pb, async) ((async) ? PBFlushVolAsync(pb) : PBFlushVolSync(pb)) 
 #pragma parameter __D0 PBFlushVolSync(__A0)
 pascal OSErr PBFlushVolSync(ParmBlkPtr paramBlock)
  = 0xA013; 
 #pragma parameter __D0 PBFlushVolAsync(__A0)
 pascal OSErr PBFlushVolAsync(ParmBlkPtr paramBlock)
  = 0xA413; 
-pascal OSErr PBCreate(ParmBlkPtr paramBlock,Boolean async); 
+#define PBCreate(pb, async) ((async) ? PBCreateAsync(pb) : PBCreateSync(pb)) 
 #pragma parameter __D0 PBCreateSync(__A0)
 pascal OSErr PBCreateSync(ParmBlkPtr paramBlock)
  = 0xA008; 
 #pragma parameter __D0 PBCreateAsync(__A0)
 pascal OSErr PBCreateAsync(ParmBlkPtr paramBlock)
  = 0xA408; 
-pascal OSErr PBDelete(ParmBlkPtr paramBlock,Boolean async); 
+#define PBDelete(pb, async) ((async) ? PBDeleteAsync(pb) : PBDeleteSync(pb)) 
 #pragma parameter __D0 PBDeleteSync(__A0)
 pascal OSErr PBDeleteSync(ParmBlkPtr paramBlock)
  = 0xA009; 
 #pragma parameter __D0 PBDeleteAsync(__A0)
 pascal OSErr PBDeleteAsync(ParmBlkPtr paramBlock)
  = 0xA409; 
-pascal OSErr PBOpenDF(ParmBlkPtr paramBlock,Boolean async); 
+#define PBOpenDF(pb, async) ((async) ? PBOpenDFAsync(pb) : PBOpenDFSync(pb)) 
 #pragma parameter __D0 PBOpenDFSync(__A0)
 pascal OSErr PBOpenDFSync(ParmBlkPtr paramBlock)
  = {0x701A,0xA060}; 
 #pragma parameter __D0 PBOpenDFAsync(__A0)
 pascal OSErr PBOpenDFAsync(ParmBlkPtr paramBlock)
  = {0x701A,0xA460}; 
-pascal OSErr PBOpenRF(ParmBlkPtr paramBlock,Boolean async); 
+#define PBOpenRF(pb, async) ((async) ? PBOpenRFAsync(pb) : PBOpenRFSync(pb)) 
 #pragma parameter __D0 PBOpenRFSync(__A0)
 pascal OSErr PBOpenRFSync(ParmBlkPtr paramBlock)
  = 0xA00A; 
 #pragma parameter __D0 PBOpenRFAsync(__A0)
 pascal OSErr PBOpenRFAsync(ParmBlkPtr paramBlock)
  = 0xA40A; 
-pascal OSErr PBRename(ParmBlkPtr paramBlock,Boolean async); 
+#define PBRename(pb, async) ((async) ? PBRenameAsync(pb) : PBRenameSync(pb)) 
 #pragma parameter __D0 PBRenameSync(__A0)
 pascal OSErr PBRenameSync(ParmBlkPtr paramBlock)
  = 0xA00B; 
 #pragma parameter __D0 PBRenameAsync(__A0)
 pascal OSErr PBRenameAsync(ParmBlkPtr paramBlock)
  = 0xA40B; 
-pascal OSErr PBGetFInfo(ParmBlkPtr paramBlock,Boolean async); 
+#define PBGetFInfo(pb, async) ((async) ? PBGetFInfoAsync(pb) : PBGetFInfoSync(pb)) 
 #pragma parameter __D0 PBGetFInfoSync(__A0)
 pascal OSErr PBGetFInfoSync(ParmBlkPtr paramBlock)
  = 0xA00C; 
 #pragma parameter __D0 PBGetFInfoAsync(__A0)
 pascal OSErr PBGetFInfoAsync(ParmBlkPtr paramBlock)
  = 0xA40C; 
-pascal OSErr PBSetFInfo(ParmBlkPtr paramBlock,Boolean async); 
+#define PBSetFInfo(pb, async) ((async) ? PBSetFInfoAsync(pb) : PBSetFInfoSync(pb)) 
 #pragma parameter __D0 PBSetFInfoSync(__A0)
 pascal OSErr PBSetFInfoSync(ParmBlkPtr paramBlock)
  = 0xA00D; 
 #pragma parameter __D0 PBSetFInfoAsync(__A0)
 pascal OSErr PBSetFInfoAsync(ParmBlkPtr paramBlock)
  = 0xA40D; 
-pascal OSErr PBSetFLock(ParmBlkPtr paramBlock,Boolean async); 
+#define PBSetFLock(pb, async) ((async) ? PBSetFLockAsync(pb) : PBSetFLockSync(pb)) 
 #pragma parameter __D0 PBSetFLockSync(__A0)
 pascal OSErr PBSetFLockSync(ParmBlkPtr paramBlock)
  = 0xA041; 
 #pragma parameter __D0 PBSetFLockAsync(__A0)
 pascal OSErr PBSetFLockAsync(ParmBlkPtr paramBlock)
  = 0xA441; 
-pascal OSErr PBRstFLock(ParmBlkPtr paramBlock,Boolean async); 
+#define PBRstFLock(pb, async) ((async) ? PBRstFLockAsync(pb) : PBRstFLockSync(pb)) 
 #pragma parameter __D0 PBRstFLockSync(__A0)
 pascal OSErr PBRstFLockSync(ParmBlkPtr paramBlock)
  = 0xA042; 
 #pragma parameter __D0 PBRstFLockAsync(__A0)
 pascal OSErr PBRstFLockAsync(ParmBlkPtr paramBlock)
  = 0xA442; 
-pascal OSErr PBSetFVers(ParmBlkPtr paramBlock,Boolean async); 
+#define PBSetFVers(pb, async) ((async) ? PBSetFVersAsync(pb) : PBSetFVersSync(pb)) 
 #pragma parameter __D0 PBSetFVersSync(__A0)
 pascal OSErr PBSetFVersSync(ParmBlkPtr paramBlock)
  = 0xA043; 
 #pragma parameter __D0 PBSetFVersAsync(__A0)
 pascal OSErr PBSetFVersAsync(ParmBlkPtr paramBlock)
  = 0xA443; 
-pascal OSErr PBAllocate(ParmBlkPtr paramBlock,Boolean async); 
+#define PBAllocate(pb, async) ((async) ? PBAllocateAsync(pb) : PBAllocateSync(pb)) 
 #pragma parameter __D0 PBAllocateSync(__A0)
 pascal OSErr PBAllocateSync(ParmBlkPtr paramBlock)
  = 0xA010; 
 #pragma parameter __D0 PBAllocateAsync(__A0)
 pascal OSErr PBAllocateAsync(ParmBlkPtr paramBlock)
  = 0xA410; 
-pascal OSErr PBGetEOF(ParmBlkPtr paramBlock,Boolean async); 
+#define PBGetEOF(pb, async) ((async) ? PBGetEOFAsync(pb) : PBGetEOFSync(pb)) 
 #pragma parameter __D0 PBGetEOFSync(__A0)
 pascal OSErr PBGetEOFSync(ParmBlkPtr paramBlock)
  = 0xA011; 
 #pragma parameter __D0 PBGetEOFAsync(__A0)
 pascal OSErr PBGetEOFAsync(ParmBlkPtr paramBlock)
  = 0xA411; 
-pascal OSErr PBSetEOF(ParmBlkPtr paramBlock,Boolean async); 
+#define PBSetEOF(pb, async) ((async) ? PBSetEOFAsync(pb) : PBSetEOFSync(pb)) 
 #pragma parameter __D0 PBSetEOFSync(__A0)
 pascal OSErr PBSetEOFSync(ParmBlkPtr paramBlock)
  = 0xA012; 
 #pragma parameter __D0 PBSetEOFAsync(__A0)
 pascal OSErr PBSetEOFAsync(ParmBlkPtr paramBlock)
  = 0xA412; 
-pascal OSErr PBGetFPos(ParmBlkPtr paramBlock,Boolean async); 
+#define PBGetFPos(pb, async) ((async) ? PBGetFPosAsync(pb) : PBGetFPosSync(pb)) 
 #pragma parameter __D0 PBGetFPosSync(__A0)
 pascal OSErr PBGetFPosSync(ParmBlkPtr paramBlock)
  = 0xA018; 
 #pragma parameter __D0 PBGetFPosAsync(__A0)
 pascal OSErr PBGetFPosAsync(ParmBlkPtr paramBlock)
  = 0xA418; 
-pascal OSErr PBSetFPos(ParmBlkPtr paramBlock,Boolean async); 
+#define PBSetFPos(pb, async) ((async) ? PBSetFPosAsync(pb) : PBSetFPosSync(pb)) 
 #pragma parameter __D0 PBSetFPosSync(__A0)
 pascal OSErr PBSetFPosSync(ParmBlkPtr paramBlock)
  = 0xA044; 
 #pragma parameter __D0 PBSetFPosAsync(__A0)
 pascal OSErr PBSetFPosAsync(ParmBlkPtr paramBlock)
  = 0xA444; 
-pascal OSErr PBFlushFile(ParmBlkPtr paramBlock,Boolean async); 
+#define PBFlushFile(pb, async) ((async) ? PBFlushFileAsync(pb) : PBFlushFileSync(pb)) 
 #pragma parameter __D0 PBFlushFileSync(__A0)
 pascal OSErr PBFlushFileSync(ParmBlkPtr paramBlock)
  = 0xA045; 
@@ -1037,7 +1037,7 @@ pascal OSErr PBEject(ParmBlkPtr paramBlock)
 pascal OSErr PBOffLine(ParmBlkPtr paramBlock)
  = 0xA035; 
 
-pascal OSErr PBCatSearch(CSParamPtr paramBlock,Boolean async); 
+#define PBCatSearch(pb, async) ((async) ? PBCatSearchAsync(pb) : PBCatSearchSync(pb)) 
 #pragma parameter __D0 PBCatSearchSync(__A0)
 pascal OSErr PBCatSearchSync(CSParamPtr paramBlock)
  = {0x7018,0xA260}; 
@@ -1088,70 +1088,70 @@ pascal OSErr GetFPos(short refNum,long *filePos);
 pascal OSErr SetFPos(short refNum,short posMode,long posOff); 
 pascal OSErr GetVRefNum(short fileRefNum,short *vRefNum); 
 
-pascal OSErr PBOpenWD(WDPBPtr paramBlock,Boolean async); 
+#define PBOpenWD(pb, async) ((async) ? PBOpenWDAsync(pb) : PBOpenWDSync(pb)) 
 #pragma parameter __D0 PBOpenWDSync(__A0)
 pascal OSErr PBOpenWDSync(WDPBPtr paramBlock)
  = {0x7001,0xA260}; 
 #pragma parameter __D0 PBOpenWDAsync(__A0)
 pascal OSErr PBOpenWDAsync(WDPBPtr paramBlock)
  = {0x7001,0xA660}; 
-pascal OSErr PBCloseWD(WDPBPtr paramBlock,Boolean async); 
+#define PBCloseWD(pb, async) ((async) ? PBCloseWDAsync(pb) : PBCloseWDSync(pb)) 
 #pragma parameter __D0 PBCloseWDSync(__A0)
 pascal OSErr PBCloseWDSync(WDPBPtr paramBlock)
  = {0x7002,0xA260}; 
 #pragma parameter __D0 PBCloseWDAsync(__A0)
 pascal OSErr PBCloseWDAsync(WDPBPtr paramBlock)
  = {0x7002,0xA660}; 
-pascal OSErr PBHSetVol(WDPBPtr paramBlock,Boolean async); 
+#define PBHSetVol(pb, async) ((async) ? PBHSetVolAsync(pb) : PBHSetVolSync(pb)) 
 #pragma parameter __D0 PBHSetVolSync(__A0)
 pascal OSErr PBHSetVolSync(WDPBPtr paramBlock)
  = 0xA215; 
 #pragma parameter __D0 PBHSetVolAsync(__A0)
 pascal OSErr PBHSetVolAsync(WDPBPtr paramBlock)
  = 0xA615; 
-pascal OSErr PBHGetVol(WDPBPtr paramBlock,Boolean async); 
+#define PBHGetVol(pb, async) ((async) ? PBHGetVolAsync(pb) : PBHGetVolSync(pb)) 
 #pragma parameter __D0 PBHGetVolSync(__A0)
 pascal OSErr PBHGetVolSync(WDPBPtr paramBlock)
  = 0xA214; 
 #pragma parameter __D0 PBHGetVolAsync(__A0)
 pascal OSErr PBHGetVolAsync(WDPBPtr paramBlock)
  = 0xA614; 
-pascal OSErr PBCatMove(CMovePBPtr paramBlock,Boolean async); 
+#define PBCatMove(pb, async) ((async) ? PBCatMoveAsync(pb) : PBCatMoveSync(pb)) 
 #pragma parameter __D0 PBCatMoveSync(__A0)
 pascal OSErr PBCatMoveSync(CMovePBPtr paramBlock)
  = {0x7005,0xA260}; 
 #pragma parameter __D0 PBCatMoveAsync(__A0)
 pascal OSErr PBCatMoveAsync(CMovePBPtr paramBlock)
  = {0x7005,0xA660}; 
-pascal OSErr PBDirCreate(HParmBlkPtr paramBlock,Boolean async); 
+#define PBDirCreate(pb, async) ((async) ? PBDirCreateAsync(pb) : PBDirCreateSync(pb)) 
 #pragma parameter __D0 PBDirCreateSync(__A0)
 pascal OSErr PBDirCreateSync(HParmBlkPtr paramBlock)
  = {0x7006,0xA260}; 
 #pragma parameter __D0 PBDirCreateAsync(__A0)
 pascal OSErr PBDirCreateAsync(HParmBlkPtr paramBlock)
  = {0x7006,0xA660}; 
-pascal OSErr PBGetWDInfo(WDPBPtr paramBlock,Boolean async); 
+#define PBGetWDInfo(pb, async) ((async) ? PBGetWDInfoAsync(pb) : PBGetWDInfoSync(pb)) 
 #pragma parameter __D0 PBGetWDInfoSync(__A0)
 pascal OSErr PBGetWDInfoSync(WDPBPtr paramBlock)
  = {0x7007,0xA260}; 
 #pragma parameter __D0 PBGetWDInfoAsync(__A0)
 pascal OSErr PBGetWDInfoAsync(WDPBPtr paramBlock)
  = {0x7007,0xA660}; 
-pascal OSErr PBGetFCBInfo(FCBPBPtr paramBlock,Boolean async); 
+#define PBGetFCBInfo(pb, async) ((async) ? PBGetFCBInfoAsync(pb) : PBGetFCBInfoSync(pb)) 
 #pragma parameter __D0 PBGetFCBInfoSync(__A0)
 pascal OSErr PBGetFCBInfoSync(FCBPBPtr paramBlock)
  = {0x7008,0xA260}; 
 #pragma parameter __D0 PBGetFCBInfoAsync(__A0)
 pascal OSErr PBGetFCBInfoAsync(FCBPBPtr paramBlock)
  = {0x7008,0xA660}; 
-pascal OSErr PBGetCatInfo(CInfoPBPtr paramBlock,Boolean async); 
+#define PBGetCatInfo(pb, async) ((async) ? PBGetCatInfoAsync(pb) : PBGetCatInfoSync(pb)) 
 #pragma parameter __D0 PBGetCatInfoSync(__A0)
 pascal OSErr PBGetCatInfoSync(CInfoPBPtr paramBlock)
  = {0x7009,0xA260}; 
 #pragma parameter __D0 PBGetCatInfoAsync(__A0)
 pascal OSErr PBGetCatInfoAsync(CInfoPBPtr paramBlock)
  = {0x7009,0xA660}; 
-pascal OSErr PBSetCatInfo(CInfoPBPtr paramBlock,Boolean async); 
+#define PBSetCatInfo(pb, async) ((async) ? PBSetCatInfoAsync(pb) : PBSetCatInfoSync(pb)) 
 #pragma parameter __D0 PBSetCatInfoSync(__A0)
 pascal OSErr PBSetCatInfoSync(CInfoPBPtr paramBlock)
  = {0x700A,0xA260}; 
@@ -1159,56 +1159,56 @@ pascal OSErr PBSetCatInfoSync(CInfoPBPtr paramBlock)
 pascal OSErr PBSetCatInfoAsync(CInfoPBPtr paramBlock)
  = {0x700A,0xA660}; 
 
-pascal OSErr PBAllocContig(ParmBlkPtr paramBlock,Boolean async); 
+#define PBAllocContig(pb, async) ((async) ? PBAllocContigAsync(pb) : PBAllocContigSync(pb)) 
 #pragma parameter __D0 PBAllocContigSync(__A0)
 pascal OSErr PBAllocContigSync(ParmBlkPtr paramBlock)
  = 0xA210; 
 #pragma parameter __D0 PBAllocContigAsync(__A0)
 pascal OSErr PBAllocContigAsync(ParmBlkPtr paramBlock)
  = 0xA610; 
-pascal OSErr PBLockRange(ParmBlkPtr paramBlock,Boolean async); 
+#define PBLockRange(pb, async) ((async) ? PBLockRangeAsync(pb) : PBLockRangeSync(pb)) 
 #pragma parameter __D0 PBLockRangeSync(__A0)
 pascal OSErr PBLockRangeSync(ParmBlkPtr paramBlock)
  = {0x7010,0xA260}; 
 #pragma parameter __D0 PBLockRangeAsync(__A0)
 pascal OSErr PBLockRangeAsync(ParmBlkPtr paramBlock)
  = {0x7010,0xA660}; 
-pascal OSErr PBUnlockRange(ParmBlkPtr paramBlock,Boolean async); 
+#define PBUnlockRange(pb, async) ((async) ? PBUnlockRangeAsync(pb) : PBUnlockRangeSync(pb)) 
 #pragma parameter __D0 PBUnlockRangeSync(__A0)
 pascal OSErr PBUnlockRangeSync(ParmBlkPtr paramBlock)
  = {0x7011,0xA260}; 
 #pragma parameter __D0 PBUnlockRangeAsync(__A0)
 pascal OSErr PBUnlockRangeAsync(ParmBlkPtr paramBlock)
  = {0x7011,0xA660}; 
-pascal OSErr PBSetVInfo(HParmBlkPtr paramBlock,Boolean async); 
+#define PBSetVInfo(pb, async) ((async) ? PBSetVInfoAsync(pb) : PBSetVInfoSync(pb)) 
 #pragma parameter __D0 PBSetVInfoSync(__A0)
 pascal OSErr PBSetVInfoSync(HParmBlkPtr paramBlock)
  = {0x700B,0xA260}; 
 #pragma parameter __D0 PBSetVInfoAsync(__A0)
 pascal OSErr PBSetVInfoAsync(HParmBlkPtr paramBlock)
  = {0x700B,0xA660}; 
-pascal OSErr PBHGetVInfo(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHGetVInfo(pb, async) ((async) ? PBHGetVInfoAsync(pb) : PBHGetVInfoSync(pb)) 
 #pragma parameter __D0 PBHGetVInfoSync(__A0)
 pascal OSErr PBHGetVInfoSync(HParmBlkPtr paramBlock)
  = 0xA207; 
 #pragma parameter __D0 PBHGetVInfoAsync(__A0)
 pascal OSErr PBHGetVInfoAsync(HParmBlkPtr paramBlock)
  = 0xA607; 
-pascal OSErr PBHOpen(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHOpen(pb, async) ((async) ? PBHOpenAsync(pb) : PBHOpenSync(pb)) 
 #pragma parameter __D0 PBHOpenSync(__A0)
 pascal OSErr PBHOpenSync(HParmBlkPtr paramBlock)
  = 0xA200; 
 #pragma parameter __D0 PBHOpenAsync(__A0)
 pascal OSErr PBHOpenAsync(HParmBlkPtr paramBlock)
  = 0xA600; 
-pascal OSErr PBHOpenRF(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHOpenRF(pb, async) ((async) ? PBHOpenRFAsync(pb) : PBHOpenRFSync(pb)) 
 #pragma parameter __D0 PBHOpenRFSync(__A0)
 pascal OSErr PBHOpenRFSync(HParmBlkPtr paramBlock)
  = 0xA20A; 
 #pragma parameter __D0 PBHOpenRFAsync(__A0)
 pascal OSErr PBHOpenRFAsync(HParmBlkPtr paramBlock)
  = 0xA60A; 
-pascal OSErr PBHOpenDF(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHOpenDF(pb, async) ((async) ? PBHOpenDFAsync(pb) : PBHOpenDFSync(pb)) 
 #pragma parameter __D0 PBHOpenDFSync(__A0)
 pascal OSErr PBHOpenDFSync(HParmBlkPtr paramBlock)
  = {0x701A,0xA260}; 
@@ -1216,49 +1216,49 @@ pascal OSErr PBHOpenDFSync(HParmBlkPtr paramBlock)
 pascal OSErr PBHOpenDFAsync(HParmBlkPtr paramBlock)
  = {0x701A,0xA660}; 
 
-pascal OSErr PBHCreate(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHCreate(pb, async) ((async) ? PBHCreateAsync(pb) : PBHCreateSync(pb)) 
 #pragma parameter __D0 PBHCreateSync(__A0)
 pascal OSErr PBHCreateSync(HParmBlkPtr paramBlock)
  = 0xA208; 
 #pragma parameter __D0 PBHCreateAsync(__A0)
 pascal OSErr PBHCreateAsync(HParmBlkPtr paramBlock)
  = 0xA608; 
-pascal OSErr PBHDelete(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHDelete(pb, async) ((async) ? PBHDeleteAsync(pb) : PBHDeleteSync(pb)) 
 #pragma parameter __D0 PBHDeleteSync(__A0)
 pascal OSErr PBHDeleteSync(HParmBlkPtr paramBlock)
  = 0xA209; 
 #pragma parameter __D0 PBHDeleteAsync(__A0)
 pascal OSErr PBHDeleteAsync(HParmBlkPtr paramBlock)
  = 0xA609; 
-pascal OSErr PBHRename(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHRename(pb, async) ((async) ? PBHRenameAsync(pb) : PBHRenameSync(pb)) 
 #pragma parameter __D0 PBHRenameSync(__A0)
 pascal OSErr PBHRenameSync(HParmBlkPtr paramBlock)
  = 0xA20B; 
 #pragma parameter __D0 PBHRenameAsync(__A0)
 pascal OSErr PBHRenameAsync(HParmBlkPtr paramBlock)
  = 0xA60B; 
-pascal OSErr PBHRstFLock(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHRstFLock(pb, async) ((async) ? PBHRstFLockAsync(pb) : PBHRstFLockSync(pb)) 
 #pragma parameter __D0 PBHRstFLockSync(__A0)
 pascal OSErr PBHRstFLockSync(HParmBlkPtr paramBlock)
  = 0xA242; 
 #pragma parameter __D0 PBHRstFLockAsync(__A0)
 pascal OSErr PBHRstFLockAsync(HParmBlkPtr paramBlock)
  = 0xA642; 
-pascal OSErr PBHSetFLock(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHSetFLock(pb, async) ((async) ? PBHSetFLockAsync(pb) : PBHSetFLockSync(pb)) 
 #pragma parameter __D0 PBHSetFLockSync(__A0)
 pascal OSErr PBHSetFLockSync(HParmBlkPtr paramBlock)
  = 0xA241; 
 #pragma parameter __D0 PBHSetFLockAsync(__A0)
 pascal OSErr PBHSetFLockAsync(HParmBlkPtr paramBlock)
  = 0xA641; 
-pascal OSErr PBHGetFInfo(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHGetFInfo(pb, async) ((async) ? PBHGetFInfoAsync(pb) : PBHGetFInfoSync(pb)) 
 #pragma parameter __D0 PBHGetFInfoSync(__A0)
 pascal OSErr PBHGetFInfoSync(HParmBlkPtr paramBlock)
  = 0xA20C; 
 #pragma parameter __D0 PBHGetFInfoAsync(__A0)
 pascal OSErr PBHGetFInfoAsync(HParmBlkPtr paramBlock)
  = 0xA60C; 
-pascal OSErr PBHSetFInfo(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHSetFInfo(pb, async) ((async) ? PBHSetFInfoAsync(pb) : PBHSetFInfoSync(pb)) 
 #pragma parameter __D0 PBHSetFInfoSync(__A0)
 pascal OSErr PBHSetFInfoSync(HParmBlkPtr paramBlock)
  = 0xA20D; 
@@ -1266,7 +1266,7 @@ pascal OSErr PBHSetFInfoSync(HParmBlkPtr paramBlock)
 pascal OSErr PBHSetFInfoAsync(HParmBlkPtr paramBlock)
  = 0xA60D; 
 
-pascal OSErr PBMakeFSSpec(HParmBlkPtr paramBlock,Boolean async); 
+#define PBMakeFSSpec(pb, async) ((async) ? PBMakeFSSpecAsync(pb) : PBMakeFSSpecSync(pb)) 
 #pragma parameter __D0 PBMakeFSSpecSync(__A0)
 pascal OSErr PBMakeFSSpecSync(HParmBlkPtr paramBlock)
  = {0x701B,0xA260}; 
@@ -1307,70 +1307,70 @@ pascal OSErr OpenWD(short vRefNum,long dirID,long procID,short *wdRefNum);
 pascal OSErr CloseWD(short wdRefNum); 
 pascal OSErr GetWDInfo(short wdRefNum,short *vRefNum,long *dirID,long *procID); 
 /*  shared environment  */
-pascal OSErr PBHGetVolParms(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHGetVolParms(pb, async) ((async) ? PBHGetVolParmsAsync(pb) : PBHGetVolParmsSync(pb)) 
 #pragma parameter __D0 PBHGetVolParmsSync(__A0)
 pascal OSErr PBHGetVolParmsSync(HParmBlkPtr paramBlock)
  = {0x7030,0xA260}; 
 #pragma parameter __D0 PBHGetVolParmsAsync(__A0)
 pascal OSErr PBHGetVolParmsAsync(HParmBlkPtr paramBlock)
  = {0x7030,0xA660}; 
-pascal OSErr PBHGetLogInInfo(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHGetLogInInfo(pb, async) ((async) ? PBHGetLogInInfoAsync(pb) : PBHGetLogInInfoSync(pb)) 
 #pragma parameter __D0 PBHGetLogInInfoSync(__A0)
 pascal OSErr PBHGetLogInInfoSync(HParmBlkPtr paramBlock)
  = {0x7031,0xA260}; 
 #pragma parameter __D0 PBHGetLogInInfoAsync(__A0)
 pascal OSErr PBHGetLogInInfoAsync(HParmBlkPtr paramBlock)
  = {0x7031,0xA660}; 
-pascal OSErr PBHGetDirAccess(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHGetDirAccess(pb, async) ((async) ? PBHGetDirAccessAsync(pb) : PBHGetDirAccessSync(pb)) 
 #pragma parameter __D0 PBHGetDirAccessSync(__A0)
 pascal OSErr PBHGetDirAccessSync(HParmBlkPtr paramBlock)
  = {0x7032,0xA260}; 
 #pragma parameter __D0 PBHGetDirAccessAsync(__A0)
 pascal OSErr PBHGetDirAccessAsync(HParmBlkPtr paramBlock)
  = {0x7032,0xA660}; 
-pascal OSErr PBHSetDirAccess(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHSetDirAccess(pb, async) ((async) ? PBHSetDirAccessAsync(pb) : PBHSetDirAccessSync(pb)) 
 #pragma parameter __D0 PBHSetDirAccessSync(__A0)
 pascal OSErr PBHSetDirAccessSync(HParmBlkPtr paramBlock)
  = {0x7033,0xA260}; 
 #pragma parameter __D0 PBHSetDirAccessAsync(__A0)
 pascal OSErr PBHSetDirAccessAsync(HParmBlkPtr paramBlock)
  = {0x7033,0xA660}; 
-pascal OSErr PBHMapID(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHMapID(pb, async) ((async) ? PBHMapIDAsync(pb) : PBHMapIDSync(pb)) 
 #pragma parameter __D0 PBHMapIDSync(__A0)
 pascal OSErr PBHMapIDSync(HParmBlkPtr paramBlock)
  = {0x7034,0xA260}; 
 #pragma parameter __D0 PBHMapIDAsync(__A0)
 pascal OSErr PBHMapIDAsync(HParmBlkPtr paramBlock)
  = {0x7034,0xA660}; 
-pascal OSErr PBHMapName(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHMapName(pb, async) ((async) ? PBHMapNameAsync(pb) : PBHMapNameSync(pb)) 
 #pragma parameter __D0 PBHMapNameSync(__A0)
 pascal OSErr PBHMapNameSync(HParmBlkPtr paramBlock)
  = {0x7035,0xA260}; 
 #pragma parameter __D0 PBHMapNameAsync(__A0)
 pascal OSErr PBHMapNameAsync(HParmBlkPtr paramBlock)
  = {0x7035,0xA660}; 
-pascal OSErr PBHCopyFile(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHCopyFile(pb, async) ((async) ? PBHCopyFileAsync(pb) : PBHCopyFileSync(pb)) 
 #pragma parameter __D0 PBHCopyFileSync(__A0)
 pascal OSErr PBHCopyFileSync(HParmBlkPtr paramBlock)
  = {0x7036,0xA260}; 
 #pragma parameter __D0 PBHCopyFileAsync(__A0)
 pascal OSErr PBHCopyFileAsync(HParmBlkPtr paramBlock)
  = {0x7036,0xA660}; 
-pascal OSErr PBHMoveRename(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHMoveRename(pb, async) ((async) ? PBHMoveRenameAsync(pb) : PBHMoveRenameSync(pb)) 
 #pragma parameter __D0 PBHMoveRenameSync(__A0)
 pascal OSErr PBHMoveRenameSync(HParmBlkPtr paramBlock)
  = {0x7037,0xA260}; 
 #pragma parameter __D0 PBHMoveRenameAsync(__A0)
 pascal OSErr PBHMoveRenameAsync(HParmBlkPtr paramBlock)
  = {0x7037,0xA660}; 
-pascal OSErr PBHOpenDeny(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHOpenDeny(pb, async) ((async) ? PBHOpenDenyAsync(pb) : PBHOpenDenySync(pb)) 
 #pragma parameter __D0 PBHOpenDenySync(__A0)
 pascal OSErr PBHOpenDenySync(HParmBlkPtr paramBlock)
  = {0x7038,0xA260}; 
 #pragma parameter __D0 PBHOpenDenyAsync(__A0)
 pascal OSErr PBHOpenDenyAsync(HParmBlkPtr paramBlock)
  = {0x7038,0xA660}; 
-pascal OSErr PBHOpenRFDeny(HParmBlkPtr paramBlock,Boolean async); 
+#define PBHOpenRFDeny(pb, async) ((async) ? PBHOpenRFDenyAsync(pb) : PBHOpenRFDenySync(pb)) 
 #pragma parameter __D0 PBHOpenRFDenySync(__A0)
 pascal OSErr PBHOpenRFDenySync(HParmBlkPtr paramBlock)
  = {0x7039,0xA260}; 
@@ -1378,28 +1378,28 @@ pascal OSErr PBHOpenRFDenySync(HParmBlkPtr paramBlock)
 pascal OSErr PBHOpenRFDenyAsync(HParmBlkPtr paramBlock)
  = {0x7039,0xA660}; 
 
-pascal OSErr PBExchangeFiles(HParmBlkPtr paramBlock,Boolean async); 
+#define PBExchangeFiles(pb, async) ((async) ? PBExchangeFilesAsync(pb) : PBExchangeFilesSync(pb)) 
 #pragma parameter __D0 PBExchangeFilesSync(__A0)
 pascal OSErr PBExchangeFilesSync(HParmBlkPtr paramBlock)
  = {0x7017,0xA260}; 
 #pragma parameter __D0 PBExchangeFilesAsync(__A0)
 pascal OSErr PBExchangeFilesAsync(HParmBlkPtr paramBlock)
  = {0x7017,0xA660}; 
-pascal OSErr PBCreateFileIDRef(HParmBlkPtr paramBlock,Boolean async); 
+#define PBCreateFileIDRef(pb, async) ((async) ? PBCreateFileIDRefAsync(pb) : PBCreateFileIDRefSync(pb)) 
 #pragma parameter __D0 PBCreateFileIDRefSync(__A0)
 pascal OSErr PBCreateFileIDRefSync(HParmBlkPtr paramBlock)
  = {0x7014,0xA260}; 
 #pragma parameter __D0 PBCreateFileIDRefAsync(__A0)
 pascal OSErr PBCreateFileIDRefAsync(HParmBlkPtr paramBlock)
  = {0x7014,0xA660}; 
-pascal OSErr PBResolveFileIDRef(HParmBlkPtr paramBlock,Boolean async); 
+#define PBResolveFileIDRef(pb, async) ((async) ? PBResolveFileIDRefAsync(pb) : PBResolveFileIDRefSync(pb)) 
 #pragma parameter __D0 PBResolveFileIDRefSync(__A0)
 pascal OSErr PBResolveFileIDRefSync(HParmBlkPtr paramBlock)
  = {0x7016,0xA260}; 
 #pragma parameter __D0 PBResolveFileIDRefAsync(__A0)
 pascal OSErr PBResolveFileIDRefAsync(HParmBlkPtr paramBlock)
  = {0x7016,0xA660}; 
-pascal OSErr PBDeleteFileIDRef(HParmBlkPtr paramBlock,Boolean async); 
+#define PBDeleteFileIDRef(pb, async) ((async) ? PBDeleteFileIDRefAsync(pb) : PBDeleteFileIDRefSync(pb)) 
 #pragma parameter __D0 PBDeleteFileIDRefSync(__A0)
 pascal OSErr PBDeleteFileIDRefSync(HParmBlkPtr paramBlock)
  = {0x7015,0xA260}; 
@@ -1407,14 +1407,14 @@ pascal OSErr PBDeleteFileIDRefSync(HParmBlkPtr paramBlock)
 pascal OSErr PBDeleteFileIDRefAsync(HParmBlkPtr paramBlock)
  = {0x7015,0xA660}; 
 
-pascal OSErr PBGetForeignPrivs(HParmBlkPtr paramBlock,Boolean async); 
+#define PBGetForeignPrivs(pb, async) ((async) ? PBGetForeignPrivsAsync(pb) : PBGetForeignPrivsSync(pb)) 
 #pragma parameter __D0 PBGetForeignPrivsSync(__A0)
 pascal OSErr PBGetForeignPrivsSync(HParmBlkPtr paramBlock)
  = {0x7060,0xA260}; 
 #pragma parameter __D0 PBGetForeignPrivsAsync(__A0)
 pascal OSErr PBGetForeignPrivsAsync(HParmBlkPtr paramBlock)
  = {0x7060,0xA660}; 
-pascal OSErr PBSetForeignPrivs(HParmBlkPtr paramBlock,Boolean async); 
+#define PBSetForeignPrivs(pb, async) ((async) ? PBSetForeignPrivsAsync(pb) : PBSetForeignPrivsSync(pb)) 
 #pragma parameter __D0 PBSetForeignPrivsSync(__A0)
 pascal OSErr PBSetForeignPrivsSync(HParmBlkPtr paramBlock)
  = {0x7061,0xA260}; 
@@ -1428,84 +1428,84 @@ pascal OSErr PBDTGetPath(DTPBPtr paramBlock)
 #pragma parameter __D0 PBDTCloseDown(__A0)
 pascal OSErr PBDTCloseDown(DTPBPtr paramBlock)
  = {0x7021,0xA260}; 
-pascal OSErr PBDTAddIcon(DTPBPtr paramBlock,Boolean async); 
+#define PBDTAddIcon(pb, async) ((async) ? PBDTAddIconAsync(pb) : PBDTAddIconSync(pb)) 
 #pragma parameter __D0 PBDTAddIconSync(__A0)
 pascal OSErr PBDTAddIconSync(DTPBPtr paramBlock)
  = {0x7022,0xA260}; 
 #pragma parameter __D0 PBDTAddIconAsync(__A0)
 pascal OSErr PBDTAddIconAsync(DTPBPtr paramBlock)
  = {0x7022,0xA660}; 
-pascal OSErr PBDTGetIcon(DTPBPtr paramBlock,Boolean async); 
+#define PBDTGetIcon(pb, async) ((async) ? PBDTGetIconAsync(pb) : PBDTGetIconSync(pb)) 
 #pragma parameter __D0 PBDTGetIconSync(__A0)
 pascal OSErr PBDTGetIconSync(DTPBPtr paramBlock)
  = {0x7023,0xA260}; 
 #pragma parameter __D0 PBDTGetIconAsync(__A0)
 pascal OSErr PBDTGetIconAsync(DTPBPtr paramBlock)
  = {0x7023,0xA660}; 
-pascal OSErr PBDTGetIconInfo(DTPBPtr paramBlock,Boolean async); 
+#define PBDTGetIconInfo(pb, async) ((async) ? PBDTGetIconInfoAsync(pb) : PBDTGetIconInfoSync(pb)) 
 #pragma parameter __D0 PBDTGetIconInfoSync(__A0)
 pascal OSErr PBDTGetIconInfoSync(DTPBPtr paramBlock)
  = {0x7024,0xA260}; 
 #pragma parameter __D0 PBDTGetIconInfoAsync(__A0)
 pascal OSErr PBDTGetIconInfoAsync(DTPBPtr paramBlock)
  = {0x7024,0xA660}; 
-pascal OSErr PBDTAddAPPL(DTPBPtr paramBlock,Boolean async); 
+#define PBDTAddAPPL(pb, async) ((async) ? PBDTAddAPPLAsync(pb) : PBDTAddAPPLSync(pb)) 
 #pragma parameter __D0 PBDTAddAPPLSync(__A0)
 pascal OSErr PBDTAddAPPLSync(DTPBPtr paramBlock)
  = {0x7025,0xA260}; 
 #pragma parameter __D0 PBDTAddAPPLAsync(__A0)
 pascal OSErr PBDTAddAPPLAsync(DTPBPtr paramBlock)
  = {0x7025,0xA660}; 
-pascal OSErr PBDTRemoveAPPL(DTPBPtr paramBlock,Boolean async); 
+#define PBDTRemoveAPPL(pb, async) ((async) ? PBDTRemoveAPPLAsync(pb) : PBDTRemoveAPPLSync(pb)) 
 #pragma parameter __D0 PBDTRemoveAPPLSync(__A0)
 pascal OSErr PBDTRemoveAPPLSync(DTPBPtr paramBlock)
  = {0x7026,0xA260}; 
 #pragma parameter __D0 PBDTRemoveAPPLAsync(__A0)
 pascal OSErr PBDTRemoveAPPLAsync(DTPBPtr paramBlock)
  = {0x7026,0xA660}; 
-pascal OSErr PBDTGetAPPL(DTPBPtr paramBlock,Boolean async); 
+#define PBDTGetAPPL(pb, async) ((async) ? PBDTGetAPPLAsync(pb) : PBDTGetAPPLSync(pb)) 
 #pragma parameter __D0 PBDTGetAPPLSync(__A0)
 pascal OSErr PBDTGetAPPLSync(DTPBPtr paramBlock)
  = {0x7027,0xA260}; 
 #pragma parameter __D0 PBDTGetAPPLAsync(__A0)
 pascal OSErr PBDTGetAPPLAsync(DTPBPtr paramBlock)
  = {0x7027,0xA660}; 
-pascal OSErr PBDTSetComment(DTPBPtr paramBlock,Boolean async); 
+#define PBDTSetComment(pb, async) ((async) ? PBDTSetCommentAsync(pb) : PBDTSetCommentSync(pb)) 
 #pragma parameter __D0 PBDTSetCommentSync(__A0)
 pascal OSErr PBDTSetCommentSync(DTPBPtr paramBlock)
  = {0x7028,0xA260}; 
 #pragma parameter __D0 PBDTSetCommentAsync(__A0)
 pascal OSErr PBDTSetCommentAsync(DTPBPtr paramBlock)
  = {0x7028,0xA660}; 
-pascal OSErr PBDTRemoveComment(DTPBPtr paramBlock,Boolean async); 
+#define PBDTRemoveComment(pb, async) ((async) ? PBDTRemoveCommentAsync(pb) : PBDTRemoveCommentSync(pb)) 
 #pragma parameter __D0 PBDTRemoveCommentSync(__A0)
 pascal OSErr PBDTRemoveCommentSync(DTPBPtr paramBlock)
  = {0x7029,0xA260}; 
 #pragma parameter __D0 PBDTRemoveCommentAsync(__A0)
 pascal OSErr PBDTRemoveCommentAsync(DTPBPtr paramBlock)
  = {0x7029,0xA660}; 
-pascal OSErr PBDTGetComment(DTPBPtr paramBlock,Boolean async); 
+#define PBDTGetComment(pb, async) ((async) ? PBDTGetCommentAsync(pb) : PBDTGetCommentSync(pb)) 
 #pragma parameter __D0 PBDTGetCommentSync(__A0)
 pascal OSErr PBDTGetCommentSync(DTPBPtr paramBlock)
  = {0x702A,0xA260}; 
 #pragma parameter __D0 PBDTGetCommentAsync(__A0)
 pascal OSErr PBDTGetCommentAsync(DTPBPtr paramBlock)
  = {0x702A,0xA660}; 
-pascal OSErr PBDTFlush(DTPBPtr paramBlock,Boolean async); 
+#define PBDTFlush(pb, async) ((async) ? PBDTFlushAsync(pb) : PBDTFlushSync(pb)) 
 #pragma parameter __D0 PBDTFlushSync(__A0)
 pascal OSErr PBDTFlushSync(DTPBPtr paramBlock)
  = {0x702B,0xA260}; 
 #pragma parameter __D0 PBDTFlushAsync(__A0)
 pascal OSErr PBDTFlushAsync(DTPBPtr paramBlock)
  = {0x702B,0xA660}; 
-pascal OSErr PBDTReset(DTPBPtr paramBlock,Boolean async); 
+#define PBDTReset(pb, async) ((async) ? PBDTResetAsync(pb) : PBDTResetSync(pb)) 
 #pragma parameter __D0 PBDTResetSync(__A0)
 pascal OSErr PBDTResetSync(DTPBPtr paramBlock)
  = {0x702C,0xA260}; 
 #pragma parameter __D0 PBDTResetAsync(__A0)
 pascal OSErr PBDTResetAsync(DTPBPtr paramBlock)
  = {0x702C,0xA660}; 
-pascal OSErr PBDTGetInfo(DTPBPtr paramBlock,Boolean async); 
+#define PBDTGetInfo(pb, async) ((async) ? PBDTGetInfoAsync(pb) : PBDTGetInfoSync(pb)) 
 #pragma parameter __D0 PBDTGetInfoSync(__A0)
 pascal OSErr PBDTGetInfoSync(DTPBPtr paramBlock)
  = {0x702D,0xA260}; 
@@ -1515,7 +1515,7 @@ pascal OSErr PBDTGetInfoAsync(DTPBPtr paramBlock)
 #pragma parameter __D0 PBDTOpenInform(__A0)
 pascal OSErr PBDTOpenInform(DTPBPtr paramBlock)
  = {0x702E,0xA060}; 
-pascal OSErr PBDTDelete(DTPBPtr paramBlock,Boolean async); 
+#define PBDTDelete(pb, async) ((async) ? PBDTDeleteAsync(pb) : PBDTDeleteSync(pb)) 
 #pragma parameter __D0 PBDTDeleteSync(__A0)
 pascal OSErr PBDTDeleteSync(DTPBPtr paramBlock)
  = {0x702F,0xA060}; 
@@ -1562,14 +1562,14 @@ pascal OSErr FSpCatMove(const FSSpec *source,const FSSpec *dest)
 pascal OSErr FSpExchangeFiles(const FSSpec *source,const FSSpec *dest)
  = {0x303C,0x000F,0xAA52}; 
 /* Obsoolete names for PBGetForeignPrivs and PBSetForeignPrivs */
-pascal OSErr PBGetAltAccess(HParmBlkPtr paramBlock,Boolean async); 
+#define PBGetAltAccess(pb, async) ((async) ? PBGetAltAccessAsync(pb) : PBGetAltAccessSync(pb)) 
 #pragma parameter __D0 PBGetAltAccessSync(__A0)
 pascal OSErr PBGetAltAccessSync(HParmBlkPtr paramBlock)
  = {0x7060,0xA060}; 
 #pragma parameter __D0 PBGetAltAccessAsync(__A0)
 pascal OSErr PBGetAltAccessAsync(HParmBlkPtr paramBlock)
  = {0x7060,0xA460}; 
-pascal OSErr PBSetAltAccess(HParmBlkPtr paramBlock,Boolean async); 
+#define PBSetAltAccess(pb, async) ((async) ? PBSetAltAccessAsync(pb) : PBSetAltAccessSync(pb)) 
 #pragma parameter __D0 PBSetAltAccessSync(__A0)
 pascal OSErr PBSetAltAccessSync(HParmBlkPtr paramBlock)
  = {0x7061,0xA060}; 
diff --git a/Interfaces/CIncludes/Memory.h b/Interfaces/CIncludes/Memory.h
--- a/Interfaces/CIncludes/Memory.h
+++ b/Interfaces/CIncludes/Memory.h
@@ -71,7 +71,7 @@ Created: Saturday, July 27, 1991 at 4:28 PM
 
 enum {
 
- maxSize = 0x800000,	/*Max data block size is 8 megabytes*/
+ maxSize = 0x7FFFFFF0,	/*Max data block size is 8 megabytes*/
  defaultPhysicalEntryCount = 8,
 
 /* values returned from the GetPageState function */
@@ -132,9 +132,12 @@ extern "C" {
 #pragma parameter __A0 GetZone
 pascal THz GetZone(void)
  = 0xA11A; 
-#define SystemZone() (* (THz*) 0x02A6)
-#define ApplicZone() (* (THz*) 0x02AA)
-#define ApplicationZone() (* (THz*) 0x02AA)
+pascal THz SystemZone(void)
+ = {0x2EB8,0x02A6};
+pascal THz ApplicZone(void)
+ = {0x2EB8,0x02AA};
+pascal THz ApplicationZone(void)
+ = {0x2EB8,0x02AA};
 #pragma parameter __A0 NewHandle(__D0)
 pascal Handle NewHandle(Size byteCount)
  = {__GenOSTrapCode(0xA122)}; 
@@ -171,7 +174,8 @@ pascal Ptr NewPtrSysClear(Size byteCount)
 #pragma parameter __A0 PtrZone(__A0)
 pascal THz PtrZone(Ptr p)
  = 0xA148; 
-#define GZSaveHnd() (* (Handle*) 0x0328)
+pascal Handle GZSaveHnd(void)
+ = {0x2EB8,0x0328};
 #define TopMem() (* (Ptr*) 0x0108)
 #pragma parameter __D0 MaxBlock
 pascal long MaxBlock(void)
@@ -204,7 +208,7 @@ pascal void HNoPurge(Handle h)
 pascal void HLockHi(Handle h)
  = {0xA064,0xA029}; 
 
-#ifdef	Supports24Bit
+#if	Supports24Bit
 	#if SystemSixOrLater
 	#pragma parameter __D0 StripAddress(__D0)
 	pascal Ptr StripAddress(void *theAddress)
@@ -344,7 +348,8 @@ pascal void BlockMove(const void *srcPtr,void *destPtr,Size byteCount)
 #pragma parameter BlockMoveData(__A0,__A1,__D0)
 pascal void BlockMoveData(const void *srcPtr,void *destPtr,Size byteCount)
  = {__GenOSTrapCode(0xA22E)}; 
-#define MemError() (* (OSErr*) 0x0220)
+pascal OSErr MemError(void)
+ = {0x3EB8,0x0220};
 pascal void PurgeSpace(long *total,long *contig); 
 #pragma parameter __D0 HGetState(__A0)
 pascal char HGetState(Handle h)
diff --git a/Interfaces/CIncludes/Notification.h b/Interfaces/CIncludes/Notification.h
--- a/Interfaces/CIncludes/Notification.h
+++ b/Interfaces/CIncludes/Notification.h
@@ -63,10 +63,12 @@ typedef NMRec *NMRecPtr;
 #ifdef __cplusplus
 extern "C" {
 #endif
+#pragma parameter __D0 NMInstall(__A0)
 pascal OSErr NMInstall(NMRecPtr nmReqPtr)
- = {0x205F,0xA05E,0x3E80}; 
+ = {0xA05E}; 
+#pragma parameter __D0 NMRemove(__A0)
 pascal OSErr NMRemove(NMRecPtr nmReqPtr)
- = {0x205F,0xA05F,0x3E80}; 
+ = {0xA05F}; 
 #ifdef __cplusplus
 }
 #endif
diff --git a/Interfaces/CIncludes/Resources.h b/Interfaces/CIncludes/Resources.h
--- a/Interfaces/CIncludes/Resources.h
+++ b/Interfaces/CIncludes/Resources.h
@@ -191,6 +191,9 @@ pascal void SetResourceSize(Handle theResource,long newSize)
 pascal Handle GetNextFOND(Handle fondHandle)
  = {0x700A,0xA822};
 
+pascal void TempInsertROMMap(Boolean tempResLoad)
+ = {0x70FF,0x4A1F,0x56C0,0x31C0,0x0B9E};
+
 short openrfperm(char *fileName,short vRefNum,char permission);
 short openresfile(char *fileName);
 void createresfile(char *fileName);
diff --git a/Interfaces/CIncludes/SetJmp.h b/Interfaces/CIncludes/SetJmp.h
--- a/Interfaces/CIncludes/SetJmp.h
+++ b/Interfaces/CIncludes/SetJmp.h
@@ -19,7 +19,7 @@
 #define __SETJMP__
 
 
-typedef long *jmp_buf[12];		/*	D2-D7,PC,A2-A4,A6,SP  */
+typedef long *jmp_buf[16];		/*	new 68K: D2-D7,PC,A2-A4,A6,SP,FLAGS,A5,RESVD,RESVD  */
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/Interfaces/CIncludes/Sound.h b/Interfaces/CIncludes/Sound.h
new file mode 100644
--- /dev/null
+++ b/Interfaces/CIncludes/Sound.h
@@ -0,0 +1,521 @@
+
+/************************************************************
+
+Created: Monday, December 2, 1991 at 5:07 PM
+ Sound.h
+ C Interface to the Macintosh Libraries
+
+
+  Copyright Apple Computer, Inc. 1986-1991
+  All rights reserved
+
+************************************************************/
+
+
+#ifndef __SOUND__
+#define __SOUND__
+
+#ifndef __TYPES__
+#include <Types.h>
+#endif
+
+#ifndef __FILES__
+#include <Files.h>
+#endif
+
+
+enum {
+
+ swMode = -1,								/* Sound Driver modes */
+ ftMode = 1,
+ ffMode = 0,
+
+
+#define synthCodeRsrc 'snth'				/* Resource types used by Sound Manager */
+#define soundListRsrc 'snd '
+
+#define twelfthRootTwo 1.05946309434
+
+ rate22khz = 0x56EE8BA3,					/* 22254.54545 in fixed-point */
+ rate11khz = 0x2B7745D1,					/* 11127.27273 in fixed-point */
+
+/* synthesizer numbers for SndNewChannel */
+ squareWaveSynth = 1,						/*square wave synthesizer*/
+ waveTableSynth = 3,						/*wave table synthesizer*/
+ sampledSynth = 5,							/*sampled sound synthesizer*/
+
+/* old Sound Manager MACE synthesizer numbers */
+ MACE3snthID = 11,
+ MACE6snthID = 13,
+
+/* command numbers for SndDoCommand and SndDoImmediate */
+ nullCmd = 0,
+ initCmd = 1,
+ freeCmd = 2,
+ quietCmd = 3,
+ flushCmd = 4,
+ reInitCmd = 5,
+
+ waitCmd = 10,
+ pauseCmd = 11,
+ resumeCmd = 12,
+ callBackCmd = 13
+};
+enum {
+ syncCmd = 14,
+ emptyCmd = 15,
+
+ tickleCmd = 20,
+ requestNextCmd = 21,
+ howOftenCmd = 22,
+ wakeUpCmd = 23,
+ availableCmd = 24,
+ versionCmd = 25,
+ totalLoadCmd = 26,
+ loadCmd = 27,
+
+ scaleCmd = 30,
+ tempoCmd = 31,
+
+ freqDurationCmd = 40,
+ restCmd = 41,
+ freqCmd = 42,
+ ampCmd = 43,
+ timbreCmd = 44,
+ getAmpCmd = 45,
+
+ volumeCmd                     = 46,   /*sound manager 3.0 or later only*/
+ getVolumeCmd                  = 47,   /*sound manager 3.0 or later only*/
+ clockComponentCmd             = 50,   /*sound manager 3.2.1 or later only*/
+ getClockComponentCmd          = 51,   /*sound manager 3.2.1 or later only*/
+ scheduledSoundCmd             = 52,   /*sound manager 3.3 or later only*/
+ linkSoundComponentsCmd        = 53,   /*sound manager 3.3 or later only*/
+
+ waveTableCmd = 60,
+ phaseCmd = 61
+};
+enum {
+
+ soundCmd = 80,
+ bufferCmd = 81,
+ rateCmd = 82,
+ continueCmd = 83,
+ doubleBufferCmd = 84,
+ getRateCmd = 85,
+ rateMultiplierCmd             = 86,
+ getRateMultiplierCmd          = 87,
+
+ sizeCmd = 90,
+ convertCmd = 91,
+
+ stdQLength = 128,
+ dataOffsetFlag = 0x8000,
+
+ waveInitChannelMask = 0x07,
+ waveInitChannel0 = 0x04,
+ waveInitChannel1 = 0x05,
+ waveInitChannel2 = 0x06,
+ waveInitChannel3 = 0x07,
+
+/* channel initialization parameters */
+ initPanMask = 0x0003,						/* mask for right/left pan values */
+ initSRateMask = 0x0030,					/* mask for sample rate values */
+ initStereoMask = 0x00C0,					/* mask for mono/stereo values */
+ initCompMask = 0xFF00,						/* mask for compression IDs */
+
+ initChanLeft = 0x0002						/* left stereo channel */
+};
+enum {
+ initChanRight = 0x0003,					/* right stereo channel */
+ initNoInterp = 0x0004,						/* no linear interpolation */
+ initNoDrop = 0x0008,						/* no drop-sample conversion */
+ initMono = 0x0080,							/* monophonic channel */
+ initStereo = 0x00C0,						/* stereo channel */
+ initMACE3 = 0x0300,						/* MACE 3:1 */
+ initMACE6 = 0x0400,						/* MACE 6:1 */
+
+ initChan0 = 0x0004,						/* channel 0 - wave table only */
+ initChan1 = 0x0005,						/* channel 1 - wave table only */
+ initChan2 = 0x0006,						/* channel 2 - wave table only */
+ initChan3 = 0x0007,						/* channel 3 - wave table only */
+
+ stdSH = 0x00,								/* Standard sound header encode value */
+ extSH = 0xFF,								/* Extended sound header encode value */
+ cmpSH = 0xFE,								/* Compressed sound header encode value */
+
+ notCompressed = 0,							/* compression ID's */
+ twoToOne = 1,
+ eightToThree = 2,
+ threeToOne = 3,
+ sixToOne = 4,
+
+ outsideCmpSH = 0							/* MACE constants */
+};
+enum {
+ insideCmpSH = 1,
+ aceSuccess = 0,
+ aceMemFull = 1,
+ aceNilBlock = 2,
+ aceBadComp = 3,
+ aceBadEncode = 4,
+ aceBadDest = 5,
+ aceBadCmd = 6,
+ sixToOnePacketSize = 8,
+ threeToOnePacketSize = 16,
+ stateBlockSize = 64,
+ leftOverBlockSize = 32,
+
+ firstSoundFormat = 0x0001,					/* general sound format */
+ secondSoundFormat = 0x0002,				/* special sampled sound format (HyperCard) */
+
+ dbBufferReady = 0x00000001,				/* double buffer is filled */
+ dbLastBuffer = 0x00000004,					/* last double buffer to play */
+
+ sysBeepDisable = 0x0000,					/* SysBeep() enable flags */
+ sysBeepEnable = 0x0001,
+
+ unitTypeNoSelection = 0xFFFF,				/* unitTypes for AudioSelection.unitType */
+ unitTypeSeconds = 0x0000
+};
+
+
+/*   Structures for Sound Driver   */
+
+
+typedef unsigned char FreeWave[30001];
+
+struct FFSynthRec {
+ short mode;
+ Fixed count;
+ FreeWave waveBytes;
+};
+
+typedef struct FFSynthRec FFSynthRec;
+typedef FFSynthRec *FFSynthPtr;
+
+struct Tone {
+ short count;
+ short amplitude;
+ short duration;
+};
+
+typedef struct Tone Tone;
+
+
+typedef Tone Tones[5001];
+
+struct SWSynthRec {
+ short mode;
+ Tones triplets;
+};
+
+typedef struct SWSynthRec SWSynthRec;
+typedef SWSynthRec *SWSynthPtr;
+
+
+typedef unsigned char Wave[256];
+typedef Wave *WavePtr;
+
+struct FTSoundRec {
+ short duration;
+ Fixed sound1Rate;
+ long sound1Phase;
+ Fixed sound2Rate;
+ long sound2Phase;
+ Fixed sound3Rate;
+ long sound3Phase;
+ Fixed sound4Rate;
+ long sound4Phase;
+ WavePtr sound1Wave;
+ WavePtr sound2Wave;
+ WavePtr sound3Wave;
+ WavePtr sound4Wave;
+};
+
+typedef struct FTSoundRec FTSoundRec;
+typedef FTSoundRec *FTSndRecPtr;
+
+struct FTSynthRec {
+ short mode;
+ FTSndRecPtr sndRec;
+};
+
+typedef struct FTSynthRec FTSynthRec;
+typedef FTSynthRec *FTSynthPtr;
+
+
+typedef pascal void (*SndCompletionProcPtr)(void);
+
+/*   Structures for Sound Manager   */
+
+struct SndCommand {
+ unsigned short cmd;
+ short param1;
+ long param2;
+};
+
+typedef struct SndCommand SndCommand;
+
+
+typedef long Time;							/* in half milliseconds */
+
+
+
+typedef struct SndChannel SndChannel;
+typedef SndChannel *SndChannelPtr;
+
+
+typedef pascal void (*SndCallBackProcPtr)(SndChannelPtr chan, SndCommand cmd);
+
+struct SndChannel {
+    struct SndChannel *nextChan;
+    Ptr firstMod;                      		/* reserved for the Sound Manager */
+    SndCallBackProcPtr callBack;
+    long userInfo;
+    Time wait;                         		/* The following is for internal Sound Manager use only.*/
+    SndCommand cmdInProgress;
+    short flags;
+    short qLength;
+    short qHead;                       		/* next spot to read or -1 if empty */
+    short qTail;                       		/* next spot to write = qHead if full */
+    SndCommand queue[stdQLength];
+};
+
+/* MACE structures */
+struct StateBlock {
+ short stateVar[stateBlockSize];
+};
+
+typedef struct StateBlock StateBlock;
+typedef StateBlock *StateBlockPtr;
+
+struct LeftOverBlock {
+ unsigned long count;
+ char sampleArea[leftOverBlockSize];
+};
+
+typedef struct LeftOverBlock LeftOverBlock;
+typedef LeftOverBlock *LeftOverBlockPtr;
+
+struct ModRef {
+ unsigned short modNumber;
+ long modInit;
+};
+
+typedef struct ModRef ModRef;
+
+struct SndListResource {
+ short format;
+ short numModifiers;
+ ModRef modifierPart[1];					/*This is a variable length array*/
+ short numCommands;
+ SndCommand commandPart[1];					/*This is a variable length array*/
+ char dataPart[1];							/*This is a variable length array*/
+};
+
+typedef struct SndListResource SndListResource;
+typedef SndListResource *SndListPtr;
+
+struct SoundHeader {
+ Ptr samplePtr;								/* if NIL then samples are in sampleArea */
+ unsigned long length;						/* length of sound in bytes */
+ Fixed sampleRate;							/* sample rate for this sound */
+ unsigned long loopStart;					/* start of looping portion */
+ unsigned long loopEnd;						/* end of looping portion */
+ unsigned char encode;						/* header encoding */
+ unsigned char baseFrequency;				/* baseFrequency value */
+ char sampleArea[1];
+};
+
+typedef struct SoundHeader SoundHeader;
+typedef SoundHeader *SoundHeaderPtr;
+
+struct CmpSoundHeader {
+ Ptr samplePtr;								/* if nil then samples are in sample area */
+ unsigned long numChannels;					/* number of channels i.e. mono = 1 */
+ Fixed sampleRate;							/* sample rate in Apples Fixed point representation */
+ unsigned long loopStart;					/* loopStart of sound before compression */
+ unsigned long loopEnd;						/* loopEnd of sound before compression */
+ unsigned char encode;						/* data structure used , stdSH, extSH, or cmpSH */
+ unsigned char baseFrequency;				/* same meaning as regular SoundHeader */
+ unsigned long numFrames;					/* length in frames ( packetFrames or sampleFrames ) */
+ extended80 AIFFSampleRate;					/* IEEE sample rate */
+ Ptr markerChunk;							/* sync track */
+ Ptr futureUse1;							/* reserved by Apple */
+ Ptr futureUse2;							/* reserved by Apple */
+ StateBlockPtr stateVars;					/* pointer to State Block */
+ LeftOverBlockPtr leftOverSamples;			/* used to save truncated samples between compression calls */
+ unsigned short compressionID;				/* 0 means no compression, non zero means compressionID */
+ unsigned short packetSize;					/* number of bits in compressed sample packet */
+ unsigned short snthID;						/* resource ID of Sound Manager snth that contains NRT C/E */
+ unsigned short sampleSize;					/* number of bits in non-compressed sample */
+ char sampleArea[1];						/* space for when samples follow directly */
+};
+
+typedef struct CmpSoundHeader CmpSoundHeader;
+typedef CmpSoundHeader *CmpSoundHeaderPtr;
+
+struct ExtSoundHeader {
+ Ptr samplePtr;								/* if nil then samples are in sample area */
+ unsigned long numChannels;					/* number of channels,  ie mono = 1 */
+ Fixed sampleRate;							/* sample rate in Apples Fixed point representation */
+ unsigned long loopStart;					/* same meaning as regular SoundHeader */
+ unsigned long loopEnd;						/* same meaning as regular SoundHeader */
+ unsigned char encode;						/* data structure used , stdSH, extSH, or cmpSH */
+ unsigned char baseFrequency;				/* same meaning as regular SoundHeader */
+ unsigned long numFrames;					/* length in total number of frames */
+ extended80 AIFFSampleRate;					/* IEEE sample rate */
+ Ptr markerChunk;							/* sync track */
+ Ptr instrumentChunks;						/* AIFF instrument chunks */
+ Ptr AESRecording;
+ unsigned short sampleSize;					/* number of bits in sample */
+ unsigned short futureUse1;					/* reserved by Apple */
+ unsigned long futureUse2;					/* reserved by Apple */
+ unsigned long futureUse3;					/* reserved by Apple */
+ unsigned long futureUse4;					/* reserved by Apple */
+ char sampleArea[1];						/* space for when samples follow directly */
+};
+
+typedef struct ExtSoundHeader ExtSoundHeader;
+typedef ExtSoundHeader *ExtSoundHeaderPtr;
+
+struct ConversionBlock {
+ short destination;
+ short unused;
+ CmpSoundHeaderPtr inputPtr;
+ CmpSoundHeaderPtr outputPtr;
+};
+
+typedef struct ConversionBlock ConversionBlock;
+typedef ConversionBlock *ConversionBlockPtr;
+
+struct SMStatus {
+ short smMaxCPULoad;
+ short smNumChannels;
+ short smCurCPULoad;
+};
+
+typedef struct SMStatus SMStatus;
+typedef SMStatus *SMStatusPtr;
+
+struct SCStatus {
+ Fixed scStartTime;
+ Fixed scEndTime;
+ Fixed scCurrentTime;
+ Boolean scChannelBusy;
+ Boolean scChannelDisposed;
+ Boolean scChannelPaused;
+ Boolean scUnused;
+ unsigned long scChannelAttributes;
+ long scCPULoad;
+};
+
+typedef struct SCStatus SCStatus;
+typedef SCStatus *SCStatusPtr;
+
+struct AudioSelection {
+ long unitType;
+ Fixed selStart;
+ Fixed selEnd;
+};
+
+typedef struct AudioSelection AudioSelection;
+typedef AudioSelection *AudioSelectionPtr;
+
+struct SndDoubleBuffer {
+ long dbNumFrames;
+ long dbFlags;
+ long dbUserInfo[2];
+ char dbSoundData[1];
+};
+
+typedef struct SndDoubleBuffer SndDoubleBuffer;
+typedef SndDoubleBuffer *SndDoubleBufferPtr;
+
+
+typedef pascal void (*SndDoubleBackProcPtr) (SndChannelPtr channel,
+           SndDoubleBufferPtr doubleBufferPtr);
+
+struct SndDoubleBufferHeader {
+ short dbhNumChannels;
+ short dbhSampleSize;
+ short dbhCompressionID;
+ short dbhPacketSize;
+ Fixed dbhSampleRate;
+ SndDoubleBufferPtr dbhBufferPtr[2];
+ SndDoubleBackProcPtr dbhDoubleBack;
+};
+
+typedef struct SndDoubleBufferHeader SndDoubleBufferHeader;
+typedef SndDoubleBufferHeader *SndDoubleBufferHeaderPtr;
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+pascal OSErr SndDoCommand(SndChannelPtr chan,const SndCommand *cmd,Boolean noWait)
+ = 0xA803; 
+pascal OSErr SndDoImmediate(SndChannelPtr chan,const SndCommand *cmd)
+ = 0xA804; 
+pascal OSErr SndNewChannel(SndChannelPtr *chan,short synth,long init,SndCallBackProcPtr userRoutine)
+ = 0xA807; 
+pascal OSErr SndDisposeChannel(SndChannelPtr chan,Boolean quietNow)
+ = 0xA801; 
+pascal OSErr SndPlay(SndChannelPtr chan,Handle sndHdl,Boolean async)
+ = 0xA805; 
+pascal OSErr SndAddModifier(SndChannelPtr chan,ProcPtr modifier,short id,
+ long init)
+ = 0xA802; 
+pascal OSErr SndControl(short id,SndCommand *cmd)
+ = 0xA806; 
+
+pascal void SetSoundVol(short level); 
+#pragma parameter GetSoundVol(__A0)
+pascal void GetSoundVol(short *level)
+ = {0x4218,0x10B8,0x0260}; 
+pascal void StartSound(const void *synthRec,long numBytes,SndCompletionProcPtr completionRtn); 
+pascal void StopSound(void); 
+pascal Boolean SoundDone(void); 
+
+pascal NumVersion SndSoundManagerVersion(void)
+ = {0x203C,0x000C,0x0008,0xA800}; 
+pascal OSErr SndStartFilePlay(SndChannelPtr chan,short fRefNum,short resNum,
+ long bufferSize,void *theBuffer,AudioSelectionPtr theSelection,ProcPtr theCompletion,
+ Boolean async)
+ = {0x203C,0x0D00,0x0008,0xA800}; 
+pascal OSErr SndPauseFilePlay(SndChannelPtr chan)
+ = {0x203C,0x0204,0x0008,0xA800}; 
+pascal OSErr SndStopFilePlay(SndChannelPtr chan,Boolean async)
+ = {0x203C,0x0308,0x0008,0xA800}; 
+pascal OSErr SndChannelStatus(SndChannelPtr chan,short theLength,SCStatusPtr theStatus)
+ = {0x203C,0x0010,0x0008,0xA800}; 
+pascal OSErr SndManagerStatus(short theLength,SMStatusPtr theStatus)
+ = {0x203C,0x0014,0x0008,0xA800}; 
+pascal void SndGetSysBeepState(short *sysBeepState)
+ = {0x203C,0x0018,0x0008,0xA800}; 
+pascal OSErr SndSetSysBeepState(short sysBeepState)
+ = {0x203C,0x001C,0x0008,0xA800}; 
+pascal OSErr SndPlayDoubleBuffer(SndChannelPtr chan,SndDoubleBufferHeaderPtr theParams)
+ = {0x203C,0x0020,0x0008,0xA800}; 
+pascal OSErr GetSysBeepVolume(long *level)
+ = {0x203C,0x0224,0x0018,0xA800};
+
+pascal NumVersion MACEVersion(void)
+ = {0x203C,0x0000,0x0010,0xA800}; 
+pascal void Comp3to1(const void *inBuffer,void *outBuffer,unsigned long cnt,
+ const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+ = {0x203C,0x0004,0x0010,0xA800}; 
+pascal void Exp1to3(const void *inBuffer,void *outBuffer,unsigned long cnt,
+ const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+ = {0x203C,0x0008,0x0010,0xA800}; 
+pascal void Comp6to1(const void *inBuffer,void *outBuffer,unsigned long cnt,
+ const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+ = {0x203C,0x000C,0x0010,0xA800}; 
+pascal void Exp1to6(const void *inBuffer,void *outBuffer,unsigned long cnt,
+ const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+ = {0x203C,0x0010,0x0010,0xA800}; 
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/Interfaces/CIncludes/Sound.h.idump b/Interfaces/CIncludes/Sound.h.idump
new file mode 100644
--- /dev/null
+++ b/Interfaces/CIncludes/Sound.h.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Interfaces/CIncludes/Sound.h.rdump b/Interfaces/CIncludes/Sound.h.rdump
new file mode 100644
--- /dev/null
+++ b/Interfaces/CIncludes/Sound.h.rdump
@@ -0,0 +1,45 @@
+#if 0
+data '????' (0, "Header as fake resource (not for Rez)") {
+	$"0002 0031 0032 0002 0031 005A 000F 0061"            /* ...1.2...1.Z...a */
+	$"6D70 436D 6420 4551 5520 3433 2000 0055"            /* mpCmd EQU 43 ..U */
+	$"0753 6F75 6E64 2E68 0200 0000 5445 5854"            /* .Sound.h....TEXT */
+	$"4D50 5320 0000 0000 0000 0000 0000 014D"            /* MPS ...........M */
+	$"0000 5445 5854 4D50 5320 0000 0000 0000"            /* ..TEXTMPS ...... */
+	$"0000 0000 0000 0000 0000 0000 0000 0000"            /* ................ */
+	$"0000 A664 D9C0 0000 0000 0000 021B 0000"            /* ...d............ */
+	$"0000 01C0 4341 5244 0000 3B1E 0000 0000"            /* ....CARD..;..... */
+	$"0000 0000 0000 0000 0000 0000 0000 0000"            /* ................ */
+	$"0000 202A 0000 122E 0000 0000 0000 0000"            /* .. *............ */
+	$"001A 0000 0160 0009 0011 0031 322F 3131"            /* .....`.....12/11 */
+	$"2F38 3720 353A 3533 2041 4D00 0002 0006"            /* /87 5:53 AM..... */
+	$"0053 6F75 6E64 0003 000A 0074 696D 6272"            /* .Sound.....timbr */
+	$"6543 6D64 0004 0003 0034 3400 0005 0006"            /* eCmd.....44..... */
+	$"0024 3030 3332 000C 000C 0052 6F6E 204D"            /* .$0032.....Ron M */
+};
+#endif
+
+data 'vers' (1) {
+	$"0321 8000 0000 0533 2E32 2E31 2833 2E32"            /* .!.....3.2.1(3.2 */
+	$"2E31 2C20 A920 4170 706C 6520 436F 6D70"            /* .1, . Apple Comp */
+	$"7574 6572 2C20 496E 632E 2031 3938 352D"            /* uter, Inc. 1985- */
+	$"3139 3932 2E"                                       /* 1992. */
+};
+
+data 'vers' (2, purgeable) {
+	$"0330 8000 0000 0333 2E33 074D 5057 2033"            /* .0.....3.3.MPW 3 */
+	$"2E33"                                               /* .3 */
+};
+
+data 'MPSR' (1005) {
+	$"0009 4D6F 6E61 636F 00FF 001F 01E1 01E2"            /* ..Monaco........ */
+	$"7FFF 015E 0009 000A 7FFF 015F 000A 01E2"            /* ...^......._.... */
+	$"7FFF 0006 0004 0031 000A 015D 01E0 0031"            /* .......1...]...1 */
+	$"000A 015D 01E0 A664 D9C0 0000 0000 0000"            /* ...]...d........ */
+	$"0000 0000 0000 0100"                                /* ........ */
+};
+
+data 'MPSR' (1008) {
+	$"0031 000A 015D 01E0 0031 000A 015D 01E0"            /* .1...]...1...].. */
+	$"0000 0000 0000 0000 0000 0000 0000"                 /* .............. */
+};
+
diff --git a/Interfaces/CIncludes/Types.h b/Interfaces/CIncludes/Types.h
--- a/Interfaces/CIncludes/Types.h
+++ b/Interfaces/CIncludes/Types.h
@@ -72,6 +72,14 @@
 
 #define noErr 0			/*All is well*/
 
+/* hacked in from Universal Interfaces 3.4 */
+typedef unsigned char                   UInt8;
+typedef signed char                     SInt8;
+typedef unsigned short                  UInt16;
+typedef signed short                    SInt16;
+typedef unsigned long                   UInt32;
+typedef signed long                     SInt32;
+
 /* common aliases for C unsigned types */
 typedef unsigned char	uchar;
 typedef unsigned short	ushort;
diff --git a/Internal/Asm/AppleDeskBusPriv.a b/Internal/Asm/AppleDeskBusPriv.a
--- a/Internal/Asm/AppleDeskBusPriv.a
+++ b/Internal/Asm/AppleDeskBusPriv.a
@@ -53,7 +53,7 @@ resetCmd		EQU			$00					; Command for Bus Reset
 kbdAddr   		EQU 		$02   				; keyboard type device 
 mouseAddr 		EQU 		$03   				; mouse type device 
 numFDBAdr 		EQU 		16   				; number of avaiblae FDB address 
-moveTime  		EQU 		50    				; number of times to move device 
+moveTime  		EQU 		10    				; number of times to move device 
 
 				IF IopADB THEN
 
@@ -127,7 +127,7 @@ hasDev			ds.w	1	    			; every bit corresponds to an device address
 											; 1 = device is present in address (2 bytes)
 devMap			ds.w	1	  				; device address map (2 bytes)
 
-				ds.l	1					; unused space												<6>
+DeviceBase		ds.l	1					; unused space												<6>
 				ds.l	1					; •• Now Used! ••  Pointer to Extended ADB Data (4 bytes)	<6>
 				ds.l	1					; unused space												<6>
 				
diff --git a/Internal/Asm/ColorEqu.a b/Internal/Asm/ColorEqu.a
--- a/Internal/Asm/ColorEqu.a
+++ b/Internal/Asm/ColorEqu.a
@@ -266,7 +266,7 @@ PMFlag		EQU		$8000			; flag to say it's a new pixMap
 cPortFlag	EQU		$C000			; isPixMap+isCPort
 pixVersion	EQU		$0000			; isPixMap
 
-qdStackXtra	EQU		$0640			; stack space left for interrupts		<1.4> BAL
+qdStackXtra	EQU		$0800			; stack space left for interrupts		<1.4> BAL
 
 isPixMap	EQU		15				; for testing high bit of pRowbytes
 isCPort		EQU		14				; indicates that "bitmap" belongs to port
@@ -376,7 +376,7 @@ CCSTATEREGS     EQU     CCDEPTH+2       ;[16 BYTES] STATE INFO OF SAVED DATA
 CCBYTES			EQU		CCSTATEREGS+16	;[WORD] ROWBYTES OF EXPANDED DATA
 CCMAXDEPTH		EQU		CCBYTES+2		;[WORD] MAXIMUM SCREEN DEPTH
 
-CCSAVEREC		EQU		CCMAXDEPTH+2	;SIZE OF CURSOR SAVE AREA
+CCSAVEREC		EQU		CCMAXDEPTH+2+8	;SIZE OF CURSOR SAVE AREA
 
 ;	Font Manager low mem
 ;
diff --git a/Internal/Asm/CrsrDevEqu.a b/Internal/Asm/CrsrDevEqu.a
--- a/Internal/Asm/CrsrDevEqu.a
+++ b/Internal/Asm/CrsrDevEqu.a
@@ -90,6 +90,8 @@ denom				ds.w	1					; Private: fraction of the errors to use next time
 spread				ds.w	1					; Private: Number of samples to spread errors over
 newData				ds.b	1					; Private: set when deltas are new
 					ds.b	1					;  align
+					
+					ds.b	4					; new
 
 CrsrDevSize			EQU		*
 					ENDR
diff --git a/Internal/Asm/DialogsPriv.a b/Internal/Asm/DialogsPriv.a
--- a/Internal/Asm/DialogsPriv.a
+++ b/Internal/Asm/DialogsPriv.a
@@ -67,10 +67,10 @@ selectDMgrCite4						EQU			-5
 paramWordsDMgrCite4					EQU			10
 
 selectDMgrCitationsSH				EQU			-4
-paramWordsDMgrCitationsSH			EQU			7
+paramWordsDMgrCitationsSH			EQU			5
 
 selectDMgrCitationsCH				EQU			-3
-paramWordsDMgrCitationsCH			EQU			5
+paramWordsDMgrCitationsCH			EQU			7
 
 selectDMgrPopMenuState				EQU			-2
 paramWordsDMgrPopMenuState			EQU			0
diff --git a/Internal/Asm/EDiskEqu.a b/Internal/Asm/EDiskEqu.a
--- a/Internal/Asm/EDiskEqu.a
+++ b/Internal/Asm/EDiskEqu.a
@@ -219,7 +219,7 @@ slimNoWrites	equ		3				; bit 3 = 1 if software write protected
 
 bRamDisk		EQU		$70000000		; base of Ram Disk area (32 bit mode)				<T7>
 
-MinRamDiskSize	EQU		$00030000		; minimum disk size is 192k							<T6>
+MinRamDiskSize	EQU		$00068000		; minimum disk size is 416k							<T6>
 MaxRamDiskSize	EQU		$0FF00000		; maximum disk size is 255MB 						<MC4>
 MinHeapSize		EQU		$00260000		; must have at least ≈2.5 megs free for heap		<LW5>
 
diff --git a/Internal/Asm/InternalOnlyEqu.a b/Internal/Asm/InternalOnlyEqu.a
--- a/Internal/Asm/InternalOnlyEqu.a
+++ b/Internal/Asm/InternalOnlyEqu.a
@@ -237,35 +237,71 @@ DockingGlobals	EQU		$1FF8				; pointer to docking globals							<H12>
 ;	software.
 ;_______________________________________________________________________
 
-ProcessorInfoPtr		equ		$5FFFEFD8	; logical address of ProcessorInfo record
-ProcessorInfoVer		equ		$5FFFEFDC	; version number of ProcessorInfo record
-ProcessorInfoLen		equ		$5FFFEFDE	; length of ProcessorInfo record
+ProcessorInfoPtr		equ		$68FFEFD8	; logical address of ProcessorInfo record
+ProcessorInfoVer		equ		$68FFEFDC	; version number of ProcessorInfo record
+ProcessorInfoLen		equ		$68FFEFDE	; length of ProcessorInfo record
 
 ProcessorInfo			record	0,increment
-ProcessorVersionReg		ds.l	1			; contents of the PVR special purpose register
-CpuClockRateHz			ds.l	1			; CPU Clock frequency
-BusClockRateHz			ds.l	1			; Bus Clock frequency
-DecClockRateHz			ds.l	1			; Decrementer Clock frequency
-PageSize				ds.l	1			; number of bytes in a memory page
-DataCacheTotalSize		ds.l	1			; number of bytes in the Data Cache
-InstCacheTotalSize		ds.l	1			; number of bytes in the Instruction Cache
-CoherencyBlockSize		ds.w	1			; number of bytes in a Coherency Block
-ReservationGranuleSize	ds.w	1			; number of bytes in a Reservation Granule
-CombinedCaches			ds.w	1			; 1 <- combined or no cache, 0 <- split cache
-InstCacheLineSize		ds.w	1			; number of bytes in a Line of the Instruction Cache
-DataCacheLineSize		ds.w	1			; number of bytes in a Line of the Data Cache
-DataCacheBlockSizeTouch	ds.w	1			; number of bytes in a Block for DCBT DCBTST
-InstCacheBlockSize		ds.w	1			; number of bytes in a Block of the Instruction Cache
-DataCacheBlockSize		ds.w	1			; number of bytes in a Block of the Data Cache
-InstCacheAssociativity	ds.w	1			; Associativity of the Instruction Cache
-DataCacheAssociativity	ds.w	1			; Associativity of the Data Cache
-
-TransCacheTotalSize		ds.w	1			; number of entries in the Translation Cache
-TransCacheAssociativity	ds.w	1			; Associativity of the Translation Cache
-						align	32			; pad to nice cache block alignment
-Size					equ		*-ProcessorInfo
+ProcessorVersionReg		ds.l	1			; 000 ; contents of the PVR special purpose register
+CpuClockRateHz			ds.l	1			; 004 ; CPU Clock frequency
+BusClockRateHz			ds.l	1			; 008 ; Bus Clock frequency
+DecClockRateHz			ds.l	1			; 00c ; Decrementer Clock frequency
+
+Ovr
+PageSize				ds.l	1			; 010 ; number of bytes in a memory page
+DataCacheTotalSize		ds.l	1			; 014 ; number of bytes in the Data Cache
+InstCacheTotalSize		ds.l	1			; 018 ; number of bytes in the Instruction Cache
+CoherencyBlockSize		ds.w	1			; 01c ; number of bytes in a Coherency Block
+ReservationGranuleSize	ds.w	1			; 01e ; number of bytes in a Reservation Granule
+CombinedCaches			ds.w	1			; 020 ; 1 <- combined or no cache, 0 <- split cache
+InstCacheLineSize		ds.w	1			; 022 ; number of bytes in a Line of the Instruction Cache
+DataCacheLineSize		ds.w	1			; 024 ; number of bytes in a Line of the Data Cache
+DataCacheBlockSizeTouch	ds.w	1			; 026 ; number of bytes in a Block for DCBT DCBTST
+InstCacheBlockSize		ds.w	1			; 028 ; number of bytes in a Block of the Instruction Cache
+DataCacheBlockSize		ds.w	1			; 02a ; number of bytes in a Block of the Data Cache
+InstCacheAssociativity	ds.w	1			; 02c ; Associativity of the Instruction Cache
+DataCacheAssociativity	ds.w	1			; 02e ; Associativity of the Data Cache
+
+TransCacheTotalSize		ds.w	1			; 030 ; number of entries in the Translation Cache
+TransCacheAssociativity	ds.w	1			; 032 ; Associativity of the Translation Cache
+OvrEnd
+
+;	These fields were added to report information about back-side L2 caches
+
+ProcessorL2DSize		ds.l	1			; 034 ; Size of back-side L2 Dcache
+ProcessorL2ISize		ds.l	1			; 038 ; Size of back-side L2 Icache
+ProcessorL2Combined		ds.w	1			; 03c ; 1 <- combined or no cache, 0 <- split cache
+ProcessorL2IBlockSize	ds.w	1			; 03e ; Block size of back-side I L2 cache
+ProcessorL2DBlockSize	ds.w	1			; 040 ; Block size of back-side D L2 cache
+ProcessorL2IAssoc		ds.w	1			; 042 ; Associativity of L2 I
+ProcessorL2DAssoc		ds.w	1			; 044 ; Associativity of L2 D
+
+filler1					ds.w	1			; 046 ; align to long
+
+;	   ProcessorFlags - Definitions for the processor flags field. These are bit positions,
+;						as in 1 << hasVMX, and not masks.
+hasL2CR					equ		0
+hasPLRUL1				equ		1
+hasTAU					equ		2
+hasVMX					equ		3
+unknownFlag				equ		4
+hasExtraBATs			equ		5
+ProcessorFlags			ds.l	1			; 048 ; flags to specify processor features
+
+						align	5			; pad to nice cache block alignment
+						
+						org		$05e
+SetToZero				ds.w	1			; 05e ; by same code that sets below
+CpuClockRateHzCopy		ds.l	1			; 060 ; copies by Init.s
+BusClockRateHzCopy		ds.l	1			; 064 ; copies by Init.s
+DecClockRateHzCopy		ds.l	1			; 068 ; copies by Init.s
+
+						ds.b	$34
+Size					equ		*
 						endr
 
+
+
 ;_______________________________________________________________________
 ;	System Info Record
 ;
@@ -273,70 +309,112 @@ Size					equ		*-ProcessorInfo
 ;	software.
 ;_______________________________________________________________________
 
-NKSystemInfoPtr			equ		$5FFFEFF0	; logical address of NKSystemInfo record
-NKSystemInfoVer			equ		$5FFFEFF4	; version number of NKSystemInfo record
-NKSystemInfoLen			equ		$5FFFEFF6	; length of NKSystemInfo record
+NKSystemInfoPtr			equ		$68FFEFF0	; logical address of NKSystemInfo record
+NKSystemInfoVer			equ		$68FFEFF4	; version number of NKSystemInfo record
+NKSystemInfoLen			equ		$68FFEFF6	; length of NKSystemInfo record
 
 NKSystemInfo			record	0,increment
-PhysicalMemorySize		ds.l	1			; Number of bytes in Physical RAM
-UsableMemorySize		ds.l	1			; Number of bytes in Usable RAM
-LogicalMemorySize		ds.l	1			; Number of bytes in Logical RAM
-HashTableSize			ds.l	1			; Number of bytes in Memory Hash Table
-
-L2DataCacheTotalSize	ds.l	1			; number of bytes in the L2 Data Cache
-L2InstCacheTotalSize	ds.l	1			; number of bytes in the L2 Instruction Cache
-L2CombinedCaches		ds.w	1			; 1 <- combined or no cache, 0 <- split cache
-L2InstCacheBlockSize	ds.w	1			; number of bytes in a Block of the L2 Instruction Cache
-L2DataCacheBlockSize	ds.w	1			; number of bytes in a Block of the L2 Data Cache
-L2InstCacheAssociativity ds.w	1			; Associativity of the L2 Instruction Cache
-L2DataCacheAssociativity ds.w	1			; Associativity of the L2 Data Cache
-						ds.b	2			; unused
-
-						ds.b	2			; unused
-FlashManufacturerCode	ds.b	1			; Flash ROM Manufacturer code
-FlashDeviceCode			ds.b	1			; Flash ROM Device code
-FlashStart				ds.l	1			; Starting address of Flash ROM
-FlashSize				ds.l	1			; Number of bytes in  Flash ROM
-
-						align	16
-Bank0Start				ds.l	1			; Starting address of RAM bank 0
-Bank0Size				ds.l	1			; Number of bytes in  RAM bank 0
-Bank1Start				ds.l	1			; Starting address of RAM bank 1
-Bank1Size				ds.l	1			; Number of bytes in  RAM bank 1
-Bank2Start				ds.l	1			; Starting address of RAM bank 2
-Bank2Size				ds.l	1			; Number of bytes in  RAM bank 2
-Bank3Start				ds.l	1			; Starting address of RAM bank 3
-Bank3Size				ds.l	1			; Number of bytes in  RAM bank 3
-Bank4Start				ds.l	1			; Starting address of RAM bank 4
-Bank4Size				ds.l	1			; Number of bytes in  RAM bank 4
-Bank5Start				ds.l	1			; Starting address of RAM bank 5
-Bank5Size				ds.l	1			; Number of bytes in  RAM bank 5
-Bank6Start				ds.l	1			; Starting address of RAM bank 6
-Bank6Size				ds.l	1			; Number of bytes in  RAM bank 6
-Bank7Start				ds.l	1			; Starting address of RAM bank 7
-Bank7Size				ds.l	1			; Number of bytes in  RAM bank 7
-Bank8Start				ds.l	1			; Starting address of RAM bank 8
-Bank8Size				ds.l	1			; Number of bytes in  RAM bank 8
-Bank9Start				ds.l	1			; Starting address of RAM bank 9
-Bank9Size				ds.l	1			; Number of bytes in  RAM bank 9
-Bank10Start				ds.l	1			; Starting address of RAM bank 10
-Bank10Size				ds.l	1			; Number of bytes in  RAM bank 10
-Bank11Start				ds.l	1			; Starting address of RAM bank 11
-Bank11Size				ds.l	1			; Number of bytes in  RAM bank 11
-Bank12Start				ds.l	1			; Starting address of RAM bank 12
-Bank12Size				ds.l	1			; Number of bytes in  RAM bank 12
-Bank13Start				ds.l	1			; Starting address of RAM bank 13
-Bank13Size				ds.l	1			; Number of bytes in  RAM bank 13
-Bank14Start				ds.l	1			; Starting address of RAM bank 14
-Bank14Size				ds.l	1			; Number of bytes in  RAM bank 14
-Bank15Start				ds.l	1			; Starting address of RAM bank 15
-Bank15Size				ds.l	1			; Number of bytes in  RAM bank 15
-						align	32			; pad to nice cache block alignment
-MaxBanks				equ		16			; 16 banks, 0…15
-Size					equ		*-SystemInfo
+PhysicalMemorySize		ds.l	1			; 000 ; Number of bytes in Physical RAM
+UsableMemorySize		ds.l	1			; 004 ; Number of bytes in Usable RAM
+LogicalMemorySize		ds.l	1			; 008 ; Number of bytes in Logical RAM
+HashTableSize			ds.l	1			; 00c ; Number of bytes in Memory Hash Table
+
+L2DataCacheTotalSize	ds.l	1			; 010 ; number of bytes in the L2 Data Cache
+L2InstCacheTotalSize	ds.l	1			; 014 ; number of bytes in the L2 Instruction Cache
+L2CombinedCaches		ds.w	1			; 018 ; 1 <- combined or no cache, 0 <- split cache
+L2InstCacheBlockSize	ds.w	1			; 01a ; number of bytes in a Block of the L2 Instruction Cache
+L2DataCacheBlockSize	ds.w	1			; 01c ; number of bytes in a Block of the L2 Data Cache
+L2InstCacheAssociativity ds.w	1			; 01e ; Associativity of the L2 Instruction Cache
+L2DataCacheAssociativity ds.w	1			; 020 ; Associativity of the L2 Data Cache
+						ds.b	2			; 022 ; unused
+
+						ds.b	2			; 024 ; unused
+FlashManufacturerCode	ds.b	1			; 026 ; Flash ROM Manufacturer code
+FlashDeviceCode			ds.b	1			; 027 ; Flash ROM Device code
+FlashStart				ds.l	1			; 028 ; Starting address of Flash ROM
+FlashSize				ds.l	1			; 02c ; Number of bytes in  Flash ROM
+
+Bank0Start				ds.l	1			; 030 ; Starting address of RAM bank 0
+Bank0Size				ds.l	1			; 034 ; Number of bytes in  RAM bank 0
+Bank1Start				ds.l	1			; 038 ; Starting address of RAM bank 1
+Bank1Size				ds.l	1			; 03c ; Number of bytes in  RAM bank 1
+Bank2Start				ds.l	1			; 040 ; Starting address of RAM bank 2
+Bank2Size				ds.l	1			; 044 ; Number of bytes in  RAM bank 2
+Bank3Start				ds.l	1			; 048 ; Starting address of RAM bank 3
+Bank3Size				ds.l	1			; 04c ; Number of bytes in  RAM bank 3
+Bank4Start				ds.l	1			; 050 ; Starting address of RAM bank 4
+Bank4Size				ds.l	1			; 054 ; Number of bytes in  RAM bank 4
+Bank5Start				ds.l	1			; 058 ; Starting address of RAM bank 5
+Bank5Size				ds.l	1			; 05c ; Number of bytes in  RAM bank 5
+Bank6Start				ds.l	1			; 060 ; Starting address of RAM bank 6
+Bank6Size				ds.l	1			; 064 ; Number of bytes in  RAM bank 6
+Bank7Start				ds.l	1			; 068 ; Starting address of RAM bank 7
+Bank7Size				ds.l	1			; 06c ; Number of bytes in  RAM bank 7
+Bank8Start				ds.l	1			; 070 ; Starting address of RAM bank 8
+Bank8Size				ds.l	1			; 074 ; Number of bytes in  RAM bank 8
+Bank9Start				ds.l	1			; 078 ; Starting address of RAM bank 9
+Bank9Size				ds.l	1			; 07c ; Number of bytes in  RAM bank 9
+Bank10Start				ds.l	1			; 080 ; Starting address of RAM bank 10
+Bank10Size				ds.l	1			; 084 ; Number of bytes in  RAM bank 10
+Bank11Start				ds.l	1			; 088 ; Starting address of RAM bank 11
+Bank11Size				ds.l	1			; 08c ; Number of bytes in  RAM bank 11
+Bank12Start				ds.l	1			; 090 ; Starting address of RAM bank 12
+Bank12Size				ds.l	1			; 094 ; Number of bytes in  RAM bank 12
+Bank13Start				ds.l	1			; 098 ; Starting address of RAM bank 13
+Bank13Size				ds.l	1			; 09c ; Number of bytes in  RAM bank 13
+Bank14Start				ds.l	1			; 0a0 ; Starting address of RAM bank 14
+Bank14Size				ds.l	1			; 0a4 ; Number of bytes in  RAM bank 14
+Bank15Start				ds.l	1			; 0a8 ; Starting address of RAM bank 15
+Bank15Size				ds.l	1			; 0ac ; Number of bytes in  RAM bank 15
+Bank16Start				ds.l	1			; 0b0 ; Starting address of RAM bank 16
+Bank16Size				ds.l	1			; 0b4 ; Number of bytes in  RAM bank 16
+Bank17Start				ds.l	1			; 0b8 ; Starting address of RAM bank 17
+Bank17Size				ds.l	1			; 0bc ; Number of bytes in  RAM bank 17
+Bank18Start				ds.l	1			; 0c0 ; Starting address of RAM bank 18
+Bank18Size				ds.l	1			; 0c4 ; Number of bytes in  RAM bank 18
+Bank19Start				ds.l	1			; 0c8 ; Starting address of RAM bank 19
+Bank19Size				ds.l	1			; 0cc ; Number of bytes in  RAM bank 19
+Bank20Start				ds.l	1			; 0d0 ; Starting address of RAM bank 20
+Bank20Size				ds.l	1			; 0d4 ; Number of bytes in  RAM bank 20
+Bank21Start				ds.l	1			; 0d8 ; Starting address of RAM bank 21
+Bank21Size				ds.l	1			; 0dc ; Number of bytes in  RAM bank 21
+Bank22Start				ds.l	1			; 0e0 ; Starting address of RAM bank 22
+Bank22Size				ds.l	1			; 0e4 ; Number of bytes in  RAM bank 22
+Bank23Start				ds.l	1			; 0e8 ; Starting address of RAM bank 23
+Bank23Size				ds.l	1			; 0ec ; Number of bytes in  RAM bank 23
+Bank24Start				ds.l	1			; 0f0 ; Starting address of RAM bank 24
+Bank24Size				ds.l	1			; 0f4 ; Number of bytes in  RAM bank 24
+Bank25Start				ds.l	1			; 0f8 ; Starting address of RAM bank 25
+Bank25Size				ds.l	1			; 0fc ; Number of bytes in  RAM bank 25
+EndOfBanks
+MaxBanks				equ		26			; Pads out to old struct len (cache block), more to come...
+
+											; Interrupt Support Data
+IntCntrBaseAddr			ds.l	1			; 100 ; Interrupt Controller Base Address  (variable is used since this is a PCI Dev and address is relocatable)
+IntPendingReg			ds.l 	2			; 104 ; Data of current interrupts pending register
+
+											; These fields were added to report information about tightly-coupled L2 caches.
+											; The inline L2 information should be used in situations where there is a CPU
+											; card L2 cache that can coexist with a motherboard L2.
+
+InlineL2DSize			ds.l	1			; 10c ; Size of in-line L2 Dcache
+InlineL2ISize			ds.l	1			; 110 ; Size of in-line L2 Icache
+InlineL2Combined		ds.w	1			; 114 ; 1 <- combined or no cache, 0 <- split cache
+InlineL2IBlockSize		ds.w	1			; 116 ; Block size of in-line I L2 cache
+InlineL2DBlockSize		ds.w	1			; 118 ; Block size of in-line D L2 cache
+InlineL2IAssoc			ds.w	1			; 11a ; Associativity of L2 I
+InlineL2DAssoc			ds.w	1			; 11c ; Associativity of L2 D
+						ds.w	1			; 11e ; pad
+
+											; More Interrupt Support Data
+IntsCompleted			ds.l 	2			; 120 ; completed interrupts
+
+						ds.b	$18
+Size					equ		*
 						endr
 
 
+
 ;_______________________________________________________________________
 ;	Diagnostic Info Record
 ;
@@ -344,19 +422,52 @@ Size					equ		*-SystemInfo
 ;	the NanoKernel, and from the NanoKernel to user mode software.
 ;_______________________________________________________________________
 
-nkDiagInfoPtr			equ		$5FFFEFE8	; logical address of DiagnosticInfo record
-nkDiagInfoVer			equ		$5FFFEFEC	; version number of DiagnosticInfo record
-nkDiagInfoLen			equ		$5FFFEFEE	; length of DiagnosticInfo record
-
-nkDiagInfo				record	0,increment
-						ds.b	236			; it WILL all fit in 256 bytes
-DiagPOSTResult2			ds.l	1			; POST results
-DiagPOSTResult1			ds.l	1			; POST results
-DiagEmoRestart			ds.l	1			; Burn in restart flag
-DiagWarmStartHigh		ds.l	1			; First long of native warm start  (WLSC)		<SM44>
-DiagWarmStartLow		ds.l	1			; Second long of native warm start (SamB)		<SM44>
-						align	32			; pad to nice cache block alignment
-Size					equ		*-nkDiagInfo
+NKDiagInfoPtr			equ		$68FFEFE8	; logical address of DiagnosticInfo record
+NKDiagInfoVer			equ		$68FFEFEC	; version number of DiagnosticInfo record
+NKDiagInfoLen			equ		$68FFEFEE	; length of DiagnosticInfo record
+
+NKDiagInfo				record	0,increment
+BankMBFailOffset		ds.l	1			; 000 ; Mother Board RAM failure code
+BankAFailOffset			ds.l	1			; 004 ; Bank A RAM failure code
+BankBFailOffset			ds.l	1			; 008 ; Bank B RAM failure code
+BankCFailOffset			ds.l	1			; 00c ; Bank C RAM failure code
+
+BankDFailOffset			ds.l	1			; 010 ; Bank D RAM failure code
+BankEFailOffset			ds.l	1			; 014 ; Bank E RAM failure code
+BankFFailOffset			ds.l	1			; 018 ; Bank F RAM failure code
+BankGFailOffset			ds.l	1			; 01c ; Bank G RAM failure code
+
+BankHFailOffset			ds.l	1			; 020 ; Bank H RAM failure code
+CacheFailOffset			ds.l	1			; 024 ; cache failure code
+LongBootParamOffset		ds.l	1			; 028 ; on longBoot this is where the params will be
+POSTTraceOffset			ds.l	1			; 02c ; this tells us what route the POST took
+
+POSTOldWarmOffset		ds.l	1			; 030 ; logged address of old warmstart flag
+POSTOldLongOffset		ds.l	1			; 034 ; logged address of old long boot flag
+POSTOldGlobbOffset		ds.l	1			; 038 ; logged address of old Diagnostic Info Record
+POSTOldParamOffset		ds.l	1			; 03c ; the params from the old diag globb
+
+POSTStartRTCUOffset		ds.l	1			; 040 ; PPC Real Time Clock Upper at start of POST
+POSTStartRTCLOffset		ds.l	1			; 044 ; PPC Real Time Clock Lower at start of POST
+POSTEndRTCUOffset		ds.l	1			; 048 ; PPC Real Time Clock Upper at end of POST
+POSTEndRTCLOffset		ds.l	1			; 04c ; PPC Real Time Clock Lower at end of POST
+
+POSTTestTypeOffset		ds.l	1			; 050 ; when long RAM tests fail test type which failed is put here
+POSTError2Offset		ds.l	1			; 054 ; result codes from tests
+POSTError3Offset		ds.l	1			; 058 ; result codes from tests
+POSTError4Offset		ds.l	1			; 05c ; result codes from tests
+
+RegistersStore			ds.b	140			; 060 ; store all 60x registers here, still fit into 256 bytes size.
+
+;	Everything BEFORE here is new (hence the funny-sized register store)
+
+DiagPOSTResult2			ds.l	1			; 0ec ; POST results
+DiagPOSTResult1			ds.l	1			; 0f0 ; POST results
+DiagLongBootSig			ds.l	1			; 0f4 ; Burn in restart flag
+DiagWarmStartHigh		ds.l	1			; 0f8 ; First long of native warm start  (WLSC)		<SM44>
+DiagWarmStartLow		ds.l	1			; 0fc ; Second long of native warm start (SamB)		<SM44>
+
+Size					equ		*
 						endr
 
 
@@ -368,30 +479,206 @@ Size					equ		*-nkDiagInfo
 ;	software.
 ;_______________________________________________________________________
 
-nkNanoKernelInfoPtr		equ		$5FFFEFE0	; logical address of NanoKernelInfo record
-nkNanoKernelInfoVer		equ		$5FFFEFE4	; version number of NanoKernelInfo record
-nkNanoKernelInfoLen		equ		$5FFFEFE6	; length of NanoKernelInfo record
-
-nkNanoKernelInfo			record	0,increment
-ExceptionCauseCounts	ds.l	32			; counters per exception cause
-NanoKernelCallCounts	ds.l	16			; counters per NanoKernel call
-ExternalIntCount		ds.l	1			; count of External Interrupts
-MisalignmentCount		ds.l	1			; count of Misalignment Interrupts
-FPUReloadCount			ds.l	1			; count of FPU reloads on demand
-DecrementerIntCount		ds.l	1			; count of Decrementer Interrupts
-QuietWriteCount			ds.l	1			; count of Writes to Quiet Read-Only memory
-HashTableCreateCount	ds.l	1			; count of Hash Table Entry creations
-HashTableDeleteCount	ds.l	1			; count of Hash Table Entry deletions
-HashTableOverflowCount	ds.l	1			; count of Hash Table Entry overflows
-EmulatedUnimpInstCount	ds.l	1			; count of Emulated unimplemented instructions
-NCBPtrCacheMissCount	ds.l	1			; count of NCB Pointer cache misses
-ExceptionPropagateCount	ds.l	1			; count of Exceptions propagated to system
-ExceptionForcedCount	ds.l	1			; count of Exceptions forced to system
-						align	8			; align for 64 bit time base counters
-SysContextCpuTime		ds.l	2			; CPU Time used by System Context
-AltContextCpuTime		ds.l	2			; CPU Time used by Alternate Context
-						align	32			; pad to nice cache block alignment
-Size					equ		*-nkNanoKernelInfo
+NKNanoKernelInfoPtr		equ		$68FFEFE0	; logical address of NanoKernelInfo record
+NKNanoKernelInfoVer		equ		$68FFEFE4	; version number of NanoKernelInfo record
+NKNanoKernelInfoLen		equ		$68FFEFE6	; length of NanoKernelInfo record
+
+NKNanoKernelInfo		record	0,increment
+ExceptionCauseCounts	ds.l	32			; 000 ; counters per exception cause
+NanoKernelCallCounts	ds.l	16			; 080 ; counters per NanoKernel call
+ExternalIntCount		ds.l	1			; 0c0 ; count of External Interrupts
+MisalignmentCount		ds.l	1			; 0c4 ; count of Misalignment Interrupts
+FPUReloadCount			ds.l	1			; 0c8 ; count of FPU reloads on demand
+DecrementerIntCount		ds.l	1			; 0cc ; count of Decrementer Interrupts
+QuietWriteCount			ds.l	1			; 0d0 ; count of Writes to Quiet Read-Only memory
+HashTableCreateCount	ds.l	1			; 0d4 ; count of Hash Table Entry creations
+HashTableDeleteCount	ds.l	1			; 0d8 ; count of Hash Table Entry deletions
+HashTableOverflowCount	ds.l	1			; 0dc ; count of Hash Table Entry overflows
+EmulatedUnimpInstCount	ds.l	1			; 0e0 ; count of Emulated unimplemented instructions
+NCBPtrCacheMissCount	ds.l	1			; 0e4 ; count of NCB Pointer cache misses
+ExceptionPropagateCount	ds.l	1			; 0e8 ; count of Exceptions propagated to system
+ExceptionForcedCount	ds.l	1			; 0ec ; count of Exceptions forced to system
+SysContextCpuTime		ds.l	2			; 0f0 ; CPU Time used by System Context
+AltContextCpuTime		ds.l	2			; 0f8 ; CPU Time used by Alternate Context
+
+;	This stuff is new (starts at 0x100)
+
+blueProcessID			ds.l	1			; 100 ; ID of the blue process.
+blueTaskID				ds.l	1			; 104 ; ID of the blue task.
+pageQueueID				ds.l	1			; 108 ; ID of the page fault queue.
+TaskCount				ds.l	1			; 10c ; Number of tasks.
+FreePoolExtendCount		ds.l	1			; 110 ; Number of pages given to the nanokernel.
+
+;rsrv1					ds.l	3			; 114 ; reserved???
+
+;	My additions
+
+						org		$11c
+ConfigFlags				ds.l	1			; 11c ; includes ScreenConsole ... TODO put flag equs here
+NanodbgrFlagShift		equ		1
+NanodbgrFlagBit			equ		31 - NanodbgrFlagShift
+LogFlagShift			equ		3
+LogFlagBit				equ		31 - LogFlagShift
+;	bit 31 always set on replacement, bit 27 set on replacement with ROM 2.7f3 or later
+
+						org		$128
+VMDispatchCountTblPtr	ds.l	1			; 128
+						ds.l	1
+						ds.l	1
+MPDispatchCountTblPtr	ds.l	1			; 134 ; ???????
+AddrSpcSetCtr			ds.l	1			; 138 ; incremented by SetAddrSpcRegisters
+IDCtr					ds.l	1			; 13c
+
+						ds.b	$20
+Size					equ		*
+						endr
+
+
+
+;_______________________________________________________________________
+;	Hardware Info Record
+;
+;	Used to pass hardware information from the NanoKernel to user mode
+;	software.
+;_______________________________________________________________________
+
+NKHWInfoPtr				equ		$68FFEFD0	; logical address of HWInfo record
+NKHWInfoVer				equ		$68FFEFD4	; version number of HWInfo record
+NKHWInfoLen				equ		$68FFEFD6	; length of HWInfo record
+
+NKHWInfo				record	0,increment
+MacROM_Base				ds.l	1			; 000 ; base address (physical) of Mac ROM
+DeviceTreeBase			ds.l	1			; 004 ; base address of the copied device tree properties
+UniversalInfoTableBase	ds.l	1			; 008 ; base address of the Universal Info Table
+ConfigInfoTableBase		ds.l	1			; 00c ; base address of the Config Info Table
+VectorLookupTable		ds.l	1			; 010 ; base address of the interrupt vector lookup table (short *)
+VectorMaskTable			ds.l	1			; 014 ; base address of the interrupt vector mask table (long *)
+
+OpenPICBaseAddr			ds.l	1			; 018 ; OpenPIC base address
+
+ISAMaster8259			ds.l	1			; 01c ; ISA Master 8259 ports (char *)
+ISASlave8259			ds.l	1			; 020 ; ISA Slave 8259 ports (char *)
+InterruptAck8259		ds.l	1			; 024 ; address to read to ack 8259 interrupt (long *)
+
+											; interrupt pending bits (actively changing)
+
+PendingInts				ds.l	2			; 028 ; 64 bits of pending interrupts
+
+											; some Mac I/O device base addresses
+
+ADB_Base				ds.l	1			; 030 ; base address of ADB
+SCSI_DMA_Base			ds.l	1			; 034 ; base address of SCSI DMA registers
+
+											; RTAS related stuff
+
+RTAS_PrivDataArea		ds.l	1			; 038 ; RTAS private data area 
+MacOS_NVRAM_Offset		ds.l	1			; 03c ; offset into nvram to MacOS data
+
+RTAS_NVRAM_Fetch		ds.l	1			; 040 ; token for RTAS NVRAM fetch
+RTAS_NVRAM_Store		ds.l	1			; 044 ; token for RTAS NVRAM store
+RTAS_Get_Clock			ds.l	1			; 048 ; token for RTAS clock get
+RTAS_Set_Clock			ds.l	1			; 04c ; token for RTAS clock set
+RTAS_Restart			ds.l	1			; 050 ; token for RTAS Restart
+RTAS_Shutdown			ds.l	1			; 054 ; token for RTAS Shutdown
+RTAS_Restart_At			ds.l	1			; 058 ; token for RTAS system startup at specified time
+RTAS_EventScan			ds.l	1			; 05c ; token for RTAS event scan
+RTAS_Check_Exception	ds.l	1			; 060 ; token for RTAS check exception
+RTAS_Read_PCI_Config	ds.l	1			; 064 ; token for RTAS read PCI config
+RTAS_Write_PCI_Config	ds.l	1			; 068 ; token for RTAS write PCI config
+
+											; SIO interrupt source numbers for the MPIC
+
+SIOIntVect				ds.w	1			; 06c ; SIO (8259 cascade vector) vector number
+SIOIntBit				ds.w	1			; 06e ; SIO (8259 cascade vector) bit number
+
+Signature				ds.l	1			; 070 ; signature for this record ('Hnfo')
+
+											; more interrupt source numbers
+
+SpuriousIntVect			ds.w	1			; 074 ; spurious vector number
+
+CPU_ID					ds.w	1			; 076 ; the ID of this CPU (universal-tables-related)
+
+SCCAIntVect				ds.w	1			; 078 ; SCC A (non-DMA) vector number
+SCCBIntVect				ds.w	1			; 07a ; SCC B (non-DMA) vector number
+SCSIIntVect				ds.w	1			; 07c ; SCSI vector number
+SCSIDMAIntVect			ds.w	1			; 07e ; SCSI DMA vector number
+VIAIntVect				ds.w	1			; 080 ; VIA vector number
+VIAIntBit				ds.w	1			; 082 ; VIA bit number
+ADBIntVect				ds.w	1			; 084 ; vector number
+NMIIntVect				ds.w	1			; 086 ; NMI vector number
+NMIIntBit				ds.w	1			; 088 ; NMI bit number
+
+											; current (actively changing) interrupt handling variables
+
+ISAPendingInt			ds.w	1			; 08a ; currently pending ISA/8259 interrupt
+CompletedInts			ds.b	8			; 08c ; completed interrupts
+
+nkHWInfoFlagSlowMESH	equ		1			; set if fast MESH doesn't work on this box
+nkHWInfoFlagAsynchMESH	equ		2			; set if Synchronous MESH doesn't work on this box
+nkHWInfoFlagNoCopySWTLB	equ		4			; set if the software TLB walk code for 603 should NOT be copied
+HardwareInfoFlags		ds.l	1			; 094 ; 32 bits of flags (see enum above)
+
+RTAS_Get_PowerOn_Time	ds.l	1			; 098 ; token for RTAS getting time for system startup
+
+						ds.b	$24
+Size					equ		*
+						endr
+
+
+
+;_______________________________________________________________________
+;	Processor State Record
+;
+;	Used to save the state of the processor across sleep.
+;_______________________________________________________________________
+
+NKProcessorStatePtr		equ		$68FFEFC8	; logical address of ProcessorState record
+NKProcessorStateVer		equ		$68FFEFCC	; version number of ProcessorState record
+NKProcessorStateLen		equ		$68FFEFCE	; length of ProcessorState record
+
+NKProcessorState		record	0,increment
+saveDBAT0u				ds.l	1			; 000 ; place to store DBAT0U
+saveDBAT0l				ds.l	1			; 004 ; place to store DBAT0L
+saveDBAT1u				ds.l	1			; 008 ; place to store DBAT1U
+saveDBAT1l				ds.l	1			; 00c ; place to store DBAT1L
+saveDBAT2u				ds.l	1			; 010 ; place to store DBAT2U
+saveDBAT2l				ds.l	1			; 014 ; place to store DBAT2L
+saveDBAT3u				ds.l	1			; 018 ; place to store DBAT3U
+saveDBAT3l				ds.l	1			; 01c ; place to store DBAT3L
+
+saveIBAT0u				ds.l	1			; 020 ; place to store IBAT0U
+saveIBAT0l				ds.l	1			; 024 ; place to store IBAT0L
+saveIBAT1u				ds.l	1			; 028 ; place to store IBAT1U
+saveIBAT1l				ds.l	1			; 02c ; place to store IBAT1L
+saveIBAT2u				ds.l	1			; 030 ; place to store IBAT2U
+saveIBAT2l				ds.l	1			; 034 ; place to store IBAT2L
+saveIBAT3u				ds.l	1			; 038 ; place to store IBAT3U
+saveIBAT3l				ds.l	1			; 03c ; place to store IBAT3L
+
+saveSPRG0				ds.l	1			; 040 ; place to store SPRG0
+saveSPRG1				ds.l	1			; 044 ; place to store SPRG1
+saveSPRG2				ds.l	1			; 048 ; place to store SPRG2
+saveSPRG3				ds.l	1			; 04c ; place to store SPRG3
+
+saveL2CR				ds.l	1			; 050 ; place to store Arthur's L2CR
+
+saveSRR0				ds.l	1			; 054 ; place to store SRR0
+saveSRR1				ds.l	1			; 058 ; place to store SRR1
+saveTBU					ds.l	1			; 05c ; place to store TBU
+saveTBL					ds.l	1			; 060 ; place to store TBL
+saveHID0				ds.l	1			; 064 ; place to store HID0
+saveDEC					ds.l	1			; 068 ; place to store DEC
+saveMSR					ds.l	1			; 06c ; place to store MSR
+saveSDR1				ds.l	1			; 070 ; place to store SDR1
+
+											; saveKernelDataPtr needs to always be right after saveReturnAddr
+											; because of how the code works.  DO NOT CHANGE THIS ORDERING!
+
+saveReturnAddr			ds.l	1			; 074 ; place to store the addr to jump to.
+saveKernelDataPtr		ds.l	1			; 078 ; place to store the KernelDataPtr
+saveContextPtr			ds.l	1			; 07c ; place to store the ContextPtr
+Size					equ		*
 						endr
 
 
diff --git a/Internal/Asm/ResourceMgrPriv.a b/Internal/Asm/ResourceMgrPriv.a
--- a/Internal/Asm/ResourceMgrPriv.a
+++ b/Internal/Asm/ResourceMgrPriv.a
@@ -104,7 +104,7 @@ kPreventFileFromBeingClosedMask	equ	16
 kAllOverrideAttributesMask		equ	kOverrideNextMapMask +				\
 									kDontCountOrIndexDuplicatesMask +	\
 									kTwoDeepMask +						\
-									kPreventFileFromBeingClosedMask
+									kPreventFileFromBeingClosedMask + 32 + 64 + 128
 kAllButOverrideAttributesMask	equ	255 - kAllOverrideAttributesMask 
 
 selectMakeOverrideMap			equ	4
diff --git a/Internal/Asm/ScriptPriv.a b/Internal/Asm/ScriptPriv.a
--- a/Internal/Asm/ScriptPriv.a
+++ b/Internal/Asm/ScriptPriv.a
@@ -802,9 +802,9 @@ smKeySynchKbdMenuState		EQU		-18			; synchronize kbd menu state to current proce
 
 ; private one byte SetScript/GetScript verbs - used by TextEdit in Cube-E					<59>
 
-smScriptSysBase		EQU		-26					; Roman font to use with the system font
-smScriptAppBase		EQU		-28					; Roman font to use with the application font
-smScriptFntBase		EQU		-30					; Roman font to use with all other fonts
+smScriptSysBase		EQU		-281				; Roman font to use with the system font
+smScriptAppBase		EQU		-283				; Roman font to use with the application font
+smScriptFntBase		EQU		-285				; Roman font to use with all other fonts
 ; -----------------------------------------------------------------------------
 ; Script Manager Global record
 ; -----------------------------------------------------------------------------
diff --git a/Internal/Asm/SysPrivateEqu.a b/Internal/Asm/SysPrivateEqu.a
--- a/Internal/Asm/SysPrivateEqu.a
+++ b/Internal/Asm/SysPrivateEqu.a
@@ -214,233 +214,302 @@ IntRegsSize	equ		8*4					; size of IntRegs in bytes - must change if IntRegs cha
 ; Extended Low Memory area available on all machines
 
 ExpandMemRec  		RECORD  	0
-emVersion 			DS.W		1 					; version of expanded memory
-emSize				DS.L		1 					; length of em
-emIntlGlobals 		DS.L		1 					; international globals pointer
-emKeyDeadState		DS.L		1 					; Key1Trans, Key2Trans dead state
-emKeyCache			DS.L		1 					; KCHR keyboard cache
-emIntlDef			DS.L		1					; Reserved for Intl
-emFirstKeyboard		ds.b		1					; flag byte
-emAlign				ds.b		1					; long-align until we need this storage
+emVersion 			DS.W		1 					; 000 ; version of expanded memory
+emSize				DS.L		1 					; 002 ; length of em
+emIntlGlobals 		DS.L		1 					; 006 ; international globals pointer
+emKeyDeadState		DS.L		1 					; 00a ; Key1Trans, Key2Trans dead state
+emKeyCache			DS.L		1 					; 00e ; KCHR keyboard cache
+emIntlDef			DS.L		1					; 012 ; Reserved for Intl
+emFirstKeyboard		ds.b		1					; 016 ; flag byte
+emAlign				ds.b		1					; 017 ; long-align until we need this storage
 emItlCacheSize		equ			16					; bytes in cache
-emItlCache			ds.b		emItlCacheSize		; reserve room for cache
-emItlNeedUnlock		ds.b		1					; for pack6
-emItlDontUnlockYet	ds.b		1					; for pack6										<56>
-emItlFiller			ds.b		2					; Reserved room
-emScriptsInstalled	ds.b		1					; number of installed scripts
-emTwoCursorsFlag	ds.w		1					; indicates split cursor and if emCursor2Rect is high cursor
-emCursor2Rect		ds.w		4					; top, left, bottom, right edges of split cursor: initialized to 0
-emFmtOrderHFlag		ds.b		1					; flag to indicate a handle was allocated
-emDirection			ds.l		1					; direction param for C2P for both offsets
-emMeasureLine		ds.b		1					; flag that says to measure the whole line
-emCleanWordBrk		ds.l		1					; storage for 32-bit clean defWordBrk address
-emNewFont			ds.b		1					; textStyle.tsFont: the only field I fill in
-emNewStyle			ds.w		4					; SetRsrved params: flag.b, textStylePtr.l, mode.w
-emBufferHandle		ds.l		1					; handle for text buffering
-emUnsynchedFlag		ds.b		1					; indicates unsynched keyboard and font
-emTExtra			ds.b		3					; extra TE bytes
-emBufferLen			ds.w		1					; length of text in buffer
-emSERDVars			ds.l		1					; Serial Driver Globals
-emGestalt			ds.l		1					; Gestalt Globals
-emLayoutGlobals		ds.l		1					; Layout Mgr Globals
-emTSMGlobals		ds.l		1					; Text-Service Mgr Globals
-emSplineKey			ds.l		1					; Bass Fonts Globals
-emSnarfGlobals		ds.l		1					; Snarf Man
-emLAPGlobals		ds.l		1					; AppleTalk globals
-emLMgrGlobals		ds.l		1					; LAP Mgr globals
-emHelpGlobals		ds.l		1					; Help Mgr Globals
-emPPCGlobals		ds.l		1					; PPC Mgr globals
-emDataPub			ds.l		1					; Data Publications globals
-emReliability		ds.l		1					; Reliability manager globals
-emjRunSlotHandlrs	ds.l		1					; for slot mgrs
-emFolderCache		ds.l		1					; used by Folder Manager
-
-vDoErase			ds.l		1
-vCaretDisplay		ds.l		1					; Used by TextEdit for vectors
-vGetLRPosition		ds.l		1					;   to patch Rom
-vGetRLPosition		ds.l		1
-vOnLineEnd			ds.l		1
-vCaretInsideRun		ds.l		1
-vSetDirection		ds.l		1
-vGetDirection		ds.l		1
-vGetStylesInOrder	ds.l		1
-vteGetFormatOrder	ds.l		1
-vGetWidth			ds.l		1
-vGetCurScript		ds.l		1
-vOnSameLine			ds.l		1
-vMeasureWidth		ds.l		1
-vMeasureWholeRun	ds.l		1
-vHiliteLineEnds		ds.l		1
-vInvrtRectangle		ds.l		1
-vPixelWidths		ds.l		1
-vTEBufferText		ds.l		1
-vDumpBuffer			ds.l		1
-vCursorMovement		ds.l		1
-vTestRunDirection	ds.l		1
-vBufferChar			ds.l		1
-vSetFont2Keyboard	ds.l		1
-vSetKeyboard2Font	ds.l		1
-vStyleGuts			ds.l		1
-vConcatRuns			ds.l		1
-
-resourceMgrDirID	ds.l		1					; dirID one-shot for Resource Mgr
-emLAPAGlobals		ds.l		1					; LAP Mgr (router) globals
-emMailGlobals		ds.l		1					; AppleMail globals
-emADASGlobals		ds.l		1					; ADAS globals
-
-emELAPGlobals		ds.l		1					; EtherTalk LAP globals
-
-soundMgrGlobals		ds.l		1					; one global for ALL machines
-
-emWindowListGlobals	ds.l		1					; <52> globals for layerless windowing
-
-emDragGlobals		ds.l		1					; <64> globals for dragging stuff (in Finder, etc)
-
-emFSCommon			ds.l		1					; <68> globals for FSCommon Library Modules
-emButtonMgrGlobals	ds.l		1					; <52> <70> globals for Button Manager (Not enUnused1 anymore)
-
-emPack8Globals		ds.w		1					; <52> globals for Apple Event Manager package
-emPack9Globals		ds.w		1					; <52> globals for PPC Browser package
-
-emProcessMgrExists	ds.w		1					; <58> true when Process Mgr is running
-
-emPack11Globals		ds.w		1					; <52> globals for Edition Manager package
-
-emWindowMgrFlags	ds.w		1					; <77> flags to speed CheckUpdateIn (previously emUnused2)
-
-emPack13Globals		ds.w		1					; <52> globals for Data Access Manager package
-emPack14Globals		ds.w		1					; <52> globals for Balloon Help package
-
-emResrvMemSemaphore	ds.l		1					; Semaphore for ResrvMem moved to here. Used to be emUnused4. <57>
-
-emPack15Globals		ds.w		1					; <52> globals for Picture Utilities package
-
-emSerialMgrGlobals	ds.l		1					; <70> globals for Serial Manager (one long out of emUnused3)
-emLanguagePackGlobals	ds.l	1					; <71> globals for LanguagePackExtension (one long out of emUnused3)
-
-emStartTicks		ds.l		1					; PN global used by ListMgrPack
-
-emRectRgn			ds.l		1					; <SM10> global used by WindowMgr routine <PN>
-
-emPPCPromptForUserGlobals ds.l	1					; <59> global used by PPC’s PromptForUser routine
-
-emScrollSpeedGlobals ds.l		1					; <58> global used by scroll speed throttling
-
-emDialogGlobals		ds.l		1					; <53> FM Dialog Manager Globals
-
-emAppleEvents		ds.l		1					; Apple Events (switched for each application)
-
-sysErrorUpdateRect	ds.w		4					; rectangle for updating after SysError box goes away
-
-emItlSysCachePtr	ds.l		1					; pointer to system itl cache				<7><20>
-emScriptMapPtr		ds.l		1					; pointer to script mapping/sorting data	<8>
-emLangMapPtr		ds.l		1					; pointer to language mapping/sorting data	<8>
-
-					ds.l		1					; was emNumer (obsolete), now unused		<11><84>
-					ds.l		1					; was emDenom (obsolete), now unused		<11><84>
-emIconCluts			ds.l		1					; Ptr to global icon info				<13>
-emScriptAppGlobals	ds.l		1					; Handle to application-specific script globals	<16><20><21>
-emAppleEventsGlobal	ds.l		1					; Apple Events/Apple Scripts global pointer (not switched) <22>
-emEditionMgrPerApp	ds.l		1					; EditionMgr global (switched) <22>
+emItlCache			ds.b		emItlCacheSize		; 018 ; reserve room for cache
+emItlNeedUnlock		ds.b		1					; 028 ; for pack6
+emItlDontUnlockYet	ds.b		1					; 029 ; for pack6										<56>
+emItlFiller			ds.b		2					; 02a ; Reserved room
+emScriptsInstalled	ds.b		1					; 02c ; number of installed scripts
+emTwoCursorsFlag	ds.w		1					; 02e ; indicates split cursor and if emCursor2Rect is high cursor
+emCursor2Rect		ds.w		4					; 030 ; top, left, bottom, right edges of split cursor: initialized to 0
+emFmtOrderHFlag		ds.b		1					; 038 ; flag to indicate a handle was allocated
+emDirection			ds.l		1					; 03a ; direction param for C2P for both offsets
+emMeasureLine		ds.b		1					; 03e ; flag that says to measure the whole line
+emCleanWordBrk		ds.l		1					; 040 ; storage for 32-bit clean defWordBrk address
+emNewFont			ds.b		1					; 044 ; textStyle.tsFont: the only field I fill in
+emNewStyle			ds.w		4					; 046 ; SetRsrved params: flag.b, textStylePtr.l, mode.w
+emBufferHandle		ds.l		1					; 04e ; handle for text buffering
+emUnsynchedFlag		ds.b		1					; 052 ; indicates unsynched keyboard and font
+emTExtra			ds.b		3					; 053 ; extra TE bytes
+emBufferLen			ds.w		1					; 056 ; length of text in buffer
+emSERDVars			ds.l		1					; 058 ; Serial Driver Globals
+emGestalt			ds.l		1					; 05c ; Gestalt Globals
+emLayoutGlobals		ds.l		1					; 060 ; Layout Mgr Globals
+emTSMGlobals		ds.l		1					; 064 ; Text-Service Mgr Globals
+emSplineKey			ds.l		1					; 068 ; Bass Fonts Globals
+emSnarfGlobals		ds.l		1					; 06c ; Snarf Man
+emLAPGlobals		ds.l		1					; 070 ; AppleTalk globals
+emLMgrGlobals		ds.l		1					; 074 ; LAP Mgr globals
+emHelpGlobals		ds.l		1					; 078 ; Help Mgr Globals
+emPPCGlobals		ds.l		1					; 07c ; PPC Mgr globals
+emDataPub			ds.l		1					; 080 ; Data Publications globals
+emReliability		ds.l		1					; 084 ; Reliability manager globals
+emjRunSlotHandlrs	ds.l		1					; 088 ; for slot mgrs
+emFolderCache		ds.l		1					; 08c ; used by Folder Manager
+
+vDoErase			ds.l		1					; 090
+vCaretDisplay		ds.l		1					; 094 ; Used by TextEdit for vectors
+vGetLRPosition		ds.l		1					; 098 ;   to patch Rom
+vGetRLPosition		ds.l		1					; 09c
+vOnLineEnd			ds.l		1					; 0a0
+vCaretInsideRun		ds.l		1					; 0a4
+vSetDirection		ds.l		1					; 0a8
+vGetDirection		ds.l		1					; 0ac
+vGetStylesInOrder	ds.l		1					; 0b0
+vteGetFormatOrder	ds.l		1					; 0b4
+vGetWidth			ds.l		1					; 0b8
+vGetCurScript		ds.l		1					; 0bc
+vOnSameLine			ds.l		1					; 0c0
+vMeasureWidth		ds.l		1					; 0c4
+vMeasureWholeRun	ds.l		1					; 0c8
+vHiliteLineEnds		ds.l		1					; 0cc
+vInvrtRectangle		ds.l		1					; 0d0
+vPixelWidths		ds.l		1					; 0d4
+vTEBufferText		ds.l		1					; 0d8
+vDumpBuffer			ds.l		1					; 0dc
+vCursorMovement		ds.l		1					; 0e0
+vTestRunDirection	ds.l		1					; 0e4
+vBufferChar			ds.l		1					; 0e8
+vSetFont2Keyboard	ds.l		1					; 0ec
+vSetKeyboard2Font	ds.l		1					; 0f0
+vStyleGuts			ds.l		1					; 0f4
+vConcatRuns			ds.l		1					; 0f8
+
+resourceMgrDirID	ds.l		1					; 0fc ; dirID one-shot for Resource Mgr
+emLAPAGlobals		ds.l		1					; 100 ; LAP Mgr (router) globals
+emMailGlobals		ds.l		1					; 104 ; AppleMail globals
+emADASGlobals		ds.l		1					; 108 ; ADAS globals
+
+emELAPGlobals		ds.l		1					; 10c ; EtherTalk LAP globals
+
+soundMgrGlobals		ds.l		1					; 110 ; one global for ALL machines
+
+emWindowListGlobals	ds.l		1					; 114 ; <52> globals for layerless windowing
+
+emDragGlobals		ds.l		1					; 118 ; <64> globals for dragging stuff (in Finder, etc)
+
+emFSCommon			ds.l		1					; 11c ; <68> globals for FSCommon Library Modules
+emButtonMgrGlobals	ds.l		1					; 120 ; <52> <70> globals for Button Manager (Not enUnused1 anymore)
+
+emPack8Globals		ds.w		1					; 124 ; <52> globals for Apple Event Manager package
+emPack9Globals		ds.w		1					; 126 ; <52> globals for PPC Browser package
+
+emProcessMgrExists	ds.w		1					; 128 ; <58> true when Process Mgr is running
+
+emPack11Globals		ds.w		1					; 12a ; <52> globals for Edition Manager package
+
+emWindowMgrFlags	ds.w		1					; 12c ; <77> flags to speed CheckUpdateIn (previously emUnused2)
+
+emPack13Globals		ds.w		1					; 12e ; <52> globals for Data Access Manager package
+emPack14Globals		ds.w		1					; 130 ; <52> globals for Balloon Help package
+
+emResrvMemSemaphore	ds.l		1					; 132 ; Semaphore for ResrvMem moved to here. Used to be emUnused4. <57>
+
+emPack15Globals		ds.w		1					; 136 ; <52> globals for Picture Utilities package
+
+emSerialMgrGlobals	ds.l		1					; 138 ; <70> globals for Serial Manager (one long out of emUnused3)
+emLanguagePackGlobals	ds.l	1					; 13c ; <71> globals for LanguagePackExtension (one long out of emUnused3)
+
+emStartTicks		ds.l		1					; 140 ; PN global used by ListMgrPack
+
+emRectRgn			ds.l		1					; 144 ; <SM10> global used by WindowMgr routine <PN>
+
+emPPCPromptForUserGlobals ds.l	1					; 148 ; <59> global used by PPC’s PromptForUser routine
+
+emScrollSpeedGlobals ds.l		1					; 14c ; <58> global used by scroll speed throttling
+
+emDialogGlobals		ds.l		1					; 150 ; <53> FM Dialog Manager Globals
+
+emAppleEvents		ds.l		1					; 154 ; Apple Events (switched for each application)
+
+sysErrorUpdateRect	ds.w		4					; 158 ; rectangle for updating after SysError box goes away
+
+emItlSysCachePtr	ds.l		1					; 160 ; pointer to system itl cache				<7><20>
+emScriptMapPtr		ds.l		1					; 164 ; pointer to script mapping/sorting data	<8>
+emLangMapPtr		ds.l		1					; 168 ; pointer to language mapping/sorting data	<8>
+
+					ds.l		1					; 16c ; was emNumer (obsolete), now unused		<11><84>
+					ds.l		1					; 170 ; was emDenom (obsolete), now unused		<11><84>
+emIconCluts			ds.l		1					; 174 ; Ptr to global icon info				<13>
+emScriptAppGlobals	ds.l		1					; 178 ; Handle to application-specific script globals	<16><20><21>
+emAppleEventsGlobal	ds.l		1					; 17c ; Apple Events/Apple Scripts global pointer (not switched) <22>
+emEditionMgrPerApp	ds.l		1					; 180 ; EditionMgr global (switched) <22>
 
 ; Note: These vectors are not used by the local file system.  They exist to provide a cleaner interface
 ; to AppleShare and FileShare.  Thus, you can't change these vectors and assume that you're patching
 ; the file system. (This may change, however, so don't patch them expecting to only affect AppleShare and 
 ; FileShare, either).
-jSyncWait			ds.l		1					; points to the top of the HFS sync call spin loop					<23>
-jAfterFSQHook		ds.l		1					; points into FSQueue just after return from calling fsQueueHook	<23>
-jCmdDone			ds.l		1					; points to the top of File System Command Done processing			<23>
-jDispatchNext		ds.l		1					; point into code where the FS checks for another call to process 	<23>
-jSCSIFreeHook		ds.l		1					; vector called by SCSI Mgr every time it frees the bus
+jSyncWait			ds.l		1					; 184 ; points to the top of the HFS sync call spin loop					<23>
+jAfterFSQHook		ds.l		1					; 188 ; points into FSQueue just after return from calling fsQueueHook	<23>
+jCmdDone			ds.l		1					; 18c ; points to the top of File System Command Done processing			<23>
+jDispatchNext		ds.l		1					; 190 ; point into code where the FS checks for another call to process 	<23>
+jSCSIFreeHook		ds.l		1					; 194 ; vector called by SCSI Mgr every time it frees the bus
 													; this vector is used by the File System to complete SCSI Busy deferrals 
 
 ; routines to manage the sound interrupt source
-jSetupSoundInterrupt		ds.l	1
-jSuspendSoundInterrupt		ds.l	1
-jResumeSoundInterrupt		ds.l	1
-jAcknowledgeSoundInterrupt	ds.l	1
+jSetupSoundInterrupt		ds.l	1				; 198
+jSuspendSoundInterrupt		ds.l	1				; 19c
+jResumeSoundInterrupt		ds.l	1				; 1a0
+jAcknowledgeSoundInterrupt	ds.l	1				; 1a4
 
 ; lomem for PaintOne and PaintBehind flag
 
-ancestorRgnsCalced			ds.w	1
+ancestorRgnsCalced			ds.w	1				; 1a8
 
-emSndPrimitives				ds.l	1				; points to a vector table of sound primitive routines				<30>
+emSndPrimitives				ds.l	1				; 1aa ; points to a vector table of sound primitive routines				<30>
 
-emMinSysHeapFreeSpace		ds.l	1				; contains a minimum memory value for sysheap free after allocations <31>
+emMinSysHeapFreeSpace		ds.l	1				; 1ae ; contains a minimum memory value for sysheap free after allocations <31>
 
-emHwPrivTable				ds.l	1				; Ptr to a jump table for HwPriv's selectors						<36>
-emKeyTMTaskPtr				ds.l	1				; Ptr to a TimeMgr task that Eclipse Keyswitch uses to shut down	<36>
+emHwPrivTable				ds.l	1				; 1b2 ; Ptr to a jump table for HwPriv's selectors						<36>
+emKeyTMTaskPtr				ds.l	1				; 1b6 ; Ptr to a TimeMgr task that Eclipse Keyswitch uses to shut down	<36>
 
-emMessageManagerGlobals		ds.l	3				; Globals for the new message manager	<32>
+emMessageManagerGlobals		ds.l	3				; 1ba ; Globals for the new message manager	<32>
 
-emDictionaryMgrPackHandle	ds.l	1				; handle to the package code		<37>
-emDictionaryMgrUseCount		ds.w	1				; pack use count for ProcHelper
+emDictionaryMgrPackHandle	ds.l	1				; 1c6 ; handle to the package code		<37>
+emDictionaryMgrUseCount		ds.w	1				; 1ca ; pack use count for ProcHelper
 
-emWorldScriptIIPrintingGlobals	ds.l	1			; <66> it is now used by WS II printing stuff, so don't use it
-emHasMultiScript			ds.w	1				; true when non-Roman script system is installed.  (but false until the Process Mgr is initialized)
+emWorldScriptIIPrintingGlobals	ds.l	1			; 1cc ; <66> it is now used by WS II printing stuff, so don't use it
+emHasMultiScript			ds.w	1				; 1d0 ; true when non-Roman script system is installed.  (but false until the Process Mgr is initialized)
 
-emResourceCache				ds.l	1				; Information for calls to _CountResources and _GetIndResource
-emLastMapOverridden			ds.w	1				; Reference number of last resource map that was overriden
-emOverrideMapRefNum			ds.w	1				; Reference number of override map
-emScanOverrideMaps			ds.w	1				; Boolean determining whether or not override maps are scanned for resources
+emResourceCache				ds.l	1				; 1d2 ; Information for calls to _CountResources and _GetIndResource
+emLastMapOverridden			ds.w	1				; 1d6 ; Reference number of last resource map that was overriden
+emOverrideMapRefNum			ds.w	1				; 1d8 ; Reference number of override map
+emScanOverrideMaps			ds.w	1				; 1da ; Boolean determining whether or not override maps are scanned for resources
 
-emPrintingGlobals			ds.l	1				; Tsunami Printing Manager non-swapped printing globals	<41>
+emPrintingGlobals			ds.l	1				; 1dc ; Tsunami Printing Manager non-swapped printing globals	<41>
 
-emCursorGlobals				ds.l	1				; Ptr to CursorDev globals								<46>
+emCursorGlobals				ds.l	1				; 1e0 ; Ptr to CursorDev globals								<46>
 
-emButtonIntGlobals			ds.l	1				; Ptr to Button Interrupt globals. previously Ptr to "real" SwapMMUMode routine	<SM22> CSS				
+emButtonIntGlobals			ds.l	1				; 1e4 ; Ptr to Button Interrupt globals. previously Ptr to "real" SwapMMUMode routine	<SM22> CSS				
 
-emAppleTalkInactiveOnBoot	ds.w	1				; True if AppleTalk was inactive on boot				<48>
+emAppleTalkInactiveOnBoot	ds.w	1				; 1e8 ; True if AppleTalk was inactive on boot				<48>
 
-emOpenFontFiles				ds.w	1				; Count of open font files in the Fonts folder. 		<49>
+emOpenFontFiles				ds.w	1				; 1ea ; Count of open font files in the Fonts folder. 		<49>
 
-emLowMemoryPrintingGlobals	ds.l	1				; Handle to globals used by LowMemoryPrintingPatches	<50>
+emLowMemoryPrintingGlobals	ds.l	1				; 1ec ; Handle to globals used by LowMemoryPrintingPatches	<50>
 
-emNetBootGlobals			ds.l	1				; Handle to globals used by emNetBootGlobals for Network Booting and Appletalk stuff.	<65>
-
-emFndrDeskRgn				ds.l	1				; Handle to region maintained by Bungee Finder if fndrDeskRgnTracking is true <67> <69>
-
-emFndrDeskRgnTracking		ds.w	1				; If true, the Bungee Finder will keep an up-to-date region handle in fndrDeskRgn of the icons on the desktop <67> <69>
-
-emFndrDeskRgnChange			ds.w	1				; Always incremented by the Bungee Finder for every change made to the desktop <67> <69>
-
-emDisplayManagerGlobals		ds.l	1				; Pointer to globals used by Display Manager
-
-emTranslationMgrGlobals		ds.l	1				; Pointer to globals used by Translation Manager (Macintosh Easy Open)	<73>
-
-emTingeInfo					ds.l	1				; Handle to color information kept by the Tinge Manager
-
-emIsDragging				ds.b	1				; Set within DragTheRgn and cleared before exiting; if true, HelpMgr
-emIsDraggingSlop			ds.b	3				; patch in OSEventAvail is bypassed.		<SM1>
-
-emRenoGlobals				ds.l	1				; Ptr to Reno Globals						<LW2>
-
-emDMADispatchGlobals		ds.l	1				; DMA dispatch globals ptr					<SM20>
-
-emInternalModemMgrGlobals	ds.l	1				; Internal modem manager globals 			<78>
-
-emGadgetPixMap				ds.l	1				; PixMapHandle used by defprocs to draw gadgets
-
-emAuxiliaryWindowHashTable	ds.l	1				; Pointer to auxiliary window record hash table
-emAuxiliaryControlHashTable	ds.l	1				; Pointer to auxiliary control record hash table
-
-emIDEGlobals				ds.l	1				; IDE driver globals						<SM24>
-
-emSpeechRecognitionGlobals	ds.l	1				; Speech Recognition Globals				<85><KWR>
-
-emControlHandle				ds.l	1				; control handle used in _DragTheRgn when the thumb is being dragged so we can send a draw thumb outline message. <SM25> CSS
-
-emHeapUtilsGlobals			ds.l	1				; Heap Utilities globals
-
-emExpansionBusGlobals		ds.l	1				; Pointer to Expansion Bus Manager Globals
-
-jSWModemSoundVector			ds.l	1				; Vector to control routine for software modem sound
+emNetBootGlobals			ds.l	1				; 1f0 ; Handle to globals used by emNetBootGlobals for Network Booting and Appletalk stuff.	<65>
+
+emFndrDeskRgn				ds.l	1				; 1f4 ; Handle to region maintained by Bungee Finder if fndrDeskRgnTracking is true <67> <69>
+
+emFndrDeskRgnTracking		ds.w	1				; 1f8 ; If true, the Bungee Finder will keep an up-to-date region handle in fndrDeskRgn of the icons on the desktop <67> <69>
+
+emFndrDeskRgnChange			ds.w	1				; 1fa ; Always incremented by the Bungee Finder for every change made to the desktop <67> <69>
+
+emDisplayManagerGlobals		ds.l	1				; 1fc ; Pointer to globals used by Display Manager
+
+emTranslationMgrGlobals		ds.l	1				; 200 ; Pointer to globals used by Translation Manager (Macintosh Easy Open)	<73>
+
+emTingeInfo					ds.l	1				; 204 ; Handle to color information kept by the Tinge Manager
+
+emIsDragging				ds.b	1				; 208 ; Set within DragTheRgn and cleared before exiting; if true, HelpMgr
+emIsDraggingSlop			ds.b	3				; 209 ; patch in OSEventAvail is bypassed.		<SM1>
+
+emRenoGlobals				ds.l	1				; 20c ; Ptr to Reno Globals						<LW2>
+
+emDMADispatchGlobals		ds.l	1				; 210 ; DMA dispatch globals ptr					<SM20>
+
+emInternalModemMgrGlobals	ds.l	1				; 214 ; Internal modem manager globals 			<78>
+
+emGadgetPixMap				ds.l	1				; 218 ; PixMapHandle used by defprocs to draw gadgets
+
+emAuxiliaryWindowHashTable	ds.l	1				; 21c ; Pointer to auxiliary window record hash table
+emAuxiliaryControlHashTable	ds.l	1				; 220 ; Pointer to auxiliary control record hash table
+
+emIDEGlobals				ds.l	1				; 224 ; IDE driver globals						<SM24>
+
+emSpeechRecognitionGlobals	ds.l	1				; 228 ; Speech Recognition Globals				<85><KWR>
+
+emControlHandle				ds.l	1				; 22c ; control handle used in _DragTheRgn when the thumb is being dragged so we can send a draw thumb outline message. <SM25> CSS
+
+emHeapUtilsGlobals			ds.l	1				; 230 ; Heap Utilities globals
+
+emExpansionBusGlobals		ds.l	1				; 234 ; Pointer to Expansion Bus Manager Globals
+
+jSWModemSoundVector			ds.l	1				; 238 ; Vector to control routine for software modem sound
+
+							ds.l	1				; 23c
+							ds.l	1				; 240
+							ds.l	1				; 244
+							ds.l	1				; 248
+							ds.l	1				; 24c
+							ds.l	1				; 250
+							ds.l	1				; 254
+							ds.l	1				; 258
+							ds.l	1				; 25c
+							ds.l	1				; 260
+							ds.l	1				; 264
+							ds.l	1				; 268
+							ds.l	1				; 26c
+							ds.l	1				; 270
+							ds.l	1				; 274
+							ds.l	1				; 278
+							ds.l	1				; 27c
+							ds.l	1				; 280
+							ds.l	1				; 284
+							ds.l	1				; 288
+							ds.l	1				; 28c
+							ds.l	1				; 290
+							ds.l	1				; 294
+							ds.l	1				; 298
+							ds.l	1				; 29c
+							ds.l	1				; 2a0
+							ds.l	1				; 2a4
+							ds.l	1				; 2a8
+							ds.l	1				; 2ac
+							ds.l	1				; 2b0
+							ds.l	1				; 2b4
+							ds.l	1				; 2b8
+							ds.l	1				; 2bc
+							ds.l	1				; 2c0
+							ds.l	1				; 2c4
+							ds.l	1				; 2c8
+							ds.l	1				; 2cc
+							ds.l	1				; 2d0
+							ds.l	1				; 2d4
+							ds.l	1				; 2d8
+							ds.l	1				; 2dc
+							ds.l	1				; 2e0
+							ds.l	1				; 2e4
+							ds.l	1				; 2e8
+							ds.l	1				; 2ec
+							ds.l	1				; 2f0
+							ds.l	1				; 2f4
+							ds.l	1				; 2f8
+							ds.l	1				; 2fc
+							ds.l	1				; 300
+							ds.l	1				; 304
+							ds.l	1				; 308
+							ds.l	1				; 30c
+							ds.l	1				; 310
+							ds.l	1				; 314
+							ds.l	1				; 318
+							ds.l	1				; 31c
+							ds.l	1				; 320
+							ds.l	1				; 324
+							ds.l	1				; 328
+							ds.l	1				; 32c
+							ds.l	1				; 330
+							ds.l	1				; 334
+							ds.l	1				; 338
+							ds.l	1				; 33c
+							ds.l	1				; 340
+							ds.l	1				; 344
+							ds.w	1				; 348
 
 ; NOTE: When adding new fields here, be sure to update the high-level language header files as well
 ; (currently {CInternal}ExpandMemPriv.h is the one)
 ; Be sure to update the Reality sources when you change this file (and the version number)
 
-emCurVersion		EQU			$0133				; version 
+emCurVersion		EQU			$016b				; version 
 
 emRecSize			equ			*					; size for this version
 size				equ			*
diff --git a/Internal/Asm/UniversalEqu.a b/Internal/Asm/UniversalEqu.a
--- a/Internal/Asm/UniversalEqu.a
+++ b/Internal/Asm/UniversalEqu.a
@@ -514,7 +514,7 @@ SlotF			ds.b	1			; info for Slot F
 ; 	If you change the ProductInfo record, bump the version up by 1.	
 ;
 ;--------------------------------------------------------------------------------------------
-ProductInfoVersion	equ		1		; Version of the ProductInfo record
+ProductInfoVersion	equ		0		; Version of the ProductInfo record
 
 ProductInfo		record	0,increment	; data structure describing product dependent features
 
diff --git a/Internal/Asm/egretequ.a b/Internal/Asm/egretequ.a
--- a/Internal/Asm/egretequ.a
+++ b/Internal/Asm/egretequ.a
@@ -109,6 +109,7 @@ ContinueComp	ds.l	1				; vector to power message continue procedure				<SM5>
 deferredPDM		ds.l	1				; pointer to PDM deferred task to post alert				<SM5>
 prevPollStack	ds.l	1				; keep address of any other poll stack						<SM6>
 SpareComp3		ds.l	1				; spare vector #3											<SM5>
+				ds.b	$178-$64		; new
 EgretGlobSize	EQU		*
 			  ENDR
 
@@ -273,7 +274,8 @@ EnDisPDM		equ		$21				; Enable/Disable PowerDown Message							<T2>
 RdWrIIC			equ		$22				; Read or Write IIC (I sqared C)							<SM3>[rbm]<3>
 WakeUpMode		equ		$23				; Enable/Disable WakeUpMode									<P1>
 TimerTickle		equ		$24				; ShutDown Timer Tickle										<P1>
-MaxPseudoCmd	equ		TimerTickle		; largest possible pseudo command number					<P1>
+; more commands apparently added
+MaxPseudoCmd	equ		$2A				; largest possible pseudo command number					<P1>
 
 ;
 ;__________________________________________________________________________________________________
diff --git a/Internal/Asm/fontPrivate.a b/Internal/Asm/fontPrivate.a
--- a/Internal/Asm/fontPrivate.a
+++ b/Internal/Asm/fontPrivate.a
@@ -265,70 +265,110 @@ selectInitializediskCache		equ		$0010									; <24>
 		MACRO		
 		_sbIsOutline
 		IMPORT		SplineMgr
-		MOVEQ		#sbIsOutline,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbIsOutline,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM
 		
 		MACRO		
 		_sbRetrieveGlyph
 		IMPORT		SplineMgr
-		MOVEQ		#sbRetrieveGlyph,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbRetrieveGlyph,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM
 		
 		MACRO
 		_sbKillSomeCaches
 		IMPORT		SplineMgr
-		MOVEQ		#sbKillSomeCaches,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbKillSomeCaches,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM				
 
 		MACRO
 		_sbFillWidthTab
 		IMPORT		SplineMgr
-		MOVEQ		#sbFillWidthTab,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbFillWidthTab,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM				
 
 		MACRO
 		_sbResetWorkSpace
 		IMPORT		SplineMgr
-		MOVEQ		#sbResetWorkSpace,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbResetWorkSpace,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM				
 
 		MACRO
 		_sbInitMemory
 		IMPORT		SplineMgr
-		MOVEQ		#sbInitMemory,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbInitMemory,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM				
 
 		MACRO
 		_sbSetFontState
 		IMPORT		SplineMgr
-		MOVEQ		#sbSetFontState,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbSetFontState,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM				
 
 		MACRO
 		_sbSearchForCache
 		IMPORT		SplineMgr
-		MOVEQ		#sbSearchForCache,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbSearchForCache,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM				
 
 		MACRO
 		_sbPreFlightFontMem
 		IMPORT		SplineMgr
-		MOVEQ		#sbPreFlightFontMem,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbPreFlightFontMem,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM				
 
 		MACRO
 		_fsLowestPPEM
 		IMPORT		SplineMgr
-		MOVEQ		#fsLowestPPEM,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#fsLowestPPEM,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM				
 
@@ -341,19 +381,31 @@ selectInitializediskCache		equ		$0010									; <24>
 		MACRO		
 		_sbFlushFonts
 		IMPORT		SplineMgr
-		MOVEQ		#sbFlushFonts,D0
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#sbFlushFonts,D0
+		OPT	&OLDOPT
 		_SplineMgr
 		ENDM
 		
 		Macro																; <24>
 		_InitializePartialFonts												; <24>
-		moveq		#selectInitializePartialFonts,d0						; <24>
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#selectInitializePartialFonts,d0						; <24>
+		OPT	&OLDOPT
 		_SplineMgr															; <24>
 		EndM																; <24>
 		
 		Macro																; <24>
 		_InitializeDiskCache												; <24>
-		moveq		#selectInitializeDiskCache,d0							; <24>
+		LCLC		&OLDOPT
+&OLDOPT	SETC		&Setting('OPT')
+		OPT			NONE
+		MOVE		#selectInitializeDiskCache,d0							; <24>
+		OPT	&OLDOPT
 		_SplineMgr															; <24>
 		EndM																; <24>
 		
diff --git a/Internal/C/DialogsPriv.h b/Internal/C/DialogsPriv.h
--- a/Internal/C/DialogsPriv.h
+++ b/Internal/C/DialogsPriv.h
@@ -67,9 +67,9 @@ pascal OSErr Cite4(StringHandle baseString,ConstStr255Param p0,ConstStr255Param
 	= { 0x303C, 0x0AFB, 0xAA68 };
 
 pascal OSErr CitationsSH(StringHandle baseString,short numCitations,CiteListPtr citations)
-	= { 0x303C, 0x07FC, 0xAA68 };
+	= { 0x303C, 0x05FC, 0xAA68 };
 
 pascal OSErr CitationsCH(CharsHandle baseString,long offset,short numCitations,CiteListPtr citations)
-	= { 0x303C, 0x05FD, 0xAA68 };
+	= { 0x303C, 0x07FD, 0xAA68 };
 
 #endif		/* __DIALOGSPRIV__ */
diff --git a/Internal/C/IconUtilsPriv.h b/Internal/C/IconUtilsPriv.h
--- a/Internal/C/IconUtilsPriv.h
+++ b/Internal/C/IconUtilsPriv.h
@@ -103,6 +103,7 @@ typedef struct
 	unsigned short	type;
 	unsigned short	label;
 	Handle			table[IconSpace];
+	char			padding[36]; /* struct enlarged, says notification manager */
 } IconSuite;
 
 typedef IconSuite *IconSuitePtr;
diff --git a/Internal/Pascal/DialogsPriv.p b/Internal/Pascal/DialogsPriv.p
--- a/Internal/Pascal/DialogsPriv.p
+++ b/Internal/Pascal/DialogsPriv.p
@@ -94,11 +94,11 @@ TYPE
 
 	FUNCTION CitationsSH(baseString: StringHandle;
 					numCitations: INTEGER; citations: CiteListPtr): OSErr;
-		INLINE $303C, $07FC, $AA68;
+		INLINE $303C, $05FC, $AA68;
 
 	FUNCTION CitationsCH(baseString: CharsHandle;offset: LONGINT;
 					numCitations: INTEGER; citations: CiteListPtr): OSErr;
-		INLINE $303C, $05FD, $AA68;
+		INLINE $303C, $07FD, $AA68;
 
 
 {$IFC NOT UsingIncludes}
diff --git a/Libs/InterfaceSrcs/DuplicateModules.rom b/Libs/InterfaceSrcs/DuplicateModules.rom
--- a/Libs/InterfaceSrcs/DuplicateModules.rom
+++ b/Libs/InterfaceSrcs/DuplicateModules.rom
@@ -226,7 +226,6 @@ fsdelete
 p2cstr
 clock
 getpid
-strlen
 fclose
 dec2str
 str2dec
diff --git a/Libs/InterfaceSrcs/Interface.Make b/Libs/InterfaceSrcs/Interface.Make
--- a/Libs/InterfaceSrcs/Interface.Make
+++ b/Libs/InterfaceSrcs/Interface.Make
@@ -28,21 +28,21 @@ CTTermDir		=	{CTDir}TerminalMgr:
 
 InterfaceObjs							=	"{IfObjDir}"Copyright.a.o					∂
 											"{IfObjDir}"OSTraps.a.o						∂
-											"{IfObjDir}"BitMapToRegion.a.o 				∂
+											"{IfObjDir}"Strings.a.o						∂
+											"{IfObjDir}"PackTraps.a.o					∂
 											"{IfObjDir}"HFSGlue.c.o						∂
-											"{IfObjDir}"FoldersGlue.c.o					∂
 											"{IfObjDir}"ToolTraps.a.o					∂
+											"{IfObjDir}"nAppleTalk.a.o					∂
+											"{IfObjDir}"ENet.a.o						∂
+											"{IfObjDir}"piMAIN.a.o						∂
+											"{IfObjDir}"BitMapToRegion.a.o 				∂
+											"{IfObjDir}"FoldersGlue.c.o					∂
 											"{IfObjDir}"EnvironsGlue.a.o				∂
 											"{IfObjDir}"GestaltGlue.a.o					∂
-											"{IfObjDir}"PackTraps.a.o					∂
 											"{IfObjDir}"ListTraps.a.o					∂
 											"{IfObjDir}"PrintCalls.a.o					∂
 											"{IfObjDir}"Graf3DAsm.a.o					∂
 											"{IfObjDir}"SlotTraps.a.o					∂
-											"{IfObjDir}"Strings.a.o						∂
-											"{IfObjDir}"nAppleTalk.a.o					∂
-											"{IfObjDir}"ENet.a.o						∂
-											"{IfObjDir}"piMAIN.a.o						∂
 											"{IfObjDir}"controls.a.o					∂
 											"{IfObjDir}"desk.a.o						∂
 											"{IfObjDir}"devices.a.o						∂
diff --git a/Libs/InterfaceSrcs/OSTraps.a b/Libs/InterfaceSrcs/OSTraps.a
--- a/Libs/InterfaceSrcs/OSTraps.a
+++ b/Libs/InterfaceSrcs/OSTraps.a
@@ -579,21 +579,25 @@ BlockMoveData	PROC  EXPORT
 ;
 OpenDriver		FUNC	EXPORT
 
-				MOVEQ	#(ioQElSize/2)-1,D0
-@1				CLR.W	-(SP)
+				MOVE.L	(SP)+,D2			;return address
+				MOVE.L	(SP)+,A1			;ptr to refNum return
+				MOVE.L	(SP)+,D1			;driver name
+				LINK.W	A6,#0				;we like A6 chains
+
+				MOVEQ	#(ioQElSize/4)-1,D0
+@1				CLR.L	-(SP)
 				DBRA	D0,@1
 
-				MOVE.L	ioQElSize+8(sp),ioFileName(SP)	;set up name
 				MOVE.L	SP,A0				;point to it
+				MOVE.L	D1,ioFileName(A0)	;set up name
 				_Open						;open the driver
 
-				MOVE.L	ioQElSize+4(SP),a0	;get place to put result
-				MOVE.W	ioRefNum(SP),(a0)	;store result
+				MOVE.W	ioRefNum(a0),(a1)	;store result
 
-				MOVE.L	ioQElSize(SP),A0	;get return address
-				LEA 	ioQElSize+12(SP),SP ;get rid of param. block and parameters
+				UNLK	A6
 				MOVE.W	D0,(SP) 			;store error code
-				JMP 	(A0)				;return
+				MOVE.L	D2,A1				;use return addr to...
+				JMP 	(A1)				;return
 
 ;
 ; PROCEDURE CloseDriver(refNum: INTEGER):OsErr;
@@ -807,7 +811,7 @@ DriveStatus FUNC	EXPORT
 		MOVE.L	8(A6),A1				; ptr to where to put the status bytes
 		LEA 	csParam(A0),A0			;ptr from where to get status bytes
 		MOVEQ	#22,D0					;number of bytes to move
-		_BlockMove
+		_BlockMoveData
 
 		UNLK	A6
 		MOVE.L	(SP)+,A1				; return address
@@ -1360,15 +1364,16 @@ OpenDF
 
 FSClose FUNC  EXPORT
 
+		MOVE.L	(SP)+,A1				; pop return address
+		MOVE	(SP)+,D0				; and argument before linking
+
 		LINK	 A6,#-ioQElSize 		; make room on stack for cmd block
 		MOVE.L	SP,A0					; address of cmd block
-		MOVE	8(A6),ioRefNum(A0)		; get the refnum param
+		MOVE	D0,ioRefNum(A0)			; get the refnum param
 		_Close
-		MOVE	D0,10(A6)				; return the result code
 		UNLK	A6
-		MOVE.L	(SP)+,A0				; return address
-		ADDQ.L	#2,SP					; fix up stack
-		JMP 	(A0)
+		MOVE	D0,(SP)					; return the result code
+		JMP 	(A1)
 
 ;FUNCTION FSRead(refNum: INTEGER; VAR count: LongInt; buffPtr: Ptr): OsErr;
 ;FUNCTION FSWrite(refNum: INTEGER; VAR count: LongInt; buffPtr: Ptr): OsErr;
@@ -1423,7 +1428,7 @@ Control FUNC  EXPORT
 		LEA 	csParam(A0),A1			; dest address of op specific params
 		MOVE.L	8(A6),A0				; src address of op specific params
 		MOVEQ	#22,D0					; max number of bytes to be moved
-		_BlockMove						; copy the op specific params
+		_BlockMoveData					; copy the op specific params
 		LEA 	-ioQElSize(A6),A0		; put cmd block addr back into A0
 
 @1		_CONTROL
@@ -1449,7 +1454,7 @@ Status	FUNC  EXPORT					;analogous to MacControl but returns
 		LEA 	csParam-ioQElSize(A6),A0 ;ptr to the status information
 		MOVE.L	8(A6),A1				; ptr to where to put this information
 		MOVEQ	#22,D0					; max number of bytes to be moved
-		_BlockMove						; copy the op specific params
+		_BlockMoveData					; copy the op specific params
 
 		UNLK	A6
 		MOVE.L	(SP)+,A1				; return address
@@ -1523,7 +1528,7 @@ GetFInfo FUNC	 EXPORT
 		LEA 	ioFlUsrWds(A0),A0		;where to copy from
 		MOVE.L	8(A6),A1				;where to copy to
 		MOVEQ	#16,D0					; 16 bytes of information
-		_BlockMove
+		_BlockMoveData
 
 		UNLK	A6
 		MOVE.L	(SP)+,A1				; return address
@@ -1723,7 +1728,7 @@ SetFInfo FUNC  EXPORT
 		LEA 	ioFlUsrWds(A0),A1		;where to copy user words
 		MOVE.L	8(A6),A0				;where the user words are now
 		MOVEQ	#16,D0					; 16 bytes of information
-		_BlockMove
+		_BlockMoveData
 		MOVE.L 	SP,A0					;restore A0
 
 		_SetFileInfo
@@ -2311,7 +2316,7 @@ notIntrupt
 		  MOVEQ 	#12,D0	   ;number of bytes to copy
 		  SUB		D0,A1
 		  LEA		4(SP),A0	   ;ptr to the args
-		  _BlockMove
+		  _BlockMoveData
 		  BRA.S 	quit	   ;done queueing up, exit
 
 			; Index off of ioResult(A1) instead of A0, bug called in to
@@ -2432,7 +2437,7 @@ more	  MOVE.L	A0,A1	   ;make a copy of it
 		  EXT.L 	D0		   ;clear top half for block move
 		  MOVE.L	A0,A1	   ;A0 points to next queue entry
 		  SUB		#12,A1	   ;A1 points to first queue entry
-		  _BlockMove		   ;shift the bytes up in the queue
+		  _BlockMoveData	   ;shift the bytes up in the queue
 		  ADD		#blkSize,D1    ;get back the new size
 		  BRA.S 	setSize
 
@@ -2540,7 +2545,7 @@ getLoop 	BLT.S		getEnd			;are we done?
 			AND 		#$FFFE,D0		;evenize it
 			ADDQ		#8,D0			;also move refnum,type,versNum
 			ADD 		D0,A2			;move to next
-			_BlockMove
+			_BlockMoveData
 			SUBQ		#1,D1
 			BRA.S		getLoop
 
diff --git a/Libs/InterfaceSrcs/PackTraps.a b/Libs/InterfaceSrcs/PackTraps.a
--- a/Libs/InterfaceSrcs/PackTraps.a
+++ b/Libs/InterfaceSrcs/PackTraps.a
@@ -458,13 +458,16 @@ IUStringOrder
 ;   convert a string into a number using Jerome's routine
 ;
 StringToNum     PROC EXPORT
-                IMPORT    	Exit8
+                EXPORT    	Exit8
 
                MOVE.L	    8(SP),A0
                PackCall	    #1,_Pack7	   ;LDec2Bin
                MOVE.L	    4(SP),A0
                MOVE.L	    D0,(A0)
-               JMP	    	Exit8
+
+Exit8          MOVE.L       (SP)+,A0
+               ADDQ         #8,SP
+               JMP          (A0)
 
 
 ;
@@ -473,15 +476,14 @@ StringToNum     PROC EXPORT
 ;   convert a number to a string using anonymous routine
 ;
 NumToString     PROC EXPORT
-                EXPORT    	Exit8
 
-               MOVE.L	 	4(SP),A0
-               MOVE.L	 	8(SP),D0
+               MOVE.L       (SP)+,A1
+               MOVE.L       (SP)+,A0
+               MOVE.L       (SP)+,D0
+               MOVE.L       A1,-(SP)
                PackCall	    #0,_Pack7	    ;LBin2Dec
 
-Exit8	       MOVE.L	 	(SP)+,A0
-               ADDQ	 		#8,SP
-               JMP	 		(A0)
+               RTS
 
 
          END
diff --git a/Libs/InterfaceSrcs/Strings.a b/Libs/InterfaceSrcs/Strings.a
--- a/Libs/InterfaceSrcs/Strings.a
+++ b/Libs/InterfaceSrcs/Strings.a
@@ -39,7 +39,7 @@ C2PStr		proc	EXPORT
 			
 			cmpi.l	#255,d0
 			ble.s	@2
-			move.l	#255,d0
+			moveq	#-1,d0
 @2			move.b  d0,(a0)					; Pascal string length
 
 @4			MOVE.L	(SP)+,A1				; return address
@@ -69,7 +69,7 @@ C2PStrProc	proc	EXPORT
 			
 			cmpi.l	#255,d0
 			ble.s	@2
-			move.l	#255,d0
+			moveq	#-1,d0
 @2			move.b  d0,(a0)					; Pascal string length
 
 @4			MOVE.L	(SP)+,A1				; return address
diff --git a/Libs/InterfaceSrcs/ToolTraps.a b/Libs/InterfaceSrcs/ToolTraps.a
--- a/Libs/InterfaceSrcs/ToolTraps.a
+++ b/Libs/InterfaceSrcs/ToolTraps.a
@@ -340,7 +340,7 @@ gsLoop			SUBQ.W	#1,D1					;decrement the index
 
 gsCopy			MOVE.B	(A0),D0 				;get the length of this string
 				ADDQ	#1,D0					;add one for the length byte
-				_BlockMove						;copy it into the string
+				_BlockMoveData					;copy it into the string
 
 gsret			UNLK	A6
 				MOVE.L	(SP)+,A0				;return addr
diff --git a/Libs/InterfaceSrcs/nAppleTalk.a b/Libs/InterfaceSrcs/nAppleTalk.a
--- a/Libs/InterfaceSrcs/nAppleTalk.a
+++ b/Libs/InterfaceSrcs/nAppleTalk.a
@@ -414,7 +414,7 @@ MoveAstring
 				ADDQ.L		#1,D0				;adj for str len byte
 				MOVEA.L		32(SP),A1			;setup dest addr
 				ADD.L		D0,32(SP)			;update dest addr
-				_BlockMove
+				_BlockMoveData
 				RTS
 				ENDPROC
 
diff --git a/Make/FeatureList b/Make/FeatureList
--- a/Make/FeatureList
+++ b/Make/FeatureList
@@ -194,7 +194,8 @@ Set	AvailableFeatures  "hasROMGibbly			∂
 						hasPenFraction			∂
 						hasFullKerning			∂
 						hasGlyphState			∂
-						useROMFonts				"
+						useROMFonts				∂
+						hasBCScreen				"
 
 
 	# Hacky replacement for the lost "ParseFeatures"
diff --git a/Make/MainCode.Make b/Make/MainCode.Make
--- a/Make/MainCode.Make
+++ b/Make/MainCode.Make
@@ -54,30 +54,23 @@ MainCodeLibs = 												∂
 				"{MiscDir}GoNativeROMLib.o"					∂
 				"{LibDir}SlotMgr.lib"						∂
 				"{LibDir}SCSI.lib"							∂
-				"{LibDir}SCSI4pt3.lib"						∂
 				"{LibDir}HFS.lib"							∂
-				"{LibDir}PPC.lib"							∂
 				"{LibDir}ADBMgr.lib"						∂
-				"{LibDir}TimeMgr.lib"						∂
 				"{LibDir}Toolbox.lib"						∂
-				"{LibDir}CommToolboxPatch.Lib"				∂
 				"{LibDir}MemoryMgr.lib"						∂
 				"{LibDir}AliasMgr.lib"						∂
 				"{LibDir}ComponentMgr.lib"					∂
 				"{LibDir}DataAccessMgr.lib"					∂
-				"{LibDir}EditionMgr.lib"					∂
 				"{LibDir}ExpansionBusMgr.lib"				∂
-				"{LibDir}HelpMgr.lib"						∂
-				"{LibDir}SoundMgr.lib"						∂
 				"{LibDir}Gestalt.lib"						∂
-				"{LibDir}IconUtils.lib"						∂
 				"{LibDir}NotificationMgr.lib"				∂
-				"{LibDir}PictUtilities.lib"					∂
 				"{LibDir}ToolboxEventMgr.lib"				∂
 				"{LibDir}ControlMgr.lib"					∂
 				"{LibDir}DisplayMgr.lib"					∂
 				"{LibDir}WindowMgr.lib"						∂
 				"{LibDir}MenuMgr.lib"						∂
+				"{LibDir}ATAMgr.lib"						∂
+				"{ObjDir}DeviceMgr.a.o"						∂
 #															∂
 #	DispatchHelper and DialogMgr.lib need to be colocated	∂
 #															∂
@@ -89,15 +82,10 @@ MainCodeLibs = 												∂
 				"{LibDir}ResourceMgr.lib"					∂
 				"{LibDir}ScriptMgr.lib"						∂
 				"{LibDir}CQD.lib"							∂
-				"{LibDir}TextServicesMgr.lib"				∂
 				"{LibDir}FontMgr.lib"						∂
 				"{LibDir}RomInterface.Lib"					∂
 				"{LibDir}RomStandardLib.lib"				∂
 				"{LibDir}StartTest.lib"						∂
-				"{LibDir}VideoDriver.lib"					∂
-				"{ObjDir}WallyWorld.a.o"					∂
-				"{ObjDir}FPEmulation.a.o"					∂
-				"{LibDir}Beep.lib"							∂
 #															∂
 #	Keep DispTable at end									∂
 #															∂
diff --git a/Make/RISC.make b/Make/RISC.make
--- a/Make/RISC.make
+++ b/Make/RISC.make
@@ -167,33 +167,25 @@ CLibraries		=	{Sources}Libs:CLibraries:
 PLibraries		=	{Sources}Libs:PLibraries:
 
 
-MAOpts			=	-d TRUE=1 -d FALSE=0 -d Alignment=8 -d CPU=20 -d ROMRelease=$D4C1 -wb -d SubRelease=3 -blksize 62
-MCOpts			=	-d TRUE=1 -d FALSE=0 -d Alignment=8 -d CPU=20 -d ROMRelease=$D4C1 -b3 -mbg full -mc68020 -blksize 62 -opt full
-MPOpts			=	-mbg full -mc68020
+MAOpts			=	-d TRUE=1 -d FALSE=0 -d Alignment=8 -d CPU=20 -d ROMRelease=$45F6 -wb -d SubRelease=1 -blksize 62
+MCOpts			=	-d TRUE=1 -d FALSE=0 -d Alignment=8 -d CPU=20 -d ROMRelease=$45F6 -b3 -mbg off -mc68020 -blksize 62 -opt full
+MPOpts			=	-mbg off -mc68020
 
-RomBase			=	$40800000
+RomBase			=	$FFC00000
 
 Features		=	hasRISCV0ResMgrPatches					∂
 					hasDoubleByte							∂
-					hasAMIC									∂
 					SupportNativeComponents					∂
 					Script_Char_Extra						∂
 					hasPenFraction							∂
 					hasFullKerning							∂
 					hasGlyphState							∂
-					hasNewHeapMgr							∂
 					hasPDMMaceEnet							∂
-					hasAppleTalkInROM						∂
 					hasMixedMode							∂
 					nonSerializedIO							∂
 					hasSCSIDiskModeFeature					∂
-					hasSysSevenResources					∂
-					hasDataAccessPACK						∂
-					hasYMCA									∂
 					hasCPUIDRegister						∂
-					hasHMC									∂
 					has2MegROMOrMore						∂
-					hasVideoIn								∂
 					hasAsyncSCSI							∂
 					BadBlockSparingEnabled					∂
 					CubeE									∂
@@ -202,63 +194,36 @@ Features		=	hasRISCV0ResMgrPatches					∂
 					PwrMgrADB								∂
 					SystemSevenOrLater						∂
 					SystemSixOrLater						∂
-					ViaADB									∂
 					forADBKeyboards 						∂
 					forAppleTalk20							∂
 					forLocalizability						∂
-					has040MMU								∂
+					forSTPnop								∂
 					hasADBKeyLayouts						∂
-					hasASC									∂
 					hasAliasMgr 							∂
-					hasApple2Fonts							∂
 					hasAppleEventMgr						∂
 					hasBalloonHelp							∂
 					hasBattery								∂
 					hasCommToolbox							∂
 					hasCQD									∂
-					hasDAFB									∂
-					hasDJMEMC								∂
-					hasDataAccessMgr						∂
 					hasDisplayMgr 							∂
 					hasDisplayMgrWindows 					∂
 					hasEDisk								∂
-					hasEclipseVIA2							∂
-					hasEditionMgr							∂
 					hasEgret								∂
 					hasExtendedCharacterSet					∂
-					hasFMC									∂
 					hasGDU									∂
-					hasGlue									∂
-					hasGrandCentral							∂
 					hasIdle 								∂
-					hasIopScc								∂
-					hasIopSwim								∂
-					hasJaws 								∂
-					hasMDU									∂
-					hasMMU									∂
-					hasMSC									∂
-					hasMac2VIA2 							∂
-					hasNetBoot								∂
-					hasNiagra								∂
-					hasOrwell								∂
-					hasOss									∂
-					hasPratt								∂
 					hasProtectedPRAM						∂
 					hasSCSI96								∂
 					hasSWIM2								∂
-					hasSwim3								∂
 					hasSlotMgr								∂
-					hasSonora								∂
 					hasSplineFonts							∂
 					hasVDAC									∂
 					hasVIAClock								∂
 					hasVISA2								∂
-					hasVISADecoder							∂
 					hasWaimeaVIA2							∂
 					isUniversal								∂
 					hasPwrControls							∂
 					hasPwrMgrClock							∂
-					hasRBV									∂
 					hasSplineFonts							∂
 					hasVIAClock 							∂
 					hasWaimeaVIA2							∂
@@ -267,52 +232,36 @@ Features		=	hasRISCV0ResMgrPatches					∂
 					onHafMac								∂
 					onMac32 								∂
 					onNuMac 								∂
+					hasBCScreen								∂
+					hasMMU									∂
 					ForROM
 
 
-ResourceFiles	=	"{RsrcDir}ATBoot.RSRC"					∂
-					"{MiscDir}AppleTalk.ROM.rsrc"			∂
-					"{RsrcDir}AppleEventMgr.rsrc"			∂
+ResourceFiles	=	"{MiscDir}ATAMgr.rsrc"					∂
+					"{MiscDir}BCScreen.rsrc"				∂
 					"{RsrcDir}CQD.rsrc"						∂
-					"{RsrcDir}ColorPicker.rsrc"				∂
-					"{RsrcDir}CommToolbox.rsrc"				∂
-					"{RsrcDir}ControlMgr.rsrc"				∂
-					"{RsrcDir}DataAccessMgr.rsrc"			∂
-					"{RsrcDir}DictionaryMgr.rsrc"			∂
 					"{RsrcDir}DeclData"						∂
+					"{MiscDir}DriverServices.rsrc"			∂
 					"{RsrcDir}EDisk.rsrc"					∂
-					"{RsrcDir}EditionMgr.rsrc"				∂
+					"{MiscDir}FireWire.rsrc"				∂
 					"{RsrcDir}Gibbly.rsrc"					∂
 					"{MiscDir}GoNativeResources"			∂
 					"{MiscDir}EmulatorAccelerations.rsrc"	∂
-					"{RsrcDir}HelpMgr.rsrc"					∂
-					"{RsrcDir}InSane.rsrc"					∂
-					"{RsrcDir}I2CC.rsrc"					∂
-					"{RsrcDir}I2CT.rsrc"					∂
-					"{RsrcDir}ListMgr.rsrc"					∂
+					"{MiscDir}LANDisk.rsrc"					∂
 					"{RsrcDir}MainCode.Rsrc"				∂
-					"{RsrcDir}MenuMgr.rsrc"					∂
+					"{MiscDir}MediaBay.rsrc"				∂
 					"{RsrcDir}MiscROMRsrcs.rsrc" 			∂
-					"{RsrcDir}NetBoot.rsrc"					∂
-					"{RsrcDir}PDMENET.rsrc"					∂
-					"{RsrcDir}PPC.rsrc"						∂
-					"{RsrcDir}PictUtilities.rsrc"			∂
-					"{RsrcDir}ROMApple2Fonts.rsrc"			∂
+					"{MiscDir}MultiprocessingServices.rsrc" ∂
+					"{MiscDir}NativeItt.rsrc" 				∂
+					"{MiscDir}NativeNub.rsrc" 				∂
+					"{MiscDir}PCCard.rsrc" 					∂
+					"{MiscDir}PowerMgr.rsrc" 				∂
 					"{RsrcDir}ROMFonts.rsrc" 				∂
 					"{RsrcDir}RomLayout.Rsrc"				∂
-					"{RsrcDir}SCCIOP.rsrc"					∂
-					"{RsrcDir}SWIMIOP.rsrc"					∂
 					"{RsrcDir}InSaneNFPU.rsrc" 				∂
-					"{RsrcDir}Sane.rsrc" 					∂
-					"{RsrcDir}Serial.rsrc"					∂
-					"{RsrcDir}SerialDMA.rsrc"				∂
-					"{RsrcDir}Sony.rsrc" 					∂
-					"{RsrcDir}SoundMgr.rsrc" 				∂
-					"{RsrcDir}StandardFile.rsrc" 			∂
-					"{RsrcDir}VDigC.rsrc"					∂
-					"{RsrcDir}VDigT.rsrc"					∂
-					"{MiscDir}VM.RSRC"						∂
-					"{RsrcDir}WindowMgr.rsrc"				∂
+					"{RsrcDir}SANE.rsrc" 					∂
+					"{MiscDir}SerialDMA.rsrc"				∂
+					"{MiscDir}USB.rsrc"						∂
 					"{RsrcDir}kbd.rsrc"
 
 
diff --git a/Make/VectorTable.a b/Make/VectorTable.a
--- a/Make/VectorTable.a
+++ b/Make/VectorTable.a
@@ -221,6 +221,7 @@
 ;	$2080	-	Time Manager
 ; 	$2084	-	Window Mananger
 ; 	$2088	-	Figment Memory Manager
+; 	$208c	-	Expansion Bus Manager
 
 ;Global							Vector		Table	Code	Dispatch	Source
 ;Identifier						Macro		Vector	Vector	Register	File
@@ -330,21 +331,21 @@ SETRESPONSEPARAMS				vIndirect	$2010,	$0040,	A7		; {sources}OS:EgretMgr.a
 TICKHANDLER 					vIndirect	$2010,	$0044,	A7		; {sources}OS:EgretMgr.a
 PSEUDOCNTTABLE					vDataTable							; {sources}OS:EgretMgr.a
 ADBCNTTABLE 					vDataTable							; {sources}OS:EgretMgr.a
-EGRETINIT						vIndirect	$2010,	$0048,	A7		; {sources}OS:EgretMgr.a
+EGRETINIT						vNoVector							; {sources}OS:EgretMgr.a
 SENDEGRETCMD					vNoVector							; {sources}OS:EgretMgr.a
-ECLIPSEPDMPATCH 				vIndirect	$2010,	$004c,	A7		; {sources}OS:EgretMgr.a
-KEYSWITCHHANDLER				vIndirect	$2010,	$0050,	A7		; {sources}OS:EgretMgr.a
-ECLIPSEDFACPATCH				vIndirect	$2010,	$0054,	A7		; {sources}OS:EgretMgr.a
-DEBUGUTILRUNKBDPATCH			vIndirect	$2010,	$0058,	A7		; {sources}OS:EgretMgr.a
+ECLIPSEPDMPATCH 				vNoVector							; {sources}OS:EgretMgr.a
+KEYSWITCHHANDLER				vNoVector							; {sources}OS:EgretMgr.a
+ECLIPSEDFACPATCH				vNoVector							; {sources}OS:EgretMgr.a
+DEBUGUTILRUNKBDPATCH			vNoVector							; {sources}OS:EgretMgr.a
 CUDAEGRETCODE					vDataTable							; {sources}OS:EgretMgr.a
-EGRETDFACANDPDM 				vIndirect	$2010,	$005c,	A7		; {sources}OS:EgretMgr.a
-CACHEINSTALL 					vIndirect	$2010,	$0060,	A7		; {sources}OS:HFS:Cache:DiskCache.a
+EGRETDFACANDPDM 				vNoVector							; {sources}OS:EgretMgr.a
+CACHEINSTALL 					vNoVector							; {sources}OS:HFS:Cache:DiskCache.a
 CHKFIRMWARE 					vIndirect	$2010,	$0064,	A7		; {sources}OS:EgretMgr.a
-INSTALLFPSP 					vIndirect	$2010,	$0068,	A7, has040MMU		; {sources}OS:FPUEmulation:FPEmulation.a
-NEWGESTALTSELECTORS 			vIndirect	$2010,	$006c,	A7		; {sources}OS:Gestalt:GestaltExtensions.a
+INSTALLFPSP 					vNoVector							; {sources}OS:FPUEmulation:FPEmulation.a
+NEWGESTALTSELECTORS 			vNoVector							; {sources}OS:Gestalt:GestaltExtensions.a
 GESTALTTRAP 					vATrap		A???					; {sources}OS:Gestalt:GestaltFunction.a
-newGestalt						vIndirect	$2010,	$0070,	A7		; {sources}OS:Gestalt:GestaltLookup.c
-findLong						vIndirect	$2010,	$0074,	A7		; {sources}OS:Gestalt:GestaltLookup.c
+newGestalt						vNoVector							; {sources}OS:Gestalt:GestaltLookup.c
+findLong						vNoVector							; {sources}OS:Gestalt:GestaltLookup.c
 HWPRIV							vATrap		A???					; {sources}OS:HwPriv.a
 SWAPICACHE						vIndirect	$2010,	$0078,	A7		; {sources}OS:HwPriv.a
 FLUSHICACHE 					vIndirect	$2010,	$007c,	A7		; {sources}OS:HwPriv.a
@@ -355,7 +356,7 @@ FLUSHEXTCACHE					vIndirect	$2010,	$008c,	A7		; {sources}OS:HwPriv.a
 SWAPSERIALCLOCK 				vIndirect	$2010,	$0090,	A7		; {sources}OS:HwPriv.a
 FLUSHCRANGEFORBM				vNoVector							; {sources}OS:HwPriv.a
 FLUSHCRANGE 					vIndirect	$2010,	$0094,	A7		; {sources}OS:HwPriv.a
-WAITFORSCSIDEVS 				vIndirect	$2010,	$0098,	A7		; {sources}OS:HwPriv.a
+WAITFORSCSIDEVS 				vNoVector							; {sources}OS:HwPriv.a
 MEMORYDISPATCH					vNoVector							; {sources}OS:HwPriv.a
 HOLDMEMORYPROC					vNoVector							; {sources}OS:HwPriv.a
 UNHOLDMEMORYPROC				vNoVector							; {sources}OS:HwPriv.a
@@ -372,13 +373,13 @@ MMUSETWRITEPROTECT				vNoVector							; {sources}OS:HwPriv.a
 MMUSETCACHEINHIBIT				vNoVector							; {sources}OS:HwPriv.a
 MMUSETCACHEMODE 				vNoVector							; {sources}OS:HwPriv.a
 MMUFLUSHATC 					vNoVector							; {sources}OS:HwPriv.a
-;					UNUSED		vIndirect	$2010,	$009C			;
+MAKESOMETHINGWRITETHROUGH		vIndirect	$2010,	$009C,	A7		; {sources}OS:HwPriv.a
 IOPMGR							vNoVector							; {sources}OS:IOPMgr.a
-IOPINFOACCESS					vIndirect	$2010,	$00a0,	A7		; {sources}OS:IOPMgr.a
-IOPMSGREQUEST					vIndirect	$2010,	$00a4,	A7		; {sources}OS:IOPMgr.a
-IOPMOVEDATA 					vIndirect	$2010,	$00a8,	A7		; {sources}OS:IOPMgr.a
+IOPINFOACCESS					vNoVector							; {sources}OS:IOPMgr.a
+IOPMSGREQUEST					vNoVector							; {sources}OS:IOPMgr.a
+IOPMOVEDATA 					vNoVector							; {sources}OS:IOPMgr.a
 IOPINTERRUPT					vDirect		????					; {sources}OS:IOPMgr.a
-MOVEREQHANDLER					vIndirect	$2010,	$00ac,	A7		; {sources}OS:IOPMgr.a
+MOVEREQHANDLER					vNoVector							; {sources}OS:IOPMgr.a
 INITIOPMGR						vNoVector							; {sources}OS:IOPMgr.a
 SCCIOPBYPASS					vNoVector							; {sources}OS:IOPMgr.a
 SCCIOPHWINIT					vNoVector							; {sources}OS:IOPMgr.a
@@ -422,7 +423,7 @@ PMGROP							vATrap		A???					; {sources}OS:PowerMgr:PowerMgr.a
 IDLEMIND						vNoVector							; {sources}OS:PowerMgr:PowerMgr.a
 GOTOSLEEP						vATrap		A???					; {sources}OS:PowerMgr:PowerMgr.a
 WAKEUP							vNoVector							; {sources}OS:PowerMgr:PowerMgr.a
-SETSUPERVISORMODE				vIndirect	$2010,	$00b8,	A7, hasPwrControls		; {sources}OS:PowerMgr:PowerMgr.a
+SETSUPERVISORMODE				vNoVector							; {sources}OS:PowerMgr:PowerMgr.a
 DISPATCHER						vNoVector							; {sources}OS:TrapDispatcher:Dispatch.a
 GETTRAPADDRESSTRAP				vATrap	 	A???					; {sources}OS:TrapDispatcher:Dispatch.a
 SETTRAPADDRESSTRAP				vATrap	 	A???					; {sources}OS:TrapDispatcher:Dispatch.a
@@ -430,7 +431,7 @@ CACHEFLUSH						vDirect		????					; {sources}OS:TrapDispatcher:Dispatch.a
 VCACHEFLUSH 					vDirect		????					; {sources}OS:TrapDispatcher:Dispatch.a
 INITDISPATCHER					vNoVector							; {sources}OS:TrapDispatcher:Dispatch.a
 BADTRAP 						vIndirect	$2010,	$00bc,	A7		; {sources}OS:TrapDispatcher:Dispatch.a
-TRAPADDRESSBITS 				vIndirect	$2010,	$00c0,	A7		; {sources}OS:TrapDispatcher:Dispatch.a
+TRAPADDRESSBITS 				vNoVector							; {sources}OS:TrapDispatcher:Dispatch.a
 UNIVERSAL						vNoVector							; {sources}OS:Universal.a
 JUMPINTOROM 					vNoVector							; {sources}OS:Universal.a
 INITVIAS						vNoVector							; {sources}OS:Universal.a
@@ -483,7 +484,7 @@ RELTIMETASK 					vNoVector							; {sources}OS:sysUtil.a
 ;					UNUSED		vATrap	 	A???					; {sources}Patches:MiscPatches.a
 INITAPP 						vIndirect	$2010,	$00c8,	A7		; {sources}Patches:MiscPatches.a
 CLEANUPAPP						vATrap	 	A???					; {sources}Patches:MiscPatches.a
-MISCPATCHESINSTALL				vIndirect	$2010,	$00cc,	A7		; {sources}Patches:MiscPatches.a
+MISCPATCHESINSTALL				vNoVector							; {sources}Patches:MiscPatches.a
 
 PACK8							vATrap	 	A???					; {sources}Toolbox:AppleEventMgr:AEPackEntry.a
 
@@ -509,9 +510,9 @@ GETNEWCONTROL					vATrap	 	A???					; {sources}Toolbox:GetMgr:GetMgr.a
 GETMENU 						vATrap		A???					; {sources}Toolbox:GetMgr:GetMgr.a
 GETNEWMBAR						vATrap	 	A???					; {sources}Toolbox:GetMgr:GetMgr.a
 GETMGREND						vNoVector							; {sources}Toolbox:GetMgr:GetMgr.a
-INSTALLPRIVTRAP 				vIndirect	$2010,	$00d8,	A7, has040MMU		; {sources}Toolbox:InSANE:FPPrivTrap.a
-PRIVTRAP881 					vIndirect	$2010,	$00dc,	A7, has040MMU		; {sources}Toolbox:InSANE:FPPrivTrap.a
-PRIVTRAP040 					vIndirect	$2010,	$00e0,	A7, has040MMU		; {sources}Toolbox:InSANE:FPPrivTrap.a
+INSTALLPRIVTRAP 				vNoVector							; {sources}Toolbox:InSANE:FPPrivTrap.a
+PRIVTRAP881 					vNoVector							; {sources}Toolbox:InSANE:FPPrivTrap.a
+PRIVTRAP040 					vNoVector							; {sources}Toolbox:InSANE:FPPrivTrap.a
 PACKDISPATCHER					vIndirect	$2010,	$00e4,	A7		; {sources}Toolbox:PackageMgr.a
 INITPACK						vATrap	 	A???					; {sources}Toolbox:PackageMgr.a
 INITALLPACKS					vATrap	 	A???					; {sources}Toolbox:PackageMgr.a
@@ -540,6 +541,19 @@ EMT1010 						vDirect		????					; {sources}Objects:ROM:Dispatch.a.o
 BASEOFROM						vDataTable							; {sources}Objects:ROM:StartTop.a.o
 ;					UNUSED		vIndirect	$2010,	$00ec,	A7		; {sources}
 
+MISCELLANEOUS_VEC00F0			vIndirect	$2010,	$00f0,	A7
+MISCELLANEOUS_VEC00F4			vIndirect	$2010,	$00f4,	A7
+MISCELLANEOUS_VEC00F8			vIndirect	$2010,	$00f8,	A7
+MISCELLANEOUS_VEC00FC			vIndirect	$2010,	$00fc,	A7
+MISCELLANEOUS_VEC0100			vIndirect	$2010,	$0100,	A7
+MISCELLANEOUS_VEC0104			vIndirect	$2010,	$0104,	A7
+MISCELLANEOUS_VEC0108			vIndirect	$2010,	$0108,	A7
+MISCELLANEOUS_VEC010C			vIndirect	$2010,	$010c,	A7
+MISCELLANEOUS_VEC0110			vIndirect	$2010,	$0110,	A7
+MISCELLANEOUS_VEC0114			vIndirect	$2010,	$0114,	A7
+MISCELLANEOUS_VEC0118			vIndirect	$2010,	$0118,	A7
+MISCELLANEOUS_VEC011C			vIndirect	$2010,	$011c,	A7
+
 ;============================== End Misc. Vectors
 
 ;============================== Public Vectors
@@ -552,13 +566,13 @@ PICKWDCB						vIndirect	$2014,	$002C,	A7		; {sources}OS:HFS:TFSVol.a ### PC Exch
 
 ALIASMGRINSTALL 				vIndirect	$2018,	$0004,	A7		; {sources}Toolbox:AliasMgr:AliasMgr.a
 ALIAS							vATrap	 	A???					; {sources}Toolbox:AliasMgr:AliasMgr.a
-gestaltAliasMgr 				vIndirect	$2018,	$0008,	A7		; {sources}Toolbox:AliasMgr:AliasMgr.a
+gestaltAliasMgr 				vNoVector							; {sources}Toolbox:AliasMgr:AliasMgr.a
 GETEXPORTEDFOLDERINFO			vIndirect	$2018,	$000c,	A7		; {sources}Toolbox:AliasMgr:AliasMgr.a
-GETVOLMOUNTINFOSIZE 			vIndirect	$2018,	$0010,	A7		; {sources}Toolbox:AliasMgr:AliasMgr.a
-GETVOLMOUNTINFO 				vIndirect	$2018,	$0014,	A7		; {sources}Toolbox:AliasMgr:AliasMgr.a
-VOLUMEMOUNT 					vIndirect	$2018,	$0018,	A7		; {sources}Toolbox:AliasMgr:AliasMgr.a
+GETVOLMOUNTINFOSIZE 			vNoVector							; {sources}Toolbox:AliasMgr:AliasMgr.a
+GETVOLMOUNTINFO 				vNoVector							; {sources}Toolbox:AliasMgr:AliasMgr.a
+VOLUMEMOUNT 					vNoVector							; {sources}Toolbox:AliasMgr:AliasMgr.a
 InitFolderManager				vIndirect	$2018,	$001c,	A7		; {sources}Toolbox:AliasMgr:FolderMgr.a
-gestaltFolderMgr				vIndirect	$2018,	$0020,	A7		; {sources}Toolbox:AliasMgr:FolderMgr.a
+gestaltFolderMgr				vNoVector							; {sources}Toolbox:AliasMgr:FolderMgr.a
 FindFolder						vIndirect	$2018,	$0024,	A7		; {sources}Toolbox:AliasMgr:FolderMgr.a
 GetFolderName					vIndirect	$2018,	$0028,	A7		; {sources}Toolbox:AliasMgr:FolderMgr.a
 FindFolderInternal				vIndirect	$2018,	$002c,	A7		; {sources}Toolbox:AliasMgr:FolderMgr.a
@@ -631,29 +645,6 @@ AL_mountVolume					vIndirect	$2018,	$0134,	A1		; {sources}Toolbox:AliasMgr:alUti
 
 ;============================== End Alias Manager Vectors
 
-;============================== Commtoolbox Vectors
-
-MyGetString 					vIndirect	$201C,	$0004,	A1		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CRMBuiltInSerial.c
-REGISTERBUILTINPORTS			vIndirect	$201C,	$0008,	A1		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CRMBuiltInSerial.c
-COMMTOOLBOXDISPATCHER			vATrap	 	A???					; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxDispatcher.a
-SETUPGLOBALS					vIndirect	$201C,	$000c,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-SETUPGESTALT					vIndirect	$201C,	$0010,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-GETCTBVERSION					vIndirect	$201C,	$0014,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-GETCMATTR						vIndirect	$201C,	$0018,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-GETFTATTR						vIndirect	$201C,	$001c,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-GETTMATTR						vIndirect	$201C,	$0020,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-GETCRMATTR						vIndirect	$201C,	$0024,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-GETDITLATTR 					vIndirect	$201C,	$0028,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-GETPOPUPATTR					vIndirect	$201C,	$002c,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-GETSTDNBPATTR					vIndirect	$201C,	$0030,	A7		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.a
-CLEANUPCOMMTOOLBOX				vIndirect	$201C,	$0034,	A1		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.c
-TRACKMANAGERS					vIndirect	$201C,	$0038,	A1		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.c
-FindApp 						vIndirect	$201C,	$003c,	A1		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.c
-AddApp							vIndirect	$201C,	$0040,	A1		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.c
-RemoveApp						vIndirect	$201C,	$0044,	A1		; {sources}Toolbox:CommToolbox:CommToolboxStartup:CommToolboxPatches.c
-
-;============================== End Commtoolbox Vectors
-
 ;============================== Component Manager Vectors
 
 ;COMPONENTMGRINSTALL 			vIndirect	$2020,	$0004,	A7		; {sources}Toolbox:ComponentMgr:ComponentExtensions.a
@@ -712,7 +703,7 @@ __OPENCOMPONENT					vIndirect	$2020,	$00d4,	A1		; {sources}Toolbox:ComponentMgr:
 __CLOSECOMPONENT				vIndirect	$2020,	$00d8,	A1		; {sources}Toolbox:ComponentMgr:ThingManager.c
 __OPENDEFAULTCOMPONENT			vIndirect	$2020,	$00dc,	A1		; {sources}Toolbox:ComponentMgr:ThingManager.c
 __CALLCOMPONENT					vIndirect	$2020,	$00e0,	A1		; {sources}Toolbox:ComponentMgr:ThingManager.c
-REGISTERCOMPONENTROMRESOURCE	vIndirect	$2020,	$00e4,	A1		; {sources}Toolbox:ComponentMgr:ThingManager.c
+REGISTERCOMPONENTROMRESOURCE	vNoVector							; {sources}Toolbox:ComponentMgr:ThingManager.c
 __REGISTERROMCOMPONENTS			vIndirect	$2020,	$00e8,	A1		; {sources}Toolbox:ComponentMgr:ThingManager.c
 __MAINCOMPONENT					vATrap	 	A???					; {sources}Toolbox:ComponentMgr:ThingManagerDisp.a
 COMPONENTBUMMER 				vIndirect	$2020,	$00ec,	A7		; {sources}Toolbox:ComponentMgr:ThingManagerDisp.a
@@ -1432,233 +1423,11 @@ BLKCHK							vIndirect	$2030,	$0370,	A7		; {sources}OS:HFS:vsm.a
 UPDATEFREE						vIndirect	$2030,	$0374,	A7		; {sources}OS:HFS:vsm.a
 VREADBM 						vDirect		????					; {sources}OS:HFS:vsm.a
 
+HFS_VEC0378						vIndirect	$2030,	$0378,	A7
+HFS_VEC037C						vIndirect	$2030,	$037c,	A7
+
 ;============================== End HFS Vectors
 
-;============================== Help Manager Vectors
-
-HELPMGRINSTALL					vIndirect	$2034,	$0004,	A7		; {sources}Toolbox:HelpMgr:BalloonExtensions.a
-PACK14ENTRY 					vATrap	 	A???					; {sources}Toolbox:HelpMgr:BalloonExtensions.a
-PTCHHMUPDATEHELPMENU			vIndirect	$2034,	$0008,	A7		; {sources}Toolbox:HelpMgr:BalloonExtensions.a
-PTCHHMGETHELPGLOBAL 			vIndirect	$2034,	$000c,	A7		; {sources}Toolbox:HelpMgr:BalloonExtensions.a
-PTCHHMGETBALLOONS				vIndirect	$2034,	$0010,	A7		; {sources}Toolbox:HelpMgr:BalloonExtensions.a
-PTCHHMSETHELPGLOBAL 			vIndirect	$2034,	$0014,	A7		; {sources}Toolbox:HelpMgr:BalloonExtensions.a
-PTCHHMPASCALGETBALLOONS 		vIndirect	$2034,	$0018,	A1		; {sources}Toolbox:HelpMgr:Balloonptch28.p
-PTCHHMGESTALTISTHEREHELP		vIndirect	$2034,	$001c,	A1		; {sources}Toolbox:HelpMgr:Balloonptch28.p
-PTCHHMBOOTINITHELPMANAGER		vIndirect	$2034,	$0020,	A1		; {sources}Toolbox:HelpMgr:Balloonptch28.p
-PTCHHMTOGGLEWHATIS				vIndirect	$2034,	$0024,	A1		; {sources}Toolbox:HelpMgr:Balloonptch28.p
-PTCHHMCALLTRACKERINCONTEXT		vIndirect	$2034,	$0028,	A1		; {sources}Toolbox:HelpMgr:Balloonptch28.p
-PTCHHMSHOWHELPABOUTDIALOG		vIndirect	$2034,	$002c,	A1		; {sources}Toolbox:HelpMgr:Balloonptch28.p
-
-;============================== End Help Manager Vectors
-
-;============================== Icon Utils Vectors
-
-ICONDISPATCH					vATrap	 	A???					; {sources}Toolbox:IconUtils:IconUtils.a
-typeTable						vDataTable							; {sources}Toolbox:IconUtils:IconUtils.a
-GetGlobalPtr					vIndirect	$2038,	$0004,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-GetGlobalHandle 				vIndirect	$2038,	$0008,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-FromResource					vIndirect	$2038,	$000c,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__PLOTICONID					vIndirect	$2038,	$0010,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__LOADICONCACHE 				vIndirect	$2038,	$0014,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__PLOTICONSUITE 				vIndirect	$2038,	$0018,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__ICONIDTORGN					vIndirect	$2038,	$001c,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__ICONSUITETORGN				vIndirect	$2038,	$0020,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__RECTINICONID					vIndirect	$2038,	$0024,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__PTINICONID					vIndirect	$2038,	$0028,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__RECTINICONSUITE				vIndirect	$2038,	$002c,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__PTINICONSUITE 				vIndirect	$2038,	$0030,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-FromMethod						vIndirect	$2038,	$0034,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__PLOTICONMETHOD				vIndirect	$2038,	$0038,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__ICONMETHODTORGN				vIndirect	$2038,	$003c,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__RECTINICONMETHOD				vIndirect	$2038,	$0040,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__PTINICONMETHOD				vIndirect	$2038,	$0044,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__ADDICONTOSUITE				vIndirect	$2038,	$0048,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__GETICONFROMSUITE				vIndirect	$2038,	$004c,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-ADJUSTRGN						vIndirect	$2038,	$0050,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__GETICONCACHEDATA				vIndirect	$2038,	$0054,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__SETICONCACHEDATA				vIndirect	$2038,	$0058,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__GETICONCACHEPROC				vIndirect	$2038,	$005c,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__SETICONCACHEPROC				vIndirect	$2038,	$0060,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__GETICONDEVICE 				vIndirect	$2038,	$0064,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-__SETICONDEVICE 				vIndirect	$2038,	$0068,	A7		; {sources}Toolbox:IconUtils:IconUtils.a
-PERFORMALIGNMENT				vIndirect	$2038,	$006c,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-ADDBUFFERTORGN					vIndirect	$2038,	$0070,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-MASKRGN 						vIndirect	$2038,	$0074,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-GETBESTDATA 					vIndirect	$2038,	$0078,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-ChooseBestSize					vIndirect	$2038,	$007c,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-SETUPPIXMAP 					vIndirect	$2038,	$0080,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__NEWICONSUITE					vIndirect	$2038,	$0084,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__MAKEICONCACHE 				vIndirect	$2038,	$0088,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-EDITICONSUITE					vIndirect	$2038,	$008c,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__FOREACHICONDO 				vIndirect	$2038,	$0090,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-GETICONFROMRESOURCE 			vIndirect	$2038,	$0094,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__GETICONSUITE					vIndirect	$2038,	$0098,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__SETSUITELABEL 				vIndirect	$2038,	$009c,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__GETSUITELABEL 				vIndirect	$2038,	$00a0,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-DISPOSER						vIndirect	$2038,	$00a4,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__DISPOSEICONSUITE				vIndirect	$2038,	$00a8,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-FromSuite						vIndirect	$2038,	$00ac,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-DOREGIONTRANSFORM				vIndirect	$2038,	$00b0,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-DoOutline						vIndirect	$2038,	$00b4,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-APPLYPATTERN					vIndirect	$2038,	$00b8,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-DOBITMAPTRANSFORM				vIndirect	$2038,	$00bc,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-RENDER							vIndirect	$2038,	$00c0,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-PLOTDEEP						vIndirect	$2038,	$00c4,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-PLOTSHALLOWBLACKANDWHITE		vIndirect	$2038,	$00c8,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-PLOTSHALLOWCOLOR				vIndirect	$2038,	$00cc,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-PLOTSHALLOW 					vIndirect	$2038,	$00d0,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-PLOTTHEICON 					vIndirect	$2038,	$00d4,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-MakeBoundary					vIndirect	$2038,	$00d8,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-CreateMask						vIndirect	$2038,	$00dc,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-SetupParamBlock 				vIndirect	$2038,	$00e0,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-PRESCALEMASK					vIndirect	$2038,	$00e4,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-PLOTICONGENERIC 				vIndirect	$2038,	$00e8,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-ICONTORGNGENERIC				vIndirect	$2038,	$00ec,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-HITTESTICONMASKGENERIC			vIndirect	$2038,	$00f0,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-HITTESTICONGENERIC				vIndirect	$2038,	$00f4,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-MAKEICONDATA					vIndirect	$2038,	$00f8,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-CompareComponent				vIndirect	$2038,	$00fc,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-Darken							vIndirect	$2038,	$0100,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-Luminance						vIndirect	$2038,	$0104,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-Brighten						vIndirect	$2038,	$0108,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-FindBlack						vIndirect	$2038,	$010c,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-MakeClut						vIndirect	$2038,	$0110,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-GetDeviceCheck					vIndirect	$2038,	$0114,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-CheckClut						vIndirect	$2038,	$0118,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-IconGetClut 					vIndirect	$2038,	$011c,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__GETLABEL						vIndirect	$2038,	$0120,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-INVALLABELCLUTS 				vIndirect	$2038,	$0124,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__SETLABEL						vIndirect	$2038,	$0128,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-FromICON						vIndirect	$2038,	$012c,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-FromSICN						vIndirect	$2038,	$0130,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__PLOTICONHANDLE				vIndirect	$2038,	$0134,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__PLOTSICNHANDLE				vIndirect	$2038,	$0138,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-SetupParamBlockForCIcon 		vIndirect	$2038,	$013c,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-CopyClut						vIndirect	$2038,	$0140,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-GETCICONCLUT					vIndirect	$2038,	$0144,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-PLOTTHECICON					vIndirect	$2038,	$0148,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-__PLOTCICONHANDLE				vIndirect	$2038,	$014c,	A1		; {sources}Toolbox:IconUtils:IconUtils.c
-
-;============================== End Icon Utils Vectors
-
-;============================== MMU Vectors
-
-GETREALPROC 					vNoVector							; {sources}OS:MMU:GetReal.a
-GETPAGEDESCPROC 				vNoVector							; {sources}OS:MMU:GetReal.a
-GETMMUINFO						vNoVector							; {sources}OS:MMU:GetReal.a
-CHECKTTREGS 					vNoVector							; {sources}OS:MMU:GetReal.a
-EDISKPROTECT					vNoVector							; {sources}OS:MMU:GetReal.a
-INITMMUTRAP 					vNoVector							; {sources}OS:MMU:MMU.a
-INITMMUGLOBALS					vNoVector							; {sources}OS:MMU:MMU.a
-MMUCLEANUPFOR8MB				vNoVector							; {sources}OS:MMU:MMU.a
-INITMMU 						vNoVector							; {sources}OS:MMU:MMUTables.a
-TRANS							vNoVector							; {sources}OS:MMU:MMUTables.a
-
-;============================== End MMU Vectors
-
-;============================== Memory Manager Vectors
-
-__BLOCKMOVE 					vATrap		A???					; {sources}OS:MemoryMgr:BlockMove.a
-BLOCKMOVE68020					vNoVector							; {sources}OS:MemoryMgr:BlockMove.a
-BLOCKMOVE68040					vNoVector							; {sources}OS:MemoryMgr:BlockMove.a
-HEAP							vNoVector							; {sources}OS:MemoryMgr:MemoryMgr.a
-INITMEMVECT 					vNoVector							; {sources}OS:MemoryMgr:MemoryMgr.a
-SETAPPLBASE 					vATrap		A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-INITAPPLZONE					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-VIAZINIT						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-VIAZPOSTINIT					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-INITZONETRAP					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-GETZONE 						vATrap		A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-SETZONE 						vATrap		A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-MAXBLOCKTRAP					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-COMPACTMEMTRAP					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-PURGEMEM						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-PURGESPACETRAP					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-FREEMEM 						vATrap		A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-RESRVMEM						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-MAXMEMTRAP						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-SETGROWZONE 					vATrap		A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-SETAPPLLIMIT					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-STACKSPACETRAP					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-MAXAPPLZONE 					vATrap		A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-NEWPTRTRAP						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-DISPOSEPTR						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-GETPTRSIZETRAP					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-SETPTRSIZETRAP					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-PTRZONETRAP 					vATrap		A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-NEWEMPTYHANDLETRAP				vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-NWHANDLE						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-DSPOSEHANDLE					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-__GETHANDLESIZE 				vATrap		A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-SETHANDLESIZETRAP				vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-HANDLEZONETRAP					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-RECOVERHANDLETRAP				vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-EMPTYHANDLE 					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-REALLOCHANDLETRAP				vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-HLOCK							vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-HUNLOCK 						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-HPURGE							vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-HNOPURGE						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-HRSRC							vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-HNORSRC 						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-HGETFLAGS						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-HSETFLAGS						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-MOREMASTERS 					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-__STRIPADDRESS					vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-MOVEHHI 						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgr.a
-MOVEHLOW						vATrap	 	A???					; {sources}OS:MemoryMgr:MemoryMgrExtensions.a
-HEAPGUTS						vNoVector							; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-MMPPROLOGUE 					vDirect		????					; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-MMHPROLOGUE 					vDirect		????					; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-MMNOPROLOGUE					vDirect		????					; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-MMMMPROLOGUE					vDirect		????					; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-MMPROLOGUE						vDirect		????					; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-MMRHPROLOGUE					vDirect		????					; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-MMEPILOGUE						vDirect		????					; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-MMNOERREPILOGUE 				vDirect		????					; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24MAKEBKF						vIndirect	$2040,	$0004,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32MAKEBKF						vIndirect	$2040,	$0008,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24EH							vIndirect	$2040,	$000c,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32EH							vIndirect	$2040,	$0010,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24PURGEHEAP					vIndirect	$2040,	$0014,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32PURGEHEAP					vIndirect	$2040,	$0018,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24TOTEPURGEABLES				vIndirect	$2040,	$001c,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32TOTEPURGEABLES				vIndirect	$2040,	$0020,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24BKCOMPACTS					vIndirect	$2040,	$0024,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32BKCOMPACTS					vIndirect	$2040,	$0028,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24ALLOCBK						vIndirect	$2040,	$002c,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32ALLOCBK						vIndirect	$2040,	$0030,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24COMPACTHP					vIndirect	$2040,	$0034,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32COMPACTHP					vIndirect	$2040,	$0038,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-TOMAXLIMIT						vIndirect	$2040,	$003c,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24MAXLIMIT 					vIndirect	$2040,	$0040,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32MAXLIMIT 					vIndirect	$2040,	$0044,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24ZONEADJUSTEND				vIndirect	$2040,	$0048,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32ZONEADJUSTEND				vIndirect	$2040,	$004c,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24ACTUALS						vIndirect	$2040,	$0050,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32ACTUALS						vIndirect	$2040,	$0054,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24GETSIZE						vNoVector							; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32GETSIZE						vNoVector							; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-CLEARGZSTUFF					vIndirect	$2040,	$0058,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24SETSIZE						vNoVector							; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32SETSIZE						vNoVector							; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-ADJUSTFREE						vIndirect	$2040,	$005c,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24NEXTMASTER					vIndirect	$2040,	$0060,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32NEXTMASTER					vIndirect	$2040,	$0064,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24HMAKEMOREMASTERS 			vIndirect	$2040,	$0068,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32HMAKEMOREMASTERS 			vIndirect	$2040,	$006c,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-RELEASEMP						vIndirect	$2040,	$0070,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24MAKEPTRSPC					vIndirect	$2040,	$0074,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32MAKEPTRSPC					vIndirect	$2040,	$0078,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A24FREEBK						vIndirect	$2040,	$007c,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-A32FREEBK						vIndirect	$2040,	$0080,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-STDGZ							vIndirect	$2040,	$0084,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-MEMMGREND						vNoVector							; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-INITMEMMGR 						vNoVector							; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-IAZ 							vIndirect	$2040,	$0088,	A7		; {sources}OS:MemoryMgr:MemoryMgrInternal.a
-
-;============================== End Memory Manager Vectors
-
 ;============================== Menu Manager Vectors
 
 MENUMGRDISPATCH 				vATrap	 	A???					; {sources}Toolbox:MenuMgr:MenuDispatch.a
@@ -1744,41 +1513,6 @@ FIND6BOFROMID					vIndirect	$2044,	$007c,	A7		; {sources}Toolbox:MenuMgr:SystemM
 
 ;============================== End Menu Manager Vectors
 
-;============================== Munger Vectors
-
-BYTES							vIndirect	$2048,	$0004,	A7		; {sources}Toolbox:Munger:Munger.a
-MUNGER							vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-XMUNGER 						vATrap		A???					; {sources}Toolbox:Munger:Munger.a
-HANDTOHANDTRAP					vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-PTRTOXHANDTRAP					vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-PTRTOHANDTRAP					vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-HANDANDHANDTRAP 				vATrap		A???					; {sources}Toolbox:Munger:Munger.a
-PTRANDHANDTRAP					vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-METHODDISPATCH					vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-LONGMUL 						vATrap		A???					; {sources}Toolbox:Munger:Munger.a
-FRACMUL 						vATrap		A???					; {sources}Toolbox:Munger:Munger.a
-FIXMUL							vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FRACDIV 						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FIXDIV							vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FRACSQRT						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FIXRATIO						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-LOWORD							vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-HIWORD							vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FIXROUND						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FRACCOS 						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FRACSIN 						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FIXATAN2						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FIX2X							vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FRAC2X							vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-X2FIX							vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-X2FRAC							vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FIX2LONG						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FRAC2FIX						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-LONG2FIX						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-FIX2FRAC						vATrap	 	A???					; {sources}Toolbox:Munger:Munger.a
-
-;============================== End Munger Vectors
-
 ;============================== Notification Manager Vectors
 
 __NMINSTALL 					vATrap		A???					; {sources}Toolbox:NotificationMgr:NotificationMgr.a
@@ -1799,10 +1533,10 @@ ValidIconRec					vIndirect	$204C,	$0034,	A1		; {sources}Toolbox:NotificationMgr:
 NMINIT							vIndirect	$204C,	$0038,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 _NMInstall						vIndirect	$204C,	$003c,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 _NMRemove						vIndirect	$204C,	$0040,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
-COPYSTRING						vIndirect	$204C,	$0044,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
+COPYSTRING						vNoVector							; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 FLUSHAPPLNM 					vIndirect	$204C,	$0048,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 NMFILTER						vIndirect	$204C,	$004c,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
-DEFBUTPROC						vIndirect	$204C,	$0050,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
+DEFBUTPROC						vNoVector							; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 NMCallMBarProc					vIndirect	$204C,	$0054,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 SWAPITEMMARKS					vIndirect	$204C,	$0058,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 ClearMarks						vIndirect	$204C,	$005c,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
@@ -1812,223 +1546,13 @@ RotateIcon						vIndirect	$204C,	$0068,	A1		; {sources}Toolbox:NotificationMgr:N
 DoSound 						vIndirect	$204C,	$006c,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 DoDialog						vIndirect	$204C,	$0070,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 DoRespProc						vIndirect	$204C,	$0074,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
-NMGNEFILTER 					vIndirect	$204C,	$0078,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
+NMGNEFILTER 					vNoVector							; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 NMTASK							vIndirect	$204C,	$007c,	A1		; {sources}Toolbox:NotificationMgr:NotificationMgr.c
 disable 						vIndirect	$204C,	$0080,	A7		; {sources}Toolbox:NotificationMgr:SetProcessorLevel.a
 spl 							vIndirect	$204C,	$0084,	A7		; {sources}Toolbox:NotificationMgr:SetProcessorLevel.a
 
 ;============================== End Notification Manager Vectors
 
-;============================== PPC Vectors
-
-OPENUGBT						vIndirect	$2050,	$0004,	A7		; {sources}OS:PPC:BTIntf.a
-BLDFSKEY						vIndirect	$2050,	$0008,	A7		; {sources}OS:PPC:BTIntf.a
-BTINIT							vIndirect	$2050,	$000c,	A7		; {sources}OS:PPC:BTreeCGlue.a
-MYBTOPEN						vIndirect	$2050,	$0010,	A7		; {sources}OS:PPC:BTreeCGlue.a
-MYBTCLOSE						vIndirect	$2050,	$0014,	A7		; {sources}OS:PPC:BTreeCGlue.a
-BTINSREC						vIndirect	$2050,	$0018,	A7		; {sources}OS:PPC:BTreeCGlue.a
-BTSETREC						vIndirect	$2050,	$001c,	A7		; {sources}OS:PPC:BTreeCGlue.a
-BTREPLREC						vIndirect	$2050,	$0020,	A7		; {sources}OS:PPC:BTreeCGlue.a
-MYBTSEARCH						vIndirect	$2050,	$0024,	A7		; {sources}OS:PPC:BTreeCGlue.a
-BTSEARCHPPC 					vIndirect	$2050,	$0028,	A7		; {sources}OS:PPC:BTreeCGlue.a
-BTGETREC						vIndirect	$2050,	$002c,	A7		; {sources}OS:PPC:BTreeCGlue.a
-MYBTDELETE						vIndirect	$2050,	$0030,	A7		; {sources}OS:PPC:BTreeCGlue.a
-BTGETINFO						vIndirect	$2050,	$0034,	A7		; {sources}OS:PPC:BTreeCGlue.a
-MYBTFLUSH						vIndirect	$2050,	$0038,	A7		; {sources}OS:PPC:BTreeCGlue.a
-mixupPswd						vIndirect	$2050,	$003c,	A1		; {sources}OS:PPC:PPCAuth.c
-getUserRec						vIndirect	$2050,	$0040,	A1		; {sources}OS:PPC:PPCAuth.c
-GetUserCompletion				vIndirect	$2050,	$0044,	A1		; {sources}OS:PPC:PPCAuth.c
-GetAuthInfo 					vIndirect	$2050,	$0048,	A1		; {sources}OS:PPC:PPCAuth.c
-random							vATrap	 	A???					; {sources}OS:PPC:PPCAuth.c
-checkInit						vIndirect	$2050,	$004c,	A1		; {sources}OS:PPC:PPCAuth.c
-ppcStartSecure					vIndirect	$2050,	$0050,	A1		; {sources}OS:PPC:PPCAuth.c
-promptCallBack					vIndirect	$2050,	$0054,	A1		; {sources}OS:PPC:PPCAuth.c
-UserRefNumCompare				vIndirect	$2050,	$0058,	A1		; {sources}OS:PPC:PPCAuth.c
-ppcDeleteUser					vIndirect	$2050,	$005c,	A1		; {sources}OS:PPC:PPCAuth.c
-ppcGetDefaultUser				vIndirect	$2050,	$0060,	A1		; {sources}OS:PPC:PPCAuth.c
-FindUserByNameAndPassword		vIndirect	$2050,	$0064,	A1		; {sources}OS:PPC:PPCAuth.c
-findUserByRef					vIndirect	$2050,	$0068,	A1		; {sources}OS:PPC:PPCAuth.c
-GetFreeEntry					vIndirect	$2050,	$006c,	A1		; {sources}OS:PPC:PPCAuth.c
-scramble						vIndirect	$2050,	$0070,	A1		; {sources}OS:PPC:PPCAuth.c
-PACK9							vATrap	 	A???					; {sources}OS:PPC:PPCBrowserPackEntry.a
-ppcDispatcher					vIndirect	$2050,	$0074,	A7		; {sources}OS:PPC:PPCDispatcher.a
-VPPCDISPATCHER					vATrap	 	A???					; {sources}OS:PPC:PPCDispatcher.a
-ppcBadSelector					vIndirect	$2050,	$0078,	A7		; {sources}OS:PPC:PPCDispatcher.a
-OpenADSPDriver					vIndirect	$2050,	$007c,	A1		; {sources}OS:PPC:PPCDsp.c
-CreateConnectionListener		vIndirect	$2050,	$0080,	A1		; {sources}OS:PPC:PPCDsp.c
-ListenConnectionRequest 		vIndirect	$2050,	$0084,	A1		; {sources}OS:PPC:PPCDsp.c
-RejectConnectionRequest 		vIndirect	$2050,	$0088,	A1		; {sources}OS:PPC:PPCDsp.c
-RemoveConnectionListener		vIndirect	$2050,	$008c,	A1		; {sources}OS:PPC:PPCDsp.c
-CreateConnectionEnd 			vIndirect	$2050,	$0090,	A1		; {sources}OS:PPC:PPCDsp.c
-OpenConnectionEnd				vIndirect	$2050,	$0094,	A1		; {sources}OS:PPC:PPCDsp.c
-RemoveConnectionEnd 			vIndirect	$2050,	$0098,	A1		; {sources}OS:PPC:PPCDsp.c
-WriteToConnection				vIndirect	$2050,	$009c,	A1		; {sources}OS:PPC:PPCDsp.c
-ReadFromConnection				vIndirect	$2050,	$00a0,	A1		; {sources}OS:PPC:PPCDsp.c
-ppcOpen 						vIndirect	$2050,	$00a4,	A1		; {sources}OS:PPC:PPCEntry.c
-ppcStart						vIndirect	$2050,	$00a8,	A1		; {sources}OS:PPC:PPCEntry.c
-ppcInform						vIndirect	$2050,	$00ac,	A1		; {sources}OS:PPC:PPCEntry.c
-ppcAccept						vIndirect	$2050,	$00b0,	A1		; {sources}OS:PPC:PPCEntry.c
-ppcReject						vIndirect	$2050,	$00b4,	A1		; {sources}OS:PPC:PPCEntry.c
-ppcWrite						vIndirect	$2050,	$00b8,	A1		; {sources}OS:PPC:PPCEntry.c
-ppcRead 						vIndirect	$2050,	$00bc,	A1		; {sources}OS:PPC:PPCEntry.c
-ppcEnd							vIndirect	$2050,	$00c0,	A1		; {sources}OS:PPC:PPCEntry.c
-ppcClose						vIndirect	$2050,	$00c4,	A1		; {sources}OS:PPC:PPCEntry.c
-ipcListPorts					vIndirect	$2050,	$00c8,	A1		; {sources}OS:PPC:PPCEntry.c
-PPCCommonPBEntry				vIndirect	$2050,	$00cc,	A1		; {sources}OS:PPC:PPCEntry.c
-PPCCommonPBExit 				vIndirect	$2050,	$00d0,	A1		; {sources}OS:PPC:PPCEntry.c
-NetOpenCompletion				vIndirect	$2050,	$00d4,	A1		; {sources}OS:PPC:PPCEntry.c
-CallCompletionRoutine			vIndirect	$2050,	$00d8,	A1		; {sources}OS:PPC:PPCEntry.c
-CompleteWithResult				vIndirect	$2050,	$00dc,	A1		; {sources}OS:PPC:PPCEntry.c
-VerifyLocNameFormat 			vIndirect	$2050,	$00e0,	A1		; {sources}OS:PPC:PPCEntry.c
-LocationNameLocal				vIndirect	$2050,	$00e4,	A1		; {sources}OS:PPC:PPCEntry.c
-LocNameTaken					vIndirect	$2050,	$00e8,	A1		; {sources}OS:PPC:PPCEntry.c
-BeginLocalOrRemote				vIndirect	$2050,	$00ec,	A1		; {sources}OS:PPC:PPCEntry.c
-LocalOrNot						vIndirect	$2050,	$00f0,	A1		; {sources}OS:PPC:PPCEntry.c
-DoGetMyZone 					vIndirect	$2050,	$00f4,	A1		; {sources}OS:PPC:PPCEntry.c
-DMFix							vIndirect	$2050,	$00f8,	A1		; {sources}OS:PPC:PPCEntry.c
-PPCSetUp						vIndirect	$2050,	$00fc,	A1		; {sources}OS:PPC:PPCInit.c
-AtalkEvent						vIndirect	$2050,	$0100,	A1		; {sources}OS:PPC:PPCInit.c
-EnableIncoming					vIndirect	$2050,	$0104,	A1		; {sources}OS:PPC:PPCInit.c
-DisableIncoming 				vIndirect	$2050,	$0108,	A1		; {sources}OS:PPC:PPCInit.c
-initUserGroupFile				vIndirect	$2050,	$010c,	A1		; {sources}OS:PPC:PPCInit.c
-RemoveConnectionListeners		vIndirect	$2050,	$0110,	A1		; {sources}OS:PPC:PPCInit.c
-SetUpToolBoxName				vIndirect	$2050,	$0114,	A1		; {sources}OS:PPC:PPCInit.c
-RemoveToolBoxName				vIndirect	$2050,	$0118,	A1		; {sources}OS:PPC:PPCInit.c
-SetUpConnectionListeners		vIndirect	$2050,	$011c,	A1		; {sources}OS:PPC:PPCInit.c
-PPCSleepEvent					vIndirect	$2050,	$0120,	A1		; {sources}OS:PPC:PPCInit.c
-EndAllNetworkSessions			vIndirect	$2050,	$0124,	A1		; {sources}OS:PPC:PPCInit.c
-KillUserSession 				vIndirect	$2050,	$0128,	A1		; {sources}OS:PPC:PPCInit.c
-PPCCloseUserSessions			vIndirect	$2050,	$012c,	A1		; {sources}OS:PPC:PPCInit.c
-PPCCountAcceptedNetworkSessions vIndirect	$2050,	$0130,	A1		; {sources}OS:PPC:PPCInit.c
-PPCCheckDupNBPName				vIndirect	$2050,	$0134,	A1		; {sources}OS:PPC:PPCInit.c
-PPCGESTALTFUNCTION				vIndirect	$2050,	$0138,	A1		; {sources}OS:PPC:PPCInit.c
-GetPPCGlobalFlag				vIndirect	$2050,	$013c,	A1		; {sources}OS:PPC:PPCInit.c
-PPCSHUTDOWN 					vIndirect	$2050,	$0140,	A1		; {sources}OS:PPC:PPCInit.c
-PPCSystemTask					vNoVector							; {sources}OS:PPC:PPCInit.c
-UnRegisterAllNBPNames			vIndirect	$2050,	$0144,	A1		; {sources}OS:PPC:PPCInit.c
-ReRegisterAllNBPNames			vIndirect	$2050,	$0148,	A1		; {sources}OS:PPC:PPCInit.c
-PPCDEADGESTAULT 				vIndirect	$2050,	$014c,	A1		; {sources}OS:PPC:PPCInit.c
-KillPPC 						vIndirect	$2050,	$0150,	A1		; {sources}OS:PPC:PPCInit.c
-PPCINSTALL						vIndirect	$2050,	$0154,	A1		; {sources}OS:PPC:PPCInstall.a
-setupGlobal 					vIndirect	$2050,	$0158,	A1		; {sources}OS:PPC:PPCInstall.a
-ppcLoader						vIndirect	$2050,	$015c,	A1		; {sources}OS:PPC:PPCLoader.c
-initAuth						vIndirect	$2050,	$0160,	A1		; {sources}OS:PPC:PPCLoader.c
-GetLocSess						vIndirect	$2050,	$0164,	A1		; {sources}OS:PPC:PPCLocal.c
-FreeLocSess 					vIndirect	$2050,	$0168,	A1		; {sources}OS:PPC:PPCLocal.c
-StartLocalSession				vIndirect	$2050,	$016c,	A1		; {sources}OS:PPC:PPCLocal.c
-AcceptLocalSession				vIndirect	$2050,	$0170,	A1		; {sources}OS:PPC:PPCLocal.c
-RejectLocalSession				vIndirect	$2050,	$0174,	A1		; {sources}OS:PPC:PPCLocal.c
-WriteLocalData					vIndirect	$2050,	$0178,	A1		; {sources}OS:PPC:PPCLocal.c
-ReadLocalData					vIndirect	$2050,	$017c,	A1		; {sources}OS:PPC:PPCLocal.c
-EndLocalSession 				vIndirect	$2050,	$0180,	A1		; {sources}OS:PPC:PPCLocal.c
-ListLocalPorts					vIndirect	$2050,	$0184,	A1		; {sources}OS:PPC:PPCLocal.c
-LocalTransfer					vIndirect	$2050,	$0188,	A1		; {sources}OS:PPC:PPCLocal.c
-RegisterName					vIndirect	$2050,	$018c,	A1		; {sources}OS:PPC:PPCNbp.c
-LookupName						vIndirect	$2050,	$0190,	A1		; {sources}OS:PPC:PPCNbp.c
-RemoveName						vIndirect	$2050,	$0194,	A1		; {sources}OS:PPC:PPCNbp.c
-GetRemSess						vIndirect	$2050,	$0198,	A1		; {sources}OS:PPC:PPCNetwork.c
-FreeRemSess 					vIndirect	$2050,	$019c,	A1		; {sources}OS:PPC:PPCNetwork.c
-RemoveNetworkConnection 		vIndirect	$2050,	$01a0,	A1		; {sources}OS:PPC:PPCNetwork.c
-RemoveCompletion				vIndirect	$2050,	$01a4,	A1		; {sources}OS:PPC:PPCNetwork.c
-StartNetworkSession 			vIndirect	$2050,	$01a8,	A1		; {sources}OS:PPC:PPCNetwork.c
-AcceptNetworkSession			vIndirect	$2050,	$01ac,	A1		; {sources}OS:PPC:PPCNetwork.c
-RejectNetworkSession			vIndirect	$2050,	$01b0,	A1		; {sources}OS:PPC:PPCNetwork.c
-WriteNetworkData				vIndirect	$2050,	$01b4,	A1		; {sources}OS:PPC:PPCNetwork.c
-ReadNetworkData 				vIndirect	$2050,	$01b8,	A1		; {sources}OS:PPC:PPCNetwork.c
-EndNetworkSession				vIndirect	$2050,	$01bc,	A1		; {sources}OS:PPC:PPCNetwork.c
-ListNetworkPorts				vIndirect	$2050,	$01c0,	A1		; {sources}OS:PPC:PPCNetwork.c
-BeginNetworkConnection			vIndirect	$2050,	$01c4,	A1		; {sources}OS:PPC:PPCNetwork.c
-AcceptNetworkConnection 		vIndirect	$2050,	$01c8,	A1		; {sources}OS:PPC:PPCNetwork.c
-NetLookUpCompletion 			vIndirect	$2050,	$01cc,	A1		; {sources}OS:PPC:PPCNetwork.c
-ConnectionEndCompletion 		vIndirect	$2050,	$01d0,	A1		; {sources}OS:PPC:PPCNetwork.c
-OpenCompletion					vIndirect	$2050,	$01d4,	A1		; {sources}OS:PPC:PPCNetwork.c
-StartSendCompletion 			vIndirect	$2050,	$01d8,	A1		; {sources}OS:PPC:PPCNetwork.c
-StartCommandCompletion			vIndirect	$2050,	$01dc,	A1		; {sources}OS:PPC:PPCNetwork.c
-ListSendCompletion				vIndirect	$2050,	$01e0,	A1		; {sources}OS:PPC:PPCNetwork.c
-ListReadCompletion				vIndirect	$2050,	$01e4,	A1		; {sources}OS:PPC:PPCNetwork.c
-ListCommandCompletion			vIndirect	$2050,	$01e8,	A1		; {sources}OS:PPC:PPCNetwork.c
-ConnectionRequestCompletion 	vIndirect	$2050,	$01ec,	A1		; {sources}OS:PPC:PPCNetwork.c
-RespConnectionEndCompletion 	vIndirect	$2050,	$01f0,	A1		; {sources}OS:PPC:PPCNetwork.c
-RespOpenCompletion				vIndirect	$2050,	$01f4,	A1		; {sources}OS:PPC:PPCNetwork.c
-RecvSessReqCompletion			vIndirect	$2050,	$01f8,	A1		; {sources}OS:PPC:PPCNetwork.c
-GuestRecCompletion				vIndirect	$2050,	$01fc,	A1		; {sources}OS:PPC:PPCNetwork.c
-UserRecCompletion				vIndirect	$2050,	$0200,	A1		; {sources}OS:PPC:PPCNetwork.c
-AuthSendCompletion				vIndirect	$2050,	$0204,	A1		; {sources}OS:PPC:PPCNetwork.c
-AuthRespCompletion				vIndirect	$2050,	$0208,	A1		; {sources}OS:PPC:PPCNetwork.c
-ProcessInform					vIndirect	$2050,	$020c,	A1		; {sources}OS:PPC:PPCNetwork.c
-RespSendCompletion				vIndirect	$2050,	$0210,	A1		; {sources}OS:PPC:PPCNetwork.c
-ARepostConnectionListener		vIndirect	$2050,	$0214,	A1		; {sources}OS:PPC:PPCNetwork.c
-RepostConnectionListener		vIndirect	$2050,	$0218,	A1		; {sources}OS:PPC:PPCNetwork.c
-ListWrite						vIndirect	$2050,	$021c,	A1		; {sources}OS:PPC:PPCNetwork.c
-ListWriteCompletion 			vIndirect	$2050,	$0220,	A1		; {sources}OS:PPC:PPCNetwork.c
-ListRespCompletion				vIndirect	$2050,	$0224,	A1		; {sources}OS:PPC:PPCNetwork.c
-BeginWriteBlock 				vIndirect	$2050,	$0228,	A1		; {sources}OS:PPC:PPCNetwork.c
-WriteHdrCompletion				vIndirect	$2050,	$022c,	A1		; {sources}OS:PPC:PPCNetwork.c
-WriteBlockData					vIndirect	$2050,	$0230,	A1		; {sources}OS:PPC:PPCNetwork.c
-WriteBlockDataCompletion		vIndirect	$2050,	$0234,	A1		; {sources}OS:PPC:PPCNetwork.c
-CompleteWriteRequest			vIndirect	$2050,	$0238,	A1		; {sources}OS:PPC:PPCNetwork.c
-BeginReadBlock					vIndirect	$2050,	$023c,	A1		; {sources}OS:PPC:PPCNetwork.c
-ReadHdrCompletion				vIndirect	$2050,	$0240,	A1		; {sources}OS:PPC:PPCNetwork.c
-ReadBlockData					vIndirect	$2050,	$0244,	A1		; {sources}OS:PPC:PPCNetwork.c
-ReadDataCompletion				vIndirect	$2050,	$0248,	A1		; {sources}OS:PPC:PPCNetwork.c
-CompleteReadRequest 			vIndirect	$2050,	$024c,	A1		; {sources}OS:PPC:PPCNetwork.c
-CopyReadBlk 					vIndirect	$2050,	$0250,	A1		; {sources}OS:PPC:PPCNetwork.c
-ClosePortTable					vIndirect	$2050,	$0254,	A1		; {sources}OS:PPC:PPCPort.c
-NBPRemoveCompletion 			vIndirect	$2050,	$0258,	A1		; {sources}OS:PPC:PPCPort.c
-CompleteClosePort				vIndirect	$2050,	$025c,	A1		; {sources}OS:PPC:PPCPort.c
-CheckPortName					vIndirect	$2050,	$0260,	A1		; {sources}OS:PPC:PPCPort.c
-ValidPortName					vIndirect	$2050,	$0264,	A1		; {sources}OS:PPC:PPCPort.c
-ComparePortName 				vIndirect	$2050,	$0268,	A1		; {sources}OS:PPC:PPCPort.c
-GetLocationName 				vIndirect	$2050,	$026c,	A1		; {sources}OS:PPC:PPCPort.c
-PortRefNumCompare				vIndirect	$2050,	$0270,	A1		; {sources}OS:PPC:PPCPort.c
-DeletePortByRefNum				vIndirect	$2050,	$0274,	A1		; {sources}OS:PPC:PPCPort.c
-PortRefNumtoPtr 				vIndirect	$2050,	$0278,	A1		; {sources}OS:PPC:PPCPort.c
-GetUniquePortRefNum 			vIndirect	$2050,	$027c,	A1		; {sources}OS:PPC:PPCPort.c
-GetPortTable					vIndirect	$2050,	$0280,	A1		; {sources}OS:PPC:PPCPort.c
-FreePortTable					vIndirect	$2050,	$0284,	A1		; {sources}OS:PPC:PPCPort.c
-SetPortInformQue				vIndirect	$2050,	$0288,	A1		; {sources}OS:PPC:PPCPort.c
-GetPortNames					vIndirect	$2050,	$028c,	A1		; {sources}OS:PPC:PPCPort.c
-WildPortMatch					vIndirect	$2050,	$0290,	A1		; {sources}OS:PPC:PPCPort.c
-QueueFromSessRefNum 			vIndirect	$2050,	$0294,	A1		; {sources}OS:PPC:PPCSession.c
-SessRefNumCompare				vIndirect	$2050,	$0298,	A1		; {sources}OS:PPC:PPCSession.c
-SessRefNumtoPtr 				vIndirect	$2050,	$029c,	A1		; {sources}OS:PPC:PPCSession.c
-DeleteSessByRefNum				vIndirect	$2050,	$02a0,	A1		; {sources}OS:PPC:PPCSession.c
-GetSessionRefNum				vIndirect	$2050,	$02a4,	A1		; {sources}OS:PPC:PPCSession.c
-SetSessionTable 				vIndirect	$2050,	$02a8,	A1		; {sources}OS:PPC:PPCSession.c
-PortSessCompare 				vIndirect	$2050,	$02ac,	A1		; {sources}OS:PPC:PPCSession.c
-CleanSessions					vIndirect	$2050,	$02b0,	A1		; {sources}OS:PPC:PPCSession.c
-KillReadAndWrite				vIndirect	$2050,	$02b4,	A1		; {sources}OS:PPC:PPCSession.c
-getGlobal						vNoVector							; {sources}OS:PPC:PPCUtil.a
-callCompletion					vIndirect	$2050,	$02b8,	A1		; {sources}OS:PPC:PPCUtil.a
-AddtoAtalkQ 					vIndirect	$2050,	$02bc,	A1		; {sources}OS:PPC:PPCUtil.a
-RmvfromAtalkQ					vIndirect	$2050,	$02c0,	A1		; {sources}OS:PPC:PPCUtil.a
-FakeCompletion					vIndirect	$2050,	$02c4,	A1		; {sources}OS:PPC:PPCUtil.a
-PointerCompare					vIndirect	$2050,	$02c8,	A1		; {sources}OS:PPC:PPCUtilities.c
-EnQueue 						vIndirect	$2050,	$02cc,	A1		; {sources}OS:PPC:PPCUtilities.c
-ServeQueue						vIndirect	$2050,	$02d0,	A1		; {sources}OS:PPC:PPCUtilities.c
-SearchQueue 					vIndirect	$2050,	$02d4,	A1		; {sources}OS:PPC:PPCUtilities.c
-DeleteFromQueue 				vIndirect	$2050,	$02d8,	A1		; {sources}OS:PPC:PPCUtilities.c
-DeleteMultiple					vIndirect	$2050,	$02dc,	A1		; {sources}OS:PPC:PPCUtilities.c
-NewMem							vIndirect	$2050,	$02e0,	A1		; {sources}OS:PPC:PPCUtilities.c
-DisposeMem						vIndirect	$2050,	$02e4,	A1		; {sources}OS:PPC:PPCUtilities.c
-AddNew							vIndirect	$2050,	$02e8,	A1		; {sources}OS:PPC:PPCUtilities.c
-RemOld							vIndirect	$2050,	$02ec,	A1		; {sources}OS:PPC:PPCUtilities.c
-Replenish						vNoVector							; {sources}OS:PPC:PPCUtilities.c
-Excess							vNoVector							; {sources}OS:PPC:PPCUtilities.c
-PRMTFUSER						vIndirect	$2050,	$02f0,	A7		; {sources}OS:PPC:PromptForUser.a
-PROMPTFORUSER					vIndirect	$2050,	$02f4,	A7		; {sources}OS:PPC:PromptForUser.a
-GETPASSWORDBULLET				vIndirect	$2050,	$02f8,	A1		; {sources}OS:PPC:PromptForUser.c
-GetIntlTokenChar				vIndirect	$2050,	$02fc,	A1		; {sources}OS:PPC:PromptForUser.c
-FRK 							vDataTable							; {sources}Objects:ROM:PPC.lib
-PERMUTE 						vDataTable							; {sources}Objects:ROM:PPC.lib
-PTBL							vDataTable							; {sources}Objects:ROM:PPC.lib
-IPINVTBL						vDataTable							; {sources}Objects:ROM:PPC.lib
-IP								vDataTable							; {sources}Objects:ROM:PPC.lib
-KEYSCHED						vIndirect	$2050,	$0300,	A1		; {sources}Objects:ROM:PPC.lib
-ENCODE							vIndirect	$2050,	$0304,	A1		; {sources}Objects:ROM:PPC.lib
-
-;============================== End PPC Vectors
-
 ;============================== Quickdraw Vectors
 
 ANGLEFROMSLOPE					vATrap	 	A???					; {sources}QuickDraw:ANGLES.a
@@ -2699,8 +2223,8 @@ INITCRTABLE 					vDataTable							; {sources}QuickDraw:cCrsrCore.a
 CRSRVBLTASK 					vIndirect	$2054,	$0390,	A7		; {sources}QuickDraw:cCrsrCore.a
 PINRECT 						vATrap	 	A???					; {sources}QuickDraw:cCrsrCore.a
 CURSORSECT						vIndirect	$2054,	$0394,	A7		; {sources}QuickDraw:cCrsrCore.a
-ERASECURSOR 					vIndirect	$2054,	$0398,	A7		; {sources}QuickDraw:cCrsrCore.a
-DRAWCURSOR						vIndirect	$2054,	$039c,	A7		; {sources}QuickDraw:cCrsrCore.a
+ERASECURSOR 					vNoVector							; {sources}QuickDraw:cCrsrCore.a
+DRAWCURSOR						vNoVector							; {sources}QuickDraw:cCrsrCore.a
 GETMAINCRSR 					vIndirect	$2054,	$03a0,	A7		; {sources}QuickDraw:cCrsrCore.a
 SETCRSRDATA 					vIndirect	$2054,	$03a4,	A7		; {sources}QuickDraw:cCrsrCore.a
 ALLOCCRSR						vATrap	 	A???					; {sources}QuickDraw:cCrsrCore.a
@@ -2842,513 +2366,6 @@ GETNEXTFOND 					vIndirect	$2058,	$0090,	A7		; {sources}Toolbox:ResourceMgr:Reso
 
 ;============================== End Resource Manager Vectors
 
-;============================== SCSI Manager Vectors
-
-;————— Old SCSI Manager
-SCSIDISPATCHCOMMON				vATrap	 	A???					; {sources}OS:SCSIMgr:SCSILinkPatch.a
-SCSIBUSYPLUS					vIndirect	$205C,	$0004,	A7		; {sources}OS:SCSIMgr:SCSILinkPatch.a
-SCSIBUSYOTHERS					vIndirect	$205C,	$0008,	A7		; {sources}OS:SCSIMgr:SCSILinkPatch.a
-SCSIBOOTS						vIndirect	$205C,	$000c,	A7		; {sources}OS:SCSIMgr:scsiboot.a
-SCSILOAD						vIndirect	$205C,	$0010,	A7		; {sources}OS:SCSIMgr:scsiboot.a
-SCSI96							vNoVector							; {sources}OS:SCSIMgr:scsimgr96.a
-SCSIMGR_96						vIndirect	$205C,	$0014,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-UNIMPLEMENTED_96				vIndirect	$205C,	$0018,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSISTAT_96					vIndirect	$205C,	$001c,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSIRESET_96					vIndirect	$205C,	$0020,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSIGET_96					vIndirect	$205C,	$0024,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSISELECT_D96				vIndirect	$205C,	$0028,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSISELATN_D96				vIndirect	$205C,	$002c,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSISELECT_S96				vIndirect	$205C,	$0030,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSISELATN_S96				vIndirect	$205C,	$0034,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSICMD_96					vIndirect	$205C,	$0038,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-NEWSCSIWBLIND_96				vIndirect	$205C,	$003c,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-NEWSCSIWRITE_96 				vIndirect	$205C,	$0040,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-NEWSCSIRBLIND_96				vIndirect	$205C,	$0044,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-NEWSCSIREAD_96					vIndirect	$205C,	$0048,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSICOMPLETE_96				vIndirect	$205C,	$004c,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSIMSGIN_96					vIndirect	$205C,	$0050,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-DOSCSIMSGOUT_96 				vIndirect	$205C,	$0054,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-CYCLEPHASE_96					vIndirect	$205C,	$0058,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-SCSIPCTO32BIT					vIndirect	$205C,	$005c,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-ERROR							vIndirect	$205C,	$0060,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-SCSIERR_96						vIndirect	$205C,	$0064,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-SWAPMMU 						vIndirect	$205C,	$0068,	A7		; {sources}OS:SCSIMgr:scsimgr96.a
-SCSIHW							vNoVector							; {sources}OS:SCSIMgr:scsimgrhw.a
-DOSPINDOWN						vNoVector							; {sources}OS:SCSIMgr:scsimgrhw.a
-SLEEPTASK						vNoVector							; {sources}OS:SCSIMgr:scsimgrhw.a
-CLEARIRQ						vIndirect	$205C,	$006c,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-DISENABLE						vIndirect	$205C,	$0070,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-BUSERRHANDLER					vIndirect	$205C,	$0074,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-ARB 							vIndirect	$205C,	$0078,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-SEL 							vIndirect	$205C,	$007c,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-DELAY22 						vIndirect	$205C,	$0080,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-SCSIINTHND						vIndirect	$205C,	$0084,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-TRANSFER						vIndirect	$205C,	$0088,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-SLOWREAD						vIndirect	$205C,	$008c,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-SLOWWRITE						vIndirect	$205C,	$0090,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-VFASTWRITEOSS					vIndirect	$205C,	$0094,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-PFASTWRITEOSS					vIndirect	$205C,	$0098,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-PFASTWRITE						vIndirect	$205C,	$009c,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-VFASTWRITE						vIndirect	$205C,	$00a0,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-FASTWRITE						vIndirect	$205C,	$00a4,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-FASTWRITEOSS					vIndirect	$205C,	$00a8,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-VFASTREADOSS					vIndirect	$205C,	$00ac,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-PFASTREADOSS					vIndirect	$205C,	$00b0,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-PFASTREAD						vIndirect	$205C,	$00b4,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-VFASTREAD						vIndirect	$205C,	$00b8,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-FASTREAD						vIndirect	$205C,	$00bc,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-FASTREADOSS 					vIndirect	$205C,	$00c0,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-SLOWCOMP						vIndirect	$205C,	$00c4,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-FASTCOMP						vIndirect	$205C,	$00c8,	A7		; {sources}OS:SCSIMgr:scsimgrhw.a
-SCSIHW96						vNoVector							; {sources}OS:SCSIMgr:scsimgrhw96.a
-INITHW_SCSI96					vNoVector							; {sources}OS:SCSIMgr:scsimgrhw96.a
-INTHND_SCSI96					vIndirect	$205C,	$00cc,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-TRANSFER_96 					vIndirect	$205C,	$00d0,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-XFER1BYTE						vIndirect	$205C,	$00d4,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-SLOWREAD_96 					vIndirect	$205C,	$00d8,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-SLOWWRITE_96					vIndirect	$205C,	$00dc,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-FASTWRITE_96					vIndirect	$205C,	$00e0,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-FASTREAD_96 					vIndirect	$205C,	$00e4,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-RESETBUS_96 					vIndirect	$205C,	$00e8,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-WAITFORINTNOTIME				vIndirect	$205C,	$00ec,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-HANDLESELINPROG 				vIndirect	$205C,	$00f0,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-WT4DREQORINT					vIndirect	$205C,	$00f4,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-WAITFORSCSIINTRP				vIndirect	$205C,	$00f8,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-FASTCOMP_96 					vIndirect	$205C,	$00fc,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-SLOWCOMP_96 					vIndirect	$205C,	$0100,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-BUSERRHANDLER_96				vIndirect	$205C,	$0104,	A7		; {sources}OS:SCSIMgr:scsimgrhw96.a
-SCSIINIT						vNoVector							; {sources}OS:SCSIMgr:scsimgrinit.a
-INITSCSIMGR 					vNoVector							; {sources}OS:SCSIMgr:scsimgrinit.a
-INITSCSIHW						vNoVector							; {sources}OS:SCSIMgr:scsimgrinit.a
-SCSIINIT96						vNoVector							; {sources}OS:SCSIMgr:scsimgrinit96.a
-INITMGR_SCSI96					vNoVector							; {sources}OS:SCSIMgr:scsimgrinit96.a
-SCSISETFLAGS					vIndirect	$205C,	$0108,	A7		; {sources}OS:SCSIMgr:scsimgrinitflags.a
-SCSINEW 						vNoVector							; {sources}OS:SCSIMgr:scsimgrnew.a
-NEWSCSITRAP 					vATrap		A???					; {sources}OS:SCSIMgr:scsimgrnew.a
-ALTBUSCALL						vIndirect	$205C,	$010c,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-DOREQUESTIO 					vIndirect	$205C,	$0110,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-DOKILLIO						vIndirect	$205C,	$0114,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-DOBUSINFO						vIndirect	$205C,	$0118,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-RESETBUS						vIndirect	$205C,	$011c,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-ENDEQUEUE						vIndirect	$205C,	$0120,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-LOGERROR						vIndirect	$205C,	$0124,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-CLEARSTATE						vIndirect	$205C,	$0128,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-CLEARBUS						vIndirect	$205C,	$012c,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MESSAGE 						vIndirect	$205C,	$0130,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-PREFLIGHT						vIndirect	$205C,	$0134,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-SETUP							vIndirect	$205C,	$0138,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-FIND							vIndirect	$205C,	$013c,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-SETTIMER						vIndirect	$205C,	$0140,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-TIMETASK						vIndirect	$205C,	$0144,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-SCSIDT							vIndirect	$205C,	$0148,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-COMMAND 						vIndirect	$205C,	$014c,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-STATUSPHASE 					vIndirect	$205C,	$0150,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGIN							vIndirect	$205C,	$0154,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGINVALIDIN					vIndirect	$205C,	$0158,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGIDENTIFYIN					vIndirect	$205C,	$015c,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGCMDCOMPLETE					vIndirect	$205C,	$0160,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGSAVEDATAPTR					vIndirect	$205C,	$0164,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGRESTOREPTRS					vIndirect	$205C,	$0168,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGDISCONNECT					vIndirect	$205C,	$016c,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGMSGREJIN 					vIndirect	$205C,	$0170,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGLCCF 						vIndirect	$205C,	$0174,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGOUT							vIndirect	$205C,	$0178,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGIDENTIFYOUT					vIndirect	$205C,	$017c,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGBUSDEVRST					vIndirect	$205C,	$0180,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGMSGREJOUT					vIndirect	$205C,	$0184,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGINVALIDOUT					vIndirect	$205C,	$0188,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGKILLIO						vIndirect	$205C,	$018c,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-MSGNOOP 						vIndirect	$205C,	$0190,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-DATAIO							vIndirect	$205C,	$0194,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-DATADMA 						vIndirect	$205C,	$0198,	A7		; {sources}OS:SCSIMgr:scsimgrnew.a
-SCSIOLD 						vNoVector							; {sources}OS:SCSIMgr:scsimgrold.a
-SCSIMGR 						vATrap		A???					; {sources}OS:SCSIMgr:scsimgrold.a
-UNIMPLEMENTED					vIndirect	$205C,	$019c,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-DOSCSISTAT						vIndirect	$205C,	$01a0,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-DOSCSIRESET 					vIndirect	$205C,	$01a4,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-DOSCSIGET						vIndirect	$205C,	$01a8,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-DOSCSISELECT					vIndirect	$205C,	$01ac,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-DOSCSISELATN					vIndirect	$205C,	$01b0,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-DOSCSICMD						vIndirect	$205C,	$01b4,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-NEWSCSIWBLIND					vIndirect	$205C,	$01b8,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-NEWSCSIWRITE					vIndirect	$205C,	$01bc,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-NEWSCSIRBLIND					vIndirect	$205C,	$01c0,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-NEWSCSIREAD 					vIndirect	$205C,	$01c4,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-DOSCSICOMPLETE					vIndirect	$205C,	$01c8,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-DOSCSIMSGIN 					vIndirect	$205C,	$01cc,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-DOSCSIMSGOUT					vIndirect	$205C,	$01d0,	A7		; {sources}OS:SCSIMgr:scsimgrold.a
-LATELOAD						vIndirect	$205C,	$01d4,	A7		; {sources}OS:SCSIMgr:scsiLateLoad.a
-
-SCSIDISKMODE vNoVector
-SCSIDISKWAKEALERT vNoVector
-TESTFORDISKMODE vNoVector
-SCSICYC96 vNoVector
-SCSIERR_PSC vNoVector
-NEWSCSIRBLIND_PSC vNoVector
-NEWSCSIWBLIND_PSC vNoVector
-NEWSCSIWRITE_PSC vNoVector
-NEWSCSIREAD_PSC vNoVector
-DOSCSIMSGIN_PSC vNoVector
-DOSCSIGET_PSC vNoVector
-DOSCSIRESET_PSC vNoVector
-UNIMPLEMENTED_PSC vNoVector
-ERROR_PSC vNoVector
-SCSIPCTO32BIT_PSC vNoVector
-DOSCSIMSGOUT_PSC vNoVector
-DOSCSISTAT_PSC vNoVector
-CYCLEPHASE_PSC vNoVector
-DOSCSISELATN_DPSC vNoVector
-DOSCSISELATN_SPSC vNoVector
-DOSCSISELECT_DPSC vNoVector
-DOSCSISELECT_SPSC vNoVector
-DOSCSICOMPLETE_PSC vNoVector
-DOSCSICMD_PSC vNoVector
-SCSIMGR_PSC vNoVector
-SCSICYCHW96 vNoVector
-WAITFORINTNOTIME_PSC vNoVector
-FASTCOMP_PSC vNoVector
-FASTWRITE_PSC vNoVector
-FASTREAD_PSC vNoVector
-SLOWCOMP_PSC vNoVector
-SLOWWRITE_PSC vNoVector
-INTHND_SCSI_PSC vNoVector
-INITHW_SCSI_PSC vNoVector
-BUSERRHANDLER_PSC vNoVector
-WAITFORSCSIINTRP_PSC vNoVector
-RESETBUS_PSC vNoVector
-HANDLESELINPROGPSC vNoVector
-WT4DREQORINTPSC vNoVector
-XFER1BYTE_PSC vNoVector
-TRANSFER_PSC vNoVector
-SLOWREAD_PSC vNoVector
-SCSIMGRINITPSC vNoVector
-INITMGR_SCSI_PSC vNoVector
-SCSIC96INSTALL vNoVector
-PATCHSCSIDRIVERS vNoVector
-SCSIPATCHTOBLOCKIOINDRIVER vNoVector
-
-;————— SCSI Manager 4.3												; {sources}OS:SCSIMgr4pt3:≈
-SCSIAtomic						vATrap	 	A???									
-
-JmpToDrvr						vIndirect	$205C,	$01d8,	A7, hasAsyncSCSI		; BootItt.a
-CheckSumDrvr					vIndirect	$205C,	$01dc,	A7, hasAsyncSCSI		; BootItt.a
-;					UNUSED		vIndirect	$205C,	$01e0,	A1, hasAsyncSCSI		; BootItt.c
-;					UNUSED		vIndirect	$205C,	$01e4,	A1, hasAsyncSCSI		; BootItt.c
-;					UNUSED		vIndirect	$205C,	$01e8,	A1, hasAsyncSCSI		; BootItt.c
-ScanDrive						vIndirect	$205C,	$01ec,	A1, hasAsyncSCSI		; BootItt.c
-LoadDriver						vIndirect	$205C,	$01f0,	A1, hasAsyncSCSI		; BootItt.c
-ScRead							vIndirect	$205C,	$01f4,	A1, hasAsyncSCSI		; BootItt.c
-;					UNUSED		vIndirect	$205C,	$01f8,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$01fc,	Ax, hasAsyncSCSI		; HALc96.a
-RecordEvent						vIndirect	$205C,	$0200,	A7, hasAsyncSCSI		; Recorder.a
-;					UNUSED		vIndirect	$205C,	$0204,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0208,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$020c,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0210,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0214,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0218,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$021c,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0220,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0224,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0228,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$022c,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0230,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0234,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$0238,	Ax, hasAsyncSCSI		; HALc96.a
-;					UNUSED		vIndirect	$205C,	$023c,	Ax, hasAsyncSCSI		; HALc96.a
-SIMRegisterHAL					vIndirect	$205C,	$0240,	A1, hasAsyncSCSI		; HALc96Data.a
-SIMReregisterHAL				vIndirect	$205C,	$0244,	A1, hasAsyncSCSI		; HALc96Data.a
-SIMRegisterCommon				vIndirect	$205C,	$0248,	A1, hasAsyncSCSI		; HALc96Data.a
-EarlySwitchPhase				vIndirect	$205C,	$024c,	A1, hasAsyncSCSI		; HALc96Data.a
-WastePhase						vIndirect	$205C,	$0250,	A1, hasAsyncSCSI		; HALc96Data.a
-HandleInitWErr					vIndirect	$205C,	$0254,	A1, hasAsyncSCSI		; HALc96Data.a
-HandleRejectedIdentify			vIndirect	$205C,	$0258,	A1, hasAsyncSCSI		; HALc96Data.a
-HandleEarlyMsgIn				vIndirect	$205C,	$025c,	A1, hasAsyncSCSI		; SIMmachine.c
-HandleNoIdentifyMsg				vIndirect	$205C,	$0260,	A1, hasAsyncSCSI		; HALc96Data.a
-CallMachine						vIndirect	$205C,	$0264,	A1, hasAsyncSCSI		; HALc96Data.a
-GetVirtualIDInfo 				vIndirect	$205C,	$0268,	A1, hasAsyncSCSI		; HALc96Data.a
-CheckInterrupts 				vIndirect	$205C,	$026c,	A1, hasAsyncSCSI		; HALc96Data.a
-XPTCallCompRoutine 				vIndirect	$205C,	$0270,	A1, hasAsyncSCSI		; HALc96Data.a
-SIMIntPoll 						vIndirect	$205C,	$0274,	A1, hasAsyncSCSI		; HALc96Data.a
-SetupResetPB 					vIndirect	$205C,	$0278,	A1, hasAsyncSCSI		; HALc96Data.a
-ValidateDeviceIdent 			vIndirect	$205C,	$027c,	A1, hasAsyncSCSI		; HALc96HWInit.a
-TryToRecover					vIndirect	$205C,	$0280,	A1, hasAsyncSCSI		; HALc96Init.a
-XPTRegisterCommon				vIndirect	$205C,	$0284,	A1, hasAsyncSCSI		; HALc96HWInit.a
-NewXPTioPB						vIndirect	$205C,	$0288,	A1, hasAsyncSCSI		; HALc96PSC.a
-;					UNUSED		vIndirect	$205C,	$028c,	Ax, hasAsyncSCSI		; HALc96DMA.a
-;					UNUSED		vIndirect	$205C,	$0290,	Ax, hasAsyncSCSI		; HALc96DMA.a
-;					UNUSED		vIndirect	$205C,	$0294,	Ax, hasAsyncSCSI		; HALc96DMA.a
-COMPRESETDEVICE 				vIndirect	$205C,	$0298,	A7, hasAsyncSCSI		; HALc96DMA.a
-Disconnected					vIndirect	$205C,	$029c,	A1, hasAsyncSCSI		; HALc96Routines.a
-ciDebuggerPatch					vIndirect	$205C,	$02a0,	A7, hasAsyncSCSI		; XPT.a
-ReRegisterAllSIMs				vIndirect	$205C,	$02a4,	A1, hasAsyncSCSI		; XPT.c
-;					UNUSED		vIndirect	$205C,	$02a8,	Ax, hasAsyncSCSI		; HALc96Routines.a
-;					UNUSED		vIndirect	$205C,	$02ac,	Ax, hasAsyncSCSI		; HALc96Routines.a
-;					UNUSED		vIndirect	$205C,	$02b0,	Ax, hasAsyncSCSI		; HALc96Routines.a
-;					UNUSED		vIndirect	$205C,	$02b4,	Ax, hasAsyncSCSI		; HALc96Routines.a
-Ck4SCSIInt						vIndirect	$205C,	$02b8,	A7, hasAsyncSCSI		; HALc96Routines.a
-Wt4SCSIInt			 			vIndirect	$205C,	$02bc,	A7, hasAsyncSCSI		; InitItt.c
-Ck4DREQ 						vIndirect	$205C,	$02c8,	A7, hasAsyncSCSI		; HALc96Routines.a
-;					UNUSED		vIndirect	$205C,	$02c0,	Ax, hasAsyncSCSI		; HALc96Routines.a
-;					UNUSED		vIndirect	$205C,	$02c4,	Ax, hasAsyncSCSI		; HALc96Routines.a
-
-;					UNUSED		vIndirect	$205C,	$02cc,	Ax, hasAsyncSCSI		; 
-;					UNUSED		vIndirect	$205C,	$02d0,	Ax, hasAsyncSCSI		;
-;					UNUSED		vIndirect	$205C,	$02d4,	Ax, hasAsyncSCSI		; 
-;					UNUSED		vIndirect	$205C,	$02d8,	Ax, hasAsyncSCSI		; 
-;					UNUSED		vIndirect	$205C,	$02dc,	Ax, hasAsyncSCSI		; 
-;					UNUSED		vIndirect	$205C,	$02e0,	Ax, hasAsyncSCSI		; Recorder.a
-CallOldXPT						vIndirect	$205C,	$02e4,	A7, hasAsyncSCSI		; SCSIGlue.a
-;					UNUSED		vIndirect	$205C,	$02e8,	Ax, hasAsyncSCSI		; SCSIGlue.a
-;					UNUSED		vIndirect	$205C,	$02ec,	Ax, hasAsyncSCSI		; SCSIGlue.a
-;					UNUSED		vIndirect	$205C,	$02f0,	Ax, hasAsyncSCSI		; SCSIGlue.a
-SIMaction						vIndirect	$205C,	$02f4,	A1, hasAsyncSCSI		; SIMCore.c
-NewOldCall						vIndirect	$205C,	$02f8,	A1, hasAsyncSCSI		; SIMCore.c
-SIMinit 						vIndirect	$205C,	$02fc,	A1, hasAsyncSCSI		; SIMCore.c
-SIM_ISR 						vIndirect	$205C,	$0300,	A1, hasAsyncSCSI		; SIMCore.c
-ResetSIM						vIndirect	$205C,	$0304,	A1, hasAsyncSCSI		; SIMCore.c
-ResetDevice 					vIndirect	$205C,	$0308,	A1, hasAsyncSCSI		; SIMCore.c
-TerminateIO 					vIndirect	$205C,	$030c,	A1, hasAsyncSCSI		; SIMCore.c
-AbortCommand					vIndirect	$205C,	$0310,	A1, hasAsyncSCSI		; SIMCore.c
-SetTempXPTg						vIndirect	$205C,	$0314,	A1, hasAsyncSCSI		; XPT.c
-EnQIO							vIndirect	$205C,	$0318,	A1, hasAsyncSCSI		; SIMQ.c
-DeQIO							vIndirect	$205C,	$031c,	A1, hasAsyncSCSI		; SIMQ.c
-GetNextReadyIO					vIndirect	$205C,	$0320,	A1, hasAsyncSCSI		; SIMQ.c
-ResetQueues 					vIndirect	$205C,	$0324,	A1, hasAsyncSCSI		; SIMQ.c
-GetNextAutoSense				vIndirect	$205C,	$0328,	A1, hasAsyncSCSI		; SIMQ.c
-FindIO							vIndirect	$205C,	$032c,	A1, hasAsyncSCSI		; SIMQ.c
-SwitchQ 						vIndirect	$205C,	$0330,	A1, hasAsyncSCSI		; SIMQ.c
-;					UNUSED		vIndirect	$205C,	$0334,	Ax, hasAsyncSCSI		; SIMmachine.a
-;					UNUSED		vIndirect	$205C,	$0338,	Ax, hasAsyncSCSI		; SIMmachine.a
-VMEnableUserCode				vIndirect	$205C,	$033c,	A7, hasAsyncSCSI		; SIMmachine.a
-VMDisableUserCode				vIndirect	$205C,	$0340,	A7, hasAsyncSCSI		; SIMmachine.a
-TheMachine 						vIndirect	$205C,	$0344,	A1, hasAsyncSCSI		; SIMmachine.c
-Reconnect						vIndirect	$205C,	$0348,	A1, hasAsyncSCSI		; SIMmachine.c
-SwitchPhase 					vIndirect	$205C,	$034c,	A1, hasAsyncSCSI		; SIMmachine.c
-FreeMachine 					vIndirect	$205C,	$0350,	A1, hasAsyncSCSI		; SIMmachine.c
-StartMachine					vIndirect	$205C,	$0354,	A1, hasAsyncSCSI		; SIMmachine.c
-NewIOStartMachine				vIndirect	$205C,	$0358,	A1, hasAsyncSCSI		; SIMmachine.c
-;					UNUSED		vIndirect	$205C,	$035c,	Ax, hasAsyncSCSI		; SIMmachine.c
-CompleteIO						vIndirect	$205C,	$0360,	A1, hasAsyncSCSI		; SIMmachine.c
-;					UNUSED		vIndirect	$205C,	$0364,	Ax, hasAsyncSCSI		; SIMmachine.c
-CheckErrors 					vIndirect	$205C,	$0368,	A1, hasAsyncSCSI		; SIMmachine.c
-SetupSensePB					vIndirect	$205C,	$036c,	A1, hasAsyncSCSI		; SIMmachine.c
-COMPAUTOSENSE					vIndirect	$205C,	$0370,	A1, hasAsyncSCSI		; SIMmachine.c
-ValidatePB						vIndirect	$205C,	$0374,	A1, hasAsyncSCSI		; SIMmachine.c
-StartTimer						vIndirect	$205C,	$0378,	A1, hasAsyncSCSI		; Timeout.c
-SIMTimerProc					vIndirect	$205C,	$037c,	A7, hasAsyncSCSI		; Timeout.c
-;					UNUSED		vIndirect	$205C,	$0380,	Ax, hasAsyncSCSI		; XPT.a
-;					UNUSED	 	vIndirect	$205C,	$0384,	Ax, hasAsyncSCSI		; XPT.a
-;					UNUSED		vIndirect	$205C,	$0388,	Ax, hasAsyncSCSI		; XPT.a
-;					UNUSED		vIndirect	$205C,	$038c,	Ax, hasAsyncSCSI		; XPT.a
-;					UNUSED		vIndirect	$205C,	$0390,	Ax, hasAsyncSCSI		; XPT.a
-;					UNUSED		vIndirect	$205C,	$0394,	Ax, hasAsyncSCSI		; XPT.c
-;					UNUSED		vIndirect	$205C,	$0398,	Ax, hasAsyncSCSI		; XPT.c
-;					UNUSED		vIndirect	$205C,	$039c,	Ax, hasAsyncSCSI		; XPT.c
-XPTRegisterBus					vIndirect	$205C,	$03a0,	A1, hasAsyncSCSI		; XPT.c
-XPTDeregisterBus				vIndirect	$205C,	$03a4,	A1, hasAsyncSCSI		; XPT.c
-XPTAction						vIndirect	$205C,	$03a8,	A1, hasAsyncSCSI		; XPT.c
-CallSIMaction					vIndirect	$205C,	$03ac,	A1, hasAsyncSCSI		; XPT.c
-SyncWait						vIndirect	$205C,	$03b0,	A1, hasAsyncSCSI		; XPT.c
-XPTKillXPT	 					vIndirect	$205C,	$03b4,	A1, hasAsyncSCSI		; XPT.c
-DispatchISR 					vIndirect	$205C,	$03b8,	A1, hasAsyncSCSI		; XPT.c
-SetRefNum						vIndirect	$205C,	$03bc,	A1, hasAsyncSCSI		; XPT.c
-GetRefNum						vIndirect	$205C,	$03c0,	A1, hasAsyncSCSI		; XPT.c
-RemoveRefNum					vIndirect	$205C,	$03c4,	A1, hasAsyncSCSI		; XPT.c
-CallCompRoutine 				vIndirect	$205C,	$03c8,	A1, hasAsyncSCSI		; XPT.c
-XPTReregisterBus 				vIndirect	$205C,	$03cc,	A1, hasAsyncSCSI		; XPT.c
-SCSIXLATE						vIndirect	$205C,	$03d0,	A7, hasAsyncSCSI		; XPTSCSIXlate.a
-;					UNUSED		vIndirect	$205C,	$03d4,	Ax, hasAsyncSCSI		; 
-Clear							vIndirect	$205C,	$03d8,	A1, hasAsyncSCSI		; XPTfunctions.c
-;					UNUSED		vIndirect	$205C,	$03dc,	Ax, hasAsyncSCSI		; 
-OldSCSICall 					vIndirect	$205C,	$03e0,	A1, hasAsyncSCSI		; XPToldCall.c
-EnumPhaseToSCSIStat 			vIndirect	$205C,	$03e4,	A1, hasAsyncSCSI		; XPToldCall.c
-CallSIMNewOldCall				vIndirect	$205C,	$03e8,	A1, hasAsyncSCSI		; XPToldCall.c
-OldCallWait 					vIndirect	$205C,	$03ec,	A1, hasAsyncSCSI		; XPToldCall.c
-getTimerPB						vIndirect	$205C,	$03f0,	A7, hasAsyncSCSI		; timeout.a
-
-
-SIMCoreRegisterHAL 				vNoVector
-FindIOFromID 					vNoVector
-
-AttemptDriverLoad 				vNoVector
-
-InitXPT 						vNoVector
-SetXPTg 						vNoVector
-XlateOldSCSIGlobals				vNoVector
-Init_SCSIXlate					vNoVector
-InitRecorder					vNoVector
-InitItt							vNoVector
-TestFor_SCSI96_1Exists			vNoVector
-TestFor_SCSI96_2Exists			vNoVector
-TestFor_PSCExists				vNoVector
-WtForFIFOData	 				vNoVector
-Init53c9xSW 					vNoVector
-OldSCSIExists					vNoVector
-SCSITrap						vNoVector
-getCurrentA5					vNoVector
-restoreCurrentA5				vNoVector
-InitSyncWait					vNoVector
-RemoveSyncWait				 	vNoVector
-ReconnectISR					vNoVector
-BlockInterrupts 				vNoVector
-UnblockInterrupts				vNoVector
-Install_ISR 					vNoVector
-OneByteRead 					vNoVector
-OneByteWrite					vNoVector
-Xfer1Byte96 					vNoVector
-SlowRead96						vNoVector
-FastRead96						vNoVector
-SlowWrite96 					vNoVector
-FastWrite96 					vNoVector
-Init53c9xHW 					vNoVector
-Initc96Asm						vNoVector
-AsmInit53c9xHW 					vNoVector
-HALinit 						vNoVector
-GetHalInfo						vNoVector
-HALSyncConfig					vNoVector
-HALTeardownIO					vNoVector
-HALAssertATN					vNoVector
-HALResetBus						vNoVector
-HALIntPoll 						vNoVector
-CallBusInquiry					vNoVector
-HALaction						vNoVector
-CallCompRoutineGlue 			vNoVector
-Ck4IgnoreCmdShOptDel			vNoVector
-Ck4OnlyLoadFromDefault			vNoVector
-AutoMsgIn						vNoVector
-HandleBusInt					vNoVector
-InitHW_SCSI96_BIOS				vNoVector
-DoWeHaveFastSCSI				vNoVector
-DataIn_DMA1x1					vNoVector
-DataOut_DMA1x1					vNoVector
-InitAMIC						vNoVector
-HALc96DataBIOS					vNoVector
-OneByteWrite_BIOS				vNoVector
-OneByteRead_BIOS				vNoVector
-FastWrite_96_BIOS				vNoVector
-FastRead_96_BIOS				vNoVector
-DeferAndWait					vNoVector
-DataDTask						vNoVector
-RemoveBEH96						vNoVector
-InstallBEH96					vNoVector
-CEnqueueHead					vNoVector
-TestFor_OrwellExists			vNoVector
-TestFor_djMEMCExists			vNoVector
-IllegalInstr					vNoVector
-UnimplementedATrap				vNoVector
-VMRunning						vNoVector
-InitXPTAsm						vNoVector
-Ck4EjectableVolume				vNoVector
-DummyOldCallRead				vNoVector
-ReInitHAL						vNoVector
-HALInitCommon					vNoVector
-InitHW_AMIC						vNoVector
-InitSW_AMIC						vNoVector
-SetupIOAMIC						vNoVector
-TeardownIOAMIC					vNoVector
-InitHW_PSC						vNoVector
-InitSW_PSC						vNoVector
-SetupIOPSC						vNoVector
-TeardownIOPSC					vNoVector
-
-HALc96							vDataTable											; HALc96.a
-HALc96Data						vDataTable											; HALc96Data.a
-HALc96Init						vDataTable											; HALc96Init.a
-
-;——— Internally Dispatched Entry points		
-DoInitiate						vNoVector
-DoBitBucket						vNoVector
-DoDataIn						vNoVector
-DoDataOut						vNoVector
-DoAcceptMsg						vNoVector
-DoMsgIn							vNoVector
-DoMsgOut						vNoVector
-DoStatus						vNoVector
-DoComplete						vNoVector
-DoSaveDataPointer				vNoVector
-DoModifyDataPointer				vNoVector
-DoRestorePointers				vNoVector
-GetReconnectInfo				vNoVector
-GetSelectInfo					vNoVector
-DoSelect						vNoVector
-DoSelectWAtn					vNoVector
-DoCommand						vNoVector
-SetParity						vNoVector
-SetupIONoDMA					vNoVector
-DoReset							vNoVector
-DoAssertATN						vNoVector
-TeardownIONoDMA					vNoVector
-HandleSelected					vNoVector
-
-;——— Internally Dispatched (Non-entry points)			
-InitDataBuffer					vNoVector
-InitDataTIB						vNoVector
-InitDataSG						vNoVector
-DoDataBuffer					vNoVector
-DoDataTIB						vNoVector
-DoDataSG						vNoVector
-DataIn_DMA						vNoVector
-DataOut_DMA						vNoVector
-CyclePhase						vNoVector
-BusErrHandler96					vNoVector
-
-;——— Internally Vectored (Non-entry points)			
-Wt4SelectComplete				vNoVector
-StartPSC						vNoVector											; HALc96PSC.a
-PausePSC						vNoVector											; HALc96PSC.a
-Wt4PSCComplete					vNoVector											; HALc96PSC.a
-StopPSCRead						vNoVector											; HALc96PSC.a
-StopPSCWrite					vNoVector											; HALc96PSC.a
-StartAMIC 						vNoVector											; HALc96AMIC.a
-Wt4AMICComplete 				vNoVector											; HALc96AMIC.a
-StopAMICRead 					vNoVector											; HALc96AMIC.a
-StopAMICWrite 					vNoVector											; HALc96AMIC.a
-DMAInitSW						vNoVector											; HALc96PSC.c
-HALc96Routines					vNoVector											; HALc96Routines.a
-SizeOfGlobals					vNoVector											; HALc96Routines.a
-HAL_SingleISR 					vNoVector											; HALc96Routines.a
-InterruptLevel					vNoVector											; XPT.a
-DEFERREDCALL					vNoVector											; XPT.a
-InitDataStuff					vNoVector
-TeardownIO 						vNoVector
-Init53x9xRegs 					vNoVector
-HAL_DualISR 					vNoVector
-TestFor_HMCDecoder 				vNoVector
-SetLoadFlag 					vNoVector
-SOpenDriver 					vNoVector
-HAL_NoISR 						vNoVector
-DMAInitHW 						vNoVector
-SetupIOPB 						vNoVector
-TeardownIOPB 					vNoVector
-ITTGESTALT 						vNoVector
-XPT_ISR0 						vNoVector
-XPT_ISR1 						vNoVector
-XPT_ISR2 						vNoVector
-XPT_ISR3 						vNoVector
-XPT_ISR4 						vNoVector
-XPT_ISR5 						vNoVector
-XPT_ISR6 						vNoVector
-XPT_ISR7 						vNoVector
-XPT_ISR8 						vNoVector
-XPT_ISR9 						vNoVector
-XPT_ISRa 						vNoVector
-XPT_ISRb 						vNoVector
-XPT_ISRc 						vNoVector
-XPT_ISRd 						vNoVector
-XPT_ISRe 				 		vNoVector
-XPT_ISRf 						vNoVector
-ReadInitiatorID					vNoVector
-GetInitiatorID					vNoVector
-
-;——— Non-vectored but we don't want them vectored (debugging or init things)			
-ISITT							vNoVector
-INITSCSIBOOT					vNoVector
-ITTBOOT 						vNoVector
-RecordError						vNoVector
-
-;============================== End SCSI Manager Vectors
-
 ;============================== Script Manager Vectors
 
 GETIDENTRY						vIndirect	$2060,	$0004,	A7		; {sources}Toolbox:ScriptMgr:DblByteCompat.a
@@ -3485,6 +2502,9 @@ INTLTOKENIZE					vIndirect	$2060,	$01dc,	A7		; {sources}Toolbox:ScriptMgr:Script
 MAXOLDDATE						vDataTable							; {sources}Objects:ROM:ScriptMgr.lib
 SECSINDAYX						vDataTable							; {sources}Objects:ROM:ScriptMgr.lib
 
+SCRIPTMGR_VEC01E0				vIndirect	$2060,	$01e0,	A7
+SCRIPTMGR_VEC01E4				vIndirect	$2060,	$01e4,	A7
+
 ;============================== End Script Manager Vectors
 
 ;============================== Segment Loader Vectors
@@ -3525,8 +2545,8 @@ UPDATEEMUWARMSTART				vIndirect	$2068,	$002C,	A7		; {sources}Toolbox:ShutDownMgr
 
 ;============================== Original SuperMario Team Names
 
-MAGICNAME						vIndirect	$206C,	$0004,	A7		; Ricardo's attempt to hide the name strings
-MAGIC							vIndirect	$206C,	$0008,	A7		; can be found in {Sources}OS:MagicData.a
+MAGICNAME						vNoVector							; Ricardo's attempt to hide the name strings
+MAGIC							vNoVector							; can be found in {Sources}OS:MagicData.a
 
 ;============================== Original SuperMario Team Names
 
@@ -3563,8 +2583,8 @@ CARDCHANGED 					vIndirect	$206C,	$003c,	A7		; {sources}OS:SlotMgr:SlotMgr.a
 SLOTEXEC						vIndirect	$206C,	$0040,	A7		; {sources}OS:SlotMgr:SlotMgr.a
 CALCSPOINTER					vIndirect	$206C,	$0044,	A7		; {sources}OS:SlotMgr:SlotMgr.a
 GETSLOTDRVR 					vIndirect	$206C,	$0048,	A7		; {sources}OS:SlotMgr:SlotMgr.a
-GETDRIVERPATCH					vIndirect	$206C,	$004c,	A7, has2MegROMOrMore		; {sources}OS:SlotMgr:SlotMgr.a
-GETDEVINDEX 					vIndirect	$206C,	$0050,	A7, has2MegROMOrMore		; {sources}OS:SlotMgr:SlotMgr.a
+GETDRIVERPATCH					vNoVector							; {sources}OS:SlotMgr:SlotMgr.a
+GETDEVINDEX 					vNoVector							; {sources}OS:SlotMgr:SlotMgr.a
 JSRTBL							vDataTable							; {sources}OS:SlotMgr:SlotMgr.a
 READSLOTPRAM					vIndirect	$206C,	$0054,	A7		; {sources}OS:SlotMgr:SlotMgr.a
 PUTSLOTPRAM 					vIndirect	$206C,	$0058,	A7		; {sources}OS:SlotMgr:SlotMgr.a
@@ -3623,124 +2643,6 @@ SECONDARYEND					vNoVector							; {sources}OS:SlotMgr:SlotMgrInit.a
 
 ;============================== End Slot Manager Vectors
 
-;============================== Sound Manager Vectors
-
-AcceptInitOptions 				vIndirect	$2070,	$0004,	A7		; {sources}Toolbox:SoundMgr:
-AddToHead 						vIndirect	$2070,	$0008,	A7		; {sources}Toolbox:SoundMgr:
-CancelWaitCallback 				vIndirect	$2070,	$000c,	A7		; {sources}Toolbox:SoundMgr:
-ClearASCInt 					vIndirect	$2070,	$0010,	A7		; {sources}Toolbox:SoundMgr:
-ClearStandardASCInterrupt 		vNoVector
-CloseOutputDevice 				vIndirect	$2070,	$0018,	A7		; {sources}Toolbox:SoundMgr:
-__Comp3to1 						vIndirect	$2070,	$001c,	A7		; {sources}Toolbox:SoundMgr:
-__Comp6to1 						vIndirect	$2070,	$0020,	A7		; {sources}Toolbox:SoundMgr:
-CountMatchingBits 				vIndirect	$2070,	$0024,	A7		; {sources}Toolbox:SoundMgr:
-DisableASCInts 					vIndirect	$2070,	$0028,	A7		; {sources}Toolbox:SoundMgr:
-DisableStandardASCInterrupt 	vNoVector
-DispAddTool 					vIndirect	$2070,	$0030,	A7		; {sources}Toolbox:SoundMgr:
-DispFuncDisp 					vIndirect	$2070,	$0034,	A7		; {sources}Toolbox:SoundMgr:
-DispRemTool 					vNoVector
-DispToolAddr 					vNoVector
-DispVersion 					vNoVector
-DoNothing 						vNoVector
-DOUBLEBUFFERCOMPLETE 			vIndirect	$2070,	$0048,	A7		; {sources}Toolbox:SoundMgr:
-EnableASCInts 					vIndirect	$2070,	$004c,	A7		; {sources}Toolbox:SoundMgr:
-EnableStandardASCInterrupt 		vNoVector
-__Exp1to3 						vIndirect	$2070,	$0054,	A7		; {sources}Toolbox:SoundMgr:
-__Exp1to6 						vIndirect	$2070,	$0058,	A7		; {sources}Toolbox:SoundMgr:
-GetBuiltInDevice 				vIndirect	$2070,	$005c,	A7		; {sources}Toolbox:SoundMgr:
-GetHardwareVolume 				vIndirect	$2070,	$0060,	A7		; {sources}Toolbox:SoundMgr:
-GetSoundAttributes 				vIndirect	$2070,	$0064,	A7		; {sources}Toolbox:SoundMgr:
-GetThisComponent 				vIndirect	$2070,	$0068,	A7		; {sources}Toolbox:SoundMgr:
-HGetFCBInfo 					vIndirect	$2070,	$006c,	A7		; {sources}Toolbox:SoundMgr:
-InitSoundMgr 					vNoVector							; {sources}Toolbox:SoundMgr:
-InitSndDispatch 				vIndirect	$2070,	$0074,	A7		; {sources}Toolbox:SoundMgr:
-InitWaveBuffer 					vIndirect	$2070,	$0078,	A7		; {sources}Toolbox:SoundMgr:
-InsertInQueue 					vIndirect	$2070,	$007c,	A7		; {sources}Toolbox:SoundMgr:
-InstallNewGlobals 				vIndirect	$2070,	$0080,	A7		; {sources}Toolbox:SoundMgr:
-InstallSoundIntHandler 			vIndirect	$2070,	$0084,	A7		; {sources}Toolbox:SoundMgr:
-IsDeadProcess 					vIndirect	$2070,	$0088,	A7		; {sources}Toolbox:SoundMgr:
-IsUnknownChannel 				vIndirect	$2070,	$008c,	A7		; {sources}Toolbox:SoundMgr:
-LoadSoundInputDriver 			vIndirect	$2070,	$0090,	A7		; {sources}Toolbox:SoundMgr:
-MACEDispatch 					vIndirect	$2070,	$0094,	A7		; {sources}Toolbox:SoundMgr:
-MakeFlags 						vIndirect	$2070,	$0098,	A7		; {sources}Toolbox:SoundMgr:
-NEXTDOUBLEBUFFER 				vIndirect	$2070,	$009c,	A7		; {sources}Toolbox:SoundMgr:
-NextFromQueue 					vIndirect	$2070,	$00a0,	A7		; {sources}Toolbox:SoundMgr:
-NEXTNOTEBUFFER 					vIndirect	$2070,	$00a4,	A7		; {sources}Toolbox:SoundMgr:
-NEXTWAVEBUFFER 					vIndirect	$2070,	$00a8,	A7		; {sources}Toolbox:SoundMgr:
-OpenOutputDevice 				vIndirect	$2070,	$00ac,	A7		; {sources}Toolbox:SoundMgr:
-OpenPreferenceFile 				vIndirect	$2070,	$00b0,	A7		; {sources}Toolbox:SoundMgr:
-PowerTable 						vDataTable							; {sources}Toolbox:SoundMgr:
-PrepChannel 					vIndirect	$2070,	$00b8,	A7		; {sources}Toolbox:SoundMgr:
-PrepDoubleBuffer 				vIndirect	$2070,	$00bc,	A7		; {sources}Toolbox:SoundMgr:
-PrepNoteBuffer 					vIndirect	$2070,	$00c0,	A7		; {sources}Toolbox:SoundMgr:
-PrepSoundParamBlock 			vIndirect	$2070,	$00c4,	A7		; {sources}Toolbox:SoundMgr:
-PrepWaveBuffer 					vIndirect	$2070,	$00c8,	A7		; {sources}Toolbox:SoundMgr:
-ProcessCmd 						vIndirect	$2070,	$00cc,	A7		; {sources}Toolbox:SoundMgr:
-ProcessNextCmd 					vIndirect	$2070,	$00d0,	A7		; {sources}Toolbox:SoundMgr:
-PumpSndResource 				vIndirect	$2070,	$00d4,	A7		; {sources}Toolbox:SoundMgr:
-QuantizeSample 					vNoVector
-SadismDispatch 					vIndirect	$2070,	$00dc,	A7		; {sources}Toolbox:SoundMgr:
-SadismJmpTable 					vNoVector
-SamplesToBytes 					vNoVector
-ScheduleWaitCallback 			vIndirect	$2070,	$00e8,	A7		; {sources}Toolbox:SoundMgr:
-SetChannelType 					vIndirect	$2070,	$00ec,	A7		; {sources}Toolbox:SoundMgr:
-SetSoundHeader 					vIndirect	$2070,	$00f0,	A7		; {sources}Toolbox:SoundMgr:
-SetTimbre 						vIndirect	$2070,	$00f4,	A7		; {sources}Toolbox:SoundMgr:
-SetUpSifter 					vIndirect	$2070,	$00f8,	A7		; {sources}Toolbox:SoundMgr:
-SetupSoundInterruptVectors 		vIndirect	$2070,	$00fc,	A7		; {sources}Toolbox:SoundMgr:
-SetWaveTable 					vIndirect	$2070,	$0100,	A7		; {sources}Toolbox:SoundMgr:
-SineTable 						vDataTable							; {sources}Toolbox:SoundMgr:
-SndManagerDispatch 				vIndirect	$2070,	$0108,	A7		; {sources}Toolbox:SoundMgr:
-SndManagerJmpTable 				vNoVector							; {sources}Toolbox:SoundMgr:
-SOUNDCOMPLETE 					vIndirect	$2070,	$0110,	A7		; {sources}Toolbox:SoundMgr:
-SoundDispatcher 				vIndirect	$2070,	$0114,	A7		; {sources}Toolbox:SoundMgr:
-SoundInDispatch 				vIndirect	$2070,	$0118,	A7		; {sources}Toolbox:SoundMgr:
-SoundIntHandler 				vIndirect	$2070,	$011c,	A7		; {sources}Toolbox:SoundMgr:
-StartSyncedSounds 				vIndirect	$2070,	$0120,	A7		; {sources}Toolbox:SoundMgr:
-TryRomBeep 						vIndirect	$2070,	$0124,	A7		; {sources}Toolbox:SoundMgr:
-TwelthPower 					vIndirect	$2070,	$0128,	A7		; {sources}Toolbox:SoundMgr:
-UnimplFunction 					vIndirect	$2070,	$012c,	A7		; {sources}Toolbox:SoundMgr:
-WAITCOMPLETION 					vIndirect	$2070,	$0130,	A7		; {sources}Toolbox:SoundMgr:
-__CLOSEMIXERCOMPONENT 			vIndirect	$2070,	$0134,	A7		; {sources}Toolbox:SoundMgr:
-__DISPOSESOUNDGLOBALS 			vIndirect	$2070,	$0138,	A7		; {sources}Toolbox:SoundMgr:
-__GETCOMPRESSIONINFO 			vIndirect	$2070,	$013c,	A7		; {sources}Toolbox:SoundMgr:
-__GETDEFAULTOUTPUTVOLUME 		vIndirect	$2070,	$0140,	A7		; {sources}Toolbox:SoundMgr:
-__GETDEFAULTSOUNDOUTPUT 		vIndirect	$2070,	$0144,	A7		; {sources}Toolbox:SoundMgr:
-__GETSOUNDHEADEROFFSET 			vIndirect	$2070,	$0148,	A7		; {sources}Toolbox:SoundMgr:
-__GETSOUNDPREFERENCE 			vIndirect	$2070,	$014c,	A7		; {sources}Toolbox:SoundMgr:
-__GETSYSBEEPVOLUME 				vIndirect	$2070,	$0150,	A7		; {sources}Toolbox:SoundMgr:
-__MAKESIFTERCHAIN 				vIndirect	$2070,	$0154,	A7		; {sources}Toolbox:SoundMgr:
-__MulDivU 						vIndirect	$2070,	$0158,	A7		; {sources}Toolbox:SoundMgr:
-__OPENMIXERCOMPONENT 			vIndirect	$2070,	$015c,	A7		; {sources}Toolbox:SoundMgr:
-__SETDEFAULTOUTPUTVOLUME 		vIndirect	$2070,	$0160,	A7		; {sources}Toolbox:SoundMgr:
-__SETDEFAULTSOUNDOUTPUT 		vIndirect	$2070,	$0164,	A7		; {sources}Toolbox:SoundMgr:
-__SETSOUNDPREFERENCE 			vIndirect	$2070,	$0168,	A7		; {sources}Toolbox:SoundMgr:
-__SETSOUNDVOL 					vNoVector
-__SETSYSBEEPVOLUME 				vIndirect	$2070,	$0170,	A7		; {sources}Toolbox:SoundMgr:
-__SNDADDMODIFIER 				vIndirect	$2070,	$0174,	A7		; {sources}Toolbox:SoundMgr:
-__SNDAPPDEAD 					vIndirect	$2070,	$0178,	A7		; {sources}Toolbox:SoundMgr:
-__SNDCHANNELSTATUS 				vIndirect	$2070,	$017c,	A7		; {sources}Toolbox:SoundMgr:
-__SNDCONTROL 					vIndirect	$2070,	$0180,	A7		; {sources}Toolbox:SoundMgr:
-__SNDDISPOSECHANNEL 			vIndirect	$2070,	$0184,	A7		; {sources}Toolbox:SoundMgr:
-__SNDDOCOMMAND 					vIndirect	$2070,	$0188,	A7		; {sources}Toolbox:SoundMgr:
-__SNDDOIMMEDIATE 				vIndirect	$2070,	$018c,	A7		; {sources}Toolbox:SoundMgr:
-__SNDGETSYSBEEPSTATE 			vIndirect	$2070,	$0190,	A7		; {sources}Toolbox:SoundMgr:
-__SNDMANAGERSTATUS 				vIndirect	$2070,	$0194,	A7		; {sources}Toolbox:SoundMgr:
-__SNDNEWCHANNEL 				vIndirect	$2070,	$0198,	A7		; {sources}Toolbox:SoundMgr:
-__SNDPLAY 						vIndirect	$2070,	$019c,	A7		; {sources}Toolbox:SoundMgr:
-__SNDPLAYDOUBLEBUFFER 			vIndirect	$2070,	$01a0,	A7		; {sources}Toolbox:SoundMgr:
-__SNDSETSYSBEEPSTATE 			vIndirect	$2070,	$01a4,	A7		; {sources}Toolbox:SoundMgr:
-__SNDSOUNDMANAGERVERSION 		vIndirect	$2070,	$01a8,	A7		; {sources}Toolbox:SoundMgr:
-__SYSBEEP 						vIndirect	$2070,	$01ac,	A7		; {sources}Toolbox:SoundMgr:
-
-DELTA_TABLE 					vDataTable							; {sources}Toolbox:SoundMgr:Tables.3.a
-MIN2_TABLE						vDataTable							; {sources}Toolbox:SoundMgr:Tables.3.a
-MIN3_TABLE						vDataTable							; {sources}Toolbox:SoundMgr:Tables.3.a
-IQUADEL2_TABLE					vDataTable							; {sources}Toolbox:SoundMgr:Tables.3.a
-IQUADEL3_TABLE					vDataTable							; {sources}Toolbox:SoundMgr:Tables.3.a
-
-;============================== End Sound Manager Vectors
-
 ;============================== Start Manager Vectors
 SIZEMEMORY						vNoVector							; {sources}OS:StartMgr:SizeMem.a
 ALLOCFAKERGNS					vNoVector							; {sources}OS:StartMgr:StartAlert.a
@@ -3904,101 +2806,6 @@ SONIC_Test						vNoVector							; {sources}OS:StartMgr:UnivTestEnv:SONIC_Test.c
 
 ;============================== End Start Manager Vectors
 
-;============================== Text Services Manager Vectors
-
-TSMDISPATCH 					vATrap		A???					; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-XINITTSMAWAREAPPLICATION		vIndirect	$2078,	$0004,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-xInitTSMAwareDriver 			vIndirect	$2078,	$0008,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-utaRecordDocumentID 			vIndirect	$2078,	$000c,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-utaRemoveDocumentID 			vIndirect	$2078,	$0010,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-utaUpdateAppFlagInPSNTable		vIndirect	$2078,	$0014,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-utaUpdateDocFlagInPSNTable		vIndirect	$2078,	$0018,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-utaTSMAwareApplicationP 		vIndirect	$2078,	$001c,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-XCLOSETSMAWAREAPPLICATION		vIndirect	$2078,	$0020,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-utCloseAppCommon				vIndirect	$2078,	$0024,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-UTAGETTSMAWAREDOCTABLE			vIndirect	$2078,	$0028,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-UTAGETTSMAPPRECORDPTR			vIndirect	$2078,	$002c,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-UTAGETAPPSUSEINPUTWINDOWFLAG	vIndirect	$2078,	$0030,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-UTAISAPPTSMAWAREANDNOTUSINGIW	vIndirect	$2078,	$0034,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-XINFORMTSM						vIndirect	$2078,	$0038,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-TSMGestalt						vIndirect	$2078,	$003c,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-TSMGRINSTALL					vIndirect	$2078,	$0040,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-OLDJAPANESEINPUTMETHODEXISTS	vIndirect	$2078,	$0044,	A7		; {sources}Toolbox:TextServicesMgr:TSMExtension.a
-utNewTSMDocument				vIndirect	$2078,	$0048,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XNEWTSMDOCUMENT4SWM 			vIndirect	$2078,	$004c,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XNEWTSMDOCUMENT 				vIndirect	$2078,	$0050,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XDELETETSMDOCUMENT				vIndirect	$2078,	$0054,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XDEACTIVATETSMDOCUMENT			vIndirect	$2078,	$0058,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XACTIVATETSMDOCUMENT			vIndirect	$2078,	$005c,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-utTSMEvent2InputMethod			vIndirect	$2078,	$0060,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XTSMEVENTFROMSWM				vIndirect	$2078,	$0064,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XTSMEVENT						vIndirect	$2078,	$0068,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XTSMMENUSELECT					vIndirect	$2078,	$006c,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XFIXTSMDOCUMENT 				vIndirect	$2078,	$0070,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XSETTSMCURSOR					vIndirect	$2078,	$0074,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XGETSERVICELIST 				vIndirect	$2078,	$0078,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XOPENTEXTSERVICE				vIndirect	$2078,	$007c,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XCLOSETEXTSERVICE				vIndirect	$2078,	$0080,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-utMapInstance2Refcon			vIndirect	$2078,	$0084,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-XSENDAETOCLIENT 				vIndirect	$2078,	$0088,	A1		; {sources}Toolbox:TextServicesMgr:TSMFunctions.c
-utJustDeactivateIM4Document 	vIndirect	$2078,	$008c,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utBadSandL						vIndirect	$2078,	$0090,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utVerifyTSMDocID				vIndirect	$2078,	$0094,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utAppendTS2Document 			vIndirect	$2078,	$0098,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utMakeRoom4SInfoHandle			vIndirect	$2078,	$009c,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utHidePaletteAndMenu			vIndirect	$2078,	$00a0,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utCleanUpPreviousDoc			vIndirect	$2078,	$00a4,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utCreateSystemVersionOfMenu 	vIndirect	$2078,	$00a8,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utActivateIM4Document			vIndirect	$2078,	$00ac,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utDeactivateIMforDocument		vIndirect	$2078,	$00b0,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utDeleteCleanUpTSMDocument		vIndirect	$2078,	$00b4,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utCloseIM4Document				vIndirect	$2078,	$00b8,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utDeleteInputMethodsPreviousMenu vIndirect	$2078,	$00bc,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utCheckSysHeapSlop				vIndirect	$2078,	$00c0,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utOpenIM4Document				vIndirect	$2078,	$00c4,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utOpenActivateDefaultIM 		vIndirect	$2078,	$00c8,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utActivateThisDocsInputMethod	vIndirect	$2078,	$00cc,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utSupportedSL					vIndirect	$2078,	$00d0,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utScriptIsNotCCJK				vIndirect	$2078,	$00d4,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utScriptIsCCJKAndNeedsIM		vIndirect	$2078,	$00d8,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utInformPMgr					vIndirect	$2078,	$00dc,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utDocNeedsInputMethod			vIndirect	$2078,	$00e0,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utGetScriptIndex				vIndirect	$2078,	$00e4,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utGetTSMDefaultInputMethod		vIndirect	$2078,	$00e8,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utSLRec2CompFlag				vIndirect	$2078,	$00ec,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utChangeToOldJIM				vIndirect	$2078,	$00f0,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utSuspendResumeApp				vIndirect	$2078,	$00f4,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utAddTSMResource				vIndirect	$2078,	$00f8,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utUpdateDefaultInputMethodResource vIndirect	$2078,	$00fc,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utFixDocumentAndCloseSWMWindow	vIndirect	$2078,	$0100,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utCloseSWMWindow				vIndirect	$2078,	$0104,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utDeleteMenu					vIndirect	$2078,	$0108,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utDeleteSysMenu 				vIndirect	$2078,	$010c,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-utSwapZone						vIndirect	$2078,	$0110,	A1		; {sources}Toolbox:TextServicesMgr:TSMInternalUtils.c
-XSETDEFAULTINPUTMETHOD			vIndirect	$2078,	$0114,	A1		; {sources}Toolbox:TextServicesMgr:TSMUtility.c
-XGETDEFAULTINPUTMETHOD			vIndirect	$2078,	$0118,	A1		; {sources}Toolbox:TextServicesMgr:TSMUtility.c
-XSETTEXTSERVICELANGUAGE 		vIndirect	$2078,	$011c,	A1		; {sources}Toolbox:TextServicesMgr:TSMUtility.c
-XGETTEXTSERVICELANGUAGE 		vIndirect	$2078,	$0120,	A1		; {sources}Toolbox:TextServicesMgr:TSMUtility.c
-XUSEINPUTWINDOW 				vIndirect	$2078,	$0124,	A1		; {sources}Toolbox:TextServicesMgr:TSMUtility.c
-XNEWSERVICEWINDOW				vIndirect	$2078,	$0128,	A1		; {sources}Toolbox:TextServicesMgr:TSMUtility.c
-XCLOSESERVICEWINDOW 			vIndirect	$2078,	$012c,	A1		; {sources}Toolbox:TextServicesMgr:TSMUtility.c
-XGETFRONTSERVICEWINDOW			vIndirect	$2078,	$0130,	A1		; {sources}Toolbox:TextServicesMgr:TSMUtility.c
-XFINDSERVICEWINDOW				vIndirect	$2078,	$0134,	A1		; {sources}Toolbox:TextServicesMgr:TSMUtility.c
-MISCMGR 						vNoVector							; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-GETKEYS 						vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-BUTTON							vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-TICKCOUNT						vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-GETMOUSE						vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-STILLDOWN						vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-WAITMOUSEUP 					vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-EVENTAVAIL						vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-GETNEXTEVENT					vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-WAITNEXTEVENT					vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgr.a
-DOSYSERRORUPDATES				vATrap	 	A???					; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgrPatches.a
-CLEARSYSERRORUPDATERECT 		vIndirect	$2078,	$0138,	A7		; {sources}Toolbox:ToolboxEventMgr:ToolboxEventMgrPatches.a
-
-;============================== End Text Services Manager Vectors
-
 ;============================== TextEdit Vectors
 
 TEXTEDIT						vNoVector							; {sources}Toolbox:TextEdit:TextEdit.a
@@ -4084,14 +2891,14 @@ TEGETOFFSET 					vATrap	 	A???					; {sources}Toolbox:TextEdit:TextEdit.a
 
 TIMEMGR 						vNoVector							; {sources}OS:TimeMgr:TimeMgr.a
 __RMVTIME						vATrap	 	A???					; {sources}OS:TimeMgr:TimeMgr.a
-AFTERFREEZETIMEINRMVTIME		vIndirect	$2080,	$0004,	A7		; {sources}OS:TimeMgr:TimeMgr.a
+AFTERFREEZETIMEINRMVTIME		vNoVector							; {sources}OS:TimeMgr:TimeMgr.a
 __INSTIME						vATrap	 	A???					; {sources}OS:TimeMgr:TimeMgr.a
-MULTANDMERGE					vIndirect	$2080,	$0008,	A7		; {sources}OS:TimeMgr:TimeMgr.a
+MULTANDMERGE					vNoVector							; {sources}OS:TimeMgr:TimeMgr.a
 __PRIMETIME 					vATrap	 	A???					; {sources}OS:TimeMgr:TimeMgr.a
-AFTERFREEZETIMEINPRIMETIME		vIndirect	$2080,	$000c,	A7		; {sources}OS:TimeMgr:TimeMgr.a
-AFTERFREEZETIMEINTIMER2INT		vIndirect	$2080,	$0010,	A7		; {sources}OS:TimeMgr:TimeMgr.a
+AFTERFREEZETIMEINPRIMETIME		vNoVector							; {sources}OS:TimeMgr:TimeMgr.a
+AFTERFREEZETIMEINTIMER2INT		vNoVector							; {sources}OS:TimeMgr:TimeMgr.a
 __MICROSECONDS					vATrap	 	A???					; {sources}OS:TimeMgr:TimeMgr.a
-FREEZETIME						vIndirect	$2080,	$0014,	A7		; {sources}OS:TimeMgr:TimeMgr.a
+FREEZETIME						vNoVector							; {sources}OS:TimeMgr:TimeMgr.a
 INITTIMEMGR 					vNoVector							; {sources}OS:TimeMgr:TimeMgr.a
 
 ;============================== End Time Manager Vectors
@@ -4286,165 +3093,94 @@ FASTERINVALRECT 				vATrap	 	A???					; {sources}Toolbox:WindowMgr:WindowMgrExte
 ACTIVATEPALETTELAYERBRACKET 	vATrap	 	A???					; {sources}Toolbox:WindowMgr:WindowMgrExtensions.a
 GETREARWINDOW					vIndirect	$2084,	$01d0,	A7		; {sources}Toolbox:WindowMgr:WindowMgrExtensions.a
 
+WINDOWMGR_VEC01D4				vIndirect	$2084,	$01d4,	A1
+
 ;============================== End Window Manager Vectors
 
-;============================== Figment Memory Manager Vectors
+;============================== Expansion Bus Manager Vectors
 
+DevTreeRoot						vIndirect	$208c,	$0004,	A7		; _ExpansionBusDispatch selector  4
+EXPANSIONBUSMGR_VEC0008			vIndirect	$208c,	$0008,	A7		; _ExpansionBusDispatch selector 21
+EXPANSIONBUSMGR_VEC000C			vIndirect	$208c,	$000c,	A7		; _ExpansionBusDispatch selector 22
+EXPANSIONBUSMGR_VEC0010			vIndirect	$208c,	$0010,	A7		; _ExpansionBusDispatch selector 23
+EXPANSIONBUSMGR_VEC0014			vIndirect	$208c,	$0014,	A7		; _ExpansionBusDispatch selector 24
+EXPANSIONBUSMGR_VEC0018			vIndirect	$208c,	$0018,	A7		; _ExpansionBusDispatch selector 30
+EXPANSIONBUSMGR_VEC001C			vIndirect	$208c,	$001c,	A7		; _ExpansionBusDispatch selector 31
+ExpVRemove						vIndirect	$208c,	$0020,	A7		; _ExpansionBusDispatch selector  3
+DevTreeDelNode					vIndirect	$208c,	$0024,	A7		; _ExpansionBusDispatch selector  7
+DevTreeSetProperty				vIndirect	$208c,	$0028,	A7		; _ExpansionBusDispatch selector  8
+EXPANSIONBUSMGR_VEC002C			vIndirect	$208c,	$002c,	A7		; _ExpansionBusDispatch selector 15
+EXPANSIONBUSMGR_VEC0030			vIndirect	$208c,	$0030,	A7		; _ExpansionBusDispatch selector 16
+DevTreeGetProperty				vIndirect	$208c,	$0034,	A7		; _ExpansionBusDispatch selector  9
+EXPANSIONBUSMGR_VEC0038			vIndirect	$208c,	$0038,	A7		; _ExpansionBusDispatch selector 11
+EXPANSIONBUSMGR_VEC003C			vIndirect	$208c,	$003c,	A7		; _ExpansionBusDispatch selector 10
+EXPANSIONBUSMGR_VEC0040			vIndirect	$208c,	$0040,	A7		; _ExpansionBusDispatch selector 12
+DevTreeAddNode					vIndirect	$208c,	$0044,	A7		; _ExpansionBusDispatch selector  6
+DevTreeNodeInfo					vIndirect	$208c,	$0048,	A7		; _ExpansionBusDispatch selector  5
+EXPANSIONBUSMGR_VEC004C			vIndirect	$208c,	$004c,	A7		; _ExpansionBusDispatch selector 13
+EXPANSIONBUSMGR_VEC0050			vIndirect	$208c,	$0050,	A7		; _ExpansionBusDispatch selector 14
+ExpMgrConfigReadByte			vIndirect	$208c,	$0054,	A7		; _ExpansionBusDispatch selector 32
+ExpMgrConfigReadWord			vIndirect	$208c,	$0058,	A7		; _ExpansionBusDispatch selector 33
+ExpMgrConfigReadLong			vIndirect	$208c,	$005c,	A7		; _ExpansionBusDispatch selector 34
+ExpMgrConfigWriteByte			vIndirect	$208c,	$0060,	A7		; _ExpansionBusDispatch selector 35
+ExpMgrConfigWriteWord			vIndirect	$208c,	$0064,	A7		; _ExpansionBusDispatch selector 36
+ExpMgrConfigWriteLong			vIndirect	$208c,	$0068,	A7		; _ExpansionBusDispatch selector 37
+ExpMgrIOReadByte				vIndirect	$208c,	$006c,	A7		; _ExpansionBusDispatch selector 38
+ExpMgrIOReadWord				vIndirect	$208c,	$0070,	A7		; _ExpansionBusDispatch selector 39
+ExpMgrIOReadLong				vIndirect	$208c,	$0074,	A7		; _ExpansionBusDispatch selector 40
+ExpMgrIOWriteByte				vIndirect	$208c,	$0078,	A7		; _ExpansionBusDispatch selector 41
+ExpMgrIOWriteWord				vIndirect	$208c,	$007c,	A7		; _ExpansionBusDispatch selector 42
+ExpMgrIOWriteLong				vIndirect	$208c,	$0080,	A7		; _ExpansionBusDispatch selector 43
+ExpMgrInterruptAcknowledgeReadByte	vIndirect	$208c,	$0084,	A7	; _ExpansionBusDispatch selector 17
+ExpMgrInterruptAcknowledgeReadWord	vIndirect	$208c,	$0088,	A7	; _ExpansionBusDispatch selector 18
+ExpMgrInterruptAcknowledgeReadLong	vIndirect	$208c,	$008c,	A7	; _ExpansionBusDispatch selector 19
+ExpMgrSpecialCycleWriteLong		vIndirect	$208c,	$0090,	A7		; _ExpansionBusDispatch selector 25
+ExpMgrSpecialCycleBroadcastLong	vIndirect	$208c,	$0094,	A7		; _ExpansionBusDispatch selector 26
+ExpMgrRestorePropsFromPrefFile	vIndirect	$208c,	$0098,	A7		; _ExpansionBusDispatch selector 44
+ExpMgrLoadExptsFromExtnFolder	vIndirect	$208c,	$0100,	A7		; _ExpansionBusDispatch selector 29
+EXPANSIONBUSMGR_VEC0104			vIndirect	$208c,	$0104,	A7
+EXPANSIONBUSMGR_VEC0108			vIndirect	$208c,	$0108,	A7
+EXPANSIONBUSMGR_VEC010C			vIndirect	$208c,	$010c,	A7
+EXPANSIONBUSMGR_VEC0110			vIndirect	$208c,	$0110,	A7
+EXPANSIONBUSMGR_VEC0114			vIndirect	$208c,	$0114,	A7
+EXPANSIONBUSMGR_VEC0118			vIndirect	$208c,	$0118,	A7
+EXPANSIONBUSMGR_VEC011C			vIndirect	$208c,	$011c,	A7		; _ExpansionBusDispatch selector 46
+EXPANSIONBUSMGR_VEC0120			vIndirect	$208c,	$0120,	A7		; _ExpansionBusDispatch selector 47
+EXPANSIONBUSMGR_VEC0124			vIndirect	$208c,	$0124,	A7		; _ExpansionBusDispatch selector 45
+EXPANSIONBUSMGR_VEC012C			vIndirect	$208c,	$012c,	A7
+EXPANSIONBUSMGR_VEC0130			vIndirect	$208c,	$0130,	A7		; _ExpansionBusDispatch selector 48
+EXPANSIONBUSMGR_VEC0134			vIndirect	$208c,	$0134,	A7		; _ExpansionBusDispatch selector 49
+EXPANSIONBUSMGR_VEC0138			vIndirect	$208c,	$0138,	A7		; _ExpansionBusDispatch selector 20
+EXPANSIONBUSMGR_VEC014C			vIndirect	$208c,	$014c,	A7
+EXPANSIONBUSMGR_VEC0150			vIndirect	$208c,	$0150,	A7
+EXPANSIONBUSMGR_VEC0154			vIndirect	$208c,	$0154,	A7
+EXPANSIONBUSMGR_VEC0158			vIndirect	$208c,	$0158,	A7
+EXPANSIONBUSMGR_VEC015C			vIndirect	$208c,	$015c,	A7
+EXPANSIONBUSMGR_VEC0160			vIndirect	$208c,	$0160,	A7
+EXPANSIONBUSMGR_VEC0164			vIndirect	$208c,	$0164,	A7
+EXPANSIONBUSMGR_VEC0168			vIndirect	$208c,	$0168,	A7
+EXPANSIONBUSMGR_VEC016C			vIndirect	$208c,	$016c,	A7
+EXPANSIONBUSMGR_VEC0170			vIndirect	$208c,	$0170,	A7
+EXPANSIONBUSMGR_VEC0174			vIndirect	$208c,	$0174,	A7
+EXPANSIONBUSMGR_VEC0178			vIndirect	$208c,	$0178,	A7
+EXPANSIONBUSMGR_VEC017C			vIndirect	$208c,	$017c,	A7
+EXPANSIONBUSMGR_VEC0180			vIndirect	$208c,	$0180,	A7
+EXPANSIONBUSMGR_VEC0184			vIndirect	$208c,	$0184,	A7
+EXPANSIONBUSMGR_VEC0188			vIndirect	$208c,	$0188,	A7
+EXPANSIONBUSMGR_VEC018C			vIndirect	$208c,	$018c,	A7
+EXPANSIONBUSMGR_VEC0190			vIndirect	$208c,	$0190,	A7
+EXPANSIONBUSMGR_VEC0194			vIndirect	$208c,	$0194,	A7
+EXPANSIONBUSMGR_VEC0198			vIndirect	$208c,	$0198,	A7
+EXPANSIONBUSMGR_VEC019C			vIndirect	$208c,	$019c,	A7
+EXPANSIONBUSMGR_VEC01A0			vIndirect	$208c,	$01a0,	A7
+EXPANSIONBUSMGR_VEC01A4			vIndirect	$208c,	$01a4,	A7
+EXPANSIONBUSMGR_VEC01A8			vIndirect	$208c,	$01a8,	A7
+EXPANSIONBUSMGR_VEC01AC			vIndirect	$208c,	$01ac,	A7
+EXPANSIONBUSMGR_VEC01B0			vIndirect	$208c,	$01b0,	A7
+EXPANSIONBUSMGR_VEC01B4			vIndirect	$208c,	$01b4,	A7
 
-HEAPDISPATCH					vIndirect	$2088,	$0004,	A7		; Figment
-FIG_HSETFLAGS					vIndirect	$2088,	$0008,	A7		; Figment
-FIG_HGETFLAGS					vIndirect	$2088,	$000c,	A7		; Figment
-FIG_HNORSRC 					vIndirect	$2088,	$0010,	A7		; Figment
-FIG_HRSRC						vIndirect	$2088,	$0014,	A7		; Figment
-FIG_STACKSPACETRAP				vIndirect	$2088,	$0018,	A7		; Figment
-FIG_PURGESPACETRAP				vIndirect	$2088,	$001c,	A7		; Figment
-FIG_MAXBLOCKTRAP				vIndirect	$2088,	$0020,	A7		; Figment
-FIG_MOVEHLOW					vIndirect	$2088,	$0024,	A7		; Figment
-FIG_MOVEHHI 					vIndirect	$2088,	$0028,	A7		; Figment
-FIG_SETGROWZONE 				vIndirect	$2088,	$002c,	A7		; Figment
-FIG_HNOPURGE					vIndirect	$2088,	$0030,	A7		; Figment
-FIG_HPURGE						vIndirect	$2088,	$0034,	A7		; Figment
-FIG_HUNLOCK 					vIndirect	$2088,	$0038,	A7		; Figment
-FIG_HLOCK						vIndirect	$2088,	$003c,	A7		; Figment
-FIG_EMPTYHANDLE 				vIndirect	$2088,	$0040,	A7		; Figment
-FIG_PURGEMEM					vIndirect	$2088,	$0044,	A7		; Figment
-FIG_RESRVMEM					vIndirect	$2088,	$0048,	A7		; Figment
-FIG_COMPACTMEMTRAP				vIndirect	$2088,	$004c,	A7		; Figment
-FIG_MAXMEMTRAP					vIndirect	$2088,	$0050,	A7		; Figment
-FIG_FREEMEM 					vIndirect	$2088,	$0054,	A7		; Figment
-FIG_PTRZONETRAP 				vIndirect	$2088,	$0058,	A7		; Figment
-FIG_SETPTRSIZETRAP				vIndirect	$2088,	$005c,	A7		; Figment
-FIG_GETPTRSIZETRAP				vIndirect	$2088,	$0060,	A7		; Figment
-FIG_DISPOSEPTR					vIndirect	$2088,	$0064,	A7		; Figment
-FIG_NEWPTRTRAP					vIndirect	$2088,	$0068,	A7		; Figment
-FIG_REALLOCHANDLETRAP			vIndirect	$2088,	$006c,	A7		; Figment
-FIG_RECOVERHANDLETRAP			vIndirect	$2088,	$0070,	A7		; Figment
-FIG_HANDLEZONETRAP				vIndirect	$2088,	$0074,	A7		; Figment
-FIG_SETHANDLESIZETRAP			vIndirect	$2088,	$0078,	A7		; Figment
-FIG___GETHANDLESIZE 			vIndirect	$2088,	$007c,	A7		; Figment
-FIG_DSPOSEHANDLE				vIndirect	$2088,	$0080,	A7		; Figment
-FIG_NEWEMPTYHANDLETRAP			vIndirect	$2088,	$0084,	A7		; Figment
-FIG_NWHANDLE					vIndirect	$2088,	$0088,	A7		; Figment
-FIG_SETZONE 					vIndirect	$2088,	$008c,	A7		; Figment
-FIG_GETZONE 					vIndirect	$2088,	$0090,	A7		; Figment
-FIG_MOREMASTERS 				vIndirect	$2088,	$0094,	A7		; Figment
-FIG_MAXAPPLZONE 				vIndirect	$2088,	$0098,	A7		; Figment
-FIG_SETAPPLLIMIT				vIndirect	$2088,	$009c,	A7		; Figment
-FIG_INITZONETRAP				vIndirect	$2088,	$00a0,	A7		; Figment
-c_InitZone						vIndirect	$2088,	$00a4,	A7		; Figment
-c_SetApplLimit					vIndirect	$2088,	$00a8,	A7		; Figment
-c_MaxApplZone					vIndirect	$2088,	$00ac,	A7		; Figment
-c_MoreMasters					vIndirect	$2088,	$00b0,	A7		; Figment
-c_GetZone						vIndirect	$2088,	$00b4,	A7		; Figment
-c_SetZone						vIndirect	$2088,	$00b8,	A7		; Figment
-c_NewHandle 					vIndirect	$2088,	$00bc,	A7		; Figment
-c_NewEmptyHandle				vIndirect	$2088,	$00c0,	A7		; Figment
-c_NewHandleHi					vIndirect	$2088,	$00c4,	A7		; Figment
-c_DisposeHandle 				vIndirect	$2088,	$00c8,	A7		; Figment
-c_GetHandleSize 				vIndirect	$2088,	$00cc,	A7		; Figment
-c_SetHandleSize 				vIndirect	$2088,	$00d0,	A7		; Figment
-c_HandleZone					vIndirect	$2088,	$00d4,	A7		; Figment
-c_RecoverHandle 				vIndirect	$2088,	$00d8,	A7		; Figment
-c_ReallocHandle 				vIndirect	$2088,	$00dc,	A7		; Figment
-c_NewPtr						vIndirect	$2088,	$00e0,	A7		; Figment
-c_DisposePtr					vIndirect	$2088,	$00e4,	A7		; Figment
-c_GetPtrSize					vIndirect	$2088,	$00e8,	A7		; Figment
-c_SetPtrSize					vIndirect	$2088,	$00ec,	A7		; Figment
-c_PtrZone						vIndirect	$2088,	$00f0,	A7		; Figment
-c_FreeMem						vIndirect	$2088,	$00f4,	A7		; Figment
-c_MaxMem						vIndirect	$2088,	$00f8,	A7		; Figment
-c_CompactMem					vIndirect	$2088,	$00fc,	A7		; Figment
-c_ReserveMem					vIndirect	$2088,	$0100,	A7		; Figment
-c_PurgeMem						vIndirect	$2088,	$0104,	A7		; Figment
-c_EmptyHandle					vIndirect	$2088,	$0108,	A7		; Figment
-c_HLock 						vIndirect	$2088,	$010c,	A7		; Figment
-c_HUnlock						vIndirect	$2088,	$0110,	A7		; Figment
-c_HPurge						vIndirect	$2088,	$0114,	A7		; Figment
-c_HNoPurge						vIndirect	$2088,	$0118,	A7		; Figment
-c_SetGrowZone					vIndirect	$2088,	$011c,	A7		; Figment
-c_MoveHHi						vIndirect	$2088,	$0120,	A7		; Figment
-c_MoveHLow						vIndirect	$2088,	$0124,	A7		; Figment
-c_MaxBlock						vIndirect	$2088,	$0128,	A7		; Figment
-c_PurgeSpace					vIndirect	$2088,	$012c,	A7		; Figment
-c_StackSpace					vIndirect	$2088,	$00130,	A7		; Figment
-c_HSetRBit						vIndirect	$2088,	$0134,	A7		; Figment
-c_HClrRBit						vIndirect	$2088,	$0138,	A7		; Figment
-c_HGetState 					vIndirect	$2088,	$013c,	A7		; Figment
-c_HSetState 					vIndirect	$2088,	$0140,	A7		; Figment
-c_GetNextBlockInHeap			vIndirect	$2088,	$0144,	A7		; Figment
-c_DisposeZone					vIndirect	$2088,	$0148,	A7		; Figment
-c_SetZoneCompatibilityFlags 	vIndirect	$2088,	$014c,	A7		; Figment
-c_GetZoneCompatibilityFlags 	vIndirect	$2088,	$0150,	A7		; Figment
-c_RegisterDisposeProc			vIndirect	$2088,	$0154,	A7		; Figment
-GetZoneFromNilMP				vIndirect	$2088,	$0158,	A7		; Figment
-WalkUpFindNewLowRemoveable		vIndirect	$2088,	$015c,	A7		; Figment
-FixedBlockInRange				vIndirect	$2088,	$0160,	A7		; Figment
-CompactHeap 					vIndirect	$2088,	$0164,	A7		; Figment
-CalcMaxBlockSize				vIndirect	$2088,	$0168,	A7		; Figment
-ExtendHeapLimit 				vIndirect	$2088,	$016c,	A7		; Figment
-ExtendApplLimit 				vIndirect	$2088,	$0170,	A7		; Figment
-MakeSpaceLow					vIndirect	$2088,	$0174,	A7		; Figment
-MakeSpaceHigh					vIndirect	$2088,	$0178,	A7		; Figment
-ShrinkHeapLimit 				vIndirect	$2088,	$017c,	A7		; Figment
-NewBlock						vIndirect	$2088,	$0180,	A7		; Figment
-NewBlockFast					vIndirect	$2088,	$0184,	A7		; Figment
-MarkBlockAsPrivate				vIndirect	$2088,	$0188,	A7		; Figment
-AllocateMoreMasters 			vIndirect	$2088,	$018c,	A7		; Figment
-KillBlock						vIndirect	$2088,	$0190,	A7		; Figment
-SetBlockSize					vIndirect	$2088,	$0194,	A7		; Figment
-CalcFreeSpaceAndFindRegionTop	vIndirect	$2088,	$0198,	A7		; Figment
-MoveBlockHigh					vIndirect	$2088,	$019c,	A7		; Figment
-MoveBlockLow					vIndirect	$2088,	$01a0,	A7		; Figment
-CalcLargestPurgeRegion			vIndirect	$2088,	$01a4,	A7		; Figment
-PurgeBlock						vIndirect	$2088,	$01a8,	A7		; Figment
-DoEmpty 						vIndirect	$2088,	$01ac,	A7		; Figment
-LocatePurgePtr					vIndirect	$2088,	$01b0,	A7		; Figment
-PurgeAndMakeSpace				vIndirect	$2088,	$01b4,	A7		; Figment
-PurgeAndCompactHeap 			vIndirect	$2088,	$01b8,	A7		; Figment
-FindHeap						vIndirect	$2088,	$01bc,	A7		; Figment
-FindBlockInHeap 				vIndirect	$2088,	$01c0,	A7		; Figment
-IsValidBlockInHeap				vIndirect	$2088,	$01c4,	A7		; Figment
-CreateNewHeap					vIndirect	$2088,	$01c8,	A7		; Figment
-MoveHeapHeaderHigh				vIndirect	$2088,	$01cc,	A7		; Figment
-RemoveHeap						vIndirect	$2088,	$01d0,	A7		; Figment
-GrowHeap						vIndirect	$2088,	$01d4,	A7		; Figment
-ShrinkHeap						vIndirect	$2088,	$01d8,	A7		; Figment
-CLEARBYTES						vIndirect	$2088,	$01dc,	A7		; Figment
-FillBytes						vIndirect	$2088,	$01e0,	A7		; Figment
-c_InitProcessMgrHeap			vIndirect	$2088,	$01e4,	A7		; Figment
-c_ShrinkSysHeap 				vIndirect	$2088,	$01e8,	A7		; Figment
-c_LowerProcessMgrZoneBottom 	vIndirect	$2088,	$01ec,	A7		; Figment
-c_ShrinkProcessMgrZone			vIndirect	$2088,	$01f0,	A7		; Figment
-c_ExtendSystemZone				vIndirect	$2088,	$01f4,	A7		; Figment
-c_ReclaimSpaceIfSysHeapLow		vIndirect	$2088,	$01f8,	A7		; Figment
-c_StraddleBlockSize 			vIndirect	$2088,	$01fc,	A7		; Figment
-c_ProcessMgrMaxBlock			vIndirect	$2088,	$0200,	A7		; Figment
-c_GetProcessMgrLoFreeBytes		vIndirect	$2088,	$0204,	A7		; Figment
-c_GetSystemHiFreeBytes			vIndirect	$2088,	$0208,	A7		; Figment
-GetSystemHiPurgeBytes			vIndirect	$2088,	$020c,	A7		; Figment
-FIG_VIAZPOSTINIT				vIndirect	$2088,	$0210,	A7		; Figment
-FIG_VIAZINIT					vIndirect	$2088,	$0214,	A7		; Figment
-FIG_INITAPPLZONE				vIndirect	$2088,	$0218,	A7		; Figment
-FIG_SETAPPLBASE 				vIndirect	$2088,	$021c,	A7		; Figment
-FIG___STRIPADDRESS				vIndirect	$2088,	$0220,	A7		; Figment
-MOVEBYTES020					vIndirect	$2088,	$0224,	A7		; Figment
-MOVEBYTES040					vIndirect	$2088,	$0228,	A7		; Figment
-INITQTMEMORY					vIndirect	$2088,	$022c,	A7		; Figment
-addTrashMemoryProc				vIndirect	$2088,	$0230,	A7		; Figment
-removeTrashMemoryProc			vIndirect	$2088,	$0234,	A7		; Figment
-c_RegisterHandleTrashNotification vIndirect $2088,	$0238,	A7		; Figment
-c_UnregisterHandleTrashNotification vIndirect $2088, $023c, A7	    ; Figment
-c_TrashZone 					vIndirect	$2088,	$0240,	A7		; Figment
-c_TrashProcess					vIndirect	$2088,	$0244,	A7		; Figment
-c_TrashMemoryArea				vIndirect	$2088,	$0248,	A7		; Figment
-c_NewHandleSystemSafe			vIndirect	$2088,	$024c,	A7		; Figment
-c_NewPtrSystemSafe				vIndirect	$2088,	$0250,	A7		; Figment
-c_EnoughSystemHeapSlop			vIndirect	$2088,	$0254,	A7		; Figment
-OLD_INITMEMMGR					vIndirect	$2088,	$0258,	A7		; Figment
-OLD_INITMEMVECT 				vIndirect	$2088,	$025c,	A7		; Figment
-OLD_AFTERBOOTSETAPPLBASE		vIndirect	$2088,	$0260,	A7		; Figment
+;============================== End Expansion Bus Manager Vectors
 
-;============================== End Figment Memory Manager Vectors
 
 ;
 ;	The following list of entrypoints are not currently vectorized.
diff --git a/OS/ADBMgr/ADBMgr.a b/OS/ADBMgr/ADBMgr.a
--- a/OS/ADBMgr/ADBMgr.a
+++ b/OS/ADBMgr/ADBMgr.a
@@ -559,37 +559,74 @@ RequestDone	move.l	a0,-(sp)			; copy buffer address to A0 save area on stack
 
 			TestFor	SupportsIdle
 			BEQ.S	@notsupported
-			_IdleUpdate					; this is activity, stay at full speed
+
+			MoveA.L	(PmgrBase), A1
+			CmpI.L	#sleepConst, PmgrRec.SleepSaveFlag(A1)
+			BEQ.B	@definitelyNot
+			BTst.B	#$2, $129(A1)
+			BEQ.B	@nearEnd
+@definitelyNot
+
+			Move.L	(A7), D3
+			Move.B	D3, D0
+			LsR.B	#$4, D0
+			Bsr		FindFDBInfo
+			Move.B	$1(A1), D0
+			MoveA.L	$4(A7), A1
+			Move.L	(A1), D3
+			CmpI.B	#$2, D0
+			BNE.B	@noTesting
+			BTst.L	#$17, D3
+			BNE.B	@idleDone
+			Bra.B	@nearEnd
+@noTesting
+			MoveA.L	(PmgrBase), A1
+			CmpI.L	#sleepConst, PmgrRec.SleepSaveFlag(A1)
+			BEQ.B	@idleDone
+			CmpI.B	#$3, D0
+			BNE.B	@idleDone
+@nearEnd
+			Move.L	D0, -(A7)
+			Move.L	#$10001, D0
+			_PowerDispatch
+			Move.L	(A7)+, D0
+@idleDone
 @notsupported
 
 			movem.l	(sp)+,d0/a0/a1/a2	; setup cmd, buffer, handler, data
-													;									(13).start
-			TestFor	SupportsIdle
-			beq.s	@continue
-			move.l	d0,-(sp)						; save d0 temporarily on the stack						<t10> ag
-			move.l	#((UsrActivity<<16)|\	; set for user activity								<K2>
-					(IdleUpdateDisp<<0)),d0	; idle update selector								<K2>
-			_PowerDispatch							; call power manager
-			move.l	(sp)+,d0						; restore d0											<t10> ag
-@continue
 			move.l	a1,d1							; test to see if handler address is valid
 			beq.s	@noHandler						; if not, don't call it
 
 			BTST	#fDBInit,FDBFlag(A3)			; is ADB initialization in progress?
 			BNE.S	@JustDoIt						; -> yes, calling the handler now is allowed
 
+			MOVE.L	D0,D2
+			AND		#$F,D2
+			CMP.B	#$C,D2
+			BNE		@justDoIt
+
 ;  jump thru the ProductInfo table to check if a keyswitch is in the secure position					<H4>
 
 			MOVEA.L	UnivInfoPtr,A1					; point to the ProductInfo table					<H4>
 			ADDA.L	ProductInfo.ADBDebugUtilPtr(A1),A1 ;  and get the address of its ADB table			<H4>
 			MOVE.L	4*adbKeySwSecure(A1),D2			; get the offset to the keyswitch code				<H4>
-			BEQ.S	@JustDoIt						; -> no keyswitch check, so just call the handler	<H4>
+			BEQ.S	@MaybeDoIt						; -> no keyswitch check, so just call the handler	<H4>
 			MOVEM.L	D0/D1/A0/A2,-(SP)				;													<H4>
 			ADDA.L	D2,A1							; calculate the routine's address					<H4>
 			JSR		(A1)							;  and call it										<H4>
 			MOVEM.L	(SP)+,D0/D1/A0/A2				;													<H4>
 			BEQ.S	@noHandler						; -> the keyswitch is secure, so don't call the handler
 
+@MaybeDoIt	BTST.B	#3,$240A
+			BEQ.S	@JustDoIt
+
+			MOVE.L	PmgrBase,A1
+			CMP.L	#sleepConst,PmgrRec.SleepSaveFlag(A1)
+			BEQ.S	@noHandler
+
+			BTST.B	#2,PmgrRec.PmgrFlags2(A1)
+			BNE.B	@noHandler
+
 @JustDoIt	MOVEA.L	D1,A1							; get the handler's address							<H4>
 			jsr		(a1)							; call the handler
 
@@ -735,7 +772,7 @@ PostInit								; <SM3> rb
 
 InitADBDrvr	_CountADBs						; get the number of valid ADB entries
 			Move	D0,D3					; save it in D3
-			BEQ.S	DoneSrv					; If none, nothing to do
+			BEQ		DoneSrv					; If none, nothing to do
 			MoveQ	#1,D4					; start at first entry
 			Link	A6,#iLocalData			; reserve stack frame
 FSrvLoop	
@@ -759,9 +796,7 @@ FSrvLoop
 			_DetachResource					; detach it
 			
 			Move.L	D1,A0					; put handle in A0
-			Move.L	(A0),D0					; dereference handle
-			_StripAddress					; make it a 24-bit address
-			Move.L	D0,A0					; put it in A0
+			Move.L	(A0),A0					; dereference handle
 			Move.B	iADBAddr(A6),D0			; put ADB Address in D0
 			Move.B	iDeviceTy(A6),D1		; put device type in D1
 			JSR		(A0)					; execute the service routine
@@ -796,6 +831,50 @@ InitADB		MOVE.L 	#FDBDSize,D0		; get local data area length
 			LEA 	FDBTask,A0 			; setup the FDB VBL task
 			MOVE.L	A0,JKybdTask		; lomem vector
 
+			BTst.B	#$2, ($2408)
+			BEQ.B	@dontHitExpandMem
+			import	BetaInitADB
+			Lea.L	BetaInitADB, A0
+			Move.L	A0, ([ExpandMem],$294)
+@dontHitExpandMem
+
+			Move.L	UnivROMFlags, D0
+
+			AndI.L	#$E, D0
+			BEQ.B	@escape
+
+			CmpI.L	#$A, D0
+			BEQ.B	@escape
+
+			CmpI.L	#$C, D0
+			BEQ.B	@second
+
+			CmpI.L	#$8, D0
+			BEQ.B	@fourth
+
+			CmpI.L	#$2, D0
+			BNE.B	@third
+
+@first		Lea.L	($FFFDB592).L, A0
+			Lea.L	@first(A0.L), A0
+			Bra.B	@done
+
+@second		Lea.L	($FFFDB5A2).L, A0
+			Lea.L	@second(A0.L), A0
+			Bra.B	@done
+
+@third		Lea.L	($FFFDB5CE).L, A0
+			Lea.L	@third(A0.L), A0
+			Bra.B	@done
+
+@fourth		Lea.L	($FFFDB5DE).L, A0
+			Lea.L	@fourth(A0.L), A0
+
+@done		MoveA.L	(UnivInfoPtr), A1
+			SubA.L	A1, A0
+			Move.L	A0, $48(A1)
+@escape
+
 ;  jump thru the ProductInfo table to call the hardware-dependent initialization code
 
 			MOVEA.L	UnivInfoPtr,A0		; point to the ProductInfo table						<H4>
@@ -853,17 +932,19 @@ InitDevT	bsr		BusReset			; reset all devices on the bus
 @PollNext	move.b	d0,InitAddr(a3)		; save device address
 			bsr		TalkR3				; issue a Talk R3 command (asynchronously)
 			move.b	InitAddr(a3),d0		; restore poll address
-			tst.b	(a0)+				; test reply length, see if device returned data
+			tst.b	(a0)				; test reply length, see if device returned data
 			beq.s	@NoDevice			; no, nothing to install 
 
 ; there is a response from the device in the address, so update the
 ; device table according to the device
 
+@whoaGoBack
 			moveq.l	#0,d1				; zero extend for indexing
 			move.b	DevTOffset(a3),d1	; get offset to devicetable
-			move.b	1(a0),FDBDevTy(a3,d1.w)	; copy device handler ID into table
+			move.b	2(a0),FDBDevTy(a3,d1.w)	; copy device handler ID into table
 			move.b	d0,FDBOAddr(a3,d1.w); save device address
 			move.b	d0,FDBAddr(a3,d1.w)	; save device address
+			move.b	d0,FDBOAddr(a3,d1.w); save device address
 
 			cmpi.b	#KbdAddr,d0			; is it a keyboard type device?
 			bne.s	@notKbd				; no, branch
@@ -878,10 +959,29 @@ InitDevT	bsr		BusReset			; reset all devices on the bus
 			move.w	HasDev(a3),d2		; get value in HasDev
 			bset.l	d0,d2				; remember which address has device
 			move.w	d2,HasDev(A3)		; save it
+			Bra		@skipNewNoDeviceCode
 @NoDevice
+
+			BTst.B	#$2, ($2408)
+			BEQ.B	@skipNewNoDeviceCode
+
+			Tst.L	([$2B6],$29C)
+			BEQ.B	@skipNewNoDeviceCode
+
+			MoveM.L	D0/A0-A3, -(A7)
+			MoveA.L	([$2B6],$29C), A1
+			MoveA.L	A0, A2
+			AndI	#$FF, D0
+			OrI		#$200, D0
+			Jsr		(A1)
+			MoveM.L	(A7)+, D0/A0-A3
+			Tst.B	(A0)
+			BNE.B	@whoaGoBack
+@skipNewNoDeviceCode
+
 			addq.b	#1,d0				; advance device address
 			cmpi.b	#NumFDBAdr,d0		; has it polled all addresses yet?
-			bne.s	@PollNext			; no, go to poll next device
+			bne		@PollNext			; no, go to poll next device
 
 ; ChgAddr - check the device address to identify multiple devices on 
 ; the same address
@@ -922,7 +1022,7 @@ ChgNext
 ;   to the old address by issuing a Listen R3.
 
 			Move.B	InitAddr(A3),D0		; get address
-			BSR.s	TalkR3				; issue a Talk R3 command					<1.6>
+			BSR		TalkR3				; issue a Talk R3 command					<1.6>
 
 ; MovBack - A Talk R3 has just been issued, a timeout in S1 indicates no
 ;   more device in original address, we want to move the device back to 
@@ -931,21 +1031,40 @@ ChgNext
 			tst.b	(a0)				; did the device return data
 			beq.S	@1					; no, branch 
 ; no timeout indication, 
-			BSR.S	CopyEntry			; copy entry into device table
+@whoaGoBack
+			BSR		CopyEntry			; copy entry into device table
 			Move.B	FDBByte1(A3),FDBDevTy(A3,D1.W)	; get new handle ID into table
 			BRA.S	ChgNext				; go to change next device
 ; there is timeout indication
 @1
+			BTst.B	#$2, ($2408)
+			BEQ.B	@skipNewTimeoutCode
+
+			Move.B	$16F(A3), D0
+			Tst.L	([$2B6],$29C)
+			BEQ.B	@skipNewTimeoutCode
+
+			MoveM.L	D0/A1-A2, -(A7)
+			MoveA.L	([$2B6],$29C), A1
+			MoveA.L	A0, A2
+			AndI	#$FF, D0
+			OrI		#$300, D0
+			Jsr		(A1)
+			MoveM.L	(A7)+, D0/A1-A2
+			Tst.B	(A0)
+			BNE.B	@whoaGoBack
+@skipNewTimeoutCode
+
 			Move.B	InitAddr(A3),D1		; get address to change back to
 			Move.B	NewAddr(A3),D0		; get address to talk to
-			bsr.s	ListenR3			; send a listen R3 command					<1.6>
+			bsr		ListenR3			; send a listen R3 command					<1.6>
 
 ; CKNewAdr - check the new address by issuing a Talk R3, to see if
 ;   there is still any device left.  If yes, add entry into device 
 ;   table, but if not, just go to change next device address
 
 			Move.B	NewAddr(A3),D0		; get address
-			BSR.S	TalkR3				; issue a talk R3							<1.6>
+			BSR		TalkR3				; issue a talk R3							<1.6>
 
 ; AddEntry - a Talk R3 command has just been issed to the new address, 
 ;   if there is no timeout in S1, one or more device is still in that
@@ -1167,6 +1286,7 @@ waitForKeys	equ			(4+4)				; add 100% margin
 @type		cmp.b	#kbdAddr,origADBAddr(a0); is this a keyboard
 			bne.s	@next					; not a keyboard, next device
 			bsr.s	sendFlush				; send a flush command to kbd
+			bsr.s	newAdbFunc
 			bra.s	@next					; next device
 			
 @done		movea.l	#waitForKeys,a0			; wait for keys
@@ -1176,6 +1296,31 @@ waitForKeys	equ			(4+4)				; add 100% margin
 			movem.l	(sp)+,@saved			; restore registers
 			rts
 
+
+;______________________________________________________________________
+;
+; Routine:		newAdbFunc
+; Arguments:	a0
+; Output:		none
+; Function:
+; Note:			
+;______________________________________________________________________
+
+newAdbFunc
+@saved		reg		d0/d1/a0
+
+			movem.l	@saved,-(sp)
+
+			move.l	6(a0),a0
+			addq.l	#4,a0
+			clr.l	(a0)+
+			clr.l	(a0)
+			bsr		RSetKmap
+
+			movem.l	(sp)+,@saved			; restore registers
+			rts
+
+
 ;______________________________________________________________________
 ;
 ; Routine:		sendFlush
@@ -1606,6 +1751,13 @@ FirstInstall
 			MOVE.L	D0, A0
 			MOVE.L	(A0), KCHRPtr(A2)		; Dereference and put away
 
+			MOVE.L	A1, -(SP)
+			MOVE.L	ExpandMem, A1
+			TST.L	ExpandMemRec.emKeyCache(A1)
+			BNE.S	@no
+			MOVE.L	(A0), ExpandMemRec.emKeyCache(A1)
+@no			MOVE.L	(SP)+, A1
+
 			SUBQ.L	#4, SP					; Make room for result
 			MOVE.L	#'KMAP', -(SP)			; ResType = KCHR
 			CLR.W	-(SP)					; theID = 0
@@ -1909,7 +2061,7 @@ KeyTrans
 ; Macintosh keyboard mapping hook, which relies on the new KeyTrans trap.
 ; -----------------------------------------------------------------------------
 
-KeyHook 	PROC
+KeyHook 	PROC	EXPORT
 			with	ExpandMemRec
 			bra.s	SkipHeader				; skip the header.
 
diff --git a/OS/Clock.a b/OS/Clock.a
--- a/OS/Clock.a
+++ b/OS/Clock.a
@@ -151,7 +151,7 @@ Clock		PROC	EXPORT
 ;_______________________________________________________________________
 
 OneSecInt	MOVE.B	#1<<ifCA2,VIFR(A1)		; clear the interrupt						<1.4>
-			ADDQ.L	#1,Time					; count the second
+			NOP
 			BCLR	#5,AlarmState			; flag GNEFilter to flash if enabled
 
 			TST.B	SPVolCtl				; bit 7 is alarm enable
@@ -322,14 +322,16 @@ ValidatePRAM
 					 (8<<0),D3				;   starting at PRAM address 8							<H2>
 			BSR		PramIO					; write out the last 4 bytes of original PRAM			<H2>
 
+			LEA		@other,A3
+			MOVE.L	#(1<<31)|\				; write
+					 (1<<16)|\				;  1 byte
+					 (16<<0),D3				;   starting at PRAM address 16
+			BSR		PramIO
+
 @CheckXPRAM	LEA		@XPRAMSig,A3			;														<H2>
 			MOVE.L	12(SP),D3				; are the extended PRAM signature bytes valid?			<H2>
 			CMP.L	(A3),D3					;														<H2>
 			BEQ.S	@Done					; -> yes, we're done									<H2>
-			MOVE.L	#(1<<31)|\				; write													<H2>
-					 (4<<16)|\				;  4 bytes												<H2>
-					 (12<<0),D3				;   starting at PRAM address 12							<H2>
-			BSR		PramIO					; write out the correct extended PRAM signature bytes	<H2>
 
 			MOVEA.L	SP,A3					; point to our stack buffer								<H2>
 			MOVEQ	#(256-32)/4-1,D3		;  and zero each byte									<H2>
@@ -337,8 +339,11 @@ ValidatePRAM
 			DBRA	D3,@ClearBuf			;														<H2>
 
 			BIGLEA	PRAMInitTbl,A2			; point to the table of default extended PRAM values	<H2>
+			BIGLEA	*+$373c,A3
+			SUB.L	A2,A3
+			MOVE.L	A3,D3
+			SUB.L	#1,D3
 			LEA		$76-32(SP),A3			;  and where they'll go in the buffer					<H2>
-			MOVEQ	#$89-$76,D3				; copy them into the buffer								<H2>
 @CopyXDefs	MOVE.B	(A2)+,(A3)+				;														<H2>
 			DBRA	D3,@CopyXDefs			;														<H2>
 
@@ -348,11 +353,19 @@ ValidatePRAM
 					 (32<<0),D3				;   starting at PRAM address 32							<H2>
 			BSR		PramIO					;														<H2>
 
+			LEA		@XPRAMSig,A3
+			MOVE.L	#(1<<31)|\				; write
+					 (4<<16)|\				;  4 bytes
+					 (12<<0),D3				;   starting at PRAM address 12
+			BSR		PramIO
+
 @Done		
 			LEA		256(SP),SP				; clean up the stack									<H2>
 			MOVEM.L	(SP)+,D0-D3/A0-A3		; restore regs from StartINIT							<SM5>													<8.6>
 			RTS								;														<H2>
 		
+@other		DC.W	$A800
+
 @XPRAMSig	DC.L	'NuMc'					; extended PRAM validity bytes (slot-based machines)	<H2>
 
 
diff --git a/OS/CrsrDev.a b/OS/CrsrDev.a
--- a/OS/CrsrDev.a
+++ b/OS/CrsrDev.a
@@ -100,7 +100,7 @@ _FixDiv		OPWORD  $A84D
 CrsrDev		PROC
 
 			EXPORT	InitCrsrDev,CrsrDevDispatch
-			IMPORT	CrsrVBLTask
+			IMPORT	CrsrVBLTask,vDrawCursor,vEraseCursor
 
 			WITH	CrsrDevGlobals, CrsrDevRec, CrsrDevSegment, CrsrDataRec
 			WITH	ADBDeviceEntry, ADBVars, ExpandMemRec
@@ -934,20 +934,20 @@ doDouble
 
 ;---------------------------------------------------------			
 doClickLock
-			tst.b	buttonData(a2,d3.w)		; is this the 1st time?
+			tst.b	buttonData(a2,d2.w)		; is this the 1st time?
 			bne.s	@secondHit				; no, skip
 			btst.b	d3,buttons(a2)			; are we down?
 			beq.s	@firstUp				; no, skip
 			bsr.s	CrsrDevButtonDown		; yes, generate button down event
 			bra.s	@done
 
-@firstUp	st.b	buttonData(a2,d3.w)		; first up, mark it
+@firstUp	st.b	buttonData(a2,d2.w)		; first up, mark it
 			bra.s	@done			
 
 @secondHit	btst.b	d3,buttons(a2)			; are we up (2nd time)?
 			bne.s	@done					; no, do nothing...
 			bsr.s	CrsrDevButtonUp			; yes, post up event
-			clr.b	buttonData(a2,d3.w)		; mark that we're really up
+			clr.b	buttonData(a2,d2.w)		; mark that we're really up
 @done		rts
 
 
@@ -963,7 +963,7 @@ doAppleScript
 
 ;---------------------------------------------------------			
 doCustom	
-			pea		buttonData(a2)			; push our custom routine address
+			move.l	buttonData(a2,d2.w),-(sp)	; push our custom routine address
 			rts								; and call it.
 			
 
@@ -1102,7 +1102,21 @@ CrsrDevSetAccel
 ; first find the two tables which enclose the desired acceleration
 ;----------------------------------------------
 
-@foundIt	move.l	acceleration(a2),d3		; get new acceleration in d3
+@foundIt	Move.B    $85(A2), D3
+			BEQ.B     @endofthing
+			Clr       -(SP)
+			Move.L    #'accl', -(A7)
+			Move      #$FFFF, (ROMMapInsert)
+			_CountResources
+			Move      (SP)+, D3
+			Move.L    #'USB*', D4
+			Bsr       FindResource
+			BEQ.B     @endofthing
+			MoveQ.L   #$0, D4
+			Bsr       FindResource
+@endofthing
+
+			move.l	acceleration(a2),d3		; get new acceleration in d3
 			move.w	(a0)+,d2				; get # of  acceleration tables in resource
 			move.l	a0,a1					; keep ptr to 'low' accel table in a1
 			
@@ -1456,6 +1470,9 @@ CrsrDevHandleVBL
 		
 			movea.l	ExpandMem,a3				; get ptr to expandmem rec
 			movea.l	emCursorGlobals(a3),a3		; get cursory global ptr
+			tst.l	a3
+			beq		@exit
+
 			move.l	firstCrsrDev(a3),d0			; get ptr to 1st CrsrDevRec
 			beq		@exit						; if not even 1 device, just exit
 			move.l	d0,a2						;     ptr in a2
@@ -1691,6 +1708,7 @@ DrawCursor	movea.l	firstCrsrData(a3),a4		; get ptr to main CrsrDataRec			<H15>
 			bne.s	@exit						; yes… exit
 			
 			lea		CrsrPin,a0					; it's ok to update cursor, get bounding rect
+			move.l	d0,-(sp)
 			BSR.L	CrsrVBLTask					; pin and draw the cursor
 			
 			move.l	Mouse,d0					; has cursor been pinned?
@@ -1850,6 +1868,7 @@ CrsrDevDisposeDev
 @loop		cmpa.l	a1,a2					; is this the linked list element we want?
 			beq.s	@gotIt					; yes, handle it
 			move.l	a1,d1					; no, prev := next
+			beq.s	@exit
 			move.l	nextCrsrDev(a1),d0		; get next->nextCrsrDev
 			beq.s	@exit					; exit if NIL (we never found it)
 			move.l	d0,a1					; next := next->nextCrsrDev
@@ -1859,8 +1878,10 @@ CrsrDevDisposeDev
 			tst.l	d1						; was it the first one?
 			beq.s	@firstOne				; yes, handle special case
 			
+			move.l	a2,d0
 			move.l	d1,a2
 			move.l	a1,nextCrsrDev(a2)		; else, delete our element from middle of list
+			move.l	d0,a2
 			bra.s	@dispose
 
 @firstOne	move.l	a1,firstCrsrDev(a0)
@@ -1912,6 +1933,7 @@ CrsrDevReInit								;													<H14>
 	
 			movem.l	d0-d3/a0-a3,-(sp)
 			link	a6,#adbPBSize			; Make a stack frame for our param block
+			tst		d0
 			bne.s	@PostInit				; Skip if post-processing
 
 ;---------------------
@@ -2120,7 +2142,9 @@ CrsrDevReInit								;													<H14>
 ;_______________________________________________________________________
 
 syncADBTalk	
+@restart
 			move.l	a0,-(sp)				; save ptr to our buffer
+			move.l	d0,-(sp)
 			clr.w	-(sp)					; our 'sync' flag
 
 			move.l	sp,a1					; keep pointer to globals for later
@@ -2129,14 +2153,19 @@ syncADBTalk
 			move.l	a0,-(sp)				; push pointer to our reply buffer
 			move.l	sp,a0
 			_ADBOp
+			bmi.s	@weird
 			
 @spin		tst.b	(a1)					; have we completed?
 			beq.s	@spin					; no, keep waiting
 			
-			lea		14(sp),sp				; dump locals
+			lea		18(sp),sp				; dump locals
 			move.l	(sp)+,a0				; restore a0
 			rts
 
+@weird		lea.l	$e(sp),sp
+			move.l	(sp)+,d0
+			move.l	(sp)+,a0
+			bra.s	@restart
 
 ;_______________________________________________________________________
 ;			
@@ -2154,6 +2183,8 @@ syncADBTalk
 ;_______________________________________________________________________
 
 syncADBListen	
+@restart
+			movem.l	d0/a0,-(sp)
 			clr.w	-(sp)					; our 'sync' flag
 			move.l	sp,a1					; keep pointer to data area for later
 			move.l	sp,-(sp)				; push pointer to data area
@@ -2161,13 +2192,17 @@ syncADBListen
 			move.l	a0,-(sp)				; push ptr to data to send
 			move.l	sp,a0
 			_ADBOp
+			bmi.s	@weird
 			
 @spin		tst.b	(a1)					; have we completed?
 			beq.s	@spin					; no, keep waiting
 			
-			lea		14(sp),sp				; dump locals
+			lea		22(sp),sp				; dump locals
 			rts
-			
+
+@weird		lea.l	$e(sp),sp
+			movem.l	(sp)+,d0/a0
+			bra.s	@restart
 			
 ;_______________________________________________________________________
 ;			
@@ -2296,6 +2331,21 @@ SetCrsrDelCore
 			rts											; just a hook for now
 
 
+NewCrsrFunction
+			Move.L    (DeviceList), D0
+@loop		BEQ.B     @done
+			MoveA.L   D0, A0
+			CmpA.L    D1, A0
+			BNE.B     @moredone
+			MoveA.L   (A0), A0
+			Move.L    $1E(A0), D0
+			Bra.B     @loop
+@done		SubA.L    A0, A0
+@moredone	Move.L    A0, D1
+			Rts
+
+
+
 ;_____________________________________________________________________________________________	<H15>
 ;	VDrawCursor  -  default DrawCursor routine
 ;
@@ -2304,23 +2354,10 @@ SetCrsrDelCore
 ;	the routine InitCrsrVects.
 ;
 
-			EXPORT	VDrawCursor
-			IMPORT	BLITCURSOR						;from ccrsrcore.a
-VDrawCursor
-			MOVE.B	#1,CRSRBUSY 					;MARK CHANGE IN PROGRESS
-		
-			TST		CRSRSTATE
-			BMI.S	DoneSho							;QUIT IF STILL HIDDEN
-			CLR 	CRSRSTATE						;DON'T LET CRSRSTATE GET > 0
-			TST.B	CRSRVIS 						;IS CURSOR ALREADY VISIBLE?
-			BNE.S	DoneSho							;YES, DON'T TRY TO REDRAW
-			TST.B	CrsrObscure						;Skip if obscured
-			BNE.S	DoneSho
+VDrawCursor	PROC	EXPORT	
 
-			BSR.L	BLITCURSOR						;Do the real work: put pixels up
-
-DoneSho		CLR.B	CRSRBUSY						;CHANGE COMPLETE
-			RTS
+			IMPORT	QD_DRAWCURSOR
+			BRA.L	QD_DRAWCURSOR
 
 
 ;______________________________________________________________________________________________	<H15>
@@ -2331,16 +2368,9 @@ DoneSho		CLR.B	CRSRBUSY						;CHANGE COMPLETE
 ;	the routine InitCrsrVects.
 ;
 
-			EXPORT	VEraseCursor
-			IMPORT	UNBLITCURSOR					;from ccrsrcore.a
-VEraseCursor
-			MOVE.B	#1,CRSRBUSY 					;MARK CHANGE IN PROGRESS
-			TST.B	CRSRVIS 						;IS CURSOR VISIBLE?
-			BEQ.S	DoneHid							;NO, DON'T TRY TO REMOVE IT
-			
-			BSR.L	UNBLITCURSOR					;Zap Pixels
+VEraseCursor	PROC	EXPORT
 
-DoneHid		CLR.B	CRSRBUSY						;CHANGE COMPLETE
-			RTS
+			IMPORT	QD_ERASECURSOR
+			BRA.L	QD_ERASECURSOR
 
 		END
\ No newline at end of file
diff --git a/OS/CudaMgr.a b/OS/CudaMgr.a
--- a/OS/CudaMgr.a
+++ b/OS/CudaMgr.a
@@ -271,12 +271,52 @@ CudaDispatch
 			bra		@done
 
 @CudaRestart
+			CmpI      #$10C, (A0)
+			BEQ.B     @L4
+			CmpI      #$107, (A0)
+			BNE.B     @endChicanery
+			Tst.B     $64(A2)
+			BEQ       @endChicanery
+
+@L4			CmpI      #$100, $2(A0)
+			BLT.B     @L5
+			Move      #$FFCE, $E(A0)
+			Bra       @done
+
+@L5			Lea.L     $66(A2), A2
+			Move      $6(A0), D1
+			BEQ       @L9
+			SubQ      #$1, D1
+			MoveQ.L   #$0, D2
+			Move      $2(A0), D2
+			MoveA.L   $8(A0), A1
+
+@L6			CmpI.B    #$7, $1(A0)
+			BEQ.B     @L7
+			Move.B    (A1)+, $0(A2,D2.W)
+			Bra.B     @L8
+
+@L7			Move.B    $0(A2,D2.W), (A1)+
+
+@L8			AddQ      #$1, D2
+			AndI      #$FF, D2
+			DBF       D1, @L6
+
+@L9			MoveA.L   ($DE0), A2
+			MoveA.L   ($1D4), A1
+			CmpI.B    #$C, $1(A0)
+			BEQ.B     @endChicanery
+			Tst.L     $10(A0)
+			BEQ       @done
+			MoveA.L   $10(A0), A1
+			Jsr       (A1)
+			Bra       @done
+
+@endChicanery
 			move.w	sr,-(sp)					; save SR
 			ori.w	#hiIntMask,sr				; mask interrupts
 			
-		eieioSTP
 			btst.b	#TReq,vBufB(a1)				; does Cuda want to abort?
-		eieioSTP
 			beq.s	@abort						; yes, wait for it to go away
 			btst.b	#busy,flags(a2)				; has an idle acknowledge occured?
 			bne.s	@abort						; no, then wait for it!
@@ -285,10 +325,9 @@ CudaDispatch
 			
 @abort		move.w	(sp)+,sr					; we were busy, enable interrupts
 			jsr		pollByte					; poll shift reg, calling handler if interrupts masked
-			bra.s	@CudaRestart				; and keep waiting for busy to go away...
+			bra.s	@endChicanery				; and keep waiting for busy to go away...
 
 @sendPackType									; interrupts masked here
-		eieioSTP
 			bset.b	#SRdir,vACR(a1)				; switch to output, Define direction FROM System		
 		eieioSTP
 			move.b	pbCmdType(a0),vSR(a1)		; send command packet to shift reg
@@ -303,7 +342,7 @@ CudaDispatch
 ;		When the shift register irq comes in call the PollProc
 ;		then process the shift register irq data
 ;
-			movem.l	d0/d1/a0-a4/a6,-(sp)		; save some registers
+			movem.l	d0-d3/a0-a4/a6,-(sp)		; save some registers
 			move.l	PollStack,-(sp)				; save previous poll stack
 			lea		@zero, a3
 			move.l	sp,PollStack				; Pointer to buffer for polled bytes
@@ -323,9 +362,8 @@ CudaDispatch
 			beq.s	@2
 			move.b	(a6),-(sp)					; Push the data on the stack
 @2
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#vShift,vIFR(a1)			; now wait for shift reg IRQ
-		eieioSTP
 			beq.s	@wait
 
 			cmpa.l	PollStack,SP				; Is there any poll data
@@ -341,10 +379,8 @@ CudaDispatch
 
 @NoSCCData
 			move.l	(sp)+,PollStack				; restore previous poll stack
-			movem.l	(sp)+,d0/d1/a0-a4/a6		; restore work registers
-		eieioSTP
+			movem.l	(sp)+,d0-d3/a0-a4/a6		; restore work registers
 			btst.b	#TReq,vBufB(a1)				; did CUDA abort?		
-		eieioSTP
 			bne.s	@accepted					; no, then it will accept our packet
 ;-----------------------------------------------------------------------------------------------
 ;	Note that changing the VIA mode can generate an edge internal to the VIA which will
@@ -353,14 +389,11 @@ CudaDispatch
 ;	of CB1.  Delay long enough for the edge to occur before acknowledging the shift
 ;	register interrupt.	(R. Montagne	1/11/93)
 ;________________________________________________________________________________________________
-			moveq	#10,d0						; delay for 10µS min.
+			move	$d00,d0
+			divu	#$50,d0
 @mode7delay
-		eieioSTP
-			tst.b	vBufB(a1)					; 1.2µS per access
-		eieioSTP
 			dbra	d0,@mode7delay
 			
-		eieioSTP
 			bclr.b	#SRdir,vACR(a1)				; yes, switch back to input
 		eieioSTP
 			tst.b	vSR(a1)						; clear pending shift register interrupt
@@ -369,9 +402,8 @@ CudaDispatch
 					(1<<vByteAck)),vBufB(a1)	;						
 		eieioSTP
 @abortAck
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#ifSR,vIFR(a1)				; now wait for shift reg IRQ to acknowledge abort
-		eieioSTP
 			beq.s	@abortAck					;						
 			jsr		CudaCallShiftRegIRQ			; handle it				
 			bra.s	@abort						; and wait				
@@ -412,9 +444,8 @@ PollByte
 			move.w	sr,d0						; get 68xxx interrupt mask
 			andi.w	#hiIntMask,d0				; are we at interrupt level?
 			beq.s	@exit						; no, just exit
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#ifSR,vIFR(a1)				; yes, poll the shift reg
-		eieioSTP
 			beq.s	@exit						; no shift reg interrupt, return
 			bsr.s	CudaCallShiftRegIRQ			; yes, handle it
 @exit		rts
@@ -436,7 +467,6 @@ PollByte
 ;________________________________________________________________________________________________
 ;			Export	SendByte	
 SendByte
-		eieioSTP
 			move.b	d0,vSR(a1)					; send the byte to the shift reg
 		eieioSTP
 			eori.b	#1<<vByteAck,vBufB(a1)		; let Cuda know it's there
@@ -492,26 +522,31 @@ CudaCallShiftRegIRQ
 CudaShiftRegIRQ
 			move.w	sr,d3
 			ori.w	#hiIntMask,sr				; mask interrupts						<LW8><LW5>
+
+			btst.b	#vShift,vIFR(a1)
+			bne.s	@output
+
+			move.w	d3,sr						; restore interrupts
+			rts
+
+;________________________________________________________________________________________________
+;	When outputing from the VIA to Cuda, the interrupt will occur prior to the rising edge
+;	of CB1.  Delay long enough for the edge to occur before acknowledging the shift
+;	register interrupt.	(R. Montagne	1/11/93)
+;________________________________________________________________________________________________
+
+@output
 			movea.l	EgretBase,a2				; get ptr to globals <13>
 			bset.b	#busy,flags(a2)				; make sure we're marked as busy
-			
-		eieioSTP
-			btst.b	#SRdir,vACR(a1)				; see if VIA direction is output
-		eieioSTP
-			beq.s	@input						; no, then we're receiving..
-;________________________________________________________________________________________________
-;	When outputing from the VIA to Cuda, the interrupt will occur prior to the rising edge
-;	of CB1.  Delay long enough for the edge to occur before acknowledging the shift
-;	register interrupt.	(R. Montagne	1/11/93)
-;________________________________________________________________________________________________
-			moveq	#10,d0						; delay for 10µS min.					<LW2><VIA rbm>
+
+			btst.b	#$4, $1600(A1)
+			beq.s	* + $60 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
+
+			move	$d00,d0
+			divu	#$50,d0
 @mode7delay
-		eieioSTP
-			tst.b	vBufB(a1)					; 1.2µS per access						<LW2><VIA rbm>
-		eieioSTP
 			dbra	d0,@mode7delay				;										<LW2><VIA rbm>
 		
-		eieioSTP
 			tst.b	vSR(a1)						; clear the shift reg interrupt
 		eieioSTP
 			tst.w	sendHdrCnt(a2)				; any bytes left in header?
@@ -533,7 +568,6 @@ CudaShiftRegIRQ
 			subq.w	#1,sendDataCnt(a2)			; count it
 			bra		@exit						; and exit
 @CmdFinished
-		eieioSTP
 			bclr.b	#SRdir,vACR(a1)				; now switch to input
 		eieioSTP
 ;________________________________________________________________________________________________
@@ -541,18 +575,14 @@ CudaShiftRegIRQ
 ;	access to the shift data register will keep the counter in sync with the communications
 ;	protocol to Cuda.
 ;________________________________________________________________________________________________
-		eieioSTP
 			tst.b	vSR(a1)						; make sure VIA counter is in sync		<LW2><VIA rbm>
-		eieioSTP
 @sendCmd	
-		eieioSTP
 			ori.b	#((1<<TIP)| \				; terminate transaction	
 					 (1<<vByteAck)),vBufB(a1)	; and set idle state	
 		eieioSTP
 			bra		@exit						; and exit
 			
 @input		;-----------------------------------------------------------------------------
-		eieioSTP
 			move.b	vSR(a1),d0					; read the byte from shift reg into D0			
 		eieioSTP
 			tst.w	rcvHdrCnt(a2)				; any bytes left in response packet header?
@@ -591,9 +621,7 @@ CudaShiftRegIRQ
 			beq.s	@zeroReq					; yes, don't pass any data back						<SM5> 
 			move.b	d0,(a0)+					; store the data byte
 @zeroReq			
-		eieioSTP
 			btst.b	#TREQ,vBufB(a1)				; was this the last byte?
-		eieioSTP
 			bne		@lastIrq					; yes, terminate response packet
 			move.l	a0,rcvDataPtr(a2)			; and update data ptr
 			subq.w	#1,rcvDataCnt(a2)			; count it
@@ -612,7 +640,7 @@ CudaShiftRegIRQ
 			cmp.b	#((1<<TIP)|\				; is this an idle acknowledge?
 					(1<<vByteAck)|\
 					(1<<TReq)),d0
-			beq.s	@done						; yes, dont handshake.	
+			beq		@done						; yes, dont handshake.	
 
 			cmp.b	#((1<<TIP)|\				; is this an attention byte?
 					(1<<vByteAck)|\
@@ -627,19 +655,16 @@ CudaShiftRegIRQ
 			beq.s	@lastIRQ					; yes					
 
 @dataIrq
-		eieioSTP
 			eori.b	#1<<vByteAck,vBufB(a1)		; acknowledge the current byte
 		eieioSTP
 			bra		@exit						;						
 
 @attnIrq
-		eieioSTP
 			bclr.b	#TIP,vBufB(a1)				; start the response packet transaction
 		eieioSTP
 			bra		@exit						;						
 
 @lastIrq
-		eieioSTP
 			ori.b	#((1<<TIP)|\				; no, terminate the response packet transaction
 					(1<<vByteAck)),vBufB(a1)
 		eieioSTP
@@ -655,11 +680,9 @@ CudaShiftRegIRQ
 ;	mouse).																							<SM6> (rbm)
 ;																									<SM6> (rbm)
 @waitIdleAck									;													<SM6> (rbm)
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#ifSR,vIFR(a1)				; wait for idle state acknowledgement				<SM6> (rbm)
-		eieioSTP
 			beq.s	@waitIdleAck				;													<SM6> (rbm)
-		eieioSTP
 			tst.b	vSR(a1)						; clear the shift reg interrupt						<SM6> (rbm)
 		eieioSTP
 
@@ -667,9 +690,7 @@ CudaShiftRegIRQ
 @done
 			movea.l	curPb(a2),a0				; a0 points to current param block
 			lea		rcvHeader(a2),a1			; a1 points to header buffer
-		eieioSTP
 			cmp.b	#ErrorPkt,1(a1)				; check for Error response packet
-		eieioSTP
 			bne.s	@NotError
 ;
 ;		The current transaction generated an Error <11>
@@ -850,7 +871,9 @@ SetTransferParams
 			clr.l	sendDataPtr(a2)					; no extended data ptr 							<12>
 			bra		@rcvParams
 			
-@notDFAC	cmp.b	#RdWrIIC,pbCmd(a0)				; check for IIC transaction						<SM3>
+@notDFAC	cmp.b	#$25,pbCmd(a0)
+			beq		@dontjump
+			cmp.b	#RdWrIIC,pbCmd(a0)				; check for IIC transaction						<SM3>
 			bne.s	@notRdWrIIC						; use the table if not RdWrIIC					<SM3>
 *
 *	Here is how the transfer globals are set up for IIC transactions…
@@ -885,21 +908,30 @@ SetTransferParams
 *		RespData		•										RespData		•
 *	curPB				CudaPB								curPB				CudaPB
 *
+@dontjump
 			move.w	pbByteCnt(a0),d1				; RdWrIIC uses byte count for send portion	<SM3>
 			addq.w	#1,d1							; include the packet byte already sent		<SM3>
 			move.w	d1,sendHdrCnt(a2)				; set up header byte count					<SM3>
 			move.w	#4,rcvHdrCnt(a2)				; 4 byte header default						<SM3>
 			clr.w	rcvHdrIndex(a2)					; reset index into header buffer			<SM3>
 			move.l	pbBufPtr(a0),a1					; get address of data buffer				<SM3>
-			btst.b	#0,pbParam(a0)					; is this a read or write IIC operation?	<SM3>
-			bne.s	@doIICread						;											<SM3>
+
+			cmp.b	#RdWrIIC,pbCmd(a0)
+			beq.s	@doIICwrite
+
+			btst.b	#0,4(a0)
+			bne.s	@doIICread
 @doIICwrite											;											<SM3>
+			btst.b	#0,pbParam(a0)
+			bne.s	@doIICread
+
 			moveq	#0,d1							; data phase count must be 1 to 256			<SM3>
 			move.b	(a1),d1							;											<SM3>
 			bne.s	@wrCntOK						;											<SM3>
 			move.w	#$0100,d1						;											<SM3>
 @wrCntOK											;											<SM3>
 			move.w	d1,sendDataCnt(a2)				; number of extended data bytes to send		<SM3>
+@newlbl
 			adda.l	#1,a1							;											<SM3>
 			move.l	a1,sendDataPtr(a2)				; extended data ptr							<SM3>
 			clr.w	rcvDataCnt(a2)					; no data to receive on IIC write			<SM3>
@@ -1057,9 +1089,7 @@ CudaTickHandler
 @CallLVL1DT
 			move.l	VIA,a1						; point to the VIA
 			move.l	LVL1DT,a0					; get vector
-		eieioSTP
 			jmp		(a0)
-		eieioSTP
 			ENDWITH								;	}
 			
 ;=========================================================================
@@ -1115,74 +1145,54 @@ CudaTickHandler
 ;-------------------------------------------------------------------------
 CudaInit
 			movea.l	DecoderInfo.VIA1Addr(a0),a2	 		; get VIA 1 base address									<SM3> <SM9>
-		eieioSTP
 			ori.b	#((1<<TIP)| \						; terminate transaction										<SM3>
 					 (1<<vByteAck)),vBufB(a2)			; and set idle state										<SM3> <SM9>
 		eieioSTP
 			move.l	#hw4msDelay,d4						; we want to delay 4 millisecs for ADB reset to complete	<SM3>
 @killtime
-		eieioSTP
 			tst.b	vBufB(a2)							;															<SM3> <SM9>
-		eieioSTP
 			dbra	d4,@killtime						;															<SM3>
-		eieioSTP
 			btst.b	#TReq,vBufB(a2)						; is Cuda starting a transaction???							<SM3> <SM9>
-		eieioSTP
 			bne.s	@noX								; no, then continue with SyncAck							<SM3>
 			move.l	#hw4msDelay,d4						; we want to delay 4 millisecs for ADB reset to complete	<SM3>
 @asyncByte
-		eieioSTP
 			btst.b	#ifSR,vIFR(a2)						; else, wait for that lil' interrupt to occur				<SM3> <SM9>
-		eieioSTP
 			bne.s	@noX								;															<SM3>
 			dbra	d4,@asyncByte						;															<SM3>
 @noX
-		eieioSTP
 			tst.b	vSR(a2)								; clear the pending interrupt									 <SM9>
 		eieioSTP
 			move.l	#hw10msDelay,d4						; Timeout values must exceed duration of maximum ADB auto poll.	<7>
-		eieioSTP
 			bclr.b	#vByteAck,vBufB(a2)					; issue a sync state (TIP = negated, ByteAck = asserted)	 <SM9>
 		eieioSTP
 @waitSync
-		eieioSTP
 			btst.b	#TReq,vBufB(a2)						; wait for sync acknowledge									 <SM9>
-		eieioSTP
 			beq.s	@syncAck							;					
 			dbra.w	d4,@waitSync						;					
 			bra.l	DeadCuda							; go play death chimes
 @syncAck	move.l	#hw10msDelay,d4						; number of retries before giving up with Cuda
 @wSyncIrq	
-		eieioSTP
 			btst.b	#ifSR,vIFR(a2)						; wait for sync acknowledge interrupt						 <SM9>
-		eieioSTP
 			bne.s	@haveSync							;					
 			dbra.w	d4,@wSyncIrq						;					
 @haveSync	move.l	#hw10msDelay,d4						; number of retries before giving up with Cuda
-		eieioSTP
 			bset.b	#vByteAck,vBufB(a2)					; terminate the sync cycle									 <SM9>
 		eieioSTP
 @syncTerm	
-		eieioSTP
 			btst.b	#TReq,vBufB(a2)						; wait for sync termination acknowledge						 <SM9>
-		eieioSTP
 			bne.s	@haveTerm							;					
 			dbra.w	d4,@syncTerm						;					
 			bra.l	DeadCuda							; go play death chimes
 @haveTerm	
-		eieioSTP
 			tst.b	vSR(a2)								; clear the pending interrupt								 <SM9>
 		eieioSTP
 			move.l	#hw10msDelay,d4						; number of retries before giving up with Cuda
 @waitIdle2	
-		eieioSTP
 			btst.b	#ifSR,vIFR(a2)						; wait for sync termination acknowledge						 <SM9>
-		eieioSTP
 			bne.w	@haveIdle							;					
 			dbra.w	d4,@waitIdle2						;					
 			bra.l	DeadCuda							; go play death chimes
 @haveIdle												;					
-		eieioSTP
 			ori.b	#((1<<TIP)| \						; terminate transaction
 					 (1<<vByteAck)),vBufB(a2)			; and set idle state										 <SM9>
 		eieioSTP
@@ -1228,28 +1238,21 @@ CudaInit
 SendCudaCmd	
 			movea.l	DecoderInfo.VIA1Addr(a0),a1			; get VIA 1 base address
 			move.l	#((MaxTout<<16) OR MaxRetries),d4	; number of retries before giving up with Cuda
-		eieioSTP
 			btst.b	#TIP,vBufB(a1)			; check for a transaction in progress
-		eieioSTP
 			bne.s	@AllOK
 @Timeout
-		eieioSTP
 			ori.b	#((1<<TIP)| \			; terminate transaction
 					(1<<vByteAck)),vBufB(a1)	; and set idle state
 		eieioSTP
 @WaitIdle
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#ifSR,vIFR(a1)			; wait for idle state acknowledgement
-		eieioSTP
 			beq.s	@WaitIdle				;				
-		eieioSTP
 			tst.b	vSR(a1)					; clear the idle acknowledge interrupt
 		eieioSTP
 			
 @AllOK		swap.w	d4						; timeout in low word of d4 Retry count in high word
-		eieioSTP
 			btst.b	#TReq,vBufB(a1)			; check for a transaction request from Cuda
-		eieioSTP
 			beq.l	IrqMissed				; MIssed Vsr Irq because of INITVIAS
 			bsr5	@SendPtype				; send the packet type
 			beq.l	RealAbort				; Discard Aborting transaction
@@ -1274,7 +1277,6 @@ SendCudaCmd
 ;
 @EndCmd
 
-		eieioSTP
 			bclr.b	#SRdir,vACR(a1)			; shift in
 		eieioSTP
 			ori.b	#((1<<TIP)|\			; terminate command packet transaction
@@ -1285,7 +1287,6 @@ SendCudaCmd
 ;	Now receive the Standard Response packet Header
 ;
 			bsr5	readAttn				; get the Attention byte
-		eieioSTP
 			bclr.b	#TIP,vBufB(a1)			; start the response transaction
 		eieioSTP
 		
@@ -1299,17 +1300,15 @@ SendCudaCmd
 			exg		d0,d1					; save the packet type and flags returned
 		
 			bsr5	readByte				; get the command
-		eieioSTP
 			ori.b	#((1<<TIP)|\			; terminate command packet transaction
 					(1<<vByteAck)),vBufB(a1)			;				
 		eieioSTP
 		
 @WaitIdle1
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#ifSR,vIFR(a1)			; wait for idle state acknowledgement
 		eieioSTP
 			beq.s	@WaitIdle1				;				
-		eieioSTP
 			tst.b	vSR(a1)					; clear the idle acknowledge interrupt
 		eieioSTP
 ;
@@ -1325,13 +1324,10 @@ SendCudaCmd
 
 ;--------------------------------------------------------------------------
 @SendPtype
-		eieioSTP
 			bset.b	#SRdir,vACR(a1)			; shift out
 		eieioSTP
 			btst.b	#TReq,vBufB(a1)			; check for abort
-		eieioSTP
 			beq.w	AbortReq				; go away if abort requested
-		eieioSTP
 			move.b	d0,vSR(a1)				; load byte into shift reg
 		eieioSTP
 			bclr.b	#TIP,vBufB(a1)			; TIP indicates shift reg is full on 1st byte
@@ -1340,8 +1336,8 @@ SendCudaCmd
 ;	Check Vsr Irq until timeout.  If timeout then check the retry count
 ;	and Call Death Chimes if Retry count exausted.
 ;
-@PollDelay	btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
+@PollDelay	bsr.l	otherDelay
+			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
 			bne.w	VsrIrq					; Go service Shift register Irq
 			dbra.w	d4,@PollDelay			; try again if timed out
 			move.w	#MaxTout,d4				; Reset the Timeout
@@ -1350,24 +1346,20 @@ SendCudaCmd
 			bne.s	@Timeout
 	
 DeadCuda	
-		eieioSTP
 			ori.b	#((1<<TIP)| \						; terminate transaction
 					 (1<<vByteAck)),vBufB(a1)			; and set idle state
 		eieioSTP
 			move.l	#ErrCudaInit,d7			; Cuda failed, zero high byte flags 		<SM7>
 			move.l	#0001,d6				; d6.l must be nonzero
-			bigjmp	Error1Handler,a3		; Play death chimes
+			bra.s	*
 
 VsrIrq
-			move.b	#10,d4					; mode 7 interrupt occurs at falling edge CB1	<LW2><VIA rbm>
-@m7dly										; use d4 since retry count not required anymore	<LW2><VIA rbm>
-		eieioSTP
-			tst.b	vBufB(a1)				; hardware access is 1.2µS						<LW2><VIA rbm>
-		eieioSTP
-			sub.b	#1,d4					; can only trash low byte						<LW2><VIA rbm>
-			bne.s	@m7dly					; wait long enough for CB1 to rise (10µS delay)	<LW2><VIA rbm>
-			
-		eieioSTP
+			move.l	d4,-(sp)
+			move	$d00,d4
+			divu	#10,d4
+			dbra.w	d4,*
+			move.l	(sp)+,d4
+
 			tst.b	vSR(a1)					; clear the interrupt
 		eieioSTP
 			btst.b	#TReq,vBufB(a1)			; exit with abort status
@@ -1381,14 +1373,13 @@ AbortReq	rts5
 			
 			Export	RealAbort	
 RealAbort	
-		eieioSTP
 			bclr.b	#SRdir,vACR(a1)			; shift in										<rbm>
 		eieioSTP
 			ori.b	#((1<<TIP)| \			; terminate transaction
 					(1<<vByteAck)),vBufB(a1)	; and set idle state
 		eieioSTP
-WAbortAck	btst.b	#ifSR,vIFR(a1)			; wait for acknowledgement of abort cycle
-		eieioSTP
+WAbortAck	bsr.l	otherDelay
+			btst.b	#ifSR,vIFR(a1)			; wait for acknowledgement of abort cycle
 			beq.s	WAbortAck				;				
 			tst.b	vSR(a1)					; clear the pending interrupt
 		eieioSTP
@@ -1404,28 +1395,21 @@ WAbortAck	btst.b	#ifSR,vIFR(a1)			; wait for acknowledgement of abort cycle
 			Export	IrqMissed	
 IrqMissed
 			bsr5	Delay100us				; Let Cuda see SysSes. ≥ 125µsec
-		eieioSTP
 			bclr.b	#SRdir,vACR(a1)			; shift in
 		eieioSTP
 StartRPkt
-		eieioSTP
 			tst.b	vSR(a1)					; discard the byte
 		eieioSTP
 			bclr.b	#TIP,vBufB(a1)			; start the response transaction
 		eieioSTP
 
 DumpAbort
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
 			beq.s	DumpAbort
-		eieioSTP
 			tst.b	vSR(a1)					; discard the byte
-		eieioSTP
-			btst.b	#TReq,vBufB(a1)			; check for last byte
 		eieioSTP
 			bne.s	DumpDone				; Clock Tick Packets only 2 bytes
-		eieioSTP
 			eori.b	#1<<vByteAck,vBufB(a1)	; acknowlege byte
 		eieioSTP
 			bra.s	DumpAbort				; and loop for next byte
@@ -1453,16 +1437,13 @@ DumpAbort
 ; TREQ		__________________|
 ;
 DumpDone
-		eieioSTP
 			ori.b	#((1<<TIP)| \			; terminate transaction
 					(1<<vByteAck)),vBufB(a1)	; and set idle state
 		eieioSTP
 @WaitIdleAck
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#ifSR,vIFR(a1)			; wait for idle state acknowledge
-		eieioSTP
 			beq.s	@WaitIdleAck			;				
-		eieioSTP
 			tst.b	vSR(a1)					; discard the byte
 		eieioSTP
 			bra.w	SendCudaCmd				; go try sending our command again
@@ -1472,25 +1453,20 @@ DumpDone
 ;	inputs:		d0.b			data byte to send to Cuda.
 ;	trashes:	d0.b
 sendByte1
-		eieioSTP
 			bset.b	#SRdir,vACR(a1)			; shift out
 		eieioSTP
 			move.b	d0,vSR(a1)				; load byte into shift reg
 		eieioSTP
 			eori.b	#1<<vByteAck,vBufB(a1)	; indicate byte pending in VIA
 		eieioSTP
-@poll		btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
+@poll		bsr.l	otherDelay
+			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
 			beq.s	@poll
-			move.b	#10,d0					; mode 7 interrupt occurs at falling edge CB1	<LW2><VIA rbm>
-@m7dly
-		eieioSTP
-			tst.b	vBufB(a1)				; hardware access is 1.2µS						<LW2><VIA rbm>
-		eieioSTP
-			sub.b	#1,d0					; can only trash low byte						<LW2><VIA rbm>
-			bne.s	@m7dly					; wait long enough for CB1 to rise (10µS delay)	<LW2><VIA rbm>
-			
-		eieioSTP
+			move.l	d0,-(sp)
+			move	$d00,d0
+			divu	#10,d0
+			dbra.w	d0,*
+			move.l	(sp)+,d0
 			tst.b	vSR(a1)					; clear the interrupt
 		eieioSTP
 			rts5
@@ -1498,11 +1474,9 @@ sendByte1
 ;--------------------------------------------------------------------------
 ;			Export	readByte	
 readByte	
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
 			beq.s	readByte
-		eieioSTP
 			move.b	vSR(a1),d0				; read the byte
 		eieioSTP
 			eori.b	#1<<vByteAck,vBufB(a1)	; and acknowledge it
@@ -1512,11 +1486,9 @@ readByte
 ;--------------------------------------------------------------------------
 ;			Export	readAttn	
 readAttn
-		eieioSTP
+			bsr.l	otherDelay
 			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
 			beq.s	readAttn
-		eieioSTP
 			tst.b	vSR(a1)					; clear the interrupt
 		eieioSTP
 			rts5
@@ -1525,14 +1497,19 @@ readAttn
 ;			Export	delay100us	
 delay100us	
 			move.w	#DelayCnt,d3
-		eieioSTP
 @wait
-		eieioSTP
 			tst.b	(a1)					; sync to VIA clock
-		eieioSTP
 			dbra	d3,@wait				; delay at least 100 us (very rough)
 			rts5
 
+;--------------------------------------------------------------------------
+otherDelay	
+			move.l	d0,-(sp)
+			move	$d00,d0
+			lsr		#6,d0
+			dbra.w	d0,*
+			move.l	(sp)+,d0
+			rts
 			
 
 	ENDPROC								;	EndProc for CudaMgr		}
diff --git a/OS/DeferredTaskMgr.a b/OS/DeferredTaskMgr.a
--- a/OS/DeferredTaskMgr.a
+++ b/OS/DeferredTaskMgr.a
@@ -151,13 +151,21 @@ vDisptch		BTST.B	#INVBL,QFLAGS+VBLQUEUE 	; doing VBL tasks?
 				MOVEA.L	DTParm(A0),A1			; get optional parameter
 				ANDI.W	#$F8FF,SR				; enable all ints
 				JSR		(A2)					; and go do task
+
+				MOVEA.L	ExpandMem,A1
+				MOVEA.L	$26a(A1),A2
+				TST.L	(A2)
+				BNE.S	@otherThing
+
 @DspStart		ORI.W	#HiIntMask,SR			; disable all ints
 				MOVE.L	DTskQHdr,D0				; get queue head
 				BNE.S	@DspLoop				; loop if tasks	exist
 				
-				BCLR.B	#InDTQ,DTQFlags			; clear indicator
+@backwards		BCLR.B	#InDTQ,DTQFlags			; clear indicator
 				RTS								; and exit
 
+@otherThing		ORI		#$0700,SR
+				BRA.S	@backwards
 
 				END 
 
diff --git a/OS/DispTable.a b/OS/DispTable.a
--- a/OS/DispTable.a
+++ b/OS/DispTable.a
@@ -314,33 +314,6 @@ DspTable	PROC	EXPORT
 		endif
 		endm
 
-	If hasNewHeapMgr Then
-;------------------------------------------------------------------------------
-; <SM46> BT: Second OS table macro for Figment.  This is temporary
-; until figment is fully approved.
-;------------------------------------------------------------------------------
-		macro
-		OS2		&num,&name,&cond
-		if (*-SecondOS)/4 <> &Eval(&num) then
-		aerror	'Trap Number out of sequence'
-		endif
-		if &name = '' then
-		dc.l	0		; unused
-		elseif &cond = '' then
-		import	&name
-		dc.l	&name-BaseOfRom
-		elseif &Eval(&cond) then
-		import	&name
-		dc.l	&name-BaseOfRom
-		else
-		dc.l	0		; not used in this configuration
-		endif
-		endm
-;------------------------------------------------------------------------------
-; <SM46> BT: End second OS table macro
-;------------------------------------------------------------------------------
-	endif
-
 
 	EXPORT	DispTable
 	IMPORT	BaseofRom
@@ -353,13 +326,13 @@ DispTable
 
 FirstTool
 	ToolBox	$000								; toolbox trap $000 (ALWAYS LEAVE AS ZERO) <SM39> rb
-	ToolBox	$001,__SNDDISPOSECHANNEL			; toolbox trap $001
-	ToolBox	$002,__SNDADDMODIFIER				; toolbox trap $002
-	ToolBox	$003,__SNDDOCOMMAND					; toolbox trap $003
-	ToolBox	$004,__SNDDOIMMEDIATE				; toolbox trap $004
-	ToolBox	$005,__SNDPLAY						; toolbox trap $005
-	ToolBox	$006,__SNDCONTROL					; toolbox trap $006
-	ToolBox	$007,__SNDNEWCHANNEL				; toolbox trap $007
+	ToolBox	$001 ;,__SNDDISPOSECHANNEL			; toolbox trap $001
+	ToolBox	$002 ;,__SNDADDMODIFIER				; toolbox trap $002
+	ToolBox	$003 ;,__SNDDOCOMMAND				; toolbox trap $003
+	ToolBox	$004 ;,__SNDDOIMMEDIATE				; toolbox trap $004
+	ToolBox	$005 ;,__SNDPLAY					; toolbox trap $005
+	ToolBox	$006 ;,__SNDCONTROL					; toolbox trap $006
+	ToolBox	$007 ;,__SNDNEWCHANNEL				; toolbox trap $007
 	ToolBox	$008,InitProcMenu					; toolbox trap $008 (new menu mgr)	<C175>
 	ToolBox	$009,GetCVariant					; toolbox trap $009 				<C496>
 	ToolBox	$00A,GetWVariant					; toolbox trap $00A					<C496>
@@ -374,8 +347,8 @@ FirstTool
 	ToolBox	$013,TEAutoView						; toolbox trap $013
 	ToolBox	$014,SetFractEnable					; toolbox trap $014 (font mgr) 		<C560>
 ;	ToolBox	$015,SCSIMgr						; toolbox trap $015
-	ToolBox	$015,SCSIDispatchCommon				; toolbox trap $015 <RLM>
-	ToolBox	$016,Pack8							; toolbox trap $016
+	ToolBox	$015, ;SCSIDispatchCommon			; toolbox trap $015 <RLM>
+	ToolBox	$016, ;Pack8						; toolbox trap $016
 	ToolBox	$017,CopyMask						; toolbox trap $017
 	ToolBox	$018,FixAtan2						; toolbox trap $018
 	ToolBox	$019,XMunger						; toolbox trap $019
@@ -396,13 +369,13 @@ FirstTool
 	ToolBox	$028,ShowDItem						; toolbox trap $028
 	ToolBox	$029,LayerDispatch					; toolbox trap $029 (LayerDispatch) (v1.1)
 	ToolBox	$02A,MainComponent					; toolbox trap $02A (ComponentDispatch) (v1.1)
-	ToolBox	$02B,Pack9							; toolbox trap $02B
+	ToolBox	$02B ;,Pack9						; toolbox trap $02B
 	ToolBox	$02C,Pack10							; toolbox trap $02C
-	ToolBox	$02D,Pack11							; toolbox trap $02D
+	ToolBox	$02D ;,Pack11						; toolbox trap $02D
 	ToolBox	$02E,Pack12							; toolbox trap $02E
 	ToolBox	$02F,Pack13							; toolbox trap $02F
-	ToolBox	$030,Pack14Entry					; toolbox trap $030
-	ToolBox	$031,Pack15							; toolbox trap $031
+	ToolBox	$030 ;,Pack14Entry					; toolbox trap $030
+	ToolBox	$031 ;,Pack15						; toolbox trap $031
 	ToolBox	$032								; toolbox trap $032 (unimplemented) (v1.1)
 	ToolBox	$033,ScrnBitMap						; toolbox trap $033
 	ToolBox	$034,SetFScaleDisable				; toolbox trap $034
@@ -819,7 +792,7 @@ FirstTool
 	ToolBox	$1C5,RsrcMapEntry					; toolbox trap $1C5
 	ToolBox	$1C6,Secs2Date						; toolbox trap $1C6
 	ToolBox	$1C7,Date2Secs						; toolbox trap $1C7
-	ToolBox	$1C8,__SYSBEEP						; toolbox trap $1C8
+	ToolBox	$1C8 ;,__SYSBEEP						; toolbox trap $1C8
 	ToolBox	$1C9,SystemError					; toolbox trap $1C9
 	ToolBox	$1CA,PutIcon						; toolbox trap $1CA
 	ToolBox	$1CB,TEGetText						; toolbox trap $1CB
@@ -958,11 +931,11 @@ FirstTool
 	ToolBox	$250,SeedCFill						; toolbox trap $250		<31Jan89 BAL>
 	ToolBox	$251,KopyMask						; toolbox trap $251 	<SM40>
 	ToolBox	$252,HighLevelFSDispatch			; toolbox trap $252 (unknown)		<C146>
-	ToolBox	$253,DictionaryDispatch				; toolbox trap $253 (DictionaryDispatch) <SM41> CSS
-	ToolBox	$254,TSMDispatch					; toolbox trap $254 (TMSDispatch)		<C146>
+	ToolBox	$253 ;,DictionaryDispatch			; toolbox trap $253 (DictionaryDispatch) <SM41> CSS
+	ToolBox	$254 ;,TSMDispatch					; toolbox trap $254 (TMSDispatch)		<C146>
 	ToolBox	$255								; toolbox trap $255 (unknown)		<C146>
 	ToolBox	$256								; toolbox trap $256 (unknown)		<C146>
-	ToolBox	$257,DockingDispatch				; toolbox trap $257 (unknown)		<SM38>
+	ToolBox	$257 ;,DockingDispatch				; toolbox trap $257 (unknown)		<SM38>
 	ToolBox	$258								; toolbox trap $258 (unknown)		<C146>
 	ToolBox	$259								; toolbox trap $259 (unknown)		<C146>
 	ToolBox	$25A								; toolbox trap $25A (unknown)		<C146>
@@ -983,13 +956,14 @@ FirstTool
 	ToolBox	$268,DialogMgrDispatch				; toolbox trap $268 <RLM>
 
 	ToolBox	$269								; toolbox trap $269 (unknown)		<C146> <C413>
-	ToolBox	$26A								; toolbox trap $26A (unknown)		<C146> <C413>
+	ToolBox	$26A,DeviceDispatch
 	ToolBox	$26B								; toolbox trap $26B (unknown)		<C146> <C413>
 	ToolBox	$26C								; toolbox trap $26C (unknown)		<C146> <C413>
 	ToolBox	$26D								; toolbox trap $26D (unknown)		<C146> <C413>
 	ToolBox	$26E								; toolbox trap $26E (unknown)		<C146> <C413>
 	ToolBox	$26F								; toolbox trap $26F (unknown)		<C146> <C413>
-	DCB.L	16,0								; toolbox trap $270-$27F (unknown)		<C146>
+	DCB.L	15,0								; toolbox trap $270-$27E (unknown)		<C146>
+	ToolBox	$27F,MPDispatchStubTrap
 	DCB.L	16,0								; toolbox trap $280-$28F (unknown)		<C146>
 	ToolBox	$290,InitPalettes					; toolbox trap $290		<02Jun87 DAF>
 	ToolBox	$291,NewPalette						; toolbox trap $291		<02Jun87 DAF>
@@ -1045,7 +1019,7 @@ FirstTool
 
 	DCB.L	16,0								; toolbox trap $2E0-$2EF (unknown)		<C146>
 	ToolBox	$2F0								; toolbox trap $2AF (unknown)		<C146>
-	ToolBox	$2F1								; toolbox trap $2AF (unknown)		<C146>
+	ToolBox	$2F1,ATAManager
 	ToolBox	$2F2								; toolbox trap $2AF (unknown)		<C146>
 	ToolBox	$2F3,ExpansionBusDispatch			; toolbox trap $2F3 (Expansion Bus Mgr)
 	ToolBox	$2F4								; toolbox trap $2AF (unknown)		<C146>
@@ -1262,7 +1236,7 @@ FirstTool
 	ToolBox	$3C6								; quickdraw hook $3C6
 	ToolBox	$3C7								; quickdraw hook $3C7
 	ToolBox	$3C8								; quickdraw2 hook $3C8
-	ToolBox	$3C9,IconDispatch					; quickdraw _IconDispatch $3C9
+	ToolBox	$3C9 ;,IconDispatch					; quickdraw _IconDispatch $3C9
 	ToolBox	$3CA,DeviceLoop						; quickdraw _DeviceLoop <20> PN
 	ToolBox	$3CB								; quickdraw hook $3CB
 	ToolBox	$3CC								; quickdraw hook $3CC
@@ -1270,7 +1244,8 @@ FirstTool
 	ToolBox	$3CE								; quickdraw hook $3CE
 	ToolBox	$3CF								; quickdraw hook $3CF
 	DCB.L	16,0								; toolbox trap $3D0-$3DF (unknown)		<C146>
-	DCB.L	11,0								; toolbox trap $3E0-$3EA (unknown)		<C146>
+	ToolBox	$3E0,QDExtensions2
+	DCB.L	10,0								; toolbox trap $3E1-$3EA (unknown)		<C146>
 		IF hasDisplayMgr THEN					;	Only install if we have we are flagged
 	ToolBox	$3EB,DisplayDispatch				; toolbox trap $3EB (DisplayManager)	(IH)
 		ELSE
@@ -1278,7 +1253,7 @@ FirstTool
 		ENDIF
 	DCB.L	4,0									; toolbox trap $3EC-$3EF (unknown)		<C146>
 	ToolBox	$3F0								; toolbox trap $3F0 (unknown)		<C146>
-	ToolBox	$3F1								; toolbox trap $3F1 (unknown)		<C146>
+	ToolBox	$3F1,GestaltValueDispatch
 	ToolBox	$3F2								; toolbox trap $3F2 (unknown)		<C146>
 	ToolBox	$3F3								; toolbox trap $3F3 (unknown)		<C146>
 	ToolBox	$3F4								; toolbox trap $3F4 (unknown)		<C146>
@@ -1384,14 +1359,14 @@ FirstOS
 	OS		$50,RelStringTrap					; OS trap $50
 	OS		$51,ReadXPRam						; OS trap $51
 	OS		$52,WriteXPRam						; OS trap $52
-	OS		$53,ClkNoMem						; OS trap $53
+	OS		$53 ;,ClkNoMem						; OS trap $53
 	OS		$54,UprStringTrap					; OS trap $54
 	OS		$55,__StripAddress					; OS trap $55 (new memory mgr)	<C172>
 	OS		$56,NewLwrString					; OS trap $56 ;in-ROM script manager
 	OS		$57,SetApplBase						; OS trap $57
-	OS		$58,__InsTime						; OS trap $58
-	OS		$59,__RmvTime						; OS trap $59
-	OS		$5A,__PrimeTime						; OS trap $5A
+	OS		$58 ;,__InsTime						; OS trap $58
+	OS		$59 ;,__RmvTime						; OS trap $59
+	OS		$5A ;,__PrimeTime					; OS trap $5A
 	OS		$5B,PowerOff						; OS trap $5B (poweroff trap)	<11apr86>/<C68>
 	OS		$5C,MemoryDispatch,hasMMU			; OS trap $5C (MemoryDispatch trap) <v1.8>
 	OS		$5D									; OS trap $5D (MMU trap, set up later) <2.7>
@@ -1408,7 +1383,7 @@ FirstOS
 	OS		$68,HNoRSRC							; OS trap $68
 	OS		$69,HGetFlags						; OS trap $69
 	OS		$6A,HSetFlags						; OS trap $6A
-	OS		$6B,TestManager						; OS trap $6B (test trap)		<C17/27may86>
+	OS		$6B ;,TestManager					; OS trap $6B (test trap)		<C17/27may86>
 	OS		$6C,InitFS							; OS trap $6C
 	OS		$6D,InitEvents						; OS trap $6D
 	OS		$6E,SlotManager,hasSlotMgr			; OS trap $6E					<C90>
@@ -1434,13 +1409,13 @@ FirstOS
 	OS		$82,DTInstallTrap					; OS trap $82 (deferred task)	<C489>
 	OS		$83,SetOSDefault,hasSlotMgr			; OS trap $83 (which os to use)	<C508>
 	OS		$84,GetOSDefault,hasSlotMgr			; OS trap $84 (which os to use)	<C508>
-	OS		$85,PmgrOp,hasPwrControls|PwrMgrADB|hasPwrMgrClock	; OS trap $85
+	OS		$85 ;,PmgrOp,hasPwrControls|PwrMgrADB|hasPwrMgrClock	; OS trap $85
 	OS		$86,IOPInfoAccess,hasIopScc|hasIopSwim	; OS trap $086					<1.3>
 	OS		$87,IOPMsgRequest,hasIopScc|hasIopSwim	; OS trap $087					<1.3>
 	OS		$88,IOPMoveData,hasIopScc|hasIopSwim	; OS trap $088					<1.3>
 	OS		$89,NewSCSITrap,0					; os trap $89 (async SCSI Mgr)	<v1.7><3.0>
 	OS		$8A,GoToSleep,hasPwrControls|PwrMgrADB|hasPwrMgrClock	; OS trap $8A
-	OS		$8B,COMMTOOLBOXDISPATCHER			; os trap $8B (CommToolBoxTrap)		<SM33><PN>
+	OS		$8B ;,COMMTOOLBOXDISPATCHER			; os trap $8B (CommToolBoxTrap)		<SM33><PN>
 	OS		$8C									; os trap $8C (unknown)		<C489><C508><C908><1.5>
 	OS		$8D,DebugUtil						; os trap $8D					<1.5>
 	OS		$8E,ExtBTreeDispatch				; os trap $8E (BTreeDispatch)					<2.0>
@@ -1448,7 +1423,7 @@ FirstOS
 	OS		$90,SysEnvironsTrap					; OS trap $90					<C982>
 	OS		$91,Translate24To32					; os trap $91 (unknown)			<2.9> BAL
 	OS		$92,EgretDispatch,hasEgret			; os trap $92					<4>
-	OS		$93,__Microseconds					; os trap $93					<9>
+	OS		$93 ;,__Microseconds					; os trap $93					<9>
 	OS		$94									; os trap $94 (unknown)
 	OS		$95									; os trap $95 (unknown)
 	OS		$96									; os trap $96 (unknown)
@@ -1459,8 +1434,8 @@ FirstOS
 	OS		$9B									; os trap $9B (unknown)
 	OS		$9C									; os trap $9C (unknown)
 	OS		$9D,MoveHLow						; os trap $9D MoveHLow			<SM18> tcn
-	OS		$9E,PowerMgrDispatch,hasPwrControls	; os trap $9E (PowerMgrDispatch Trap)		<SM25> <SM35>
-	OS		$9F,PowerDispatch,hasPwrControls	; os trap $9F (PwrControls Traps)	<17> rb
+	OS		$9E ;,PowerMgrDispatch,hasPwrControls	; os trap $9E (PowerMgrDispatch Trap)		<SM25> <SM35>
+	OS		$9F ;,PowerDispatch,hasPwrControls	; os trap $9F (PwrControls Traps)	<17> rb
 	OS		$A0									; os trap $A0 (unknown)
 	OS		$A1									; os trap $A1 (unknown)
 	OS		$A2									; os trap $A2 (unknown)
@@ -1493,7 +1468,7 @@ FirstOS
 	OS		$B6,vWaitUntil						; vector $B6 (iocore)			<C811>
 	OS		$B7,vSyncWait						; vector $B7 (iocore)			<C811>
 
-	OS		$B8,__SNDAPPDEAD					; vector $B8
+	OS		$B8 ;,__SNDAPPDEAD					; vector $B8
 	OS		$B9,vDisPtch						; vector $B9 (deferred task)	<C811><2.2>
 	OS		$BA,vIAZInit						; vector $BA					<16jun87 CSL>
 	OS		$BB,vIAZPostInit					; vector $BB					<16jun87 CSL>
@@ -1530,7 +1505,7 @@ FirstOS
 	OS		$DA,vExtendFile						; vector $DA
 	OS		$DB,vTruncateFile					; vector $DB
 	OS		$DC,vCMSetUp						; vector $DC
-	OS		$DD,vppcDispatcher					; vector $DD (PPCDispatcher)
+	OS		$DD ;,vppcDispatcher				; vector $DD (PPCDispatcher)
 	OS		$DE,vDtrmV1							; vector $DE
 	OS		$DF,vBlkAlloc						; vector $DF
 	OS		$E0,vBlkDeAlloc						; vector $E0
@@ -1570,285 +1545,5 @@ FirstOS
 ; end of vectors
 ;------------------------------------------------------------------------------
 
-
-	if hasNewHeapMgr Then
-;------------------------------------------------------------------------------
-; <SM46> BT: Second OS table for Figment.  This is temporary
-; until figment is fully approved.
-;------------------------------------------------------------------------------
-; WARNING -- DO NOT CHANGE THIS TABLE UNLESS YOU CHANGE THE CORRESPONDING OS TABLE! (ABOVE)
-;------------------------------------------------------------------------------
-
-SecondOS
-	OS2		$00,Open							; OS trap $00
-	OS2		$01,Close							; OS trap $01
-	OS2		$02,Read							; OS trap $02
-	OS2		$03,Write							; OS trap $03
-	OS2		$04,ControlTrap						; OS trap $04
-	OS2		$05,StatusTrap						; OS trap $05
-	OS2		$06,KillIOTrap						; OS trap $06
-	OS2		$07,GetVolInfo						; OS trap $07
-	OS2		$08,FileCreate						; OS trap $08
-	OS2		$09,FileDelete						; OS trap $09
-	OS2		$0A,OpenRFTrap						; OS trap $0A
-	OS2		$0B,RenameTrap						; OS trap $0B
-	OS2		$0C,GetFileInfo						; OS trap $0C
-	OS2		$0D,SetFileInfo						; OS trap $0D
-	OS2		$0E,UnmountVolTrap					; OS trap $0E
-	OS2		$0F,MountVol						; OS trap $0F
-	OS2		$10,FileAlloc						; OS trap $10
-	OS2		$11,GetEOFTrap						; OS trap $11
-	OS2		$12,SetEOFTrap						; OS trap $12
-	OS2		$13,FlushVolTrap					; OS trap $13
-	OS2		$14,GetVolTrap						; OS trap $14
-	OS2		$15,SetVolTrap						; OS trap $15
-	OS2		$16,FInitQueue						; OS trap $16
-	OS2		$17,EjectTrap						; OS trap $17
-	OS2		$18,GetFPosTrap						; OS trap $18
-	OS2		$19,Fig_InitZoneTrap				; OS trap $19
-	OS2		$1A,Fig_GetZone						; OS trap $1A
-	OS2		$1B,Fig_SetZone						; OS trap $1B
-	OS2		$1C,Fig_FreeMem						; OS trap $1C
-	OS2		$1D,Fig_MaxMemTrap					; OS trap $1D
-	OS2		$1E,Fig_NewPtrTrap					; OS trap $1E
-	OS2		$1F,Fig_DisposePtr					; OS trap $1F
-	OS2		$20,Fig_SetPtrSizeTrap				; OS trap $20
-	OS2		$21,Fig_GetPtrSizeTrap				; OS trap $21
-	OS2		$22,Fig_NwHandle					; OS trap $22
-	OS2		$23,Fig_DsposeHandle				; OS trap $23
-	OS2		$24,Fig_SetHandleSizeTrap			; OS trap $24
-	OS2		$25,Fig___GetHandleSize				; OS trap $25
-	OS2		$26,Fig_HandleZoneTrap				; OS trap $26
-	OS2		$27,Fig_ReallocHandleTrap			; OS trap $27
-	OS2		$28,Fig_RecoverHandleTrap			; OS trap $28
-	OS2		$29,Fig_HLock						; OS trap $29
-	OS2		$2A,Fig_HUnlock						; OS trap $2A
-	OS2		$2B,Fig_EmptyHandle					; OS trap $2B
-	OS2		$2C,Fig_InitApplZone				; OS trap $2C
-	OS2		$2D,Fig_SetApplLimit				; OS trap $2D
-	OS2		$2E,__BlockMove						; OS trap $2E
-	OS2		$2F,PostEventTrap					; OS trap $2F
-	OS2		$30,OSEventAvailTrap				; OS trap $30 <PN> <SM28> rb
-	OS2		$31,GetOSEventTrap					; OS trap $31
-	OS2		$32,FlushEvents						; OS trap $32
-	OS2		$33,VInstall						; OS trap $33
-	OS2		$34,VRemove							; OS trap $34
-	OS2		$35,OffLine							; OS trap $35
-	OS2		$36,Fig_MoreMasters					; OS trap $36
-	OS2		$37,ReadParam						; OS trap $37
-	OS2		$38,WriteParamTrap					; OS trap $38
-	OS2		$39,ReadDateTimeTrap				; OS trap $39
-	OS2		$3A,SetDateTimeTrap					; OS trap $3A
-	OS2		$3B,DelayTrap						; OS trap $3B
-	OS2		$3C,CmpString						; OS trap $3C
-	OS2		$3D,DrvrInstall						; OS trap $3D
-	OS2		$3E,DrvrRemove						; OS trap $3E
-	OS2		$3F,InitUtil						; OS trap $3F
-	OS2		$40,Fig_ResrvMem					; OS trap $40
-	OS2		$41,SetFilLock						; OS trap $41 new from extensionHFS
-	OS2		$42,RstFilLock						; OS trap $42 new from extensionHFS
-	OS2		$43,SetFilType						; OS trap $43
-	OS2		$44,SetFPosTrap						; OS trap $44
-	OS2		$45,FlushFile						; OS trap $45
-	OS2		$46,GetTrapAddressTrap				; OS trap $46
-	OS2		$47,SetTrapAddressTrap				; OS trap $47
-	OS2		$48,Fig_PtrZoneTrap					; OS trap $48
-	OS2		$49,Fig_HPurge						; OS trap $49
-	OS2		$4A,Fig_HNoPurge					; OS trap $4A
-	OS2		$4B,Fig_SetGrowZone					; OS trap $4B
-	OS2		$4C,Fig_CompactMemTrap				; OS trap $4C
-	OS2		$4D,Fig_PurgeMem					; OS trap $4D
-	OS2		$4E,AddDriveTrap					; OS trap $4E
-	OS2		$4F,InstallRDrivers					; OS trap $4F
-	OS2		$50,RelStringTrap					; OS trap $50
-	OS2		$51,ReadXPRam						; OS trap $51
-	OS2		$52,WriteXPRam						; OS trap $52
-	OS2		$53,ClkNoMem						; OS trap $53
-	OS2		$54,UprStringTrap					; OS trap $54
-	OS2		$55,__StripAddress					; OS trap $55 (new memory mgr)	<C172>
-	OS2		$56,NewLwrString					; OS trap $56 ;in-ROM script manager
-	OS2		$57,Fig_SetApplBase					; OS trap $57
-	OS2		$58,__InsTime						; OS trap $58
-	OS2		$59,__RmvTime						; OS trap $59
-	OS2		$5A,__PrimeTime						; OS trap $5A
-	OS2		$5B,PowerOff						; OS trap $5B (poweroff trap)	<11apr86>/<C68>
-	OS2		$5C,MemoryDispatch,hasMMU			; OS trap $5C (MemoryDispatch trap) <v1.8>
-	OS2		$5D									; OS trap $5D (MMU trap, set up later) <2.7>
-	OS2		$5E,__NMINSTALL						; OS trap $5E (v1.1) <SM21> tcn
-	OS2		$5F,__NMREMOVE						; OS trap $5F (v1.1) <SM21> tcn
-	OS2		$60,TFSDispatch						; OS trap $60
-	OS2		$61,Fig_MaxBlockTrap				; OS trap $61
-	OS2		$62,Fig_PurgeSpaceTrap				; OS trap $62
-	OS2		$63,Fig_MaxApplZone					; OS trap $63
-	OS2		$64,Fig_MoveHHi						; OS trap $64
-	OS2		$65,Fig_StackSpaceTrap				; OS trap $65
-	OS2		$66,Fig_NewEmptyHandleTrap			; OS trap $66
-	OS2		$67,Fig_HRSRC						; OS trap $67
-	OS2		$68,Fig_HNoRSRC						; OS trap $68
-	OS2		$69,Fig_HGetFlags					; OS trap $69
-	OS2		$6A,Fig_HSetFlags					; OS trap $6A
-	OS2		$6B,TestManager						; OS trap $6B (test trap)		<C17/27may86>
-	OS2		$6C,InitFS							; OS trap $6C
-	OS2		$6D,InitEvents						; OS trap $6D
-	OS2		$6E,SlotManager,hasSlotMgr			; OS trap $6E					<C90>
-	OS2		$6F,SlotVInstall,hasSlotMgr			; os trap $6F (Slot Manager)	<C147>
-	OS2		$70,SlotVRemove,hasSlotMgr			; os trap $70 (Slot Manager)	<C147>
-	OS2		$71,AttachVBL,hasSlotMgr			; os trap $71 (VBL Manager)		<C147>
-	OS2		$72,DoVBLTask,hasSlotMgr			; os trap $72 (VBL Manager)		<C147>
-	OS2		$73									; OS trap $73 (reserved for twitcher??) <C908>
-	OS2		$74,CacheTrap						; os trap $74					<v2.3>
-	OS2		$75,SIntInstall,hasSlotMgr			; OS trap $75					<C88>
-	OS2		$76,SIntRemove,hasSlotMgr			; OS trap $76					<C88>
-	OS2		$77,CountADBs						; OS trap $77 (fdb manager)		<C103>
-	OS2		$78,GetIndADBTrap					; OS trap $78 (fdb manager)		<C103>
-	OS2		$79,GetADBInfoTrap					; OS trap $79 (fdb manager)		<C103>
-	OS2		$7A,SetADBInfoTrap					; OS trap $7A (fdb manager)		<C103>
-	OS2		$7B,ADBReinit						; OS trap $7B (fdb manager)		<C103>
-	OS2		$7C,ADBOpTrap						; OS trap $7C (fdb manager)		<C103>
-	OS2		$7D,GetDefaultStartup				; OS trap $7D (start manager)	<C908>
-	OS2		$7E,SetDefaultStartup				; OS trap $7E (start manager)	<C908>
-	OS2		$7F,InternalWait					; os trap $7F (start manager)	<A345>
-	OS2		$80,GetVideoDefault,hasSlotMgr		; OS trap $80 (start manager)	<A345>
-	OS2		$81,SetVideoDefault,hasSlotMgr		; OS trap $81 (start manager)	<A345>
-	OS2		$82,DTInstallTrap					; OS trap $82 (deferred task)	<C489>
-	OS2		$83,SetOSDefault,hasSlotMgr			; OS trap $83 (which os to use)	<C508>
-	OS2		$84,GetOSDefault,hasSlotMgr			; OS trap $84 (which os to use)	<C508>
-	OS2		$85,PmgrOp,hasPwrControls|PwrMgrADB|hasPwrMgrClock	; OS trap $85
-	OS2		$86,IOPInfoAccess,hasIopScc|hasIopSwim	; OS trap $086					<1.3>
-	OS2		$87,IOPMsgRequest,hasIopScc|hasIopSwim	; OS trap $087					<1.3>
-	OS2		$88,IOPMoveData,hasIopScc|hasIopSwim	; OS trap $088					<1.3>
-	OS2		$89,NewSCSITrap,0					; os trap $89 (async SCSI Mgr)	<v1.7><3.0>
-	OS2		$8A,GoToSleep,hasPwrControls|PwrMgrADB|hasPwrMgrClock	; OS trap $8A
-	OS2		$8B,COMMTOOLBOXDISPATCHER			; os trap $8B (CommToolBoxTrap)		<SM33><PN>
-	OS2		$8C									; os trap $8C (unknown)		<C489><C508><C908><1.5>
-	OS2		$8D,DebugUtil						; os trap $8D					<1.5>
-	OS2		$8E,ExtBTreeDispatch				; os trap $8E (BTreeDispatch)					<2.0>
-	OS2		$8F,NonVMDeferUserFn				; os trap $8F (DeferUserFn)			PN
-	OS2		$90,SysEnvironsTrap					; OS trap $90					<C982>
-	OS2		$91,Translate24To32					; os trap $91 (unknown)			<2.9> BAL
-	OS2		$92,EgretDispatch,hasEgret			; os trap $92					<4>
-	OS2		$93,__Microseconds					; os trap $93					<9>
-	OS2		$94									; os trap $94 (unknown)
-	OS2		$95									; os trap $95 (unknown)
-	OS2		$96									; os trap $96 (unknown)
-	OS2		$97									; os trap $97 (unknown)
-	OS2		$98,HwPriv,Cpu≥020					; OS trap $98					<1.6>
-	OS2		$99									; os trap $99 (unknown)
-	OS2		$9A,ProcHelper						; os trap $9A ProcHelper		<19> rb
-	OS2		$9B									; os trap $9B (unknown)
-	OS2		$9C									; os trap $9C (unknown)
-	OS2		$9D,Fig_MoveHLow					; os trap $9D MoveHLow			<SM18> tcn
-	OS2		$9E,PowerMgrDispatch,hasPwrControls	; os trap $9E (PowerMgrDispatch Trap)	<K2>
-	OS2		$9F,PowerDispatch,hasPwrControls	; os trap $9F (PwrControls Traps)	<17> rb
-	OS2		$A0									; os trap $A0 (unknown)
-	OS2		$A1									; os trap $A1 (unknown)
-	OS2		$A2									; os trap $A2 (unknown)
-	OS2		$A3									; os trap $A3 (unknown)
-	OS2		$A4,HeapDispatch					; os trap $A4 (unknown)
-	OS2		$A5,VisRgnChanged					; os trap $A5 <26MAR90 KON>
-	OS2		$A6,vRMgrStdEntry					; vector  $A6 (StdEntry in rmgr)<3.2>
-	OS2		$A7,vRMgrStdExit					; vector  $A7 (StdExit in rmgr)	<3.2>
-	OS2		$A8									; os trap $A8 (unknown)
-	OS2		$A9									; os trap $A9 (unknown)
-	OS2		$AA									; os trap $AA (unknown)
-	OS2		$AB									; os trap $AB (unknown)
-	OS2		$AC									; os trap $AC (unknown)
-	OS2		$AD,GestaltTrap						; os trap $AD (Gestalt)			<1.9>
-	OS2		$AE									; os trap $AE (unknown)
-
-;------------------------------------------------------------------------------
-; end of OS traps, start of vectors
-;------------------------------------------------------------------------------
-; WARNING -- DO NOT CHANGE THIS TABLE UNLESS YOU CHANGE THE CORRESPONDING OS TABLE! (ABOVE)
-;------------------------------------------------------------------------------
-
-	OS2		$AF,vMtCheck						; vector $AF (HFS)				<C828>
-	OS2		$B0,vCheckReMount					; vector $B0 (HFS)				<C828>
-	OS2		$B1,vDtrmV2							; vector $B1 (HFS)				<C828>
-	OS2		$B2,vFindDrive						; vector $B2 (HFS)				<C828>
-	OS2		$B3,vFClose							; vector $B3 (HFS)				<C828>
-	OS2		$B4,vFlushMDB						; vector $B4 (HFS)				<C828>
-	OS2		$B5,vGoDriver						; vector $B5 (iocore)			<C811>
-	OS2		$B6,vWaitUntil						; vector $B6 (iocore)			<C811>
-	OS2		$B7,vSyncWait						; vector $B7 (iocore)			<C811>
-
-	OS2		$B8,__SNDAPPDEAD					; vector $B8
-	OS2		$B9,vDisPtch						; vector $B9 (deferred task)	<C811><2.2>
-	OS2		$BA,vIAZInit						; vector $BA					<16jun87 CSL>
-	OS2		$BB,vIAZPostInit					; vector $BB					<16jun87 CSL>
-	OS2		$BC,vLaunchInit						; vector $BC					<16jun87 CSL>
-	OS2		$BD,vCacheFlush						; vector $BD					<C668><1.2>
-	OS2		$BE,AsyncPatch						; vector $BE					<A368>
-	OS2		$BF,vLg2Phys						; vector $BF
-	OS2		$C0,vFLushCache						; vector $C0
-	OS2		$C1,vGetBlock						; vector $C1
-	OS2		$C2,vMarkBlock						; vector $C2
-	OS2		$C3,vRelBlock						; vector $C3
-	OS2		$C4,vTrashBlocks					; vector $C4
-	OS2		$C5,vTrashVBlks						; vector $C5
-	OS2		$C6,vCacheWrIP						; vector $C6
-	OS2		$C7,vCacheRdIP						; vector $C7
-	OS2		$C8,vBasicIO						; vector $C8
-	OS2		$C9,vRdBlocks						; vector $C9
-	OS2		$CA,vWrBlocks						; vector $CA
-	OS2		$CB,vSetUpTags						; vector $CB
-	OS2		$CC,vBTClose						; vector $CC
-	OS2		$CD,vBTDelete						; vector $CD
-	OS2		$CE,vBTFlush						; vector $CE
-	OS2		$CF,vBTGetRecord					; vector $CF
-	OS2		$D0,VBTINSERT						; vector $D0
-	OS2		$D1,vBTOpen							; vector $D1
-	OS2		$D2,vBTSEARCH						; vector $D2
-	OS2		$D3,vBTUpdate						; vector $D3
-	OS2		$D4,vGetNode						; vector $D4
-	OS2		$D5,vRelNode						; vector $D5
-	OS2		$D6,vAllocNode						; vector $D6
-	OS2		$D7,vFreeNode						; vector $D7
-	OS2		$D8,vExtBTFile						; vector $D8
-	OS2		$D9,vDeallocFile					; vector $D9
-	OS2		$DA,vExtendFile						; vector $DA
-	OS2		$DB,vTruncateFile					; vector $DB
-	OS2		$DC,vCMSetUp						; vector $DC
-	OS2		$DD,vppcDispatcher					; vector $DD (PPCDispatcher)
-	OS2		$DE,vDtrmV1							; vector $DE
-	OS2		$DF,vBlkAlloc						; vector $DF
-	OS2		$E0,vBlkDeAlloc						; vector $E0
-	OS2		$E1,vFileOpen						; vector $E1
-	OS2		$E2,vPermssnChk						; vector $E2
-	OS2		$E3,vFndFilName						; vector $E3
-	OS2		$E4,vRfNCall						; vector $E4
-	OS2		$E5,vAdjEOF							; vector $E5
-	OS2		$E6,vPixel2Char						; vector $E6	<C146>
-	OS2		$E7,vChar2Pixel						; vector $E7	<C146>
-	OS2		$E8									; vector $E8 (unknown)
-	OS2		$E9,vFileClose						; vector $E9 (dnf v2.6)
-	OS2		$EA,vFileRead						; vector $EA (dnf v2.6)
-	OS2		$EB,vFileWrite						; vector $EB (dnf v2.6)
-	OS2		$EC,DispatchHelper					; OS Trap $EC DispatchHelper	<19> rb
-	OS2		$ED,VUPDALTMDB						; vector $ED	<3.1>
-	OS2		$EE,vCkExtFS						; vector $EE	<A281>
-	OS2		$EF,vDTrmV3							; vector $EF	<A281>
-	OS2		$F0,vBMChk							; vector $F0	<A281>
-	OS2		$F1,vTstMod							; vector $F1	<A281>
-	OS2		$F2,vLocCRec						; vector $F2	<A281>
-	OS2		$F3,vTreeSearch						; vector $F3	<A281>
-	OS2		$F4,vMapFBlock						; vector $F4	<A281>
-	OS2		$F5,vXFSearch						; vector $F5	<A281>
-	OS2		$F6,vReadBM							; vector $F6	<A281>
-	OS2		$F7,vDoEject						; vector $F7
-	OS2		$F8,vSegStack						; vector $F8
-	OS2		$F9,vSuperLoad						; vector $F9
-	OS2		$FA,vCmpFrm							; vector $FA
-	OS2		$FB,vNewMap							; vector $FB
-	OS2		$FC,vCheckLoad						; vector $FC
-	OS2		$FD,XTrimMeasure					; vector $FD
-	OS2		$FE,XFindWord						; vector $FE
-	OS2		$FF,XFindLine						; vector $FF
-
-;------------------------------------------------------------------------------
-; <SM46> BT: End second OS table macro
-;------------------------------------------------------------------------------
-	endif
-
 	END
 
diff --git a/OS/EgretMgr.a b/OS/EgretMgr.a
--- a/OS/EgretMgr.a
+++ b/OS/EgretMgr.a
@@ -243,7 +243,7 @@ ErrEgretInit	equ		$0030			; TEMPORARY definition of error equate defined in STEQ
 ;	Destroys:	a0-a2, d0-d2
 ;________________________________________________________________________________________________
 InitEgretOrCuda
-			moveq.l #EgretGlobSize,D0			; get size of globals
+			move.l	#EgretGlobSize,D0			; get size of globals
 			_NewPtr ,SYS,CLEAR					; allocate space on heap and clear
 
 			move.l	a0,EgretBase				; save ptr to it
@@ -262,13 +262,13 @@ InitEgretOrCuda
 			move.l	a1,tickComp(a2)				; set up default tick packet handler
 			
 			movea.l	VIA,a1						; point to the VIA
-		eieioSTP
 			bclr.b	#SRdir,vACR(a1)				; shift reg direction = input
 		eieioSTP
 			move.b	#(1<<ifIRQ)|\
 						(1<<ifSR),vIER(a1)		; enable shift register interrupts
 		eieioSTP
 			move.w	(sp)+,sr					; restore interrupts
+			bsr		TweakUnknownPramVal
 			rts
 
 
@@ -320,12 +320,9 @@ EgretDispatch
 	
 			move.w	sr,-(sp)					; save SR
  			ori.w	#hiIntMask,sr				; mask interrupts
-		eieioSTP
 			btst.b	#xcvrSes,vBufB(a1)			; does Egret want to abort?
-		eieioSTP
 			beq.s	@abort						; yes, wait for it to go away
 			bset.b	#busy,flags(a2)				; not an abort, mark that we're busy.
-		eieioSTP
 			beq.s	@sendPackType				; we were not busy before, so try to send the first byte
 
 @abort		move.w	(sp)+,sr					; we were busy, enable interrupts
@@ -334,7 +331,6 @@ EgretDispatch
 			bra.s	@EgretRestart				; and keep waiting for busy to go away...
 
 @sendPackType									; interrupts masked here
-		eieioSTP
 			bset.b	#sysSes,vBufB(a1)			; assert System Session (we're starting command packet)
 		eieioSTP
 			bset.b	#SRdir,vACR(a1)				; switch to output
@@ -356,13 +352,11 @@ EgretDispatch
 ;		When the shift register irq comes in call the PollProc
 ;		then process the shift register irq data
 ;
-			movem.l	d0/d1/a0-a4/a6,-(sp)		; save some registers
+			movem.l	d0-d3/a0-a4/a6,-(sp)		; save some registers
 
 			move.l	sp,PollStack				; Pointer to buffer for polled bytes
 
-		eieioSTP
 			btst.b	#0,SccIopFlag				; Check if we are in IOP mode (On Eclipse...)
-		eieioSTP
 			beq.s	@NoPollWait					; If IOP then we don't need to poll
 
 			tst.l	PollProc					; Check for a Poll Proc available
@@ -374,16 +368,12 @@ EgretDispatch
 			addq.l	#AData,a6					; Point to the SCC data register
 
 @wait
-		eieioSTP
 			btst.b	#RxCa,(a3)					; Test for SCC data available
-		eieioSTP
 			beq.s	@2
 			move.b	(a6),-(sp)					; Push the data on the stack
 @2			
-		eieioSTP
 			btst.b	#vShift,vIFR(a1)			; now wait for shift reg IRQ
 
-		eieioSTP
 			beq.s	@wait
 
 			cmpa.l	PollStack,SP				; Is there any poll data
@@ -397,25 +387,20 @@ EgretDispatch
 
 
 @NoPollWait
-		eieioSTP
 			btst.b	#vShift,vIFR(a1)			; now wait for shift reg IRQ
-		eieioSTP
 
 			beq.s	@NoPollWait
 
-@NoSCCData	movem.l	(sp)+,d0/d1/a0-a4/a6		; restore work registers
+@NoSCCData	movem.l	(sp)+,d0-d3/a0-a4/a6		; restore work registers
 
 @VsrIrq
-		eieioSTP
 			btst.b	#xcvrSes,vBufB(a1)			; did Egret abort?
-		eieioSTP
 			bne.s	@accepted					; no, then it will accept our packet
 			bclr.b	#SRdir,vACR(a1)				; yes, switch back to input
 		eieioSTP
 			bclr.b	#sysSes,vBufB(a1)			; ack the abort
 		eieioSTP
 			bsr		CallShiftRegIRQ				; handle it
-		eieioSTP
 			bra.s	@abort						; and wait
 
 ;<SM4><SES> end of EgretDispatch SCC poll fix
@@ -424,15 +409,12 @@ EgretDispatch
 			jsr		SetTransferParams			; setup globals for this packet
 			bsr		CallShiftRegIRQ				; transfer second byte (command) to start things
 			move.w	(sp)+,sr					; now enable interrupts
-		eieioSTP
 
 			tst.l	pbCompletion(a0)			; do we have a completion routine
-		eieioSTP
 			bne.s	@done						; yes, then return asynchronously
 
 @waitComplete
 			btst.b	#busy,flags(a2)				; otherwise, are we still busy?
-		eieioSTP
 			beq.s	@done						; no, then we're done...
 			
 			bsr.s	pollByte					; yes, poll out a byte if necessary	
@@ -507,9 +489,7 @@ PollByte
 			move.w	sr,d0						; get 68xxx interrupt mask
 			andi.w	#hiIntMask,d0				; are we at interrupt level?
 			beq.s	@exit						; no, just exit
-		eieioSTP
 			btst.b	#vShift,vIFR(a1)			; yes, poll the shift reg
-		eieioSTP
 			beq.s	@exit						; no shift reg interrupt, return
 			bsr.s	CallShiftRegIRQ				; yes, handle it
 @exit		rts
@@ -529,11 +509,9 @@ PollByte
 ;	Destroys:	d1
 ;________________________________________________________________________________________________
 SendByte
-		eieioSTP
 			bclr.b	#viaFull,vBufB(a1)			; negate via full
 		eieioSTP
 			bsr.s	Delay100					; give Egret time to see it
-		eieioSTP
 			move.b	d0,vSR(a1)					; send the byte to the shift reg
 		eieioSTP
 			bset.b	#viaFull,vBufB(a1)			; let Egret know it's there
@@ -550,13 +528,35 @@ CallShiftRegIRQ
 
 ;________________________________________________________________________________________________
 viaFullAck
-		eieioSTP
 			bset.b	#viaFull,vBufB(a1)			; acknowlege the byte
 		eieioSTP
 			bsr.s	Delay100					; give Egret time to see it
-		eieioSTP
 			rts									; gets cleared on exit from IRQ handler
 
+;________________________________________________________________________________________________
+DelayAndPollSCC
+			tst.l	PollProc					; Check for a Poll Proc available
+			beq.s	Delay100					; If no Poll Proc then just wait 100us
+			btst.b	#0,SccIopFlag				; Check if we are in IOP mode
+			beq.s	Delay100					; If IOP then just wait 100us
+
+			movem.l	d0-d3/a0-a4/a6,-(sp)		; do some hacky new stuff
+			move.l	sp,PollStack				; save a stack ptr to detect pushes
+			move.l	SccRd,a3					; a3 is SCC base register
+			move	TimeSCCDB, d1				; num iters of (SCC access + DBRA) in 1ms
+			lsr		#3,d1						; x8 -> pull bytes from SCC for 8ms
+@poll		btst.b	#RxCA, aCtl(a3)				; POLL: SCC data available?
+			beq.b	@next
+			move.b	aData(a3),-(sp)				; yes -> push it to stack
+@next		dbra	d1,@poll
+		eieioSTP
+			cmp.l	PollStack,sp				; done polling, any data on our stack?
+			beq.b	@return						; no -> return
+			lea.l	aData(a3), a6
+			jsr		([PollProc])				; yes -> call the PollProc
+@return		movem.l	(sp)+,d0-d3/a0-a4/a6
+			rts
+
 ;________________________________________________________________________________________________
 Delay100
 			move.l	d1,-(sp)					; save d1
@@ -566,12 +566,9 @@ Delay100
 		;	bne.s	@loop						; no ? then skip			<60> rb
 			add.w	#EclipseDelay,d1			; <60> rb, we need an extra 25 usecs on Eclipse <GAA Eclipse>
 @loop
-		eieioSTP
 			tst.b	(a1)						; access the VIA
-		eieioSTP
 			dbra	d1,@loop
 			move.l	(sp)+,d1					; restore d1
-		eieioSTP
 			rts
 
 ;________________________________________________________________________________________________
@@ -595,7 +592,6 @@ ShiftRegIRQ
 			ori.w	#hiIntMask,sr				; mask interrupts <13>
 			movea.l	EgretBase,a2				; get ptr to globals <13>
 			bset.b	#busy,flags(a2)				; make sure we're marked as busy
-		eieioSTP
 
 			btst.b	#SRdir,vACR(a1)				; see if VIA direction is output
 		eieioSTP
@@ -624,11 +620,10 @@ ShiftRegIRQ
 			move.w	d3,sr						; restore interrupts							<SM5><SES>
 			bra		@exit						; and exit
 @CmdFinished
-		eieioSTP
 
 			bclr.b	#SRdir,vACR(a1)				; now switch to input
+			eieioSTP
 @sendCmd
-		eieioSTP
 			andi.b	#~((1<<viaFull) | \			; negate VIA full bit
 					   (1<<sysSes)),vBufB(a1)	; negate System Session
 		eieioSTP
@@ -637,16 +632,13 @@ ShiftRegIRQ
 			bra		@exit						; and exit
 
 @input		;-----------------------------------------------------------------------------
-		eieioSTP
 			move.b	vSR(a1),d0					; read the byte from shift reg into D0
 		eieioSTP
 			tst.w	rcvHdrCnt(a2)				; any bytes left in response packet header?
 			ble.s	@ckRcvData					; if not then must be data byte
 
 @getHdrByte	
-		eieioSTP
 			btst.b	#sysSes,vBufB(a1)			; is System Session asserted?
-		eieioSTP
 			bne.s	@notFirst					; yes, then this is not the first byte
 			bsr.s	Delay100					; delay 100us
 			bra.s	@stuff
@@ -658,9 +650,7 @@ ShiftRegIRQ
 			addq.w	#1,rcvHdrIndex(a2)			; bump to next byte
 			subq.w	#1,rcvHdrCnt(a2)			; count it
 			ble.s	@CheckError					;  <12>
-		eieioSTP
 			btst.b	#xcvrSes,vBufB(a1)			; is Egret done?
-		eieioSTP
 			bne.s	@done						; yes, we're through...
 			bset.b	#sysSes,vBufB(a1)			; make sure System Session is asserted			<5>
 		eieioSTP
@@ -674,15 +664,12 @@ ShiftRegIRQ
 			bgt.s	@ack						; not last, normal acknowlege
 			btst.b	#openData,flags(a2)			; is this an open ended data packet?
 
-		eieioSTP		
 			beq.s	@ack						; no, normal acknowlege
 			bsr.s	viaFullAck					; acknowlege the byte using via full <8>
-		eieioSTP
 			bclr.b	#sysSes,vBufB(a1)			; yes, let Egret know we don't want more <8>
+			eieioSTP
 @wait
-		eieioSTP
 			btst.b	#xcvrSes,vBufB(a1)			; wait for egret to acknowledge termination <8>
-		eieioSTP
 			beq.s	@wait						; branch until xcvr session goes high <8>
 			bra.s	@done						; and we're done
 
@@ -706,26 +693,22 @@ ShiftRegIRQ
 ;
 @ack		bsr.s	viaFullAck					; normal byte, acknowlege it
 @checkDone	
-		eieioSTP
 			btst.b	#xcvrSes,vBufB(a1)			; was that Egrets last byte?
-		eieioSTP
 			bne.s	@done						; yes, we're through...
 			tst.w	rcvDataCnt(a2)				; any receive data bytes to get?
 			bgt		@exitRd						; yes, then just exit
 
 			;---------------------------------------------------------------------------
 @done	
-		eieioSTP
 			bclr.b	#viaFull,vBufB(a1)			; make sure via full is low
 		eieioSTP
 			bclr.b	#sysSes,vBufB(a1)			; let Egret know we're done
 		eieioSTP
-			bsr		delay100					; Give Egret time to see transitions & Poll SCC <13>
+			bsr		DelayAndPollSCC				; Give Egret time to see transitions & Poll SCC <13>
 
 			movea.l	curPb(a2),a0				; a0 points to current param block
 			lea		rcvHeader(a2),a1			; a1 points to header buffer <11>
 			cmp.b	#ErrorPkt,1(a1)				; check for Error response packet <11>
-		eieioSTP
 			bne.s	@NotError
 ;
 ;		The current transaction generated an Error <11>
@@ -744,12 +727,10 @@ ShiftRegIRQ
 			cmpa.l	adbPb(a2),a0				; is this autopoll data
 			bne.s	@skip						; no, don't fix ray's flag
 			bset.b	#EgAutoPoll,2(a1)			; yes, fix em
-		eieioSTP
 @skip
 		ENDIF
 
 			btst.b	#EgAutoPoll,2(a1)			; check status, is this AutoPoll data?
-		eieioSTP
 			bne		@ckAutoPollComp				; yes, handle if we have completion routine
 
 			move.b	2(a1),pbFlags(a0)			; explicit ADB command, stuff flags byte
@@ -761,7 +742,6 @@ ShiftRegIRQ
 			addq.w	#4,a1						; point at the data
 			bra.s	@cnt
 @xfer		move.b	(a1)+,(a2)+					; copy the byte
-		eieioSTP
 @cnt		dbra	d0,@xfer					; repeat for all bytes
 
 			move.l	EgretBase,a2				; get globals ptr again
@@ -862,7 +842,6 @@ ShiftRegIRQ
 			bra.s	@exit						; and exit
 
 @exitRd	
-		eieioSTP
 			bclr.b	#viaFull,vBufB(a1)			; make sure via full is low
 		eieioSTP
 			move.w	d3,sr						; restore interrupts							<SM5><SES>
@@ -887,7 +866,6 @@ SetTransferParams
 			move.l	a1,-(sp)						; save a1
 			lea		pbCmd(a0),a1
 			move.l	a1,sendHdrPtr(a2)				; point to 1st byte of header to send
-	eieioSTP
 			moveq	#0,d0
 			move.b	pbCmd(a0),d0					; get command
 
@@ -910,13 +888,9 @@ SetTransferParams
 			move.w	pbByteCnt(a0),d1				; was Write DFAC use the byte count in the pBlock <12>
 			addq.w	#1,d1							; include the packet byte already sent <12>
 			move.w	d1,sendHdrCnt(a2)				; set up header byte count <12>
-	eieioSTP
 			move.w	#0,sendDataCnt(a2)				; do not send the bytes as data also <12>
-	eieioSTP
 			clr.w	sendDataCnt(a2)					; no extended data bytes <12>
-	eieioSTP
 			clr.l	sendDataPtr(a2)					; no extended data ptr <12>
-	eieioSTP
 			bra.s	@rcvParams
 
 @notDFAC	lea		PseudoCntTable,a1				; get ptr to our pseudo command table
@@ -930,27 +904,19 @@ SetTransferParams
 			ext.w	d0								; extend to word
 			addq.b	#1,d0							; data bytes + 1 = header byte count
 			move.w	d0,sendHdrCnt(a2)				; set up header byte count
-	eieioSTP
 			clr.w	sendDataCnt(a2)					; no extended data bytes
-	eieioSTP
 			clr.l	sendDataPtr(a2)					; no extended data ptr
-	eieioSTP
 			bra.s	@rcvParams						; now setup receive ptrs
 
 @sendExt	moveq	#$7F,d0							; prepare to mask sign
 			and.w	d1,d0							; get rid of sign
 			addq.w	#1,d0							; + 1 for command (packet type already sent)
 			move.w	d0,sendHdrCnt(a2)				; set up header byte count
-	eieioSTP
 			move.w	pbByteCnt(a0),sendDataCnt(a2)	; set up data byte count
-	eieioSTP
 			move.l	pbBufPtr(a0),sendDataPtr(a2)	; set up send data ptr
-	eieioSTP
 
 @rcvParams	clr.w	rcvHdrIndex(a2)					; reset index into header buffer
-	eieioSTP
 			move.w	#4,rcvHdrCnt(a2)				; 4 byte header default
-	eieioSTP
 			asr.w	#8,d1							; get receive data byte count
 			bmi.s	@rcvExt							; branch for open-ended reads
 
@@ -958,28 +924,20 @@ SetTransferParams
 			beq.s	@rcvADB							; no, must be adb data
 
 			lea		pbParam(a0),a1					; pseudo data will be received in pbParam
-	eieioSTP
 			move.l	a1,rcvDataPtr(a2)
-	eieioSTP
 			move.w	d1,rcvDataCnt(a2)				; get receive count from table
-	eieioSTP
 			bra.s	@exit							; and exit
 
 @rcvADB		add.w	d1,rcvHdrCnt(a2)				; total header bytes = 4 + ADB data
-	eieioSTP
 			clr.w	rcvDataCnt(a2)					; not used
-	eieioSTP
 			bclr.b	#openData,flags(a2)				; this is not an open ended data packet (readPram, read6805)
 			bra.s	@exit
 
 @rcvExt		move.w	pbByteCnt(a0),rcvDataCnt(a2)	; set up received data byte count
-	eieioSTP
 			move.l	pbBufPtr(a0),rcvDataPtr(a2)		; set up received data buffer ptr
-	eieioSTP
 			bset.b	#openData,flags(a2)				; this is an open ended data packet (readPram, read6805)
 
 @exit		move.l	a0,curPb(a2)					; set up current param block
-	eieioSTP
 			movea.l	(sp)+,a1						; restore a1
 			rts
 
@@ -1132,6 +1090,8 @@ PseudoCntTable
 			dc.b	$00,	$00			; 22 RdWrIIC			send n bytes, 	receive n data bytes	<S2> [rbm]
 			dc.b	$01,	$00			; 23 Set WakeUpMode		send 1 bytes, 	receive 0 data bytes	<T2><SM7> rb
 			dc.b	$01,	$00			; 24 Tickle PDM Timer	send 1 bytes, 	receive 0 data bytes	<T2><SM7> rb
+			dc.b	$00,	$00
+			dc.b	$01,	$00
 
 
 ADBCntTable
@@ -1158,806 +1118,71 @@ ADBCntTable
 
 
 			Eject
-;=========================================================================
-; Routines: 	EgretInit
+;--------------------------------------------------------------------------
+;ChkFirmware																		<P2>
 ;
-; This routine sends a NOP/WarmStart command to Egret.  This routine is
-; called early during rom Startup to stop autopoll and 1 sec irq.  Also,
-; the routine will issue a Send DFAC command to Egret to initialize the
-; the DFAC hardware to a known state.  The routine does not use ANY
-; memory it is register driven only.
-;
-; NOTE:	This routine actually sends a STOP AUTO POLL, SET ONE SECOND
-;		INTERRUPT MODE 0 call and a SEND DFAC command to Egret.
-;		The Stop Autopoll and set one second interrupt modes calls will
-;		be changed to a single NOP/WarmStart when Egret 3 becomes
-;		available (S/B 4/6/90).
-;
-; Inputs:	NONE
-;
-; Outputs:	NONE
-;
-; Destroys:	D0, D1, D2, D3, A1, A5, A6, A4	(Egret 2 implementation)
-; Destroys:	D0, D3, A1, A5, A6				(Egret 3 implementation)
-;
-;	NOTE: This routine is called via a BSR6 and returns via a RTS6
+;	This routine will determine if the Egret Chip is using Egret 8 or Caboose
+;	firmware or the new Cuda firmware.  Based on this result, the IRQ handler,
+;	Dispatcher, and Tick handler vectors are set up...
+;	Inputs:
+;		A2	->	EgretGlobals
+;	Outputs:
+;		A0 	->	ShiftRegIRQ	
+;		A1	->	TickHandler
+;	Trashes:
+;		A0,A1
+
+			
+ChkFirmware											;								<P2>
+			movem.l	a2/d0-d2, -(sp)					; preserve used regs
+
+@haveCuda											;								
+			biglea	CudaDispatch, a0				; Cuda FW dispatcher			
+			move.l	#$92,d0							; set $92 trap					
+			_SetTrapAddress	,NEWOS
+			
+			biglea 	CudaShiftRegIRQ,a0				; stuff Cuda IRQ handler in	
+			biglea	CudaTickHandler,a1				; stuff Cuda tick handler in
+
+@chkDone
+			movem.l	(sp)+, a2/d0-d2					; restore used regs
+			rts
+			
+
+
 ;-------------------------------------------------------------------------
-			EXPORT	EgretInit
-
-EgretInit	movea.l	DecoderInfo.VIA1Addr(a0),a1		; get VIA 1 base address
-		eieioSTP
-			bclr.b	#vSyssesbit,vBufB(a1)	; kill any pending transactions <8> <13>
-		eieioSTP
-			bclr.b	#vViafullbit,vBufB(a1)	; <8> <13>
-		eieioSTP
-			moveq	#$28,d0					; we want to delay 4 millisecs
-@killtime	bsr5	delay100us				; in 100 usec increments
-			dbra	d0,@killtime
-			move.l	a6,a4					; save the return address
-
-		if		rayFix	then
-;
-;	Send the Stop autopoll pseudo command
-;
-			move.l	#(APoll << 16) + PseudoPkt,d0	; first command to send is Stop Auto Poll
-			moveq	#0,d1					; sending one byte of data $00 = stop autopoll
-			moveq	#1,d2
-			bsr6	SendEgretCmd			; send the command to Egret
-			tst.w	d0						; check for an error
-			bne.s	@exit					; failed to send the command (hang timeout expired)
-;
-;	Send the mode 0 1 second interrupt pseudo command
-;
-			move.l	#(Wr1SecMode << 16) + PseudoPkt,d0	 ; mode 0 1 sec interrupts (stop 1 second irq)
-			moveq	#0,d1					; sending one byte of data
-			moveq	#1,d2
-			bsr6	SendEgretCmd			; send the command to Egret
-			tst.w	d0						; negative if error
-			bne.s	@exit					; failed to send the command (hang timeout expired)
-
-		else
-;
-;	Send the NOP/WarmStart command
-;
-			move.w	#NopCmd,d0				; Nop/WarmStart stops autopoll and 1 sec irq
-			swap	d0						; packet type Pseudo
-			move.w	#pseudopkt,d0
-			moveq	#0,d2					; no data to send
-			bsr6	SendEgretCmd			; send the command to Egret
-			tst.w	d0						; nonzero if error
-			bne.s	@exit					; failed to send the command (hang timeout expired)
-
-		endif
-
-;
-;	Send Elsie/Erickson initial DFAC setting
-;
-		with	ProductInfo
-
-			moveq	#0,d2						; force full scan of hardware features <10>
-			bsr6	GetHardwareInfo				; get the ProductInfo Record <9>
-			btst.b	#v8chipbit,ExtValid+3(a1)	; See if system has a VISA chip (bit7)<9><10>
-			beq.s	@Erickson					; 0 = No Visa (Erickson) 1 = Visa (Elsie) <9>
-
-			move.l	#ElsieDFAC,d1				; Assume running on Erickson (Not Elsie) <9>
-			bra.s	@sendit
-
-@Erickson	move.l	#EricksonDFAC,d1				; Erickson DFAC setting <9>
-@sendit		move.l	#(WrDFAC << 16) + PseudoPkt,d0	; Send DFAC command
-			moveq	#1,d2							; One byte to send
-			bsr6	SendEgretCmd					; send the command to Egret
-			tst.w	d0								; negative if error
-@exit		move.l	a4,a6							; restore return address
-			rts6									; return to the caller
-
-			endwith
-
-				eject
-************************************************************************************************************
-* SendEgretCmd:	This register based routine will send up to four bytes of data to Egret.  The
-*				packet type, command, byte count and data are passed in registers.  The routine
-*				will return with d0.w = $0000 if it sent the command successfully.  A value of
-*				$FFFF signifies that the command did not get through.  The system and Egret hung
-*				and the system aborted the transaction.
-*
-*	WARNING:	This routine will not error check the transaction requested.  It is  the responsibility of
-*	WARNING:	the caller to make sure that the packet type, command, data and data byte count are valid
-*	WARNING:	for the transaction requested.  Failure to follow the rules will make this routine fail and
-*	WARNING:	CRASH the system.
-*
-*		Input:
-*				a0.l	Pointer to Base address table
-*
-*				d0.l =  High word PACKET Command
-*						Low word PACKET Type
-*
-*				d1.l =	Up to four bytes of data to send
-*						Long word data byte assigment = byte 4, byte 3, byte 2, byte 1
-*						Byte 1 sent out first
-*
-*				d2.l = 	Byte count to send. (0-4 bytes)
-*						Byte count > 4 will send four bytes only
-*
-*		Output:	d0.w	$0000 if call succeeded, Nonzero if failed
-*
-*				d1.l	high word = flags, low word packet type returned by Egret
-*
-*		Destroys:	D2.l, D3.l, D4.l, A5.l, A4.l, A1.l
-*
-************************************************************************************************************
-
-			Export	SendEgretCmd
-SendEgretCmd
-			movea.l	DecoderInfo.VIA1Addr(a0),a1			; get VIA 1 base address				<P2> <SM7> rb, start
-			move.l	#((MaxTout<<16) OR MaxRetries),d4	; number of retries before giving up with Egret <13>
-			bsr5	Delay100us
-		eieioSTP
-			btst.b	#vsysSesBit,vBufB(a1)	; check for a transaction in progress
-		eieioSTP
-			beq.s	@AllOK
-
-@Timeout
-		eieioSTP
-			bclr.b	#vsysSesBit,vBufB(a1)	; kill the rest of the transaction <8>
-		eieioSTP
-			bclr.b	#vViaFullBit,vBufB(a1)	; <8>
-		eieioSTP
-			bsr5	Delay100us				; in progretss <8>
-  			bsr5	Delay100us				; <8>
-
-@AllOK		swap.w	d4						; timeout in low word of d4 Retry count in high word <13>
-		eieioSTP
-			btst.b	#vxcvrSesBit,vBufB(a1)	; check for abort pending
-		eieioSTP
-			beq		IrqMissed				; MIssed Vsr Irq because of INITVIAS
-			bset	#vsysSesBit,vBufB(a1)	; assert sysSesBit
-		eieioSTP
-			bsr5	@SendPtype				; send the packet type
-			beq		RealAbort				; Discard Aborting transaction					<SM7> rb, end
-;
-;	If not abort transaction in progress then send the command byte
-;
-			swap	d0
-			bsr5	sendByte1				; send the command byte
-			bsr5	delay100us				; give Egret time to see viaEmpty
-;
-;	Now send number of bytes contained in d1 based on
-;	byte count contained in d2.w
-;
-			move.l	d1,d0					; get the data to send
-			subq	#1,d2					; adjust for DBRA
-			cmp.w	#3,d2					; if count out of range quit
-			bhi.s	@EndCmd					; if count valid then adjust for dbra
-@sendloop	bsr5	sendByte1
-			bsr5	delay100us
-			lsr.l	#8,d0					; move data byte to low byte of register
-@loopEntry	dbra	d2,@sendloop			; decrement byte count
-;
-;	Wait for the response packet header
-;
-@EndCmd		
-		eieioSTP
-			bclr.b	#SRdir,vACR(a1)			; shift in
-		eieioSTP
-			bclr.b	#vSyssesbit,vBufB(a1)	; negate vSyssesbit
-		eieioSTP
-			bsr5	Delay100us
-;
-;	Now receive the Standard Response packet Header
-;
-			bsr5	readAttn				; get the Attention byte
-		eieioSTP
-			bsr5	Delay100us
-		eieioSTP
-			bset.b	#vSyssesbit,vBufB(a1)	; assert vSyssesbit
-		eieioSTP
-			bsr5	readByte				; get the packet type
-			and		#$00FF,d0				; keep low byte only
-			swap	d0						; save the packet type
-			bsr5	readByte				; get the flags byte
-			and.w	#$00FF,d0				; keep low byte only
-			swap	d0						; keep the flags byte as an error code
-			exg		d0,d1					; save the packet type and flags returned
-			bsr5	readByte				; get the command
-		eieioSTP
-			bclr.b	#vSyssesbit,vBufB(a1)	; negate vSyssesbit
-		eieioSTP
-			bsr5	Delay100us
-;
-;	Check for an error packet returned by Egret
-;
-			move.l	d1,d0					; save the packet type and flags
-			cmp.b	#errorpkt,d0			; check for error packet
-			beq.s	@Exit					; error pkt then just exit
-			sub.w	d0,d0					; zero for success
-@exit		rts6
-
-;--------------------------------------------------------------------------
-@SendPtype									;												<2>
-		eieioSTP
-			bset.b	#SRdir,vACR(a1)			; shift out
-		eieioSTP
-			btst.b	#vXcvrsesbit,vbufB(a1)	; check for abort
-		eieioSTP
-			beq.s	@AbortReq				; go away if abort requested
-			move.b	d0,vSR(a1)				; load byte into shift reg
-		eieioSTP
-			bset.b	#vViafullbit,vBufB(a1)	; indicate shift reg is full
-		eieioSTP
-;
-;	Check Vsr Irq until timeout.  If timeout then check the retry count
-;	and Call Death Chimes if Retry count exausted.
-;
-@PollDelay		
-		eieioSTP
-			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
-			bne.s	@VsrIrq					; Go service Shift register Irq <13>
-			dbra.w	d4,@PollDelay			; try again if timed out <13><SM7> rb
-			move.w	#MaxTout,d4				; Reset the Timeout <13><SM7> rb
-			swap.w	d4						; get the Retry count <13><SM7> rb
-			subq.w	#1,d4					; Try again if Retry count not Exausted <13><SM7> rb
-			beq.s	@Timeout				; <13>
-
-@DeadEgret	move.w	#ErrEgretInit,d7		; Egret failed <13>
-			move.l	#0001,d6				; d6.l must be nonzero <13>
-			bigjmp	Error1Handler,a3		; Play death chimes <13>
-
-@VsrIrq	
-		eieioSTP
-			tst.b	vSR(a1)					; clear the interrupt
-		eieioSTP
-			bclr.b	#vViafullbit,vBufB(a1)	; now indicate shift reg empty
-		eieioSTP
-;
-;		Delay 100 usec
-;
-			move.w	#DelayCnt,d3
-@wait20		
-		eieioSTP
-			tst.b	(a1)					; sync to VIA clock
-		eieioSTP
-			dbra	d3,@wait20				; delay at least 100 us (very rough)
-		eieioSTP
-			btst.b	#vXcvrsesbit,vbufB(a1)	; check for abort
-		eieioSTP
-@AbortReq	rts5
-
-;--------------------------------------------------------------------------
-; DumpAbort	This routine will read all the data for an abort transaction and
-;			discard it.  When done it will jump back to SendNopCmd entry point
-;			to retry our command.  This command will eventually complete...
-
-RealAbort
-		eieioSTP
-			bclr.b	#vSyssesbit,vBufB(a1)	; deassert system session
-		eieioSTP
-IrqMissed	bsr5	Delay100us				; Let Egret see SysSes. ≥ 125µsec
-		eieioSTP
-			bclr.b	#SRdir,vACR(a1)			; shift in
-		eieioSTP
-			tst.b	vSR(a1)					; discard the byte
-		eieioSTP
-			bset	#vSyssesbit,vBufB(a1)	; assert vSyssesbit
-		eieioSTP
-
-DumpAbort
-
-		eieioSTP
-		bclr	#vViafullbit,vBufB(a1)	; then negate VIA full bit
-		eieioSTP
-
-@loop
-		eieioSTP
-			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
-			beq.s	@loop
-			bset.b	#vViafullbit,vBufB(a1)	; acknowlege byte
-		eieioSTP
-			tst.b	vSR(a1)					; discard the byte
-		eieioSTP
-;
-;		Delay 100 usec
-;
-			move.w	#DelayCnt,d3
-@wait
-		eieioSTP
-			tst.b	(a1)					; sync to VIA clock
-			dbra	d3,@wait				; delay at least 100 us (very rough)
-		eieioSTP
-			btst.b	#vXcvrsesbit,vBufB(a1)	; check for last byte
-		eieioSTP
-			beq.s	DumpAbort				; Clock Tick Packets only 2 bytes
-;
-;		Last byte was read
-;
-			bclr	#vViafullbit,vBufB(a1)	; then negate VIA full bit
-		eieioSTP
-			bclr.b	#vSyssesbit,vBufB(a1)	; negate vSyssesbit
-		eieioSTP
-			bsr5	Delay100us				; delay 200 usec
-			bra.s	SendEgretCmd			; go try sending our command again
-
-;--------------------------------------------------------------------------
-sendByte1									;												<2>
-		eieioSTP
-			bset.b	#SRdir,vACR(a1)			; shift out
-		eieioSTP
-			move.b	d0,vSR(a1)				; load byte into shift reg
-		eieioSTP
-			bset.b	#vViafullbit,vBufB(a1)	; indicate shift reg is full
-		eieioSTP
-@poll	
-		eieioSTP
-			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
-			beq.s	@poll
-			tst.b	vSR(a1)					; clear the interrupt
-		eieioSTP
-			bclr.b	#vViafullbit,vBufB(a1)	; now indicate shift reg empty
-		eieioSTP
-			rts5
-
-;--------------------------------------------------------------------------
-readByte	
-		eieioSTP			
-			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
-			beq.s	readByte
-			bset.b	#vViafullbit,vBufB(a1)	; Tell Egret we saw the byte
-		eieioSTP
-			move.b	vSR(a1),d0				; read the byte
-;
-;		Delay 100 usec
-;
-		eieioSTP
-			move.w	#DelayCnt,d3
-@wait
-		eieioSTP
-			tst.b	(a1)					; sync to VIA clock
-		eieioSTP
-			dbra	d3,@wait				; delay at least 100 us (very rough)
-		eieioSTP
-			bclr	#vViafullbit,vBufB(a1)	; then negate VIA full bit
-		eieioSTP
-			rts5
-
-;--------------------------------------------------------------------------
-readAttn
-		eieioSTP
-
-			btst.b	#ifSR,vIFR(a1)			; wait for shift to complete
-		eieioSTP
-			beq.s	readAttn
-		eieioSTP
-			tst.b	vSR(a1)					; clear the interrupt
-		eieioSTP
-			rts5
-
-;--------------------------------------------------------------------------
-delay100us	
-		move.w	#DelayCnt,d3
-;	add.w	d3,d3						; let's make it even rougher
-@wait
-		eieioSTP
-			tst.b	(a1)					; sync to VIA clock
-		eieioSTP
-			dbra	d3,@wait				; delay at least 100 us (very rough)
-		eieioSTP
-			rts5
-
-;_______________________________________________________________________
-;
-;  Routine:		EclipsePDMPatch
-;
-;  Desc:		Patch for ECLIPSE PowerDown Messsage Handler Install
-;				and PowerDown Message Enable
-;_______________________________________________________________________
-
-			EXPORT	EclipsePDMPatch
-EclipsePDMPatch	
-			WITH	EgretPB
-;
-;		Initialize the Eclipse PowerDown Message handler.
-;
-			movem.l	a0-a1,-(sp)						; work registers
-			suba.l	#EgretPbSize,sp					; make room for PB
-			move.l	sp,a0							; point a0 to pbBuffer									<T3>
-			move.w	#(PDMVectPkt << 8),pbCmdType(a0); InitPDM Vector Packet (Cmd ignored)
-			clr.l	pbCompletion(a0)				; No Completion
-			lea		KeySwitchHandler,a1				; address of keyswitch sense handling					<T5>
-			move.l	a1,PbParam(a0)
+;TweakUnknownPramVal
+;
+;	Called at end of InitEgretOrCuda. pram[0xA1] &= ~0x20
+;
+
+			with	EgretPB
+
+TweakUnknownPramVal
+			link.w	a6,#-EgretPBSize
+			move.l	#$07000000,d0
+			and.l	univromflags,d0
+			cmpi.l	#$03000000,d0
+			bne.s	@return
+			move.l	sp,a0
+			move.b	#pseudoPkt,pbCmdType(a0)
+			move.b	#Rd6805addr,pbCmd(a0)
+			clr.l	pbParam(a0)
+			move.w	#$a1,pbParam(a0)				; <L> WHAT IS THIS PRAM LOCATION?!
+			move.w	#1,pbByteCnt(a0)
+			lea		pbParam+2(a0),a1
+			move.l	a1,pbBufPtr(a0)
+			clr.w	pbFlags(a0)
+			clr.w	pbResult(a0)
+			clr.l	pbCompletion(a0)
 			_EgretDispatch
-
-; •••••••••••••••••••••••••••••••••••••••••••••••••
-;	We don't want to enable messages where we set up the Power Down Message Handler.  This is because		<T10>
-;	up until the time a system is located to boot from, when the user turns the keyswitch OFF, there		<T10>
-;	are no files to flush, no volumes to unmount and Caboose can safely turn the machine off with us		<T10>
-;	getting in the way.  Once we get a system loaded, we'll enable Power Down Messages with the other		<T10>
-;	routine, EclipsePDEPatch() (see below).																	<T10>
-; •••••••••••••••••••••••••••••••••••••••••••••••••
-
-;	We need to allocate a TimeMgr TMTask record that we can use once we enable power down messages so		<T15>
-;	we can power the machine down even if UnMounts fail or hang.  ExpandMemRec has JUST been initialized	<T15>
-;	when this patch gets called, so this is safe to do.														<T15>
-
-		WITH	ExpandMemRec
-
-			movea.l	expandMem,a1					; get base of ExpandMemRec								<T15>
-			moveq.l	#(tmQSize+dtQElSize),d0			; request a TimeMgr TMTask+Deferred Task-sized record in SysHeap		<T15>
-			_NewPtr	,SYS,CLEAR						;														<T15>
-			move.l	a0,emKeyTMTaskPtr(a1)			; save pointer to TMTask record in ExpandMemRec			<T15>
-		ENDWITH
-			adda.l	#EgretPbSize,sp					; discard the parameter block
-			movem.l	(sp)+,a0-a1						; restore registers
-@EgretDone
-			
-			rts										; Return to Caller
-
-;_______________________________________________________________________
-;
-;	Eclipse Keyswitch Handler
-;	-------------------------
-;
-;		This routines either
-;			(1) turns off Eclipse, or
-;			(2) catches and ignores keyswitch changes interrupts
-;			from Caboose, since we look directly at the keyswitch
-;			position values on VIA2[PB][v2Keyswitch] or [v2PowerOff].
-;
-;		As of DVT hardware, the values of these keyswitch positions
-;		should be available on VIA2 and no longer need to be maintained
-;		in SW.
-;_______________________________________________________________________
-;
-;		PowerDown Message Handler
-;
-			export	KeySwitchHandler				;														<T5>
-			import	EgretPowerOff					; from EgretPatches.a									<T14>
-			
-KeySwitchHandler									; Handler of Power Down / Keyswitch Sense messages		<T5>
-
-;	Caboose sends a message whenever the keyswitch sense changes.											<T5> thru next <T5>
-;
-;	Input:  D0.B		Keyswitch position
-;
-;				0			OFF
-;				1			Secure
-;				2			Insecure or ON ("normal")
-;	
-
-			tst.b	d0								; check for PowerOff message							<T10>
-			bne.s	@rts							; IF Message == PowerDOWN THEN							<T10>
-
-			movem.l	a0-a1,-(sp)						; save A0, A1											<T15> thru next <T15>
-
-;	First, install a time manager task that will forcefull shut us down in 5 seconds.  That way,
-;	in case something goes wrong with the deferred task, we will shut off anyway.
-
-		WITH	ExpandMemRec
-
-			movea.l	expandMem,a1					; get base address of ExpandMemRec
-			movea.l	emKeyTMTaskPtr(a1),a0			; retrieve "final" Time Mgr queue element
-			movea.l	a0,a1							; use A1 to clear the record
-			moveq.l	#((tmQSize+dtQElSize)/2)-1,d0	; clear the TimeMgr+DeferredTask queue elements
-@clrRec		clr.w	(a1)+							; just in case someone has crapped them up
-			dbra	d0,@clrRec
-			lea		PullThePlug,a1					; get address of where to go when timer expires
-			move.l	a1,tmAddr(a0)					; tell the TimeMgr about it
-			_InsTime								; go install the Turn Off The Power Time Mgr task
-			move.l	#(5*1000),d0					; set timeout to be 5 SECONDS
-			_PrimeTime								; activate the task
-
-;	Now install the Deferred Task that will attempt to unmount all mounted volumes.
-;
-;	The ExpandMemRec Ptr points at an area that is tmQSize+dtQSize bytes big.
-;
-;	Initialize the Deferred Task queue element to point at our Unmount Volumes Deferred Task.
-
-			adda.w	#tmQSize,a0						; move A0 to point at the Deferred Task Queue Element
-			move.w	#dtQType,dtType(a0)				; and initialize the record
-			lea		EclipseAdios,a1
-			move.l	a1,dtAddr(a0)
-			jsr		([jDTInstall])					; go install our Unmount and Shutdown deferred task
-			movem.l	(sp)+,a0-a1						; restore A0, A1
-			tst.w	d0								; see whether or not deferred task install was done
-			bne.s	PullThePlug						; if it failed, shut down RIGHT NOW
-@rts		rts										; if it was successful, return to the int. handler
-
-		ENDWITH
-
-;_______________________________________________________________________
-;
-;	Routine:	EclipseAdios
-;
-;	Desc:		Deferred Task installed when the keyswitch is turned
-;				to the OFF position.  This attempts to Unmount all
-;				volumes.  Once that attempt has been made, the system
-;				is powered down.
-;
-;	Inputs:		None.
-;	Returns:	None.
-;	Trashes:	The System.  Power to Eclipse is turned off.  G'night.
-;
-;_______________________________________________________________________
-
-EclipseAdios
-
-;	Try and unmount any mounted volumes before we power down.
-
-			move.l	VCBQHdr+qHead,a1				;   Start at the head of the VCBQ
-			bra.s	@checkVCB						;   Check if valid
-@UMloop
-			tst.w	vcbFSID(a1)						;   Make sure it’s FSID = 0
-			bne.s	@nextQEntry						;   ... i.e. not a server
-
-; Try to unmount the volume.
-
-			sub.w	#ioQElSize,a7					;   get an I/O param block
-			movea.l	a7,a0
-	
-			move.w	vcbVRefNum(a1),ioVRefNum(a0)	;   stuff VCB VRefNum into PB
-			move.l	#0,ioFileName(a0)
-			move.l	#0,ioCompletion(a0)				;   no completion routine
-			move.l	a1,-(sp)						;   save A1 (queue link ptr)
-			_HUnmountVol							;   attempt to forcefully unmount volume
-			movea.l	(sp)+,a1						;   restore A1
-			adda.w	#ioQElSize,a7					;   get rid of PB.  we'll reallocate the PB if needed
-
-@nextQEntry	movea.l	qLink(a1),a1					;   get next queue entry
-@checkVCB	move.l	a1,d0							;   at EOQ yet?
-			bne.s	@UMloop							;   nope, try this one
-
-PullThePlug											; ENDIF
-			bsr.l	EgretPowerOff					; power junkies go into sudden withdrawl				<T16>
-			bra.s	PullThePlug						; with no hope of recovery								<T16>
-
-;_______________________________________________________________________
-;
-;  Routine:		EclipseDFACPatch
-;
-;  Desc:		Patch for ECLIPSE send default DFAC Messsage
-;_______________________________________________________________________
-			EXPORT	EclipseDFACPatch
-
-EclipseDFACPatch
-;
-;		Build a Parameter block for the default DFAC message
-;
-			movem.l	a0-a1,-(sp)						; work register
-			suba.l	#EgretPbSize,sp					; make room for PB
-			move.l	sp,a0							; point a0 to pbBuffer									<T4>
-			move.w	#(pseudoPkt << 8) \
-					+ SetDefDFAC,pbCmdType(a0)		; InitPDM Vector Packet (Cmd ignored)
-			clr.l	pbCompletion(a0)				; No Completion
-;
-;	Build the DFAC message issue the call and clean up
-;
-			move.w	#$0100,-(sp)					; byte count and one DFAC byte in buffer
-			move.l	sp,pbBufPtr(a0)					; Buffer pointer
-			move.w	#$0002,pbByteCnt(a0)			; byte count includes the byte count byte in the buffer
+			move.b	#Wr6805Addr,pbCmd(a0)
+			bclr	#5,pbParam+2(a0)
 			_EgretDispatch
-			adda.l	#EgretPbSize+2,sp				; discard the parameter block and data buffer
-			movem.l	(sp)+,a0-a1
-@EgretDone
-			rts										; Return to Caller
-
-;_______________________________________________________________________									<T16> thru next <T16>
-;
-;  Routine:		DebugUtilRunKbdPatch
-;
-;  Desc:		Checks to see if the machine we're running on has a
-;				keyswitch, and if so, if it's in the OFF position.
-;				If so, then we probably don't have any choice as to
-;				whether volumes can be flushed and unmounted, so we
-;				go directly to the PowerOff routine.  Do not pass Go,
-;				do not collect $200.  (is that 200 hex dollars?)
-;
-;  NOTE:		This handles both the DebugEnter _and_ DebugPoll cases.
-;_______________________________________________________________________
-
-			EXPORT		DebugUtilRunKbdPatch		; provide address to InterruptHandlers.and anyone else
-DebugUtilRunKbdPatch
-
-			TestFor	KeyswCabooseBit					; do we have a caboose?			<21>
-			beq.s	@justDoIt						;  nope							<21>
-
-;	If you made it here, you're a Caboose-flavor keyswitch.
-;
-;	VIA2 has v2PowerOff and v2Keyswitch (SECURE mode) wired, with 0=TRUE.
-
-			move.l	a1,-(sp)						;     save A1 temporarily
-			movea.l	VIA2RBV,a1						;     retrieve address of VIA2
-		eieioSTP
-			btst.b	#v2PowerOff,VBufB(a1)			;     is the keyswitch OFF?
-		eieioSTP
-			move.l	(sp)+,a1						;     restore A1
-			beq.s	@powerOff						;     IF Keyswitch != OFF THEN
-@justDoIt
-			bra		DebugPwrMgrADBPatch2			;         check for PowerMgr stuff
-@powerOff											;     ELSE
-			bra.s	PullThePlug						;         administer the death blow						<T16>
-
-DebugPwrMgrADBPatch2
-			TestFor	hwCbPwrMgr				; see if we have a power manager
-			beq.s	@noPmgrADB				; if not, skip it
-
-			movea.l	VIA,a1					; point to the VIA
-			movea.l	Lvl1DT+(ifCB1*4),a0		; get the handler address
-			jsr		(a0)					; call the interrupt handler
-			addq.l	#4,SP					; clean up stack from bsr			
-			movem.l	(sp)+,d3/a3				; restore registers
+@return		unlk	a6
 			rts
-@noPmgrADB
-			rts	
-
-;_______________________________________________________________________
-;
-;  Routine:		EgretDFACandPDM			formerly:	EclipseEgretPatches				<P4><MC2>
-;
-;  Desc:		Calls egret patches for Eclipse with Caboose, keyswitch
-;				Calls Egret patches for Anyone with Cuda, SoftPower Off
-;_______________________________________________________________________
-
-				EXPORT	EgretDFACandPDM
-				IMPORT	CudaPDMPatch
-
-EgretDFACandPDM	
-
-			move.l	#EgretFWMask, d0				; get productInfo record mask for Egret FW
-			and.l	UnivRomFlags,d0					; isolate the field
-			sub.l	#Caboose,d0						; Do we have an Egret/Caboose?
-			bne.s	@Done							; -> Nope. Don't do nothing!
-
-	; Instead of calling EclipseDFACPatch, this should more generally initialize DFAC
-	; for all machines that care about it (or even if we don't but it needs it anyway).
-	;	-- bg/djw, 12/6/90
-
-@EgretCaboose
-			bsr		EclipseDFACPatch				; call the Eclipse DFAC control patch
-			bsr		EclipsePDMPatch					; call the Eclipse keyswitch/PowerDown Msgs patch
-@Done		rts										; Return to Caller
-
-
-;--------------------------------------------------------------------------
-;ChkFirmware																		<P2>
-;
-;	This routine will determine if the Egret Chip is using Egret 8 or Caboose
-;	firmware or the new Cuda firmware.  Based on this result, the IRQ handler,
-;	Dispatcher, and Tick handler vectors are set up...
-;	Inputs:
-;		A2	->	EgretGlobals
-;	Outputs:
-;		A0 	->	ShiftRegIRQ	
-;		A1	->	TickHandler
-;	Trashes:
-;		A0,A1
-
-			
-ChkFirmware											;								<P2>
-			movem.l	a2/d0-d2, -(sp)					; preserve used regs
 
-			move.l	#EgretFWMask,d0					; mask for EgretFW				<MC2>
-			and.l	UnivRomFlags,d0					; isolate the field
-			sub.l	#Egret8,d0						; see if we have EgretFW
-			beq.s	@haveEgret						; set Zero flag, exit
 
-	; If we dont have Egret FW, we still might have an Caboose FW
-
-			sub.l	#Egret8,d0						; see if we have CabooseFW
-			beq.s	@haveCaboose					; if we do, chk for Cuda
-
-@haveCuda											;								
-			biglea	CudaDispatch, a0				; Cuda FW dispatcher			
-			move.l	#$92,d0							; set $92 trap					
-			_SetTrapAddress	,NEWOS
-			
-			biglea 	CudaShiftRegIRQ,a0				; stuff Cuda IRQ handler in	
-			biglea	CudaTickHandler,a1				; stuff Cuda tick handler in
-			bra.s	@chkDone						;								
-
-@haveEgret
-@haveCaboose
-			lea		EgretDispatch, a0				; Egret FW dispatcher	
-			move.l	#$92,d0							; set $92 trap			
-			_SetTrapAddress	,NEWOS							;				
-													;							
-			lea 	ShiftRegIRQ,a0					; stuff Egret IRQ handler in
-			lea		tickHandler,a1					; stuff Egret tick handler in
-@chkDone
-			movem.l	(sp)+, a2/d0-d2					; restore used regs
-			rts
-			
-
-
-;--------------------------------------------------------------------------			<P2>
-;SendEgretCmdPatch
-;
-;	This routine will determine if the Egret Chip is using Egret 8 or Caboose
-;	firmware or the new Cuda firmware.  From the firmware type, determine what
-;	routine to use, SendEgretCmd for Egret or Caboose, and SendCudaCmd for Cuda
-;
-;	NOTE:  This routine is REGISTER based, there isn't a stack						<P4>
-;	SendEgretCmd is called via BSR6, so must Preserve A6, as the return address		<P4>
-;	SendEgretCmdPatch is called via a BSR5 return is in A5							<P4>
-;		Input:
-;				a0.l	Pointer to Base address table
-;
-;				d0.l =  High word PACKET Command
-;						Low word PACKET Type
-;
-;				d1.l =	Up to four bytes of data to send
-;						Long word data byte assigment = byte 4, byte 3, byte 2, byte 1
-;						Byte 1 sent out first
-;
-;				d2.l = 	Byte count to send. (0-4 bytes)
-;						Byte count > 4 will send four bytes only
-;
-;--------------------------------------------------------------------------			<P2>
-
-SendEgretCmdPatch
-		move.l	a5, a3						; preserve patch return addr
-		move.l	a6, a4						; preserve EgretInit rtn addr
-		bigbsr6	GetHardwareInfo,a1			;							
-		move.l	a4, a6						; restore EgretInitrtn addr	
-		move.l	a3, a5						; restore patch rtn addr	
-		moveq.l	#ProductInfo.ADBMask,d0		;mask for ADB kind					<23>
-		and.l	d1,d0						;isolate the field					<23>
-		subq.l	#ProductInfo.ADBEgret,d0	;see if we have Egret ADB			<23>
-		
-		and.l	#EgretFWMask,d4				; isolate the field			
-		sub.l	#Egret8,d4					; see if we have Egret8 FW	
-		beq.s	@patchdone					; if we do, zero flag set	
-;
-;	If we dont have Egret FW, we still might have an Caboose			
-;
-		sub.l	#Egret8,d1					; see if we have Caboose FW	
-@haveEgret										; if we do, zero flag set
-		beq.s	@patchdone					; its Egret or Caboose, just exit...
-@haveCuda									;							
-		bigjmp	SendCudaCmd,a3				; jump to Cuda Send routine	
-@patchdone									;							
-		movea.l	DecoderInfo.VIA1Addr(a0),a1			; get VIA 1 base address
-		move.l	#((MaxTout<<16) OR MaxRetries),d4	; number of retries before giving up with Egret <13>
-		rts5
-		
-;--------------------------------------------------------------------------
-;EgretInitPatch															
-;																		
-;	This routine will determine if the Egret Chip is using Egret 8 or Caboose		<P4> 
-;	firmware or the new Cuda firmware.  From the firmware type, determine what
-;	routine to use, EgretInit for Egret or Caboose, and CudaInit for Cuda	
-;																		
-;	NOTE:  This routine is REGISTER based, there isn't a stack
-;	EgretInit is called via BSR6, so must Preserve A6, as the return address
-;	EgretInitPatch is called via a BSR5 return is in A5					
-;	
-EgretInitPatch								;							
-		move.l	a5, a3						; preserve patch return addr
-		move.l	a6, a4						; preserve EgretInit rtn addr
-		bigbsr6	GetHardwareInfo,a1			;							
-		move.l	a4, a6						; restore EgretInitrtn addr	
-		move.l	a3, a5						; restore patch rtn addr	
-		
-		and.l	#EgretFWMask,d1				; isolate the field			
-		sub.l	#Egret8,d1					; see if we have Egret8 FW	
-		beq.s	@patchdone					; if we do, zero flag set	
-;
-;	If we dont have Egret FW, we still might have an Caboose			
-;
-		sub.l	#Egret8,d1					; see if we have Caboose FW				
-@haveEgret										; if we do, zero flag set			
-		beq.s	@patchdone					; its Egret or Caboose, just exit...	
-@haveCuda									;										
-		bigjmp	CudaInit,a3					; jump to CudaInit routine in CudaMgr.a 
-@patchdone									;										
-		movea.l	DecoderInfo.VIA1Addr(a0),a1	; get VIA 1 base address				
-	eieioSTP
-		bclr.b	#vsysSesBit,vBufB(a1)		; kill any pending transactions <8> <13> <P2>
-	eieioSTP
-		bclr.b	#vViaFullBit,vBufB(a1)		; 								<8> <13> <P4>
-	eieioSTP
-		rts5
 
 TerrorEgret		
 
diff --git a/OS/HwPriv.a b/OS/HwPriv.a
--- a/OS/HwPriv.a
+++ b/OS/HwPriv.a
@@ -329,18 +329,21 @@ Vects												;table of offsets to selector routines
 			HwPrivSelector	DisableExtCache			; 5		DisableExtCache
 			HwPrivSelector	FlushExtCache			; 6		FlushExtCache
 			HwPrivSelector	SwapSerialClock			; 7		SwapSerialClock
-			HwPrivSelector	ProtectEDisk			; 8		Protect/Unprotect EDisk
+			HwPrivSelector	EDiskProtectPPC			; 8		Protect/Unprotect EDisk
 			HwPrivSelector	FlushCRange				; 9		FlushCRange
-			HwPrivSelector	WaitForSCSIDevs			; 10	WaitForSCSIDevs
+			HwPrivSelector	ReturnErr				; 10	WaitForSCSIDevs
 			HwPrivSelector	ReturnErr				; 11	Unused
 			HwPrivSelector	SlotBlockXferCtl		; 12 - enable block xfers to a slot
-			HwPrivSelector	GetENetID				; 13 - Get Ethernet ID from serial ROM
+			HwPrivSelector	ReturnErr				; 13 - Get Ethernet ID from serial ROM
+			HwPrivSelector	ReturnErr				; 14
+			HwPrivSelector	ReturnErr				; 15
+			HwPrivSelector	MakeSomethingWriteThrough	; 16
 LastVec
 
 			ALIGN	8
 HWPrivSwitch
 			cmpi.w	#(LastVec-Vects)/HwVecSize,d0	; check if selector in range
-			bhs		ReturnErr						; abort if it’s not a valid selector
+			bcc.s	ReturnErr						; abort if it’s not a valid selector
 			move.w	Vects(d0*HwVecSize),d0			; get offset to selector’s routine
 			jmp		Vects(d0)						; go to the routine
 
@@ -376,37 +379,6 @@ ReturnErr	PROC	ENTRY
 
 SwapICache	PROC	EXPORT
 
-			TestFor	has68kEmulator				;	are we on a PPC-based machine?
-			bnz.b	@EmuFake
-
-			cmp.b	#cpu68040,CpuFlag			;	are we on an 040-based machine?
-			bhs.s	@handle040
-
-@handle030
-			movec	CACR,d0						;	get current cache state
-			bfextu	d0{31:1},d1					;	get cache enable bit into LSbit of d1
-			bclr	#CACR_EI_020_030,d0			;	assume we're disabling (clear enable flag)
-			move.l	a0,d2						;	see what we want to do
-			beq.s	@SetCACR					;	if we want to turn it on
-			ori.b	#((1<<CACR_EI_020_030)|\	;		set enable,
-					(1<<CACR_CI_020_030)),d0	;		flush I-Cache flags
-			bra.s	@SetCACR					;   	go set the desired cache state
-
-@handle040
-			movec	CACR,d0						;	get current cache state
-			bfextu	d0{16:1},d1					;	get cache enable bit into LSbit of d1
-			bclr	#CACR_IE_040,d0				;	assume we're disabling
-			move.l	a0,d2						;	are we enabling the I-Cache?
-			beq.s	@SetCACR					;	NO  ... go turn in OFF
-			jsr		([jCacheFlush])				;		invalidate both caches
-			bset	#CACR_IE_040,d0				;		set IE=1 to enable I-Cache
-
-@SetCACR
-			move.l	d1,a0						;	save the previous I-Cache state
-			movec	d0,CACR						;	set the Cache to desired state
-			moveq	#noErr,d0					;	signal all's well
-			rts
-
 @EmuFake	lea		1,a0						;	do nothing and report that caches were enabled
 			moveq	#noErr,d0
 			rts
@@ -430,7 +402,7 @@ SwapICache	PROC	EXPORT
 
 FlushICache	PROC	EXPORT
 
-			TestFor	has68kEmulator
+			btst.b	#2,$240a
 			bnz.b	@Coherent
 
 			jsr		([jCacheFlush])			; invalidate both caches
@@ -463,40 +435,6 @@ FlushICache	PROC	EXPORT
 
 SwapDCache	PROC	EXPORT
 
-			TestFor	has68kEmulator				;	are we on a PPC-based machine?
-			bnz.b	@EmuFake
-
-			cmp.b	#cpu68040,CpuFlag			;	are we on an 040-based machine?
-			bhs.s	@handle040
-
-@handle030
-			movec	CACR,d0						;	get current cache state
-			bfextu	d0{23:1},d1					;	get cache enable bit into LSbit of d1.l
-			bclr	#CACR_ED_030,d0				;	assume we're disabling (clear enable flag)
-			move.l	a0,d2						;	see what we want to do
-			beq.s	@SetCACR					;	if we want to turn it on
-			ori.w	#((1<<CACR_ED_030)|\		;		set enable,
-					(1<<CACR_CD_030)),d0		;		flush D-Cache flags
-			bra.s	@SetCACR					;   	set cache to the desired state
-
-@handle040
-			movec	CACR,d0						;	get current D-Cache state
-			bfextu	d0{0:1},d1					;	put cache enable bit into LSbit of d1.l
-			bset	#CACR_DE_040,d0				;	assume we're enabling
-			move.l	a0,d2						;	check what we are really doing
-			bne.s	@SetCACR					;	if we are disabling the caches
-			MACHINE	MC68040						;
-			nop									;     required by D43B CPUSHA DC errata item
-			cpusha	dc							;	  push dirty D-Cache data items to memory
-			MACHINE	MC68030						;
-			bclr	#CACR_DE_040,d0				;	  set DE=0 to disable D-Cache
-
-@SetCACR
-			move.l	d1,a0						;	save the previous D-Cache state
-			movec	d0,CACR						;	update D-Cache status value
-			moveq	#noErr,d0					;	signal all's well
-			rts
-
 @EmuFake	lea		1,a0						;	do nothing and report that caches were enabled
 			moveq	#noErr,d0
 			rts
@@ -516,25 +454,6 @@ SwapDCache	PROC	EXPORT
 
 FlushDCache	PROC	EXPORT
 
-			TestFor	has68kEmulator				;	are we on a PPC-based machine?
-			bnz.b	@flushDCacheExit
-
-			cmp.b	#cpu68040,CpuFlag			;	are we on an 040-based machine?
-			bhs.s	@handle040
-
-@handle030
-			movec	CACR,d0						;	get current cache state
-			bset	#CACR_CD_030,d0				;	set 'clear data cache' flag
-			movec	d0,CACR						;	set cache state
-			bra.s	@flushDCacheExit
-
-@handle040
-			MACHINE	MC68040
-			nop									;   required by DD43B CPUSHA DC errata item
-			cpusha	dc							;	flush the D-Cache
-			MACHINE	MC68030
-
-@flushDCacheExit
 			moveq	#noErr,d0					;	signal all's well
 			rts
 
@@ -553,57 +472,6 @@ FlushDCache	PROC	EXPORT
 
 EnableExtCache	PROC	EXPORT
 
-			tst.l	DockingGlobals				; have traps been initialized yet?
-			beq.s	@noDockMgr					;  -> nope, just blow it all off
-			subq	#4,sp						; make room for result
-			move.l	#dockCacheControl,-(sp)		; cache control selector
-			move.l	#dockCacheOn,-(sp)			; indicate the cache should be turned on
-			_DockingDispatch
-			addq	#4,sp						; remove the result (assume success)
-
-		IF hasMDU THEN
-			bra.s	@extCacheDone
-@noDockMgr
-
-			movea.l	UnivInfoPtr,a0				; point to the product info
-			cmpi.b	#DecoderKinds.MDUDecoder,\
-					ProductInfo.DecoderKind(a0)	; see if we have an MDU
-			bne.s	@noMDU						; if not, nothing to enable
-
-; enable the external MDU cache as follows:
-; Toggle the RvCFlush bit 1 - 0 - 1, to flush the cache
-; set the RvCDis bit to 0, to enable the cache (special restriction, can't access cacheable
-; memory for some amount of time after enableing the cache.  By executing this code in
-; a loop, it will be executing out of the instruction cache, and not accessing memory)
-
-			movea.l	VIA2RBV,a0					; get the VIA2 or RBV base address
-			lea		vBufB|RvDataB(a0),a0		; point to the cache register
-
-			move.w	sr,-(sp)					; save int mask
-			ori.w	#HiIntMask,sr				; disable all interrupts
-
-			moveq.l	#~(1<<RvCFlush),d0			; mask to clear flush bit (active low)
-			and.b	(a0),d0						; get the register, clear flush
-			btst.l	#RvCDis,d0					; test the cache disable bit (active high)
-			beq.s	@flushDone					; if already enabled, nothing to do
-			move.b	d0,(a0)						; flush the cache
-			bset.l	#RvCFlush,d0				; setup to un-flush the cache
-
-@loop		move.b	d0,(a0)						; 1st time, un-flush, 2nd time, enable cache
-			move.b	(a0),(a0)					; kill time accessing the RBV/VIA2
-			move.b	(a0),(a0)					; kill some more time
-			bclr.l	#RvCDis,d0					; enable the cache (active high)
-			bne.s	@loop						; loop if first time through
-
-@flushDone	move.w	(sp)+,sr					; restore int mask
-@noMDU
-
-		ELSE
-@noDockMgr
-
-		ENDIF
-
-@extCacheDone
 			moveq	#noErr,d0					; signal all's well
 			rts
 
@@ -622,34 +490,6 @@ EnableExtCache	PROC	EXPORT
 
 DisableExtCache	PROC	EXPORT
 
-			tst.l	DockingGlobals				; have traps been initialized yet?
-			beq.s	@noDockMgr					;  -> nope, just blow it all off
-			subq	#4, sp						; make room for result
-			move.l	#dockCacheControl, -(sp)	; cache control selector
-			move.l	#dockCacheOff, -(sp)		; indicate the cache should be turned on
-			_DockingDispatch
-			addq	#4,sp						; remove the result (assume success)
-
-		IF hasMDU THEN
-			bra.s	@extCacheDone
-@noDockMgr
-
-			movea.l	UnivInfoPtr,a0				; point to the product info
-			cmpi.b	#DecoderKinds.MDUDecoder,\
-					ProductInfo.DecoderKind(a0)	; see if we have an MDU
-			bne.s	@noMDU						; if not, nothing to enable
-
-			movea.l	VIA2RBV,a0					; get the VIA2 or RBV base address
-			lea		vBufB|RvDataB(a0),a0		; point to the cache register
-			ori.b	#(1<<RvCDis),(a0)			; disable cache
-@noMDU
-
-		ELSE
-@noDockMgr
-
-		ENDIF
-
-@extCacheDone
 			moveq	#noErr,d0					; signal all's well
 			rts
 
@@ -711,60 +551,6 @@ SwapSerialClock	PROC	EXPORT
 			tst.w	d2								; check SCC and port number
 			bne		ReturnErr						; only port A supported
 
-			TestFor	SCCIOPExists
-			beq.w	@BuiltinSCC						; no IOP hardware
-			btst.b	#0,SCCIOPFlag					; are we in bypass mode ?
-			beq		@Done							; no, so can't make the call, so exit
-
-;	Call SCC IOP kernel to set the external clock mode.
-
-			WITH	IOPRequestInfo, SCCCtlMsg, SCCCtlReply
-
-@IOPSCC
-			suba.w	#irReqInfoSize+SCCCtlMsgSize,sp	; SP = ptr to request msg
-
-			lea		irIOPNumber(sp),a0
-			move.b	#SCCIOPNum,(a0)+				; set iop number
-			assert	irRequestKind=(irIOPNumber+1)
-			move.b	#irSendXmtMessage,(a0)+			; a send xmit message kind
-			assert	irMsgNumber=(irRequestKind+1)
-			assert	irMessageLen=(irMsgNumber+1)
-			assert	irReplyLen=(irMessageLen+1)
-			assert	irReqActive=(irReplyLen+1)
-			move.l	#(1<<24)+\						; irMsgNumber = 1
-					(SCCCtlMsgSize<<16)+\			; irMessageLen = SCCCtlMsgSize
-					(SCCCtlMsgSize<<8)+\			; irReplyLen = SCCCtlMsgSize
-					(0),(a0)+						; irReqActive = 0
-
-			movea.l	sp,a1
-			adda.w	#irReqInfoSize,a1				; point to SCCCtlMsg
-			assert	irMessagePtr=(irReqActive+1)
-			move.l	a1,(a0)+						; irMessagePtr = SCCCtlMsg
-			assert	irReplyPtr=(irMessagePtr+4)
-			move.l	a1,(a0)+						; irReplyPtr = SCCCtlMsg
-			assert	irHandler=(irReplyPtr+4)
-			clr.l	(a0)							; irHandler = nil (no completion routine)
-			move.b	#6,msgNum(a1)					; message to change external clocking
-			move.b	d2,Driver(a1)					; set port to change
-			swap	d2								; get ext clk state in low word
-			move.b	d2,GPI(a1)						; set state of external clocking
-
-			movea.l	sp,a0							; a0 = ptr IOPRequestInfo
-			_IOPMsgRequest
-			bne.s	@1								; error in request
-
-@waitloop	tst.b	irReqActive(a0)					; wait for request to complete
-			bne.s	@waitloop
-
-			movea.l	irReplyPtr(a0),a0				; get reply
-			move.b	errNum(a0),d0					; error code from reply
-@1			adda.w	#irReqInfoSize+SCCCtlMsgSize,sp
-			bra.s	@Done
-
-			ENDWITH
-
-;	Bang on the VIA vSync bit directly.
-
 @BuiltinSCC
 			TestFor	VIA1Exists
 			beq.s	@Done							; no via - nothing to do now
@@ -794,31 +580,6 @@ SwapSerialClock	PROC	EXPORT
 			ENDPROC
 
 
-;----------
-;
-;   ProtectEDisk (_HWPriv Selector 8)
-;
-;	This stub merely selects what version of the primitive routine to use.
-;	EDisk protection is handled differently on 68K Macs than it is on PPC Macs.
-;
-;----------
-
-ProtectEDisk	PROC	EXPORT
-
-			IMPORT	EDiskProtect, EDiskProtectPPC
-
-			TestFor	has68kEmulator				; are we on a PPC-based machine?
-			bnz.b	@UsePPCVersion
-
-@Use68KVersion
-			bra		EDiskProtect
-
-@UsePPCVersion
-			bra		EDiskProtectPPC
-
-			ENDPROC
-
-
 ;----------
 ;
 ;   FlushCRange (_HWPriv Selector 9)
@@ -841,91 +602,10 @@ ProtectEDisk	PROC	EXPORT
 
 FlushCRangeForBM	PROC	EXPORT
 			EXPORT	FlushCRange
-
-			Move.l	(Sp)+,A0					; Address.
-			Move.l	(Sp)+,A1					; Count.
-
 FlushCRange
-			TestFor	has68kEmulator				; are we on a PPC-based machine?
-			bnz		@EmuFake
 
-			Cmpi.b	#cpu68040,CPUFlag			; Are we less than an 040?
-			Blo		@Non040						; Yes? Then do an 030 style flush.
-
-			MACHINE	MC68040
-			Adda.w	#15,A1						; Round length.
-			Move.l	A1,D1						; Length in D1
-			And.w	#$FFF0,D1					; Round to nearest cache line.
-
-			Move	SR,D0						; Get and save the SR.
-			Btst	#13,D0						; Are we in Supervisor mode?
-			Bne.s	@CheckCnt					; Yes? Then don't call _EnterSupervisorMode.
-			Moveq	#8,D0						; Selector for "EnterSupervisorMode".
-			_DebugUtil							; Must be in supervisor mode (SR returned in D0).
-
-@CheckCnt	Cmpi.l	#$0C00,D1					; Less than 3/4 the size of the cache?  ***Tune***
-			Blo.s	@KillInterrupts				; Yes? Then flush line by line.
-@0			Nop									; Sync up pipeline.  ***TEMP***
-			Cpusha	BC							; No? Then flush everything and be done with it.
-			Bra.s	@Exit1						; Outta here.
-
-@KillInterrupts
-			Movem.l	D3-D5/A0-A1,-(Sp)			; Save registers.
-			Ori.w	#$0700,SR					; Disable interrupts till we exit.
-			Moveq	#5,D2						; Set the DFC value.
-			Movec	D2,DFC						; Set the Destination Function Code to 5.
-
-			Move.w	#$D000,D4					; Build a mask based on the page size from bit #14 of TC.
-			Movec	TC,D2						; Get Translation Control (Bit 14 set:8K, clear:4K).
-			Lsr.w	#2,D2						; Move the TC bits (enable/page size) over 2
-			Eor.w	D2,D4						; Eor in the bits to make the mask ($F000 for 4K, $E000 for 8K).
-			Move.w	D4,D5						; Copy physical mask.
-			Not.w	D5							; Make 1's complement mask for logical address.
-
-@LetsGetPhysical
-			Move.l	A0,A1						; Set scratch register (A1) with logical address.
-			Ptestr	(A1)						; Get translated physical address.
-			Movec	MMUSR,D3					; Address is in high 19 or 20 bits of MMUSR.
-
-			And.w	D4,D3						; Clear off bottom n bits.
-			Move.w	A1,D2						; Logical address in D2.
-			And.w	D5,D2						; Grab low n bits of original address.
-			Or.w	D2,D3						; Build complete physical address.
-			Move.l	D3,A1						; Physical address.
-
-			Eor.w	D5,D2						; Calculate number of bytes left in this page.
-			Addq.w	#1,D2
-			Sub.w	D2,D1						; Subtract from total buffer size.
-			Bpl.s	@FlushIt					; Still pos? Then D2 has correct byte count.
-			Add.w	D1,D2						; No? Then almost done…correct the count.
-
-@FlushIt	Adda.w	D2,A0						; Logical address of next page.
-			Asr.w	#4,D2						; Lines to flush.
-			Cmp.w	#16,D2						; More than 16 lines?  ***TUNE***
-			Blt.s	@LineByLine					; No? Then do it line by line.
-
-			Nop									; Sync up pipeline.  ***TEMP***
-			Cpushp	BC,(A1)						; Invalidate the whole page.
-			Bra.s	@NextPage					; Do next page.
-
-@LineByLine	Cpushl	BC,(A1)						; Invalidate the cache line.
-			Add.w	#$10,A1						; Bump logical address to the next cache line.
-			Dbra	D2,@LineByLine				; Loop till page is done.
-
-@NextPage	Tst.w	D1							; Are we done?
-			Bgt.s	@LetsGetPhysical			; No? Then do next page.
-
-@Exit		Movem.l	(Sp)+,D3-D5/A0-A1			; Restore registers.
-@Exit1		Move	D0,SR						; Restore status register (interrupts and user/supervisor mode).
-			Moveq	#noErr,D0					; No Error.
-			Rts									; Adios.
-			MACHINE	MC68030
-
-@Non040		Movec	CACR,D0						; Cache control register.
-			Bset	#3,D0						; Set flag to flush instruction cache.
-			Movec	D0,CACR						; Flush it.
-			Moveq	#noErr,D0					; No Error.
-			Rts									; Adios.
+			move.l	a1,d0
+			dc.w	$FC16
 
 @EmuFake	moveq	#noErr,d0
 			rts
@@ -933,100 +613,6 @@ FlushCRange
 			ENDPROC
 
 
-;----------
-;
-;   WaitForSCSIDevs (_HWPriv Selector 10)
-;
-;	On Entry:
-;	-> A0[7-0]		= bit map of SCSI IDs to wait for
-;	-> A0[23-16]	= bit map of SCSI IDs to search for
-;
-;	On Exit:
-;	<- A0			= result (0=found wait_for drives, -1=didn't find them)
-;
-;	Register Usage:
-;	D0 = temp
-;	D1 = bitmap of devices to wait for
-;	D2 = bitmap of devices to search for
-;	D3 = OS Type (for SCSILoad)
-;	D4 = Ticks at timeout
-;
-;----------
-
-WaitForSCSIDevs	PROC	EXPORT
-
-				IMPORT	SCSILoad
-
-trashedRegs		REG		D2-D4/D6
-
-DefaultTimeOut	EQU		20					; Number of seconds timeout if PRAM is pristine
-PollDelay		EQU		15					; Delay (in ticks) between SCSILoads
-
-			movem.l	trashedRegs, -(sp)		; save registers that we're going to trash
-
-; Get bitmap parameters into D1 and D2
-			move.l	A0, D1					; D1 = bitmap of devices to wait for
-			move.l	D1, D2					;
-			swap	D2						; D2 = bitmap of devices to search for
-			or.b	D1, D2					; make sure that we search for the drive(s)
-											; that we are waiting for
-
-; SCSILoad expects OS type in high word of D3
-			subq.w	#2, sp					; Make room for parameters.
-			move.l	sp, A0					; Point to the parameter block.
-			_GetOSDefault					; Get info about the default device.
-											; leave OS results on stack for a second
-
-; Get PRAM time out value and convert it to ticks and keep in D4
-			_GetTimeOut						; Get the timeout parameter.
-			bne.s	@UseGivenTime			; Branch if not using default.
-			moveq.l	#DefaultTimeOut, D0		; Use default timeout.
-@UseGivenTime
-			mulu	#60, D0					; Convert timeout to ticks.
-			move.l	D0, D4					; Save timeout in our final reg.
-
-			move.w	(sp)+, D3				; Get OS type off of stack
-			swap	D3						; put in high word (where SCSILoad expects it)
-
-			moveq.l	#0, D6
-			bset	#31, D6					; tell drivers not to munge the blasted heap
-
-; SCSILoad polling loop -------
-
-@TopO_TheLoop
-			move.l	D2, D0					; Try to load drivers for the "search" disks
-			bsr.l	SCSILoad
-
-			move.b	SCSIDrvrs, D0
-			and.b	D1, D0					; look only at bits we are waiting for
-			cmp.b	D1, D0					; if all are 1 then
-			beq.s	@goodexit				; we got what we were waiting for - exit
-
-; Check for timeout, wait for PollDelay more ticks, check timeout again, then do the SCSILoad again
-			move.l	Ticks, D0
-			cmp.l	D4, D0					; is current ticks higher than our time_out ticks?
-			bhi		@fldexit				; yes - timed out, exit
-
-			add.l	#PollDelay, D0			; wait till Ticks+PollDelay before polling
-@1			cmp.l	Ticks, D0				; if polldelay timeout is higher than current ticks,
-			bhi		@1						; then loop
-
-			cmp.l	D4, D0					; is current ticks higher than our time_out ticks?
-			blo		@TopO_TheLoop			; no - repeat SCSILoad
-											; yes - timed out, exit
-@fldexit
-			move.w	#-1, A0
-			bra.s	@exit
-
-@goodexit
-			move.w	#0, A0
-@exit
-			movem.l	(sp)+, trashedRegs		; restore registers that we trashed
-			rts
-
-			ENDPROC
-
-
 ;----------
 ;
 ;   SlotBlockXferCtl (_HWPriv Selector 12)
@@ -1051,117 +637,38 @@ PollDelay		EQU		15					; Delay (in ticks) between SCSILoads
 
 SlotBlockXferCtl	PROC	EXPORT
 
-			MoveQ.l	#paramErr, D0			; assume don't have MUNI or bad slot value passed
-			Testfor	BARTExists				; are we on a ColdFusion or PDM
-			bne.s	@bart
-			TestFor MUNIExists				; Do we have the MUNI Nubus controller
-			Beq.s	@exit					; No, we're done.
-
-			MoveA.l	UnivInfoPtr, A1			; point to the product info
-			Add.l	ProductInfo.DecoderInfoPtr(A1), A1 ; get decoder info ptr
-			MoveA.l	DecoderInfo.MUNIAddr(A1), A1 ; get MUNI base address
-
-			Move.l	A0, D1					; get user parm
-			MoveQ	#0, D2
-			Move.l	MUNI_BlkAttmpt(A1), D2	; get previous state of slots 1-14
-			Lsl.w	#1, D2					; make bit x match slot x, bit 1 = slot 1
-			MoveA.l	D2, A0					; return previous state bit mask in A0
-
-			MoveQ	#0, D2
-			Move.b	D1, D2					; Get slot #
-			SubQ.b	#1, D2					; adjust slot # for bit offset
-			Bmi.s	@exit					; bad slot value, < 1
-			Cmp.b	#14, D2
-			Bhs.s	@exit					; bad slot value, > 14
-			Move.l	MUNI_BlkAttmpt(A1), D0	; get current state of slots 1-14
-			BTst 	#8, D1					; Turn blk xfer on or off?
-			Bne.s	@on
-			BClr	D2, D0					; turn if off
-			Bra.s	@doit
-@on			BSet	D2, D0					; turn if on
-@doit		Move.l	D0, MUNI_BlkAttmpt(A1)	; setup block xfers for slot # in D2
-			bra.s	@done
-
-@bart
-			MoveA.l	UnivInfoPtr, A1						; point to the product info
-			Add.l	ProductInfo.DecoderInfoPtr(A1),A1	; get decoder info ptr
-			MoveA.l	DecoderInfo.BARTAddr(A1),A1 		; get Bart base address
-
-			Move.l	A0, D1					; get user parm
-			MoveQ	#0, D2
-			Move.b	D1, D2					; Get slot #
-			SubQ.b	#1, D2					; adjust slot # for bit offset
-			Bmi.s	@exit					; bad slot value, < 1
-			Cmp.b	#14, D2
-			Bhs.s	@exit					; bad slot value, > 14
-			BTst 	#8, D1					; Turn blk xfer on or off?
-			Bne.s	@Bon
-
-			moveq	#BARTBurstRegOff, d0
-			mulu.l	d2, d0
-			adda.l	#BARTBurstReg,a1
-			suba.l	d0, a1
-			bclr.b	#BARTBurstBit, (A1)		; turn off block xfers for slot # in D2
-			Bra.s	@done
-
-@Bon		moveq	#BARTBurstRegOff, d0
-			mulu.l	d2, d0
-			adda.l	#BARTBurstReg,a1
-			suba.l	d0, a1
-			bset.b	#BARTBurstBit, (A1)		; turn on block xfers for slot # in D2
-
-@done		MoveQ	#noErr,D0				; signal all's well
-
-@exit		Rts
-
-			ENDPROC
-
-
-;----------
-;
-;   GetENetID (_HWPriv Selector 13)
-;
-;   This routine gets the EtherNet ID from a serial-interface EtherNet ID ROM.
-;	On all machines except Blackbird (so far), the Ethernet ID is in a memory-mapped
-;	parallel ROM. When this routine runs on those machines, a0 should already
-;	contain a valid address at which to read the ethernet ID, so this routine
-;	will just exit for those machines. If there is no address in a0, we double check
-;	here to make sure we are on a Blackbird (by checking for Pratt), and then
-;	go ahead and try to get the Ethernet ID from the serial ROM.
-;
-;   Entry:
-;
-;      A0.l - ENetPROM field of the EtherNet Driver (address of ID ROM, or
-;			  zero for an ID ROM that is not memory-mapped).
-;
-;   Exit:
-;
-;      A0.l - non-zero pointer to EtherNet ID
-;			- ID = 0 if we can't get address from ID ROM
-;
-;   Destroys: D1, D2, A1
-;
-;----------
-
-GetENetID	PROC	EXPORT
-
-			IMPORT	X24c01aGetID
-
-			WITH 	PMgrRec, PmgrPrimitivesRec
-
-		IF hasPratt THEN
-			TestFor	PrattExists				; 	do we have a Pratt?
-			beq.s	@exit					; 	no, so exit
-
-			move.l	a4, -(sp)				; 	save our macro register
-			bigjsr	X24c01aGetID,a4			;	get the ID from the serial ROM
-			move.l	(sp)+, a4				; 	restore our macro register
-		ENDIF
-
-@exit		moveq	#noErr,d0				;	everything always fine
+			moveq	#paramErr,D0
 			rts
 
-			ENDWITH
+			ENDPROC
+
+
+;----------
+;
+;   MakeSomethingWriteThrough
+;
+;----------
+
+MakeSomethingWriteThrough	PROC	EXPORT
+
+			Move.L	([$1FF4],$8), D2
+			Move.L	A0, D0
+			LsR.L	D2, D0
+			MoveA.L	D0, A0
+			Move.L	A1, D0
+			SubQ.L	#$1, D0
+			LsR.L	D2, D0
+			Move.L	D0, D2
+@loop
+			_nkMakePageWriteThrough
+			Tst.L	D0
+			BMI.B	@exit
+			AddQ	#$1, A0
+			DBF		D2, @loop
+			MoveQ.L	#$0, D0
+@exit
+			Rts
+
 			ENDPROC
 
 
@@ -1228,21 +735,25 @@ Vects														;table of offset to selector routines
 				MemDispSelector	LockMemoryContiguousProc	; 4
 				MemDispSelector	GetPhysicalProc				; 5
 				MemDispSelector	WriteProtectProc			; 6		<T6>
-LastVec			MemDispSelector	UnWriteProtectProc			; 7		<T6>
+				MemDispSelector	UnWriteProtectProc			; 7		<T6>
+				dc.w			badSelect-Vects				; 8		<T6>
+				dc.w			badSelect-Vects				; 9		<T6>
+LastVec			MemDispSelector	LockMemoryProc				; 10	<T6>
 
 
 MemoryDispatchCode
 				cmp.w	#(LastVec-Vects)/MdVecSize,d0	; check if selector in range
-				bhi.s	@badSelect						; abort if its not a valid selector
+				bhi.s	badSelect						; abort if its not a valid selector
 				move.w	Vects(d0.w*MdVecSize),d0		; get offset to selector's routine
 				jmp		Vects(d0)						; go to the routine
 
-@badSelect		move.l	#hwParamErr,d0					; abort: return error code
+badSelect2
+badSelect3
+badSelect		move.l	#hwParamErr,d0					; abort: return error code
 				rts
 
 				EndProc
 
-
 ;-----
 ;
 ;   HoldMemoryProc (_MemoryDispatch Selector 0)
@@ -1301,7 +812,7 @@ LockMemoryProc		PROC	Export
 				movea.l	LockMemCt,a2			; point to MemoryDispatch globals
 				bsr		GetPageRange			; check input arguments
 				bne.s	@error					; get out
-				lea.l	mdLockTable(a2,d1*2),a1	; point to lock counter for first page
+				lea.l	mdLockTable(a2,d1.l*2),a1	; point to lock counter for first page
 				moveq.l	#1,d0					; flag to MMUSetCacheInhibit to inhibit caching
 @loop
 				addq.w	#1,(a1)+				; bump the lock count
@@ -1310,10 +821,6 @@ LockMemoryProc		PROC	Export
 				subq.l	#1,d2					; one less page to go						<T4>
 				bhi.s	@loop					; keep looping								<T4>
 
-				cmpi.b	#EMMU1,MMUType			; is this an Emulated MMU?					<SM17>
-				beq.s	@done					; -> Yes, no need to flush anything			<SM17>
-				bsr		MMUFlushATC				; flush ATC's
-				_FlushDataCache					; flush data cache
 @done			moveq.l	#noErr,d0				; no error
 @error
 				movem.l	(sp)+,@saveRegs			; restore registers
@@ -1342,7 +849,7 @@ UnLockMemoryProc	PROC	Export
 				movea.l	LockMemCt,a2			; point to MemoryDispatch globals
 				bsr		GetPageRange			; check input arguments
 				bne.s	@error					; get out
-				lea.l	mdLockTable(a2,d1*2),a1	; point to lock counter for first page
+				lea.l	mdLockTable(a2,d1.l*2),a1	; point to lock counter for first page
 				move.l	d2,d3					; copy of the count
 				move.w	#notLockedErr,d0		; assume a nonlocked page
 @lockCheckLoop
@@ -1351,7 +858,7 @@ UnLockMemoryProc	PROC	Export
 				subq.l	#1,d3					; one less page to go						<T4>
 				bhi.s	@lockCheckLoop			; keep looping								<T4>
 
-				lea.l	mdLockTable(a2,d1*2),a1	; point to lock counter for first page
+				lea.l	mdLockTable(a2,d1.l*2),a1	; point to lock counter for first page
 				move.l	d2,d3					; copy of the count
 				moveq.l	#0,d0					; flag to MMUSetCacheInhibit to enable caching
 				moveq.l	#0,d4					; assume ATC will not need to be cleared
@@ -1423,7 +930,7 @@ LockMemoryContiguousProc PROC	Export
 				cmpa.l	a1,a0					; compare the results
 				bne.s	@notContigError			; range crosses a non-contiguous bank boundary
 
-				lea.l	mdLockTable(a2,d1*2),a1	; point to lock counter for first page
+				lea.l	mdLockTable(a2,d1.l*2),a1	; point to lock counter for first page
 				moveq.l	#1,d0					; flag to MMUSetCacheInhibit to inhibit caching
 @loop
 				addq.w	#1,(a1)+				; bump the lock count
@@ -1432,10 +939,6 @@ LockMemoryContiguousProc PROC	Export
 				subq.l	#1,d2					; one less page to go						<T4>
 				bhi.s	@loop					; keep looping								<T4>
 
-				cmpi.b	#EMMU1,MMUType			; is this an Emulated MMU?					<SM17>			<SM17>
-				beq.s	@done					; -> Yes, no ATC or Data cache to flush		<SM17>
-				bsr		MMUFlushATC				; flush ATC's
-				_FlushDataCache					; flush data cache
 @done			moveq.l	#noErr,d0				; no error
 @error
 				movem.l	(sp)+,@saveRegs			; restore registers
@@ -1722,12 +1225,7 @@ WriteProtectProc	Proc	Export
 
 			bsr		GetPageRange			; check input arguments
 			bne.s	@error					; get out
-			cmpi.b	#EMMU1,MMUType			; do we have an EMMU?			<SM17>
-			beq.s	@NoFlush				; -> Yes, no need for this crap
-			_FlushDataCache					; flush data cache (flush data before write protecting)
-			_FlushInstructionCache			; flush instruction cache (just for grins)
-			bsr		MMUFlushATC				; flush ATC's
-@NoFlush	lea.l	mdLockTable(a2,d1*2),a1	; point to lock counter for first page
+@NoFlush	lea.l	mdLockTable(a2,d1.l*2),a1	; point to lock counter for first page
 			moveq.l	#@setW,d0				; flag to MMUSetWriteProtect to write-protect
 @loop
 			ori.w	#@setWMask,(a1)+		; set the write-protect flag
@@ -1789,7 +1287,7 @@ UnWriteProtectProc	Proc	Export
 
 			bsr		GetPageRange			; check input arguments
 			bne.s	@error					; get out
-			lea.l	mdLockTable(a2,d1*2),a1	; point to lock counter for first page
+			lea.l	mdLockTable(a2,d1.l*2),a1	; point to lock counter for first page
 			moveq.l	#@clearW,d0				; flag to MMUSetWriteProtect to clear write-protect
 @loop
 			andi.w	#@clearWMask,(a1)+		; clear the write-protect flag
@@ -1827,15 +1325,6 @@ InitMemoryDispatch	Proc	Export
 
 			clr.l	LockMemCt					; clear ptr to globals (assume failure)
 
-			cmpi.b	#HMMU,MMUType				; Do we have an MMU?								<SM17>
-			bhi.s	@hasMMU						; -> Yes, do the init!
-
-			MOVE.W	#@UnimplementedTrap,d0		; _Unimplemented									<SM17>
-			_GetTrapAddress ,newTool			; Get its address
-			MOVE.W	#@MemoryDispatchTrap,d0		; Select MemoryDispatch trap
-			_SetTrapAddress ,newOS				; Set it to point to Unimplemented
-			bra		@NoPages					; -> All done
-
 @hasMMU		move.b	CPUFlag,d1					; get the CPU type
 			moveq.l	#0,d2						; assume no page size
 			move.l	PhysMemTop,d3				; get actual amount of physical RAM
@@ -1856,8 +1345,6 @@ InitMemoryDispatch	Proc	Export
 			blo.w	@noPages					; bail without allocating globals ??? (Use old code ?)
 			cmpi.b	#PMMU851,MMUType			; do we have a real MMU ?
 			blo.w	@noPages					; bail without allocating globals ??? (Use old code ?)
-			cmpi.b	#EMMU1,MMUType				; do we have an emulated MMU?
-			bne.s	@mustbe030					; -> No, must be an 030								<SM17>
 
 			moveq	#0,D1						; clear D1
 			move.l	([ProcessorInfoPtr],ProcessorInfo.PageSize),D0	; Get the Page size from the nano-k
@@ -1867,8 +1354,6 @@ InitMemoryDispatch	Proc	Export
 			addq	#1,d1
 			bra.s	@countBits					; Keep shifting till we find one					<SM17>
 
-@mustbe030	pmove.l	TC,-4(a6)					; get the '030 TC register contents
-			bfextu	-4(a6){8,4},d1				; get log2 of page size
 @gotPageSize
 			bset.l	d1,d2						; get the page size
 			lsr.l	d1,d3						; get number of page frames
@@ -1978,15 +1463,9 @@ MMUSetWriteProtect	Proc	Export
 @moreRegs	REG		d1/a1/a2
 @wBit		EQU		2						; write protect bit in all page descriptors
 
-			cmp.b	#PMMU851,MMUType		; do we have at least a 68851 PMMU ?
-			blo.w	@noPages				; if not, no pages to write protect (020 or less)
-@hasPages
 			movem.l	@saveRegs,-(sp)			; save registers
 			move.l	d0,d4					; remember write-protect mask
 
-			CMPI.B	#EMMU1,MMUType			; Do we have an EMMU?						<SM17>
-			BNE.S	@RealMMU				; -> Nope, sorry
-
 			MOVE.L	D1,A0					; Put the page number in A0
 			_nkGetPTEntryGivenPage			; Get the 030+ PTE from the nk
 
@@ -1997,47 +1476,6 @@ MMUSetWriteProtect	Proc	Export
 			MOVE.L	D1,A1					; Put the page number in A1
 			_nkSetPTEntryGivenPage			; Set the 030+ PTE
 
-			BRA.S	@RegDone				 ; -> Exit
-
-@RealMMU	move.l	mdLog2PageSize(a2),d0	; get the log2 of the page size
-			asl.l	d0,d1					; turn logical page number into a logical address
-
-	IF Supports24Bit THEN					; <SM17>
-			cmp.l	mdPages24(a2),d1		; check if page is in the 24-bit address space
-			slo		d3						; if it is, be sure to whack the 24-bit table
-
-			moveq.l	#false32b,d0			; first go to 24-bit mode
-			_SwapMMUMode					; go to 24-bit mode
-			move.l	d0,d2					; remember the caller's MMU mode
-
-			movea.l	d1,a0					; set up logical address to get page descriptor
-			movem.l	@moreRegs,-(sp)			; save registers that GetPageDesc destroys
-			bsr		GetPageDescProc			; ptr to page descriptor given logical address
-			movem.l	(sp)+,@moreRegs			; restore registers that GetPageDesc destroys
-			movea.l	a0,a1					; save ptr to 24-bit page descriptor
-
-			moveq.l	#true32b,d0				; go to 32-bit mode
-			_SwapMMUMode					; go to 32-bit, return caller's MMU mode
-	ENDIF
-
-			movea.l	d1,a0					; set up logical address to get page descriptor
-			movem.l	@moreRegs,-(sp)			; save registers that GetPageDesc destroys
-			bsr		GetPageDescProc			; ptr to page descriptor given logical address
-			movem.l	(sp)+,@moreRegs			; restore registers that GetPageDesc destroys
-
-			bclr.b	#@wBit,3(a0)			; clear the W bit
-			or.l	d4,(a0)					; clear/set the write-protect flag
-
-	IF Supports24Bit THEN					; <SM17>
-			tst.b	d3						; should we whack the 24-bit table ?
-			beq.s	@exit					; if not, we're done
-
-			bclr.b	#@wBit,3(a1)			; clear the W bit
-			or.l	d4,(a1)					; clear/set the write-protect flag
-@exit
-			move.l	d2,d0					; caller's MMU mode
-			_SwapMMUMode					; restore the MMU mode						<end>
-	ENDIF
 @regDone	movem.l	(sp)+,@saveRegs			; restore registers							<T4>
 @noPages
 			rts
@@ -2072,118 +1510,27 @@ MMUSetCacheInhibit	Proc	Export
 @saveRegs	REG		d0-d4/a0/a1
 @moreRegs	REG		d1/a1/a2
 
-			cmp.b	#PMMU851,MMUType		; do we have at least a 68851 PMMU ?
-			blo.w	@noPages				; if not, we can't control data caching (020 or less)
-@hasPages
 			movem.l	@saveRegs,-(sp)			; save registers
 
-			cmpi.b	#EMMU1,MMUType			; Do we have an EMMU?
-			bne.s	@RealMMU				; -> Nope, sorry
+			btst.b	#7,$240A
+			bne.s	@RegDone
 
 			MOVE.L	D1,A0					 ; Put the page number in A0
 			ADDI.W	#mmuMakePageCacheable,D0 ; Turn the cache mode flag into a nKernel selector
 			_KernelVMDispatch				 ; Set the cache status & flush the ATC
-			BRA.S	@RegDone				 ; -> Exit
 
-@RealMMU	move.l	d0,d4					; remember inhibit flag
-
-			move.l	mdLog2PageSize(a2),d0	; get the log2 of the page size
-			asl.l	d0,d1					; turn logical page number into a logical address
-
-	IF Supports24Bit THEN					; <SM17>
-			cmp.l	mdPages24(a2),d1		; check if page is in the 24-bit address space
-			slo		d3						; if it is, be sure to whack the 24-bit table
-
-			moveq.l	#false32b,d0			; first go to 24-bit mode						<T4>
-			_SwapMMUMode					; go to 24-bit mode
-			move.l	d0,d2					; remember the caller's MMU mode
-
-			movea.l	d1,a0					; set up logical address to get page descriptor
-			movem.l	@moreRegs,-(sp)			; save registers that GetPageDesc destroys
-			bsr		GetPageDescProc			; ptr to page descriptor given logical address
-			movem.l	(sp)+,@moreRegs			; restore registers that GetPageDesc destroys
-			movea.l	a0,a1					; save ptr to 24-bit page descriptor			<T4>
-
-			moveq.l	#true32b,d0				; go to 32-bit mode								<T4>
-			_SwapMMUMode
-	ENDIF
-			movea.l	d1,a0					; set up logical address to get page descriptor
-			movem.l	@moreRegs,-(sp)			; save registers that GetPageDesc destroys
-			bsr		GetPageDescProc			; ptr to page descriptor given logical address
-			movem.l	(sp)+,@moreRegs			; restore registers that GetPageDesc destroys
-			bsr.s	MMUSetCacheMode			; go whack the page descriptor					<T3>
-
-	IF Supports24Bit THEN					; <SM17>
-			tst.b	d3						; should we whack the 24-bit table ?
-			beq.s	@exit					; if not, we're done
-
-			movea.l	a1,a0					; point to the 24-bit page descriptor			<T4>
-			bsr.s	MMUSetCacheMode			; go whack the page descriptor					<T3>
-@exit
-			move.l	d2,d0					; caller's MMU mode
-			_SwapMMUMode					; restore the MMU mode
-	ENDIF
 @RegDone	movem.l	(sp)+,@saveRegs			; restore registers
 @noPages
 			rts
 			EndWith
 			EndProc
 
-;-------------------------------------------------------------------
-;	MMUSetCacheMode - code to actually whack the page table entry (Called in 32-bit mode)	<T4>
-;																							<T3>
-;	Destroys:	None.																		<start>
-;
-;	On entry:	d4.l = cache inhibit flag:	0=clear cache inhibit bit(s)
-;											1=set cache inhibit bit(s)
-;				a0.l = logical address of page descriptor
-;				a2.l = ptr to MemoryDispatch globals
-;-------------------------------------------------------------------
-MMUSetCacheMode		Proc	Export
-@saveRegs	REG		d0/d1
-@cacheBit	EQU		6						; C bit for 851/030, CM[1] for 040 (CM[0] untouched)
-@cm0bit		EQU		5						; CM[0] bit in 040 page descriptor
-
-			movem.l	@saveRegs,-(sp)			; save registers
-			tst.b	d4						; check the cache inhibit flag
-			beq.s	@enableCaching			; if clear, enable caching for the page
-			move.l	(a0),d1					; get page desc (forces serialization on 040)	<T7>
-			bset.l	#@cacheBit,d1			; inhibit caching
-			bclr.l	#@cm0bit,d1				; make it non-serialized						<T7>
-			move.l	d1,(a0)					; update page descriptor
-			bra.s	@exit
-@enableCaching
-			clr.l	d1						; clear 68040 mask								<T7>
-			bfextu	CacheFlags{31-bCopybackMode:1},d1	; get current cache mode			<T7>
-			lsl.l	#@cm0bit,d1				; make a mask for a 68040 page descriptor		<T7>
-			or.l	(a0),d1					; get page descriptor (forces copyback on 040)
-			bclr.l	#@cacheBit,d1			; enable caching
-			move.l	d1,(a0)					; update page descriptor
-@exit
-			movem.l	(sp)+,@saveRegs			; restore registers								<T3>
-			rts
-			EndProc
-
-
 ;-------------------------------------------------------------------
 ;
 ;	MMUFlushATC - Flush all entries in the MMU's Address Translation Cache
 ;
 ;-------------------------------------------------------------------
 MMUFlushATC	Proc	Export
-			cmpi.b	#EMMU1,MMUType			; do we have an Emulated MMU?
-			beq.s	@exit					; -> Yes, do nothing							<SM17>
-			cmp.b	#PMMU851,MMUType		; do we have at least a 68851 PMMU ?
-			blo.s	@exit					; if not, we're done
-			cmp.b	#PMMU040,MMUType		; do we have an 040 PMMU?
-			beq.s	@handle040				; if so, use 040 PFLUSHA
-			pflusha							; use 851 & 030 PFLUSHA
-@exit
-			rts								; done
-@handle040
-			MACHINE	MC68040
-			pflusha							; flush the ATC
-			MACHINE	MC68030
 			rts
 			EndProc
 
diff --git a/OS/IoPrimitives/ADBPrimitives.a b/OS/IoPrimitives/ADBPrimitives.a
--- a/OS/IoPrimitives/ADBPrimitives.a
+++ b/OS/IoPrimitives/ADBPrimitives.a
@@ -42,7 +42,6 @@
 			PRINT	OFF
 			LOAD	'StandardEqu.d'
 			INCLUDE	'HardwarePrivateEqu.a'
-			INCLUDE	'SoundPrivate.a'
 			INCLUDE	'UniversalEqu.a'
 		IF PwrMgrADB THEN
 			INCLUDE	'PowerPrivEqu.a'
@@ -81,6 +80,7 @@ ADBPrimitives PROC	EXPORT
 
 		IF ViaADB THEN
 			EXPORT	ViaADBTable
+			DC.W	0									; flags
 			DC.W	(VIATableEnd-ViaADBTable)/4			; number of entries
 ViaADBTable
 			DC.L	VIAInitADB-ViaADBTable				; ADB initialization
@@ -95,6 +95,7 @@ VIATableEnd
 
 		IF PwrMgrADB THEN
 			EXPORT	PMgrADBTable
+			DC.W	0									; flags
 			DC.W	(PMGRTableEnd-PMgrADBTable)/4		; number of entries
 PMgrADBTable
 			DC.L	PMgrInitADB-PMgrADBTable			; ADB initialization
@@ -104,11 +105,24 @@ PMgrADBTable
 			DC.L	PMgrDebugPoll-PMgrADBTable			; DebugUtil ADB polling
 			DC.L	0									; not used
 PMGRTableEnd
+
+			EXPORT	PMgrADBTable2
+			DC.W	0									; flags
+			DC.W	(PMGRTableEnd2-PMgrADBTable2)/4		; number of entries
+PMgrADBTable2
+			DC.L	PMgrInitADB-PMgrADBTable2			; ADB initialization
+			DC.L	PMgrEnableKbdNMI-PMgrADBTable2		; not used
+			DC.L	0									; not used
+			DC.L	0									; not used
+			DC.L	PMgrDebugPoll2-PMgrADBTable2		; DebugUtil ADB polling
+			DC.L	0									; not used
+PMGRTableEnd2
 		ENDIF
 
 
 		IF hasEgret THEN
 			EXPORT	EgretADBTable
+			DC.W	0									; flags
 			DC.W	(EgretTableEnd-EgretADBTable)/4		; number of entries
 EgretADBTable
 			DC.L	EgretInitADB-EgretADBTable			; ADB initialization
@@ -120,6 +134,7 @@ EgretADBTable
 EgretTableEnd
 
 			EXPORT	CudaADBTable
+			DC.W	0									; flags
 			DC.W	(CudaTableEnd-CudaADBTable)/4		; number of entries
 CudaADBTable
 			DC.L	EgretInitADB-CudaADBTable			; ADB initialization
@@ -132,32 +147,43 @@ CudaTableEnd
 		ENDIF
 
 
-		IF IopADB THEN
-			EXPORT	IOPADBTable
-			DC.W	(IOPTableEnd-IOPADBTable)/4			; number of entries
-IOPADBTable
-			DC.L	IOPInitADB-IOPADBTable				; ADB initialization
-			DC.L	0									; not used
-			DC.L	IOPRunKBD-IOPADBTable				; DebugUtil enter
-			DC.L	0									; not used
-			DC.L	IOPRunKBD-IOPADBTable				; DebugUtil ADB polling
-			DC.L	0									; not used
-IOPTableEnd
+			EXPORT	AlphaADBTable
+			DC.W	0								; flags
+			DC.W	(AlphaTableEnd-AlphaADBTable)/4	; number of entries
+AlphaADBTable
+			DC.L	AlphaInitADB-AlphaADBTable		; ADB initialization
+			DC.L	0								; not used
+			DC.L	AlphaDebugEnter-AlphaADBTable	; DebugUtil enter
+			DC.L	AlphaDebugExit-AlphaADBTable	; DebugUtil exit
+			DC.L	AlphaDebugPoll-AlphaADBTable	; DebugUtil ADB polling
+			DC.L	0								; not used
+AlphaTableEnd
 
-		  IF hasOrwell THEN								;											<H2>
-			EXPORT	QuadraADBTable
-			DC.W	(QuadraADBTableEnd-QuadraADBTable)/4; number of entries
-QuadraADBTable
-			DC.L	IOPInitADB-QuadraADBTable			; ADB initialization
-			DC.L	0									; not used
-			DC.L	IOPRunKBD-QuadraADBTable			; DebugUtil enter
-			DC.L	0									; not used
-			DC.L	QuadraDebugPoll-QuadraADBTable		; DebugUtil ADB polling
-			DC.L	QuadraCheckSecure-QuadraADBTable	; check if keyswitch is in SECURE position
-QuadraADBTableEnd
-		  ENDIF
-		ENDIF
 
+			EXPORT	DummyADBTable
+			DC.W	0								; flags
+			DC.W	(DummyTableEnd-DummyADBTable)/4	; number of entries
+DummyADBTable
+			DC.L	DummyInitADB-DummyADBTable		; ADB initialization
+			DC.L	0								; not used
+			DC.L	0								; DebugUtil enter
+			DC.L	0								; DebugUtil exit
+			DC.L	0								; DebugUtil ADB polling
+			DC.L	0								; not used
+DummyTableEnd
+
+
+			EXPORT	BetaADBTable
+			DC.W	0								; flags
+			DC.W	(BetaTableEnd-BetaADBTable)/4	; number of entries
+BetaADBTable
+			DC.L	BetaInitADB-BetaADBTable		; ADB initialization
+			DC.L	0								; not used
+			DC.L	BetaDebugEnter-BetaADBTable		; DebugUtil enter
+			DC.L	BetaDebugExit-BetaADBTable		; DebugUtil exit
+			DC.L	BetaDebugPoll-BetaADBTable		; DebugUtil ADB polling
+			DC.L	0								; not used
+BetaTableEnd
 
 
 		IF ViaADB THEN
@@ -521,10 +547,8 @@ VIAReqDone	MOVE.B	FDBAuFlag(A3),D0		; get the flags
 ;________________________________________________________________________________________
 
 VIADebugPoll
-			JSR		([jCacheFlush])			; Temporary “fix” so that MacsBug works on Q700s. <SM4>
 EgretDebugPoll
 			MOVEA.L	VIA,A1					; point to the VIA
-		eieioSTP
 			BTST	#ifSR,vIFR(A1)			; is the shift register full?
 		eieioSTP
 			BEQ.S	@PollDone				; -> no, just return
@@ -608,7 +632,6 @@ PMgrEnableKbdNMI
 
 PMgrStartReq
 			MOVEA.L	VIA,A1					; point to the base of VIA1
-		eieioSTP
 			MOVE.B	#(0<<ifIRQ)|\
 					 (1<<ifCB1),vIER(A1)	;  and disable the interrupt since it's set
 
@@ -660,7 +683,6 @@ PMgrStartReq
 			_PmgrOp							; send the request to the PMGR
 @DontCall	LEA		pmRBuffer+4+12(SP),SP	; clean up the stack
 
-		eieioSTP
 			MOVE.B	#(1<<ifIRQ)|\
 					 (1<<ifCB1),vIER(A1)	; re-enable PMGR interrupts
 		eieioSTP
@@ -755,7 +777,6 @@ PMgrReqDone	MOVEA.L	ADBBase,A3				; point to ADB globals
 
 PMgrDebugPoll
 			MOVEA.L	VIA,A1					; point to the VIA
-		eieioSTP
 			BTST	#ifCB1,vIFR(A1)			; does the PMgr have some data?
 		eieioSTP
 			BEQ.S	@PollDone				; -> no, just return
@@ -763,6 +784,31 @@ PMgrDebugPoll
 @PollDone	RTS								;  and call the interrupt handler
 
 
+;________________________________________________________________________________________
+;
+; Routine:	PMgrDebugPoll2
+;
+; Inputs:	none
+;
+; Outputs:	none
+;
+; Trashes:	A1
+;
+; Function:	DebugUtil code to check if ADB data is available
+;________________________________________________________________________________________
+
+PMgrDebugPoll2
+			MOVE.L	VIA,D3					; point to the VIA
+			SUB.L	#$16000,D3				; mysterious data check, cf above
+			MOVE.L	D3,A1
+			MOVE.B	$59(A1),D3
+			AND.B	#2,D3
+		eieioSTP
+			BNZ.S	@PollDone				; -> no data, just return
+			MOVE.L	Lvl1DT+(4*ifCB1),-(SP)	; get the handler address
+@PollDone	RTS								;  and call the interrupt handler
+
+
 		ENDIF								; {PwrMgrADB}
 
 
@@ -850,14 +896,10 @@ EgretStartReq
 
 @ImplicitCompleted
 			MOVEQ	#(1<<EgSRQ),D3			; mask to test for SRQ pending
-		eieioSTP
 			AND.B	(A1)+,D3
-		eieioSTP
 			NEG.L	D3						; set bit 31 if SRQ pending
-		eieioSTP
 			MOVE.B	(A1)+,D3				; get the ADB command byte
 			MOVEQ	#0,D2					; zero extend the length
-		eieioSTP
 			MOVE.W	D0,D2
 			MOVEA.L	A1,A2					; get the buffer pointer
 			BSR		@FillInVars				; setup A3 and ADB globals for ADB Parser
@@ -907,6 +949,11 @@ EgretStartReq
 ;	If it does not, force Egret to poll the mouse as the MRU device and keyboard as the LRU device.
 ;	This fixes an Egret bug.
 
+			MOVE.L	#EgretFWMask,D1			; don't do this hack for a Cuda!
+			AND.L	UnivROMFlags,D1
+			CMP.L	#Cuda,D1
+			BEQ.S	@ExpDone
+
 			MOVE.W	Devmap(A3),D1			; get the ADB device Bitmap
 			btst.l	D0,D1					; does this device exist?
 			BNE.S	@ExpDone				; -> yes, done
@@ -973,8 +1020,7 @@ CudaDebugEnter
 ;________________________________________________________________________________________
 
 EgretDebugEnter
-			MOVEQ	#0,D1					; turn off mode 3 clock data packets
-			BRA.S	EgretDebugCommon
+			RTS
 
 
 ;________________________________________________________________________________________
@@ -1012,17 +1058,6 @@ CudaDebugExit
 ;________________________________________________________________________________________
 
 EgretDebugExit
-			MOVEQ	#Mode3Clock,D1			; turn on mode 3 clock data packets
-EgretDebugCommon
-			MOVEQ	#EgretPBSize/2-1,D0
-@ClearPB	CLR.W	-(SP)					; zero all fields in the parameter block
-			DBRA	D0,@ClearPB				; (forces mode 0 and no completion vector)
-			MOVEA.L	SP,A0					; point to the parameter block
-			MOVE.W	#(pseudoPkt<<8)+\
-					 (Wr1SecMode<<0),pbCmdType(A0)	; set up the packet type and command
-			MOVE.B	D1,pbParam(A0)			; turn on/off Mode 3 clock data packets
-			_EgretDispatch					; turn on/off one-second interrupts
-			LEA		EgretPbSize(SP),SP		; clean up the stack
 			RTS
 
 
@@ -1058,232 +1093,633 @@ EgretDebugPDM
 
 
 
-		IF IopADB THEN
-;••••••••••••••••••••••••••••••••••••••••• IOP ••••••••••••••••••••••••••••••••••••••••••
+		IF 1 THEN
+;•••••••••••••••••••••••••••••••••••• Alpha •••••••••••••••••••••••••••••••••••••
 
-			WITH	IOPRequestInfo
 
-			IMPORT	IOPInterrupt
+AlphaNotSureWhatThisIs
+                move.b  ([ExpandMem],$2A0),d3
+                cmpi.b  #$FF,d3
+                beq.s   @return
+                movea.l #$12345678,a0
+                cmpa.l  a0,a1
+                beq.s   @normv
+                movea.l a1,a0
+                _RmvTime
+@normv
+                movem.l d4-d7/a4-a6,-(sp)
+                movea.l ADBBase,a3
+                moveq   #2,d2
+                moveq   #0,d3
+                move.b  ([ExpandMem],$2A0),d3
+                ror.w   #8,d3
+                move.b  #$FF,d3
+                move.w  d3,-(sp)
+                movea.l sp,a2
+                moveq   #0,d3
+                move.b  ([ExpandMem],$2A1),d3
+                ori.l   #$80000000,d3
+                bsr.l   IMPLICITREQUESTDONE
+                lea     2(sp),sp
+                move.b  #$FF,([ExpandMem],$2A0)
+                movem.l (sp)+,d4-d7/a4-a6
+@return
+                rts
 
 
-;________________________________________________________________________________________
-;
-; Routine:	IOPInitADB
-;
-; Inputs:	A3	-	pointer to ADBBase
-;
-; Outputs:	
-;
-; Trashes:	A0,A1
-;
-; Function:	initializes the ADB Manager for IOP based ADB
-;________________________________________________________________________________________
 
-IOPInitADB	LEA		IOPStartReq,A0			; setup the procedure to start an ADB request
-			MOVE.L	A0,StartReqProc(A3)
+AlphaInitADB
+
+                lea     AlphaStartReq,a0
+                move.l  a0,StartReqProc(a3)
+                movea.l ([$68FFEFD0],$30),a0 ; HWInfo.ADB_Base
+                move.l  a0,DeviceBase(a3)
+                tst.l   a0
+                beq.w   @return
+                move.b  #$C,$100(a0)
+                eieioSTP
+
+
+                move.l  a1,-(sp)
+
+                lea     sub_72C6,a0
+                suba.l  a1,a1
+                moveq   #0,d0
+                move.w  ([$68FFEFD0],$84),d0 ; HWInfo.ADBIntVect
+
+                movem.l d1/a2,-(sp)
+                movea.l ([ExpandMem],$210),a2
+                lea     8(a2),a2
+                moveq   #$40,d1
+@loc_70BE
+                cmp.w   $18(a2),d0
+                beq.s   @loc_70CE
+                OPT NONE
+                adda.w	#32,a2
+                OPT ALL
+                dbra    d1,@loc_70BE
+                bra.s   @loc_70D4
+@loc_70CE
+                move.l  a0,(a2)
+                move.l  a1,4(a2)
+@loc_70D4
+                movem.l (sp)+,d1/a2
 
-;	initialize the XmtRequest message (all other fields remain zero)
-		eieioSTP
-			MOVE.B	#ADBIopNum,XmtRequest.irIOPNumber(A3)
-		eieioSTP
-			MOVE.B	#IOPRequestInfo.irSendXmtMessage,XmtRequest.irRequestKind(A3)
-		eieioSTP
-			MOVE.B	#ADBMsgNum,XmtRequest.irMsgNumber(A3)
-		eieioSTP
-			LEA		XmtMsg(A3),A0			; get pointer to message buffer
-		eieioSTP
-			MOVE.L	A0,XmtRequest.irMessagePtr(A3)
-		eieioSTP
+                movem.l d0-d2/a0,-(sp)
+                movea.l ([$68FFEFD0],$18),a0
+                tst.l   a0
+                bne.s   @loc_7120
+                movea.l ([$68FFEFF0],$100),a0
+                move.l  #$80000000,d1
+                cmpi.l  #$1F,d0
+                bgt.s   @loc_710E
+                ror.l   d0,d1
+                or.l    d1,$14(a0)
+                eieioSTP
+                bra.w   @loc_7136
+@loc_710E
+                subi.l  #$20,d0
+                ror.l   d0,d1
+                or.l    d1,4(a0)
+                eieioSTP
+                bra.w   @loc_7136
+@loc_7120
+                adda.l  #$10000,a0
+                lsl.l   #5,d0
+                move.l  (a0,d0.w),d1
+                bclr    #7,d1
+                move.l  d1,(a0,d0.w)
+                eieioSTP
+@loc_7136
+                movem.l (sp)+,d0-d2/a0
 
-;	initialize the RcvRequest message (all other fields remain zero)
+                movea.l (sp)+,a1
 
-		eieioSTP
-			MOVE.B	#ADBIopNum,RcvRequest.irIOPNumber(A3)
-		eieioSTP
-			MOVE.B	#IOPRequestInfo.irWaitRcvMessage,RcvRequest.irRequestKind(A3)
-		eieioSTP
-			MOVE.B	#ADBMsgNum,RcvRequest.irMsgNumber(A3)
-		eieioSTP
-			MOVE.B	#ADBMsg.ADBMsgSize,RcvRequest.irMessageLen(A3)
-		eieioSTP
-			LEA		RcvMsg(A3),A0			; get pointer to message buffer
-		eieioSTP
-			MOVE.L	A0,RcvRequest.irMessagePtr(A3)
-		eieioSTP
-			MOVE.L	A0,RcvRequest.irReplyPtr(A3)
-		eieioSTP
-			LEA		IOPReqDone,A0			; get handler pointer
-		eieioSTP
-			MOVE.L	A0,RcvRequest.irHandler(A3)
-		eieioSTP
-			LEA		RcvRequest(A3),A0		; setup pointer to param block
-		eieioSTP
-			_IOPMsgRequest					; install the Rcv message handler
-		eieioSTP
-			MOVE.B	#IOPRequestInfo.irSendRcvReply,RcvRequest.irRequestKind(A3)
-		eieioSTP
-			RTS
+                movea.l DeviceBase(a3),a0
+                clr.b   $E0(a0)
+                eieioSTP
+                bset    #0,$A0(a0)
+                eieioSTP
+@return         rts
 
 
 ;________________________________________________________________________________________
 ;
-; Routine:	IOPStartReq
+; Routine	AlphaStartReq
 ;
-; Inputs:	A2	-	pointer to transmit data buffer
+; Inputs	A2	-	pointer to transmit data buffer
 ;			A3	-	pointer to ADBBase
 ;			D2	-	number of bytes of transmit data
 ;			D3	-	command byte (bits 0-7) + implicit flag (bit 31)
 ;
-; Outputs:	A3	-	pointer to ADBBase
-;
-; Trashes:	A0,A1,A2,D0,D1,D2
-;
-; Function:	sends an ADB request to the IOP and asynchronously waits for a reply
-;________________________________________________________________________________________
-
-IOPStartReq	MOVEQ	#ADBMsg.ADBData-ADBMsg+2,D0	; length of msg preceeding data +2 for implicit
-			ADD.B	D2,D0						; d0 := length of message buffer
-		eieioSTP
-			BCLR	#fDBUseRcvMsg,fDBAuFlag(A3)	; see which buffer/message to use
-		eieioSTP
-			BNE.S	@useRcv						; if rcv available, use it
-
-@useXmt		LEA		XmtRequest(A3),A0		; get the iop xmt request param block
-			LEA		XmtMsg(A3),A1			; use the xmt message buffer
-		eieioSTP
-			MOVE.B	D0,irMessageLen(A0)		; setup the message length
-		eieioSTP
-			BRA.S	@fillInReq				; fill in the remaining fields and exit
-
-@useRcv		LEA		RcvRequest(A3),A0		; get the iop rcv request param block
-			LEA		RcvMsg(A3),A1			; use the rcv message buffer
-		eieioSTP
-			MOVE.B	D0,irReplyLen(A0)		; setup the reply length
-		eieioSTP
-
-@fillInReq	
-		eieioSTP
-			MOVE.W	#(((1<<PollEnable)\		; setup ADBMsg.Flags, enable polling, assume implicit
-					+(1<<SetPollEnables))<<8)\	; indicate that DevMap is being passed
-					+2,Flags(A1)			; setup ADBMsg.DataCount = 2 (DevMap is 2 bytes long)
-		eieioSTP
-			TST.L	D3						; see if implicit
-		eieioSTP
-			BMI.S	@implicit				; if implicit, ADBCmd is ignored, send DevMap
-
-		eieioSTP
-			CLR.W	Flags(A1)				; setup ADBMsg.Flags, implicit, idle, DataCount
-		eieioSTP
-			BSET	#fDBExpActive,fDBAuFlag(A3)	; remember that an explicit command has been sent
-		eieioSTP
-			BNE.S	@SendToIOP				; if it had already been sent, just go idle
-
-		eieioSTP
-			MOVE.B	#(1<<ExplicitCmd),(A1)+	; setup ADBMsg.Flags, explicit command
-		eieioSTP
-			MOVE.B	D2,(A1)+				; setup ADBMsg.DataCount
-		eieioSTP
-			MOVE.B	D3,(A1)+				; setup ADBMsg.ADBCmd
-		eieioSTP
-			BRA.S	@copyStart				; start the copy
-		eieioSTP
-@copyLoop	
-		eieioSTP
-			MOVE.B	(A2)+,(A1)+				; copy into the message buffer one byte at a time
-		eieioSTP
-@copyStart	
-		eieioSTP
-			DBRA	D2,@copyLoop			; loop for all bytes
-		eieioSTP
-
-@SendToIOP	MOVEA.L	jIOPMsgRequest,A2		; get the OSTrap table entry
-			JMP		(A2)					; _IOPMsgRequest send the message (Asynchronously), return
-
-@implicit	
-		eieioSTP
-			MOVE.W	DevMap(A3),ADBData(A1)	; pass the Polling Enable bit map
-		eieioSTP
-			BRA.S	@SendToIOP				; pass it to the IOP
-
-
-;________________________________________________________________________________________
-;
-; Routine:	IOPReqDone
-;
-; Inputs:	A2	-	pointer to receive data buffer
+; Outputs	A1	-	pointer to base of VIA1
 ;			A3	-	pointer to ADBBase
-;			D2	-	number of bytes of receive data
-;			D3	-	command byte (bits 0-7) + SRQ flag (bit 31)
 ;
-; Outputs:	A3	-	pointer to ADBBase
-;
-; Trashes:	A0,A1,A2,A3,D0,D1,D2,D3
-;
-; Function:	completion routine for servicing messages received from the IOP
+; Function	starts an ADB request using the VIA interface to the ADB transceiver processor
 ;________________________________________________________________________________________
 
-IOPReqDone	MOVEA.L	ADBBase,A3			; point to ADB globals in low memory
-		eieioSTP
-			MOVE.B	RcvMsg.Flags(A3),D0	; get flags telling what interrupt occurred
-			MOVEQ	#(1<<SRQReq),D3		; mask to test for SRQ pending
-			AND.B	D0,D3				; isolate the bit
-			NEG.L	D3					; set bit 31 if SRQ pending
-		eieioSTP
-			MOVE.B	RcvMsg.ADBCmd(A3),D3; get command that completed
-		eieioSTP
-
-;	keep the ADB Parser program happy by updating the following variables
-;	They are not used by this implementation, but we fill them in with approximate
-;	values to make the tool happy.
-
-		eieioSTP
-			MOVE.B	D3,fDBCmd(A3)		; last ADB command
-		eieioSTP
-			MOVE.B	D3,pollCmd(A3)		; assume that it was a poll command
-		eieioSTP
-			MOVE.B	D2,D2				; copy the command zzz should this be move.b d3,d2?
-			LSR.B	#4,D2				; get the address
-		eieioSTP
-			MOVE.B	D2,pollAddr(A3)		; assume that it was a poll address
-
-			MOVEQ	#0,D2				; zero extend the length
-		eieioSTP
-			MOVE.B	RcvMsg.DataCount(A3),D2	; get length of receive data
-		eieioSTP
-			LEA		RcvMsg.ADBData(A3),A2	; point to the data buffer
-		eieioSTP
-			BSET	#fDBUseRcvMsg,fDBAuFlag(A3)	; use the receive buffer for the reply
-			BTST	#ExplicitCmd,D0		; see if explicit or implicit
-			BEQ.L	ImplicitRequestDone	; if implicit
-		eieioSTP
-			BCLR	#fDBExpActive,fDBAuFlag(A3)	; remember that it has completed
-		eieioSTP
-			BRA.L	ExplicitRequestDone	; if explicit
+
+AlphaStartReq   movea.l DeviceBase(a3),a1
+                tst.l   a1
+                bnz.s   @have_adb_hardware
+                moveq   #0,d2
+                movea.l d2,a2
+                bset    #7,fDBAuFlag(a3)
+                tst.l   d3
+                bmi.s   @earlyreturn ; implicit request with no hardware
+                bra.l   EXPLICITREQUESTDONE
+
+@have_adb_hardware
+                tst.l   d3
+                bpl.s   loc_71B8
+                btst    #2,fDBAuFlag(a3)
+                bne.s   @earlyreturn
+                bclr    #6,fDBAuFlag(a3)
+                beq.s   @loc_7194
+                move.b  PollAddr(a3),d3
+                lsl.b   #4,d3
+                ori.b   #$C,d3
+                moveq   #0,d2
+                bset    #1,fDBAuFlag(a3)
+                bra.s   loc_71B8
+@loc_7194
+                moveq   #0,d0
+                move.w  DevMap(a3),d0
+                move.b  d0,$100(a1)
+                eieioSTP
+                lsr.w   #8,d0
+                move.b  d0,$F0(a1)
+                eieioSTP
+                bset    #7,fDBAuFlag(a3)
+                bset    #0,$E0(a1)
+                eieioSTP
+
+@earlyreturn    rts
+
+loc_71B8
+
+                btst    #2,fDBAuFlag(a3)
+                bne.s   loc_7204
+                lea     $1A1(a3),a0
+                andi.w  #$FF,d2
+                addq.b  #1,d2
+                move.b  d2,(a0)+
+                move.b  d3,(a0)+
+                subq.b  #2,d2
+                bmi.s   loc_71D8
+
+loc_71D2
+                move.b  (a2)+,(a0)+
+                dbra    d2,loc_71D2
+
+loc_71D8
+                bset    #0,$D0(a1)
+                eieioSTP
+                bclr    #0,$E0(a1)
+                eieioSTP
+                bclr    #7,fDBAuFlag(a3)
+
+loc_71EE
+                btst    #1,(a1)
+                bne.s   loc_71FC
+                btst    #0,(a1)
+                beq.s   loc_71EE
+                rts
+
+loc_71FC
+                bset    #2,fDBAuFlag(a3)
+                bsr.s   sub_7242
+loc_7204
+
+; Spin for 2ms
+                moveq   #2,d1
+@two_msec       move.w  TimeDBRA,d0
+@one_msec       btst    #0,(a1)
+                bne.s   locret_7240
+                dbra    d0,@one_msec
+                dbra    d1,@two_msec
+
+
+                moveq   #0,d2
+                move.l  d2,d3
+                move.b  $1A2(a3),d3
+                movea.l d2,a2
+                bclr    #2,fDBAuFlag(a3)
+                btst    #1,fDBAuFlag(a3)
+                beq.l   EXPLICITREQUESTDONE
+                bclr    #1,fDBAuFlag(a3)
+                bra.l   IMPLICITREQUESTDONE
+
+locret_7240
+                rts
+
+
+
+sub_7242
+
+; FUNCTION CHUNK AT ROM0002B47E SIZE 00000036 BYTES
+
+                clr.b   $C0(a1)
+                eieioSTP
+                move.b  d3,d0
+                andi.b  #$F,d0
+                bne.s   loc_7282
+                bclr    #0,$D0(a1)
+                eieioSTP
+                bclr    #1,(a1)
+                eieioSTP
+                bset    #3,$D0(a1)
+                eieioSTP
+
+loc_7266
+                btst    #3,$D0(a1)
+                bne.s   loc_7266
+                lea     4(sp),sp
+
+loc_7272
+                moveq   #0,d2
+                movea.l d2,a2
+                bclr    #2,fDBAuFlag(a3)
+                bra.l   EXPLICITREQUESTDONE
+
+loc_7282
+                lea     $1A1(a3),a2
+                moveq   #0,d0
+                move.b  (a2)+,d0
+                move.b  d0,$B0(a1)
+                eieioSTP
+                subq.b  #1,d0
+                lea     (a1),a0
+
+loc_7294
+                lea     $10(a0),a0
+                move.b  (a2)+,(a0)
+                eieioSTP
+                dbra    d0,loc_7294
+                move.b  d3,d0
+                andi.b  #$C,d0
+                cmpi.b  #$C,d0
+                bne.s   loc_72B0
+                moveq   #6,d0
+                bra.s   loc_72B8
+
+loc_72B0
+                moveq   #2,d0
+                lea     loc_7272,a0
+                move.l  a0,(sp)
+
+loc_72B8
+                move.b  d0,$D0(a1)
+                eieioSTP
+                bclr    #1,(a1)
+                eieioSTP
+                rts
+; End of function sub_7242
+
+
+
+
+sub_72C6
+
+
+; FUNCTION CHUNK AT ROM0002B47E SIZE 00000036 BYTES
+
+                movea.l ADBBase,a3
+                movea.l DeviceBase(a3),a1
+                tst.l   a1
+                beq.s   locret_72DC
+                btst    #0,(a1)
+                bne.s   loc_72DE
+                clr.b   (a1)
+                eieioSTP
+
+locret_72DC
+                rts
+
+loc_72DE
+                moveq   #0,d3
+                move.l  d3,d1
+                move.b  $10(a1),d3
+                move.b  $C0(a1),d1
+                eieioSTP
+                clr.b   $C0(a1)
+                eieioSTP
+                btst    #0,d1
+                bne.s   loc_7300
+                btst    #1,d1
+                beq.s   loc_731C
+                bra.s   loc_7308
+
+loc_7300
+                move.b  d3,fDBCmd(a3)
+                move.b  d3,$16E(a3)
+
+loc_7308
+                clr.b   $163(a3)
+                moveq   #$10,d2
+                suba.l  a2,a2
+                and.b   $B0(a1),d2
+                clr.b   $B0(a1)
+                eieioSTP
+                bra.s   loc_7386
+
+loc_731C
+                lea     $1AE(a3),a2
+                moveq   #$1F,d2
+                and.b   $B0(a1),d2
+                move.b  d3,(a2)+
+                move.b  d3,d0
+                lsr.b   #4,d0
+                andi.l  #$F,d0
+                btst    #5,fDBFlag(a3)
+                bne.s   loc_7354
+                btst    #2,d1
+                beq.s   loc_7354
+                bset    #6,fDBAuFlag(a3)
+                move.w  DevMap(a3),d1
+
+loc_734A
+                addq.b  #1,d0
+                andi.b  #$F,d0
+                btst    d0,d1
+                beq.s   loc_734A
+
+loc_7354
+                move.b  d0,PollAddr(a3)
+                moveq   #$10,d1
+                and.b   d2,d1
+                bclr    #4,d2
+                clr.b   $163(a3)
+                subq.b  #1,d2
+                move.b  d2,$163(a3)
+                move.b  d2,d0
+                or.b    d1,d2
+                subq.b  #1,d0
+                bmi.s   loc_7386
+                movea.l a2,a0
+                move.l  a1,d1
+                lea     $20(a1),a1
+
+loc_737A
+                move.b  (a1),(a0)+
+                lea     $10(a1),a1
+                dbra    d0,loc_737A
+                movea.l d1,a1
+
+loc_7386
+                bclr    #0,(a1)
+                eieioSTP
+                bclr    #4,d2
+                bne.l   IMPLICITREQUESTDONE
+                bclr    #2,fDBAuFlag(a3)
+                bclr    #1,fDBAuFlag(a3)
+                bne.l   IMPLICITREQUESTDONE
+                bra.l   EXPLICITREQUESTDONE
+; End of function sub_72C6
+
+
+
+AlphaDebugPoll
+
+                movea.l ADBBase,a1
+                movea.l DeviceBase(a1),a1
+                tst.l   a1
+                beq.s   locret_73C4
+                btst    #0,(a1)
+                beq.s   locret_73C4
+                pea     sub_72C6
+
+locret_73C4
+
+                rts
+
+
+AlphaDebugEnter
+
+                movea.l ADBBase,a0
+                movea.l DeviceBase(a0),a1
+                tst.l   a1
+                beq.s   locret_73E2
+                bset    #0,$E0(a1)
+                eieioSTP
+                bne.s   locret_73E2
+                bset    #6,fDBAuFlag(a0)
+
+locret_73E2
+
+                rts
+
+AlphaDebugExit
+
+                movea.l ADBBase,a0
+                movea.l DeviceBase(a0),a1
+                tst.l   a1
+                beq.s   locret_7400
+                bclr    #6,fDBAuFlag(a0)
+                beq.s   locret_7400
+                bclr    #0,$E0(a1)
+                eieioSTP
+
+locret_7400
+
+                rts
+		ENDIF								; {1, Alpha}
+
+
+
+		IF 1 THEN
+;•••••••••••••••••••••••••••••••••••• Dummy •••••••••••••••••••••••••••••••••••••
 
 
 ;________________________________________________________________________________________
 ;
-; Routine:	IOPRunKBD
+; Routine:	DummyInitADB
+;________________________________________________________________________________________
+
+DummyInitADB
+                movea.l ADBBase,a3
+                lea     loc_7410,a0
+                move.l  a0,$130(a3)
+                rts
+loc_7410
+                moveq   #0,d2
+                movea.l d2,a2
+                tst.l   d3
+                bmi.s   locret_741E
+                bra.l   EXPLICITREQUESTDONE
+locret_741E
+                rts
+		ENDIF								; {1, Dummy}
+
+
+
+		IF 1 THEN
+;•••••••••••••••••••••••••••••••••••• Beta •••••••••••••••••••••••••••••••••••••
+
+
+;_______________________________________________________________________________________
 ;
-; Inputs:	
+; Routine:	BetaInitADB
+;
+; Inputs:	Does not assume that A3 points to ADBBase, because called from InitADB!
+;_______________________________________________________________________________________
+
+				export  BetaInitADB ; for direct ADB Manager call
+BetaInitADB
+                lea     loc_7560,a0
+                move.l  a0,([ExpandMem],$298)
+                lea     BetaADBTable,a0 ; yes, my parent table!
+                movea.l UnivInfoPtr,a1
+                suba.l  a1,a0
+                move.l  a0,$48(a1)
+                movea.l ADBBase,a3
+                bclr    #5,fDBFlag(a3)
+                lea     loc_744E,a0
+                move.l  a0,$130(a3)
+                rts
+
+loc_744E
+                movem.l d0-d3/a3-a4,-(sp)
+                tst.l   ([ExpandMem],$294)
+                beq.s   loc_746E
+                movea.l ([ExpandMem],$294),a1
+                jsr     (a1)
+                cmpi.l  #$FFFFFFFF,d0
+                bne.s   loc_74AC
+
+loc_746E
+                move.w  ([ExpandMem],$2A0),d0
+                cmpi.w  #$1234,d0
+                bne.s   loc_7486
+                movea.l ([ExpandMem],$2A0),a0
+                bra.s   loc_749C
+
+loc_7486
+                tst.l   ([ExpandMem],$29C)
+                beq.s   loc_74AC
+                movea.l ([ExpandMem],$29C),a1
+                moveq   #3,d0
+                jsr     (a1)
+
+loc_749C
+                movem.l (sp)+,d0-d3/a3-a4
+                tst.l   a0
+                beq.s   locret_74AA
+                movea.l ADBBase,a3
+                jsr     (a0)
+
+locret_74AA
+                rts
+
+loc_74AC
+
+                movea.l d0,a2
+                movem.l (sp)+,d0-d3/a3-a4
+                moveq   #0,d2
+                move.b  (a2)+,d2
+                bra.l   EXPLICITREQUESTDONE
+
+
+;_______________________________________________________________________________________
 ;
-; Outputs:	
+; Routine:	BetaDebugPoll
+;_______________________________________________________________________________________
+
+BetaDebugPoll
+                tst.l   ([ExpandMem],$290)
+                beq.s   loc_74D8
+                movem.l d1-d2/a0-a1,-(sp)
+                movea.l ([ExpandMem],$290),a1
+                jsr     (a1)
+                movem.l (sp)+,d1-d2/a0-a1
+
+loc_74D8
+                tst.l   ([ExpandMem],$29C)
+                beq.s   locret_74F8
+                movea.l ([ExpandMem],$29C),a1
+                moveq   #4,d0
+                jsr     (a1)
+                move.l  $10(a0),d0
+                beq.s   locret_74F8
+                adda.l  d0,a0
+                jsr     (a0)
+
+locret_74F8
+
+                rts
+
+
+;_______________________________________________________________________________________
 ;
-; Trashes:	
+; Routine:	BetaDebugEnter
+;_______________________________________________________________________________________
+
+BetaDebugEnter
+                tst.l   ([ExpandMem],$29C)
+                beq.s   locret_7530
+                movea.l ([ExpandMem],$29C),a1
+                moveq   #4,d0
+                jsr     (a1)
+                move.l  8(a0),d0
+                beq.s   loc_751A
+                adda.l  d0,a0
+                jsr     (a0)
+
+loc_751A
+                tst.l   ([ExpandMem],$29C)
+                beq.s   locret_7530
+                movea.l ([ExpandMem],$29C),a1
+                moveq   #1,d0
+                jsr     (a1)
+
+locret_7530
+
+                rts
+
+
+;_______________________________________________________________________________________
 ;
-; Function:	code to handle keyboard polling in a debugger
-;________________________________________________________________________________________
+; Routine:	BetaDebugExit
+;_______________________________________________________________________________________
+
+BetaDebugExit
+                tst.l   ([ExpandMem],$29C)
+                beq.s   locret_755E
+                movea.l ([ExpandMem],$29C),a1
+                moveq   #2,d0
+                jsr     (a1)
+                movea.l ([ExpandMem],$29C),a1
+                moveq   #4,d0
+                jsr     (a1)
+                move.l  $C(a0),d0
+                beq.s   locret_755E
+                adda.l  d0,a0
+                jsr     (a0)
 
-IOPRunKBD	MOVE.L	#(%00001000<<24)+\		; allow xmt msg 3
-					(%00001000<<16)+\		; allow rcv msg 3
-					(0<<8)+\				; this byte must be zero
-					1,d0					; ADB is on SWIM IOP (IOP 1)
-			BRA.L	IOPInterrupt			; go handle the interrupt
+locret_755E
 
+                rts
 
-			ENDWITH							; {IOPRequestInfo}
+loc_7560
+                movea.l #$12345678,a0
+                cmpa.l  a0,a1
+                beq.s   loc_758C
+                movea.l a1,a0
+                _RmvTime
+                movea.l ADBBase,a3
+                lea     $1AC(a3),a2
+                move.b  #2,(a2)+
+                move.b  #$35,(a2)+
+                move.b  #$FF,(a2)+
+                lea     $1AC(a3),a2
+                move.l  #$8000002C,d3
 
-		ENDIF								; {IopADB}
+loc_758C
+                movea.l ADBBase,a3
+                moveq   #0,d2
+                move.b  (a2)+,d2
+                bra.l   IMPLICITREQUESTDONE
+		ENDIF								; {1, Beta}
 
 
 
diff --git a/OS/IoPrimitives/ClockPRAMPrimitives.a b/OS/IoPrimitives/ClockPRAMPrimitives.a
--- a/OS/IoPrimitives/ClockPRAMPrimitives.a
+++ b/OS/IoPrimitives/ClockPRAMPrimitives.a
@@ -110,95 +110,30 @@ ClockPRAMPrimitives	PROC	EXPORT
 ;	PRAM and clock models, it should have a machine-specific table added below
 
 
-		IF hasVIAClock THEN
-			EXPORT	RTCClockPRAM
-			DC.W	0									; flags
-			DC.W	(RTCTableEnd-RTCClockPRAM)/4		; number of entries
-RTCClockPRAM
-			DC.L	RTCInitHW-RTCClockPRAM				; initialize the hardware (RAM-less)
-			DC.L	RTCWrProtOff-RTCClockPRAM			; write-enable PRAM (RAM-less)
-			DC.L	RTCWrProtOn-RTCClockPRAM			; write-protect PRAM (RAM-less)
-			DC.L	RTCRdXByte-RTCClockPRAM				; read PRAM byte (RAM-less)
-			DC.L	RTCWrXByte-RTCClockPRAM				; write PRAM byte (RAM-less)
-			DC.L	StandardXPramIO-RTCClockPRAM		; read/write PRAM byte[s] (no traps)		<H3>
-			DC.L	RTCXParam-RTCClockPRAM				; read/write PRAM byte[s] (trap-based)
-			DC.L	RTCReadTime-RTCClockPRAM			; read the clock (uses RAM)
-			DC.L	RTCWriteTime-RTCClockPRAM			; write to the clock (uses RAM)
-RTCTableEnd
-		ENDIF
+			IMPORT	NWReadNVRAM_C, NWWriteNVRAM_C, NWReadTime_C, NWWriteTime_C
 
+			EXPORT	NWClockPRAM
+			DC.W	0								; flags
+			DC.W	(NWTableEnd-NWClockPRAM)/4		; number of entries
+NWClockPRAM
+			DC.L	0								; not used
+			DC.L	0								; not used
+			DC.L	0								; not used
+			DC.L	NWRdXByte-NWClockPRAM			; read PRAM byte (RAM-less)
+			DC.L	NWWrXByte-NWClockPRAM			; write PRAM byte (RAM-less)
+			DC.L	StandardXPramIO-NWClockPRAM		; read/write PRAM byte[s] (no traps)		<H3>
+			DC.L	NWXParam-NWClockPRAM			; read/write PRAM byte[s] (trap-based)
+			DC.L	NWReadTime-NWClockPRAM			; read the clock (uses RAM)
+			DC.L	NWWriteTime-NWClockPRAM			; write to the clock (uses RAM)
+			DC.L	NWReadNVRAM_C-NWClockPRAM		; direct path to C-based NVRAM access
+			DC.L	NWWriteNVRAM_C-NWClockPRAM		; direct path to C-based NVRAM access
+NWTableEnd
 
-		IF hasPwrControls THEN
-			EXPORT	PMGRClockPRAM
-			DC.W	0									; flags
-			DC.W	(PMGRTableEnd-PMGRClockPRAM)/4		; number of entries
-PMGRClockPRAM
-			DC.L	0									; not used
-			DC.L	0									; not used
-			DC.L	0									; not used
-			DC.L	PMGRRdXByte-PMGRClockPRAM			; read PRAM byte (RAM-less)
-			DC.L	PMGRWrXByte-PMGRClockPRAM			; write PRAM byte (RAM-less)
-			DC.L	StandardXPramIO-PMGRClockPRAM		; read/write PRAM byte[s] (no traps)		<H3>
-			DC.L	PMGRXParam-PMGRClockPRAM			; read/write PRAM byte[s] (trap-based)
-			DC.L	PMGRReadTime-PMGRClockPRAM			; read the clock (uses RAM)
-			DC.L	PMGRWriteTime-PMGRClockPRAM			; write to the clock (uses RAM)
-PMGRTableEnd
-		ENDIF
 
 
-		IF hasEgret THEN
-			EXPORT	EgretClockPRAM
-			DC.W	0									; flags
-			DC.W	(EgretTableEnd-EgretClockPRAM)/4	; number of entries
-EgretClockPRAM
-			DC.L	0									; not used
-			DC.L	0									; not used
-			DC.L	0									; not used
-			DC.L	EgretRdXByte-EgretClockPRAM			; read PRAM byte (RAM-less)
-			DC.L	EgretWrXByte-EgretClockPRAM			; write PRAM byte (RAM-less)
-			DC.L	StandardXPramIO-EgretClockPRAM		; read/write PRAM byte[s] (no traps)		<H3>
-			DC.L	EgretXParam-EgretClockPRAM			; read/write PRAM byte[s] (trap-based)
-			DC.L	EgretReadTime-EgretClockPRAM		; read the clock (uses RAM)
-			DC.L	EgretWriteTime-EgretClockPRAM		; write to the clock (uses RAM)
-EgretTableEnd
+			WITH	EgretPB ; PMCommandRec
 
-			EXPORT	CudaClockPRAM
-			DC.W	0									; flags
-			DC.W	(CudaTableEnd-CudaClockPRAM)/4		; number of entries
-CudaClockPRAM
-			DC.L	0									; not used
-			DC.L	0									; not used
-			DC.L	0									; not used
-			DC.L	CudaRdXByte-CudaClockPRAM			; read PRAM byte (RAM-less)
-			DC.L	CudaWrXByte-CudaClockPRAM			; write PRAM byte (RAM-less)
-			DC.L	StandardXPramIO-CudaClockPRAM		; read/write PRAM byte[s] (no traps)		<H5>
-			DC.L	EgretXParam-CudaClockPRAM			; read/write PRAM byte[s] (trap-based)
-			DC.L	EgretReadTime-CudaClockPRAM			; read the clock (uses RAM)
-			DC.L	EgretWriteTime-CudaClockPRAM		; write to the clock (uses RAM)
-CudaTableEnd
-		ENDIF
 
-
-		IF hasProtectedPRAM THEN
-			EXPORT	NoPRAMClockPRAM
-			DC.W	0									; flags
-			DC.W	(NoPRAMTableEnd-NoPRAMClockPRAM)/4	; number of entries
-NoPRAMClockPRAM
-			DC.L	0									; not used
-			DC.L	0									; not used
-			DC.L	0									; not used
-			DC.L	NoPRAMRdXByte-NoPRAMClockPRAM		; read PRAM byte (RAM-less)
-			DC.L	NoPRAMWrXByte-NoPRAMClockPRAM		; write PRAM byte (RAM-less)
-			DC.L	NoPRAMXPramIO-NoPRAMClockPRAM		; read/write PRAM byte[s] (no traps)
-			DC.L	NoPRAMXParam-NoPRAMClockPRAM		; read/write PRAM byte[s] (trap-based)
-			DC.L	NoPRAMReadTime-NoPRAMClockPRAM		; read the clock (uses RAM)
-			DC.L	NoPRAMWriteTime-NoPRAMClockPRAM		; write to the clock (uses RAM)
-NoPRAMTableEnd
-		ENDIF
-
-
-
-		IF hasVIAClock | hasPwrControls | hasEgret | hasPowerMgr THEN	;							<H3>
 ;________________________________________________________________________________________
 ;
 ; Routine:	StandardXPramIO
@@ -218,8 +153,6 @@ NoPRAMTableEnd
 ;			each PRAM byte.
 ;________________________________________________________________________________________
 
-			IMPORT	ClkWPOff,RdXByte,WrXByte
-
 StandardXPramIO
 			MOVEM.L	D7/A4-A6,-(SP)
 
@@ -228,7 +161,7 @@ StandardXPramIO
 			BCLR	#31,D3					; read or write?
 			BEQ.S	@StartRead				; -> read
 
-			;BigBSR6	ClkWPOff,A5				; write-enable PRAM
+			BigBSR6	ClkWPOff,A5				; write-enable PRAM
 			BRA.S	@StartWrite
 
 @WriteLoop	
@@ -242,18 +175,19 @@ StandardXPramIO
 			BigBSR6	WrXByte,A5				; write a byte to PRAM
 			MOVEA.L	D7,A3					; (restore the buffer pointer)
 			ADDQ.W	#1,D3					; next byte
+			; Re-write-protect after each loop iteration: needed to flush some buffer?
+			MOVEA.L	A1,A6					; point to this machine's product info
+			ADDA.L	ProductInfo.ClockPRAMPtr(A6),A6	;  and get the address of its clock/PRAM table
+			MOVE.L	4*cpWrProtOn(A6),D0		; get the offset to the write-protect routine
+			BEQ.S	@ReprotectDone			; -> it's not supported for this implementation
+			LEA		@ReprotectDone,A5		; (simulate a BSR5)
+			ADDA.L	D0,A6					; calculate the routine's address
+			JMP		(A6)					;  and call it to turn on PRAM write-protect
+@ReprotectDone
 			MOVE	(SP)+,SR				; restore the status register
-			bsr.l	StdXPRAM2Patch			; call the patch
 @StartWrite	
 			SWAP	D3						; get the count
 			DBRA	D3,@WriteLoop			; -> keep looping until done
-			MOVEA.L	A1,A6					; point to this machine's product info
-			ADDA.L	ProductInfo.ClockPRAMPtr(A6),A6	;  and get the address of its clock/PRAM table
-			MOVE.L	4*cpWrProtOn(A6),D0		; get the offset to the write-protect routine
-			BEQ.S	@Done					; -> it's not supported for this implementation
-			;ADDA.L	D0,A6					; calculate the routine's address
-			;LEA		@Done,A5				; (simulate a BSR5)
-			;JMP		(A6)					;  and call it to turn on PRAM write-protect
 			bra.s	@Done					; we're done
 
 @ReadLoop	SWAP	D3						; get the PRAM address
@@ -268,1394 +202,266 @@ StandardXPramIO
 
 @Done		MOVEM.L	(SP)+,D7/A4-A6
 			RTS
-		ENDIF
 
 
+;________________________________________________________________________________________
+;
+; Routine:	NWXParam (old generic RTC code)
+;
+; Inputs:	A0	-	pointer to user's buffer
+;			D0	-	[number of bytes to transfer][starting PRAM address]
+;			D1	-	bit 12: 1=read, 0=write
+;
+; Outputs:	D0	-	result code
+;
+; Trashes:	A0,A1,A2,A3,D1,D2,D3
+;
+; Function:	reads/writes byte[s] from RTC-based paramter RAM
+;________________________________________________________________________________________
+
+NWXParam	MOVEA.L	A0,A3					; get the pointer to the caller's buffer
+			MOVEA.L	UnivInfoPtr,A1			; point to the ProductInfo table						<H3>
+			MOVEA.L	A1,A0					;  and to the decoder table								<H3>
+			ADDA.L	ProductInfo.DecoderInfoPtr(A0),A0
+			MOVE.L	D0,D3					; get the starting PRAM address and count
+			BTST	#12,D1					; is it a read or write?
+			BNE.S	@ItsRead
+			BSET	#31,D3					; mark it as a write
+
+@ItsRead	BSR.S	StandardXPramIO			; go transfer the PRAM bytes							<H3>
 
-		IF hasVIAClock THEN
-;••••••••••••••••••••••••••••••••••••••••• RTC ••••••••••••••••••••••••••••••••••••••••••
+			MOVEQ	#0,D0					; always return "no error"
+			RTS
 
-			IMPORT	ReadTime
 
 ;________________________________________________________________________________________
 ;
-; Routine:	RTCReadTime
+; Routine:	EgretWriteTime
+;
+; Inputs:	"Time" contains 32-bit quantity to write to clock
+;
+; Outputs:	D0	-	result code
+;
+; Trashes:	A0
+;
+; Function:	writes a new time value to the realtime clock
+;________________________________________________________________________________________
+
+EgretWriteTime
+			CLR.L	-(SP)					;  pbCompletion = nil
+			LEA		pbParam-pbCompletion(SP),SP
+			MOVE.L	Time,(SP)				;  pbParam = current time
+
+			MOVE.W	#(pseudopkt<<8)+\		;  pbCmdType = pseudo type
+					+(WrTime<<0),-(SP)		;  pbCmd = write time
+			MOVEA.L	SP,A0					; point to the parameter block
+			_EgretDispatch					; call Egret to read the time
+			LEA		EgretPBSize(SP),SP		; clean up the stack
+			RTS
+
+
+;______________________________________________________________________________________
+;
+; Routine:	ExpMgrXParam (new code, seems not to be used)
+;
+; Inputs:	A0	-	pointer to user's buffer
+;			D0	-	[number of bytes to transfer][starting PRAM address]
+;			D1	-	bit 12: 1=read, 0=write
+;
+; Outputs:	D0	-	result code
+;
+; Trashes:	A0,A1,A2,A3,D1,D2,D3
+;
+; Function:	reads/writes byte[s] from paramter RAM via the Expansion Manager
+;______________________________________________________________________________________
+
+			IMPORT	EXPANSIONBUSMGR_VEC0114, EXPANSIONBUSMGR_VEC0118
+
+ExpMgrXParam
+			MOVEM.L	D4-D7/A4,-(SP)
+			MOVE.L	D0,D4
+			ANDI.L	#$FFFF,D0
+			MOVE.L	D0,-(SP)
+			MOVE.L	D4,D0
+			SWAP	D0
+			ANDI.L	#$FFFF,D0
+			MOVE.L	D0,-(SP)
+			MOVE.L	A0,-(SP)
+
+			BTST	#12,D1
+			BNZ.S	@read
+@write		JSR		EXPANSIONBUSMGR_VEC0118
+			BRA.S	@endif
+@read		JSR		EXPANSIONBUSMGR_VEC0114
+@endif
+
+			OPT		NONE
+			ADDA.W	#12,SP
+			OPT		ALL
+			MOVEM.L	(SP)+,D4-D7/A4
+			RTS
+
+
+;______________________________________________________________________________________
+;
+; Routine:	NWRdXByte (glue for C code)
+;
+; Inputs:	D1	-	address of PRAM byte to read
+;			A1	-	pointer to ProductInfo record for this machine
+;			A2	-	VIA1 base address
+;			A3	-	return address
+;
+; Outputs:	D1	-	byte read from PRAM
+;			D0	-	???
+;
+; Function:	reads a byte from RTC partition of NewWorld NVRAM
+;______________________________________________________________________________________
+
+NWRdXByte
+			MOVE.L	D0,-(SP)
+			AND.L	#$FF,D1
+			MOVE.L	D1,-(SP)
+			BSR.L	NWReadNVRAM_C
+			ADDQ.L	#4,SP
+			MOVE.L	D0,D1
+			MOVE.L	(SP)+,D0
+			JMP		(A3)
+
+
+;_____________________________________________________________________________________
+;
+; Routine:	NWWrXByte (glue for C code)
+;
+; Inputs:	D1	-	address of PRAM byte to write
+;			D2	-	byte to write to PRAM
+;			A1	-	pointer to ProductInfo record for this machine
+;			A2	-	VIA1 base address
+;			A3	-	return address
+;
+; Outputs:	D0	-	???
+;
+; Function:	writes a byte to the RTC partition of NewWorld NVRAM
+;_____________________________________________________________________________________
+
+NWWrXByte
+			MOVE.L	D0,-(SP)		; argument: why D0?
+			AND.L	#$FF,D2
+			MOVE.L	D2,-(SP)		; argument: byte to write
+			AND.L	#$FF,D1
+			MOVE.L	D1,-(SP)		; argument: PRAM address
+			BSR.L	NWWriteNVRAM_C
+			ADDQ.L	#8,SP
+			MOVE.L	(SP)+,D0		; return: again, why D0?
+			JMP		(A3)
+
+
+;______________________________________________________________________________________
+;
+; Routine:	NWReadTime (glue for C code)
 ;
 ; Inputs:	none
 ;
-; Outputs:	D0	-	result code
-;			"GetParam" contains the 32-bit time value read from the clock
+; Outputs:	"GetParam" contains the 32-bit time value read from the clock
 ;
-; Trashes:	A0,A2,A3,D1,D2,D4,D5, 8 bytes at "GetParam"
-;
-; Function:	reads the time from the realtime clock
-;________________________________________________________________________________________
-
-RTCReadTime	MOVEM.L	A5/A6,-(SP)
-			MOVEA.L	VIA,A2					; get the VIA 1 base address for RTCClkNoMem
-
-			MOVEQ	#2-1,D4					; try reading twice in case the time rolls over
-@RetryLoop	MOVEQ	#$9D-256,D5				; command to read the high byte of the time
-			LEA		GetParam,A0				; use clock utility storage
-			MOVEA.L	A0,A3					;  and save a copy for later
-
-@ReadLoop	MOVE.B	D5,D1					; get the command into D1
-			BSR5	RTCClkNoMem				; read a byte of the time
-			MOVE.B	D1,(A0)+				;  and save it
-			SUBQ.B	#4,D5					; next byte
-			BMI.S	@ReadLoop				; -> keep looping until all 8 bytes are read
-
-			MOVE.L	(A3)+,D0				; do the two reads of the time match?
-			SUB.L	(A3)+,D0
-			DBEQ	D4,@RetryLoop			; -> keep looping if not, or for two tries
-			BEQ.S	@Done					; -> no error
+; Function:	reads the time from the realtime clock via C code
+;______________________________________________________________________________________
 
-			MOVEQ	#ClkRdErr,D0			; note the problem
-@Done		MOVEM.L	(SP)+,A5/A6
+NWReadTime
+			PEA		GetParam
+			BSR.L	NWReadTime_C
+			ADDQ.L	#4,SP
 			RTS
 
 
-;________________________________________________________________________________________
+;______________________________________________________________________________________
 ;
-; Routine:	RTCWriteTime
+; Routine:	NWWriteTime (glue for C code)
 ;
 ; Inputs:	"Time" contains the 32-bit value to write to the clock
 ;
-; Outputs:	D0	-	result code
-;
-; Trashes:	A0,D1,D2,D3,D4,D5
-;
-; Function:	writes a new time value to the realtime clock
-;________________________________________________________________________________________
-
-RTCWriteTime
-			MOVEM.L	D6/A2/A5/A6,-(SP)
-			MOVEA.L	VIA,A2					; get the VIA 1 base address for RTCClkNoMem
-
-			BSR5	RTCWrProtOff			; write-enable the clock chip
-
-			MOVEQ	#2-1,D5					; give it two tries
-			MOVE.L	Time,D3					; get the time to write
-
-@RetryLoop	MOVEQ	#$01,D6					; command to write the low byte of the time
-			MOVEQ	#4-1,D4
-@WriteLoop	MOVE.L	D3,D1					; put the byte to write into the upper word
-			SWAP	D1
-			MOVE.B	D6,D1					;  and the command in the lower word
-			BSR5	RTCClkNoMem				; write a byte of the time
-			ADDQ.B	#4,D6					; address the next register
-			ROR.L	#8,D3					; get the next byte
-			DBRA	D4,@WriteLoop
-
-			BIGJSR	ReadTime,A0				; read the time to verify it was written correctly
-			BNE.S	@Done
-			CMP.L	Time,D3 				; do they match?
-			DBEQ	D5,@RetryLoop			; -> keep looping if not, or for two tries
-			BEQ.S	@Done					; -> they match so we're done
-			MOVEQ	#ClkWrErr,D0			; note the error
-
-@Done		MOVE.L	D0,D3					; save the result code
-			BSR5	RTCWrProtOn				; turn write-protect back on							<H6>
-			MOVE.L	D3,D0					; restore the result code
-			MOVEM.L	(SP)+,D6/A2/A5/A6
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	RTCXParam
-;
-; Inputs:	A0	-	pointer to user's buffer
-;			D0	-	[number of bytes to transfer][starting PRAM address]
-;			D1	-	bit 12: 1=read, 0=write
-;
-; Outputs:	D0	-	result code
-;
-; Trashes:	A0,A1,A2,A3,D1,D2,D3
-;
-; Function:	reads/writes byte[s] from RTC-based paramter RAM
-;________________________________________________________________________________________
-
-RTCXParam	MOVEA.L	A0,A3					; get the pointer to the caller's buffer
-			MOVEA.L	UnivInfoPtr,A1			; point to the ProductInfo table						<H3>
-			MOVEA.L	A1,A0					;  and to the decoder table								<H3>
-			ADDA.L	ProductInfo.DecoderInfoPtr(A0),A0
-			MOVE.L	D0,D3					; get the starting PRAM address and count
-			BTST	#12,D1					; is it a read or write?
-			BNE.S	@ItsRead
-			BSET	#31,D3					; mark it as a write
-
-@ItsRead	BSR.S	StandardXPramIO			; go transfer the PRAM bytes							<H3>
+; Function:	writes a new time value to the realtime clock via C code
+;______________________________________________________________________________________
 
-			MOVEQ	#0,D0					; always return "no error"
+NWWriteTime
+			MOVE.L	Time,-(SP)
+			BSR.L	NWWriteTime_C
+			ADDQ.L	#4,SP
 			RTS
 
 
 ;________________________________________________________________________________________
 ;
-; Routine:	RTCRdXByte
+; Routine:	RdXByte (indirect via ProductInfo, cribbed from USTPram.a)
 ;
-; Inputs:	D1	-	address of PRAM byte to read
-;			A1	-	pointer to ProductInfo record for this machine
+; Inputs:	A1	-	pointer to ProductInfo record for this machine
 ;			A2	-	VIA1 base address
-;			A3	-	return address
+;			A6	-	return address (BSR6)
+;			D1	-	address of PRAM byte to read
 ;
 ; Outputs:	D1	-	byte read from PRAM
 ;
-; Trashes:	D0,D2,A5,A6
+; Trashes:	A0,A3,A4,A5,A6,D0,D2
 ;
-; Function:	reads a byte from RTC-based PRAM without using RAM
+; Function:	reads a byte of extended PRAM at the specified address
 ;________________________________________________________________________________________
 
-RTCRdXByte	ANDI.W	#$00FF,D1				;  [oooo oooo 7654 3210]
-			ASL.W	#3,D1					;  [oooo o765 4321 0ooo]
-			ROR.B	#1,D1					;  [oooo o765 o432 10oo]
-			ROR.W	#8,D1					;  [o432 10oo oooo o765]
-			ORI.B	#$B8,D1					;  [o432 10oo ioii i765]
-
-			BSR5	RTCClkNoMem				; read the PRAM byte
-
-			ANDI.W	#$00FF,D1				; zero-extend the byte
-			JMP		(A3)
-
-
-;________________________________________________________________________________________
-;
-; Routine:	RTCWrXByte
-;
-; Inputs:	D1	-	address of PRAM byte to write
-;			D2	-	byte to write to PRAM
-;			A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A3	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0,D1,D2,A5,A6
-;
-; Function:	writes a byte to RTC-based PRAM without using RAM
-;________________________________________________________________________________________
-
-RTCWrXByte	SWAP	D1						; copy the byte to write
-			MOVE.B	D2,D1					;  to the upper word of D1
-			SWAP	D1
-
-			ANDI.W	#$00FF,D1				;  [oooo oooo 7654 3210]
-			ASL.W	#3,D1					;  [oooo o765 4321 0ooo]
-			ROR.B	#1,D1					;  [oooo o765 o432 10oo]
-			ROR.W	#8,D1					;  [o432 10oo oooo o765]
-			ORI.B	#$38,D1					;  [o432 10oo ooii i765]
-
-			MOVEA.L	A3,A5					; (fake out the return address)
-			BRA.S	RTCClkNoMem				; write the PRAM byte
-
-
-;________________________________________________________________________________________
-;
-; Routine:	RTCInitHW
-;
-; Inputs:	A1	-	pointer to ProductInfo record for this machine
-;			A6	-	return address (BSR6)
-;
-; Outputs:	none
-;
-; Trashes:	D0,D1,D2,A0,A2,A5,A6
-;
-; Function:	initializes the RTC by taking it out of test mode
-;________________________________________________________________________________________
-
-RTCInitHW	MOVEA.L	A6,A0					; save the return address
-			MOVEA.L	A1,A2					; point to the decoder info
-			ADDA.L	ProductInfo.DecoderInfoPtr(A2),A2
-			MOVEA.L	DecoderInfo.VIA1Addr(A2),A2	; get VIA 1's base address							<H6>
-
-			BSR5	RTCWrProtOff			; write-enable the clock chip
-
-			MOVEQ	#(0<<16)+($31<<0),D1 	; write zero to test bit in clock chip
-			BSR5	RTCClkNoMem
-
-			MOVEA.L	A0,A5					; restore the return address
-
-
-;________________________________________________________________________________________
-;
-; Routine:	RTCWrProtOn						[RTC utility routine]
-;
-; Inputs:	A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A5	-	return address (BSR5)
-;
-; Outputs:	none
-;
-; Trashes:	D0,D1,D2,A6
-;
-; Function:	write-protects RTC-based PRAM when we're done modifying it
-;________________________________________________________________________________________
-
-RTCWrProtOn	MOVE.L	#($D5<<16)+($35<<0),D1 	; use 'set write protect' command
-			BRA.S	RTCClkNoMem				; write it to the clock chip
+RdXByte		MOVEA.L	A1,A3					; point to this machine's product info					<H3>
+			ADDA.L	ProductInfo.ClockPRAMPtr(A3),A3	;  and get the address of its clock/PRAM table	<H3>
+			MOVE.L	4*cpRdXByte(A3),D0		; get the offset to the routine							<H3>
+			BEQ.S	@NoEntry				; -> this function is not supported						<H3>
+			ADDA.L	D0,A3					; calculate the routine's address						<H3>
+			EXG		A6,A3					; save return address in A3, put routine's address in A6<H3>
+@NoEntry	JMP		(A6)					;  and either call the routine or just return			<H3>
 
 
 ;________________________________________________________________________________________
 ;
-; Routine:	RTCWrProtOff					[RTC utility routine]
+; Routine:	WrXByte (indirect via ProductInfo, cribbed from USTPram.a)
 ;
 ; Inputs:	A1	-	pointer to ProductInfo record for this machine
 ;			A2	-	VIA1 base address
-;			A5	-	return address (BSR5)
-;
-; Outputs:	none
-;
-; Trashes:	D0,D1,D2,A6
-;
-; Function:	write-enables RTC-based PRAM so we can write bytes to it
-;________________________________________________________________________________________
-
-RTCWrProtOff
-			MOVE.L	#($55<<16)+($35<<0),D1 	; use 'reset write protect' command
-*			BRA.S	RTCClkNoMem				; write it to the clock chip
-
-
-;________________________________________________________________________________________
-;
-; Routine:	RTCClkNoMem						[RTC utility routine]
-;
-; Inputs:	D1	-	[x] [byte to write] [<extended command>] [command (bit 7: 1=read, 0=write)]
-;			A2	-	VIA1 base address
-;			A5	-	return address (BSR5)
-;
-; Outputs:	D1	-	data byte read
-;
-; Trashes:	D0,D1,D2,A6
-;
-; Function:	reads or writes one 8-bit clock register
-;________________________________________________________________________________________
-
-RTCClkNoMem	MOVE	SR,D2					; save the SR
-			ORI		#HiIntMask,SR			;  and disable interrupts
-			SWAP	D2
-
-			MOVE.B	D1,D2					; save a copy of the command
-
-			BCLR	#vRTCEnb,vBufB(A2)		; enable the clock
-
-			MOVEQ	#$78,D0					; mask off the code bits
-			AND.B	D1,D0
-			CMPI.B	#$38,D0					; is this an extended command?
-			BNE.S	@NotExtended			; -> nope
-
-			BSR6	SendToClk				; send the first command byte
-			LSR.W	#8,D1					; move the second command byte into position
-
-@NotExtended
-			TST.B	D2						; is this a read or write command?
-			BMI.S	@ItsRead				; -> read
-
-			BSR6	SendToClk				; send the command byte
-			SWAP	D1						; get the data byte
-			BSR6	SendToClk				;  and send it
-			BRA.S	@Done
-
-@ItsRead	BSR6	SendToClk				; send the command byte
-			BSR6	ReadFrClk				;  and read the data byte
-
-@Done		BSET	#vRTCEnb,vBufB(A2)		; disable the clock
-			SWAP	D2
-			MOVE	D2,SR					; re-enable interrupts
-			RTS5
-
-
-;________________________________________________________________________________________
-;
-; Routine:	SendToClk						[RTC utility routine]
-;
-; Inputs:	D1	-	command/data byte to write to RTC
-;			A2	-	VIA1 base address
-;			A6	-	return address (BSR6)
-;
-; Outputs:	none
-;
-; Trashes:	D0,D1
-;
-; Function:	writes a command or data byte to the RTC (assumes interrupts masked to $2700)
-;________________________________________________________________________________________
-
-SendToClk	MOVEQ	#8-1,D0					; shifting out 8 bits
-	
-@ShiftLoop	SWAP	D0						; save the count
-			MOVE.B	vBufB(A2),D0			; get the VIA register's contents
-			ROR.B	#1,D0					; shift the bits to position the RTC data bit (bit 0)
-			ADDX.B	D1,D1					; shift the next data bit into the extend bit
-			ADDX.B	D0,D0					; shift the data bit from the extend bit to the RTC data bit
-			MOVE.B	D0,VBufB(A2)			; stuff it back into the VIA register
-			BCLR	#vRTCClk,vBufB(A2)		;  and clock the bit out
-			BSET	#vRTCClk,vBufB(A2)
-			SWAP	D0						; get the bit counter back
-			DBRA	D0,@ShiftLoop			; -> keep looping until all bits are shifted out
-			RTS6
-
-
-;________________________________________________________________________________________
-;
-; Routine:	ReadFrClk						[RTC utility routine]
-;
-; Inputs:	A2	-	VIA1 base address
-;			A6	-	return address (BSR6)
-;
-; Outputs:	D1	-	data byte read from RTC
-;
-; Trashes:	D0
-;
-; Function:	reads a data byte from the RTC (assumes interrupts masked to $2700)
-;________________________________________________________________________________________
-
-ReadFrClk	BCLR	#vRTCData,vDirB(A2)   	; set the RTC data bit's direction to input
-			MOVEQ	#1,D1					; initialize the result with a flag bit
-
-@ShiftLoop	BCLR	#vRTCClk,vBufB(A2)		; clock the next bit in
-			BSET	#vRTCClk,vBufB(A2)
-			MOVE.B	vBufB(A2),D0			; read the register
-			LSR.B	#vRTCData+1,D0			; shift the RTC data bit into the carry/X
-			ADDX.B	D1,D1					; shift in the new bit towards the msb
-			BCC.S	@ShiftLoop				; -> keep looping until the flag bit shifts out
-
-			BSET	#vRTCData,vDirB(A2)   	; restore the RTC data bit's direction to output
-			RTS6
-
-
-		ENDIF								; {hasVIAClock}
-
-
-
-		IF hasPwrControls THEN
-;••••••••••••••••••••••••••••••••••••• Power Manager ••••••••••••••••••••••••••••••••••••
-			WITH	PMCommandRec
-
-			IMPORT	USTPmgrSendCommand, USTPMgrSendByte, USTPMGRRecvByte
-
-;________________________________________________________________________________________
-;
-; Routine:	PMGRReadTime
-;
-; Inputs:	none
-;
-; Outputs:	D0	-	result code
-;			"GetParam" contains the 32-bit time value read from the clock
-;
-; Trashes:	A0
-;
-; Function:	reads the time from the realtime clock
-;________________________________________________________________________________________
-
-PMGRReadTime
-			PEA		GetParam				;  pmRBuffer
-			MOVE.L	(SP),-(SP)				;  pmSBuffer (not used)
-			CLR.W	-(SP)					;  pmLength = 0
-			MOVE.W	#TimeRead,-(SP)			;  pmCommand = read time
-			MOVE.L	SP,A0					; point to the parameter block
-			_PmgrOp							; read the time
-			LEA		pmRBuffer+4(SP),SP		; clean up the stack
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	PMGRWriteTime
-;
-; Inputs:	"Time" contains 32-bit quantity to write to clock
-;
-; Outputs:	D0	-	result code
-;
-; Trashes:	A0
-;
-; Function:	writes a new time value to the realtime clock
-;________________________________________________________________________________________
-
-PMGRWriteTime
-			PEA		Time					;  pmRBuffer (not used)
-			MOVE.L	(SP),-(SP)				;  pmSBuffer
-			MOVE.W	#4,-(SP)				;  pmLength = 4 bytes of time
-			MOVE.W	#TimeWrite,-(SP)		;  pmCommand = write time
-			MOVE.L	SP,A0					; point to the parameter block
-			_PmgrOp							; read the time
-			LEA		pmRBuffer+4(SP),SP		; clean up the stack
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	PMGRXParam
-;
-; Inputs:	A0	-	pointer to user's buffer
-;			D0	-	[number of bytes to transfer][starting PRAM address]
-;			D1	-	bit 12: 1=read, 0=write
-;
-; Outputs:	D0	-	result code
-;
-; Trashes:	A0,A1,A2,D1,D2,D3
-;
-; Function:	reads/writes byte[s] from PMGR-based parameter RAM
-;________________________________________________________________________________________
-
-PMGRXParam	MOVEA.L	SP,A2					; point to the current top of stack
-			MOVE.L	D0,D2					; 
-			SWAP	D2						; D2.L=[starting PRAM address][count]
-			ADDQ.W	#2+1,D2					; make space on the stack for a buffer and 2 parameter bytes
-			BCLR	#0,D2					;  and round up to the next word
-			SUBA.W	D2,SP
-			MOVEA.L	SP,A1
-
-			MOVE.L	A0,-(SP)				;  pmRBuffer
-			MOVE.L	A1,-(SP)				;  pmSBuffer
-
-			MOVE.B	D0,(A1)+				; put the PRAM address
-			SWAP	D0
-			MOVE.B	D0,(A1)+				;  and count at the start of the send buffer
-
-			MOVEQ	#xPramRead,D3			; assume it's a read
-			MOVEQ	#2,D2					; 
-			BTST	#12,D1					; is this a write command?
-			BNE.S	@NoWrBuffer				; -> no
-			MOVEQ	#xPramWrite,D3
-			ADD.W	D0,D2					; adjust the count to include the bytes to be written
-			BRA.S	@StartCopy
-@CopyLoop	MOVE.B	(A0)+,(A1)+				; copy the write buffer into the stack buffer
-@StartCopy	DBRA	D0,@CopyLoop
-
-@NoWrBuffer	MOVE.W	D2,-(SP)				;  pmLength
-			MOVE.W	D3,-(SP)				;  pmCommand
-			MOVEA.L	SP,A0
-			_PMgrOp							; have the PMGR read/write PRAM
-
-			MOVEA.L	A2,SP					; restore the stack pointer
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	PMGRWrXByte
-;
-; Inputs:	D1	-	address of PRAM byte to write
+;			A6	-	caller's return address (BSR6)
+;			D1	-	address of PRAM byte to read
 ;			D2	-	byte to write to PRAM
-;			A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A3	-	return address
 ;
 ; Outputs:	none
 ;
 ; Trashes:	A0,A3,A4,A5,A6,D0,D1,D2
 ;
-; Function:	writes a byte to PMGR-based PRAM without using RAM
+; Function:	writes a byte of extended PRAM at the specified address
 ;________________________________________________________________________________________
 
-PMGRWrXByte	MOVEA.L	A3,A4					; save the return address
-
-			EXG		D3,D1					; save D3 in D1, put PRAM address in the upper word of D3
-			SWAP	D3
-			EXG		D4,D2					; save D4 in D2, put data byte in the upper word of D4
-			SWAP	D4
-			MOVE.L	D6,D0					; save D6
-
-			MOVE.W	#(xPramWrite<<0)|\		; pmCommand
-					 (-1<<8),D3				; pmLength = -1 (just send command byte)
-
-			MOVEA.L	A1,A0					; point to the decoder table
-			ADDA.L	ProductInfo.DecoderInfoPtr(A0),A0
-			BigBSR6	USTPmgrSendCommand,A5	; send the command to the PMGR
-			BNE.S	@PMgrDone				; -> error
-
-			MOVE.B	#3,D3					; send pmLength = 3 (address, count, data)
-			BigBSR5	USTPMgrSendByte,A6
-			BNE.S	@PMgrDone				; -> error
-
-			SWAP	D3						; send the PRAM address
-			BigBSR5	USTPMgrSendByte,A6
-			BNE.S	@PMgrDone				; -> error
-
-			MOVEQ	#1,D3					; send the PRAM byte count
-			BigBSR5	USTPMgrSendByte,A6
-			BNE.S	@PMgrDone				; -> error
-
-			MOVE.L	D4,D3					; send the PRAM data byte
-			SWAP	D3
-			BigBSR5	USTPMgrSendByte,A6
-
-@PMgrDone	MOVE.L	D1,D3					; restore registers
-			MOVE.L	D2,D4
-			MOVE.L	D0,D6
-			JMP		(A4)
-
-
-;________________________________________________________________________________________
-;
-; Routine:	PMGRRdXByte
-;
-; Inputs:	D1	-	address of PRAM byte to read
-;			A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A3	-	return address
-;
-; Outputs:	D1	-	byte read from PRAM
-;
-; Trashes:	A0,A3,A4,A5,A6,D0,D2
-;
-; Function:	reads a byte from PMGR-based PRAM without using RAM
-;________________________________________________________________________________________
-
-PMGRRdXByte	MOVEA.L	A3,A4					; save the return address
-
-			EXG		D3,D1					; save D3 in D1, put command/data bytes in D3
-			MOVE.L	D4,D0					; save other registers
-			MOVE.L	D6,D2
-
-			ANDI.L	#$000000FF,D3			; mask the PRAM address and build the command:
-			ORI.L	#(xPramRead<<16)|\		;  pmCommand
-					 (2<<24)|\				;  pmLength
-					 (1<<8),D3				;  count = 1 byte
-			SWAP	D3						; D1.L=[count][addr][pmLength][pmCommand]
-
-			MOVEA.L	A1,A0					; point to the decoder table
-			ADDA.L	ProductInfo.DecoderInfoPtr(A0),A0
-			BigBSR6	USTPmgrSendCommand,A5	; send the command to the PMGR
-			BNE.S	@PMgrError				; -> error
-
-			BigBSR5	USTPMGRRecvByte,A6		; read a byte back
-			BNE.S	@PMgrError				; -> error
-			CMPI.B	#xPramRead,D3			; is it the reply byte?
-			BNE.S	@NoReplyByte			; -> no, new protocol
-
-			BigBSR5	USTPMGRRecvByte,A6		; read the count byte
-			BNE.S	@PMgrError				; -> error
-@NoReplyByte
-			BigBSR5	USTPMGRRecvByte,A6		; read the PRAM byte
-			BEQ.S	@PMgrDone				; -> got it
-
-@PMgrError	MOVEQ	#0,D3					; return a zero if an error occurs
-@PMgrDone	EXG		D1,D3					; restore D3, return PRAM byte in D1
-			MOVE.L	D0,D4					; restore other registers
-			MOVE.L	D2,D6
-
-			TST.B	D1						; set up the CCR if anybody cares
-			JMP		(A4)
-
-
-			ENDWITH							; {PMgrRec}
-		ENDIF								; {hasPwrControls}
-
-
-
-		IF hasEgret THEN
-;••••••••••••••••••••••••••••••••••••••••• Egret ••••••••••••••••••••••••••••••••••••••••
-			WITH	EgretPB
-
-;________________________________________________________________________________________
-;
-; Routine:	EgretReadTime
-;
-;	The one second interrupt handler for Egret/Caboose/Cuda maintains the lowmem global		<sm10>
-;	'Time' in a self correcting manner.  This routine need only return the lowmem 'Time'.
-;	A call to _EgretDispatch will cause the AutoPoll timer within Egret/Caboose/Cuda to
-;	reset, resulting in deferring ADB auto polling.  If an application calls ReadTime
-;	in a tight loop, ADB polling could be deferred indefinitely (making the mouse/keyboard
-;	appear to hang or respond intermittently).  Since 'Time' is self correcting, the
-;	routine just returns 'Time' as the result placed into 'GetParam'.
-;
-; Inputs:	none
-;
-; Outputs:	D0	-	result code
-;			"GetParam" contains the 32-bit time value read from the clock
-;
-; Trashes:	A0
-;
-; Function:	reads the time from the realtime clock
-;________________________________________________________________________________________
-
-EgretReadTime
-			clr.l	d0						; result code = noErr					<sm10>
-			move.l	Time,GetParam			; return current time					<sm10>
-;			CLR.L	-(SP)					;  pbCompletion = nil					<sm12>
-;			LEA		pbCmdType-pbCompletion(SP),SP ; 								<sm12>
-;			MOVE.W	#(pseudopkt<<8)+\		;  pbCmdType = pseudo type				<sm12>
-;					 (RdTime<<0),(SP)		;  pbCmd = read time					<sm12>
-;			MOVEA.L	SP,A0					; point to the parameter block			<sm12>
-;			_EgretDispatch					; call Egret to read the time			<sm12>
-;			MOVE.L	pbParam(A0),GetParam	; move the time into a temporary buffer	<sm12>
-;			LEA		EgretPBSize(SP),SP		; clean up the stack					<sm12>
-
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	EgretWriteTime
-;
-; Inputs:	"Time" contains 32-bit quantity to write to clock
-;
-; Outputs:	D0	-	result code
-;
-; Trashes:	A0
-;
-; Function:	writes a new time value to the realtime clock
-;________________________________________________________________________________________
-
-EgretWriteTime
-			CLR.L	-(SP)					;  pbCompletion = nil
-			LEA		pbParam-pbCompletion(SP),SP
-			MOVE.L	Time,(SP)				;  pbParam = current time
-
-			MOVE.W	#(pseudopkt<<8)+\		;  pbCmdType = pseudo type
-					+(WrTime<<0),-(SP)		;  pbCmd = write time
-			MOVEA.L	SP,A0					; point to the parameter block
-			_EgretDispatch					; call Egret to read the time
-			LEA		EgretPBSize(SP),SP		; clean up the stack
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	EgretXParam
-;
-; Inputs:	A0	-	pointer to user's buffer
-;			D0	-	[number of bytes to transfer][starting PRAM address]
-;			D1	-	bit 12: 1=read, 0=write
-;
-; Outputs:	D0	-	result code
-;
-; Trashes:	A0
-;
-; Function:	reads/writes byte[s] from Egret-based parameter RAM
-;________________________________________________________________________________________
-
-EgretXParam	CLR.L	-(SP)					;  pbCompletion = nil
-			SUBQ.W	#pbCompletion-pbBufPtr,SP
-			MOVE.L	A0,(SP)					;  pbBufPtr = pointer to user's buffer
-			SWAP	D0
-			MOVE.W	D0,-(SP)				;  pbByteCnt = number of PRAM bytes to read/write
-			SUBQ.W	#pbByteCnt-pbParam,SP
-			SWAP	D0
-			ADDI.W	#$0100,D0				;• convert PRAM address to 6805 address (temporary?)
-			MOVE.W	D0,(SP)					;  pbParam = starting PRAM address
-			MOVE.W	#(pseudopkt<<8)+\		;  pbCmdType = pseudo type
-					 (Rd6805Addr<<0),-(SP)	;  pbCmd = read PRAM
-			BTST	#12,D1					; is this a write command?
-			BNE.S	@NotWrite				; -> no
-			MOVE.W	#(pseudopkt<<8)+\		;  pbCmdType = pseudo type
-					 (Wr6805Addr<<0),(SP)	;  pbCmd = write PRAM
-@NotWrite	MOVEA.L	SP,A0					; point to the parameter block
-			_EgretDispatch					; call Egret to read/write PRAM
-			LEA		EgretPBSize(SP),SP		; clean up the stack
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	EgretWrXByte
-;
-; Inputs:	D1	-	address of PRAM byte to write
-;			D2	-	byte to write to PRAM
-;			A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A3	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0,D1,D2,A5,A6
-;
-; Function:	writes a byte to Egret-based PRAM without using RAM
-;________________________________________________________________________________________
-
-EgretWrXByte
-			SWAP	D1
-			MOVE.B	D2,D1					; save the byte to send
-			SWAP	D1
-			BSET	#15,D1					; mark this as a write
-			;  fall into EgretRdXByte
-
-;________________________________________________________________________________________
-;
-; Routine:	EgretRdXByte
-;
-; Inputs:	D1	-	address of PRAM byte to read
-;			A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A3	-	return address
-;
-; Outputs:	D1	-	byte read from PRAM
-;
-; Trashes:	D0,D2,A5,A6
-;
-; Function:	reads a byte from Egret-based PRAM without using RAM
-;________________________________________________________________________________________
-
-EgretRdXByte
-			BCLR	#vSysSesbit,vBufB(A2)	; pending transaction?
-			BEQ.S	@NotPending				; -> no
-			BSR5	EgretDelay				; wait a bit
-			BCLR	#vViaFullBit,vBufB(A2)	; de-assert VIA full
-			BSR5	EgretDelay				; wait some more
-			BRA.S	@NotPending
-
-@Abort		BSR6	EgretReadByte			; too many bytes being returned so
-			BEQ.S	@Abort					;  keep throwing them out until there are no more,
-			BRA.S	@Reset					; then start over
-
-@DisposePacket
-			BSR5	EgretDelay				; wait for the interrupt to occur
-			TST.B	vSR(A2)					;  then read the ATTN byte to clear the interrupt
-
-@Reset		BCLR	#vSysSesbit,vBufB(A2)	; turn off SYS session
-			BCLR	#vViaFullBit,vBufB(A2)	;  and de-assert VIA full
-			BCLR	#SRdir,vACR(A2)			; define shift direction = FROM Egret
-			BSR5	EgretDelay				; wait
-			BRA.S	@CheckXCVR
-
-@ThrowAway	BSET	#vSysSesbit,vBufB(A2)	; set SYS session
-			BSR6	EgretReadByte			; read a byte to throw away
-@CheckXCVR	BTST	#vXcvrSesBit,vBufB(A2)	; is XCVR session asserted (active low)?
-			BEQ.S	@ThrowAway				; -> yes, throw away the byte
-			BSR5	EgretDelay				; wait
-
-@NotPending	ORI.B	#ACRMode++(1<<SRdir),vACR(A2)	; set VIA shift register to shift out with external clock
-			BTST	#vXcvrSesBit,vBufB(A2)	; is XCVR session asserted (active low)?
-			BEQ.S	@DisposePacket			; -> yes, dispose of the packet
-
-			BSET	#vSysSesbit,vBufB(A2)	; assert sys session signal
-			MOVEQ	#pseudopkt,D0			; packet type
-			BSR6	EgretSendByte
-			BMI.S	@Reset					; -> Egret's hung, so try to reset
-
-			BTST	#vXcvrSesBit,vBufB(A2)	; is XCVR session asserted (active low)?
-			BEQ.S	@Reset					; -> yes, throw out the packet
-
-			MOVEQ	#rdPram,D0				; assume we're doing a read
-			TST.W	D1						; are we?
-			BPL.S	@SendCmd
-			MOVEQ	#wrPram,D0				; no, we're writing
-@SendCmd	BSR6	EgretSendByte			; send the command byte
-			MOVEQ	#0,D0
-			BSR6	EgretSendByte			; send the MSB of the PRAM address
-			MOVE.B	D1,D0
-			BSR6	EgretSendByte			; send the LSB of the PRAM address
-			TST.W	D1						; are we writing?
-			BPL.S	@SendDone
-			MOVE.L	D1,D0					; yes, get the data byte
-			SWAP	D0
-			BSR6	EgretSendByte			;  and send it
-
-@SendDone	BCLR	#SRdir,vACR(A2)			; define shift direction = FROM Egret
-			BCLR	#vSysSesbit,vBufB(A2)	; turn off SYS session
-
-@WaitForIRQ	BTST	#ifSR,vIFR(A2)			; wait for shift to complete
-			BEQ.S	@WaitForIRQ
-			BTST	#vXcvrSesBit,vBufB(A2)	; is XCVR session asserted (active low)?
-			BNE.S	@WaitForIRQ				; -> no, keep polling until it is
-
-			TST.B	vSR(A2)					; read the ATTN byte to clear the interrupt
-			BSR5	EgretDelay				; wait
-			BSET	#vSysSesbit,vBufB(A2)	; assert sys session again
-
-			BSR6	EgretReadByte			; read the response packet type
-			BNE.S	@Reset					; -> XCVR session turned off early, so try again
-
-			BSR6	EgretReadByte			; read the response packet flag
-			BNE.S	@Reset					; -> XCVR session turned off early, so try again
-
-			TST.W	D1						; is this a read or write?
-			BPL.S	@FinishRead				; -> read
-
-			BSR6	EgretReadByte			; read the "command was" byte
-			BEQ.S	@Abort					; -> XCVR session is still on, so try again
-			CMPI.B	#wrPram,D0				; is this the correct packet?
-			BNE.S	@Reset					; -> no, try again
-
-			BCLR	#vSysSesbit,vBufB(A2)	; turn off SYS session
-			BCLR	#vViaFullBit,vBufB(A2)	;  and de-assert VIA full
-			BSR5	EgretDelay				; delay to let Egret see the lines change state
-			JMP		(A3)
-
-
-@FinishRead	BSR6	EgretReadByte			; read the "command was" byte
-			BNE.S	@Reset					; -> XCVR session turned off early, so try again
-			SUBQ.B	#rdPram,D0				; is this the correct packet?
-			BNE.S	@Reset					; -> no, try again
-
-			BSR6	EgretReadByte			; read the PRAM data byte
-			BCLR	#vSysSesbit,vBufB(A2)	; turn off SYS session
-
-@Wait4XCVR	BTST	#vXcvrSesBit,vBufB(A2)	; wait for XCVR session to turn off
-			BEQ.S	@Wait4XCVR
-			BCLR	#vViaFullBit,vBufB(A2)	; de-assert VIA full
-
-			BSR5	EgretDelay				; delay to let Egret see the lines change state
-			MOVE.B	D0,D1					; return the byte in D1
-			JMP		(A3)
+WrXByte		MOVEA.L	A1,A3					; point to this machine's product info					<H3>
+			ADDA.L	ProductInfo.ClockPRAMPtr(A3),A3	;  and get the address of its clock/PRAM table	<H3>
+			MOVE.L	4*cpWrXByte(A3),D0		; get the offset to the routine							<H3>
+			BEQ.S	@NoEntry				; -> this function is not supported						<H3>
+			ADDA.L	D0,A3					; calculate the routine's address						<H3>
+			EXG		A6,A3					; save return address in A3, put routine's address in A6<H3>
+@NoEntry	JMP		(A6)					;  and either call the routine or just return			<H3>
 
 
 ;________________________________________________________________________________________
 ;
-; Routine:	EgretSendByte					[Egret utility routine]
+; Routine:	ClkWPOff (indirect via ProductInfo, cribbed from USTPram.a)
 ;
-; Inputs:	D0	-	byte to send to Egret
+; Inputs:	A1	-	pointer to ProductInfo record for this machine
 ;			A2	-	VIA1 base address
 ;			A6	-	return address (BSR6)
 ;
 ; Outputs:	none
 ;
-; Trashes:	D2,A5
-;
-; Function:	sends a byte to Egret
-;________________________________________________________________________________________
-
-EgretSendByte
-			MOVEA.L	A6,A5					; save the return address
-			MOVE.B	D0,vSR(A2)				; load byte into shift register
-			BSET	#vViaFullBit,vBufB(A2)	; indicate shift register is full
-			MOVE.W	#32767,D0				; set a 42msec timeout
-@Wait4Shift	BTST	#ifSR,vIFR(A2)			; wait for shift to complete
-			DBNE	D0,@Wait4Shift
-			BEQ.S	EgretSendTO				; -> timed out
-			TST.B	vSR(A2)					; clear the interrupt
-			BCLR	#vViaFullBit,vBufB(A2)	; then negate VIA full bit
-
-;  delay a bit so Egret can keep up...
-
-EgretDelay	MOVEQ	#104,D2					; delay 125µs minimum (we actually delay 134µsec)
-@wait		TST.B	(A2)					; sync to VIA clock (about 1.28µsec/access)
-			DBRA	D2,@wait				; delay at least 100 us (very rough)
-EgretSendTO	TST.W	D0						; set CCR: BMI if send timeout, BPL if OK
-			RTS5
-
-
-;________________________________________________________________________________________
-;
-; Routine:	EgretReadByte					[Egret utility routine]
-;
-; Inputs:	A2	-	VIA1 base address
-;			A6	-	return address (BSR6)
-;
-; Outputs:	D0	-	byte read
-;
-; Trashes:	D2,A5
-;
-; Function:	reads a byte from Egret
-;________________________________________________________________________________________
-
-EgretReadByte
-			BCLR	#vViaFullBit,vBufB(A2)	; de-assert VIA full
-@Wait4Shift	BTST	#ifSR,vIFR(A2)			; wait for shift to complete
-			BEQ.S	@Wait4Shift
-			BSET	#vViaFullBit,vBufB(A2)	; acknowlege byte
-			MOVE.B	vSR(A2),D0				; read the byte
-			BSR5	EgretDelay				; give Egret time to see it
-			BTST	#vXcvrSesBit,vBufB(A2)	; return with the state of XCVR session
-			RTS6
-
-
-;________________________________________________________________________________________
-;
-; Routine:	CudaRdXByte
-;
-; Inputs:	D1	-	address of PRAM byte to read
-;			A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A3	-	return address
-;
-; Outputs:	D1	-	byte read from PRAM
-;
-; Trashes:	D0,D2,A5,A6
-;
-; Function:	reads a byte from Egret-based PRAM without using RAM
-;
-;			This routine can only be executed after a SyncAck cycle.  The SyncAck cycle,
-;			which is executed immediately after InitVia will disable all asynchronous
-;			message sources within Cuda.  This allows the following routine to be written
-;			without regard to detecting collisions between command packets and response
-;			packets.  AT NO TIME SHOULD AN ASYNCHRONOUS MESSAGE SOURCE BE ENABLED PRIOR
-;			TO USE OF THIS ROUTINE.  ASYNCHRONOUS MESSAGE SOURCES SHOULD ONLY BE ENABLED
-;			AFTER THE CUDA MANAGER HAS BEEN INSTALLED.
-;________________________________________________________________________________________
-
-CudaRdXByte	cmp.l	#$8000,sp						; is there any stack yet?
-			ble.s	@5								; no, use register based
-			cmp.w	#0,EgretBase
-			bne.s	@5
-			movec	VBR,d2							; get the contents of VBR
-			tst.l	d2								; check for zero
-			bne.s	@5
-
-;	This code allows the low level routines to be used after the Cuda manager is installed
-;	by constructing a parameter block on the stack and issuing a call to CudaDispatch.  This
-;	is absolutely necessary because the low level routines do not detect collisions which can
-;	occur once the Cuda manager is installed.  Further, it is almost impossible to determine
-;	how to to synchronize Cuda after an asynchronous re-boot has occurred.
-
-			movem.l	a0-a6/d0/d2-d7,-(sp)
-			suba.l	#EgretPBSize,sp					; make room on the stack for Cuda parameter block
-			move.b	#pseudoPkt,pbCmdType(sp)		; set packet type
-			move.b	#RdPram,pbCmd(sp)				; set packet command
-			move.w	d1,pbParam(sp)					; set pram address
-			move.w	#1,pbByteCnt(sp)				; 1 byte to send
-			move.l	sp,pbBufPtr(sp)
-			add.l	#pbParam+2,pbBufPtr(sp)			; point to our data buffer
-			move.b	#0,pbFlags(sp)
-			move.w	#0,pbResult(sp)
-			move.l	#0,pbCompletion(sp)				; execute synchronously
-			move.l	sp,a0							; parameter block in a0
-			_EgretDispatch							; (this is actually the Cuda A-Trap)
-			move.w	pbParam+2(sp),d1				; get pram data
-			adda.l	#EgretPBSize,sp					; remove parameter block from stack
-			movem.l	(sp)+,a0-a6/d0/d2-d7
-			jmp 	(a3)
-
-;
-;	The following code is executed only when the Cuda manager is not installed.
-;	AT NO TIME SHOULD AN ASYNCHRONOUS MESSAGE SOURCE BE ENABLED PRIOR TO USE OF THIS ROUTINE.
-;	ASYNCHRONOUS MESSAGE SOURCES SHOULD ONLY BE ENABLED AFTER THE CUDA MANAGER HAS BEEN INSTALLED.
-;
-@5
-			ori.b	#ACRmode,vacr(a2)				; else initialize via mode
-			bset.b	#SRdir,vACR(a2)					; set output mode
-			move.b	#pseudopkt,vSR(a2)				; send packet type & clear any pending shift irq
-			bclr.b	#TIP,vBufB(a2)					; start the transaction
-@10 			
-			btst.b	#ifSR,vIFR(a2)					; Wait for shift register IRQ to indicate byte was read
-			beq.s	@10
-			
-;________________________________________________________________________________________________
-;	When outputing from the VIA to Cuda, the interrupt will occur prior to the rising edge
-;	of CB1.  Delay long enough for the edge to occur before acknowledging the shift
-;	register interrupt.	(R. Montagne	1/11/93)
-;________________________________________________________________________________________________
-			moveq	#10,d2							; delay for 10µS min.							<LW3><VIA rbm>
-@m7dly												;												<LW3><VIA rbm>
-			tst.b	vBufB(a1)						; hardware access is 1.2µS						<LW3><VIA rbm>
-			sub.b	#1,d2							; can only trash low byte						<LW3><VIA rbm>
-			bne.s	@m7dly							; wait long enough for CB1 to rise (10µS delay)	<LW3><VIA rbm>
-			tst.b	vSR(a2) 						; Clear the shift register IRQ
-
-			moveq	#rdpram,d2						; Send the command byte
-			BSR6	CudaWriteByte
-			move.l	d1,d2
-			lsr.l	#8,d2							; Send PRAM address MSB
-			BSR6	CudaWriteByte
-			move.l	d1,d2							; Send PRAM address LSB
-			BSR6	CudaWriteByte
-
-			bclr.b	#SRdir,vACR(a2)					; Define direction FROM Cuda
-			btst.b	#SRdir,vACR(a2)
-@69up
-			bne.s	@69up
-			
-			ori.b	#((1<<vCudaTIP)|\
-				(1<<vCudaByteAck)),vBufB(a2)		; terminate current command transaction
-@Wait4Attn
-			btst.b	#ifSR,vIFR(a2)					; Wait for attention IRQ
-			beq.s	@Wait4Attn
-			tst.b	vSR(a2)							; Read attn byte from VIA (clears IRQ)
-			
-			bclr.b	#vCudaTIP,vBufB(a2)				; assert TIP to begin response transaction
-	
-			BSR6	CudaReadByte					; Read a byte - response packet type
-			BSR6	CudaReadByte					; next byte - response packet flag
-			BSR6	CudaReadByte					; next byte - "cmd was" byte
-			BSR6	CudaReadByte					; finally!	PRAM data in d2
-			
-			ori.b	#((1<<vCudaTIP)|\
-				(1<<vCudaByteAck)),vBufB(a2)		; terminate current response transaction
-@Wait4CudaDone
-			btst.b	#vCudaTReq,vBufB(a2)			; Wait for TReq to negate
-			beq.s	@Wait4CudaDone
-@Wait4IdleIRQ 		
-			btst.b	#ifSR,vIFR(a2)					; Wait for idle state IRQ
-			beq.s	@Wait4IdleIRQ
-			tst.b	vSR(a2) 						; Read idle state byte (clears IRQ)
-			move.l	d2,d1							; return data in d1
-			jmp 	(a3)							; return to caller
-
-
-;________________________________________________________________________________________
-;
-; Routine:	CudaWrXByte
-;
-; Inputs:	D1	-	address of PRAM byte to write
-;			D2	-	byte to write to PRAM
-;			A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A3	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0,D1,D2,A5,A6
-;
-; Function:	writes a byte to Egret-based PRAM without using RAM
-;
-;			This routine can only be executed after a SyncAck cycle.  The SyncAck cycle,
-;			which is executed immediately after InitVia will disable all asynchronous
-;			message sources within Cuda.  This allows the following routine to be written
-;			without regard to detecting collisions between command packets and response
-;			packets.  AT NO TIME SHOULD AN ASYNCHRONOUS MESSAGE SOURCE BE ENABLED PRIOR
-;			TO USE OF THIS ROUTINE.  ASYNCHRONOUS MESSAGE SOURCES SHOULD ONLY BE ENABLED
-;			AFTER THE CUDA MANAGER HAS BEEN INSTALLED.
-;________________________________________________________________________________________
-
-CudaWrXByte	cmp.l	#$8000,sp						; is there any stack yet?							<SM5>(rbm)<2> begin {
-			ble.s	@5								; no, use register based
-			cmp.w	#0,EgretBase
-			bne.s	@5
-			movec	vbr,d5							; get a copy of VBR
-			tst.l	d5								; is it zero?
-			bne.s	@5
-
-;	This code allows the low level routines to be used after the Cuda manager is installed
-;	by constructing a parameter block on the stack and issuing a call to CudaDispatch.  This
-;	is absolutely necessary because the low level routines do not detect collisions which can
-;	occur once the Cuda manager is installed.  Further, it is almost impossible to determine
-;	how to to synchronize Cuda after an asynchronous re-boot has occurred.
-
-			movem.l	a0-a6/d0/d3-d7,-(sp)
-			suba.l	#EgretPBSize,sp					; make room on the stack for Cuda parameter block
-			move.b	#pseudoPkt,pbCmdType(sp)		; set packet type
-			move.b	#WrPram,pbCmd(sp)				; set packet command
-			move.w	d1,pbParam(sp)					; set pram address
-			move.w	d2,pbParam+2(sp)				; set pram data
-			move.w	#1,pbByteCnt(sp)				; 1 byte to send
-			move.l	sp,pbBufPtr(sp)
-			add.l	#pbParam+2,pbBufPtr(sp)			; point to our data buffer
-			move.b	#0,pbFlags(sp)
-			move.w	#0,pbResult(sp)
-			move.l	#0,pbCompletion(sp)				; execute synchronously
-			move.l	sp,a0							; parameter block in a0
-			_EgretDispatch							; (this is actually the Cuda A-Trap)
-			adda.l	#EgretPBSize,sp					; remove parameter block from stack
-			movem.l	(sp)+,a0-a6/d0/d3-d7
-			jmp 	(a3)
-
-;	The following code is executed only when the Cuda manager is not installed.
-;	AT NO TIME SHOULD AN ASYNCHRONOUS MESSAGE SOURCE BE ENABLED PRIOR TO USE OF THIS ROUTINE.
-;	ASYNCHRONOUS MESSAGE SOURCES SHOULD ONLY BE ENABLED AFTER THE CUDA MANAGER HAS BEEN INSTALLED.
-
-@5			move.l	d2,d5							; Save the write data
-
-			ori.b	#ACRmode,vacr(a2)				; else initialize via mode
-			bset.b	#SRdir,vACR(a2)					; set output mode
-			move.b	#pseudopkt,vSR(a2)				; send packet type & clear any pending shift irq
-			bclr.b	#TIP,vBufB(a2)					; start the transaction
-@10 			
-			btst.b	#ifSR,vIFR(a2)					; Wait for shift register IRQ to indicate byte was read
-			beq.s	@10
-;________________________________________________________________________________________________
-;	When outputing from the VIA to Cuda, the interrupt will occur prior to the rising edge
-;	of CB1.  Delay long enough for the edge to occur before acknowledging the shift
-;	register interrupt.	(R. Montagne	1/11/93)
-;________________________________________________________________________________________________
-			move.b	#10,d2							; mode 7 interrupt occurs at falling edge CB1	<LW3><VIA rbm>
-@m7dly												;												<LW3><VIA rbm>
-			tst.b	vBufB(a1)						; hardware access is 1.2µS						<LW3><VIA rbm>
-			sub.b	#1,d2							; can only trash low byte						<LW3><VIA rbm>
-			bne.s	@m7dly							; wait long enough for CB1 to rise (10µS delay)	<LW3><VIA rbm>
-			tst.b	vSR(a2) 						; Clear the shift register IRQ
-
-	 		moveq	#wrpram,d2						; Send the command byte
-			BSR6	CudaWriteByte
-			move.l	d1,d2
-			lsr.l	#8,d2							; Send PRAM address MSB
-			BSR6	CudaWriteByte
-			move.l	d1,d2							; Send PRAM address LSB
-			BSR6	CudaWriteByte
-			move.l	d5,d2							; Send the write data
-			BSR6	CudaWriteByte
-	
-			bclr.b	#SRdir,vACR(a2)					; Define direction FROM Cuda
-			
-			ori.b	#((1<<vCudaTIP)|\
-					(1<<vCudaByteAck)),vBufB(a2)	; terminate current transaction
-			
-@40 		btst.b	#ifSR,vIFR(a2)					; Wait for attention byte shift register IRQ
-			beq.s	@40
-	
-			btst.b	#vCudaTReq,vBufB(a2)			; Is TReq asserted? (active low)
-			bne.s	@40 							; continue polling if TReq is not asserted
-			
-			tst.b	vSR(a2) 						; Read attn byte from VIA (clears IRQ)
-			bclr.b	#vCudaTIP,vBufB(a2)				; assert TIP to begin response transaction
-@20 			
-			btst.b	#ifSR,vIFR(a2)					; Wait for shift register IRQ to indicate byte was read
-			beq.s	@20
-			tst.b	vSR(a2) 						; Clear the shift register IRQ
-
-			ori.b	#((1<<vCudaTIP)|\
-					(1<<vCudaByteAck)),vBufB(a2)	; terminate the response transaction
-			
-@41 		btst.b	#ifSR,vIFR(a2)					; Wait for idle state IRQ
-			beq.s	@41
-			tst.b	vSR(a2) 						; Read idle state byte (clears IRQ)
-			jmp 	(a3)
-			
-;---------------------------------------------------------------------------
-
-			EXPORT	CudaWriteByte
-CudaWriteByte
-			move.b	d2,vSR(a2)					; Put data in VIA data reg
-			eori.b	#1<<vCudaByteAck,vBufB(a2)	; indicate data moved into VIA
-@10 			
-			btst.b	#ifSR,vIFR(a2)				; Wait for shift register IRQ to indicate byte was read
-			beq.s	@10
-;________________________________________________________________________________________________
-;	When outputing from the VIA to Cuda, the interrupt will occur prior to the rising edge
-;	of CB1.  Delay long enough for the edge to occur before acknowledging the shift
-;	register interrupt.	(R. Montagne	1/11/93)
-;________________________________________________________________________________________________
-			move.b	#10,d2						; mode 7 interrupt occurs at falling edge CB1	<LW3><VIA rbm>
-@m7dly											;												<LW3><VIA rbm>
-			tst.b	vBufB(a1)					; hardware access is 1.2µS						<LW3><VIA rbm>
-			sub.b	#1,d2						; can only trash low byte						<LW3><VIA rbm>
-			bne.s	@m7dly						; wait long enough for CB1 to rise (10µS delay)	<LW3><VIA rbm>
-			tst.b	vSR(a2) 					; Clear the shift register IRQ
-			RTS6
-
-;---------------------------------------------------------------------------
-
-			EXPORT	CudaReadByte
-CudaReadByte
-			btst.b	#ifSR,vIFR(a2)				; Wait for IRQ
-			beq.s	CudaReadByte
-			move.b	vSR(a2),d2					; Read data from VIA (clears IRQ)
-			and.w	#$00FF,d2					; isolate the byte
-			eori.b	#1<<vCudaByteAck,vBufB(a2)	; handshake the byte
-			btst.b	#vCudaTReq,vBufB(a2)		; Return with state of TReq Session				<SM5>(rbm)<2> end }
-			RTS6
-
-
-			ENDWITH							; {EgretPB}
-		ENDIF								; {hasEgret}
-
-
-
-		IF hasProtectedPRAM THEN
-; •••••••••••••••••••••••• PRAM in VRAM, clock is someplace else ••••••••••••••••••••••••
-			WITH	ProductInfo, VideoInfo
-
-;________________________________________________________________________________________
-;
-; Routine:	NoPRAMReadTime
-;
-; Inputs:	none
-;
-; Outputs:	D0	-	result code
-;			"GetParam" contains the 32-bit time value read from the clock
-;
-; Trashes:	TBD
-;
-; Function:	Would read the time from the clock if we knew what kind it was.  This routine
-;			is provided as an aid to the person who has to code for this case.
-;________________________________________________________________________________________
-
-NoPRAMReadTime
-			MOVEQ	#dsCoreErr,D0			; just die so we know something didn't happen
-			_SysError
-			MOVEQ	#clkRdErr,D0			;  and leave this as a clue to why
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	NoPRAMWriteTime
-;
-; Inputs:	"Time" contains 32-bit quantity to write to clock
-;
-; Outputs:	D0	-	result code
-;
-; Trashes:	TBD
-;
-; Function:	Would write the time to the clock if we knew what kind it was.  This routine
-;			is provided as an aid to the person who has to code for this case.
-;________________________________________________________________________________________
-
-NoPRAMWriteTime
-			MOVEQ	#dsCoreErr,D0			; just die so we know something didn't happen
-			_SysError
-			MOVEQ	#clkWrErr,D0			;  and leave this as a clue to why
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	NoPRAMXParam
-;
-; Inputs:	A0	-	pointer to user's buffer
-;			D0	-	[number of bytes to transfer][starting PRAM address]
-;			D1	-	bit 12: 1=read, 0=write
-;
-; Outputs:	D0	-	result code
-;
-; Trashes:	A0,A1,A2,D1,D2,D3
-;
-; Function:	reads/writes byte[s] from parameter RAM that hides in unused video RAM
-;			(assumes that traps and the MMU are set up)
-;________________________________________________________________________________________
-
-NoPRAMXParam
-			MOVEA.L	A0,A2					; save the pointer to the user's buffer,
-			MOVE.L	D0,D3					;  and the starting PRAM address and count
-
-			MOVEQ	#true32b,D0				; switch into 32-bit addressing mode
-			_SwapMMUMode
-
-			MOVEA.L	UnivInfoPtr,A1			; point to this machine's product info,
-			ADDA.L	VideoInfoPtr(A1),A1		;  which leads to video info,
-			MOVEA.L	VRAMPhysAddr(A1),A1		;   which leads to the base address of video,
-			LEA		-256(A1),A1				;    which leads to PRAM in unused video memory
-			ADD.W	D3,A1					; index into start of desired PRAM
-			SWAP 	D3						; get the number of bytes to transfer
-			BTST	#12,D1					; is it a write?
-			BNE.S	@StartCopy				; -> no
-			EXG		A1,A2					; yes, exchange source and destination pointers
-			BRA.S	@StartCopy
-			
-@CopyPRAM	MOVE.B	(A1)+,(A2)+				; move the bytes
-@StartCopy	DBRA	D3,@CopyPRAM
-
-			_SwapMMUMode					; restore the addressing mode
-			MOVEQ	#0,D0					; never an error
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	NoPRAMXPramIO
-;
-; Inputs:	A0 -- pointer to table of base addresses
-;			A1 -- pointer to ProductInfo record for this machine
-;			A3 -- pointer to PRAM I/O buffer
-;			D1 -- flags indicating which external features are valid
-;			D3 -- [r/w (bit 31)][number of PRAM bytes to read/write][starting PRAM address]
-;
-; Outputs:	none
-;
-; Trashes:	A2,A3,D3
-;
-; Function:	reads/writes byte[s] from parameter RAM that hides in unused video RAM
-;			before traps (or the MMU) are set up
-;________________________________________________________________________________________
-
-NoPRAMXPramIO
-			MOVEA.L	A1,A2					; point to this machine's product info,
-			ADDA.L	VideoInfoPtr(A2),A2		;  which leads to video info,
-			MOVEA.L	VRAMPhysAddr(A2),A2		;   which leads to the base address of video,
-			LEA		-256(A2),A2				;    which leads to PRAM in unused video memory
-			ADD.W	D3,A2					; index into start of desired PRAM
-			SWAP 	D3						; get the number of bytes to transfer
-			BCLR	#15,D3					; is it a write?
-			BEQ.S	@StartCopy				; -> no
-			EXG		A2,A3					; yes, exchange source and destination pointers
-			BRA.S	@StartCopy
-			
-@CopyPRAM	MOVE.B	(A2)+,(A3)+				; move the bytes
-@StartCopy	DBRA	D3,@CopyPRAM
-			RTS
-
-
-;________________________________________________________________________________________
-;
-; Routine:	NoPRAMRdXByte
-;
-; Inputs:	D1	-	address of PRAM byte to read
-;			A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A3	-	return address
-;
-; Outputs:	D1	-	byte read from PRAM
-;
-; Trashes:	A0,D0
-;
-; Function:	reads a byte from parameter RAM that hides in unused video RAM without using RAM
-;________________________________________________________________________________________
-
-NoPRAMRdXByte
-			MOVEA.L	A1,A0					; point to this machine's product info,
-			ADDA.L	VideoInfoPtr(A0),A0		;  which leads to video info,
-			MOVEA.L	VRAMPhysAddr(A0),A0		;   which leads to the base address of video,
-			LEA		-256(A0),A0				;    which leads to PRAM in unused video memory
-			MOVEQ	#0,D0
-			MOVE.B	D1,D0					; zero-extend the byte number to make an index
-			MOVE.B	0(A0,D0),D1				;  and get the byte
-			JMP		(A3)
-
-
-;________________________________________________________________________________________
-;
-; Routine:	NoPRAMWrXByte
-;
-; Inputs:	D1	-	address of PRAM byte to write
-;			D2	-	byte to write to PRAM
-;			A1	-	pointer to ProductInfo record for this machine
-;			A2	-	VIA1 base address
-;			A3	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	A0,D0
+; Trashes:	D0,D1,D2,A0,A5,A6
 ;
-; Function:	writes a byte to parameter RAM that hides in unused video RAM without using RAM
+; Function:	write-enables the clock chip if supported by the clock implementation
 ;________________________________________________________________________________________
 
-NoPRAMWrXByte
-			MOVEA.L	A1,A0					; point to this machine's product info,
-			ADDA.L	VideoInfoPtr(A0),A0		;  which leads to video info,
-			MOVEA.L	VRAMPhysAddr(A0),A0		;   which leads to the base address of video,
-			LEA		-256(A0),A0				;    which leads to PRAM in unused video memory
-			MOVEQ	#0,D0
-			MOVE.B	D1,D0					; zero-extend the byte number to make an index
-			MOVE.B	D2,0(A0,D0)				;  and write the byte
-			JMP		(A3)
-
-
-			ENDWITH							; {ProductInfo, VideoInfo}
-		ENDIF								; {hasProtectedPRAM}
-
-
-; ••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
-
-
-;________________________________________________________________________________________
-;
-; Routine:	ClkNoMem
-;
-; Inputs:	A1	-	VIA 1 base address
-;			A5	-	return address (BSR5)
-;			D1	-	clock chip command byte (bit 7: 0=write, 1=read)
-;			D2	-	data byte to write
-;
-; Outputs:	D2	-	data byte read
-;
-; Trashes:	A0,A1,A5,A6,D1,D3
-;
-; Function:	support for the jClkNoMem vector (do we still need this?)
-;________________________________________________________________________________________
-
-			EXPORT	ClkNoMem
-ClkNoMem	RTS5
-;________________________________________________________________________________________			<H9>thru next <H9>
-; These patches change the behavior of StandardXPramIO so that during a multi-byte
-; write to PRAM, interrupts are disabled and re-enabled around the write of each byte,
-; and the RTC is write-enabled and then write-protected again during the time that
-; interrupts are off.  This fixes a problem where the Reliability Manager's interrupt
-; task, which calls this routine to write to PRAM every 5 minutes, interrupts during
-; this loop, resulting in PRAM being left write-protected; when control returns to the
-; foreground, remaining bytes to be written to PRAM don't get written.
-;
-; Monte Benaresh - 7/2/93
-;________________________________________________________________________________________
+ClkWPOff	MOVEA.L	A1,A5					; point to this machine's product info					<H3>
+			ADDA.L	ProductInfo.ClockPRAMPtr(A5),A5	;  and get the address of its clock/PRAM table	<H3>
+			MOVE.L	4*cpWrProtOff(A5),D0	; get the offset to the routine							<H3>
+			BEQ.S	@NoEntry				; -> this function is not supported						<H3>
+			ADDA.L	D0,A5					; calculate the routine's address						<H3>
+			EXG		A6,A5					; save return address in A5, put routine's address in A6<H3>
+@NoEntry	JMP		(A6)					;  and either call the routine or just return			<H3>
 
-StdXPRAM2Patch								; patch for StandardXPramIO
-			MOVEA.L	A1,A6					; point to this machine's product info
-			ADDA.L	ProductInfo.ClockPRAMPtr(A6),A6	;  and get the address of its clock/PRAM table
-			MOVE.L	4*cpWrProtOn(A6),D0		; get the offset to the write-protect routine
-			BEQ.S	@Done					; -> it's not supported for this implementation
-			ADDA.L	D0,A6					; calculate the routine's address
-			movea.l	(sp)+,A5				; simulate a BSR5 which returns to our caller
-			JMP		(A6)					; and call it to turn on PRAM write-protect
-@Done
-			rts								;														<H9>
 
 			END
diff --git a/OS/IoPrimitives/IOPrimitives.make b/OS/IoPrimitives/IOPrimitives.make
--- a/OS/IoPrimitives/IOPrimitives.make
+++ b/OS/IoPrimitives/IOPrimitives.make
@@ -16,10 +16,9 @@
 
 
 
-IOPrimitivesObjs	=					"{ObjDir}PowerMgrPrimitives.a.o"			∂
-										"{ObjDir}ImmgPrimitives.a.o"				∂
-										"{ObjDir}ADBPrimitives.a.o"					∂
+IOPrimitivesObjs	=					"{ObjDir}ADBPrimitives.a.o"					∂
 										"{ObjDir}ClockPRAMPrimitives.a.o"			∂
+										"{ObjDir}NVRAMPrimitives.c.o"				∂
 										"{ObjDir}backlightprim.a.o"					∂
 										"{ObjDir}backlightinput.c.o"									∂
 										"{ObjDir}backlightcpu.c.o"										∂
@@ -34,7 +33,6 @@ IOPrimitivesObjs	=					"{ObjDir}PowerMgrPrimitives.a.o"			∂
 "{ObjDir}ADBPrimitives.a.o"			ƒ	"{ObjDir}StandardEqu.d"						∂
 										"{IntAIncludes}HardwarePrivateEqu.a"		∂
 										"{IntAincludes}UniversalEqu.a"				∂
-										"{IntAincludes}SoundPrivate.a"				∂
 										"{IntAincludes}PowerPrivEqu.a"				∂
 										"{IntAincludes}EgretEqu.a"					∂
 										"{IntAincludes}IopEqu.a"					∂
@@ -56,7 +54,6 @@ IOPrimitivesObjs	=					"{ObjDir}PowerMgrPrimitives.a.o"			∂
 
 "{ObjDir}PowerMgrPrimitives.a.o"	ƒ	"{ObjDir}StandardEqu.d"						∂
 										"{IntAIncludes}HardwarePrivateEqu.a"		∂
-										"{IntAincludes}SoundPrivate.a"				∂
 										"{IntAIncludes}UniversalEqu.a"				∂
 										"{IntAIncludes}PowerPrivEqu.a"				∂
 										"{IntAIncludes}MMUEqu.a"					∂
@@ -88,7 +85,6 @@ IOPrimitivesObjs	=					"{ObjDir}PowerMgrPrimitives.a.o"			∂
 
 "{ObjDir}SndPrimitives.a.o"			ƒ	"{ObjDir}StandardEqu.d"						∂
 										"{IntAIncludes}HardwarePrivateEqu.a"		∂
-										"{IntAincludes}SoundPrivate.a"				∂
 										"{IntAIncludes}IOPrimitiveEqu.a"			∂
 										"{IntAIncludes}UniversalEqu.a"				∂
 										"{IOPrimitivesDir}SndPrimitives.a"
diff --git a/OS/IoPrimitives/PowerMgrPrimitives.a b/OS/IoPrimitives/PowerMgrPrimitives.a
--- a/OS/IoPrimitives/PowerMgrPrimitives.a
+++ b/OS/IoPrimitives/PowerMgrPrimitives.a
@@ -148,7 +148,6 @@
 			PRINT	OFF				
 			LOAD	'StandardEqu.d'
 			INCLUDE	'HardwarePrivateEqu.a'
-			INCLUDE	'SoundPrivate.a'
 			INCLUDE	'UniversalEqu.a'
 			INCLUDE	'PowerPrivEqu.a'
 			INCLUDE	'PowerMgrDispatchEqu.a'
diff --git a/OS/IoPrimitives/SndPrimitives.a b/OS/IoPrimitives/SndPrimitives.a
--- a/OS/IoPrimitives/SndPrimitives.a
+++ b/OS/IoPrimitives/SndPrimitives.a
@@ -153,7 +153,6 @@
 			print	off
 			LOAD	'StandardEqu.d'
 			include	'HardwarePrivateEqu.a'
-			include	'SoundPrivate.a'
 			include	'UniversalEqu.a'
 			include	'PowerPrivEqu.a'
 			include	'EgretEqu.a'
@@ -167,54 +166,7 @@
 
 
 
-;_________________________________________________________________________________________
-;	Install Sound Primitives routines into ExpandMem vector
-
-
 InstallSndPrimitives	proc export
-			WITH	DecoderInfo,DecoderKinds,ProductInfo,SoundIOHeader,ExpandMemRec
-			WITH	SleepqRec,pmCommandRec,PmgrRec
-
-			IMPORT	ClearSoundInt							; InterruptHandlers.a
-			IMPORT	DisableSoundInts						; InterruptHandlers.a
-			IMPORT	EnableSoundInts							; InterruptHandlers.a
-			IMPORT	GetHardwareInfo							; Universal.a
-			IMPORT	RDXBYTE									; USTPram.a
-
-			EXPORT	InitSndHW, InitSndNoRAM
-
-
-;	Convert ROM sound primitive offset table into a RAM pointer table.
-
-			movea.l	UnivInfoPtr,a1						; a1 = ptr to productinfo record
-			move.l	ProductInfo.SndControlPtr(a1),d0	; get offset to sound vector tbl
-			adda.l	d0,a1								; a1 = ptr to ROM tbl
-			moveq.l	#0,d0								; clear d0
-			move.w	SndTblLength(a1),d0					; d0 = number of entries in table
-			asl.l	#2,d0								; convert long entries to byte count
-			addq.l	#SoundIOHeaderSize,d0				; size of global header records
-			_NewPtr	,sys,clear							; alloc storage
-
-			adda.l	#SoundIOHeaderSize,a0				; inc past global header
-			move.l	a0,([Expandmem],\
-					ExpandMemRec.emSndPrimitives)		; set the expandmem pointer
-
-			move.b	#sndAGCOff,UserAGC(a0)				; init AGC off as default
-
-;	Convert the offset values in the original table to long addresses in the RAM-based
-;	table.  a0 = ptr to new RAM-based tbl, a1 = ptr to old ROM table
-
-			move.w	SndTblLength(a1),d0					; get number of entries in table
-			subq.w	#1,d0								; adjust for dbra
-			move.l	a1,d1								; d1 = address of ROM/RAM table
-@Loop
-			move.l	(a1)+,(a0)							; get routine offset
-			add.l	d1,(a0)+							; add ROM/RAM table address to convert to 32 bit address
-			dbra	d0,@Loop
-
-			moveq.l	#1,d0								; default all cpu's with AGC on
-			jsrTBL	sndAGCcontrol
-			rts
 
 
 ;_________________________________________________________________________________________
@@ -228,1856 +180,40 @@ InstallSndPrimitives	proc export
 			align	4
 
 
-		IF hasVISADecoder THEN
-			Export	SndCntlClassicII,SndCntlLC
-			dc.w	0										; flags
-			dc.w	(SndCntlClassicIIEnd-SndCntlClassicII)/4 ; number of entries
-SndCntlLC													;										<H16>
-SndCntlClassicII
-			dc.l	ElsieDFACInit-SndCntlClassicII
-			dc.l	EgretDFACSend-SndCntlClassicII
-			dc.l	ASCSetVol-SndCntlClassicII
-			dc.l	EnableSoundInts-SndCntlClassicII
-			dc.l	DisableSoundInts-SndCntlClassicII
-			dc.l	ClearSoundInt-SndCntlClassicII
-			dc.l	ElsieInputSelect-SndCntlClassicII
-			dc.l	QueryInput-SndCntlClassicII
-			dc.l	ByPassControl-SndCntlClassicII
-			dc.l	PlayThruVol-SndCntlClassicII
-			dc.l	AGCControl-SndCntlClassicII
-			dc.l	ASCInitSoundHW-SndCntlClassicII			;										<SM9>
-SndCntlClassicIIEnd
-		ENDIF
-
-		IF hasMDU THEN
-			Export	SndCntlMacIIsi 							;			<SM10> PN.start
-			dc.w	0										; flags     <SM10> PN
-			dc.w	(SndCntlMacIIsiEnd-SndCntlMacIIsi)/4		; number of entries <SM10> PN
-SndCntlMacIIsi
-			dc.l	ElsieDFACInit-SndCntlMacIIsi
-			dc.l	EgretDFACSend-SndCntlMacIIsi
-			dc.l	ASCSetVol-SndCntlMacIIsi
-			dc.l	EnableSoundInts-SndCntlMacIIsi
-			dc.l	DisableSoundInts-SndCntlMacIIsi
-			dc.l	ClearSoundInt-SndCntlMacIIsi
-			dc.l	InputSelect-SndCntlMacIIsi
-			dc.l	QueryInput-SndCntlMacIIsi
-			dc.l	ByPassControl-SndCntlMacIIsi
-			dc.l	PlayThruVol-SndCntlMacIIsi
-			dc.l	AGCControl-SndCntlMacIIsi
-			dc.l	ASCInitSoundHW-SndCntlMacIIsi			;			<SM10> PN.end
-SndCntlMacIIsiEnd
-		ENDIF
-
-
-		IF hasOrwell THEN
-			Export	SndCntlQuadra900
-			dc.w	0										; flags
-			dc.w	(SndCntlQuadra900End-SndCntlQuadra900)/4 ; number of entries
-SndCntlQuadra900
-SndCntlQuadra950
-			dc.l	EclipseDFACInit-SndCntlQuadra900
-			dc.l	EgretDFACSend-SndCntlQuadra900			;										<t6>
-			dc.l	ASCSetVol-SndCntlQuadra900
-			dc.l	EnableSoundInts-SndCntlQuadra900
-			dc.l	DisableSoundInts-SndCntlQuadra900
-			dc.l	ClearSoundInt-SndCntlQuadra900
-			dc.l	EclipseInputSelect-SndCntlQuadra900		;										<t6>
-			dc.l	QueryInput-SndCntlQuadra900
-			dc.l	ByPassControl-SndCntlQuadra900
-			dc.l	PlayThruVol-SndCntlQuadra900
-			dc.l	AGCControl-SndCntlQuadra900
-			dc.l	BatmanInitSoundHW-SndCntlQuadra900
-SndCntlQuadra900End
-
-			Export	SndCntlQuadra700
-			dc.w	0										; flags
-			dc.w	(SndCntlQuadra700End-SndCntlQuadra700)/4 ; number of entries
-SndCntlQuadra700
-			dc.l	SpikeDFACInit-SndCntlQuadra700
-			dc.l	VIA2DFACSend-SndCntlQuadra700
-			dc.l	ASCSetVol-SndCntlQuadra700
-			dc.l	EnableSoundInts-SndCntlQuadra700
-			dc.l	DisableSoundInts-SndCntlQuadra700
-			dc.l	ClearSoundInt-SndCntlQuadra700
-			dc.l	InputSelect-SndCntlQuadra700			;										<t14>
-			dc.l	QueryInput-SndCntlQuadra700
-			dc.l	ByPassControl-SndCntlQuadra700
-			dc.l	PlayThruVol-SndCntlQuadra700
-			dc.l	AGCControl-SndCntlQuadra700
-			dc.l	BatmanInitSoundHW-SndCntlQuadra700		;										<SM9>
-SndCntlQuadra700End
-		ENDIF
-
-
-		IF hasJaws THEN
-			Export	SndCntlPB170
-			dc.w	0										; flags
-			dc.w	(SndCntlPB170End-SndCntlPB170)/4		; number of entries
-SndCntlPB170
-			dc.l	TimDFACInit-SndCntlPB170
-			dc.l	VIA2DFACSend-SndCntlPB170
-			dc.l	TimPlayBackVol-SndCntlPB170
-			dc.l	EnableSoundInts-SndCntlPB170
-			dc.l	DisableSoundInts-SndCntlPB170
-			dc.l	ClearSoundInt-SndCntlPB170
-			dc.l	TIMInputSelect-SndCntlPB170				;										<t11>
-			dc.l	QueryInput-SndCntlPB170
-			dc.l	ByPassControl-SndCntlPB170
-			dc.l	PlayThruVol-SndCntlPB170
-			dc.l	AGCControl-SndCntlPB170
-			dc.l	JawsInitSoundHW-SndCntlPB170			;										<SM9>
-SndCntlPB170End
-		ENDIF
-
-
-		IF hasNiagra THEN
-			Export	SndCntlPB180
-			dc.w	0										; flags
-			dc.w	(SndCntlPB180End-SndCntlPB180)/4		; number of entries
-SndCntlPB180												; <H13>
-			dc.l	DartDFACInit-SndCntlPB180
-			dc.l	VIA2DFACSend-SndCntlPB180
-			dc.l	TimPlayBackVol-SndCntlPB180
-			dc.l	EnableSoundInts-SndCntlPB180
-			dc.l	DisableSoundInts-SndCntlPB180
-			dc.l	ClearSoundInt-SndCntlPB180
-			dc.l	DartInputSelect-SndCntlPB180			;										<t11>
-			dc.l	DartQueryInput-SndCntlPB180				;										<H19>
-			dc.l	ByPassControl-SndCntlPB180
-			dc.l	DartPlayThruVol-SndCntlPB180			;										<H19>
-			dc.l	AGCControl-SndCntlPB180
-			dc.l	NiagraInitSoundHW-SndCntlPB180			;										<SM9>
-SndCntlPB180End
-		ENDIF
-
-
-		IF hasMSC THEN
-			Export	SndCntlPBDuo210
-			dc.w	0										; flags
-			dc.w	(SndCntlPBDuo210End-SndCntlPBDuo210)/4	; number of entries
-SndCntlPBDuo210
-			dc.l	DBLiteDFACInit-SndCntlPBDuo210
-			dc.l	DBLiteDFACSend-SndCntlPBDuo210
-			dc.l	DBLiteSetVol-SndCntlPBDuo210			;										<H18>
-			dc.l	EnableSoundInts-SndCntlPBDuo210
-			dc.l	DisableSoundInts-SndCntlPBDuo210
-			dc.l	ClearSoundInt-SndCntlPBDuo210
-			dc.l	DBInputSelect-SndCntlPBDuo210			;										<H2>
-			dc.l	QueryInput-SndCntlPBDuo210
-			dc.l	ByPassControl-SndCntlPBDuo210
-			dc.l	PlayThruVol-SndCntlPBDuo210
-			dc.l	AGCControl-SndCntlPBDuo210
-			dc.l	ASCInitSoundHW-SndCntlPBDuo210			;										<SM9>
-SndCntlPBDuo210End											;										<t6>
-
-			Export	SndCntlYeager							;									<t6>
-			dc.w	0										; flags
-			dc.w	(SndCntlYeagerEnd-SndCntlYeager)/4		; number of entries
-SndCntlYeager
-			dc.l	DBLiteDFACInit-SndCntlYeager			; (sndDFACInit)
-			dc.l	DBLiteDFACSend-SndCntlYeager			; (sndDFACSend)
-			dc.l	DBLiteSetVol-SndCntlYeager				; (sndPlaybackVol)
-			dc.l	EnableSoundInts-SndCntlYeager			; (sndEnableInt)
-			dc.l	DisableSoundInts-SndCntlYeager			; (sndDisableInt)
-			dc.l	ClearSoundInt-SndCntlYeager				; (sndClearInt)
-			dc.l	DBInputSelect-SndCntlYeager				; (sndInputSelect)
-			dc.l	QueryInput-SndCntlYeager				; (sndInputSource)
-			dc.l	ByPassControl-SndCntlYeager				; (sndAuxByPass)
-			dc.l	PlayThruVol-SndCntlYeager				; (sndPlayThruVol)
-			dc.l	AGCControl-SndCntlYeager				; (sndAGCcontrol)
-			dc.l	ASCInitSoundHW-SndCntlYeager			; (sndInitSoundHW)
-			dc.l	DoNothing-SndCntlYeager					; (sndInitGlobals)
-			dc.l	DoNothing-SndCntlYeager					; (sndModemSound)
-			dc.l	DoNothing-SndCntlYeager					; (sndModemSndVol)
-			dc.l	DoNothing-SndCntlYeager					; (sndGetSmplRate)
-			dc.l	DoNothing-SndCntlYeager					; (sndSetSmplRate)
-			dc.l	DoNothing-SndCntlYeager					; (sndGetInputGain)
-			dc.l	DoNothing-SndCntlYeager					; (sndSetInputGain)
-			dc.l	DoNothing-SndCntlYeager					; (sndPlayThruCntl)
-			dc.l	DoNothing-SndCntlYeager					; (sndSoundHWCntl)
-			dc.l	DoNothing-SndCntlYeager					; (sndSoundHWState)
-			dc.l	DoNothing-SndCntlYeager					; (sndVirtualHWHook)
-SndCntlYeagerEnd											;									<t6>
-		ENDIF
-
-		IF hasDJMEMC THEN
-			EXPORT	SndCntlQuadra800
-			dc.w	0										; flags
-			dc.w	(SndCntlQuadra800End-SndCntlQuadra800)/4; number of entries
-SndCntlQuadra800
-			dc.l	SpikeDFACInit-SndCntlQuadra800
-			dc.l	VIA2DFACSend-SndCntlQuadra800
-			dc.l	ASCSetVol-SndCntlQuadra800
-			dc.l	EnableSoundInts-SndCntlQuadra800
-			dc.l	DisableSoundInts-SndCntlQuadra800
-			dc.l	ClearSoundInt-SndCntlQuadra800
-			dc.l	InputSelect-SndCntlQuadra800
-			dc.l	QueryInput-SndCntlQuadra800
-			dc.l	ByPassControl-SndCntlQuadra800
-			dc.l	PlayThruVol-SndCntlQuadra800
-			dc.l	AGCControl-SndCntlQuadra800
-			dc.l	DJMEMCInitSoundHW-SndCntlQuadra800		;										<SM9>
-SndCntlQuadra800End
-		ENDIF
-
-		IF hasPratt THEN
-			Export	SndCntlBlackbird
-			dc.w	0										; flags (SuperMario style table)
-			dc.w	(SndCntlBlackEnd-SndCntlBlackbird)/4	; number of entries
-SndCntlBlackbird
-			dc.l	DoNothingViaA6-SndCntlBlackbird			; (sndDFACInit)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndDFACSend)
-			dc.l	ASCSetVol-SndCntlBlackbird				; (sndPlaybackVol)
-			dc.l	EnableSoundInts-SndCntlBlackbird		; (sndEnableInt)
-			dc.l	DisableSoundInts-SndCntlBlackbird		; (sndDisableInt)
-			dc.l	ClearSoundInt-SndCntlBlackbird			; (sndClearInt)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndInputSelect)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndInputSource)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndAuxByPass)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndPlayThruVol)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndAGCcontrol)
-			dc.l	WhitneyInitSoundHW-SndCntlBlackbird		; (sndInitSoundHW)
-			dc.l	DoNothing-SndCntlBlackbird				; (dontUse1)
-			dc.l	DoNothing-SndCntlBlackbird				; (dontUse2)
-			dc.l	DoNothing-SndCntlBlackbird				; (dontUse3)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndInitSoundHW2)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndInitGlobals)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndModemSound)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndModemSndVol)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndGetSmplRate)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndSetSmplRate)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndGetInputGain)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndSetInputGain)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndPlayThruCntl)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndSoundHWCntl)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndSoundHWState)
-			dc.l	DoNothing-SndCntlBlackbird				; (sndVirtualHWHook)
-SndCntlBlackEnd											
-		ENDIF
-
-		IF hasSonora THEN
-			Export	SndCntlSonora
-			dc.w	0										; flags
-			dc.w	(SndCntlSonoraEnd-SndCntlSonora)/4		; number of entries
-SndCntlSonora
-			dc.l	SonoraDFACInit-SndCntlSonora
-			dc.l	EgretDFACSend-SndCntlSonora
-			dc.l	ASCSetVol-SndCntlSonora
-			dc.l	EnableSoundInts-SndCntlSonora
-			dc.l	DisableSoundInts-SndCntlSonora
-			dc.l	ClearSoundInt-SndCntlSonora
-			dc.l	SonoraInputSelect-SndCntlSonora
-			dc.l	QueryInput-SndCntlSonora
-			dc.l	ByPassControl-SndCntlSonora
-			dc.l	PlayThruVol-SndCntlSonora
-			dc.l	AGCControl-SndCntlSonora
-			dc.l	BatmanInitSoundHW-SndCntlSonora			;										<SM9>
-SndCntlSonoraEnd
-
-			Export	SndCntlLCIII
-			dc.w	0										; flags
-			dc.w	(SndCntlLCIIIEnd-SndCntlLCIII)/4		; number of entries
-SndCntlLCIII
-			dc.l	SonoraDFACInit-SndCntlLCIII
-			dc.l	EgretDFACSend-SndCntlLCIII
-			dc.l	VailSetVol-SndCntlLCIII
-			dc.l	EnableSoundInts-SndCntlLCIII
-			dc.l	DisableSoundInts-SndCntlLCIII
-			dc.l	ClearSoundInt-SndCntlLCIII
-			dc.l	VailInputSelect-SndCntlLCIII
-			dc.l	QueryInput-SndCntlLCIII
-			dc.l	ByPassControl-SndCntlLCIII
-			dc.l	PlayThruVol-SndCntlLCIII
-			dc.l	AGCControl-SndCntlLCIII
-			dc.l	BatmanInitSoundHW-SndCntlLCIII			;										<SM9>
-SndCntlLCIIIEnd
-		ENDIF
-
-
-			Export	SndCntlCyclone
-			dc.w	0										; flags
-			dc.w	(SndCntlCycloneEnd-SndCntlCyclone)/4	; number of entries
-SndCntlCyclone
-			dc.l	CycloneSndStubNoRam-SndCntlCyclone		; Fake ’em for now.
-			dc.l	CycloneSndStub1-SndCntlCyclone
-			dc.l	CycloneSndStub1-SndCntlCyclone
-			dc.l	CycloneSndStub1-SndCntlCyclone
-			dc.l	CycloneSndStub1-SndCntlCyclone
-			dc.l	CycloneSndStub1-SndCntlCyclone
-			dc.l	CycloneSndStub1-SndCntlCyclone
-			dc.l	CycloneSndStub2-SndCntlCyclone
-			dc.l	CycloneSndStub1-SndCntlCyclone
-			dc.l	CycloneSndStub1-SndCntlCyclone
-			dc.l	CycloneSndStub1-SndCntlCyclone
-			dc.l	CycloneSndStubNoRam-SndCntlCyclone		;										<SM9>
-SndCntlCycloneEnd
-
-
-			Export	SndCntlPDM
-			dc.w	0										; flags
-			dc.w	(SndCntlPDMEnd-SndCntlPDM)/4			; number of entries
-SndCntlPDM													; Fake 'em
-			dc.l	PDMSndStubNoRam-SndCntlPDM				; For machines that need to init DFAC via Egret
-			dc.l	PDMSndStub1-SndCntlPDM					; For machines that use Egret to talk to DFAC
-			dc.l	PDMSndStub1-SndCntlPDM					; Set Volume
-			dc.l	PDMSndStub1-SndCntlPDM					; Enable Sound Interrupts
-			dc.l	PDMSndStub1-SndCntlPDM					; Disable Sound Interrupts
-			dc.l	PDMSndStub1-SndCntlPDM					; Clear Sound Interrupt(s)
-			dc.l	PDMSndStub1-SndCntlPDM					; Input Select
-			dc.l	PDMSndStub2-SndCntlPDM					; Query which input device(s) is/are selected
-			dc.l	PDMSndStub1-SndCntlPDM					; Enable/Disable Aux Bypass
-			dc.l	PDMSndStub1-SndCntlPDM					; Set PlayThru Volume
-			dc.l	PDMSndStub1-SndCntlPDM					; Enable/Disable AGC
-			dc.l	PDMSndStubNoRam-SndCntlPDM				; InitSoundHW - called by StartInit to set vol
-SndCntlPDMEnd
-
-
-
-;••••••••••••••••••••••••••••••••••• Common Routines ••••••••••••••••••••••••••••••••••••
-
-
-;——————————————————————————————————————————————————————————————————————————————						<SM9>
-; Routine:	InitSndHW
-;
-; Inputs:	none
-;
-; Outputs:	none
-;
-; Trashes:	D0-D1
-;
-; Function:	This routine is meant to be called after lowmem has been setup.
-;			It calls common RAM-less code in the system to initialize the
-;			sound hardware.
-;——————————————————————————————————————————————————————————————————————————————
-
-InitSndHW	movem.l	d3-d4/a0-a6,-(sp)
-			movea.l	UnivInfoPtr,a1					; point to the machine's ProductInfo table
-			MOVEA.L	A1,A0
-			adda.l	ProductInfo.DecoderInfoPtr(a0),a0 ;  and to its DecoderInfo table
-			move.b	SdVolume,d0						; get the sound volume
-			moveq.l	#1,d1						; flag RAM routine origin for InitSoundHW <ged>
-			bsr6	InitSoundHW						; initialize the sound hardware (trashes d0-d4/a0-a6)
-			movem.l	(sp)+,d3-d4/a0-a6
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————						<SM9>
-; Routine:	InitSndNoRAM
-;
-; Inputs:	A5	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0-D4, A0-A6
-;
-; Function:	called by BSR5 to initialize sound hardware without using RAM
-;——————————————————————————————————————————————————————————————————————————————
-
-InitSndNoRam
-			move.l	a5,d3							; save return addr in d3
-
-;	Setup necessary registers
-
-			moveq.l	#0,d2							; decoder unknown
-			bsr6	GetHardwareInfo					; get decoder address (trashes d0-d2/a0-a2/a5/a6)
-			movea.l	DecoderInfo.VIA1Addr(a0),a2		; get VIA1 base addr for PRAM routine
-
-;	Call start test utility to read sound volume from pram
-
-			move.w	#$10,d1							; pram addr of validation byte
-			bsr6	RdXByte							; trashes d0,d2,a0,a3,a4,a5
-			cmpi.b	#$a8,d1							; is PRAM valid?
-			beq.s	@pramValid						; pram is valid
-			moveq.l	#5,d1							; pram invalid - fake a volume level of 5
-			bra.s	@skipRead
-@pramValid
-			move.w	#8,d1							; pram addr of sound volume
-			bsr6	RdXByte							; trashes d0,d2,a0,a3,a4,a5
-@skipRead
-			and.b	#%00000111,d1					; mask volume bits
-			bne.s	@nonZeroVol						; a good non-zero volume
-			move.b	#5,d1							; set minimum volume for boot beep
-@nonZeroVol
-			move.b	d1,d4							; save pram value
-
-;	Setup registers again
-
-			moveq.l	#0,d2							; decoder unknown
-			bsr6	GetHardwareInfo					; get decoder address (trashes d0-d2/a0-a2/a5)
-
-			move.b	d4,d0							; restore volume
-			moveq.l	#0,d1							; flag RAMless routine origin for InitSoundHW	<SMXX>
-			bsr6	InitSoundHW						; init sound (trashes d0-d1/a3/a6)
-
-			movea.l	d3,a5							; restore return address
-			rts5
-
-
-;——————————————————————————————————————————————————————————————————————————————						<SM9>
-; Routine:	InitSoundHW
-;
-; Inputs:	D0	-	sound volume (0-7)
-;			A0	-	pointer to DecoderInfo table
-;			A1	-	pointer to ProductInfo table
-;			A6	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0-D1, A3
-;
-; Function:	This routine is called by routines which can use RAM, and RAM-less
-;			routines.  It is a central place in the ROM where all sound hardware
-;			initialization should happen.
-;——————————————————————————————————————————————————————————————————————————————
-
-InitSoundHW	MOVEA.L	A1,A3							; get the ProductInfo pointer							<SM82>
-			ADDA.L	SndControlPtr(A3),A3			; point to the sound primitives table					<SM82>
-			ADDA.L	sndInitSoundHW*4(A3),A3			;  and then to the routine to initialize sound hardware	<SM82>
-			JMP		(A3)							; call the routine (will return with RTS6)				<SM82>
-
-
-		IF hasASC THEN
-;——————————————————————————————————————————————————————————————————————————————
-;	ASCSetVol  -  Set the playback volume on normal ASC/Batman hardware
-;
-;	Set the playback volume using the volume control register on Batman.
-;
-;	Input:	d0.b = volume level (0-7)
-;	Output:	none
-;
-
-ASCSetVol	move.l	a0,-(sp)
-			movea.l	ASCBase,a0						; get base address of asc/batman
-			lsl.b	#5,d0							; shift volume up to pwm position
-			move.b	d0,ascVolControl(a0)			; save it in ASC volume register
-			movea.l	(sp)+,a0
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;
-; Routine:	ASCInitSoundHW
-;
-; Inputs:	D0	-	sound volume (0-7)
-;			A0	-	pointer to machine's DecoderInfo table
-;			A1	-	pointer to machine's ProductInfo table
-;			A6	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0,A3
-;
-; Function:	called by BSR6 from StartInit to set the default volume for ASC
-;			based machines
-;——————————————————————————————————————————————————————————————————————————————
-
-ASCInitSoundHW
-			MOVEA.L	ASCAddr(A0),A3					; point to the base of the ASC
-			ASL.B	#5,D0							; shift the sound volume into the upper 3 bits
-			MOVE.B	D0,ascVolControl(A3)			;  and set the volume
-			RTS6
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;
-; Routine:	BatmanInitSoundHW
-;
-; Inputs:	D0	-	sound volume (0-7)
-;			A0	-	pointer to machine's DecoderInfo table
-;			A1	-	pointer to machine's ProductInfo table
-;			A6	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0,A3
-;
-; Function:	called by BSR6 from StartInit to set the default volume for Batman
-;			based machines
-;——————————————————————————————————————————————————————————————————————————————
-
-BatmanInitSoundHW
-			MOVEA.L	ASCAddr(A0),A3					; point to the base of the ASC
-			ASL.B	#5,D0							; shift the sound volume into the upper 3 bits
-			MOVE.B	D0,ascVolControl(A3)			;  and set the volume
-
-			MOVE.W	#$7F00,bmLeftScaleA(A3)			; pan channel A full left
-			MOVE.W	#$007F,bmLeftScaleB(A3)			; pan channel B full right
-
-FinishBatmanInit
-			MOVEQ	#1,D0
-			MOVE.B	D0,bmIntControlA(A3)			; mask sound interrupts on channels A & B
-			MOVE.B	D0,bmIntControlB(A3)
-
-			ORI.B	#$80,ascFifoControl(A3)			; toggle the clear FIFO bit
-			ANDI.B	#$7F,ascFifoControl(A3)
-
-			MOVE.B	#2,ascPlayRecA(A3)				; set to play mode at 22KHz
-			MOVE.B	D0,ascMode(A3)					; set to FIFO mode
-
-			MOVEQ	#0,D0
-			MOVE.B	D0,bmFifoControlA(A3)			; force Batman to do mode-change housekeeping
-			MOVE.B	D0,bmFifoControlB(A3)
-
-			MOVE.W	#$812F,bmSrcTimeIncrA(A3)		; set sample rate to 22.254.5454 kHz on channels A & B
-			MOVE.W	#$812F,bmSrcTimeIncrB(A3)
-
-			MOVE.W	D0,$F10(A3)						; initialize the CD-XA coefficients for channel A
-			MOVE.W	#$003C,$F12(A3)
-			MOVE.W	#$CC73,$F14(A3)
-			MOVE.W	#$C962,$F16(A3)
-			MOVE.W	D0,$F30(A3)						; initialize the CD-XA coefficients for channel B
-			MOVE.W	#$003C,$F32(A3)
-			MOVE.W	#$CC73,$F34(A3)
-			MOVE.W	#$C962,$F36(A3)
-
-			MOVE.B	#$80,bmFifoControlA(A3)			; turn on Sample Rate Conversion (SRC) for channels A & B
-			MOVE.B	#$80,bmFifoControlB(A3)
-			RTS6
-
-		ENDIF										; {hasASC}
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	InputSelect  -  Select the sound input source
-;
-;	If we are selecting "none" for the input source, then turn off the volume
-;	and AGC to prevent any noise leakage.  Save the old volume and restore it
-;	later when a new source is selected.
-;
-;	AGCInputSelect
-;	On Tim and Spike, sound input does not work unless AGC is enabled.  We
-;	kludge something to always set AGC.
-;
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
-;	Output:	d0.b	last source
-;
-
-AGCInputSelect
-			tst.b	d0								; turning on sound input?						<t6>
-			beq.s	InputSelect						; no - go ahead and turn off sound input		<t6>
-			or.b	#sndAGCOn,d0					; this fixes buggy hardware						<t6>
-
-InputSelect
-@saveregs	reg		d1-d2/a0-a1						; added d2 to save registers 					<H23>
-
-			movem.l	@saveregs,-(sp)
-			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-			move.w	sr,-(sp)						;												<t9>
-			ori.w	#HiIntMask,sr					; disable ints									<t9>
-
-			moveq.l	#3,d2							; get selection bits to return					<t9>
-			and.b	DFAClast(a0),d2					; save for return								<t9>
-
-			moveq	#(sndSelectMask\				;												<t6>
-					AND sndPlayThruMask\
-					AND	sndAGCMask),d1				; mask off selection, volume, and AGC bits
-			and.b	DFAClast(a0),d1					;  in the DFAC register image					<t6>
-			or.b	d0,d1							;  and OR them into DFAC image					<t6>
-
-;	Check for volume and AGC to update in DFAC now that a sound source has been selected.
-;	If we are disabling input, then zero the volume and disable AGC to prevent noise
-;	leakage, otherwise set the currently selected volume and AGC levels.
-
-			tst.b	d0								; are we turning off input?
-			beq.s	@send							; yes - set no input and zero volume
-			or.b	UserVolume(a0),d1				; set volume level
-			cmpi.b	#sndMicrophone,d0				; are we selecting the mike input?				<H13>
-			bne.s	@send							; no - do not enable AGC						<H13>
-			or.b	UserAGC(a0),d1					; set AGC level									<t6>
-
-@send
-			move.b	d1,d0							; d0 = new DFAC value
-			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem			<t6>
-
-			move.w	(sp)+,sr						; enable ints									<t9>
-			move.b	d2,d0							; return source bits we replaced				<t9>
-			movem.l	(sp)+,@saveregs
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	QueryInput  -  return current input source selected
-;
-;	Input:	none
-;	Output:	d0.b	input source
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
-
-QueryInput	move.l	a0,-(sp)
-			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-			moveq	#~(sndSelectMask-256),d0		; mask off selection bits						<t6>
-			and.b	DFAClast(a0),d0					;  in the DFAC register image					<t6>
-			movea.l	(sp)+,a0
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————						<t6>
-;	ByPassControl  -  enable or disable aux bypass
-;
-;	Input:	d0.b  =   0 is disable, nonzero is enable
-;	Output:	none
-;
-
-ByPassControl
-@saveregs	reg		d1/a0
-
-			movem.l	@saveregs,-(sp)
-			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-			moveq.l	#sndByPassOff,d1				; assume bypass off
-			tst.b	d0								; enable or disable bypass
-			beq.s	@continue						; was bypass off
-			moveq.l	#sndByPassOn,d1					; set bypass on
-@continue	move.w	sr,-(sp)						;												<t9>
-			ori.w	#HiIntMask,sr					; disable ints									<t9>
-			moveq	#sndByPassMask-256,d0			; mask off bypass control bit
-			and.b	DFAClast(a0),d0					;  in the DFAC register image
-			or.b	d1,d0							; d0 = value to send DFAC
-			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem
-			move.w	(sp)+,sr						; enable ints									<t9>
-			movem.l	(sp)+,@saveregs
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————						<t6>
-;	PlayThruVol  -  Set the playthrough volume
-;
-;	If a sound source has not been selected, then save the volume in the globals
-;	to be updated to DFAC later when the source is selected.  Also set playback
-;	volume for consistancy.
-;
-;	Input:	d0.b = volume level (0-7)
-;	Output:	none
-;
-
-PlayThruVol
-@saveregs	reg		d1/a0
-
-			movem.l	@saveregs,-(sp)
-			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-			move.w	sr,-(sp)						;												<t9>
-			ori.w	#HiIntMask,sr					; disable ints									<t9>
-
-			asl.b	#5,d0							; shift volume into s5-s7 position
-			move.b	d0,UserVolume(a0)				; save user set volume level
-			moveq	#(sndSelectMask-256),d1			; mask off selection bits
-			and.b	DFAClast(a0),d1					;  in the DFAC register image
-			beq.s	@Done							; no sound source - we are done
-
-			moveq	#sndPlayThruMask,d1				; mask off volume bits
-			and.b	DFAClast(a0),d1					;  in the DFAC register image
-			or.b	d1,d0							; or-in value to send DFAC to set volume
-			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem
-@Done
-			move.w	(sp)+,sr						; enable ints									<t9>
-			movem.l	(sp)+,@saveregs
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————						<t6>
-;	AGCControl  -  enable or disable AGC
-;
-;	Enable or disable AGC.  If no sound source has been selected, then
-;	save the AGC value and set it whenever the sound source is selected.
-;
-;	Input:	d0.b  =   0 is disable, nonzero is enable
-;	Output:	none
-;
-
-AGCControl
-@saveregs	reg		d1/a0
-
-			movem.l	@saveregs,-(sp)
-			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-			moveq.l	#sndAGCOff,d1					; assume AGC off (min gain)						<t11>
-			tst.b	d0								; enable or disable AGC
-			beq.s	@continue						; was disable AGC
-			moveq.l	#sndAGCOn,d1					; enable AGC
-@continue
-			move.w	sr,-(sp)						;												<t9>
-			ori.w	#HiIntMask,sr					; disable ints									<t9>
-			move.b	d1,UserAGC(a0)					; save value
-
-			moveq	#(sndSelectMask-256),d0			; mask off selection bits
-			and.b	DFAClast(a0),d0					;  in the DFAC register image
-			beq.s	@Done							; no sound source - we are done
-
-			moveq	#sndAGCMask-256,d0				; mask off the AGC control bits
-			and.b	DFAClast(a0),d0					;  in the DFAC register image
-			or.b	d1,d0							; or-in AGC value to send to DFAC
-			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem
-@Done
-			move.w	(sp)+,sr						; enable ints									<t9>
-			movem.l	(sp)+,@saveregs
-			rts
-
-
-
-		IF hasVISADecoder THEN
-;••••••••••••••••••••••••••••••••••••••••• VISA •••••••••••••••••••••••••••••••••••••••••
-
-;——————————————————————————————————————————————————————————————————————————————
-;	ElsieInputSelect  -  Select the sound input source on Elsie
-;
-;	If we are turning off the source (equivalent to disabling recording), then
-;	re-establish the playback mode by selecting the Aux source with AGC on and
-;	playthrough volume set to the maximum.
-;
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
-;	Output:	none
-;
-
-; NOTE: System software has a different version of this being patched in ?!?!?
-
-ElsieInputSelect
-			cmpi.b	#sndMicrophone,d0				; are we selecting the mike?
-			beq		InputSelect						; yes - continue
-
-;	In Elsie sound, the playthrough with the auxiliary source is how playback is
-;	done.  If not selecting mike, then enable playback
-
-@saveregs	reg		d1/a0
-			movem.l	@saveregs,-(sp)
-;			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-;			moveq	#(sndSelectMask\				;												<t6>
-;					AND sndPlayThruMask\
-;					AND	sndAGCMask),d0				; mask off selection, volume, and AGC bits
-;			and.b	DFAClast(a0),d0					; get DFAC register image
-			moveq	#sndElsieDFAC-256,d0			; DFAC playback mode for Elsie sound			<t6>
-			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem			<t6>
-			movem.l	(sp)+,@saveregs
-			rts
-
-		ENDIF										; {hasVISADecoder}
-
-
-
-		IF hasEgret THEN
-;••••••••••••••••••••••••••••••••••••••••• Egret ••••••••••••••••••••••••••••••••••••••••
-			WITH	EgretPB
-
-			Import	SendEgretCmd
-
-;——————————————————————————————————————————————————————————————————————————————
-;	EgretDFACInit  -  send a byte to DFAC using Egret
-;
-;	Use this routine during initialization before traps are enabled.
-;
-;	Input:		a6.l = return address
-;				a0.l = Pointer to Base address table
-;
-;	Output:		none
-;	Destroys:	d0-d2/a2-a3
-;	Called by:	bsr6
-;
-
-		IF hasSonora THEN
-SonoraDFACInit
-			moveq	#sndSonoraReverseDFAC,d0		; DFAC data to send for Elsie					<SM5>
-			bra.s	EgretDFACInit
-		ENDIF
-		  IF hasOrwell THEN
-EclipseDFACInit
-			moveq	#sndEclipseDFAC,d1				; DFAC data to send for Eclipse					<t6>
-			bra.s	EgretDFACInit
-		ENDIF
-		IF hasVISADecoder THEN
-ElsieDFACInit
-			move.l	#ElsieDFAC,d1					; DFAC data to send for Elsie					<SM7>
-****		bra.s	EgretDFACInit
-		ENDIF
-
-EgretDFACInit
-			movea.l	a6,a3							; save return address
-			move.l	#(WrDFAC<<16) | PseudoPkt,d0	; Send DFAC command
-			moveq	#DFACInitLen,d2					; number of bytes of DFAC data
-			bigbsr6	SendEgretCmd,a2					; send the command to Egret
-			tst.w	d0								; negative if error
-			jmp		(a3)							; return to the caller
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	EgretDFACSend  -  send a byte to DFAC using Egret
-;
-;	Use this routine during runtime after traps are enabled.
-;
-;	Input:	d0.b = byte to send DFAC (in DFAC order)
-;	Output:	none
-;
-
-EgretDFACSend
-@saveregs	reg		d1-d3/a0-a1
-
-			movem.l	@saveregs,-(sp)					; work register
-
-;	Reverse the order of the bits because Egret shifts them out in reverse order
-;	to what DFAC is expecting MSB first.
-
-			move.l	d0,d3							; save DFAC value in DFAC order
-			moveq	#0,d1							; destination
-			moveq	#8-1,d2							; loop count for 8 bits
-@Loop
-			asr.b	#1,d0							; shift lsb into extend bit
-			roxl.b	#1,d1							; shift extend bit towards msb
-			dbra	d2,@Loop
-
-;	Build a Parameter block for the default DFAC message
-
-			suba.w	#EgretPbSize,sp					; make room for PB
-			movea.l	sp,a0							; point a0 to pbBuffer
-			move.b	#pseudoPkt,pbCmdType(a0)
-			move.b	#WrDFAC,pbCmd(a0)
-			move.w	#1,pbByteCnt(a0)				; set byte count
-			clr.l	pbBufPtr(a0)					; clear unused fields
-			clr.w	pbFlags(a0)
-			clr.w	pbResult(a0)
-			clr.l	pbCompletion(a0)
-			move.b	d1,pbParam(a0)					; set byte to send DFAC
-
-			_EgretDispatch
-			adda.w	#EgretPbSize,sp					; discard the parameter block and data buffer
-			bne.s	@Done							; some error - do not update image of DFAC
-
-;	Update the RAM image of the DFAC register
-
-			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-			move.b	d3,DFAClast(a0)					; update DFAC register image
-
-@Done
-			movem.l	(sp)+,@saveregs
-			rts										; Return to Caller
-
-
-			ENDWITH									; {EgretPB}
-		ENDIF										; {hasEgret}
-
-
-
-		IF hasOrwell THEN
-;••••••••••••••••••••••••••••••••••••••••• Orwell •••••••••••••••••••••••••••••••••••••••
-
-;——————————————————————————————————————————————————————————————————————————————						<t6>
-;	EclipseInputSelect  -  Select the sound input source on Eclipse
-;
-;	On Eclipse, the sound input source is selected by two bits on VIA2 port B
-;	register in addition to DFAC.  There are four sound input sources on
-;	Eclipse: Microphone (or none?), RCA jacks, Microphone, and the CD (aux).
-;	These sources are selected through the VIA2 bits and routed through DFAC.
-;
-;	If we are selecting "none" for the input source, then turn off the volume
-;	and AGC to prevent any noise leakage.  Save the old volume and restore it
-;	later when a new source is selected.
-;
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
-;						3  =  RCA jacks
-;	Output:	none
-;
-
-EclipseInputSelect
-
-			move.w	sr,-(sp)						;												<t12> djw
-			ori.w	#HiIntMask,sr					;												<t12> djw
-			movem.l	d0-d1,-(sp)						;												<t12> djw
-			move.b	([via2],vBufB),d1				; read current via values						<t12> djw
-			and.b	#%10110111,d1					; clear the previous value (bits pb6,pb3)		<t12> djw
-			andi.w	#$ff,d0							; make a word index
-			or.b	EclipseSelectTable(pc,d0.w),d1	; set new input									<t12> djw
-			move.b	d1,([via2],vBufB)				; set via2 bits
-			bsr.s	ReGenSoundInt					; since VIA2 access clear interrupts, fix em	<Z16> BG
-			movem.l	(sp)+,d0-d1						;												<t12> djw
-			move.w	(sp)+,sr						;												<t12> djw
-
-			tst.b	d0								; selecting no source?
-			beq		InputSelect						; yes - ok to go setup DFAC						<t14> djw
-			moveq.l	#sndMicrophone,d0				; all sound sources go through DFAC mike input
-			bra		InputSelect						;												<t14> djw
-
-EclipseSelectTable
-			dc.b	%00000000						; none (or microphone?)	pb6=0, pb3=0
-			dc.b	%01000000						; microphone			pb6=1, pb3=0
-			dc.b	%01001000						; auxilary (CD)			pb6=1, pb3=1
-			dc.b	%00001000						; RCA jacks				pb6=0, pb3=1
-
-
-;_______________________________________________________________________							<Z16> thru next <Z16>									<Z18> thru next <Z18>
-;
-;  Routine:		ReGenSoundInt
-;
-;  Desc:		Since reading VIAx[vBufB] causes interrupts to cleared,
-;				this re-generates those sound interrupts.
-;
-;				This routine stolen from
-;
-;					{Regatta}Toolbox:SoundMgr:SoundMgrPatch.a
-;
-;_______________________________________________________________________
-
-interruptControlA	EQU	$F09						; interrupt mask registers for Batman
-interruptControlB	EQU	$F29
-
-ReGenSoundInt
-			move.l	a1,-(sp)						; save A1 so we can play with it
-			movea.l	VIA2,a1							; grab the address of VIA2
-			cmpa.l	#-1,a1							; check if it's been set up yet
-			beq.s	@rts							; exit if not
-			btst.b	#ifCB1,vIFR(a1)					; check if we still think there's an interrupt
-			bne.s	@rts							; yes, we still have an interrupt - exit
-
-			movea.l	ASCBase,a1						; point to Batman
-			cmpa.l	#-1,a1							; check if it's been set up yet
-			beq.s	@rts							; exit if not
-
-			move.w	sr,-(sp)						; preserve the status register
-			ori.w	#$0700,sr						; mask interrupts
-
-			tst.b	interruptControlA(a1)			; channel A interrupt enabled?
-			bne.s	@checkB							; BRIF not enabled
-			move.b	#1,interruptControlA(a1)		; disable chnl A interrupts
-			nop										; give Batman time to process the disable
-			clr.b	interruptControlA(a1)			; clear the interrupt mask to re-generate
-@checkB
-			tst.b	interruptControlB(a1)			; channel B interrupt enabled?
-			bne.s	@Done							; interrupt not enabled - done
-
-;	To re-generate Batman interrupts, first disable interrupts on both channels,
-;	then re-enable them.
-
-@reGen
-			move.b	#1,interruptControlB(a1)		; disable chnl B interrupts
-			nop										; give Batman time to process the disable
-			clr.b	interruptControlB(a1)			; clear the interrupt mask to re-generate
-@Done		move.w	(sp)+,sr
-@rts		move.l	(sp)+,a1						; restore original value of A1
-			rts										;												<Z16>
-
-		ENDIF										; {hasOrwell}
-
-
-
-		IF hasJaws THEN
-;••••••••••••••••••••••••••••••••••••••••• Jaws •••••••••••••••••••••••••••••••••••••••••
-
-;——————————————————————————————————————————————————————————————————————————————				<r8> thru next <r8> djw
-;	TIMInputSelect  -  Select the sound input source on Tim
-;
-;	On Tim, the input selection routine in ROM always turns AGC on.  Patch
-;	it out to not force AGC on.
-;
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim)
-;	Output:	d0.b	last source
-;
-
-AutoSlpDisable	equ		$f8						; Counting semaphor to disable sleep
-
-TIMInputSelect
-@workingReg	reg		d2/a0-a1
-			move.w	sr,-(sp)					; save the old sr
-			movem.l	@workingReg,-(sp)			; save working registers
-
-			move.l	PmgrBase,a1					; point a1 to globals
-			movea.l	([Expandmem],emSndPrimitives),a0	; a0 = ptr to vector table
-			ori.w	#HiIntMask,sr				; disable ints
-
-			moveq.l	#3,d2						; get selection bits
-			and.b	DFAClast(a0),d2				;
-			beq.s	@currentlyOff				; is a source active ??
-
-@currentlySelected								; sound source currently selected
-			tst.b	d0							; check new state,
-			bne.s	@setsource					; if just new source, set the source
-			subq.b	#1,AutoSlpDisable(a1)		; ... if turning off source, dec the nosleep semaphore
-			bra.s	@setsource
-
-@currentlyOff									; sound source currently off
-			tst.b	d0							; check new state,
-			beq.s	@setsource					; if new source still off, set the source
-			addq.b	#1,AutoSlpDisable(a1)		; ... if turning on source, inc the nosleep semaphore
-;			bra.s	@setsource
-
-@setsource
-			movem.l	(sp)+,@workingReg			; restore working registers
-			bsr		InputSelect					; change the source					<r10> djw
-			move.w	(sp)+,sr					; enable ints
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	TimPlayBackVol  -  Set the playback volume on Tim
-;
-;	Tim uses the left and right scale registers to control the volume.  Volume
-;	levels 0-7 are table mapped.  Also should also set playthrough volume for
-;	consistancy.
-;
-;	Input:	d0.b = volume level (0-7)
-;	Output:	none
-;
-
-TimPlayBackVol
-			move.l	a0,-(sp)
-
-			andi.w	#$ff,d0							; mask to word index							<t6>
-			move.b	@TimVolumeTable(d0.W),d0		; index into tbl to get mapped volume value		<t6>
-
-			move.w	sr,-(sp)						;												<t9>
-			ori.w	#HiIntMask,sr					; disable ints									<t9>
-			movea.l	ASCBase,a0						; get base address of asc/batman
-			move.b	d0,bmLeftScaleA(a0)				; channel A plays out left speaker at this volume
-			move.b	#0,bmRightScaleA(a0)			; channel A does not play out of the right speaker at all
-			move.b	#0,bmLeftScaleB(a0)				; channel B does not play out of the left speaker at all
-			move.b	d0,bmRightScaleB(a0)			; channel B plays out right speaker at this volume
-			move.w	(sp)+,sr						; enable ints									<t9>
-
-			movea.l	(sp)+,a0
-			rts
-
-; Table of values to jam into the Batman scale registers for each sound volume setting (0..7)
-
-@TimVolumeTable
-			dc.b	1, 18, 36, 54, 72, 90, 108, 127
-			align	4
-
-		ENDIF										; {hasJaws}
-
-
-
-		IF hasNiagra THEN
-;••••••••••••••••••••••••••••••••••••••••• Niagra •••••••••••••••••••••••••••••••••••••••
-
-;——————————————————————————————————————————————————————————————————————————————
-;	DartQueryInput  -  return current input source selected
-;
-;	Input:	none
-;	Output:	d0.b	input source
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Dart)
-DartQueryInput
-			bsr.s	QueryInput						;
-			tst.b	d0								;
-			beq.s	@done							; if off, done
-
-			move.l	a0,-(sp)						; save a0
-			movea.l	UnivInfoPtr,a0					; point to the ProductInfo table,
-			adda.l	DecoderInfoPtr(a0),a0			;  then to the DecoderInfo table,
-			movea.l	JAWSAddr(a0),a0					;   then to the Niagra base address,
-			adda.l	#(NiagraGUR+PontiSndCtl),a0		; point sound control register
-
-			move.b	#sndSelectAux,d0				; assume modem sound
-			btst.b	#PontiSndMux1,(a0)				; check for modem sound override
-			bne.s	@returninput					; if override bit, return current d0 value
-			move.b	#sndSelectMike,d0				; set to mike
-
-@returninput
-			move.l	(sp)+,a0						; restore a0									  |
-													;												  V
-@done		rts										;												<H19>
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	DartPlayThruVol  -  Set the playthrough volume
-;
-;	If a sound source has not been selected, then save the volume in the globals
-;	to be updated to DFAC later when the source is selected.  Also set playback
-;	volume for consistancy.  In Dart's case, playthru is disabled (set to 0) if
-;	the internal microphone is used.  This prevents HORRible feedback.
-;
-;
-;
-;	Input:	d0.b = volume level (0-7)
-;	Output:	none
-;
-DartPlayThruVol
-@saveregs	reg		d1/a0
-
-; get the current source
-			movem.l	@saveregs,-(sp)					; save working set of registers
-			move 	d0,d1							; use d1 for volume until later
-
-			bsr.s	DartQueryInput					; get the current source
-			cmp.b	#sndSelectMike,d0				; is the mike selected,
-			bne.s	@setvol							; if not mike, just set the volume
-
-; get pointer to sound control register
-			movea.l	UnivInfoPtr,a0					; point to the ProductInfo table,
-			adda.l	DecoderInfoPtr(a0),a0			;  then to the DecoderInfo table,
-			movea.l	JAWSAddr(a0),a0					;   then to the Niagra base address,
-			adda.l	#(NiagraGUR+PontiSndCtl),a0		; point sound control register
-
-; check for internal mike
-			btst.b	#PontiSndIntMic,(a0)			; check for internal microphone operation
-			beq.s	@setvol							; if external microphone, allow playthru
-			move.b	#0,d1							; ... else set playthru to off
-
-@setvol		move.b	d1,d0							; move volume back to d0
-			movem.l	(sp)+,@saveregs					; restore working set
-			bra		PlayThruVol						; set playthru volume
-
-
-;——————————————————————————————————————————————————————————————————————————————						<t6>
-;	DartInputSelect  -  <H13> Select the sound input source on Dartanian
-;
-;	If we are selecting "none" for the input source, then turn off the volume
-;	and AGC to prevent any noise leakage.  Save the old volume and restore it
-;	later when a new source is selected.  If a source has been selected, then
-;	disable auto sleep otherwise enable auto sleep
-;
-;	On Dart however, there is an additional sound mux in front of DFAC.  For sound
-;	input selection, we will use this hardware instead of that in DFAC.  All sound input
-;	will feed through DFAC's mike input port.
-;
-;	On Dart ,as on TIM, sound input does not work unless AGC is enabled.  We
-;	kludge something to always set AGC.
-;
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim)
-;	Output:	d0.b	last source
-;
-
-DartInputSelect
-@workingreg	reg		d1/a0
-			move.w	sr,-(sp)						; save the old sr
-			movem.l	@workingreg,-(sp)				; save working register
-
-; get pointer to sound control register
-			movea.l	UnivInfoPtr,a0					; point to the ProductInfo table,
-			adda.l	DecoderInfoPtr(a0),a0			;  then to the DecoderInfo table,
-			movea.l	JAWSAddr(a0),a0					;   then to the Niagra base address,
-			adda.l	#(NiagraGUR+PontiSndCtl),a0		; point sound control register
-
-			bclr.b	#PontiSndMux0,(a0)				; default to auto mike selection
-			ori.w	#HiIntMask,sr					; disable ints
-
-; determine is we should use the modem override
-			cmp.b	#sndSelectAux,d0				; is the new input the modem channel
-			bne.s	@modemOFF
-@modemON											; don't preset, might cause "pop"
-			bset.b	#PontiSndMux1,(a0)				; set modem sound override
-			bra.s	@exitsndmux
-
-@modemOFF
-			bclr.b	#PontiSndMux1,(a0)				; clr modem sound override
-
-@exitsndmux
-			move.l	d0,d1							; save the source information
-			bsr.s	HandleAutoSleep					; handle autosleep semaphore
-
-; disable Playthru if using internal mike
-			tst.b	d0								; test the new input source						<H19>
-			cmp.b	#sndSelectMike,d0				; if it the mic ?								<H19>
-			blt.s	@setsource						; (case 0) no sources							<H19>
-			bgt.s	@modemsource					; (case 2) modem sound source					<H19>
-													;												<H19>
-			btst.b	#PontiSndIntMic,(a0)			; check for internal microphone operation		<H19>
-			beq.s	@modemsource					; if external microphone, allow playthru		<H19>
-													;												<H19>
-			move.b	#0,d0							; set playthru to off							<H19>
-			bsr.s	PlayThruVol						; 												<H19>
-
-@modemsource
-			moveq	#sndSelectMike,d0				; on dart all inputs through mike port on DFAC
-
-@setsource
-			bsr.s	AGCInputSelect					; change the source
-			move.l	d1,d0							; restore the source information
-
-			movem.l	(sp)+,@workingreg				; restore register
-			move.w	(sp)+,sr						; enable ints
-			rts
-
-		ENDIF										; {hasNiagra}
-
-
-		IF hasJaws | hasNiagra THEN
-;——————————————————————————————————————————————————————————————————————————————
-;
-; Routine:	JawsInitSoundHW,NiagraInitSoundHW
-;
-; Inputs:	D0	-	sound volume (0-7)
-;			A0	-	pointer to machine's DecoderInfo table
-;			A1	-	pointer to machine's ProductInfo table
-;			A6	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0,D1,A3
-;
-; Function:	Called by BSR6 from StartInit to set the default volume for Jaws
-;			and Niagra based machines.  Their Batman implementation is different
-;			from "standard" Batman since they do volume control using the scale
-;			registers.
-;——————————————————————————————————————————————————————————————————————————————
-
-JawsInitSoundHW
-NiagraInitSoundHW
-			MOVEQ	#18,D1							; map volume to scale value
-			MULU	D0,D1
-
-			MOVEA.L	ASCAddr(A0),A3					; point to the base of the ASC
-			ASL.B	#5,D0							; shift the sound volume into the upper 3 bits
-			MOVE.B	D0,ascVolControl(A3)			;  and set the volume
-
-			MOVE.B	D1,bmLeftScaleA(A3)				; channel A plays out left speaker at this volume
-			MOVE.B	#0,bmRightScaleA(A3)			; channel A does not play out of the right speaker at all
-			MOVE.B	#0,bmLeftScaleB(A3)				; channel B does not play out of the left speaker at all
-			MOVE.B	D1,bmRightScaleB(A3)			; channel B plays out right speaker at this volume
-
-			BRA		FinishBatmanInit				; finish up with normal initialization
-
-		ENDIF
-
-
-
-		IF hasPwrControls THEN
-;••••••••••••••••••••••••••••••••••••• Power Manager ••••••••••••••••••••••••••••••••••••
-
-;——————————————————————————————————————————————————————————————————————————————						<t6>
-;	HandleAutoSleep  -  handle the auto sleep semaphore
-;
-;	this code handles the autosleep semaphore.  when an input source is selected,
-;	we increment the semaphore to disable auto sleep.  care must be taken to not
-;	increment the semaphone when changing between microphone and aux, this does
-;	not change the semaphore state.
-;
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim)
-;
-;			a0		pointer to primitives table and globals
-;
-;	Output:	d0.b	last source
-;
-HandleAutoSleep
-@workingreg	reg		d2/a0-a1
-			movem.l	@workingreg,-(sp)				; save working registers
-
-			move.l	PmgrBase,a1						; point a1 to globals
-			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-			moveq.l	#3,d2							; get selection bits
-			and.b	DFAClast(a0),d2					;
-			beq.s	@currentlyOff					; is a source active ??
-
-@currentlySelected									; sound source currently selected
-			tst.b	d0								; check new state,
-			bne.s	@exit							; if just new source, set the source
-			subq.b	#1,AutoSlpDisable(a1)			; ... if turning off source, dec the nosleep semaphore
-			bra.s	@exit
-
-@currentlyOff										; sound source currently off
-			tst.b	d0								; check new state,
-			beq.s	@exit							; if new source still off, set the source
-			addq.b	#1,AutoSlpDisable(a1)			; ... if turning on source, inc the nosleep semaphore
-
-@exit
-			movem.l	(sp)+,@workingreg				; restore working registers
-			rts
-
-		ENDIF										; {hasPwrControls}
-
-
-
-		IF hasMSC THEN
-;•••••••••••••••••••••••••••••••••••••••••• MSC •••••••••••••••••••••••••••••••••••••••••
-
-;——————————————————————————————————————————————————————————————————————————————						<t6>
-;	DBLiteDFACInit  -  send a byte to DFAC using the PMGR micro
-;
-;	Use this routine during initialization before traps are enabled.
-;
-;	Input:		D0.B = byte to have the PMGR stuff into DFAC
-;				A0.L = ptr to DecoderInfo record
-;				A6.L = return address
-;	Output:		none
-;	Destroys:	D3-D4/D6/A2-A4/A5
-;	Called by:	BSR6
-;
-
-			IMPORT	USTPMGRSendByte
-
-DBLiteDFACInit
-			MOVEQ	#sndDBLiteDFAC-256,D0			;												<t8>
-			MOVEA.L	DecoderInfo.VIA1Addr(A0),A2		; point to the base of VIA 1
-			MOVEA.L	DecoderInfo.VIA2Addr(A0),A3		; point to the base of VIA 2
-
-			MOVEQ	#SetDFAC-256,D3					; send the command								<H3>
-			BIGBSR5	USTPMGRSendByte,A4
-
-			MOVE.B	D0,D3							; send the DFAC initialization value
-			BIGBSR5	USTPMGRSendByte,A4
-
-			MOVEQ	#sndInputOff,D3					; send the input source (none)					<H11>
-			BIGBSR5	USTPMGRSendByte,A4				;												<H11>
-			RTS6
-
-
-;——————————————————————————————————————————————————————————————————————————————						<t6>
-;	DBLiteDFACSend  -  send a byte to DFAC using the PMGR micro
-;
-;	Use this routine during runtime after traps are enabled.
-;
-;	Input:	d0.b = byte to send DFAC (in DFAC order)
-;	Output:	none
-;
-
-DBLiteDFACSend
-@saveRegs	REG		D1/A0
-
-			MOVEM.L	@saveRegs,-(SP)
-			MOVEA.L	([Expandmem],emSndPrimitives),A0; get the pointer to the vector table			<H11>
-			MOVE.B	D0,DFAClast(A0)					;  and update the DFAC register image			<H11>
-
-			MOVEQ	#3,D1							; mask off the input source						<H11>
-			AND.B	D0,D1							;												<H11>
-			CMPI.B	#sndSelectAux,d1				; is the aux modem sound selected?				<H18>
-			BNE.S	@nonAux							; no, use standard DFAC byte from table			<H18>
-
-			MOVE.B	@dfacTable(d1),d1				; yes, get modem dfac byte						<H18>
-			MOVEA.L	ASCBase,a0						; get base address of asc/batman				<H18>
-			MOVE.B	ascVolControl(a0),d0			; get current ASC volume,						<H18>
-			ANDI.B	#$E0,d0							; use as DFAC attenuation						<H18>
-			OR.B	d1,d0							; bits for modem volume							<H18>
-			MOVEQ	#sndSelectAux,d1				;												<H18>
-			BRA.S	@dfac							; and set DFAC									<H18>
-
-@nonAux		MOVE.B	@dfacTable(D1),D0				; get the appropriate DFAC command byte			<H11>
-@dfac		LSL.W	#8,D0							; move the DFAC command							<H11>
-			OR.B	D1,D0							;  include the desired input selection			<H11>
-			MOVE.W	D0,-(SP)						; put the bytes to send in a buffer on the stack<H11>
-			MOVE.L	SP,-(SP)						;  pmRBuffer points to it to be safe
-			MOVE.L	(SP),-(SP)						;  pmSBuffer points to it
-			MOVE.W	#2,-(SP)						;  pmLength										<H11>
-			MOVE.W	#SetDFAC,-(SP)					;  pmCommand
-			MOVEA.L	SP,A0							; point to the parameter block					<H6>
-			_PMgrOp									; have the PMGR stuff the byte in DFAC
-			LEA		pmData+2(SP),SP					; toss the parameter block and buffer
-			MOVEM.L	(SP)+,@saveRegs
-			RTS
-
-@dfacTable	DC.B	(7<<5)|sndByPassOff|sndTCAOff|sndSelectAux	; 0 = no input source (i.e., play)
-			DC.B	(0<<5)|sndByPassOff|sndAGCOn|sndSelectMike	; 1 = microphone
-			DC.B	(0<<5)|sndByPassOff|sndAGCOn|sndSelectMike	; 2 = modem sound					<H18>
-			DC.B	(7<<5)|sndByPassOff|sndAGCOn|sndSelectMike	; 3 = undefined (set for modem sound)
-
-
-;——————————————————————————————————————————————————————————————————————————————						<H2>
-;	DBInputSelect  -  Select the sound input source on DB-Lite
-;
-;	If we are selecting "none" for the input source, then turn off the volume
-;	and AGC to prevent any noise leakage.  Save the old volume and restore it
-;	later when a new source is selected.  If a source has been selected, then
-;	disable auto sleep otherwise enable auto sleep
-;
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on DB-Lite)
-;	Output:	d0.b	last source
-;
-DBInputSelect
-			MOVE.W	SR,-(SP)						; save the old sr
-			ori.w	#HiIntMask,sr					; disable ints									<H20>
-			BSR.S	HandleAutoSleep					; turn auto-sleep on/off if necessary			<H20>
-			CMPI.B	#sndAuxiliary,D0				; is it modem sound (aux)?						<H18>
-			BNE.S	@std							; no, continue									<H18>
-
-			move.l	a0,-(sp)						; save a0										<H18>
-			move.l	VIA2,a0							; point to the MSC's sound control register		<H18>
-			lea		MSCSndCntl(a0),a0				;												<H18>
-			bset	#MSCSndPower,(a0)				; turn on sound power							<H18>
-			move.l	(sp)+,a0						; restore a0									<H18>
-
-@std		bsr.s	InputSelect						; select it as the source
-			MOVE.W	(SP)+,SR						; enable ints
-			RTS										;
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	DBLiteSetVol  -  Set the playback volume on DBLite's ASC/Batman hardware
-;					 If the modem is selected as the sound source, then set DFAC
-;					 as well.
-;
-;	Input:	d0.b = volume level (0-7)
-;	Output:	none
-;——————————————————————————————————————————————————————————————————————————————
-
-DBLiteSetVol										;												<H18>
-			move.l	a0,-(sp)
-			move.w	sr,-(sp)						; save sr
-			ori.w	#HiIntMask,sr					; disable ints
-
-			movea.l	ASCBase,a0						; get base address of asc/batman
-			lsl.b	#5,d0							; shift volume up to pwm position
-			move.b	d0,ascVolControl(a0)			; save it in ASC volume register
-
-			move.l	PMgrBase,a0						; Modem sound volume is controlled through DFAC
-			tst.b	SysTaskFlag(a0)					; are the sound input primitives set up?
-			beq.s	@exit							; -> no, don't worry about modem yet
-
-			movea.l	([Expandmem],emSndPrimitives),a0		; a0 = ptr to vector table
-			moveq.l	#3,d0							; get selection bits
-			and.b	DFAClast(a0),d0					;
-			cmpi.b	#sndSelectAux,d0				; is the aux modem sound selected?
-			bne.s	@exit							; no, set the ASC volume
-			jsrTBL	sndDFACSend						; call DFACSend to adjust modem sound
-
-@exit		move.w	(sp)+,sr						; restore ints
-			movea.l	(sp)+,a0
-			rts
-
-		ENDIF										; {hasMSC}
-
-
-
-;•••••••••••••••••••••••••••••••••••• VIA2 DFAC stuff •••••••••••••••••••••••••••••••••••
-
-;——————————————————————————————————————————————————————————————————————————————
-;	VIA2DFACInit  -  send a byte to DFAC using via2
-;
-;	Use this routine during initialization before traps are enabled.
-;
-;	Input:		a0.l = ptr to DecoderInfo record
-;				a6.l = return address
-;	Output:		none
-;	Destroys:	d0-d1/a3
-;	Called by:	bsr6
-;
-		IF hasNiagra THEN
-DartDFACInit
-			movea.l	JAWSAddr(a0),a3					; point to the Niagra base address,				<H14>
-			adda.l	#(NiagraGUR+PontiSndCtl),a3		;  then to the sound control register			<H14>
-
-			bclr.b	#PontiSndMux0,(a3)				; default to auto mike selection				<H14>
-			bclr.b	#PontiSndMux1,(a3)				; disable modem override						<H14>
-****		bra.s	TimDFACInit						; fall through to TimDFACInit					<H13>
-		ENDIF
-		IF hasJaws | hasNiagra THEN
-TimDFACInit
-			moveq	#sndTimDFAC,d0					; DFAC data to send for Tim						<t6>
-			bra.s	VIA2DFACInit
-		ENDIF
-		IF hasOrwell THEN
-SpikeDFACInit
-			moveq	#sndSpikeDFAC,d0				; DFAC data to send for Spike					<t6>
-****		bra.s	VIA2DFACInit					; fall through to VIA2DFACInit
-		ENDIF
-
-		IF hasOrwell | hasJaws | hasNiagra THEN
-VIA2DFACInit
-			movea.l	VIA2Addr(a0),a3					; a3 = base addr of via2
-
-			bset.b	#0,vBufB(a3)					; disable data (to aviod nasty accidental data clocking)
-			bset.b	#4,vBufB(a3)					; set clock to high
-			bclr.b	#0,vBufB(a3)					; enable data
-
-			moveq.l	#8-1,d1							; adjust for dbra
-@Loop
-			asr.b	#1,d0							; shift data byte through carry
-			bcc.s	@zeroBit
-			bset.b	#3,vBufB(a3)					; write a one
-			bra.s	@clock
-@zeroBit	bclr.b	#3,vBufB(a3)					; write a zero
-@clock		bclr.b	#4,vBufB(a3)					; toggle clock
-			bset.b	#4,vBufB(a3)					; toggle clock
-			dbra	d1,@Loop						; do all 8 data bytes
-
-			bset.b	#0,vBufB(a3)					; disable data
-
-			rts6
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	VIA2DFACSend  -  send a byte to DFAC using via2
-;
-;	Use this routine during runtime after traps are enabled.  There are three
-;	bits in VIA2 used to communicate to DFAC:
-;							bit 0 = latch enable
-;								3 = data
-;								4 = data clock
-;
-;	To send data, enable data latch and clock each bit out separately.
-;
-;	Input:	d0.b = byte to send DFAC (in DFAC order)
-;	Output:	none
-;
-
-VIA2DFACSend
-@saveregs	reg		d1-d2/a0
-
-			movem.l	@saveregs,-(sp)
-			move.w	sr,-(sp)						;												<t9>
-			ori.w	#HiIntMask,sr					; disable ints									<t9>
-
-;	Update the RAM image of the DFAC register
-
-			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-			move.b	d0,DFAClast(a0)					; update DFAC register image
-
-;	Clock the data byte out through VIA2.  Data is shifted out
-;	in DFAC order (LSB first).
-
-			movea.l	VIA2,a0							; get via2 base addr
-			bset.b	#0,vBufB(a0)					; disable data (to aviod nasty accidental data clocking)
-			bset.b	#4,vBufB(a0)					; set clock to high
-			bclr.b	#0,vBufB(a0)					; drop bit to enable data
-
-			moveq.l	#8-1,d1							; adjust for dbra
-@Loop
-			asr.b	#1,d0							; shift data byte through carry
-			bcc.s	@zeroBit
-			bset.b	#3,vBufB(a0)					; write a one
-			bra.s	@clock
-@zeroBit	bclr.b	#3,vBufB(a0)					; write a zero
-@clock		bclr.b	#4,vBufB(a0)					; toggle clock
-			bset.b	#4,vBufB(a0)					; toggle clock
-			dbra	d1,@Loop						; do all 8 data bytes
-
-			bset.b	#0,vBufB(a0)					; disable data
-
-			move.w	(sp)+,sr						; enable ints									<t9>
-			movem.l	(sp)+,@saveregs
-			rts
-		ENDIF										; {hasOrwell | hasJaws | hasNiagra}
-
-
-
-		IF hasSonora THEN
-;•••••••••••••••••••••••••••••••••••••••• Sonora ••••••••••••••••••••••••••••••••••••••••
-
-;——————————————————————————————————————————————————————————————————————————————
-;	SonoraInputSelect  -  Select the sound input source on Sonora-based Macs
-;
-;	If we are turning off the source (equivalent to disabling recording), then
-;	re-establish the playback mode.
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
-;	Output:	none
-;
-SonoraInputSelect
-			cmpi.b	#sndMicrophone,d0				; are we selecting the mike?
-			beq		InputSelect						; yes - continue
-
-;	Since we're not selecting mike, then enable playback
-
-@saveregs	reg		d1/a0
-			movem.l	@saveregs,-(sp)
-			moveq	#sndSonoraDFAC-256,d0			; DFAC playback mode for Sonora sound
-			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem
-			movem.l	(sp)+,@saveregs
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	VailInputSelect  -  Select the sound input source on Vail
-;
-;	If we are turning off the source (equivalent to disabling recording), then
-;	re-establish the playback mode.
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
-;	Output:	none
-;
-VailInputSelect
-			cmpi.b	#sndMicrophone,d0				; are we selecting the mike?
-			beq		VailNewInputSelect				; yes - continue
-
-@saveregs	reg		d1/a0
-			movem.l	@saveregs,-(sp)
-			moveq	#sndSonoraDFAC-256,d0			; DFAC playback mode for Sonora sound
-			andi.b	#sndPlayThruMask,d0				; mask off playthru volume
-			move.b	SDVolume,d1						; get the volume <H22>
-			lsl.b	#5,d1							; shift it into top 3 bits <H22>
-			or.b	d1,d0							; or in last volume <H22>
-			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem
-			movem.l	(sp)+,@saveregs
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	VailNewInputSelect  -  Select the sound input source on a Vail
-;
-;	If we are selecting "none" for the input source, then turn off the volume
-;	and AGC to prevent any noise leakage.  Save the old volume and restore it
-;	later when a new source is selected.  Turn on Playthru while recording so that
-;	we can play and record simultaneously.  Turning Playthru on while in record mode
-;	causes the filtering mechanism to be by-passed in the playback sound path.
-;	This difference is not audibly noticable in 22kHz mode.
-;
-;	Input:	do.b	input selection
-;						0  =  none (off)
-;						1  =  microphone
-;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
-;	Output:	d0.b	last source
-;
-
-VailNewInputSelect
-@saveregs	reg		d1/a0-a1
-
-			movem.l	@saveregs,-(sp)
-			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
-			move.w	sr,-(sp)						;												<t9>
-			ori.w	#HiIntMask,sr					; disable ints									<t9>
-
-			moveq.l	#3,d2							; get selection bits to return					<t9>
-			and.b	DFAClast(a0),d2					; save for return								<t9>
-
-			moveq	#(sndSelectMask\				;												<t6>
-					AND sndPlayThruMask\
-					AND	sndAGCMask),d1				; mask off selection, volume, and AGC bits
-			and.b	DFAClast(a0),d1					;  in the DFAC register image					<t6>
-			or.b	d0,d1							;  and OR them into DFAC image					<t6>
-
-			;	Check for volume and AGC to update in DFAC now that a sound source has been selected.
-			;	If we are disabling input, then zero the volume and disable AGC to prevent noise
-			;	leakage, otherwise set the currently selected volume and AGC levels.
-
-			tst.b	d0								; are we turning off input?
-			beq.s	@send							; yes - set no input and zero volume
-			or.b	UserVolume(a0),d1				; set volume level <H22>
-			cmpi.b	#sndMicrophone,d0				; are we selecting the mike input?				<H13>
-			bne.s	@send							; no - do not enable AGC						<H13>
-			or.b	UserAGC(a0),d1					; set AGC level									<t6>
-
-@send
-			move.b	d1,d0							; d0 = new DFAC value
-			bset	#sndPlayThruBit,d0				; set bit
-			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem			<t6>
-
-			move.w	(sp)+,sr						; enable ints									<t9>
-			move.b	d2,d0							; return source bits we replaced				<t9>
-			movem.l	(sp)+,@saveregs
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;	VailSetVol  -  Set the playback volume on Sonora hardware
-;
-;	Set the playback volume using the DFAC chip instead of the volume control register
-;	on Batman.
-;
-;	Input:	d0.b = volume level (0-7)
-;	Output:	none
-;
-
-VailSetVol
-@SaveRegs	reg	a0-a1
-			movem.l	@SaveRegs,-(sp)
-			movea.l	ASCBase,a0						; get base address of asc/batman
-			move.l	ExpandMem,d1					; do we have expandmem set up yet??				<SM5>
-			ble.s	@oldWay							; nope, do it the old way						<SM5>
-			movea.l	d1,a1							;												<SM5>
-			move.l	emSndPrimitives(a1),d1			; do we have sound primitives yet??  			<SM5>
-			beq.s	@oldWay							; nope, do it the old way
-			movea.l	d1,a1							; point to the table							<SM5>
-			tst.b	DFAClast(a1)					; has DFAClast been initialized?
-			bne.s	@skipDFAClastInit				; yep, don't reinitialize it...
-			move.b	#sndSonoraDFAC,DFAClast(a1)		; initialize DFAClast
-
-@skipDFAClastInit
-			moveq	#3,d1							; mask off the input source						<SM5>
-			and.b	DFACLast(a1),d1					;												<H22><SM5>
-			cmpi.b	#sndSelectMike,d1				; is it in record mode??						<H22>
-			beq.s	@restore						; yes, don't do anything						<H22>
-
-			move.b	#(7<<5),ascVolControl(a0)		; set volume to seven
-			move.b	UserVolume(a1),-(sp)			; save off UserVolume							<H22>
-			jsrTBL	sndPlayThruVol					; head off to set PlayThru volume
-			move.b	(sp)+,UserVolume(a1)			; restore original UserVolume					<H22>
-
-@restore	movem.l	(sp)+,@SaveRegs					; restore registers
-			rts										; and return
-
-@oldWay
-			lsl.b	#5,d0							; shift volume up to pwm position
-			move.b	d0,ascVolControl(a0)			; save it in ASC volume register
-			movem.l	(sp)+,@SaveRegs					; restore registers
-			rts										; and split
-
-		ENDIF										; {hasSonora}
-
-
-		IF hasDJMEMC THEN
-;•••••••••••••••••••••••••••••••••••••••• DJMEMC ••••••••••••••••••••••••••••••••••••••••
-
-;——————————————————————————————————————————————————————————————————————————————
-;
-; Routine:	DJMEMCInitSoundHW
-;
-; Inputs:	D0	-	sound volume (0-7)
-;			A0	-	pointer to machine's DecoderInfo table
-;			A1	-	pointer to machine's ProductInfo table
-;			A6	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0,A3
-;
-; Function:	Called by BSR6 from StartInit to set the default volume for DJMEMC
-;			based machines.  Although they have a standard Batman implementation,
-;			the need to whack on their built-in video to prevent calamity.
-;——————————————————————————————————————————————————————————————————————————————
-
-DJMEMCInitSoundHW
-			MOVEA.L	ASCAddr(A0),A3					; point to the base of the ASC
-			ASL.B	#5,D0							; shift the sound volume into the upper 3 bits
-			MOVE.B	D0,ascVolControl(A3)			;  and set the volume
-
-			MOVE.W	#$7F00,bmLeftScaleA(A3)			; pan channel A full left
-			MOVE.W	#$007F,bmLeftScaleB(A3)			; pan channel B full right
-
-			MOVEQ	#1,D0
-			MOVE.L	D0,$F9800100					; shut off sync to built-in video BEFORE beeping
-			CMPI.L	#WmStConst,WarmStart			; If we’re just powering on,
-			BNE		FinishBatmanInit				;	then just go on
-			MOVE.B	#0,$50F14f2f					; otherwise, reset the Sound Block Configuration register
-
-			BRA		FinishBatmanInit				; finish up with normal initialization
-
-		ENDIF
-
-
-
-;•••••••••••••••••••••••••••••••••••••••• Cyclone •••••••••••••••••••••••••••••••••••••••
-
-CycloneSndStubNoRam
-			Rts6
-
-CycloneSndStub2
-			Moveq	#0,D0
-CycloneSndStub1
-			Rts
-
-
-;••••••••••••••••••••••••••••••••••••••••••• PDM ••••••••••••••••••••••••••••••••••••••••••
-
-PDMSndStubNoRam
+			Export	SndCntlNW
+			dc.w	0										; flags
+			dc.w	(SndCntlNWEnd-SndCntlNW)/4				; number of entries
+SndCntlNW													; Fake 'em
+			dc.l	NWSndStubNoRam-SndCntlNW				; For machines that need to init DFAC via Egret
+			dc.l	NWSndStub1-SndCntlNW					; For machines that use Egret to talk to DFAC
+			dc.l	NWSndStub1-SndCntlNW					; Set Volume
+			dc.l	NWSndStub1-SndCntlNW					; Enable Sound Interrupts
+			dc.l	NWSndStub1-SndCntlNW					; Disable Sound Interrupts
+			dc.l	NWSndStub1-SndCntlNW					; Clear Sound Interrupt(s)
+			dc.l	NWSndStub1-SndCntlNW					; Input Select
+			dc.l	NWSndStub2-SndCntlNW					; Query which input device(s) is/are selected
+			dc.l	NWSndStub1-SndCntlNW					; Enable/Disable Aux Bypass
+			dc.l	NWSndStub1-SndCntlNW					; Set PlayThru Volume
+			dc.l	NWSndStub1-SndCntlNW					; Enable/Disable AGC
+			dc.l	NWSndStub1-SndCntlNW					; InitSoundHW - called by StartInit to set vol
+			dc.l	NWSndStub1-SndCntlNW					; dontUse1
+			dc.l	NWSndStub1-SndCntlNW					; dontUse2
+			dc.l	NWSndStub1-SndCntlNW					; dontUse3
+			dc.l	NWSndStubNoRam-SndCntlNW				; sndInitSoundHW2
+SndCntlNWEnd
+
+
+
+;••••••••••••••••••••••••••••••••••••••••••• NW ••••••••••••••••••••••••••••••••••••••••••
+
+NWSndStubNoRam
 			Rts6
 
-PDMSndStub2
+NWSndStub2
 			Moveq	#0,D0
-PDMSndStub1
+NWSndStub1
 			Rts
 
 
-		IF hasPratt THEN
-;•••••••••••••••••••••••••••••••••••••••• Blackbird •••••••••••••••••••••••••••••••••••••••
-
-;—————————————————————————————————————————————————————————————————————————————————————————
-;	DoNothing routines  -  The following routines simply return to the caller (used for
-;							unimplemented sound primitives).
-
-DoNothingViaA6
-			RTS6
-
-DoNothing
-			rts
-
-
-;——————————————————————————————————————————————————————————————————————————————
-;
-; Routine:	WhitneyInitSoundHW
-;
-; Inputs:	D0	-	sound volume (0-7)
-;			D1	-	0 is called via the RAMless routine, else 1
-;			A0	-	pointer to machine's DecoderInfo table
-;			A1	-	pointer to machine's ProductInfo table
-;			A6	-	return address
-;
-; Outputs:	none
-;
-; Trashes:	D0,A3
-;
-; Function:	Called by InitSoundHW (via BSR6) to configure hardware for Whitney
-;			based machines (i.e. Blackbird). Called before the trap dispatcher
-;			is initialized.  Always returns via (A6).
-;——————————————————————————————————————————————————————————————————————————————
-BB_BASE		EQU		$10000							; sound buffer base addr for bootbeep (64K)
-
-WhitneyInitSoundHW
-
-			movea.l	ASCAddr(a0),a3					; point to the base of the ASC
-			
-			; Set Whitney sound FIFO base address
-			; NOTE: We use the value of d1 to determine how to set the base address. If d1
-			;  is 0, then we know that we entered via the RAMless entry point (called immediately
-			;  before and after bootbeep).  In this case, we know we have some RAM available, 
-			;  so we temporarily grab some low in memory for the sound buffer.
-			;  If d1 is 1, we set the "real" FIFO base address to just above the boot/start globals,
-			;  since this is where space is allocated for it by the SizeSoundBuffer routine.
-			tst.w	d1
-			bne.s	@setRealFIFOBase
-			
-@setTempFIFOBase
-			move.l	#BB_BASE,wSndFIFOBase(a3)		; set FIFO base for BootBeep
-			bra.s	@setSndCntl
-
-@setRealFIFOBase
-			movem.l	a0,-(sp)						; (don't worry, the stack exists for this path)
-			movea.l	BootGlobPtr,a0
-			adda.l	StartGlobals.sgTopOff(a0),a0
-			move.l	a0,wSndFIFOBase(a3)				; the REAL sound FIFO base
-			movem.l	(sp)+,a0
-
-@setSndCntl	; Set up the Singer control registers
-			move.w	#((%0100<<wRGain)|\				; set gain
-					(%0100<<wLGain)|\
-					(%0<<wInSelRight)|\				; select line-in
-					(%0<<wInSelLeft)|\
-					(%0<<wMute)|\						; do not mute output
-					(%00000<<wWordAOut))\				; MUST be 0 for Singer to function
-							,wSndSingerCtl1(a3)
-					
-			move.w	#((%0000<<wDigOut)|\				; digital out lines not used
-					(%0000<<wRAtten)|\					; no output attenutation (will be set later)
-					(%0000<<wLAtten)|\
-					(%0000<<wWordBOut))\				; MUST be 0 for Singer to function
-							,wSndSingerCtl2(a3)
-					
-@setSCR		; Set up the sound control register		
-			move.b	#((%01<<wSampleRate)|\			; 22 kHz sample rate
-					(%00<<wFIFOSize)|\				; 1K elements in FIFO
-					(1<<wSingerClk)|\				; enable Singer clock
-					(1<<wSingerPower))\
-							,wSndControl(a3)		; set new sound control reg
-			
-			; Set the volume
-@setVol		lsl.b	#5,d0							; shift the sound volume into the upper 3 bits
-			move.b	d0,ascVolControl(a3)			;  and set the volume
-			
-			; Mask sound interrupts
-			move.b	#1,bmIntControlA(a3)			; mask interrupts
-			move.b	#1,bmIntControlB(a3)
-		
-			; Clear the FIFOs
-			ori.b	#$80,ascFifoControl(a3)			; toggle the clear FIFO bit
-			andi.b	#$7F,ascFifoControl(a3)
-
-			; Set Play mode
-			move.b	#$00,ascPlayRecA(a3)			; disable recording
-			move.b	#$01,ascMode(a3)				; enable sound play
-			
-			RTS6
-
-		ENDIF										; {hasPratt}
-
-
-
 			End
 
diff --git a/OS/Keyboard/Kbd.r b/OS/Keyboard/Kbd.r
--- a/OS/Keyboard/Kbd.r
+++ b/OS/Keyboard/Kbd.r
@@ -99,6 +99,32 @@
 #define US607name	"U.S. - System 6"
 #define US607ID		16383
 
+
+data 'vadb' (0, "ISO Cosmo") {
+	$"0001 05AC 0202 00C7"
+};
+
+data 'vadb' (1, "JIS Cosmo") {
+	$"0001 05AC 0203 00C8"
+};
+
+data 'vadb' (2, "ANSI Cosmo") {
+	$"0001 05AC 0201 00C6"
+};
+
+data 'vadb' (3, "ISO Andy") {
+	$"0001 05AC 0205 00CD"
+};
+
+data 'vadb' (4, "JIS Andy") {
+	$"0001 05AC 0206 00CE"
+};
+
+data 'vadb' (5, "ANSI Andy") {
+	$"0001 05AC 0204 00CC"
+};
+
+
 //__________________________________________________________________________________________________
 // map from key codes to ASCII
 
@@ -661,6 +687,125 @@ resource 'KCHR' (0, USname, KCHRAttributes) {											/*<11>*/
 		}
 	};
 
+	resource 'KMAP' (27, sysHeap, locked) {
+		27, 0, {
+			$00; $01; $02; $03; $04; $05; $06; $07; $08; $09; $0A; $0B; $0C; $0D; $0E; $0F;
+			$10; $11; $12; $13; $14; $15; $16; $17; $18; $19; $1A; $1B; $1C; $1D; $1E; $1F;
+			$20; $21; $22; $23; $24; $25; $26; $27; $28; $29; $2A; $2B; $2C; $2D; $2E; $2F;
+			$30; $31; $32; $33; $34; $35; $3B; $37; $38; $B9; $3A; $7B; $7C; $7D; $7E; $3F;
+			$40; $41; $42; $43; $44; $45; $46; $47; $48; $49; $4A; $4B; $4C; $4D; $4E; $4F;
+			$50; $51; $52; $53; $54; $55; $56; $57; $58; $59; $5A; $5B; $5C; $5D; $5E; $5F;
+			$60; $61; $62; $63; $64; $65; $66; $67; $68; $69; $6A; $6B; $6C; $6D; $6E; $6F;
+			$70; $71; $72; $73; $74; $75; $76; $77; $78; $79; $7A; $3C; $3D; $3E; $36; $7F;
+		},
+		{
+			$39, noXor, $E, "\$00\$02";
+			$B9, noXor, $E, "\$00\$02";
+		}
+	};
+
+	resource 'KMAP' (198, sysHeap, locked) {
+		198, 0, {
+			$00; $01; $02; $03; $04; $05; $06; $07; $08; $09; $0A; $0B; $0C; $0D; $0E; $0F;
+			$10; $11; $12; $13; $14; $15; $16; $17; $18; $19; $1A; $1B; $1C; $1D; $1E; $1F;
+			$20; $21; $22; $23; $24; $25; $26; $27; $28; $29; $2A; $2B; $2C; $2D; $2E; $2F;
+			$30; $31; $32; $33; $34; $35; $3B; $37; $38; $B9; $3A; $7B; $7C; $7D; $7E; $3F;
+			$40; $41; $42; $43; $44; $45; $46; $47; $48; $49; $4A; $4B; $4C; $4D; $4E; $4F;
+			$50; $51; $52; $53; $54; $55; $56; $57; $58; $59; $5A; $5B; $5C; $5D; $5E; $5F;
+			$60; $61; $62; $63; $64; $65; $66; $67; $68; $69; $6A; $6B; $6C; $6D; $6E; $6F;
+			$70; $71; $72; $73; $74; $75; $76; $77; $78; $79; $7A; $3C; $3D; $3E; $36; $7F;
+		},
+		{
+			$39, noXor, $E, "\$00\$02";
+			$B9, noXor, $E, "\$00\$02";
+		}
+	};
+
+	resource 'KMAP' (199, sysHeap, locked) {
+		199, 0, {
+			$00; $01; $02; $03; $04; $05; $06; $07; $08; $09; $32; $0B; $0C; $0D; $0E; $0F;
+			$10; $11; $12; $13; $14; $15; $16; $17; $18; $19; $1A; $1B; $1C; $1D; $1E; $1F;
+			$20; $21; $22; $23; $24; $25; $26; $27; $28; $29; $2A; $2B; $2C; $2D; $2E; $2F;
+			$30; $31; $0A; $33; $34; $35; $3B; $37; $38; $B9; $3A; $7B; $7C; $7D; $7E; $3F;
+			$40; $41; $42; $43; $44; $45; $46; $47; $48; $49; $4A; $4B; $4C; $4D; $4E; $4F;
+			$50; $51; $52; $53; $54; $55; $56; $57; $58; $59; $5A; $5B; $5C; $5D; $5E; $5F;
+			$60; $61; $62; $63; $64; $65; $66; $67; $68; $69; $6A; $6B; $6C; $6D; $6E; $6F;
+			$70; $71; $72; $73; $74; $75; $76; $77; $78; $79; $7A; $3C; $3D; $3E; $36; $7F;
+		},
+		{
+			$39, noXor, $E, "\$00\$02";
+			$B9, noXor, $E, "\$00\$02";
+		}
+	};
+
+	resource 'KMAP' (200, sysHeap, locked) {
+		200, 0, {
+			$00; $01; $02; $03; $04; $05; $06; $07; $08; $09; $0A; $0B; $0C; $0D; $0E; $0F;
+			$10; $11; $12; $13; $14; $15; $16; $17; $18; $19; $1A; $1B; $1C; $1D; $1E; $1F;
+			$20; $21; $22; $23; $24; $25; $26; $27; $28; $29; $2A; $2B; $2C; $2D; $2E; $2F;
+			$30; $31; $32; $33; $34; $35; $3B; $37; $38; $B9; $3A; $7B; $7C; $7D; $7E; $3F;
+			$40; $41; $42; $43; $44; $45; $46; $47; $48; $49; $4A; $4B; $4C; $4D; $4E; $4F;
+			$50; $51; $52; $53; $54; $55; $56; $57; $58; $59; $5A; $5B; $5C; $5D; $5E; $5F;
+			$60; $61; $62; $63; $64; $65; $66; $67; $68; $69; $6A; $6B; $6C; $6D; $6E; $6F;
+			$70; $71; $72; $73; $74; $75; $76; $77; $78; $79; $7A; $3C; $3D; $3E; $36; $7F;
+		},
+		{
+			$39, noXor, $E, "\$00\$02";
+			$B9, noXor, $E, "\$00\$02";
+		}
+	};
+
+	resource 'KMAP' (204, sysHeap, locked) {
+		204, 0, {
+			$00; $01; $02; $03; $04; $05; $06; $07; $08; $09; $0A; $0B; $0C; $0D; $0E; $0F;
+			$10; $11; $12; $13; $14; $15; $16; $17; $18; $19; $1A; $1B; $1C; $1D; $1E; $1F;
+			$20; $21; $22; $23; $24; $25; $26; $27; $28; $29; $2A; $2B; $2C; $2D; $2E; $2F;
+			$30; $31; $32; $33; $34; $35; $3B; $37; $38; $B9; $3A; $7B; $7C; $7D; $7E; $3F;
+			$40; $41; $42; $43; $44; $45; $46; $47; $48; $49; $4A; $4B; $4C; $4D; $4E; $4F;
+			$50; $51; $52; $53; $54; $55; $56; $57; $58; $59; $5A; $5B; $5C; $5D; $5E; $5F;
+			$60; $61; $62; $63; $64; $65; $66; $67; $68; $69; $6A; $6B; $6C; $6D; $6E; $6F;
+			$70; $71; $72; $73; $74; $75; $76; $77; $78; $79; $7A; $3C; $3D; $3E; $36; $7F;
+		},
+		{
+			$39, noXor, $E, "\$00\$02";
+			$B9, noXor, $E, "\$00\$02";
+		}
+	};
+
+	resource 'KMAP' (205, sysHeap, locked) {
+		205, 0, {
+			$00; $01; $02; $03; $04; $05; $06; $07; $08; $09; $32; $0B; $0C; $0D; $0E; $0F;
+			$10; $11; $12; $13; $14; $15; $16; $17; $18; $19; $1A; $1B; $1C; $1D; $1E; $1F;
+			$20; $21; $22; $23; $24; $25; $26; $27; $28; $29; $2A; $2B; $2C; $2D; $2E; $2F;
+			$30; $31; $0A; $33; $34; $35; $3B; $37; $38; $B9; $3A; $7B; $7C; $7D; $7E; $3F;
+			$40; $41; $42; $43; $44; $45; $46; $47; $48; $49; $4A; $4B; $4C; $4D; $4E; $4F;
+			$50; $51; $52; $53; $54; $55; $56; $57; $58; $59; $5A; $5B; $5C; $5D; $5E; $5F;
+			$60; $61; $62; $63; $64; $65; $66; $67; $68; $69; $6A; $6B; $6C; $6D; $6E; $6F;
+			$70; $71; $72; $73; $74; $75; $76; $77; $78; $79; $7A; $3C; $3D; $3E; $36; $7F;
+		},
+		{
+			$39, noXor, $E, "\$00\$02";
+			$B9, noXor, $E, "\$00\$02";
+		}
+	};
+
+	resource 'KMAP' (206, sysHeap, locked) {
+		206, 0, {
+			$00; $01; $02; $03; $04; $05; $06; $07; $08; $09; $0A; $0B; $0C; $0D; $0E; $0F;
+			$10; $11; $12; $13; $14; $15; $16; $17; $18; $19; $1A; $1B; $1C; $1D; $1E; $1F;
+			$20; $21; $22; $23; $24; $25; $26; $27; $28; $29; $2A; $2B; $2C; $2D; $2E; $2F;
+			$30; $31; $32; $33; $34; $35; $3B; $37; $38; $B9; $3A; $7B; $7C; $7D; $7E; $3F;
+			$40; $41; $42; $43; $44; $45; $46; $47; $48; $49; $4A; $4B; $4C; $4D; $4E; $4F;
+			$50; $51; $52; $53; $54; $55; $56; $57; $58; $59; $5A; $5B; $5C; $5D; $5E; $5F;
+			$60; $61; $62; $63; $64; $65; $66; $67; $68; $69; $6A; $6B; $6C; $6D; $6E; $6F;
+			$70; $71; $72; $73; $74; $75; $76; $77; $78; $79; $7A; $3C; $3D; $3E; $36; $7F;
+		},
+		{
+			$39, noXor, $E, "\$00\$02";
+			$B9, noXor, $E, "\$00\$02";
+		}
+	};
+
 #endif
 
 
@@ -2433,3 +2578,309 @@ resource 'KCHR' (0, USname, KCHRAttributes) {											/*<11>*/
 	};
 
 #endif
+
+	data 'KCAP' (198) {
+		$"0032 003C 00F0 01E0 000C 002A 0024 017A"
+		$"000D 0000 000B 0015 0010 0035 0038 000A"
+		$"007A 0000 001E 0078 0000 0014 0063 0000"
+		$"0014 0076 0000 0014 0060 0000 001E 0061"
+		$"0000 0014 0062 0000 0014 0064 0000 0014"
+		$"0065 0000 001E 006D 0000 0014 0067 0000"
+		$"0014 006F 0000 0014 0072 0000 0028 0073"
+		$"0000 0014 0074 0000 0014 0079 0000 0014"
+		$"0000 0015 0015 0031 0032 0046 000A 0012"
+		$"0000 0014 0013 0000 0014 0014 0000 0014"
+		$"0015 0000 0014 0017 0000 0014 0016 0000"
+		$"0014 001A 0000 0014 001C 0000 0014 0019"
+		$"0000 0014 001D 0000 0014 001B 0000 0014"
+		$"0018 0000 0014 002A 0014 001E 001E 0000"
+		$"FFEC 0021 0000 FFEC 0023 0000 FFEC 001F"
+		$"0000 FFEC 0022 0000 FFEC 0020 0000 FFEC"
+		$"0010 0000 FFEC 0011 0000 FFEC 000F 0000"
+		$"FFEC 000E 0000 FFEC 000D 0000 FFEC 000C"
+		$"0000 FFEC 0000 0014 0005 0001 0000 0014"
+		$"0002 0000 0014 0003 0000 0014 0005 0000"
+		$"0014 0004 0000 0014 0026 0000 0014 0028"
+		$"0000 0014 0025 0000 0014 0029 0000 0014"
+		$"0027 0000 0014 002C 0014 FFF6 002F 0000"
+		$"FFEC 002B 0000 FFEC 002E 0000 FFEC 002D"
+		$"0000 FFEC 000B 0000 FFEC 0009 0000 FFEC"
+		$"0008 0000 FFEC 0007 0000 FFEC 0006 0000"
+		$"FFEC 003A 0014 FFEC 0037 0000 0014 0037"
+		$"0000 0096 0000 0015 0015 000F 0041 0096"
+		$"0168 0055 FFEC 0000 0054 0000 FFEC 0053"
+		$"0000 FFEC 0056 FFEC 0000 0057 0000 0014"
+		$"0058 0000 0014 0045 0000 0014 004E FFEC"
+		$"0000 005C 0000 FFEC 005B 0000 FFEC 0059"
+		$"0000 FFEC 0047 FFEC 0000 0051 0000 0014"
+		$"004B 0000 0014 0043 0000 0014 0000 0015"
+		$"001F 0000 0030 005A 000A 0000 0015 001F"
+		$"0000 0033 0046 010E 0000 0015 0029 0000"
+		$"0052 0096 0140 0000 0029 0015 0000 004C"
+		$"0082 017C 0000 0015 001A 0000 003B 0096"
+		$"000A 0000 000B 0015 0003 007B 00A2 00F0"
+		$"007D 0000 0014 007C 0000 0014 007E FFF6"
+		$"FFEC 0000 0015 0024 0000 0039 006E 000A"
+		$"0000 0015 0024 0000 0024 006E 0109 0000"
+		$"0015 002E 0001 0038 0082 000A 0038 0000"
+		$"00F5 0000 0015 0083 0000 0031 0096 004B"
+	};
+
+	data 'KCAP' (199) {
+		$"0032 003C 00F0 01E0 000C 002A 0024 017A"
+		$"000E 0000 000B 0015 0010 0035 0038 000A"
+		$"007A 0000 001E 0078 0000 0014 0063 0000"
+		$"0014 0076 0000 0014 0060 0000 001E 0061"
+		$"0000 0014 0062 0000 0014 0064 0000 0014"
+		$"0065 0000 001E 006D 0000 0014 0067 0000"
+		$"0014 006F 0000 0014 0072 0000 0028 0073"
+		$"0000 0014 0074 0000 0014 0079 0000 0014"
+		$"0000 0015 0015 002F 000A 0046 000A 0012"
+		$"0000 0014 0013 0000 0014 0014 0000 0014"
+		$"0015 0000 0014 0017 0000 0014 0016 0000"
+		$"0014 001A 0000 0014 001C 0000 0014 0019"
+		$"0000 0014 001D 0000 0014 001B 0000 0014"
+		$"0018 0000 0014 001E 0014 000A 0021 0000"
+		$"FFEC 0023 0000 FFEC 001F 0000 FFEC 0022"
+		$"0000 FFEC 0020 0000 FFEC 0010 0000 FFEC"
+		$"0011 0000 FFEC 000F 0000 FFEC 000E 0000"
+		$"FFEC 000D 0000 FFEC 000C 0000 FFEC 0000"
+		$"0014 0005 0001 0000 0014 0002 0000 0014"
+		$"0003 0000 0014 0005 0000 0014 0004 0000"
+		$"0014 0026 0000 0014 0028 0000 0014 0025"
+		$"0000 0014 0029 0000 0014 0027 0000 0014"
+		$"002A 0000 0014 002C 0014 FFE7 002F 0000"
+		$"FFEC 002B 0000 FFEC 002E 0000 FFEC 002D"
+		$"0000 FFEC 000B 0000 FFEC 0009 0000 FFEC"
+		$"0008 0000 FFEC 0007 0000 FFEC 0006 0000"
+		$"FFEC 0032 0000 FFEC 0000 0015 0015 000F"
+		$"0041 0096 0168 0055 FFEC 0000 0054 0000"
+		$"FFEC 0053 0000 FFEC 0056 FFEC 0000 0057"
+		$"0000 0014 0058 0000 0014 0045 0000 0014"
+		$"004E FFEC 0000 005C 0000 FFEC 005B 0000"
+		$"FFEC 0059 0000 FFEC 0047 FFEC 0000 0051"
+		$"0000 0014 004B 0000 0014 0043 0000 0014"
+		$"0000 0015 001F 0000 0030 005A 000A 0000"
+		$"0015 001F 0001 0038 0082 000A 003A 0014"
+		$"0019 0000 0015 0029 0000 0052 0096 0140"
+		$"0000 0029 0015 0000 004C 0082 017C 0000"
+		$"0015 001A 0002 003B 0096 000A 0037 0000"
+		$"0037 0037 0000 009B 0000 000B 0015 0003"
+		$"007B 00A0 00F5 007D 0000 0014 007C 0000"
+		$"0014 007E FFF6 FFEC 0000 0015 0024 0000"
+		$"0039 006E 000A 0000 0015 0024 0000 0033"
+		$"0046 010E 0001 0015 001A 0029 0005 0000"
+		$"0024 005A 0118 0000 0015 002E 0000 0038"
+		$"0082 0104 0000 0015 0083 0000 0031 0096"
+		$"005A"
+	};
+
+	data 'KCAP' (200) {
+		$"0032 003C 00F0 01E0 000C 002A 0024 017A"
+		$"0010 0000 000B 0015 0010 0035 0038 000A"
+		$"007A 0000 0021 0078 0000 0014 0063 0000"
+		$"0014 0076 0000 0014 0060 0000 001C 0061"
+		$"0000 0014 0062 0000 0014 0064 0000 0014"
+		$"0065 0000 001C 006D 0000 0014 0067 0000"
+		$"0014 006F 0000 0014 0072 0000 0028 0073"
+		$"0000 0014 0074 0000 0014 0079 0000 0014"
+		$"0000 0015 001C 0000 0012 0046 000A 0000"
+		$"0015 0015 000B 0013 0046 0025 0014 0000"
+		$"0014 0015 0000 0014 0017 0000 0014 0016"
+		$"0000 0014 001A 0000 0014 001C 0000 0014"
+		$"0019 0000 0014 001D 0000 0014 001B 0000"
+		$"0014 0018 0000 0014 005D 0000 0014 0000"
+		$"0015 0018 0000 0033 0046 0115 0000 0015"
+		$"0015 0026 001E 005A 00FA 0021 0000 FFEC"
+		$"0023 0000 FFEC 001F 0000 FFEC 0022 0000"
+		$"FFEC 0020 0000 FFEC 0010 0000 FFEC 0011"
+		$"0000 FFEC 000F 0000 FFEC 000E 0000 FFEC"
+		$"000D 0000 FFEC 000C 0000 FFEC 0030 0000"
+		$"FFEC 0000 0014 0019 0001 0000 0014 0002"
+		$"0000 0014 0003 0000 0014 0005 0000 0014"
+		$"0004 0000 0014 0026 0000 0014 0028 0000"
+		$"0014 0025 0000 0014 0029 0000 0014 0027"
+		$"0000 0014 002A 0000 0014 005E 0014 FFF6"
+		$"002C 0000 FFEC 002F 0000 FFEC 002B 0000"
+		$"FFEC 002E 0000 FFEC 002D 0000 FFEC 000B"
+		$"0000 FFEC 0009 0000 FFEC 0008 0000 FFEC"
+		$"0007 0000 FFEC 0006 0000 FFEC 003A 0014"
+		$"FFFD 0037 0000 0014 0066 0000 0014 0001"
+		$"0015 001F 0029 0005 0000 0024 005A 010E"
+		$"0000 0015 001A 0000 0036 006E 000A 0000"
+		$"0015 0024 0000 0038 0082 000A 0000 0015"
+		$"0024 0000 0038 0082 0109 0000 0029 0015"
+		$"0000 004C 0082 017C 0000 0015 001A 0003"
+		$"003B 006E 000A 0068 0028 009C 0037 0000"
+		$"0019 003A 0000 0019 0000 0015 0015 000F"
+		$"0041 0096 0168 0055 FFEC 0000 0054 0000"
+		$"FFEC 0053 0000 FFEC 0056 FFEC 0000 0057"
+		$"0000 0014 0058 0000 0014 0045 0000 0014"
+		$"004E FFEC 0000 005C 0000 FFEC 005B 0000"
+		$"FFEC 0059 0000 FFEC 0047 FFEC 0000 0051"
+		$"0000 0014 004B 0000 0014 0043 0000 0014"
+		$"0000 0015 0021 0000 0039 0096 000A 0000"
+		$"0015 0041 0000 0031 0096 0066 0000 0015"
+		$"0015 0001 0052 0096 0140 005F 0000 0014"
+		$"0000 000B 0015 0003 007B 00A0 00F5 007D"
+		$"0000 0014 007C 0000 0014 007E FFF6 FFEC"
+	};
+
+	data 'KCAP' (204) {
+		$"0032 003C 00E6 022B 000C 002A 0024 01CD"
+		$"0010 0000 0015 0015 0015 0035 0032 000A"
+		$"007A 0000 0020 0078 0000 0014 0063 0000"
+		$"0014 0076 0000 0014 0060 0000 0020 0061"
+		$"0000 0014 0062 0000 0014 0064 0000 0014"
+		$"0065 0000 001F 006D 0000 0014 0067 0000"
+		$"0014 006F 0000 0014 0069 0000 0028 006B"
+		$"0000 0014 0071 0000 0014 0072 0014 FFD8"
+		$"0073 0000 0014 0074 0000 0014 0075 0014"
+		$"FFD8 0077 0000 0014 0079 0000 0014 0000"
+		$"0015 0015 002D 0032 0046 000A 0012 0000"
+		$"0014 0013 0000 0014 0014 0000 0014 0015"
+		$"0000 0014 0017 0000 0014 0016 0000 0014"
+		$"001A 0000 0014 001C 0000 0014 0019 0000"
+		$"0014 001D 0000 0014 001B 0000 0014 0018"
+		$"0000 0014 001E 0014 000A 0021 0000 FFEC"
+		$"0023 0000 FFEC 001F 0000 FFEC 0022 0000"
+		$"FFEC 0020 0000 FFEC 0010 0000 FFEC 0011"
+		$"0000 FFEC 000F 0000 FFEC 000E 0000 FFEC"
+		$"000D 0000 FFEC 000C 0000 FFEC 0000 0014"
+		$"0005 0001 0000 0014 0002 0000 0014 0003"
+		$"0000 0014 0005 0000 0014 0004 0000 0014"
+		$"0026 0000 0014 0028 0000 0014 0025 0000"
+		$"0014 0029 0000 0014 0027 0000 0014 002C"
+		$"0014 FFF6 002F 0000 FFEC 002B 0000 FFEC"
+		$"002E 0000 FFEC 002D 0000 FFEC 000B 0000"
+		$"FFEC 0009 0000 FFEC 0008 0000 FFEC 0007"
+		$"0000 FFEC 0006 0000 FFEC 0000 0015 0015"
+		$"000F 0041 0096 01BD 0055 FFEC 0000 0054"
+		$"0000 FFEC 0053 0000 FFEC 0056 FFEC 0000"
+		$"0057 0000 0014 0058 0000 0014 0045 0000"
+		$"0014 004E FFEC 0000 005C 0000 FFEC 005B"
+		$"0000 FFEC 0059 0000 FFEC 0047 FFEC 0000"
+		$"0051 0000 0014 004B 0000 0014 0043 0000"
+		$"0014 0000 0015 0029 0000 0052 0096 0195"
+		$"0000 0029 0015 0000 004C 0082 01D1 0000"
+		$"0015 001F 0000 0030 005A 000A 0000 0015"
+		$"0024 0000 0039 006E 000A 0000 0015 002E"
+		$"0000 0038 0082 000A 0000 0015 0033 0000"
+		$"0038 0082 00FF 0000 0015 001A 0002 003B"
+		$"0096 000A 003A 0000 0019 0037 0000 0019"
+		$"0000 0015 001A 0002 0037 0096 00E6 003A"
+		$"0000 0019 003B 0000 0019 0000 0015 0015"
+		$"0003 007E 0082 0159 007B 0014 FFEC 007D"
+		$"0000 0014 007C 0000 0014 0000 0015 0024"
+		$"0000 0033 0046 010E 0000 0015 001A 0000"
+		$"002A 005A 0118 0000 0015 0029 0000 0024"
+		$"006E 0109 0000 0015 0092 0000 0031 0096"
+		$"0055"
+	};
+
+	data 'KCAP' (205) {
+		$"0032 003C 00E6 022B 000C 002A 0024 01CD"
+		$"000F 0000 0015 0015 0015 0035 0032 000A"
+		$"007A 0000 0020 0078 0000 0014 0063 0000"
+		$"0014 0076 0000 0014 0060 0000 0020 0061"
+		$"0000 0014 0062 0000 0014 0064 0000 0014"
+		$"0065 0000 001F 006D 0000 0014 0067 0000"
+		$"0014 006F 0000 0014 0069 0000 0028 006B"
+		$"0000 0014 0071 0000 0014 0072 0014 FFD8"
+		$"0073 0000 0014 0074 0000 0014 0075 0014"
+		$"FFD8 0077 0000 0014 0079 0000 0014 0000"
+		$"0015 0015 002F 000A 0046 000A 0012 0000"
+		$"0014 0013 0000 0014 0014 0000 0014 0015"
+		$"0000 0014 0017 0000 0014 0016 0000 0014"
+		$"001A 0000 0014 001C 0000 0014 0019 0000"
+		$"0014 001D 0000 0014 001B 0000 0014 0018"
+		$"0000 0014 001E 0014 000A 0021 0000 FFEC"
+		$"0023 0000 FFEC 001F 0000 FFEC 0022 0000"
+		$"FFEC 0020 0000 FFEC 0010 0000 FFEC 0011"
+		$"0000 FFEC 000F 0000 FFEC 000E 0000 FFEC"
+		$"000D 0000 FFEC 000C 0000 FFEC 0000 0014"
+		$"0005 0001 0000 0014 0002 0000 0014 0003"
+		$"0000 0014 0005 0000 0014 0004 0000 0014"
+		$"0026 0000 0014 0028 0000 0014 0025 0000"
+		$"0014 0029 0000 0014 0027 0000 0014 002A"
+		$"0000 0014 002C 0014 FFE7 002F 0000 FFEC"
+		$"002B 0000 FFEC 002E 0000 FFEC 002D 0000"
+		$"FFEC 000B 0000 FFEC 0009 0000 FFEC 0008"
+		$"0000 FFEC 0007 0000 FFEC 0006 0000 FFEC"
+		$"0032 0000 FFEC 0000 0015 0015 000F 0041"
+		$"0096 01BD 0055 FFEC 0000 0054 0000 FFEC"
+		$"0053 0000 FFEC 0056 FFEC 0000 0057 0000"
+		$"0014 0058 0000 0014 0045 0000 0014 004E"
+		$"FFEC 0000 005C 0000 FFEC 005B 0000 FFEC"
+		$"0059 0000 FFEC 0047 FFEC 0000 0051 0000"
+		$"0014 004B 0000 0014 0043 0000 0014 0000"
+		$"0015 0029 0000 0052 0096 0195 0000 0029"
+		$"0015 0000 004C 0082 01D1 0001 0015 001A"
+		$"0029 0005 0000 0024 005A 0118 0000 0015"
+		$"001F 0000 0030 005A 000A 0000 0015 0024"
+		$"0000 0039 006E 000A 0000 0015 001F 0000"
+		$"0038 0082 000A 0000 0015 002E 0000 0038"
+		$"0082 0104 0000 0015 001A 0002 003B 0096"
+		$"000A 003A 0000 0019 0037 0000 0019 0000"
+		$"0015 001A 0002 0037 0096 00E6 003A 0000"
+		$"0019 003B 0000 0019 0000 0015 0015 0003"
+		$"007E 0082 0159 007B 0014 FFEC 007D 0000"
+		$"0014 007C 0000 0014 0000 0015 0024 0000"
+		$"0033 0046 010E 0000 0015 0092 0000 0031"
+		$"0096 0055"
+	};
+
+	data 'KCAP' (206) {
+		$"0032 003C 00E6 022B 000C 002A 0024 01CD"
+		$"0014 0000 0015 0015 0015 0035 0032 000A"
+		$"007A 0000 0020 0078 0000 0014 0063 0000"
+		$"0014 0076 0000 0014 0060 0000 0020 0061"
+		$"0000 0014 0062 0000 0014 0064 0000 0014"
+		$"0065 0000 001F 006D 0000 0014 0067 0000"
+		$"0014 006F 0000 0014 0069 0000 0028 006B"
+		$"0000 0014 0071 0000 0014 0072 0014 FFD8"
+		$"0073 0000 0014 0074 0000 0014 0075 0014"
+		$"FFD8 0077 0000 0014 0079 0000 0014 0000"
+		$"0015 0015 0003 007E 0082 0159 007B 0014"
+		$"FFEC 007D 0000 0014 007C 0000 0014 0000"
+		$"0015 001F 0000 0012 0046 000A 0000 0015"
+		$"0015 000B 0013 0046 0028 0014 0000 0014"
+		$"0015 0000 0014 0017 0000 0014 0016 0000"
+		$"0014 001A 0000 0014 001C 0000 0014 0019"
+		$"0000 0014 001D 0000 0014 001B 0000 0014"
+		$"0018 0000 0014 005D 0000 0014 0000 0015"
+		$"001A 0000 0033 0046 0118 0000 0015 001A"
+		$"0000 0030 005A 000A 0000 0015 0015 000B"
+		$"001E 005A 00FF 0021 0000 FFEC 0023 0000"
+		$"FFEC 001F 0000 FFEC 0022 0000 FFEC 0020"
+		$"0000 FFEC 0010 0000 FFEC 0011 0000 FFEC"
+		$"000F 0000 FFEC 000E 0000 FFEC 000D 0000"
+		$"FFEC 000C 0000 FFEC 0000 0015 0015 0016"
+		$"0000 006E 0028 0001 0000 0014 0002 0000"
+		$"0014 0003 0000 0014 0005 0000 0014 0004"
+		$"0000 0014 0026 0000 0014 0028 0000 0014"
+		$"0025 0000 0014 0029 0000 0014 0027 0000"
+		$"0014 002A 0000 0014 005E 0014 FFF6 002C"
+		$"0000 FFEC 002F 0000 FFEC 002B 0000 FFEC"
+		$"002E 0000 FFEC 002D 0000 FFEC 000B 0000"
+		$"FFEC 0009 0000 FFEC 0008 0000 FFEC 0007"
+		$"0000 FFEC 0006 0000 FFEC 0000 0029 0015"
+		$"0000 004C 0082 01CF 0000 0015 0015 000F"
+		$"0041 0096 01BB 0055 FFEC 0000 0054 0000"
+		$"FFEC 0053 0000 FFEC 0056 FFEC 0000 0057"
+		$"0000 0014 0058 0000 0014 0045 0000 0014"
+		$"004E FFEC 0000 005C 0000 FFEC 005B 0000"
+		$"FFEC 0059 0000 FFEC 0047 FFEC 0000 0051"
+		$"0000 0014 004B 0000 0014 0043 0000 0014"
+		$"0000 0015 0015 0001 0052 0096 0193 005F"
+		$"0000 0014 0001 0015 001F 0029 0005 0000"
+		$"0024 005A 0113 0000 0015 001F 0000 003B"
+		$"006E 000A 0000 0015 0029 0000 0038 0082"
+		$"000A 0000 0015 0024 0000 0038 0082 010E"
+		$"0000 0015 0023 0000 0039 0096 000A 0000"
+		$"0015 001A 0002 003A 0096 002C 0037 0000"
+		$"0019 0066 0000 0019 0000 0015 0051 0000"
+		$"0031 0096 0077 0000 0015 001A 0002 0068"
+		$"0096 00C7 0037 0000 0019 003A 0000 0019"
+		$"0000 0015 0020 0000 003B 0096 0112"
+	};
diff --git a/OS/MMU/GetReal.a b/OS/MMU/GetReal.a
--- a/OS/MMU/GetReal.a
+++ b/OS/MMU/GetReal.a
@@ -111,14 +111,8 @@ GetRealSize	equ		*
 
 GetRealProc	PROC	EXPORT
 			WITH	GetRealVars,MemDispGlobals
-			EXPORT	GetPageDescProc
 			EXPORT	GetMMUInfo
-			EXPORT	checkTTRegs
 
-											; Note: We dont support "GetPageDesc Address" 
-			cmpi.b	#EMMU1,MMUType			; Do we have an Emulated MMU?
-			bne.s	GetRealAddr				; -> No, OSW (old slow way).
-			
 ; Do Logical to Physical Translation for machines with EMMUs.								<SM5> SAM
 
 			MOVEM.L	A2/D1/D2,-(SP)			; Save some regs
@@ -147,69 +141,6 @@ GetRealProc	PROC	EXPORT
 *			BRA.S	@Done					; -> Exit
 			RTS
 
-GetRealAddr
-			move.w	#getReal,-(sp)			; indicate we want physical address in a0
-			bra.s	walkTable				; go walk table									<SM6>
-			
-GetPageDescProc
-			move.w	#getpageDesc,-(sp)		; indicate we want page descriptor ptr in a0
-			
-walkTable	movem.l	GetRealRegs,-(sp)		; save working registers
-			link	a6,#GetRealSize			; allocate some room for our locals
-			cmpi.b	#PMMU851,MMUType		; check to see if we have an MMU
-			bhs.s	@haveAnMMU				; IF we do not have an MMU THEN
-			move.w	#noMMUErr,d0			;	return an error
-			bra.s	@exitGetReal			;	>>EXIT routine
-@haveAnMMU									; ENDIF
-			move.l	a0,d2					; get logical address into d2
-			jsr		GetMMUInfo				; fill our globals with MMU info
-		IF Supports24Bit THEN
-			move.b	MMU32Bit,-(sp)			; save current MMU mode
-			bne.s	@in32BitMode			; IF we're in 24-bit mode THEN
-			moveq	#true32b,d0				;	we want to go to 32 bit addressing
-			_SwapMMUMode					;	switch the MMU mode
-			and.l	Lo3Bytes,d2				;	clean up the 24-bit address
-			bra.s	@doTranslation			;	go do the translation
-		ENDIF
-@in32BitMode								; ELSE
-			jsr		checkTTRegs				;	check transparent translation regs
-			bne.s	@doTranslation			;	IF we matched a TT register THEN
-			move.l	d2,a0					;	  put the original address into a0
-			move.l	#0,a2					;	  return null for page descriptor address
-			moveq	#noErr,d3				;	  return good status
-			bra.s	@cleanupGetReal			;	  >>EXIT with easy translation
-											;	ENDIF
-@doTranslation								; ENDIF											
-			cmp.b	#PMMU040,MMUType		; check MMU type
-			beq.s	@trans68040				; IF we're on a 68030 THEN
-			jsr		translate030			;	do the translation for an 851/030
-			bra.s	@cleanupGetReal			; ELSE
-@trans68040	jsr		translate040			;	do the translation for a 68040
-											; ENDIF
-
-;------------
-; a2.w = address of page descriptor, if any
-; d3.w = result code
-; a0.l = physical address if successful
-;------------
-@cleanupGetReal
-		IF Supports24Bit THEN				; SM is always in 32 bit mode					<SM4>
-			move.b	(sp)+,d0				; get original MMU mode
-			bne.s	@returnResult			; IF we were originally in 24-bit mode THEN
-			_SwapMMUMode					;	swap back to it
-		ENDIF
-@returnResult								; ENDIF
-			move.w	d3,d0					; return result in d0
-@exitGetReal
-			unlk	a6						; restore registers
-			movem.l	(sp)+,GetRealRegs		; save working registers
-			cmp.w	#getpageDesc,(sp)+		; check for page getPageDesc call
-			bne.s	@getRealDone			; IF this is the getPageDesc call THEN
-			move.l	a2,a0					;	return page descriptor pointer
-@getRealDone								; ENDIF
-			tst.w	d3
-@done		rts
-
 
 ;----------------------------------------------------------------------------------
 ;	GetMMUInfo	-	Fills the global area with MMU-specific table information.
@@ -224,358 +155,9 @@ ISOffset	equ		12						; bit offset into 851/030 TC of IS field
 pageSizeBit	equ		14						; bit number of page size bit in 68040 TC
 
 GetMMUInfo
-			cmpi.b	#EMMU1,MMUType			; Do we have an Emulated MMU
-			beq		@VMisOn					; -> Yes, just clear the Log2Phys field & Exit
-			cmp.b	#PMMU040,MMUType		; check MMU type
-			beq.s	@get040Info				; IF the MMU is an 851/030 THEN
-			pmove	crp,theCRP(a6)			;	get the 64-bit CRP value
-			pmove	tc,theTc(a6)			;	get TC value
-			move.l	theTc(a6),d4			;	put TC into d4
-			move.l	#ISOffset,d3			;	get offset into TC of IS field
-			bfextu	d4{d3:4},d0				;	get IS value
-			move.b	d0,initShift(a6)		;	save IS value in globals
-			add.l	#4,d3					;	get offset into TC of TIA field
-			bfextu	d4{d3:4},d0				;	get TIA value
-			move.b	d0,levelOne(a6)			;	save level one index width in globals
-			add.l	#4,d3					;	get offset into TC of TIB field
-			bfextu	d4{d3:4},d0				;	get TIB value
-			move.b	d0,levelTwo(a6)			;	save level one index width in globals
-			add.l	#4,d3					;	get offset into TC of TIC field
-			bfextu	d4{d3:4},d0				;	get TIC value
-			move.b	d0,levelThree(a6)		;	save level one index width in globals
-			add.l	#4,d3					;	get offset into TC of TID field
-			bfextu	d4{d3:4},d0				;	get TID value
-			move.b	d0,levelFour(a6)		;	save level one index width in globals
-			bra.s	@gotInfo				; 	go check for log2Phys offset
-@get040Info									; ELSE
-			MACHINE	MC68040					;	use 68040 instructions
-			movec	srp,d0					;	get 68040 srp
-			move.l	d0,theSRP(a6)			;	save the root ptr
-			move.l	#0,theCRP(a6)			;	68040 only has a 32-bit root pointer					<T6>
-			move.b	#7,levelOne(a6)			;	68040 always uses 7 bits for first level
-			move.b	#7,levelTwo(a6)			;	68040 always uses 7 bits for second level
-			move.b	#5,levelThree(a6)		;	assume 5 bits for 8k pages in third level
-			movec	tc,d0					;	get 68040 tc
-			move.w	d0,theTC(a6)			;	store it in globals
-			btst	#pageSizeBit,d0			;	check which page size we're using
-			bne.s	@not4kPages				;	IF we're using 4k pages
-			move.b	#6,levelThree(a6)		;	  use 6 bits for 4k pages in third level
-@not4kPages									;	ENDIF
-			move.b	#0,levelFour(a6)		;	68040 never has a fourth level
-			move.b	#0,initShift(a6)		;	68040 never has an initial shift
-			MACHINE	MC68030					;	switch back to 68030 instructions
-@gotInfo									; ENDIF
-			move.l	phys2log,myPhys2Log(a6)	; get our phys2log translation offset (Assume no vm)		<SM4>
-
-		IF not forROM THEN					; Supermario is always 32bit capable						<SM4>
-			cmp.l	#-1,ExpandMem			; is gestalt unimplemented?									<T3>
-			beq.s	@done					; IF gestalt is implemented THEN							<T3>
-			move.l	#gestaltAddressingModeAttr,d0 ; we need to find out 32-bit cleanliness
-			_Gestalt						;	call Gestalt
-			tst.w	d0						;	check for errors
-			bne.s	@VMisOn					;	>>EXIT on error			
-			move.l	a0,d0					;	get response in d0
-			btst	#gestalt32BitCapable,d0	;	check if phys2Log globals exists
-			beq.s	@VMisOn					;	>>EXIT on error
-		ENDIF
-
-		; Some history:  Since GetMMUInfo cannot be making lengthy Gestalt calls to determine if VM is on
-		; we would (previously) test the lomem where VM puts its globals to see it it had been initialized.
-		; A problem arises when VM has saved its globals ptr in VMGlobals but has not yet whacked the MMU
-		; tables and someone (VM) calls GetPhysical.  An additional flag inside the VMGlobals has been added
-		; that is set at the very end of VMs initalization.  We now check it to determine if the MMU world
-		; has been changed on us.																		<SM8> SAM
-		; 
-		
-		; Determine if VM is installed an running														<LW5>
-			
-			move.l	VMGlobals,d0			; Has VM installed its globals ptr (is it installed?)		<SM4>
-		 	ble.s	@done					; -> No.  Leave with Phys2Log offset set.
-
-			move.l	d0,a0					; Globals in.  Is VM actually running yet?
-			tst.b	VMInstalled(a0)			; VM's Gestalt inited?										<LW5>
-			beq.s	@done					; -> Nope, leave the offset alone							<LW5>
-
 @VMisOn		clr.l	myPhys2log(a6)			; VM is on. No phys2log translation
 @done		rts								; return
 
-
-;----------------------------------------------------------------------------------
-;	checkTTRegs	-	Checks a logical address against the MMU's transparent 
-;					translation registers.  This routine assumes that the 
-;					instruction and data TT registers contain identical information
-;					on the 68040.
-;
-;	input:		d2.l =	logical address to check
-;
-;	output:		ccr.z is set if the address would be transparently translated
-;
-;	destroys:	d0-d1/d3-d4
-;----------------------------------------------------------------------------------
-checkTTRegs
-			cmp.b	#PMMU040,MMUType		; check MMU type
-			beq.s	@get040Regs				; IF the MMU is an 851/030 THEN
-			subq	#4,sp					;	create room on stack for tt values
-			pmove	tt0,(sp)				;	get tt0 value
-			move.l	(sp),d0					;	store in d0
-			pmove	tt1,(sp)				;	get tt1 value
-			move.l	(sp),d1					;	store in d1
-			addq	#4,sp					;	restore stack
-			bra.s	@checkTTs				;	continue with check
-@get040Regs									; ELSE
-			MACHINE	MC68040					;	use 68040 instructions
-			movec	dtt0,d0					;	store tt0 in d0
-			movec	dtt1,d1					;	store tt1 in d1
-			MACHINE	MC68030					;	switch back to 68030
-@checkTTs									; ENDIF
-			btst	#TTEnable,d0			; see if tt0 is on
-			beq.s	@checkTT1				; IF tt0 is enabled THEN
-			move.l	d2,d3					;	make a copy of the logical address
-			eor.l	d0,d3					;	exclusive OR to leave ones in different bits
-			rol.l	#8,d3					;	move upper 8-bits into low byte
-			swap	d0						;	put logical address mask in low byte
-			not.b	d0						;	invert logical address mask
-			and.b	d0,d3					;	isolate bits we care about
-			beq.s	@checkDone				;	>>EXIT if we found a match
-@checkTT1									; ENDIF
-			btst	#TTEnable,d1			; see if tt1 is on
-			beq.s	@notEnabled				; IF tt1 is enabled THEN
-			move.l	d2,d3					;	make a copy of the logical address
-			eor.l	d1,d3					;	exclusive OR to leave ones in different bits
-			rol.l	#8,d3					;	move upper 8-bits into low byte
-			swap	d1						;	put logical address mask in low byte
-			not.b	d1						;	invert logical address mask
-			and.b	d1,d3					;	isolate bits we care about
-			bra.s	@checkDone				;	go exit
-											; ELSE
-@notEnabled	andi	#$fffb,sr				;	clear zero bit
-@checkDone									; ENDIF
-			rts
-
-
-;----------------------------------------------------------------------------------
-;	translate030	-	Translates a logical address to its corresponding physical
-;						address on a 68030.
-;
-;	input:		a6.l =	pointer to globals
-;				d2.l =	logical address to translate
-;
-;	output:		a0.l =	physical address
-;				a2.l =	ptr to page descriptor for translated address
-;				d3.w =	result code
-;
-;	destroys:	d0-d1
-;----------------------------------------------------------------------------------
-tcSRE		EQU		25						; SRP Enable in TC for 851/030
-tcFCL		EQU		24						; Function code Lookup in TC for 851/030
-tcEnable030	EQU		31						; MMU enable bit in TC on 851/030
-pageDesc	EQU		1						; page descriptor
-valid4		EQU		2						; valid 4 byte
-valid8		EQU		3						; valid 8 byte
-
-transRegs	REG		d4-d7
-
-translate030
-			movem.l	transRegs,-(sp)			; save working registers
-			move.l	theSRP(a6),d1			; get root ptr
-			move.l	theCRP(a6),d7			; get limit in d7
-			move.b	d7,d3					; get descriptor type in d3
-			and.b	#3,d3					; isolate it
-			move.l	theTC(a6),d0			; get a copy of the TC in d0
-			btst	#tcSRE,d0				; check for SRP mode
-			bne		@paramErr				; >>EXIT if on
-			btst	#tcFCL,d0				; check for FCL mode
-			bne		@paramErr				; >>EXIT if on
-			btst	#tcEnable030,d0			; check if MMU is on
-			bne.s	@startTranslate			; IF MMU is off THEN
-			move.l	d2,a1					;   return logical address unchanged
-			clr.l	d1						;	return null for page descriptor addr
-			moveq	#noErr,d3				;   return good status
-			bra.s	@xlatDone				;   >>EXIT with physical address
-@startTranslate								; ENDIF
-			clr.l	d4						; clear offset into logical address
-			move.b	initShift(a6),d4		; add in initial shift
-			lea		levelOne(a6),a1			; point a1 at width of first field
-			clr.l	d5						; get a clear longword
-			move.b	(a1)+,d5				; get width of next field
-
-;-----------------
-; a1.l = pointer to width of next field
-; d1.l = current descriptor entry
-; d2.l = logical address to translate
-; d3.b = descriptor type of current descriptor
-; d4.l = offset into logical address of index field
-; d5.l = width of index field
-; d7.l = limit of current descriptor
-;-----------------
-@xlatLoop									; LOOP (to walk an MMU table)
-			cmp.b	#pageDesc,d3			;	is this a page descriptor?
-			beq.s	@getPage				;	>>BREAK on page descriptor
-			bfextu	d2{d4:d5},d6			;	get index into next table
-			tst.l	d7						;	is there a limit for this table?
-			beq.s	@noLimit				;	IF there is a limit THEN
-			jsr		checkLimit				;	  check the index against the limit
-			bcs.s	@paramErr				;	  >>EXIT on a limit overflow
-@noLimit									;	ENDIF
-			and.l	#$fffffff0,d1			;	  remove unused bottom byte
-			cmp.b	#valid4,d3				;	check for 4-byte descriptor
-			bne.s	@not4byte				;	IF this is a four byte descriptor THEN
-			add.l	myPhys2Log(a6),d1		;	  convert current descriptor to logical addr
-			move.l	d1,a2					;	  get pointer to next table
-			lsl.w	#2,d6					;	  multiple index by four
-			add.l	d6,a2					;	  get address of next descriptor
-			move.l	(a2),d1					;	  get next descriptor
-			clr.l	d7						;	  no limit on this descriptor
-			move.b	d1,d3					;	  get a copy of descriptor
-			bra.s	@doNext					;	  look at next descriptor
-@not4byte									;	ELSE
-			cmp.b	#valid8,d3				;	  check for 8-byte descriptor
-			bne.s	@paramErr				;	  >>EXITLOOP on invalid descriptors 
-			add.l	myPhys2Log(a6),d1		;	  convert current descriptor to logical addr
-			move.l	d1,a2					;	  get pointer to next table
-			lsl.w	#3,d6					;	  multiple index by eight
-			add.l	d6,a2					;	  get address of next descriptor
-			move.l	4(a2),d1				;	  get lower word of next descriptor	
-			move.l	0(a2),d7				;	  get upper word of next descriptor	
-			move.b	d7,d3					;	  get a copy of descriptor
-
-@doNext										;	ENDIF
-			add.l	d5,d4					;	update d4 to contain number of bytes decoded
-			move.b	(a1)+,d5				;	get width of next field
-			and.b	#3,d3					;	isolate descriptor type
-			bra.s	@xlatLoop				; ENDLOOP
-@getPage
-			move.l	#32,d5					; total number of bits in address
-			sub.l	d4,d5					; get number of bits not yet decoded
-			bfextu	d1{0:d4},d0				; get top bits of address of physical page
-			bfextu	d2{d4:d5},d6			; get offset into physical page
-			lsl.l	d5,d0					; make a base address out of it
-			add.l	d6,d0					; get physical address
-			move.l	d0,a0					; put address into a1
-			moveq	#noErr,d3				; return no error
-@xlatDone
-			movem.l	(sp)+,transRegs			; restore registers
-			rts
-
-@paramErr
-			move.w	#paramErr,d3
-			bra.s	@xlatDone
-
-
-;----------------------------------------------------------------------------------
-;	translate040	-	Translates a logical address to its corresponding physical
-;						address on a 68040.
-;
-;	input:		a6.l =	pointer to globals
-;				d2.l =	logical address to translate
-;
-;	output:		a0.l =	physical address
-;				a2.l =	ptr to page descriptor for translated address
-;				d3.w =	result code
-;
-;	destroys:	d0-d1
-;----------------------------------------------------------------------------------
-tcEnable040	EQU		15						; MMU enable bit in TC on 68040
-UDTResident	EQU		1						; UDT resident bit in table descriptor
-PDTResident	EQU		1						; PDT field value for a resident page
-PDTIndirect	EQU		2						; PDT field value for an indirect page desc
-
-translate040
-			movem.l	transRegs,-(sp)			; save working registers
-			move.l	theSRP(a6),d1			; get root ptr in a2
-			move.w	theTC(a6),d0			; get a copy of the TC in d0
-			btst	#tcEnable040,d0			; check if MMU is on
-			bne.s	@startTranslate			; IF MMU is off THEN
-			move.l	d2,a0					;	return logical address unchanged	<SM0>
-			clr.l	d1						;	return null for page descriptor addr
-			moveq	#noErr,d3				;	return good status
-			bra.s	@xlatDone				;	>>EXIT with physical address
-											; ENDIF
-@startTranslate
-			clr.l	d4						; clear offset into logical address
-			clr.w	d3						; clear level counter
-			clr.l	d5						; get a clear longword
-			lea		levelOne(a6),a1			; init pointer to field widths
-;-----------------
-; a1.l = pointer to field width info
-; d1.l = current descriptor entry
-; d2.l = logical address to translate
-; d3.w = level counter
-; d4.l = offset into logical address of index field
-;-----------------
-@walkLoop									; LOOP (to walk 68040 table)
-			move.b	(a1)+,d5				;	get width of first index field
-			move.l	#(32-2),d0				;	get total bits in descriptor (table pointer/4)
-			sub.l	d5,d0					;	get number of significant bits in table ptr
-			bfextu	d1{0:d0},d1				;	get pointer to next table
-			lsl.l	d5,d1					;	almost make a base address out of it
-			lsl.l	#2,d1					;	make a base address out of it
-			bfextu	d2{d4:d5},d6			;	get index into next table
-			lsl.w	#2,d6					;	multiple index by four
-			add.l	d6,d1					;	get address of next descriptor
-			add.l	myPhys2Log(a6),d1		;	convert pointer to logical addr				<T3>
-			move.l	d1,a2					;	put into an address register
-			move.l	(a2),d1					;	get next descriptor
-			cmp.w	#2,d3					;	is this the third level
-			beq.s	@getPage				;	>>EXITLOOP if so
-			btst	#UDTResident,d1			;	is it resident?
-			beq.s	@paramErr				;	>>EXIT if not
-			add.l	d5,d4					;	update d4 to contain number of bytes decoded
-			add.w	#1,d3					;	bump level count
-			bra.s	@walkLoop				; ENDLOOP
-@getPage
-			move.b	d1,d0					; get a copy of the page descriptor
-			and.b	#3,d0					; isolate PDT field
-			cmp.b	#PDTResident,d0			; is this page resident?
-			beq.s	@residentPage			; IF it is not resident THEN
-			cmp.b	#PDTIndirect,d0			;	check for indirect pointer
-			bne.s	@paramErr				;	>>EXIT if invalid
-			and.l	#$fffffffc,d1			;	clear PDT field from indirect descriptor
-			add.l	myPhys2Log(a6),d1		;	convert pointer to logical addr				<T3>
-			move.l	d1,a2					;	get address of page descriptor
-			move.l	(a2),d1					;	get page descriptor
-@residentPage								; ENDIF			
-			add.l	d5,d4					; update d4 to contain number of bytes decoded	<t10> cch
-			move.l	#32,d5					; total number of bits in address
-			sub.l	d4,d5					; get number of bits not yet decoded
-			bfextu	d1{0:d4},d0				; get address of physical page
-			bfextu	d2{d4:d5},d6			; get offset into physical page
-			lsl.l	d5,d0					; make a base address out of it
-			add.l	d6,d0					; get physical address
-			move.l	d0,a0					; put address into a0
-			moveq	#noErr,d3				; return no error
-@xlatDone
-			movem.l	(sp)+,transRegs			; restore registers
-			rts
-
-@paramErr
-			move.w	#paramErr,d3
-			bra.s	@xlatDone
-
-
-;----------------------------------------------------------------------------------
-;	checkLimit	-	Checks an index against a limit for an 8-byte descriptor.
-;
-;	input:		d6.l =	index to be checked
-;				d7.l =	upper word of descriptor
-;
-;	output:		ccr.c set on invalid index
-;				ccr.c clear on valid index
-;
-;	destroys:	d7
-;----------------------------------------------------------------------------------
-
-checkLimit	swap	d7						; get limit into low word
-			btst	#15,d7					; check type of limit
-			bne.s	@lower					; IF it is an upper limit THEN
-			cmp.w	d6,d7					;	compare upper limit
-			bra.s	@limitExit				; ELSE
-@lower		and.w	#$7fff,d7				;	remove l/u bit
-			cmp.w	d7,d6					;	compare lower limit
-@limitExit									; ENDIF
-			rts	
-
-
 			ENDWITH
 			ENDP
 
@@ -602,9 +184,6 @@ ProtectRegsPPC	REG		d2-d4
 EDiskProtectPPC	PROC	EXPORT
 				WITH	GetRealVars
 
-				cmp.b	#EMMU1,MMUType			; check to see if we have a PowerPC MMU
-				bne		@paramErr				; >>EXIT if not
-
 				movem.l	ProtectRegsPPC,-(sp)	; save working registers
 
 ;——————————————————————————————————
@@ -641,124 +220,6 @@ EDiskProtectPPC	PROC	EXPORT
 				movem.l	(sp)+,ProtectRegsPPC	; restore working registers
 @return			rts
 				
-@paramErr		move.w	#paramErr,d0			; return paramErr
-				bra.s	@return
-				
-				ENDWITH
-
-				ENDP
-
-
-
-;----------------------------------------------------------------------------------
-;	EDiskProtect	-	Protects or unprotects the EDisk as specified.
-;
-;	NOTE:		This algorithm assumes that the Edisk space is the only space
-;				mapped by it's 1st level descriptor.
-;
-;	input:		d0.w =	HwPriv selector #8
-;				a0.l =	32-bit base address of EDisk
-;				a1.w =	flag to protect or unprotect Edisk (1=protect)
-;
-;	output:		a0.l =	pointer to the 1st-level table descriptor for the eDisk
-;				d0.w =	result code
-;
-;	destroys:	d1/a1
-;----------------------------------------------------------------------------------
-ProtectRegs		REG		d2-d4/a2
-
-EDiskProtect	PROC	EXPORT
-				IMPORT	GetMMUInfo
-				IMPORT	checkTTRegs
-				WITH	GetRealVars
-
-				cmp.b	#PMMU851,MMUType		; check to see if we have an MMU		<SM3>
-				blo		@bailNoMMU				; >>EXIT if not							<SM3>
-
-				movem.l	ProtectRegs,-(sp)		; save working registers
-				link	a6,#GetRealSize			; allocate some room for our locals
-
-;——————————————————————————————————
-; 68K EDisk Write Protect Code
-;——————————————————————————————————
-@noEMMU			move.l	a0,d2					; get base address of Edisk
-				move.w	a1,a2					; save protect flag in a2
-
-				Move	SR,D0					; Get and save the SR.					<T7>
-				Btst	#13,D0					; Are we in Supervisor mode?
-				Bne.s	@noVM					; Yes? Then don't call _EnterSupervisorMode.
-				_EnterSupervisorMode			; Must be in supervisor mode (SR returned in D0).
-@noVM	
-				move.w	d0,-(sp)				; save status register value			<T7>
-		IF Supports24Bit THEN
-				move.b	MMU32Bit,-(sp)			; save current MMU mode
-				bne.s	@in32BitMode			; IF we're in 24-bit mode THEN
-				moveq	#true32b,d0				;	we want to go to 32 bit addressing
-				_SwapMMUMode					;	switch the MMU mode
-				bra.s	@doTranslation			;	go do the translation
-@in32BitMode									; ELSE
-		ENDIF
-				jsr		checkTTRegs				;	check transparent translation regs
-				bne.s	@doTranslation			;	IF we matched a TT register THEN
-				move.l	d2,a0					;	  put the original address into a0
-				moveq	#paramErr,d3			;	  return bad status
-				bra.s	@cleanup				;	  >>EXIT with easy translation
-												;	ENDIF
-@doTranslation									; ENDIF											
-				jsr		GetMMUInfo				; set up globals						<T8>
-				clr.l	d0						; clear starting bit value
-				clr.l	d1						; clear bit field length
-				move.b	initShift(a6),d0		; get bit to start at, with initial shift, if any
-				move.b	levelOne(a6),d1			; get bit field length
-				bfextu	d2{d0:d1},d0			; get index into 1st-level table
-				lsl.l	#2,d0					; convert to a 4-byte entry pointer index
-				btst.b	#0,theCRP+3(a6)			; is this an 8-byte table?
-				beq.s	@is4Byte				; IF this is a 8-byte entry table THEN
-				lsl.l	#1,d0					;	convert to an 8-byte entry pointer index
-@is4Byte										; ENDIF
-				add.l	theSRP(a6),d0			; get the physical address of the 1st-level entry
-				add.l	myPhys2Log(a6),d0		; convert to a logical address
-				move.l	d0,a0					; save in a0
-				
-;------------
-; Change RAM disk protection
-;------------
-
-				move.w	#noErr,d3				; return good result if we get here.	<Z11><H2>
-				bset	#writeProtectBit,3(a0)	; set the write-protect bit
-				tst.w	a2						; check if protect flag is set
-				bne.s	@protect				; IF we want to unprotect THEN
-				bclr	#writeProtectBit,3(a0)	;	clear the write-protect bit
-@protect										; ENDIF
-				cmp.b	#cpu68040,CPUFlag		; check for processor type				<T7>
-				bne.s	@not040					; IF on a 68040 THEN
-				MACHINE	MC68040					;	
-				pflusha							;	flush the ATC regs
-				bra.s	@cleanup				; ELSE
-				MACHINE	MC68030					;
-@not040			jsr		([jCacheFlush])			;	flush caches since they're logical	<Z11><H2>
-				pflusha							;	flush the ATC regs
-												; ENDIF									<T7>
-
-;------------
-; d3.w = result code
-; a0.l = physical address if successful
-;------------
-@cleanup
-		IF Supports24Bit THEN
-				move.b	(sp)+,d0				; get original MMU mode
-				bne.s	@skipMMUSwap			; IF we were originally in 24-bit mode THEN
-				_SwapMMUMode					;	swap back to it
-@skipMMUSwap									; ENDIF
-		ENDIF
-				move.w	(sp)+,d0				; get status register value				<T7>
-				move	d0,sr					; restore status register				<T7>
-				move.w	d3,d0					; return result in d0
-@return			unlk	a6
-				movem.l	(sp)+,ProtectRegs		; restore working registers
-@bailNoMMU
-				rts
-				
 				ENDWITH
 ;———————————————————————————————————————————————————————————————————————
 ; That's all folks.
diff --git a/OS/MMU/MMU.a b/OS/MMU/MMU.a
--- a/OS/MMU/MMU.a
+++ b/OS/MMU/MMU.a
@@ -121,7 +121,7 @@
 			PRINT		OFF
 			LOAD		'StandardEqu.d'
 			INCLUDE		'HardwarePrivateEqu.a'
-			INCLUDE		'SoundPrivate.a'
+;			INCLUDE		'SoundPrivate.a'
 			INCLUDE		'MMUEqu.a'
 			INCLUDE		'BootEqu.a'
 			INCLUDE		'UniversalEqu.a'
@@ -129,7 +129,7 @@
 
 			MACHINE		MC68030
 MMUStuff	PROC
-			EXPORT		InitMMUGlobals, InitMMUTrap, MMUCleanupFor8Mb, SwitchMMU
+			EXPORT		InitMMUGlobals, InitMMUTrap, SwitchMMU
 			IMPORT		BaseOfROM, Critical, PramIO, RamTest
 			IMPORT		RomLoc
 
@@ -195,51 +195,14 @@ InitMMUGlobals
 @NoSwap		rts
 
 @swaps		dc.w	@NoSwap-@swaps		; No MMU: no swap routine!
-			dc.w	SwapHMMU-@swaps		; offset to HMMU swap routine
+			dc.w	@NoSwap-@swaps		; offset to HMMU swap routine
 			dc.w	@NoSwap-@swaps		; MMB not supported: no swap routine!
-			dc.w	Swap851-@swaps		; offset to 68851 PMMU swap routine
+			dc.w	@NoSwap-@swaps		; offset to 68851 PMMU swap routine
 			dc.w	Swap030-@swaps		; offset to 030 PMMU swap routine
-			dc.w	Swap040-@swaps		; offset to 040 PMMU swap routine			<T2>
+			dc.w	@NoSwap-@swaps		; offset to 040 PMMU swap routine			<T2>
 			dc.w	@NoSwap-@swaps		; future expansion
 			dc.w	@NoSwap-@swaps		; future expansion
 
-;----- <3.1>
-;	MMUCleanupFor8Mb - copies MMU info (tc, crp, tt0, tt1) to below BufPtr.
-;
-;	This is called on systems supporting 24 bit mode that have more than 8mb of RAM
-;	installed.  The MMU info must be at a place that can be accessed in 24 bit mode,
-;	since the Swap MMU code must access it!
-;
-;	Entry
-;		System is in 32 bit mode
-;		MMU24Info	(long) points to 24 bit mode MMU configuration info in BootGlobs
-;		MMU32Info	(long) points to 32 bit mode MMU configuration info in BootGlobs
-;	Exit
-;		MMU24Info	(long) points to 24 bit mode MMU configuration info below BufPtr
-;		MMU32Info	(long) points to 32 bit mode MMU configuration info below BufPtr
-;
-;	Trashes
-;		d0/a0-a2
-;---
-
-			WITH	MMUConfigInfo
-
-MMUCleanupFor8Mb
-			move.l	BufPtr,a0					; get top useable memory
-			suba.w	#2*MMUInfoSize,a0			; allocate space for config info
-			move.l	a0,BufPtr					; update top useable memory
-			lea		MMU32Info,a1				; point at ptr to 32 bit mode info
-			bsr.s	@doCopy						; copy it down
-			lea		MMU24Info,a1				; point at ptr to 32 bit mode info
-@doCopy		move.l	(a1),a2						; get ptr to info in BootGlobs
-			move.l	a0,(a1)						; update ptr w/new stuff below BufPtr
-			moveq	#MMUInfoSize-1,d0			; loop counter
-@copy		move.b	(a2)+,(a0)+					; copy next byte
-			dbra	d0,@copy					; repeat for all bytes
-			rts
-			
-			ENDWITH								; {MMUConfigInfo}
-
 ;-----
 ;   Swap32Only - null MMU swap, used when system has 32 bit addressing only
 ;
@@ -256,84 +219,6 @@ Swap32Only
 			rts
 
 
-;-----
-;   Swap851 - switches 68851 PMMU between 24 & 32 bit modes.
-;
-;   Entry
-;       d0.b	0 to set 24-bit mode, non-zero to set 32-bit mode.
-;
-;   Exit
-;		MMU32Bit	updated with passed value of d0
-;		d0.l		has previous value of MMU32Bit
-;		MMU is switched into the desired mode
-;
-;	Trashes:
-;		d1/a0/a1
-;---
-
-Swap851		move.b	d0,d1					; check what mode we are going to, set up d1
-			bne.s	@to32					; IF we want 24 bit mode
-			moveq	#0,d0					;   clear return register
-			move.b	MMU32bit,d0				;   see what mode we're in now
-			beq.s	@endif					;   IF in 32 bit mode now
-			move	sr,-(sp)				;     save current interrupt status
-			ori		#HiIntMask,sr			;     disable interrupts during switch
-			move.l	MMU24Info,a0			;     get ptr to 24 bit mode info
-			bra.s	@swap					;     go to common swap code
-											;   ENDIF
-@to32										; ELSE (we want 32 bit mode)
-			moveq	#0,d0					;   clear return register
-			move.b	MMU32bit,d0				;   see what mode we're in now
-			bne.s	@endif					;   IF in 24 bit mode
-			move	sr,-(sp)				;     save current interrupt status
-			ori		#HiIntMask,sr			;     disable interrupts during switch
-			move.l	MMU32Info,a0			;     get ptr to 32 bit mode info
-
-	IF forRomulator THEN					;	  Assume logical PC <> physical PC 				<3.7>
-
-@swap		moveq.l	#1,d0					;     unset zero flag								<3.7>
-			bra.s	@doSwap					;     go put PMOVE to TC into i-cache				<3.7>
-@inCache	moveq.l	#0,d0					;	  set zero flag									<3.7>
-			pmove	theCRP(a0),CRP			;	  set the root pointer							<3.7>
-			lea		theTC(a0),a1			;	  get address of TC								<3.7>
-			bra.s	@doSwap					;	  go swap modes from i-cache					<3.7>
-			
-											;	  NOTE: the following instructions are put		<3.7>
-											;	  . in the i-cache, thus the 4 byte instructions<3.7>
-											;	  . to be executed must start on odd word		<3.7>
-											;	  . boundaries so that they are put in on the	<3.7>
-			ALIGN	4						;	  . first pass through							<3.7>
-@doSwap		bne.s	@step					;     (2 bytes) if zero flag not set, skip pmove	<3.7>
-			pmove	theCRP(a0),TC			;     (4 bytes) disable the 851						<3.7>
-											;	  NOTE: the 851 must be disabled before			<3.7>
-											;	  . the TC can be changed.  The CRP always		<3.7>
-											;	  . has the high bit off, and can be used to	<3.7>
-											;	  . disable MMU.  Also note that "theCRP" is	<3.7>
-											;	  . zero, causing this instruction to be 4 bytes<3.7>
-@step		nop								;	  (2 bytes) force next inst to start on odd word<3.7>
-			bne.s	@chk					;     (2 bytes) if zero flag not set, skip pmove	<3.7>
-			pmove	(a1),TC					;     (4 bytes) fire up new TC, flush ATC			<3.7>
-@chk		beq.s	@swapped				;	  (2 bytes) if zero flag set, we're done		<3.7>
-			bra.s	@inCache
-@swapped									;													<3.7>
-
-	ELSE									;													<3.7>
-
-@swap		pmove	theCRP(a0),tc			;     disable the MMU so we can load a new TC value	<3.8>
-			pmove	theCRP(a0),crp			;     set crp
-@thePmove	pmove	theTC(a0),tc			;     fire up the TC
-
-	ENDIF
-			pflusha							;     clean out dirty ATC entries
-			move.b	d1,MMU32Bit				;     update global w/new mode flag
-			movec	cacr,d1					;     get cache control register
-			ori.w	#$0008,d1				;     set i-cache 'flush' bit
-			movec	d1,cacr					;     flush instruction caches
-			move	(sp)+,sr				;     restore interrupt mask
-											;   ENDIF
-@endif										; ENDIF
-			rts
-
 ;-----
 ;   Swap030 - switches 030 PMMU between 24 & 32 bit modes.
 ;
@@ -383,122 +268,6 @@ Swap030		move.b	d0,d1					; check what mode we are going to, set up d1
 			rts
 
 
-;-----
-;   Swap040 - switches 040 PMMU between 24 & 32 bit modes.									<7>
-;
-;   Entry
-;       d0.b	0 to set 24-bit mode, non-zero to set 32-bit mode.
-;
-;   Exit
-;		MMU32Bit	updated with passed value of d0
-;		d0.l		has previous value of MMU32Bit
-;		MMU is switched into the desired mode
-;
-;	Trashes:
-;		d1/a0
-;---
-
-			machine	mc68040
-
-Swap040		move.b	d0,d1					; check what mode we are going to, set up d1
-			bne.s	@to32					; IF we want 24 bit mode
-			moveq	#0,d0					;   clear return register
-			move.b	MMU32bit,d0				;   see what mode we're in now
-			beq.s	@endif					;   IF in 32 bit mode now
-			move.l	MMU24Info,a0			;     get ptr to 24 bit mode info
-			bra.s	@swap					;     go to common swap code
-											;   ENDIF
-@to32										; ELSE (we want 32 bit mode)
-			moveq	#0,d0					;   clear return register
-			move.b	MMU32bit,d0				;   see what mode we're in now
-			bne.s	@endif					;   IF in 24 bit mode
-			move.l	MMU32Info,a0			;     get ptr to 32 bit mode info
-@swap		move	sr,-(sp)				;     save current interrupt status				<T5>
-			ori		#HiIntMask,sr			;     disable interrupts during switch
-			move.b	d1,MMU32Bit				;     update global w/new mode flag	
-			move.l	theTT0(a0),d1			;	  get transparent translation reg 0 value
-			movec	d1,itt0					;	  load the instruction TT0 reg
-			movec	d1,dtt0					;	  load the data TT0 reg with the same value
-			move.l	theTT1(a0),d1			;	  get transparent translation reg 1 value
-			movec	d1,itt1					;	  load the instruction TT0 reg
-			movec	d1,dtt1					;	  load the data TT0 reg with the same value
-			move.l	theTC(a0),d1			;	  get the TC value in d1
-			move.l	theSRP(a0),a0			;	  get the SRP value in a0
-			movec	a0,SRP					;	  set the SRP with new pointer
-			movec	d1,TC					;	  set the TC with the new value
-			pflusha							;	  flush the ATC entries						<T6>
-			move	(sp)+,sr				;     restore interrupt mask
-											;   ENDIF
-@endif										; ENDIF
-			rts
-
-			machine	mc68030					; 
-
-;-----
-;   SwapHMMU - switches HMMU between 24 & 32 bit modes.
-;
-;	This routine has a fix for the problem of losing sound interrupts when switching
-;	MMU modes.  On HMMU Mac II's, a bit on Via2 portB switches the MMU mode.
-;	Unfortunately, hitting this bit clears the CB1 interrupt flag, which is 
-;	the ASC interrupt.
-;
-;	Since the interrupt handlers all call SwapMMUMode to switch into 24 bit mode
-;	before processing interrutps, an ASC interrupt that occurs after the
-;	original interrupt could be lost.
-;
-;	This routine reduces the window for losing ASC interrupts to the minimum
-;	possible, which is half an instruction.  After switching MMU modes,
-;	it checks the ASC's interrupt register, and if any interrupts are present
-;	(but lost because the CB1 flag was cleared), it OR's the interrupt register back
-;	to itself.  The ASC then generates a new interrupt.
-;
-;   Entry
-;       d0.b	0 to set 24-bit mode, non-zero to set 32-bit mode.
-;
-;   Exit
-;		MMU32Bit	updated with passed value of d0
-;		d0.l		has previous value of MMU32Bit
-;		MMU is switched into the desired mode
-;
-;	Trashes:
-;		d1/a0
-;---
-
-SwapHMMU	
-			move.b		d0,d1				; check what mode desired, save it
-			bne.s		@1					; IF we want 24 bit mode
-			moveq		#0,d0				;   clear return register
-			move.b		MMU32bit,d0			;   see what mode we're in now
-			beq.s		@3					;   IF in 32 bit mode now
-			move		sr,-(sp)			;     save current interrupt status
-			ori			#HiIntMask,sr		;     disable interrupts during switch
-			move.l		VIA2RBV,a0			;     get ptr to 2nd Via
-			bclr		#vFC3,vBufB(a0)		;     throw us into 24 bit mode
-			bra.s		@common				;     (re-use common code)
-@1											; ELSE (we want 32 bit mode)
-			moveq		#0,d0				;   clear return register
-			move.b		MMU32bit,d0			;   see (and return) what mode we're in now
-			bne.s		@3					;   IF in 24 bit mode now
-			move		sr,-(sp)			;     save current interrupt status
-			ori			#HiIntMask,sr		;     disable interrupts during switch
-			move.l		VIA2RBV,a0			;     get ptr to 2nd Via
-			bset		#vFC3,vBufB(a0)		;     throw us into 32 bit mode
-@common		move.b		d1,MMU32Bit			;     update global w/new mode flag
-			movec		cacr,d1				;     get cache control register
-			bset		#3,d1				;     set icache flush bit
-			movec		d1,cacr				;     flush da cache, Guido
-			move.l		ASCBase,a0			;     point to ASC
-			adda.w		#ascFifoInt,a0		;     point to ASC interrupt register
-			move.b		(a0),d1				;     get ASC interrupt register
-			beq.s		@2					;     IF ASC thinks interrupt is pending
-			or.b		d1,(a0)				;       re-generate interrupt to VIA's CB1
-@2											;     ENDIF
-			move		(sp)+,sr			;     restore interrupt mask
-											;   ENDIF
-@3											; ENDIF
-			rts
-
-
 ;---------------------------------------------------
 ;	MMU switch code, for Unix & Pink.
 ;
@@ -525,33 +294,6 @@ SwapHMMU
 
 SwitchMMU																					
 
-@TestCPU	sub.l	d0,d0					; D0 = 0
-			bset	#CACR_DE_040,d0			; set Data Cache Enable bit on 040s						<T22>
-			movec	d0,CACR					; attempt to enable data cache (temporarily)
-			movec	CACR,d0					; check and see if it's still there
-			btst	#CACR_DE_040,d0			; see if the bit exists in CACR							<T22>
-			beq.s	@isNot040							
-
-
-			MACHINE	MC68040					; IF we're on a 68040 THEN
-
-@is040		movec	CACR,d0					; retrieve cache control register
-			move.l	d0,d1					; save a copy for later restoration
-			sub.l	d0,d0					; clear D0 to disable caches (see diagram above)
-			movec	d0,CACR					; disable both caches
-			movec	d0,TC					; disable the ATC
-			pflusha							; flush ATC
-			movea.l	theCRP(a0),a2			; retrieve the new CRP (= URP on the 040) into D0
-			move.l	theTC(a0),d0			; retrieve the new TC into D0
-			movec	a2,URP					; set up the URP
-			movec	d0,TC					; ... and the TC
-			cpusha	bc						; flush both caches (dirty data only pushed out of
-											; the data cache.  inst. cache CPUSH = CINV)
-			movec	d1,cacr					; re-enable caches
-			bra.s	@allDone					
-											
-			MACHINE	MC68030					; ELSE we're on a 68030/68020					
-
 @isNot040	movec	cacr,d0					; get 020/030 cache control reg
 			move.w	d0,d1					; save it
 			andi	#$FEFE,d0				; clear cache enable bits
diff --git a/OS/MMU/MMU.make b/OS/MMU/MMU.make
--- a/OS/MMU/MMU.make
+++ b/OS/MMU/MMU.make
@@ -22,7 +22,6 @@ MMUObjs 		=					"{ObjDir}MMU.a.o"								∂
 
 "{ObjDir}MMU.a.o"				ƒ	"{ObjDir}StandardEqu.d"							∂
 									"{IntAIncludes}HardwarePrivateEqu.a"			∂
-									"{IntAIncludes}SoundPrivate.a"					∂
 									"{AIncludes}HardwareEqu.a"						∂
 									"{IntAIncludes}MMUEqu.a"						∂
 									"{IntAIncludes}BootEqu.a"						∂
diff --git a/OS/MMU/MMUTables.a b/OS/MMU/MMUTables.a
--- a/OS/MMU/MMUTables.a
+++ b/OS/MMU/MMUTables.a
@@ -238,7 +238,6 @@
 			MACHINE		MC68030
 MMUStuff	PROC
 			EXPORT		InitMMU
-			EXPORT		Trans
 			IMPORT		BaseOfROM, Critical, PramIO, RamTest
 			IMPORT		RomLoc
 			IMPORT		SizeSoundBuffer
@@ -267,16 +266,6 @@ MMUStuff	PROC
 ;	is set.
 ;---
 
-			MACRO
-&label		Setup 	&tc,&tt0,&tt1,&template,&special,&physical
-&label		dc.l	&tc
-			dc.l	&tt0
-			dc.l	&tt1
-			dc.w	&template-&label
-			dc.w	&special-&label
-			dc.w	&physical-&label
-			ENDM
-
 MMUSetupInfo	RECORD	0,INCR
 newtc			ds.l	1		; translation control register
 newtt0			ds.l	1		; transparent translation reg 0
@@ -289,44 +278,6 @@ size			equ		*		; size of each table entry
 			
 			WITH	MMUSetupInfo
 
-;								transp.	   transp      offset to	   offset to		 offset to
-;					   TC		xlat 0	   xlat 1      template	    special template physical template
-;					--------   ---------  ---------   -----------	---------------- ----------------
-contig24	Setup	$80F84500,	  0,	  0,		 template24,		0,				physNormal
-contig32	Setup	$80F05750, 	  0,	  0,		 template32,		void32,			physNormal
-split24		Setup	$80F84500, 	  0,	  0,		 template24,		0,				physNormal
-split1mb32	Setup	$80F05750, 	  0,	  0,		 template32,		void32,			physNormal
-split2mb32	Setup	$80F05660, 	  0,	  0,		 template32,		void32,			physNormal
-split4mb32	Setup	$80F05570, 	  0,	  0,		 template32,		void32,			physNormal
-split8mb32	Setup	$80F05480, 	  0,	  0,		 template32,		void32,			physNormal
-split16mb32	Setup	$80F08900, 	  0,	  0,		 template32,		void32,			physNormal
-split32mb32	Setup	$80F07A00, 	  0,	  0,		 template32,		void32,			physNormal
-split64mb32	Setup	$80F06B00, 	  0,	  0,		 template32,		void32,			physNormal
-Rbv24b		Setup	$80F84500, 	  0, 	  0,		 template24RBVb,	0,				physRBVb	; <11>
-Rbv32b		Setup	$80F05750, 	  0,	  0,		 Template32RBVb,	void32RBVb,		physRBVb	; <11>
-Rbv24e		Setup	$80F84500, 	  0, 	  0,		 template24RBVe,	0,				physRBVe	; <11>
-Rbv32e		Setup	$80F05750, 	  0,	  0,		 Template32RBVe,	void32RBVe,		physRBVe	; <11>
-orwell24	Setup		$C000,	  0,	  0,		 template24Orwell,	0,				physOrwell	; <T7>
-orwell32	Setup		$C000, $F900C060, $807FC040, Template32Orwell,	void32Orwell,	physOrwell	; <T20>
-Jaws24		Setup	$80F84500, 	  0, 	  0,		 template24Jaws,	0,				physLCD		; <9>
-Jaws32		Setup	$80F05750, 	  0,	  0,		 template32Jaws,	void32Jaws,		physLCD 	; <9>
-MSC24		Setup	$80D86500,    0,      0,		 template24MSC,		0,				physMSC		; <H23>
-MSC32		Setup	$80D07750, $600F8507, $807F8507, template32MSC,		void32MSC,		physMSC		; <H23>
-MSC24040	Setup		$C000,    0,      0,		 template24MSC040,	0,				physMSC		; <H23>
-MSC32040	Setup		$C000, $600FC060, $807FC060, template32MSC040,	void32MSC,		physMSC		; <H23>
-Niagra24	Setup	$80D86500,    0,      0,		 template24Niagra,	0,				physNiagra	; <H23>
-Niagra32	Setup	$80D07750, $600F8507, 0,		 template32Niagra,	void32Niagra,	physNiagra	; <H23>
-Sonora24	Setup	$80D86500,	  0, 	  0,		 template24Sonora,	0,				physSonora	; <H12>
-Sonora32	Setup	$80D07750, $600F8507, $807F8507, template32Sonora,	void32Sonora,	physSonora	; <H12>
-FstrFrms24	Setup	$80F84500,	  0,	  0,		 templateFF24,		0,				physFF		; <SM1> CSS <H18>
-FstrFrms32	Setup	$80F05750,	  0,  	  0,	     templateFF32,		0,				physFF		; <SM1> CSS <H18>
-YMCA24		Setup		$C000,	  0,	  0,		 template24YMCA,	0,				physYMCA		; <SM1> CSS <P4><LW2>
-YMCA32		Setup		$C000, $F900C060, $807FC040, Template32YMCA,	void32YMCA,		physYMCA		; <SM1> CSS <P4><LW2>
-SnraForty24	Setup		$C000,	  0, 	  0,		 template24SnraFrty,	0,				physSonora	; <H31><SM13>
-SnraForty32	Setup		$C000, $600FC060, $807FC040, template32SnraFrty,	void32Sonora,	physSonora	; <H31><SM13>
-Pratt24		Setup		$C000, 	   0,     0,		 template24Pratt,	0,				physPratt	; <SM14>
-Pratt32		Setup		$C000, $A01FC040, $600FC060, template32Pratt,	void32Pratt,	physPratt	; <SM14>
-
 ;-----
 ;	The template tables describe the logical to physical address mapping.  
 ;
@@ -540,417 +491,6 @@ physNflag	ds.l	1					;   suggested physical address, & flags		<7>
 tEntrySize	equ		*					;   size of a template entry
 			ENDR
 
-			MACRO
-&label		tp	 	&span,&physNflag
-&label		dc.l	&span
-			dc.l	&physNflag			; 											<7>
-			ENDM
-
-Template32	
-	tp	bRom32-bRam, isRAM										; RAM
-	tp	bEyeOh32-bRom32, isROM32								; ROM				<T23>
-	tp	bRamDisk-bEyeOh32, isThru+cInhibit						; i/o and/or video	<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk			<T23>
-	tp	bTop32Less1-(bRamDisk+EDskMaxSize)+1, isThru+cInhibit	; slots				<T23>
-
-Template32RBVb													; RBV in Slot B
-	tp	bRom32-bRam, isRAM										; RAM
-	tp	bEyeOh32-bRom32, isROM32								; ROM				<T23>
-	tp	bRamDisk-bEyeOh32, isThru+cInhibit						; i/o 				<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk			<T23>
-	tp	RBVWrap32b-(bRamDisk+EDskMaxSize), isThru+cInhibit		; slots				<T23>
-	tp	RBVBase32b-RBVWrap32b, isVidWrap						; wrap area			<11>
-	tp	RBVEnd32b-RBVBase32b, isVideo							; frame buffer area	<11>
-	tp	(bTop32Less1-RBVEnd32b)+1, isThru+cInhibit				; rest of slots		<11>
-
-Template32RBVe													; RBV in Slot E		<11>
-	tp	bRom32-bRam, isRAM										; RAM
-	tp	bEyeOh32-bRom32, isROM32								; ROM				<T23>
-	tp	bRamDisk-bEyeOh32, isThru+cInhibit						; i/o 				<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk			<T23>
-	tp	RBVWrap32e-(bRamDisk+EDskMaxSize), isThru+cInhibit		; slots				<T23>
-	tp	RBVBase32e-RBVWrap32e, isVidWrap						; wrap area
-	tp	RBVEnd32e-RBVBase32e, isVideo							; frame buffer area
-	tp	(bTop32Less1-RBVEnd32e)+1, isThru+cInhibit				; rest of slots
-
-Template32Orwell												;					<7>
-	tp	bRealRom32-bRam, isRAM+c040CopyBack						; RAM				<T20>
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32, isROM32+c040CopyBack; ROM				<T11><T15>
-	tp	bRealEyeOh32-(bRealRom32+ROMMaxSize), isVoid			; Invalid			<T23>
-	tp	bNonSerEyeOh-bRealEyeOh32, isThru+c040InhibitSer		; ser i/o				<T20>
-	tp	(bNonSerEyeOh+IOMaxSize)-bNonSerEyeOh, isThru+c040InhibitNonSer ; non-ser i/o	<T20>
-	tp	bRamDisk-(bNonSerEyeOh+IOMaxSize), isVoid				; Invalid			<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk+c040CopyBack	; Ram Disk			<T23>
-	tp	(bTop32Less1-(bRamDisk+EDskMaxSize))+1, isVoid			; slots (uses TTx regs)	<T23>
-
-Template32Jaws
-	tp	bRom32-bRam, isRAM										; RAM				<T20>
-	tp	bEyeOh32-bRom32, isROM32								; ROM				<T23>
-	tp	bRamDisk-bEyeOh32, isThru+cInhibit						; i/o 				<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk			<T23>
-	tp	LCDWrap32-(bRamDisk+EDskMaxSize), isThru+cInhibit		; slots				<T23>
-	tp	LCDBase32-LCDWrap32, isVidWrap							; wrap area
-	tp	LCDEnd32-LCDBase32, isVideoRAM							; frame buffer area
-	tp	(bTop32Less1-LCDEnd32)+1, isThru+cInhibit				; rest of slots
-
-Template32MSC													;					<t19>
-	tp	bRealRom32-bRam,					  isRAM+FullTbl		; RAM				<H23><SM13>
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32,	  isROM32+FullTbl	; ROM				<H23><SM13>
-	tp	bRealEyeOh32-(bRealRom32+ROMMaxSize), isVoid			; Invalid			<H23><SM13>
-	tp	b32VidBase-bRealEyeOh32,			  isThru+cInhibit	; i/o				<H23><SM13>
-	tp	bRamDisk-b32VidBase,				  isVoid			; video (uses TT0)	<H23><SM13>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk,	  isEdisk			; Ram Disk			<T23><SM13>
-	tp	bTop32Less1-(bRamDisk+EDskMaxSize)+1, isVoid			; slots (uses TT1)	<H23><SM13>
-
-Template32MSC040
-	tp	bRealRom32-bRam,					  isRAM+c040CopyBack	; RAM
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32,	  isROM32+c040CopyBack	; ROM
-	tp	bRealEyeOh32-(bRealRom32+ROMMaxSize), isVoid			; Invalid
-	tp	b32VidBase-bRealEyeOh32,			  isThru+c040InhibitSer	; i/o
-	tp	bRamDisk-b32VidBase,				  isVoid			; video (uses TT0)
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk,	  isEdisk			; Ram Disk
-	tp	bTop32Less1-(bRamDisk+EDskMaxSize)+1, isVoid			; slots (uses TT1)
-
-Template32SnraFrty												;					
-	tp	bRealRom32-bRam, 						isRAM+c040CopyBack		; RAM					<SM13>
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32, 	isROM32+c040CopyBack	; ROM					<SM13>	
-	tp	bRealEyeOh32-(bRealRom32+ROMMaxSize), 	isVoid					; Invalid				<SM13>
-	tp	bNonSerEyeOh-bRealEyeOh32,			  	isThru+c040InhibitSer	; ser i/o				<SM13>
-	tp	(bNonSerEyeOh+IOMaxSize)-bNonSerEyeOh,	isThru+c040InhibitNonSer; non-ser i/o			<SM13>
-	tp	(b32VidBase-$2000)-(bNonSerEyeOh+IOMaxSize), 	isVoid			; Invalid				<SM13>
-	tp	b32VidBase-(b32VidBase-$2000), 			isThru+c040InhibitSer	; CPU ID Register		<SM13>
-	tp	bRamDisk-b32VidBase, 					isVoid					; Video (uses TTx regs)	<SM13>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, 		isEdisk+c040CopyBack	; Ram Disk				<SM13>
-	tp	(bTop32Less1-(bRamDisk+EDskMaxSize))+1, isVoid					; slots (uses TTx regs) <SM13>
-
-Template32Sonora												;					<H10><H12>
-	tp	bRealRom32-bRam, isRAM+FullTbl							; RAM
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32,   isROM32+FullTbl	; ROM					<H15>
-	tp	bRealEyeOh32-(bRealRom32+ROMMaxSize), isVoid			; Invalid				<H15>
-	tp	b32VidBase-bRealEyeOh32,			  isThru+cInhibit	; I/O					<H23><SM13>
-	tp	bRamDisk-b32VidBase,				  isThru+cInhibit	; Video (uses TT0)		<H23><SM13>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk,	  isEdisk			; Ram Disk				<H15><SM13>
-	tp	bTop32Less1-(bRamDisk+EDskMaxSize)+1, isVoid			; slots (uses TT1)		<SM13>
-
-Template32Niagra												;					<SM12>
-	tp	bRealRom32-bRam, isRAM+FullTbl							; RAM				
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32, isROM32+FullTbl		; ROM				
-	tp	bRealEyeOh32-(bRealRom32+ROMMaxSize), isVoid			; Invalid			
-	tp	b32VidBase-bRealEyeOh32, isThru+cInhibit				; i/o				
-	tp	bRamDisk-b32VidBase, isVoid								; video (uses TT0)
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk
-	tp	b32SlotE-(bRamDisk+EDskMaxSize), isThru+cInhibit		; slots	thru E
-	tp	(b32SlotF-DeclRomSize)-b32SlotE, isThru+cInhibit		; slot E up to config ROM
-	tp	b32SlotF-(b32SlotF-DeclRomSize), bRealRom32+isMap+cInhibit ; slot E Config ROM
-	tp	bTop32Less1-b32SlotF+1, isThru+cInhibit					; slots
-
-Template32YMCA													; <SM1> CSS 		<P4><LW2>
-	tp	bRealRom32-bRam, isRAM+c040CopyBack						; RAM
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32, isROM32+c040CopyBack; ROM
-	tp	bVideo32-(bRealRom32+ROMMaxSize), isVoid				; Invalid				<P7>
-	tp  bVRAM32 -bVideo32, isThru+c040InhibitNonSer				; non-ser video I/O.	<P7>
-	tp	(bVRAM32+VRAMMaxSize)-bVRAM32, isThru+c040InhibitNonSer	; non-ser VRAM.  		<P7>
-	tp  bRealEyeOh32 -(bVRAM32+VRAMMaxSize), isVoid				; Invalid				<P7>
-	tp	bNonSerEyeOh-bRealEyeOh32, isThru+c040InhibitSer		; ser i/o
-	tp	(bNonSerEyeOh+IOMaxSize)-bNonSerEyeOh, isThru+c040InhibitNonSer ; non-ser i/o
-	tp	bRamDisk-(bNonSerEyeOh+IOMaxSize),  isVoid				; Invalid
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk+c040CopyBack	; Ram Disk
-	tp	(bTop32Less1-(bRamDisk+EDskMaxSize))+1, isVoid			; slots (uses TTx regs)
-
-Template32Pratt
-	tp	bRom32-bRam, 						isRAM+c040CopyBack			; RAM
-	
-; IMPORTANT! The following two lines contain the expression 2*ROMMaxSize so that we can overlay
-;  the emulation monitor for the HP 040 emulator into a valid address range.  For the final product,
-;  we don't need the factor of 2 (i.e. just use ROMMaxSize instead). <ged>  
-	tp	(bRom32+2*ROMMaxSize)-bRom32, 		isROM32+c040CopyBack		; ROM
-	tp	bEyeOh32-(bRom32+2*ROMMaxSize), 	isVoid						; Invalid
-
-	tp	bNonSerIO-bEyeOh32, 				isThru+c040InhibitSer		; ser i/o
-	tp	b32VidBase-bNonSerIO, 				isThru+c040InhibitNonSer 	; non-ser i/o
-	tp	bRamDisk-b32VidBase, 				isVoid						; Invalid
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, 	isEdisk+c040CopyBack		; Ram Disk
-	tp	b32SlotA-(bRamDisk+EDskMaxSize),	isVoid						; Invalid
-	tp	b32SlotC-b32SlotA,					isThru+c040InhibitSer		; Minor slot spaces A and B
-	tp	b32SlotE-b32SlotC, 					isVoid						; Invalid
-	tp	(b32SlotF-DeclRomSz)-b32SlotE, 		isThru+c040InhibitSer 		; map beginning of slot E thru
-	tp	b32SlotF-(b32SlotF-DeclRomSz), 		($402e0000-DeclRomSz)+isMap+c040InhibitSer; slot E Config ROM
-	tp	bTop32Less1-b32SlotF+1, 			isVoid						; slot f not used
-
-Template24	
-	tp	bRom24-bRam, isRAM										; RAM
-	tp	b24Slot9-bRom24, isROM24								; ROM
-	tp	b24SlotA-b24Slot9, b32Slot9+isMap+cInhibit				; minor slot 9		<7>
-	tp	b24SlotB-b24SlotA, b32SlotA+isMap+cInhibit				; minor slot A		<7>
-	tp	b24SlotC-b24SlotB, b32SlotB+isMap+cInhibit				; minor slot B		<7>
-	tp	b24SlotD-b24SlotC, b32SlotC+isMap+cInhibit				; minor slot C		<7>
-	tp	b24SlotE-b24SlotD, b32SlotD+isMap+cInhibit				; minor slot D		<7>
-	tp	bEyeOh24-b24SlotE, b32SlotE+isMap+cInhibit				; minor slot E		<7>
-	tp	(bTop24Less1-bEyeOh24)+1, bEyeOh32+isMap+cInhibit		; i/o				<7>
-
-Template24RBVb													; RBV in Slot B		<11>
-	tp	bRom24-bRam, isRAM										; RAM
-	tp	b24Slot9-bRom24, isROM24								; ROM
-	tp	b24SlotA-b24Slot9, b32Slot9+isMap+cInhibit				; minor slot 9		<7>
-	tp	RBVWrap24b-b24SlotA, b32SlotA+isMap+cInhibit			; minor slot A		<7><11>
-	tp	RBVBase24b-RBVWrap24b, isVidWrap						; wrap area			   <11>
-	tp	RBVEnd24b-RBVBase24b, isVideo							; frame buffer area	   <11>
-	tp	b24SlotD-RBVEnd24b, b32SlotC+isMap+cInhibit				; minor slot C		<7><11>
-	tp	b24SlotE-b24SlotD, b32SlotD+isMap+cInhibit				; minor slot D		<7>
-	tp	bEyeOh24-b24SlotE, b32SlotE+isMap+cInhibit				; minor slot E		<7>
-	tp	bTop24Less1-bEyeOh24+1, bEyeOh32+isMap+cInhibit			; i/o				<7>
-
-Template24RBVe													;					<11>
-	tp	bRom24-bRam, isRAM										; RAM
-	tp	b24Slot9-bRom24, isROM24								; ROM
-	tp	b24SlotA-b24Slot9, b32Slot9+isMap+cInhibit				; minor slot 9
-	tp	b24SlotB-b24SlotA, b32SlotA+isMap+cInhibit				; minor slot A
-	tp	b24SlotC-b24SlotB, b32SlotB+isMap+cInhibit				; minor slot B
-	tp	b24SlotD-b24SlotC, b32SlotC+isMap+cInhibit				; minor slot C
-	tp	RBVWrap24e-b24SlotD, b32SlotD+isMap+cInhibit			; minor slot D
-	tp	RBVBase24e-RBVWrap24e, isVidWrap						; wrap area
-	tp	RBVEnd24e-RBVBase24e, isVideo							; frame buffer area	
-	tp	bEyeOh24-RBVEnd24e, isVoid								; invalid
-	tp	bTop24Less1-bEyeOh24+1, bEyeOh32+isMap+cInhibit			; i/o
-
-Template24Orwell												;					<7>
-	tp	bRom24-bRam, isRAM+c040CopyBack							; RAM				<16><T15>
-	tp	b24Slot9-bRom24, isROM24+c040CopyBack					; ROM				<16><T15>
-	tp	b24SlotA-b24Slot9, b32Slot9+isMap+c040InhibitNonSer		; minor slot 9		<16><T20>
-	tp	b24SlotB-b24SlotA, b32SlotA+isMap+c040InhibitSer		; minor slot A		<16>
-	tp	b24SlotC-b24SlotB, b32SlotB+isMap+c040InhibitSer		; minor slot B		<16>
-	tp	b24SlotD-b24SlotC, b32SlotC+isMap+c040InhibitSer		; minor slot C		<16>
-	tp	b24SlotE-b24SlotD, b32SlotD+isMap+c040InhibitSer		; minor slot D		<16>
-	tp	bEyeOh24-b24SlotE, b32SlotE+isMap+c040InhibitSer		; minor slot E		<16>
-	tp	IOMaxSize,bRealEyeOh32+isMap+c040InhibitSer				; serialized i/o	<T20>
-	tp	IOMaxSize,bNonSerEyeOh+isMap+c040InhibitNonSer			; nonserialized i/o <T20>
-	tp	bTop24Less1-(bEyeOh24+(2*IOMaxSize))+1, isVoid			; void				<T20>
-	tp	bTop32Less1-bTop24Less1+1, isWrap24						; 24-bit wrap area	<T20>
-
-Template24Jaws													;					<9>
-	tp	bRom24-bRam, isRAM										; RAM
-	tp	b24Slot9-bRom24, isROM24								; ROM				<13>
-	tp	LCDWrap24-b24Slot9, isVoid								; invalid			<13><T16>
-	tp	LCDBase24-LCDWrap24, isVidWrap							; wrap area
-	tp	LCDEnd24-LCDBase24, isVideoRAM							; frame buffer area
-	tp	bEyeOh24-LCDEnd24, isVoid								; invalid
-	tp	bTop24Less1-bEyeOh24+1, bEyeOh32+isMap+cInhibit			; i/o
-
-Template24MSC													;					<t19>
-	tp	bRom24-bRam,	   isRAM+FullTbl						; RAM				<H23><SM13>
-	tp	b24Slot9-bRom24,   isROM24+FullTbl						; ROM				<H23><SM13>
-	tp	b24SlotA-b24Slot9, b32Slot9+isMap+cInhibit				; minor slot 9		<H14>
-	tp	b24SlotB-b24SlotA, b32SlotA+isMap+cInhibit				; minor slot A		<H14>
-	tp	b24SlotC-b24SlotB, b32SlotB+isMap+cInhibit				; minor slot B		<H14>
-	tp	b24SlotD-b24SlotC, b32SlotC+isMap+cInhibit				; minor slot C		<H13>
-	tp	b24SlotE-b24SlotD, b32SlotD+isMap+cInhibit				; minor slot D		<H13>
-	tp	bEyeOh24-b24SlotE, b32SlotE+isMap+cInhibit				; minor slot E
-	tp	bTop24Less1-bEyeOh24+1,	bRealEyeOh32+isMap+cInhibit		; i/o				<H23><SM13>
-
-Template24MSC040													;						<H35>
-	tp	bRom24-bRam,			isRAM+c040CopyBack						; RAM				<H35>
-	tp	b24Slot9-bRom24,		isROM24+c040CopyBack					; ROM				<H36>
-	tp	b24SlotA-b24Slot9,		b32Slot9+isMap+c040InhibitSer			; minor slot 9		<H36>
-	tp	b24SlotB-b24SlotA,		b32SlotA+isMap+c040InhibitSer			; minor slot A		<H35>
-	tp	b24SlotC-b24SlotB,		b32SlotB+isMap+c040InhibitSer			; minor slot B		<H35>
-	tp	b24SlotD-b24SlotC,		b32SlotC+isMap+c040InhibitSer			; minor slot C		<H35>
-	tp	b24SlotE-b24SlotD,		b32SlotD+isMap+c040InhibitSer			; minor slot D		<H35>
-	tp	bEyeOh24-b24SlotE,		b32SlotE+isMap+c040InhibitSer			; minor slot E		<H35>
-	tp	bTop24Less1-bEyeOh24+1,	bRealEyeOh32+isMap+c040InhibitSer		; i/o				<H35>
-	tp	bTop32Less1-bTop24Less1+1, isWrap24						; 24-bit wrap area			<H35 End>
-
-Template24Niagra												;					<SM12>
-	tp	bRom24-bRam, isRAM+FullTbl								; RAM
-	tp	b24Slot9-bRom24, isROM24+FullTbl						; ROM
-	tp	b24SlotC-b24Slot9, isVoid								; invalid
-	tp	b24SlotD-b24SlotC, b32SlotC+isMap+cInhibit				; minor slot C
-	tp	b24SlotE-b24SlotD, b32SlotD+isMap+cInhibit				; minor slot D
-	tp	bEyeOh24-b24SlotE, b32SlotE+isMap+cInhibit				; minor slot E
-	tp	bTop24Less1-bEyeOh24+1, bRealEyeOh32+isMap+cInhibit		; i/o
-
-Template24SnraFrty												;					<SM13>
-	tp	bRom24-bRam, isRAM+c040CopyBack							; RAM				<SM13>
-	tp	b24Slot9-bRom24, isROM24+c040CopyBack					; ROM				<SM13>
-	tp	b24SlotA-b24Slot9, b32Slot9+isMap+c040InhibitSer		; minor slot 9		<SM13>
-	tp	b24SlotB-b24SlotA, b32SlotA+isMap+c040InhibitSer		; minor slot A		<SM13>
-	tp	b24SlotC-b24SlotB, $60B00000+isMap+c040InhibitNonSer	; Video RAM			<SM13>
-	tp	b24SlotD-b24SlotC, b32SlotC+isMap+c040InhibitSer		; minor slot C		<SM13>
-	tp	b24SlotE-b24SlotD, b32SlotD+isMap+c040InhibitSer		; minor slot D		<SM13>
-	tp	bEyeOh24-b24SlotE, b32SlotE+isMap+c040InhibitSer		; minor slot E		<SM13>
-	tp	b24DblX-bEyeOh24, bRealEyeOh32+isMap+c040InhibitSer		; i/o				<SM13>	
-	tp	(bTop24Less1-b24DblX)+1, $FEE00000+isMap+c040InhibitSer	; Double X slot space <SM13>
-	tp	bTop32Less1-bTop24Less1+1, isWrap24						; 24-bit wrap area	<SM13>
-
-Template24Sonora
-	tp	bRom24-bRam, isRAM+FullTbl								; RAM				<H12>
-	tp	b24Slot9-bRom24, isROM24+FullTbl						; ROM				<H15><H16>
-	tp	b24SlotA-b24Slot9, b32Slot9+isMap+cInhibit				; minor slot 9
-	tp	b24SlotB-b24SlotA, b32SlotA+isMap+cInhibit				; minor slot A
-	tp	b24SlotC-b24SlotB, $60B00000+isMap+cInhibit				; Video RAM			<H12><H15>
-	tp	b24SlotD-b24SlotC, b32SlotC+isMap+cInhibit				; minor slot C
-	tp	b24SlotE-b24SlotD, b32SlotD+isMap+cInhibit				; minor slot D
-	tp	bEyeOh24-b24SlotE, b32SlotE+isMap+cInhibit				; minor slot E
-	tp	b24DblX-bEyeOh24, bRealEyeOh32+isMap+cInhibit			; i/o				<H10>
-	tp	(bTop24Less1-b24DblX)+1, b24SlotE+isMap+cInhibit		; Double X slot space<H10>
-
-Template24YMCA													;<SM1> 				<P4><LW2>
-	tp	bRom24-bRam, isRAM+c040CopyBack							; RAM
-	tp	b24Slot9-bRom24, isROM24+c040CopyBack					; ROM
-	tp	b24SlotA-b24Slot9, $40900000 + isMap					; Slot 9 is 2nd meg of ROM.	<P5>
-	tp	b24SlotB-b24SlotA, b32SlotA+isMap+c040InhibitSer		; minor slot A		<P8>
-	tp	b24SlotC-b24SlotB, b32SlotB+isMap+c040InhibitSer		; minor slot B		<P8>
-	tp	b24SlotD-b24SlotC, b32SlotC+isMap+c040InhibitSer		; minor slot C
-	tp	b24SlotE-b24SlotD, b32SlotD+isMap+c040InhibitSer		; minor slot D
-	tp	bEyeOh24-b24SlotE, b32SlotE+isMap+c040InhibitSer		; minor slot E
-	tp	IOMaxSize,bRealEyeOh32+isMap+c040InhibitSer				; serialized i/o
-	tp	IOMaxSize,bNonSerEyeOh+isMap+c040InhibitNonSer			; nonserialized i/o
-	tp	bTop24Less1-(bEyeOh24+(2*IOMaxSize))+1, isVoid			; void
-	tp	bTop32Less1-bTop24Less1+1, isWrap24						; 24-bit wrap area
-
-Template24Pratt													;					<SM14>
-	tp	bRom24-bRam, isRAM+c040CopyBack							; RAM
-	tp	b24Slot9-bRom24, isROM24+c040CopyBack					; ROM
-	tp	b24SlotA-b24Slot9, isVoid								; invalid
-	tp	b24SlotC-b24SlotA, b32SlotC+isMap+c040InhibitSer		; minor slots A-B
-	tp	b24SlotE-b24SlotC, isVoid								; minor slots C-D
-	tp	bEyeOh24-b24SlotE, b32SlotE+isMap+c040InhibitSer		; minor slot E
-	tp	bTop24Less1-bEyeOh24+1, bRealEyeOh32+isMap+c040InhibitSer	; i/o
-
-Void32		
-	tp	HoleLowMem-bRam, isRAM									; low memory: RAM
-	tp	HoleSysHeap - HoleLowMem, isVoid						; black hole
-	tp	bRom32 - HoleSysHeap, isRAM								; RAM
-	tp	bEyeOh32-bRom32, isROM32								; ROM				<T23>
-	tp	bRamDisk-bEyeOh32, isThru+cInhibit						; i/o				<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk			<T23>
-	tp	bTop32Less1-(bRamDisk+EDskMaxSize)+1, isThru+cInhibit	; slots				<T23>
-
-Void32RBVb
-	tp	HoleLowMem-bRam, isRAM									; low memory: RAM
-	tp	HoleSysHeap - HoleLowMem, isVoid						; black hole
-	tp	bRom32 - HoleSysHeap, isRAM								; RAM
-	tp	bEyeOh32-bRom32, isROM32								; ROM				<T23>
-	tp	bRamDisk-bEyeOh32, isThru+cInhibit						; i/o 				<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk			<T23>
-	tp	RBVWrap32b-(bRamDisk+EDskMaxSize), isThru+cInhibit		; slots				<T23>
-	tp	RBVBase32b-RBVWrap32b, isVidWrap						; wrap area		
-	tp	RBVEnd32b-RBVBase32b, isVideo							; frame buffer area
-	tp	(bTop32Less1-RBVEnd32b)+1, isThru+cInhibit				; rest of slots
-
-Void32RBVe
-	tp	HoleLowMem-bRam, isRAM									; low memory: RAM
-	tp	HoleSysHeap - HoleLowMem, isVoid						; black hole
-	tp	bRom32 - HoleSysHeap, isRAM								; RAM
-	tp	bEyeOh32-bRom32, isROM32								; ROM				<T23>
-	tp	bRamDisk-bEyeOh32, isThru+cInhibit						; i/o 				<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk			<T23>
-	tp	RBVWrap32e-(bRamDisk+EDskMaxSize), isThru+cInhibit		; slots				<T23>
-	tp	RBVBase32e-RBVWrap32e, isVidWrap						; wrap area
-	tp	RBVEnd32e-RBVBase32e, isVideo							; frame buffer area
-	tp	bTop32Less1-RBVEnd32e+1, isThru+cInhibit				; rest of slots
-
-Void32Orwell													;					<T23>
-	tp	HoleLowMem-bRam, isRAM+c040CopyBack						; low memory: RAM		
-	tp	HoleSysHeap - HoleLowMem, isVoid						; black hole
-	tp	bRealRom32-HoleSysHeap, isRAM+c040CopyBack				; RAM		
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32, isROM32+c040CopyBack; ROM					
-	tp	bRealEyeOh32-(bRealRom32+ROMMaxSize), isVoid			; Invalid				<T23>
-	tp	bNonSerEyeOh-bRealEyeOh32, isThru+c040InhibitSer		; ser i/o				<T23>
-	tp	(bNonSerEyeOh+IOMaxSize)-bNonSerEyeOh, isThru+c040InhibitNonSer ; non-ser i/o	<T23>
-	tp	bRamDisk-(bNonSerEyeOh+IOMaxSize), isVoid				; Invalid				<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk+c040CopyBack	; Ram Disk				<T23>
-	tp	(bTop32Less1-(bRamDisk+EDskMaxSize))+1, isVoid			; slots (uses TTx regs)	<T23>
-
-Void32Jaws														;					<9>
-	tp	HoleLowMem-bRam, isRAM									; low memory: RAM
-	tp	HoleSysHeap - HoleLowMem, isVoid						; black hole
-	tp	bRom32 - HoleSysHeap, isRAM								; RAM
-	tp	bEyeOh32-bRom32, isROM32								; ROM				<T23>
-	tp	bRamDisk-bEyeOh32, isThru+cInhibit						; i/o 				<T23>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk			<T23>
-	tp	LCDWrap32-(bRamDisk+EDskMaxSize), isThru+cInhibit		; slots				<T23>
-	tp	LCDBase32-LCDWrap32, isVidWrap							; wrap area
-	tp	LCDEnd32-LCDBase32, isVideo								; frame buffer area
-	tp	bTop32Less1-LCDEnd32+1, isThru+cInhibit					; rest of slots
-
-Void32MSC														;					<t19>
-	tp	HoleLowMem-bRam,					  isRAM+FullTbl		; low memory: RAM	<H23><SM13>
-	tp	HoleSysHeap - HoleLowMem,			  isVoid			; black hole
-	tp	bRealRom32 - HoleSysHeap,			  isRAM+FullTbl		; RAM				<H23><SM13>
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32,	  isROM32			; ROM				<H23><SM13>
-	tp	b32VidBase-(bRealRom32+ROMMaxSize),	  isThru+cInhibit	; i/o				<H23><SM13>
-	tp	bRamDisk-b32VidBase,				  isVoid			; video (uses TT0)	<H23><SM13>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk,	  isEdisk			; Ram Disk			<T23><SM13>
-	tp	bTop32Less1-(bRamDisk+EDskMaxSize)+1, isVoid			; slots (uses TT1)	<H23><SM13>
-
-Void32Sonora													; 					<H10><H12>
-	tp	HoleLowMem-bRam, isRAM+FullTbl							; low memory: RAM		
-	tp	HoleSysHeap - HoleLowMem, isVoid						; black hole
-	tp	bRealRom32-HoleSysHeap, isRAM+FullTbl					; RAM		
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32, isROM32				; ROM
-	tp	b32VidBase-(bRealRom32+ROMMaxSize),	  isThru+cInhibit	; I/O					<H23><SM13>
-	tp	bRamDisk-b32VidBase,				  isVoid			; Video (uses TT0)		<H23><SM13>
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk				<H15>
-	tp	(bTop32Less1-(bRamDisk+EDskMaxSize))+1, isVoid			; slots (uses TTx regs)
-
-Void32Niagra													;					<SM12>
-	tp	HoleLowMem-bRam, isRAM+FullTbl							; low memory: RAM
-	tp	HoleSysHeap - HoleLowMem, isVoid						; black hole
-	tp	bRealRom32 - HoleSysHeap, isRAM+FullTbl					; RAM
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32, isROM32				; ROM
-	tp	b32VidBase-(bRealRom32+ROMMaxSize), isThru+cInhibit		; i/o
-	tp	bRamDisk-b32VidBase, isVoid								; video (uses TT0)
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk				; Ram Disk
-	tp	b32SlotE-(bRamDisk+EDskMaxSize), isThru+cInhibit		; slots	thru E
-	tp	(b32SlotF-DeclRomSize)-b32SlotE, isThru+cInhibit		; slot E up to config ROM
-	tp	b32SlotF-(b32SlotF-DeclRomSize), bRealRom32+isMap+cInhibit; slot E Config ROM
-	tp	bTop32Less1-b32SlotF+1, isThru+cInhibit					; slots
-
-TemplateFF24													; <SM1> CSS
-	tp	FFbShadow-bRam,			isRAM							; RAM							<H18><SM13>
-	tp	FFtRom24-FFbShadow,		isThru							; ROM							<H22><SM13>
-	tp	t24SlotE-FFtRom24,		b32SlotE+isMap+cInhibit			; Slot E						<SM13>	
-	tp	FFtEyeOh24-t24SlotE,	isThru+cInhibit					; I/O space						<SM13>
-	tp  FFtDblxSlot24-FFtEyeOh24,	b24SlotE+isMap+cInhibit		; Slot E (64k), for DblX		<H22><SM13>
-	tp	bTop24Less1-FFtDblxSlot24+1, isThru+cInhibit			; rest of I/O space				<H22><SM13>
-	
-TemplateFF32
-	tp	FFbShadow-bRam,						  isRAM				; RAM							<SM13>
-	tp 	FFtShadow-FFbShadow,				  isThru			; Shadowed area					<SM13>
-	tp	FFbRom32-FFtShadow,					  isRAM				; RAM							<SM13>
-	tp	FFtRom32-FFbRom32,					  FFbRom24+isMap	; ROM							<H22><SM13>
-	tp	FFbEyeOh32-FFtRom32,				  isVoid			; unmapped space				<SM13>
-	tp	FFtEyeOh32-FFbEyeOh32,				  bEyeOh24+isMap+cInhibit	; I/O space				<SM13>
-	tp	FFtDblXSlot32-FFtEyeOh32,			  b24SlotE+isMap+cInhibit	; Slot E (64k), for DblX <SM13>
-	tp	bRAMDisk-FFtDblXSlot32,				  isThru+cInhibit	; bank switch reg in here		<H22><SM13>
-	tp	bRamDisk+EDskMaxSize-bRamDisk,		  isEdisk			; Ram Disk						<H22><SM13>
-	tp	bTop32Less1-(bRamDisk+EDskMaxSize)+1, isThru+cInhibit	; Rest of slot space			<H22><SM13>
-	
-Void32YMCA														; <SM1> CSS 		<P4><LW2>
-	tp	HoleLowMem-bRam, isRAM+c040CopyBack						; low memory: RAM		
-	tp	HoleSysHeap - HoleLowMem, isVoid						; black hole
-	tp	bRealRom32-HoleSysHeap, isRAM+c040CopyBack				; RAM		
-	tp	(bRealRom32+ROMMaxSize)-bRealRom32, isROM32+c040CopyBack; ROM					
-	tp	bRealEyeOh32-(bRealRom32+ROMMaxSize), isVoid			; Invalid
-	tp	bNonSerEyeOh-bRealEyeOh32, isThru+c040InhibitSer		; ser i/o
-	tp	(bNonSerEyeOh+IOMaxSize)-bNonSerEyeOh, isThru+c040InhibitNonSer ; non-ser i/o
-	tp	bRamDisk-(bNonSerEyeOh+IOMaxSize),  isVoid				; Invalid
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk+c040CopyBack	; Ram Disk
-	tp	(bTop32Less1-(bRamDisk+EDskMaxSize))+1, isVoid			; slots (uses TTx regs)
-
-Void32Pratt														;					<SM14>
-	tp	HoleLowMem-bRam, isRAM+c040CopyBack						; low memory: RAM
-	tp	HoleSysHeap - HoleLowMem, isVoid						; black hole
-	tp	bRom32 - HoleSysHeap, isRAM+c040CopyBack				; RAM
-	tp	(bRom32+ROMMaxSize)-bRom32, isROM32						; ROM
-	tp	b32VidBase-(bRom32+ROMMaxSize), isThru+c040InhibitSer	; i/o
-	tp	bRamDisk-b32VidBase, isVoid								; video (uses TT0)
-	tp	(bRamDisk+EDskMaxSize)-bRamDisk, isEdisk+c040CopyBack	; Ram Disk
-	tp	b32SlotE-(bRamDisk+EDskMaxSize), isThru+c040InhibitSer	; slots	thru E
-	tp	(b32SlotF-DeclRomSize)-b32SlotE, isThru+c040InhibitSer	; slot E up to config ROM
-	tp	b32SlotF-(b32SlotF-DeclRomSize), bRom32+c040InhibitSer	; slot E Config ROM
-	tp	bTop32Less1-b32SlotF+1, isThru+c040InhibitSer			; slots
-
 ;-----
 ;	The physical template tables describe the significant sections of the pysical address space.
 ;	These templates are used ONLY to generate the 'physical table', which is passed to VM and 
@@ -1018,750 +558,6 @@ firstEntry			DS.B	PhysicalSpaceBlock	; first in variable-sized table
 
   					ENDIF
 			
-physNormal	dc.w	kUsageRAM, cacheable
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable
-			dc.l	$40000000, $10000000
-			dc.l	$40000000, $10000000
-			dc.l	$00800000, $00100000				; <SM13>
-
-			dc.w	kUsageIO, notCacheable
-			dc.l	$50000000, $10000000
-			dc.l	$50000000, $10000000
-			dc.l	$00F00000, $00100000
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$60000000, $10000000
-			dc.l	$60000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$90000000, $10000000
-			dc.l	$90000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$A0000000, $10000000
-			dc.l	$A0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$B0000000, $10000000
-			dc.l	$B0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$C0000000, $10000000
-			dc.l	$C0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$D0000000, $10000000
-			dc.l	$D0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$E0000000, $10000000
-			dc.l	$E0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$F9000000, $01000000
-			dc.l	$F9000000, $01000000
-			dc.l	$00900000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FA000000, $01000000
-			dc.l	$FA000000, $01000000
-			dc.l	$00A00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FB000000, $01000000
-			dc.l	$FB000000, $01000000
-			dc.l	$00B00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FC000000, $01000000
-			dc.l	$FC000000, $01000000
-			dc.l	$00C00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FD000000, $01000000
-			dc.l	$FD000000, $01000000
-			dc.l	$00D00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FE000000, $01000000
-			dc.l	$FE000000, $01000000
-			dc.l	$00E00000, $00100000
-			
-			dc.w	kUsageEndTable
-			
-;---
-;	Max size of buffer for physical table = size of above fized stuff, plus entries for
-;	max # of RAM chunks, plus video and video wrapping space, plus bootglobals space		<3.2>
-;	plus a few more just to be safe.														<3.2>
-;---
-
-physBufSize	equ		*-physNormal + (sgMaxChunks+6) * PhysicalSpaceBlock.size	 			 ; <SM6> CSS			;<3.2>
-		
-
-;---
-;	Physical table for RBV in Slot B														<9>
-;---
-
-physRBVb	dc.w	kUsageRAM, cacheable
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable
-			dc.l	$40000000, $10000000
-			dc.l	$40000000, $10000000
-			dc.l	$00800000, $00100000
-
-			dc.w	kUsageIO, notCacheable
-			dc.l	$50000000, $10000000
-			dc.l	$50000000, $10000000
-			dc.l	$00F00000, $00100000
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$90000000, $10000000
-			dc.l	$90000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$A0000000, $10000000
-			dc.l	$A0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$C0000000, $10000000
-			dc.l	$C0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$D0000000, $10000000
-			dc.l	$D0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$E0000000, $10000000
-			dc.l	$E0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$F9000000, $01000000
-			dc.l	$F9000000, $01000000
-			dc.l	$00900000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FA000000, $01000000
-			dc.l	$FA000000, $01000000
-			dc.l	$00A00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FC000000, $01000000
-			dc.l	$FC000000, $01000000
-			dc.l	$00C00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FD000000, $01000000
-			dc.l	$FD000000, $01000000
-			dc.l	$00D00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FE000000, $01000000
-			dc.l	$FE000000, $01000000
-			dc.l	$00E00000, $00100000
-
-			dc.w	kUsageEndTable
-
-
-;---
-;	Physical table for RBV in Slot E														<11>
-;---
-
-physRBVe	dc.w	kUsageRAM, cacheable
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable
-			dc.l	$40000000, $10000000
-			dc.l	$40000000, $10000000
-			dc.l	$00800000, $00100000
-
-			dc.w	kUsageIO, notCacheable
-			dc.l	$50000000, $10000000
-			dc.l	$50000000, $10000000
-			dc.l	$00F00000, $00100000
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$90000000, $10000000
-			dc.l	$90000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$A0000000, $10000000
-			dc.l	$A0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$B0000000, $10000000
-			dc.l	$B0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$C0000000, $10000000
-			dc.l	$C0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$D0000000, $10000000
-			dc.l	$D0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$F9000000, $01000000
-			dc.l	$F9000000, $01000000
-			dc.l	$00900000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FA000000, $01000000
-			dc.l	$FA000000, $01000000
-			dc.l	$00A00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FB000000, $01000000
-			dc.l	$FB000000, $01000000
-			dc.l	$00B00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FC000000, $01000000
-			dc.l	$FC000000, $01000000
-			dc.l	$00C00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FD000000, $01000000
-			dc.l	$FD000000, $01000000
-			dc.l	$00D00000, $00100000
-
-			dc.w	kUsageEndTable
-
-;---
-;	Physical table for 68030 LCD portables													<9> <17> HJR
-;---
-
-physLCD		dc.w	kUsageRAM, cacheable									
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable
-			dc.l	$40000000, $10000000
-			dc.l	$40000000, $10000000
-			dc.l	$00800000, $00100000
-
-			dc.w	kUsageIO, notCacheable
-			dc.l	$50000000, $10000000
-			dc.l	$50000000, $10000000
-			dc.l	$00F00000, $00100000
-
-			dc.w	kUsageEndTable
-			
-;---
-;	Physical table for MSC-based portables												<t19>
-;---
-
-physMSC		dc.w	kUsageRAM, cacheable				; RAM
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable				; ROM								<H23><SM13>
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$00800000, ROMMaxSize
-
-			dc.w	kUsageIO, notCacheable				; I/O
-			dc.l	$50000000, $10000000
-			dc.l	$50000000, $10000000
-			dc.l	$00F00000, $00100000
-
-			dc.w	kUsageOnboardVideo, notCacheable	; LCD video							<SM13>
-			dc.l	$60000000, $10000000
-			dc.l	$60000000, $10000000
-			dc.l	$00000000, $00000000
-
-			dc.w	kUsageMajorSlot, notCacheable		; slot 9							<H14>
-			dc.l	$90000000, $10000000
-			dc.l	$90000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable		; slot A							<H14>
-			dc.l	$A0000000, $10000000
-			dc.l	$A0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable		; slot B							<H14>
-			dc.l	$B0000000, $10000000
-			dc.l	$B0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable		; slot C in docking station			<H13>
-			dc.l	$C0000000, $10000000
-			dc.l	$C0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable		; slot D in docking station			<H13>
-			dc.l	$D0000000, $10000000
-			dc.l	$D0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable		; slot E (PDS docking connector)	<H13>
-			dc.l	$E0000000, $10000000
-			dc.l	$E0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot 9							<H14>
-			dc.l	$F9000000, $01000000
-			dc.l	$F9000000, $01000000
-			dc.l	$00900000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot A							<H14>
-			dc.l	$FA000000, $01000000
-			dc.l	$FA000000, $01000000
-			dc.l	$00A00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot B							<H14>
-			dc.l	$FB000000, $01000000
-			dc.l	$FB000000, $01000000
-			dc.l	$00B00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot C in docking station			<H13>
-			dc.l	$FC000000, $01000000
-			dc.l	$FC000000, $01000000
-			dc.l	$00C00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot D in docking station			<H13>
-			dc.l	$FD000000, $01000000
-			dc.l	$FD000000, $01000000
-			dc.l	$00D00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot E (PDS docking connector)
-			dc.l	$FE000000, $01000000
-			dc.l	$FE000000, $01000000
-			dc.l	$00E00000, $00100000
-
-			dc.w	kUsageEndTable
-			
-;---
-;	Physical table for Niagra LCD portables													<H17>
-;---
-
-physNiagra	dc.w	kUsageRAM, cacheable				;									<SM12>									
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable				; ROM								<H23>
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$00800000, ROMMaxSize
-
-			dc.w	kUsageIO, notCacheable				; I/O
-			dc.l	$50000000, $10000000
-			dc.l	$50000000, $10000000
-			dc.l	$00F00000, $00100000
-
-			dc.w	kUsageOnboardVideo, notCacheable	; LCD video
-			dc.l	$60000000, $10000000
-			dc.l	$60000000, $10000000
-			dc.l	$00000000, $00000000
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot C
-			dc.l	$FC000000, $01000000
-			dc.l	$FC000000, $01000000
-			dc.l	$00C00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot D
-			dc.l	$FD000000, $01000000
-			dc.l	$FD000000, $01000000
-			dc.l	$00D00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot E up to declaration ROM
-			dc.l	$FE000000, $01000000-DeclRomSize
-			dc.l	$FE000000, $01000000-DeclRomSize
-			dc.l	$00E00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot E declaration ROM (VSCDeclData)
-			dc.l	$40800000, DeclRomSize
-			dc.l	$FF000000-DeclRomSize, DeclRomSize
-			dc.l	$00000000, $00000000
-
-			dc.w	kUsageEndTable
-			
-;---
-;	Physical table for Orwell Based machines												<T7>
-;---
-
-physOrwell	dc.w	kUsageRAM, cacheable
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$00800000, ROMMaxSize
-
-			dc.w	kUsageIO, notCacheable
-			dc.l	$50F00000, IOMaxSize
-			dc.l	$50F00000, IOMaxSize
-			dc.l	$00F00000, IOMaxSize
-
-			dc.w	kUsageIO, notCacheable									; ••temp••		<T20>
-			dc.l	$50F40000, IOMaxSize									; should be nonserialized
-			dc.l	$50F40000, IOMaxSize
-			dc.l	$00F40000, IOMaxSize
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$A0000000, $10000000
-			dc.l	$A0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$B0000000, $10000000
-			dc.l	$B0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$C0000000, $10000000
-			dc.l	$C0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$D0000000, $10000000
-			dc.l	$D0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$E0000000, $10000000
-			dc.l	$E0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageOnboardVideo, notCacheable
-			dc.l	$F9000000, $01000000
-			dc.l	$F9000000, $01000000
-			dc.l	$00900000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FA000000, $01000000
-			dc.l	$FA000000, $01000000
-			dc.l	$00A00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FB000000, $01000000
-			dc.l	$FB000000, $01000000
-			dc.l	$00B00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FC000000, $01000000
-			dc.l	$FC000000, $01000000
-			dc.l	$00C00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FD000000, $01000000
-			dc.l	$FD000000, $01000000
-			dc.l	$00D00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FE000000, $01000000
-			dc.l	$FE000000, $01000000
-			dc.l	$00E00000, $00100000
-			
-			dc.w	kUsageEndTable
-			
-physSonora	dc.w	kUsageRAM, cacheable			; Special Cased for Double X Slot E	<H10>
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$00800000, ROMMaxSize
-
-;			dc.w	kUsageROM, cacheable				; ROM
-;			dc.l	$40000000, $10000000
-;			dc.l	$40000000, $10000000
-;			dc.l	$00800000, $00100000
-
-			dc.w	kUsageIO, notCacheable						;<H16>
-			dc.l	$50000000, $10000000						; Don't map all of I/O Space
-			dc.l	$50000000, $00FC0000						; because of Double Exposure Card
-			dc.l	$00F00000, $000C0000
-
-			dc.w	kUsageOnboardVideo, notCacheable			;<H16> Video Space <H30>
-			dc.l	$60000000, $01000000						;<SM13>
-			dc.l	$60000000, $01000000						;<SM13>
-			dc.l	$00B00000, $00100000
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$90000000, $10000000
-			dc.l	$90000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$A0000000, $10000000
-			dc.l	$A0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$B0000000, $10000000
-			dc.l	$B0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$C0000000, $10000000
-			dc.l	$C0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$D0000000, $10000000
-			dc.l	$D0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$E0000000, $10000000
-			dc.l	$E0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$F9000000, $01000000
-			dc.l	$F9000000, $01000000
-			dc.l	$00900000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FA000000, $01000000
-			dc.l	$FA000000, $01000000
-			dc.l	$00A00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FC000000, $01000000
-			dc.l	$FC000000, $01000000
-			dc.l	$00C00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FD000000, $01000000
-			dc.l	$FD000000, $01000000
-			dc.l	$00D00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FE000000, $01000000
-			dc.l	$FE000000, $01000000
-			dc.l	$00E00000, $00100000
-			
-			dc.w	kUsageOther, notCacheable					; Double X accesses slot E		 <FF4>
-			dc.l	$FEE00000, $40000							; with addresses in the range	 <FF4><H30><SM13>
-			dc.l	$50FC0000, $40000							; $50FC0000-$50100000			 <FF4>
-			dc.l	$00FC0000, $40000							;								 <FF4>
-			
-			dc.w	kUsageEndTable
-			
-;••• Begin <SM1> CSS Cyclone Roll-in.
-;-----																					<H18><Begin>					
-;	Physical table for Foster Farms
-;---
-
-physFF		dc.w	kUsageRAM, cacheable
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable
-			dc.l	$00A00000,		$00100000
-			dc.l	$40A00000, 		$00100000
-			dc.l	$00A00000, 		$00100000
-
-			dc.w	kUsageROM, cacheable
-			dc.l	$00B00000,		$00100000
-			dc.l	$40B00000, 		$00100000
-			dc.l	$00B00000, 		$00100000
-
-			dc.w	kUsageROM, cacheable					; define 2 Mb addtional ROM	<SM9>
-			dc.l	$00C00000,		$00100000				;							<SM9>			
-			dc.l	$40C00000, 		$00100000				;							<SM9>
-			dc.l	$00C00000, 		$00100000				;							<SM9>
-
-			dc.w	kUsageROM, cacheable					;							<SM9>
-			dc.l	$00D00000,		$00100000				;							<SM9>
-			dc.l	$40D00000, 		$00100000				;							<SM9>
-			dc.l	$00D00000, 		$00100000				;							<SM9>
-
-			dc.w	kUsageIO, notCacheable
-			dc.l	$00F00000,		FFIOMax													
-			dc.l	$50F00000,		FFIOMax						
-			dc.l	$00F00000,		FFIOMax						
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$E0000000, $10000000
-			dc.l	$E0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FE000000, $01000000													
-			dc.l	$FE000000, $01000000
-			dc.l	$00E00000, $00100000
-
-			dc.w	kUsageOther, notCacheable					; Double X accesses slot E		 
-			dc.l	$00E00000, DblXSlotMax						; with addresses in the range	 
-			dc.l	$50FC0000, DblXSlotMax						; $50FC0000-$50CFFFFF			 
-			dc.l	$00FC0000, DblXSlotMax						;								 
-			
-			dc.w	kUsageEndTable								;						<H18><End>
-
-;---
-;	Physical table for YMCA Based machines												<P4><LW2>
-;---
-
-physYMCA	dc.w	kUsageRAM, cacheable
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$40800000, ROMMaxSize
-			dc.l	$00800000, ROMMaxSize
-
-			dc.w	kUsageOnboardVideo, notCacheable
-			dc.l	$50100000, VRAMMaxSize
-			dc.l	$50100000, VRAMMaxSize
-			dc.l	0, 0
-			
-			dc.w	kUsageIO, notCacheable
-			dc.l	$50036000, $00002000
-			dc.l	$50036000, $00002000
-			dc.l	0, 0
-			
-			dc.w	kUsageIO, notCacheable
-			dc.l	$50F00000, IOMaxSize
-			dc.l	$50F00000, IOMaxSize
-			dc.l	$00F00000, IOMaxSize
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$A0000000, $10000000
-			dc.l	$A0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$B0000000, $10000000
-			dc.l	$B0000000, $10000000
-			dc.l	0, 0
-			
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$C0000000, $10000000
-			dc.l	$C0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$D0000000, $10000000
-			dc.l	$D0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMajorSlot, notCacheable
-			dc.l	$E0000000, $10000000
-			dc.l	$E0000000, $10000000
-			dc.l	0, 0
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FA000000, $01000000
-			dc.l	$FA000000, $01000000
-			dc.l	$00A00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FB000000, $01000000
-			dc.l	$FB000000, $01000000
-			dc.l	$00B00000, $00100000
-			
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FC000000, $01000000
-			dc.l	$FC000000, $01000000
-			dc.l	$00C00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FD000000, $01000000
-			dc.l	$FD000000, $01000000
-			dc.l	$00D00000, $00100000
-
-			dc.w	kUsageMinorSlot, notCacheable
-			dc.l	$FE000000, $01000000
-			dc.l	$FE000000, $01000000
-			dc.l	$00E00000, $00100000
-			
-			dc.w	kUsageEndTable
-
-;••• End <SM1> CSS	Cyclone roll-in		
-
-;---
-;	Physical table for Pratt LCD portables													<SM14>
-;---
-
-physPratt	dc.w	kUsageRAM, cacheable				;																		
-			dc.l	0, 0
-			dc.l	0, 0
-			dc.l	0, 0
-
-			dc.w	kUsageROM, cacheable				; ROM								
-			dc.l	$40000000, ROMMaxSize
-			dc.l	$40000000, ROMMaxSize
-			dc.l	0,0
-
-			dc.w	kUsageIO, notCacheable				; I/O
-			dc.l	$50000000, $10000000
-			dc.l	$50000000, $10000000
-			dc.l	0,0
-
-			dc.w	kUsageOnboardVideo, notCacheable	; LCD video
-			dc.l	$60000000, $10000000
-			dc.l	$60000000, $10000000
-			dc.l	0,0
-
-			dc.w	kUsageMajorSlot, notCacheable		; PDS, major slots A-B
-			dc.l	$A0000000, $20000000
-			dc.l	$A0000000, $20000000
-			dc.l	0, 0
-
-			dc.w	kUsageMinorSlot, notCacheable		; PDS, minor slots A-B
-			dc.l	$FA000000, $02000000
-			dc.l	$FA000000, $02000000
-			dc.l	0,0
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot E up to declaration ROM
-			dc.l	$FE000000, $01000000-DeclRomSz
-			dc.l	$FE000000, $01000000-DeclRomSz
-			dc.l	0,0
-
-			dc.w	kUsageMinorSlot, notCacheable		; slot E up to declaration ROM
-			dc.l	$402e0000-DeclRomSz, DeclRomSz
-			dc.l	$FF000000-DeclRomSz, DeclRomSz
-			dc.l	0,0
-
-			dc.w	kUsageEndTable
-			
-;-----
-;	MMUError - unrecoverable error discovered while setting up MMU.
-;---
-MMUError	move.w	#102,d6				; minor error code = MMU setup error			<3.2>
-			move.l	#$0F,d7				; major error code = NuMac error				<3.2>
-			bigjmp	Critical,a0			; ugly tone, service call needed...
-			
-
 ;-----
 ;	InitMMU - sets up the MMU depending on what memory controller we are running and
 ;			  what chunks of RAM were found by StartTest.
@@ -1847,11 +643,6 @@ InitMMU		link	a5,#InitSize			; set up stack frame
 			bsr		SetupGlobals			; set up stack frame, boot globals
 			bsr		FindInfo				; get ptr to MMU setup info
 											; returns a0 = 32 bit info ptr, a1 = 24 bit ptr
-			cmpi.b	#EMMU1,sgTypeMMU(A6)	; Do we have an Emulated MMU? (ie don't make tables)	<SM17>
-			beq.s	@NoTables				; -> Yes, bail out now!									<SM17>
-			cmp.b	#HMMU,sgTypeMMU(a6)		; <SM6> CSS check type of MMU
-			bne.s	@isPmmu					; IF HMMU
-@noTables
 			movem.l	SaveURegs(a5),UnivRegs	;   restore universal registers
 		IF forRomulator	THEN				; 												<T11>
 			TestInRAM	A2					; check if running ROM image in RAM				 |
@@ -1864,179 +655,9 @@ InitMMU		link	a5,#InitSize			; set up stack frame
 			move.l	a6,a4					;   return ptr to BootGlobs
 			unlk	a5						;   remove stack frame
 			rts								;   EXITROUTINE
-@isPmmu										; ENDIF
-			move.l	a1,a4					; save ptr to 24 bit mode MMU setup info
-			move.l	a0,a2					; save ptr to 32 bit mode MMU setup info
-			bsr		MakePhysicalTable		; create physical space table (for VM et. al.)
-			move.l	a2,a0					; recall ptr to 32 bit mode info
-			bsr		MakeTable				; make 32 bit translation table
-			lea		sg32Info(a6),a1			; point at 32 bit mode info in BootGlobs 	<SM6> CSS 
-			bsr		SaveMMUInfo				; move 32 bit info to BootGlobs				<SM6> CSS 
-			btst	#MMStartMode,sgMMFlags(a6);check if we're booting 32 bit only		<SM6> CSS 
-			bne.s	@modesOK				; IF not booting 32 only
-			move.l	a4,a0					;   recall addr 24 bit mode MMU setup Info
-			move.l	a4,a2					;   recall addr 24 bit mode MMU setup Info
-			bsr		MakeTable				;   make a translation table
-@modesOK									; ENDIF
-			lea		sg24Info(a6),a1			; point at 24 bit mode info in BootGlobs	<SM6> CSS 
-			bsr		SaveMMUInfo				; move 24 (or 32) bit info to BootGlobs
-@done										; ENDIF
-
-			bsr		CleanupGlobals			; tidy up, leaving registers as follows:
-											;	a2 - InitMMU's logical return address
-											;   a3 - points to tc in MMUConfigInfo
-											;   a4 - logical ptr to BootGlobs
-											;	d3 - ROM physical-2-logical conversion constant
-											;   sp - midway thru useable logical RAM
-											;   d0-d2/d7/a0-a1 restored (DON'T TOUCH!)
-
-;-----
-;	The following code actually enables the MMU.  Since enabling the MMU may change the
-;	address of the code that actually does it (if it is running in RAM under Romulator™),
-;	we take precautions to ensure that both the 'pmove tc' and the 'jmp to the new logical
-;	address' are both in the 020/030 instruction cache.  We can then jump to our new 
-;	logical pc without fetching anything from the old pc, which is invalid once the pmove
-;	is executed.  The same principle applies to the 040 'MOVEC URP', 'MOVEC TC' code.	<2>
-;
-;	We preload the instruction cache by executing the code snippet twice, passing in the Z
-;	condition code flag to determine whether to run the pmove or not. Since the pmove is 
-;	4 bytes, if we ensure that it is on a non-longword boundary, it will always be prefetched
-;	and cached by the 020 on the first pass thru the code.
-;
-;	It is important the the transparent translation registers be set up before the MMU	<7>
-;	is enabled, since we get the values for the TT regs using a3, which may become 		<7>
-;	invalid once the MMU is enabled.  This will also work with Romulator™, since 		<7>
-;	we are already executing out of phyiscal space, which will not be affected by		<7>
-;	transparent translation.															<7>
-;
-;	This routine assumes that the MMU is NOT enabled when called on a system with a		<3.8>
-;	68851 PMMU.																			<3.8>
-;---
-
-VTEntries	equ		64						; entries in exception vector table			<SM1> CSS <H18>
-
-		IF forRomulator THEN				; 											<3.8>
-			biglea	baseOfRom,a5			; get physical base of ROM					<3.8>
- 			move.l	a5,d6					; save it to adjust pointers later			<3.8>
-		ENDIF								; 											<3.8>
-
-			cmp.w	#cpu68040,d7			; Check whether or not we're on an 040		<2><3>
-			beq.s	@enable040MMU			; YES ... go enable 040 MMU					<2>
-
-			pflusha							; flush address translation cache			<16>
-;•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	<SM1> CSS <H18><Begin>
-; For LC since all addresses are mapped straight thru, (i.e. no address translation takes place)
-; 00AxXXXX is a valid address in 32 or 24 bit modes but on Foster Farms trying to access the ROM 
-; at 00AxXXXX will generate a bus error in 32 bit mode once the MMU is turned on. Therefore we
-; must adjust all ptrs that have already been set up to pt at 40AxXXXX. Note: this address is
-; also valid in 24 bit mode since the upper 8 bits of the address are ignored in this mode.
-; Remember, D3 contains the ROM physical-2-logical conversion constant. 
-;•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
-			add.l	d3,a0					; adjust ptr to base addrs
-			add.l	d3,a1					; adjust ptr to productInfo rec
-			
-			movec	vbr,a5					; get address of vectors				
-			move.w	#VTEntries-1,d5			; get number of entries to adjust	
-@adj		add.l	d3,(a5)+				; convert a vector				
-			dbra	d5,@adj					; do all of them					
-
-;•••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••	<SM1> CSS <H18><End>
-			movec	cacr,d5					; NO  ... get cache control reg
-			ori.w	#$0808,d5				; set flush bits (also set ccr.z = 0, for no pmove)
-			movec	d5,cacr					; flush instruction, data caches
-			pmove	theTT0-theTC(a3),tt0	; load the transparent translation regs		<7>
-			pmove	theTT1-theTC(a3),tt1	;	BEFORE we fire up the MMU				<7>
-			lea		theCRP-theTC(a3),a6		; get address of CRP						<3.8>
-			lea		@return1,a5				; get 1st return addr
-			bra.s	@inIcache				; load tc enable code into i-cache			<3.8>
-@return1	lea		@mmuEnabled,a5			; get 2nd return addr						<3.8>
-			add.l	d3,a5					; add in phys-to-log conversion constant	<3.8>
-			moveq	#0,d5					; set ccr.z = 1, so pmove gets executed
-		IF NOT forRomulator THEN			; Do not set the VBR to 0 if this is a ReAnimator build <H29>
-			movec	d5,vbr					; restore vector base reg					<3.8>
-		ENDIF								; 											<H29>
-			bra.s	@inIcache				; go enable the mmu, return from InitMMU	<3.8>
-			nop								; appease the assembler gods
-			ALIGN	4						;											<3.8>
-@inIcache	bne.s	@step					; (2 bytes) IF second time thru
-			pmove	(a6),crp				; (4 bytes)   set up 32 bit mode crp		<3.8>
-@step		nop								; (2 bytes)	  aligns next pmove to odd-word	<3.8>
-			bne.s	@goBack					; (2 bytes) IF second time thru				<3.8>
-			pmove	(a3),tc					; (4 bytes)   enable the MMU
-@goBack		jmp		(a5)					; (2 bytes) ENDIF - return
-
-@mmuEnabled
-
-		IF 0 THEN
-		IF forRomulator THEN				; 											<3.8>
-			TestInRam	a5					; running in RAM? 							<3.8>
-			beq.s	@noAdj					; if not, don't adjust pointers				<3.8>
-			move.l	ROMBase,d5				; get correct base of ROM					<3.8>
-			sub.l	d6,d5					; make d5 a phys-to-log offset				<3.8>
-			add.l	d5,a0					; adjust ptr to base addrs					<3.8>
-			add.l	d5,a1					; adjust ptr to productInfo rec				<3.8>
-@noAdj										;											<3.8>
-		ENDIF								;											<3.8>
-		ENDIF
-			jmp		(a2)					; get InitMMU return addr					<3.8>
-
-
-;-----
-;	Enable the MMU on a 68040.
-;
-;	Flush both caches.  Use a CPUSHA instead of a CINVA, since CINVA does not flush		<2>
-;	dirty entries to memory.  N.B. - the CPUSHA  IC generated by the <BC> operand does	<2>
-;	NOT flush out the inst. cache, but instead performs the same action as a CINVA  IC.	<2>
-;	This is because in the 040, there won't BE any "dirty" entries in the inst. cache.	<2>
-;
-;	Since the Mac OS does not distinguish between instruction and data space, we must	<7>
-;	duplicate the values placed in the instruction and data transparent translation		<7>
-;	registers.  																		<7>
-;-----
-			MACHINE	MC68040					; The use of 040 instructions requires this	<2>
-
-@enable040MMU								;											<2>
-
-		IF forRomulator THEN				; 											<T4>
-			biglea	baseOfRom,a5			; get physical base of ROM					<T4>
-			MACHINE	MC68040					; corrects for ASM bug w/040 directive		<SM12>
- 			move.l	a5,d6					; save it to adjust pointers later			<T4>
-		ENDIF								; 											<T4>
-
-			pflusha							; flush address translation cache			<16>
-			move.l	theTT0-theTC(a3),d5		; get transparent translation reg 0 value	<7>
-			movec	d5,itt0					; load the instruction TT0 reg				<7>
-			movec	d5,dtt0					; load the data TT0 reg with the same value	<7>
-			move.l	theTT1-theTC(a3),d5		; get transparent translation reg 1 value	<7>
-			movec	d5,itt1					; load the instruction TT0 reg				<7>
-			movec	d5,dtt1					; load the data TT0 reg with the same value	<7>
-			moveq	#0,d5					; set ccr.z=1, to put enable code in cache	<7>
-			lea		@return0,a5				; get 1st return addr						<2>
-			bra.s	@cachedEnableCode		; load TC enable code into i-cache			<2>
-@return0	lea		@mmuEnabled,a5			; get 2nd return addr						<2>
-			add.l	d3,a5					; add in phys-to-log conversion constant	<2>
-		if NOT forRomulator THEN			;											<16>
-			movec	d5,vbr					; restore vector base reg to zero			<16>
-		endif								;											<16>
-			move.l	theSRP-theTC(a3),a6		; retrieve 040 SRP value					<7>
-			move.l	(a3),d5					; retrieve 040 TC value in lsw (ccr.z=0)	<2>
-			bra.s	@cachedEnableCode		; go enable the MMU, return from InitMMU	<2>
-
-			ALIGN	16						; force onto Cache Line boundary			<2>
-@cachedEnableCode
-			beq.s	@aJMP					; (2 bytes) IF second time thru, fall thru	<2>
-			movec	a6,SRP					; (2 bytes)    set up 32 bit mode SRP		<7>
-			movec	d5,TC					; (2 bytes)    enable the MMU				<2>
-@aJMP		jmp		(a5)					; (2 bytes) ENDIF - return					<2>
-
-;	----------------------------------------------------------------------------------- <2>
-
-			MACHINE	MC68030					; return to prior MACHINE directive			<2>
-
-;	----------------------------------------------------------------------------------- <2>
 
 ;-----
-;	SetupGlobals - sets up the InitMMU stack frame and the BootGlobals record that is passed
+;	SetupGlobals 7a38 - sets up the InitMMU stack frame and the BootGlobals record that is passed
 ;				   back to StartInit.
 ;
 ;	Entry:
@@ -2069,7 +690,7 @@ SetupGlobals
 			move.l	ROMPhysAddr(a0),d0			;   use it instead of computed value			<H12>	
 
 @SavePhys	move.l	d0,physRomBase(a5)			; save it in our globals
-			bsr		GetMMUType					; figure out what kind of MMU we have
+			moveq.l	#6,d0						; figure out what kind of MMU we have
 			move.b	d0,sgTypeMMU(a6)			; save MMU type in BootGlobs					<SM6> CSS
 			clr.l	VRAMSize(a5)				; assume no onboard video				<9>
 			clr.l	VRAMrealSize(a5)			; assume no onboard video				<9>
@@ -2086,42 +707,15 @@ SetupGlobals
 			clr.b	sgEDiskStealFlag(a6)		; assume no chunks to steal						<SAM>
 			move.l	#-1,eDiskChunks(a5)			; make eDisk chunk table empty too
 
-			lea		sgBottom,a0					; assume we'll start allocating below BootGlobs	<SM6> CSS
+			lea		$FFFFFFA4,a0
 			move.l	a0,sgAllocOff(a6)			; save allocation offset						<SM6> CSS
 
-			move.b	#ramDiskPramAddr,d0			; get PRAM address of memory manager flags		<T11>
-			bsr		ReadPRAMByte				; read it and weep...							<T11>
-			andi.l	#$ff,d0						; clear upper bytes of pram byte				<T11>
-			beq.s	@noEdisk					; IF we want an Edisk THEN 						<T11>
 			clr.l	d3							;	clear counter								<T23>
-			cmpi.b	#EMMU1,sgTypeMMU(A6)		; DO we have an EMMU? (have we already stolen RAM for the EDisk?)
-			bne.s	@countRAM					; -> Nope, parse the tables
-			
 			move.l	sgTestSpace+24(a6),d1		; Get the amount of bytes allocated by SizeMem for the EDisk	<MC3>
-			bra.s	@saveSize					; join the rest of the code (if D1=0 then no EDisk)				<MC3>
-			
-@countRAM	lea		sgRamTable+4(a6),a0			;	get pointer to size of the first chunk		 | <SM6> CSS
-@countLoop										;	LOOP (to count RAM chunk sizes)				 v
-			add.l	(a0)+,d3					;	  bump RAM counter
-			tst.l	(a0)+						;	  is this the last chunk?
-			bpl.s	@countLoop					;	UNTIL (we reach the last chunk)
-@gotSize	lsr.l	#8,d3						;	get chunk size
-			mulu.l	d3,d0						;	calc size of edisk
-			add.l	#$7fff,d0					;	bump edisk past next 32k boundary			<T24>
-			and.w	#$8000,d0					;	round down to the boundary					 ^
-			cmp.l	#MinRamDiskSize,d0			;	check ram disk size							 |
-			blo.s	@noEdisk					;	>>EXIT if edisk is too small				<T23>
-			cmp.l	#MaxRamDiskSize,d0			;	check upper size limit						<MC2>
-			bhi.s	@noEdisk					;	>>EXIT is edisk to too big					<MC2>
-			move.l	d0,d1						;   copy the size into D1						<SAM>
-			move.b	#1,sgEDiskStealFlag(a6)		;       signal that we want to steal chunks from RAM  <SAM>
-			lea		sgRamTable(a6),a0			;		source = chunk table in BootGlobs		<T11> <SM6> CSS
-			lea		eDiskChunks(a5),a1			;		destination = edisk chunk table			<T11>
-			bsr		stealChunks					;		try to steal some ram from main memory	<T11>
-@saveSize										;
+								;
 			move.l	d1,sgRamDiskSize(a6)		;	save size of eDisk in boot globals			<T11> <SM6> CSS
 @noEdisk										; ENDIF											<T11>
-			
+
 			lea		sgRamTable(a6),a0			; source = chunk table in BootGlobs				<SM6> CSS
 			lea		globChunks(a5),a1			; destination = our globals
 			bsr		CopyChunks					; copy RAM chunks to our globals
@@ -2130,27 +724,18 @@ SetupGlobals
 												; a0 = top highest bank, d1 = total RAM
 			sub.l	a0,d1						; normal phys-to-log offset = total - top
 
-			move.b	#MMPRAMloc**$FF,d0			; get PRAM address of memory manager flags
-			bsr		ReadPRAMByte				; read it and weep...						<5>
+			moveq.l	#0,d0
 
-	IF NOT Supports24Bit THEN					;												<SM10> rb <SM11> rb
+;	IF NOT Supports24Bit THEN					;												<SM10> rb <SM11> rb
 	
+			bset	#mmFigEnable,d0				; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
 			bset	#MMStartMode,d0				; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
 			bset	#MMMixed,d0					; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
 			bset	#MMSysheap,d0				; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
 			bset	#MMROZheap,d0				; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
-			bclr	#mmHighSysHeap,d0			; Force 32-bit mode until we make room for a 2 meg rom <SM3> kc ••••
-	ENDIF										;												<SM10> rb
+			
+;	ENDIF										;												<SM10> rb
 	
-			btst	#MMStartMode,d0				; check for 32 bit only
-			bne.s	@not24						; IF not 32 bit only
-			bclr	#mmHighSysHeap,d0			;   weird system heap is a bad idea
-			bra.s	@modeOk						;   ...
-@not24		btst	#mmHighSysHeap,d0			; ELSEIF 'black hole' before system heap
-			beq.s	@modeOk						; .
-			add.l	#HoleSysHeap-HoleLowMem,d1	;   phys-to-log offset = (total-top) +
-												;   .(new base system heap - ram for lowmem)
-@modeOk											; ENDIF
 			move.b	d0,sgMMFlags(a6)			; save memory mgr flags in BootGlobs <SM6> CSS
 			move.l	d1,sgPhys2Log(a6)			; save physical-to-logical offset <SM6> CSS
 			rts
@@ -2239,14 +824,6 @@ CleanupGlobals
 		ENDIF									;												<T11>
 
 			add.l	sgAllocOff(a6),d0			; get logical address top useable memory <SM6> CSS
-			btst.b	#mmHighSysHeap,sgMMFlags(a6); check if 'black hole' before system heap  <SM6> CSS
-			beq.s	@noHole						; IF 'black hole'
-			move.l	d0,sp						;   temporarily set new logical stack ptr there
-			sub.l	#HoleSysHeap-HoleLowMem,d0	;   adjust amount of useable logical memory
-			lsr.l	#1,d0						;   divide amt useable logical memory by 2
-			suba.l	d0,sp						;   stack = middle of useable logical memory
-			bra.s	@donestak					;   .
-@noHole											; ELSE
 			cmp.l	#$200000,d0					;	do we have at least two meg of RAM?			<5>
 			bge.s	@plentyORam					;	IF we have less than two meg THEN			<5>
 			lsr.l	#2,d0						;     divide amt useable logical memory by 4	<5>
@@ -2256,7 +833,6 @@ CleanupGlobals
 			move.l	#defStackAddr,d0			;	  use default stack size 					<5>
 @stakOk											;   ENDIF
 			move.l	d0,sp						;   set new stack
-@doneStak										; ENDIF
 
 			biglea	BaseOfROM,a1 				; get physical base address of ROM
 			move.l	logRomBase(a5),d3			; get future logical base addr ROM
@@ -2291,37 +867,12 @@ SaveMMUInfo	move.l	newtc(a2),theTC(a1)			; move tc
 
 
 ;-----
-;	GetMMUType - figure out what kind of MMU we have
-;
-;	Entry
-;		a5 - points to InitMMU globals
-;		d7 - bits 31-16: logic board type
-;		d7 - bits 15-0: cpu type (0 = 68000, 1 = 68010, 2 = 68020, 3 = 68030, 4 = 68040, etc.)	<2>
-;
-;	Exit
-;		d0.b - type of MMU
-;
-;	Destroys d1-d2/a0-a1
+;	MMUError 7bac - unrecoverable error discovered while setting up MMU.
 ;---
-
-MMUTypes									; CPU type -> MMU type mapping
-			dc.b	NoMMU					;   68000 - no MMU
-			dc.b	NoMMU					;   68010 - no MMU
-			dc.b	HMMU					;   68020 - HMMU or 68851
-			dc.b	PMMU030					;   68030 - '030 MMU
-			dc.b	PMMU040					;   68040 - '040 MMU							<2>
-MaxCPU		equ		*-MMUTypes-1			;   highest CPU flag supported
-
-GetMMUType	cmp.w	#MaxCPU,d7				; check if CPU type is in range
-			bhi		MMUError				; if outta range, we're hosed
-			moveq	#0,d0					; clear a reg
-			move.b	MMUTypes(d7),d0			; get MMU type, based on CPU type
-
-			move.l	prodInfoPtr(A5),A0		; Get ptr to productInfo table
-			btst	#ProductInfo.has68kEmulator//8,ProductInfo.ExtValid1+3(A0)
-			beq.s	@done					; -> No emu.  MMU type is correct.
-			moveq	#EMMU1,D0				; Set the MMU type to EmuMMU cause we're emulation an 020.
-@done		rts
+MMUError	move.w	#102,d6				; minor error code = MMU setup error			<3.2>
+			move.l	#$0F,d7				; major error code = NuMac error				<3.2>
+			bra.l	Critical
+			
 
 ;-----
 ;	CopyChunks - copies a RAM chunk table, skipping zero sized chunks, remembering 
@@ -2365,91 +916,6 @@ CopyChunks	movem.l	CopyRegs,-(sp)		; save work regs
 			rts
 			
 			
-;-----
-;	StealChunks -	Steals chunks from the end of a chunk table and moves them to 		<T11>
-;					another table.  Also copies the original Boot Globs from the end
-;					of the original last chunk to the "new" last chunk of main memory.
-;
-;	Entry
-;		a0 - points to source table of chunks
-;		a1 - points to destination table of chunks
-;		d0 - amount of RAM to steal
-;
-;	Exit
-;		d1.l - total size of memory stolen, else zero upon failure
-;		a6.l - new boot globs pointer if RAM was stolen
-;
-;	Destroys
-;		a1-a3
-;-----
-MinBootGlobs equ	$00080000			; 512k: boot globs min size						<SM13>
-
-StealRegs	REG		d2-d5/a4
-
-StealChunks
-			movem.l	StealRegs,-(sp)		; save work regs
-			move.l	a0,a2				; get addr of source chunks
-			move.l	a1,a3				; get addr of dest chunks
-			move.l	d0,d2				; get number of bytes to steal
-			clr.l	d3					; clear RAM size count
-@findEndLoop							; LOOP (to find end of source chunks)
-			cmp.l	#-1,(a2)+			;	did we reach the end?
-			beq.s	@foundEnd			;	>>EXIT when we get there
-			add.l	(a2)+,d3			;	add size of this chunk into total
-			bra.s	@findEndLoop		; END
-@foundEnd								;
-			sub.l	#MinHeapSize,d3		; subtract minimum amount of RAM for System
-			ble		@notEnufRAM			; >>EXIT if not enuf RAM
-			cmp.l	d3,d2				; check against requested amount
-			bhi		@notEnufRAM			; >>EXIT if not enuf RAM
-
-			add.l	#MinBootGlobs,d2	; so we eat past boot globs
-			suba.l	#4,a2				; point just past last chunk entry
-			cmp.l	#MinBootGlobs,-4(a2); is this a boot globs chunk?
-			beq.s	@getChunksLoop		; IF boot globs chunk is not already seperate THEN
-			move.l	-4(a2),d4			;	get size of previous last chunk
-			sub.l	#MinBootGlobs,d4	;	calc new size of previous last chunk
-			move.l	d4,-4(a2)			;	save new size in previous last chunk
-			add.l	-8(a2),d4			;	calc new end of previous last chunk
-			move.l	d4,(a2)				;	save start of boot globs chunk in new entry
-			move.l	#MinBootGlobs,4(a2)	;	save size of new chunk in a new entry at end
-			move.l	#-1,8(a2)			;	put end of chunk marker after boot globs chunk
-			adda.l	#8,a2				;	point past new boot globs chunk
-										; ENDIF
-
-			move.l	a2,a4				; save ptr to end of boot globs chunk in src table
-@getChunksLoop							; LOOP (to get start of Edisk chunks)
-			sub.l	-(a2),d2			;	subtract this chunk from request
-			suba.l	#4,a2				;	point to beginning of this chunk
-			bgt.s	@getChunksLoop		; END
-			move.l	a2,a0				; make a copy of source table address
-			bsr		copyChunks			; copy the chunk table starting with the chunk in a0
-			add.l	d2,d1				; calc amount of memory stolen
-			neg.l	d2					; get number of bytes in last main RAM chunk we don't need
-			move.l	d2,4(a2)			; save new size of last chunk of main RAM in src table
-			sub.l	d2,4(a3)			; save size of first chunk of edisk in dest table
-			add.l	d2,(a3)				; adjust start of first chunk of edisk in dest table			
-
-; fix up boot globs chunks
-			move.l	-8(a4),8(a2)		; copy start of boot globs chunk down in src table
-			move.l	-4(a4),12(a2)		; copy size of boot globs chunk down in src table
-			move.l	#-1,16(a2)			; put an end marker in src table after last chunk
-@findEndLoop1							; LOOP (to find end of dest chunks)
-			cmp.l	#-1,(a3)+			;	did we reach the end?
-			beq.s	@foundEnd1			;	>>EXIT when we get there
-			add.l	#4,a3				;	bump up ptr to next addr
-			bra.s	@findEndLoop1		; END
-@foundEnd1	move.l	#-1,-12(a3)			; kill off extra boot globs chunk
-			sub.l	#MinBootGlobs,d1	; adjust amount of memory stolen
-
-@exit		movem.l	(sp)+,StealRegs		; restore regs
-			rts
-
-@notEnufRAM
-			clr.l	d1					; clear total size to indicate failure
-			bra.s	@exit
-
-
 ;-----
 ;	FindInfo - massage RAM chunks based on what type of hardware we are on, and return 
 ;			   pointers to the layout tables to use in setting up the MMU.
@@ -2486,1899 +952,39 @@ FindInfo	movem.l	FindRegs,-(sp)		; save work registers
 			dc.w	@bad-@casetbl		; .(Mac Pal)
 			dc.w	@bad-@casetbl		; .(BBU)
 			dc.w	@bad-@casetbl		; .(Normandy)
-			dc.w	@Glu-@casetbl		; .(Mac2Glue)
-			dc.w	@MDU-@casetbl		; .(MDU)
-			dc.w	@FMC-@casetbl		; .(OSS FMC)
-			dc.w	@VISA-@casetbl		; .(VISA has MMU similar to HMMU)				<12><T22>
-			dc.w	@Orwell-@casetbl	; .(Orwell)										<7><T22>
-			dc.w	@Jaws-@casetbl		; .(Jaws)										<9>
-			dc.w	@MSC-@casetbl		; .(MSC)										<T19>
-			dc.w	@Sonora-@casetbl	; .(Sonora)										<H4>
-			dc.w	@Niagra-@casetbl	; .(Niagra)										<H8>
-			dc.w	@YMCA-@casetbl		; .(YMCA)										<SM7> fau <LW2>
-			dc.w	@djMEMC-@casetbl	; .(djMEMC)										<H20><SM13>
-			dc.w	@Emulated-@casetbl	; .(HMC)										<SM8>
-			dc.w	@Pratt-@casetbl		; .(Pratt)										<SM14>
-			dc.w	@Emulated-@casetbl	; .(HHead)									
+			dc.w	@bad-@casetbl		; .(Mac2Glue)
+			dc.w	@bad-@casetbl		; .(MDU)
+			dc.w	@bad-@casetbl		; .(OSS FMC)
+			dc.w	@bad-@casetbl		; .(VISA has MMU similar to HMMU)				<12><T22>
+			dc.w	@bad-@casetbl		; .(Orwell)										<7><T22>
+			dc.w	@bad-@casetbl		; .(Jaws)										<9>
+			dc.w	@bad-@casetbl		; .(MSC)										<T19>
+			dc.w	@bad-@casetbl		; .(Sonora)										<H4>
+			dc.w	@bad-@casetbl		; .(Niagra)										<H8>
+			dc.w	@bad-@casetbl		; .(YMCA)										<SM7> fau <LW2>
+			dc.w	@bad-@casetbl		; .(djMEMC)										<H20><SM13>
+			dc.w	@exp-@casetbl		; .(HMC)										<SM8>
+			dc.w	@bad-@casetbl		; .(Pratt)										<SM14>
+			dc.w	@exp-@casetbl		; .(HHead)									
+			dc.w	@exp-@casetbl		;
+			dc.w	@exp-@casetbl		;
+			dc.w	@exp-@casetbl		;
+			dc.w	@bad-@casetbl		;
+			dc.w	@exp-@casetbl		;
+			dc.w	@exp-@casetbl		;
+			dc.w	@exp-@casetbl		;
+			dc.w	@exp-@casetbl		;
+			dc.w	@exp-@casetbl		;
+			dc.w	@bad-@casetbl		;
 
 			Align	4
 @bad									; CASE non-MMU based controller:
 			bra		MMUError			;   we're hosed...
 @exp									; CASE some new controller:
-			moveq	#2,d0				;   filler for a future overpatch
-			moveq	#2,d0				;   filler for a future overpatch
-			bra		@endSwitch
-
-;---
-;	Mac II glue chip:	check for weird cases, normally return pointer to Contiguous setup.
-;						Normal case is no bank B here, since we merged it with bank A
-;						and set the size bits.  If we still have bank B, either there
-;						was no bank A, or Bank B is bigger than bank A.  Either can be
-;						handled if a 68851 is present by using the Split setup.
-;---
-
-
-
-@Glu									; CASE Mac 2 glue chip:
-			lea		Contig32,a0			;   assume contig 32 bit mode layout info
-			lea		Contig24,a1			;   assume contig 24 bit mode layout info
-			tst.l	d2					;   check if first chunk start w/Bank A				<3.5>
-			bne.s	@tryPMMU			;   if not, its a weird case (has to be bank B)		<3.5>
-			addq.l	#1,d4				;   check if second chunk (bank B) exists			<3.5>
-			beq		@endSwitch			;   if only one chunk of RAM, we're all set			<3.5>
-@tryPMMU	cmp.b	#HMMU,sgTypeMMU(a6)	;	see if we have an MMU up to the task			<3.5> <SM6> CSS
-			bne		@split				;   if its a PMMU, we can live with split memory	<3.5>
-			bra		MMUError			;   otherwise we're hosed (no mem at addr zero!)
-
-;---
-;	Emulated:	RISC Macs have MMU functionality, but don't need to be setup here.			<SM8> cch
-;---
-
-@Emulated								; CASE RISC Mac:
-			bra		@endSwitch			;	that's all folks
-			
-
-;---
-;	Sonora:	Weird Case necessary to be able to handle Vail and Double Exposure.				<H10>  
-;---
-
-@Sonora									; CASE Sonora chip:									<H4>
-
-			move.l	d0,a0				; save d0											<H31 Begin><SM13>
-			movec	cacr,d0				;													<SM13>
-			move.l	d0,a1				; save cacr											<SM13>
-			sub.l	d0,d0				; D0 = 0											<SM13>
-			bset	#CACR_DE_040,d0		; set Data Cache Enable bit on 040s					<SM13>
-			movec	d0,CACR				; attempt to enable data cache (temporarily)		<SM13>
-			movec	CACR,d0				; check and see if it's still there					<SM13>
-			btst	#CACR_DE_040,d0		; see if the bit exists in CACR						<SM13>
-			beq.s	@Sonora030			; IF we're on a 68040 THEN							<SM13>
-
-			MACHINE	MC68040				;	need this for the MOVEC D0,TC below				<SM13>
-
-			cinva	bc					;	make sure caches are invalidated				<SM13>
-
-			MACHINE	MC68030				; return to prior MACHINE directive			<2>		<SM13>
-
-			move.l	a1,d0				; restore cacr										<SM13>
-			movec	d0,cacr				;
-			move.l	a0,d0				; restore d0										<SM13>
-			lea		SnraForty32,a0		;	use Sonora's 040 32 bit mode layout	info		<SM13>
-			lea		SnraForty24,a1		;	use Sonora's 040 24 bit mode layout	info		<SM13>
-			bra		@endSwitch			;	that's all folks								<SM13>
-	
-@Sonora030	move.l	a1,d0				; restore cacr										<SM13>
-			movec	d0,cacr				;													<SM13>
-			move.l	a0,d0				; restore d0										<H31 End><SM13>
-
-			lea		Sonora32,a0			;	use Sonora's 32 bit mode layout	info
-			lea		Sonora24,a1			;	use Sonora's 24 bit mode layout	info
-			bra		@endSwitch			;	that's all folks
-			
-;---
-;	Orwell:	no weird cases. This wonderful decoder has already been set up to merge			<7>
-;			RAM to be contiguous.  
-;---
-
-@djMEMC									; CASE djMEMC chip:									<H20><SM13>
-@Orwell									; CASE Orwell chip:									<7>
-			lea		Orwell32,a0			;	use Orwell's 32 bit mode layout	info
-			lea		Orwell24,a1			;	use Orwell's 24 bit mode layout	info
-			bra		@endSwitch			;	that's all folks
-			
-;---
-;	Jaws:	Memory is always contiguous on Jaws, and onboard video will always be on.  
-;---
-
-@Jaws									; CASE Jaws chip:									<9>
-			movea.l	prodInfoPtr(a5),a0	;	get productInfo record in a0
-			move.l	a0,a1				;	get a copy in a1
-			adda.l	ProductInfo.VideoInfoPtr(a0),a1	; point to the VideoInfo record
-			move.l	VideoInfo.VRAMPhysAddr(a1),VRAMPhysBase(a5)	; initialize base of video RAM
-			move.l	VideoInfo.VRAMLogAddr32(a1),logVRAMBase32(a5)	; 24-bit logical VRAM addr
-			move.l	VideoInfo.VRAMLogAddr24(a1),logVRAMBase24(a5)	; 32-bit logical VRAM addr
-			move.l	#LCDMaxSize,VRAMrealSize(a5)	; set the size of video for phys space tbl	<17> HJR
-			lea		Jaws32,a0			;	use Jaws' 32 bit mode layout info
-			lea		Jaws24,a1			;	use Jaws' 24 bit mode layout info
-			
-			bra		@endSwitch			;	that's all folks
-			
-;---
-;	MSC:	Memory is always contiguous on MSC, and onboard video will always be on.  
-;---
-
-@MSC									; CASE MSC chip:									<t19>
-
-			movea.l	prodInfoPtr(a5),a0	;	get productInfo record in a0
-			move.l	a0,a1				;	get a copy in a1
-			adda.l	ProductInfo.VideoInfoPtr(a0),a1	; point to the VideoInfo record
-			move.l	VideoInfo.VRAMPhysAddr(a1),VRAMPhysBase(a5)	; initialize base of video RAM
-			move.l	VideoInfo.VRAMLogAddr32(a1),logVRAMBase32(a5)	; 24-bit logical VRAM addr
-			move.l	VideoInfo.VRAMLogAddr24(a1),logVRAMBase24(a5)	; 32-bit logical VRAM addr
-			lea		MSC32,a0			;	use MSC's 32 bit mode layout info
-			lea		MSC24,a1			;	use MSC's 24 bit mode layout info
-			
-			bra		@endSwitch			;	that's all folks
-			
-;---
-;	Niagra:	Memory is always contiguous on Niagra, and onboard video will always be on. 		<H8> 
-;																							through next <H8> 
-;---
-
-@Niagra									; 									
-
-			movea.l	prodInfoPtr(a5),a0	;	get productInfo record in a0
-			move.l	a0,a1				;	get a copy in a1
-			adda.l	ProductInfo.VideoInfoPtr(a0),a1	; point to the VideoInfo record
-			move.l	VideoInfo.VRAMPhysAddr(a1),VRAMPhysBase(a5)	; initialize base of video RAM
-			move.l	VideoInfo.VRAMLogAddr32(a1),logVRAMBase32(a5)	; 24-bit logical VRAM addr
-			move.l	VideoInfo.VRAMLogAddr24(a1),logVRAMBase24(a5)	; 32-bit logical VRAM addr
-			lea		Niagra32,a0			;	use Niagra' 32 bit mode layout info
-			lea		Niagra24,a1			;	use Niagra' 24 bit mode layout info
-			
-			bra		@endSwitch			;	that's all folks									<H8> 
-
-;---
-;	Pratt:	Memory is always contiguous on Pratt, and onboard video will always be on. 			<SM14> 
-;																							 
-;---
-
-@Pratt									; 									
-
-			movea.l	prodInfoPtr(a5),a0	;	get productInfo record in a0
-			move.l	a0,a1				;	get a copy in a1
-			adda.l	ProductInfo.VideoInfoPtr(a0),a1	; point to the VideoInfo record
-			move.l	VideoInfo.VRAMPhysAddr(a1),VRAMPhysBase(a5)	; initialize base of video RAM
-			move.l	VideoInfo.VRAMLogAddr32(a1),logVRAMBase32(a5)	; 24-bit logical VRAM addr
-			move.l	VideoInfo.VRAMLogAddr24(a1),logVRAMBase24(a5)	; 32-bit logical VRAM addr
-			lea		Pratt32,a0			;	use Niagra' 32 bit mode layout info
-			lea		Pratt24,a1			;	use Niagra' 24 bit mode layout info
-			
-			bra		@endSwitch			;	that's all folks									 
-
-;---
-;	FMC  - 	only weird case is bank B only.  For other cases, we previously merged
-;			everything into one bank starting at physical zero.  We can survive bank B
-;			only with the split model.
-;---
-
-@FMC									; CASE FMC chip:									<3.6>
-			lea		Contig32,a0			;   assume contig 32 bit mode layout info
-			lea		Contig24,a1			;   assume contig 24 bit mode layout info
-			tst.l	d2					;   check if RAM starts at physical zero
-			bne		@split				;   if not, we can live with split memory mode		<3.8>
-			bra		@endSwitch			;	  ...
-			
-
-;••• Begin <SM7> fau
-;---
-;	YMCA:	no weird cases.  
-;---
-
-@YMCA									; CASE YMCA chip:									
-			lea		YMCA32,a0			;	use YMCA's 32 bit mode layout info <LW2>
-			lea		YMCA24,a1			;	use YMCA's 24 bit mode layout info <LW2>
-			bra		@endSwitch			;	that's all folks
-;••• End <SM7> fau end
-
-;---
-;	MDU  -	if RBV present w/monitor attached,  deallocate video buffer from useable RAM 
-;			and make Bank B, if present, be low memory.
-;---
-
-@MDU									; CASE MDU chip:			
-
-			btst	#RBVExists,d6		;   check if RBV exists
-			beq		@split				;   IF RBV exists									<3.8>
-			movea.l	prodInfoPtr(a5),a0	;	get productInfo record in a0					<9>
-			move.l	a0,a1				;	get a copy in a1								<9>
-			adda.l	ProductInfo.VideoInfoPtr(a0),a1	; point to the VideoInfo record			<9>
-			move.l	VideoInfo.VRAMPhysAddr(a1),VRAMPhysBase(a5)	; initialize base of video RAM	<9>
-			move.l	VideoInfo.VRAMLogAddr32(a1),logVRAMBase32(a5)	; 24-bit log. VRAM addr	<9>
-			move.l	VideoInfo.VRAMLogAddr24(a1),logVRAMBase24(a5)	; 32-bit log. VRAM addr	<9>
-			cmpi.l	#RBVBase32b,logVRAMBase32(a5)		; check which slot video is in		<11>
-			adda.l	ProductInfo.DecoderInfoPtr(a0),a0	; point a0 to decoder info			<11>
-			bne.s	@slotE				; 	  IF RBV is in Slot B THEN						<11>
-			lea		RBV32b,a3			;   	point to RBV Slot B table					<11>
-			bra.s	@gotSlot			; 	  ELSE											<11>
-@slotE		lea		RBV32e,a3			;   	point to RBV Slot E table					<11>
-@gotSlot								; 	  ENDIF											<11>
-			bfextu	newtc(a3){8,4},d0	;     get # addr bits for pageSize					<11>
-			moveq	#0,d6				;     clear a reg
-			bset	d0,d6				;     get our pagesize
-			move.l	sgTotalRAM(a6),d0	;     get total amt memory (for GetRBVSize)			 <SM6> CSS
-			moveq	#0,d1				;     signal no rounding, we want the REAL size
-			move.l	RBVAddr(a0),a0		;     get addr of RBV hardware						<11>
-			movea.l	prodInfoPtr(a5),a2	;	  pass addr of productInfo record in a2			<3.0>
-			bsr		GetRBVSize			;     get actual video buffer size
-			move.l	d0,VRAMrealSize(a5)	;     save it for later								<9>
-			move.l	sgTotalRAM(a6),d0	;     get total amt memory (for GetRBVSize)			 <SM6> CSS
-			move.l	d6,d1				;     rounding factor = MMU page size
-			bigjsr	GetRBVSize,a4		;     get monitor size, rounded up to pagesize
-			move.l	d0,VRAMSize(a5)		;     save it for later								<9>
-			beq		@split				;     if no monitor, its easy!
-			tst.l	d2					;     check if any memory in Bank A
-			bne		@split				;     if no Bank A, its easy!
-			sub.l	d0,d3				;     subtract monitor size from bank A
-			move.l	d3,globChunks+4(a5)	;     update RAM chunk table
-			add.l	d0,d2				;     add monitor size to bank A start addr
-			move.l	d2,globChunks(a5)	;     update RAM chunk table
-			sub.l	d0,sgPhys2Log(a6)	;     adjust physical-to-logical conversion offset  <SM6> CSS
-			move.l	a3,a0				;     point to RBV table 							<11>
-
-			lea		globChunks+8(a5),a1	;	  get pointer to second chunk					<T23>
-			tst.l	sgEDiskStealFlag(a6);	  check for ram disk			 <SM6> CSS		  |	<SAM>
-			beq.s	@noRamDisk			;	  IF there is a ram disk THEN					  v
-			add.l	#8,a1				;		point at third chunk
-@noRamDisk								;	  ENDIF
-			tst.l	(a1)				;	  check for bank B								  ^
-			bmi.s	@noBankB			;     IF Bank B exists								  |
-		IF forRomulator THEN			;		•••Note: Romulator won't work with an Edisk	<T23>
-			TestInRam	A2				;		are we running in ram?						<3.8>
-			beq.s	@inROM				;		if not, skip this							<3.8>
-			BigLea	BaseOfRom,a2		; 		get current base of ROM						<3.8>
-			lsl.l	#1,d1				;		add an extra page to bootglobs				<3.8>
-			add.l	ROMHeader.RomSize(a2),d1 ;	increase size of bootglobs by ROM size		<3.8>
-@inROM									;
-		ENDIF							;													<3.8>
-			tst.l	sgEDiskStealFlag(a6);		check for ram disk							 <SM6> CSS <SAM>
-			bne.s	@ramDiskExists		;		IF there is no ram disk THEN
-			sub.l	d1,d5				;         decrement Bank B size by pagesize
-@ramDiskExists							;		ENDIF										<T23>
-			lea		globChunks(a5),a1	;       point at beginning of chunk table
-			move.l	d4,(a1)+			;		put Bank B (addr) first in Ram chunk table
-			move.l	d5,(a1)+			;		put Bank B (size) first in Ram chunk table
-			move.l	d2,(a1)+			;		put Bank A (addr) second in Ram chunk table
-			move.l	d3,(a1)+			;		put Bank A (size) second in Ram chunk table
-			tst.l	sgEDiskStealFlag(a6);		check for ram disk							<T23> <SM6> CSS <SAM>
-			bne.s	@noBankB			;		IF there is no ram disk THEN				<T23>
-			add.l	d5,d4				;         get addr of last <pagesize> chunk
-			move.l	d4,(a1)+			;         put addr last little chunk in table
-			move.l	d1,(a1)+			;         put size last little chunk in table
-			moveq	#-1,d4				;         get end of table marker
-			move.l	d4,(a1)+			;         put end marker in table
-			move.l	d4,(a1)+			;         put end marker in table
-										;		ENDIF										<T23> 
-@noBankB								;     ENDIF
-			move.l	#RBVBase24b,d2		; get the 24-bit video base address					<14>
-			move.l	logVRAMBase24(a5),d3 ; get the 24-bit video base addr for this machine	<14>
-			andi.l	#$ffffff,d2			; ensure these are 24-bit addrs... 					<14>
-			andi.l	#$ffffff,d3			; same here											<14>
-			cmp.l	d3,d2				; check which slot video is in						<14>
-			bne.s	@inSlotE			; IF RBV is in Slot B THEN							<11>
-			lea		RBV24b,a1			; 	point to RBV Slot B table						<11>
-			bra.s	@done				; ELSE												<11>
-@inSlotE	lea		RBV24e,a1			; 	point to RBV Slot E table						<11>
-@done									; ENDIF												<11>
-			bra.s	@endSwitch			;	  ...
-
-
-;---																						<12>
-;	VISA chip:	Generally, the VISA code is similar to the HMMU (that is, there isn't any
-;				hardware, and it doesn't do anything).  This code also whacks the ChunkTable
-;				to adjust for usage of RAM by the video system.  There's no possibility of 
-;				the split RAM case (big block in bank B), since there's no PMMU at all.
-;				
-; 				For Slice there is no on-board video so no need to allocate a video buffer.		<H22><SM13>
-;				All we need to do is allocate a 4k sound buffer.								<H22> <SM13>
-;---
-
-@VISA										; CASE VISA chip:
-			sub.l	#$00001000,sgAllocOff(A6)	; allocate 4k sound buffer					 	<H22><SM13>
-			lea		FstrFrms24,a1			; point to 24 bit MMU info table					<H18>
-			lea		FstrFrms32,a0			; point to 32 bit MMU info table					<H18>
-			bra		@endSwitch				;													<H22><SM13>
-
-@split									;   ELSE (no RBV, just split memory)
-			move.l	smallest(a5),d0		;     get size smallest chunk
-			bfffo	d0{0,0},d0			;     get 32-log2(size)
-			subq.w	#5,d0				;     normalize to 64 meg
-			muls.w	#-MMUSetupInfo.Size,d0;   compute offset from 64 meg entry
-			lea		(split64mb32,d0.w),a0;    return addr 32 bit mode layout
-			lea		Split24,a1			;     return split 24 bit mode layout info
-;fallThru	bra.s	@endSwitch			;	  ...
-
-@endSwitch								; ENDSWITCH
 			movem.l	(sp)+,FindRegs		; restore work registers
 			rts
 
-;-----
-;	MakePhysicalTable
-;
-;	Create the 'physical table' describing the significant portions of the physical
-;	address space.  Use the physical template to create the table.
-;
-;	The table is actually created into a buffer on the stack, then copied to space
-;	allocated below BootGlobals.
-;
-;	Entry
-;		a0 - points to 32 bit mode layout info
-;		a5 - points to InitMMU stack frame
-;		a6 - points to BootGlobs
-;
-;	Exit
-;		physical table created (in BootGlobs)
-;---
 
-MakPhysRegs	REG		a1-a2
-
-MakePhysicalTable
-
-			movem.l	MakPhysRegs,-(sp)			; save work registers
-			suba.w	#physBufSize,sp				; allocate buffer on stack
-			move.l	sp,a2						; save ptr to buffer start
-			move.l	a2,a1						; init buffer fill ptr
-			add.w	physicalOff(a0),a0			; scan ptr = addr physical template
-@loop											; LOOP for each entry
-			move.w	PhysicalSpaceBlock.usage(a0),d0;get template entry type
-			cmp.w	#kUsageEndTable,d0			;   check it
-			beq.s	@exitLoop					; >>EXITLOOP if end-of-table
-			cmp.w	#kUsageRAM,d0				;   check it again
-			bne.s	@notRam						;   IF its a RAM entry
-			bsr		doPhysRam					;     generate RAM entries
-			adda.w	#PhysicalSpaceBlock.size,a0	;     point at next template entry
-			bra.s	@loop						;     .
-@notRam		cmp.w	#kUsageROM,d0				;   ELSEIF its a ROM entry
-			bne.s	@notRom						;   .
-			bsr		doPhysRom					;     generate ROM entry
-			adda.w	#PhysicalSpaceBlock.size,a0	;     point at next template entry
-			bra.s	@loop						;     .
-@notRom											;   ELSE
-			moveq	#PhysicalSpaceBlock.size-1,d0;    prepare to copy entry to buffer
-@copy		move.b	(a0)+,(a1)+					;     LOOP - copy next byte
-			dbra	d0,@copy					;     REPEAT
-												;   ENDIF
-			bra.s	@loop						; REPEAT
-@exitLoop	
-			suba.l	a2,a1						; size = end - start
-			move.l	a1,d1						; save size of entries
-			addq.l	#PhysicalSpace.firstEntry-PhysicalSpace,a1 ; add in extra fields
-			move.l	a6,a0						; get ptr to BootGlobs
-			move.l	sgAllocOff(a6),d0			; get current allocation offset  <SM6> CSS
-			sub.l	a1,d0						; allocate space for physical table
-			move.l	d0,sgPhysicalTableOff(a6)	; save offset to physical table  <SM6> CSS
-			move.l	d0,sgAllocOff(a6)			; update allocation offset  <SM6> CSS
-			add.l	d0,a0						; get ptr to allocated table
-
-			move.l	d1,d0						; get total size of entries
-			divu	#PhysicalSpaceBlock.size,d0 ; # entries = (total size)/(entry size)
-			move.w	d0,(a0)+					; write # entries
-			move.w	#PhysicalSpaceBlock.size,(a0)+ ; write entry size
-			bra.s	@endCopy					; adjust for dbra
-@copyLoop	move.b	(a2)+,(a0)+					; LOOP - copy byte from buffer to final table
-@endCopy	dbra	d1,@copyLoop				; REPEAT for all bytes of entries in buffer
-			adda.w	#physBufSize,sp				; de-allocate buffer from stack
-			movem.l	(sp)+,MakPhysRegs			; restore registers
-			rts
-
-;-----
-;	doPhysRam - local subroutine of MakePhysicalTable to generate RAM entries in the
-;				physical table.
-;
-;	First, if onboard video uses some RAM, entries are generated for both the video
-;	and the wrap of the logical space before and afet the video buffer (to accomodate	<3.2>
-;	the Quickdraw bug of accessing a few bytes before and after the video buffer).		<3.2>
-;
-;	Then, a RAM entry is generated for each RAM chunk from our 'massaged' RAM chunk
-;	table.  The first RAM entry is marked as low memory, so VM knows where low
-;	memory really is.  We also duplicate the last entry, because we need to
-;	divide the last chunk into useable Ram and boot globals space.  Later we will
-;	go back and adjust the addesses and sizes to reflect the actual size of the
-;	boot globals/mmu tables area.
-;
-;	Entry
-;		a0 - points to physical template entry
-;		a1 - buffer fill ptr where physical table is being generated
-;		a2 - points to start of buffer
-;		a5 - points to InitMMU stack frame
-;		a6 - points to boot globs
-;
-;	Exit
-;		a1 - updated buffer fill ptr (after RAM entries are added)
-;		a0-a2 preserved
-;---
-
-doPhysRegs	REG		d2-d4/a3-a4
-
-doPhysRam	movem.l	doPhysRegs,-(sp)			; save registers
-			move.l	VRAMrealSize(a5),d0			; get exact onboard video size			<9>
-			beq.s	@doneVideo					; IF any onboard video
-
-			move.l	VRAMPhysBase(a5),d4			;	get physical base					<T11>
-
-			moveq	#kUsageOnboardVideo,d1		;   entry type = onboard video			<3.2, to end 3.2>
-			move.l	logVRAMBase32(a5),d2		;   logical 32 addr						<9>
-			move.l	logVRAMBase24(a5),d3		;	logical 24 addr						<T11>
-			bsr		@writeOne					;   create entry for real video buffer
-			
-			add.l	d0,d2						;   log 32 addr = end of video buffer
-			add.l	d0,d3						;   log 24 addr = end of video buffer	<T11>
-			move.l	#VidWrapSize,d0				;   size = size of wrap area			<9>
-			moveq	#kUsageOnboardVideoWrap,d1	;   entry type = onboard video WRAP
-			bsr.w	@writeOne					;   create entry for wrap area after video buffer <SM13>
-			
-			move.l	logVRAMBase32(a5),d2		;   wrap area before video buffer		<9>
-			sub.l	d0,d2						;   calculate start of wrap area		<9>
-			move.l	logVRAMBase24(a5),d3		;	logical 24 addr						<T11>
-			sub.l	d0,d3						;   calculate start of wrap area		<T11>
-			bsr.w	@writeOne					;   for wrap area before video buffer	<T11><SM13>
-
-@doneVideo										; ENDIF
-
-			tst.l	sgEDiskStealFlag(a6)		; check for ram disk	  <SM6> CSS	   <T11> <SAM>
-			beq.s	@doneEDisk					; IF any ram disk THEN					 |
-			move.l	#kUsageEDisk,d1				;	entry type = ram disk				 v
-			move.l	sgRamDiskBase(a6),d2		;	logical 32 base = from globals  <SM6> CSS
-			clr.l	d3							;	no access in 24-bit mode
-			lea		eDiskChunks(a5),a3			;	point at ram disk chunk table
-@eDiskLoop										;	LOOP (to write entries for eDisk chunks)
-			move.l	(a3)+,d4					;	  get chunk addr
-			move.l	(a3)+,d0					;	  get chunk size
-			cmp.l	#-1,d4						;	  check for end of chunks
-			beq.s	@doneEDisk					;	>>EXITIF done all ram disk chunks
-			bsr		@writeOne					;	  write a physical table entry
-			add.l	d0,d2						;	  bump up logical pointer			 ^
-			bra.s	@eDiskLoop					; 	REPEAT								 |
-@doneEDisk										; ENDIF									<T11>
-
-			moveq	#kUsageLowMemory,d0			; start w/type = low memory
-			lea		globChunks(a5),a3			; point at massaged RAM chunk table
-@ramLoop										; LOOP through RAM chunk table
-			movem.l	(a3)+,d1-d2					;   get chunk addr/size
-			cmp.l	#-1,d1						;   check for end of chunks
-			beq.s	@doneRam					; >>EXITIF done all RAM chunks
-			move.l	a1,a4						;   remember pointer to last RAM entry
-			move.w	d0,(a1)+					;   type = current type
-			move.w	#cacheable,(a1)+			;   attributes = cacheable
-			move.l	d1,(a1)+					;   physical addr = RAM chunk addr
-			move.l	d2,(a1)+					;   physical size = RAM chunk size
-			clr.l	(a1)+						;   logical 32 addr = (don't care)
-			clr.l	(a1)+						;   logical 32 size = (don't care)
-			clr.l	(a1)+						;   logical 24 addr = (don't care)
-			clr.l	(a1)+						;   logical 24 size = (don't care)
-			moveq	#kUsageRam,d0				;   next type = normal RAM
-			bra.s	@ramLoop					; REPEAT
-@doneRam	
-			move.l	a4,d0						; get ptr to last RAM chunk entry
-			sub.l	a2,d0						; buffer offset = ptr - start of buffer
-			addq.l	#PhysicalSpace.firstEntry-PhysicalSpace,d0 ; account for extra fields			
-			move.l	d0,lastPhysRam(a5)			; save offset to last RAM chunk entry
-			moveq	#PhysicalSpaceBlock.size-1,d0;prepare to copy last RAM chunk entry
-@copy		move.b	(a4)+,(a1)+					; LOOP - copy next byte
-			dbra	d0,@copy					; REPEAT
-
-			move.l	soundBufferSize(a5),d0		; is there a sound buffer on this machine?		<H25><SM13>
-			beq.s	@NoSoundBuffer				; -> nope, all done								<H25><SM13>
-			clr.w	(a1)+						;	entry type = other							<H25><SM13>
-			move.w	#notCacheable,(a1)+			;	attributes = notCacheable					<H25><SM13>
-			move.l	soundBufferBase(a5),(a1)+	;	physical addr = base of sound buffer		<H25><SM13>
-			move.l	d0,(a1)+					;	physical size = size of sound buffer		<H25><SM13>
-			clr.l	(a1)+						;   logical 32 addr = (don't care)				<H25><SM13>
-			move.l	d0,(a1)+					;   logical 32 size = size of sound buffer		<H28><SM13>
-			clr.l	(a1)+						;   logical 24 addr = (don't care)				<H25><SM13>
-			move.l	d0,(a1)+					;   logical 24 size = size of sound buffer		<H28><SM13>
-@NoSoundBuffer									;												<H25><SM13>
-			movem.l	(sp)+,doPhysRegs			; restore regs
-			rts
-
-;------
-; mini-routine to write a non-cached physical space entry
-;	d0 - size
-;	d1 - entry type
-;	d2 - logical 32 addr
-;	d3 - logical 24 addr
-;	d4 - physical addr
-;	a1 - pointer to next free entry
-;------
-@writeOne	move.w	d1,(a1)+					;   write out entry type
-			move.w	#notCacheable,(a1)+			;   attributes = notCacheable			<T11>
-			move.l	d4,(a1)+					;   physical addr = video base addr		<T11>
-			move.l	d0,(a1)+					;   physical size
-			move.l	d2,(a1)+					;   logical 32 addr
-			move.l	d0,(a1)+					;   logical 32 size
-			move.l	d3,(a1)						;   logical 24 addr
-			andi.l	#$00FFFFFF,(a1)+			;   strip high byte of 24 bit addr
-			move.l	d0,(a1)+					;   logical 24 size
-			rts
-
-
-;-----
-;	doPhysRom - local subroutine of MakePhysicalTable to generate the Rom entry in the
-;				physical table.
-;
-;	The physical address in the entry is the physical address of the ROM image, which might 
-;	be in RAM if we are using Romulator™.  The size is obtained from the Rom header.
-;
-;	Entry
-;		a0 - points to physical template entry
-;		a1 - buffer fill ptr where physical table is being generated
-;		a2 - points to start of buffer
-;		a5 - points to InitMMU stack frame
-;
-;	Exit
-;		a1 - updated buffer fill ptr (after RAM entries are added)
-;		a0-a2 preserved
-;---
-
-doPhysRom	exg		a3,d1						; save register
-			move.w	PhysicalSpaceBlock.usage(a0),(a1)+				; <SM1> CSS get usage type								<H18>																
-			move.w	PhysicalSpaceBlock.attributes(a0),(a1)+			; <SM1> CSS get the attributes							<H18>
-			move.l	PhysicalSpaceBlock.physical.rangeSize(a0),d0	; <SM1> CSS 											<H18>
-			cmpi.l	#$10000000,d0									; <SM1> CSS is the size 256MB ?							<H18>
-			
-			bne.s	@doNew								; <SM1> CSS if 256MB then generate ROM entry the old way otherwise get<H18>
-;														; <SM1> CSS actual values from the physical space template										
-			biglea	BaseOfRom,a3				; get physical addr Rom image
-			move.l	a3,(a1)+					; physical addr = image addr
-			move.l	RomHeader.RomSize(a3),d0	; get Rom image size from header
-			move.l	d0,(a1)+					; physical size = image size
-			exg		a3,d1						; restore reg
-			move.l	logRomBase(a5),d1			; get logical addr ROM
-			move.l	d1,(a1)+					; logical 32 addr
-			move.l	d0,(a1)+					; logical 32 size...
-			and.l	#$FFFFFF,d1					; get 24 bit mode address of ROM
-			move.l	d1,(a1)+					; logical 24 addr...
-			move.l	d0,(a1)+					; logical 24 size...
-			
-			bra.s	@done								; <SM1> CSS 															<H18>
-
-@doNew		move.l	PhysicalSpaceBlock.physical.address(a0),(a1)+		; <SM1> CSS get the physical address of the rom bank 	<H18>			
-			move.l	d0,(a1)+											; <SM1> CSS physical size of rom image from template	<H18>
-			move.l	PhysicalSpaceBlock.logical.address(a0),(a1)+		; <SM1> CSS get the logical 32 bit Rom bank address	<H18>
-			move.l	PhysicalSpaceBlock.logical.rangesize(a0),(a1)+		; <SM1> CSS get the logical 32 bit Rom bank size		<H18>
-			move.l	PhysicalSpaceBlock.logical24.address(a0),(a1)+		; <SM1> CSS get the logical 24 bit Rom bank address	<H18>
-			move.l	PhysicalSpaceBlock.logical24.rangesize(a0),(a1)+	; <SM1> CSS get the logical 32 bit Rom bank size		<H18>
-		
-@done		exg		a3,d1												; <SM1> CSS restore reg								<H18>
-			rts
-
-;-----
-;
-;   MakeTable - creates an MMU table. 
-;
-;	First an intermediate table is generated, given the installed RAM and the desired
-;	logical map.  Then the final MMU table entries are generated from the intermediate table.
-;
-;   The intermediate table entries are formatted as follows:
-;
-;		 31								8 7 6 5 43 2 10
-;		+--------------------------------+-+-+-+--+-+--+
-;		| page address or table limit    |0|c|0|xx|0|yy|
-;		+--------------------------------+-+-+-+--+-+--+
-;			c  - cache inhibit bit (one if cache should be inhibited, zero if not)
-;			xx - level in table.  Level one corresponds to TIA, four to TID
-;			yy - descriptor type
-;
-;	Each intermediate entry corresponds to some piece of the logical address space.  For 
-;	instance, if the tc specifies 16 TIA entries, there would be 16 level 1 entries.
-;
-;	The intermediate entry is generated to allow easy creation of the final MMU table.
-;	Entries for the same level are laid out consecutively until it is determined that
-;	a deeper level is needed, or until the entire address space for that level has been
-;	covered.
-;
-;	If a deeper level is needed, entries are laid out for that deeper level, followed
-;	by an entry for the parent level with a descriptor type of 'table'.  The sequence
-;	of levels for a tc w/16 TIA entries, xx TIB entries, yy TIC entries might look like:
-;
-;		1111223333...322..2111111111111
-;					  |    | - level 1 'table' entry, possible w/limit for the preceeding run
-;					  | 	   of level 2's
-;					  |
-;					  | - level 2 'table' entry, possibly w/limit
-;
-;	In the above example, the level 2's even had a nested level 3 table!
-;
-;	Entry:	a0 points to table layout info
-;			a5 points to InitMMU stack frame
-;
-;   Exit:	a0 points to created table
-;			d0 has 1st longword of CRP
-;-----
-
-tableSize	EQU		$30000				; get 192k of space for intermediate table			<7>
-
-MakeFrame	RECORD	{prevLink},DECR
-Return		ds.l	1					; return addr
-prevLink	ds.l	1					; previous value of link register
-mmuSetupPtr	ds.l	1					; ptr to mmu setup information
-templatePtr	ds.l	1					; pointer to template
-logicalAddr	ds.l	1					; current logical address
-genPtr		ds.l	1					; ptr into "intermediate form" table
-ramChunks	ds.l	sgMaxChunks*2		; space for copy of RAM chunks (addr/size) (last addr -1)  <SM6> CSS
-eDskChunks	ds.l	sgMaxChunks*2		; space for copy of edisk chunks (addr/size) (last addr -1) <T11>  <SM6> CSS
-vidAddr		ds.l	1					; video chunk addr (get bumped up as allocated)
-vidSize		ds.l	1					; video chunk size (gets bumped down as allocated)
-doWrap24	ds.w	1					; true if we need to wrap tables for 24-bit mode	<7>
-intermedTbl	ds.l	1					; start of intermediate table						<7>
-makeLocSize	equ		*					; size of locals
-			ENDR
-
-NoLimit		equ		$7FFF0000			; what to stuff in limit field when there is no limit
-			
-			WITH	MakeFrame
-
-MakeTable	
-MakeRegs	REG		d2/a1
-			link	a4,#makeLocSize-tableSize	; set up stack frame						<7>
-			movem.l	MakeRegs,-(sp)		; save registers
-			
-			move.l	a0,mmuSetupPtr(a4)	; save ptr to MMU setup info
-			move.w	templOff(a0),d0		; get offset to normal template
-			btst.b	#mmHighSysHeap,sgMMFlags(a6) ; check if creating map w/huge void   <SM6> CSS
-			beq.s	@haveTempl			; IF we are 
-			move.w	specialOff(a0),d0	;   get offset to special template
-@haveTempl	add.w	d0,a0				; ENDIF - add in template offset
-			move.l	a0,templatePtr(a4)	; save ptr to template
-
-			lea		globChunks(a5),a0	; source = ram chunk table from InitMMU globals
-			lea		ramChunks(a4),a1	; destination = our local copy
-			bsr.s	CopyChunks			; get a local copy of chunk table
-			
-			lea		eDiskChunks(a5),a0	; source = ram disk chunk table from globals		<T11>
-			lea		eDskChunks(a4),a1	; destination = our local copy						<T11>
-			bsr.s	CopyChunks			; get a local copy of chunk table					<T11>
-			move.l	VRAMPhysBase(a5),vidAddr(a4) ; get local copy of base of video RAM		<9>
-			move.l	VRAMSize(a5),vidSize(a4) ; get local copy of size of video buffer		<9>
-			
-			bsr.s	IntermediateTable	; make the intermediate table
-			bsr		FinalTable			; make the final MMU tables
-			
-			movem.l	(sp)+,MakeRegs		; restore registers
-			unlk	a4					; deallocate stack frame
-			rts
-
-;-----
-;	IntermediateTable - wrapper routine for creating the intermediate form table.
-;
-;	The table is created using two mutually recursive routines, DoLevel and DoNode.
-;	DoLevel is responsible for creating all nodes at a given level.  It calls DoNode
-;	to create each node.
-;
-;	DoNode attempts to create a node at the current level.  If it determines that a node
-;	can be created at the current level (a contiguous physical space is possible for the
-;	current logical address mapping and the span of the current level), it quickly does so 
-;	and returns.  Otherwise, a lower level table is neccessary, and it calls DoLevel to
-;	create the lower level entries in the intermediate table.
-;
-;	This routine simply sets up for generating nodes at the top level, and calls DoLevel.
-;	Before returning, it appends a dummy level zero node to the end of the intermediate
-;	table, to make generating the final MMU tables easier.
-;
-;	Entry:
-;		a4 - points to MakeTable stack frame
-;
-;---
-
-IntermediateTable
-			move.l	d2,-(sp)			; save work reg
-			lea		intermedTbl(a4),a0	; get ptr to where intermediate table will go
-			move.l	a0,genPtr(a4)		; save ptr to intermediate table
-			clr.l	logicalAddr(a4)		; start at logical address zero
-			clr.w	doWrap24(a4)		; assume generating for 32-bit mode				<7>
-			moveq	#1,d0				; start at level one
-			bsr.s	DoLevel				; create level 1 (and higher!) intermediate table
-			moveq	#0,d2				; signal writing table node for level zero
-			bsr		WriteTableNode		; write the final table node
-			move.l	(sp)+,d2			; restore work reg
-			rts
-
-;-----
-;	DoLevel - create intermediate table entries for a given level of the MMU tree.
-;
-;	Entry:
-;		d0.w - the level
-;---
-
-DoLevelRegs	REG		d2-d4
-DoLevel		movem.l	DoLevelRegs,-(sp)	; save regs
-			move.w	d0,d2				; save level of interest
-			bsr		SpanAndCount		; d0 = span, d1 = count of entries at this level
-			move.l	d0,d3				; save span
-			move.l	d1,d4				; save count
-			bra.s	@endLoop			; adjust loop count for dbra
-@loop									; LOOP count times
-			bsr.s	DoNode				;   create next node
-@endLoop	dbra	d4,@loop			; REPEAT
-			movem.l	(sp)+,DoLevelRegs	; restore regs
-			rts
-
-;-----
-;	DoNode - create a node in the intermediate table, given the current table level and
-;			 logical address.
-;
-;	Entry:
-;		d2.w - level
-;		d3   - span of this level (passed in for convenience, could be recomputed here)
-;		a4	 - points to MakeTable stack frame
-;---
-
-DoNode		bsr.s	PageAddr			; a0 = page address, d0 = type, d1 = cache inhibit flag
-			move.b	@casetbl(d0),d0		; get offset to routine to handle type
-			jmp		@casetbl(d0.w)		; SWITCH(type)
-@casetbl	dc.b	@valid-@casetbl		; .
-			dc.b	@invalid-@casetbl	; .
-			dc.b	@noFit-@casetbl		; .
-			dc.b	@endCase-@casetbl	; .
-			ALIGN	2					; .
-@valid									;   CASE(type = valid)
-			bsr		WritePageNode		;     write page node(level, page addr, cache flag)
-			bra.s	@endCase			;     ...
-@invalid								;   CASE(type = invalid)
-			bsr		WriteInvalidNode	;     write invalid node(level)
-			bra.s	@endCase			;     ...
-@noFit									;   CASE(type = didn't fit)
-			bsr		CanGoDeeper			;     see if we can go to next level
-			beq.s	@noDeeper			;     IF we can
-			move.w	d2,d0				;       recall level
-			addq.w	#1,d0				;       bump to next level
-			bsr.s	DoLevel				;       make entries at next level
-			bsr		WriteTableNode		;       write a table node (level)
-			bra.s	@endCase			;       ...
-@noDeeper								;     ELSE
-			bsr		WriteInvalidNode	;       write invalid node (level)
-										;     ENDIF
-;fallthru	bra.s	@endCase			;     ...
-@endCase								; ENDSWITCH
-			rts
-
-;-----
-;	PageAddr - given logical address and level span, return information about the physical
-;              page where it will map to
-;
-;	Entry:
-;		a4 - points to MakeTable stack frame
-;		a5 - points to InitMMU stack frame <3.2>
-;		d2.w - level
-;		d3   - span of this level (passed in for convenience, could be recomputed here)
-;
-;	Exit
-;		d0.w - type (0 = valid page, 1 = invalid page, 2 = didn't fit)
-;		d1.w - cache inhibit flag in bit 6
-;		a0   - page address
-;---
-
-			WITH	Template
-PageRegs	REG		d3-d5
-PageAddr	movem.l	PageRegs,-(sp)		; save regs
-			move.l	templatePtr(a4),a0	; get ptr to template table
-			moveq	#0,d5				; template logical address = zero
-			move.l	logicalAddr(a4),d0	; get our current logical addr
-@loop									; LOOP
-			move.l	span(a0),d1			;   get chunk size
-			move.l	d0,d4				;   recall our current logical address
-			sub.l	d5,d4				;   get offset from start of template chunk
-			cmp.l	d4,d1				;   check if we're in this chunk's range
-			bhi.s	@exitLoop			; >>EXITLOOP if logical addr falls in this chunk
-			add.l	d1,d5				;   bump template chunk address by size this chunk
-			addq.l	#tEntrySize,a0		;   point at next template entry
-			bra.s	@loop				; REPEAT
-@exitLoop								; at this point: a0 -> template entry, 
-										; d1 = template chunk size, d2 -> bottom of chunk,
-										; d3 = level span, d4 = our offset from bottom of chunk
-			move.l	d3,d0				; save level span
-			add.l	d4,d3				; get offset + span
-			cmp.l	d3,d1				; check against size of chunk
-			bhs.s	@fits				; IF logical span doesn't fit in template chunk
-			moveq	#2,d0				;   returned type = "doesn't fit"
-			bra		@done				;   EXITROUTINE
-@fits									; ENDIF
-			move.l	physNflag(a0),d3	; get phys addr/flags word						<7>
-			move.l	d3,d5				; copy for getting type bits					<7>
-			and.l	#typeMask,d5		; mask all except type bits						<7>
-			move.b	@casetbl(d5),d5		; get offset to routine to handle type
-			jmp		@casetbl(d5.w)		; SWITCH(type)
-@casetbl	dc.b	@thru-@casetbl		; .
-			dc.b	@ram-@casetbl		; .
-			dc.b	@rom32-@casetbl		; .
-			dc.b	@rom24-@casetbl		; .
-			dc.b	@vidWrap-@casetbl	; .
-			dc.b	@video-@casetbl		; .
-			dc.b	@mapped-@casetbl	; .
-			dc.b	@Void-@casetbl		; .
-			dc.b	@wrap24-@casetbl	; .												<7>
-			dc.b	@vram-@casetbl		; .												<9>
-			dc.b	@eDisk-@casetbl		; .												<T11>
-
-			ALIGN	2					; .
-@thru									;   CASE(pass thru)
-			move.l	logicalAddr(a4),a0	;     page address = current logical address
-			bra.s	@valid				;     returned type = "valid page"
-@ram									;   CASE(ram)
-			bsr.w	GrabRam				;     allocate from RAM chunks, return type, page addr
-			bra.s	@endSwitch			;     ...
-@wrap24									;	CASE(24-bit wrap area)						<7>
-			move.w	#1,doWrap24(a4)		;	  fall through, and mark "invalid"			<7>
-@Void									;   CASE(void in the middle of RAM)
-			moveq	#1,d0				;     mark page as "invalid"
-			bra.s	@endSwitch			;     ...
-@rom32									;   CASE(rom, 32 bit mode)
-			move.l	physRomBase(a5),d0	;     assume running in ROM (use real h/w address)<H12>
-			cmp.w	#cpu68040,d7		; Check whether or not we're on an 040			<H12>
-			beq.s	@nomask				; IF NOT on a 68040 THEN						<H12>
-			btst.l	#FullTblBit,d3		; Check if we want full MMU tables for this block<H12>
-			bne.s	@nomask				; 	IF Full Tables NOT wanted then				<H12>
-			and.l	#$ff000000,d0		;		mask to just use high byte of phys addr	<H12>
-@nomask		move.l	d0,a0				;	ENDIF										<H12>
-			bra.s	@romCommon			;     (continue w/common code)					<H12>
-
-@rom24									;   CASE(rom, 24 bit mode)						<H12>
-			move.l	physRomBase(a5),a0	;     assume running in ROM (use phys addr)		<H12>
-
-@romCommon	
-		IF forRomulator THEN			;												<3.7>
-			biglea	BaseOfROM,a0		;       point to start of ROM image in RAM
-		ENDIF							;												<3.7>
-@gotROM									;     ENDIF
-			add.l	d4,a0				;     returned page addr = start of ROM + offset from
-										;     .start of template chunk
-			bra.s	@valid				;     returned type = "valid page"
-@vidWrap								;   CASE(wrap to start of video)
-			move.l	VRAMPhysBase(a5),a0	;     get physical base of video buffer			<9>
-			bra.s	@valid				;     ...
-@video									;   CASE(video)
-			bsr		GrabVideo			;     allocate from vRAM chunks, return type, page addr
-			bra.s	@endSwitch			;     ...
-@vram									;	CASE(vram)									<9>
-			move.l	VRAMPhysBase(a5),a0	;	  get physical base of video RAM			<9>
-;			adda.l	d4,a0				;	  returned page addr = start + offset		<T11>
-			bra.s	@valid				;	  ...										<9>
-@eDisk									;	CASE(ram disk)								<T11>
-			bsr		GrabEdisk			;     allocate from eDisk chunks, return type, page addr
-			bra.s	@endSwitch			;	  ...										<T11>
-@mapped									;   CASE(mapped)
-			move.l	d3,d0				;     get phys addr/flags word
-			and.l	#physMask,d0		;     mask all except suggested physical addr	<7>
-			move.l	d0,a0				;     returned page addr = suggested phys addr	<7>
-			add.l	d4,a0				;     .plus offset from start of template chunk
-@valid		moveq	#0,d0				;     returned type = "valid page"
-;fallThru	bra.s	@endSwitch			;     ...
-
-@endSwitch								; ENDSWITCH
-			cmp.w	#cpu68040,d7		; Check whether or not we're on an 040			<7>
-			beq.s	@on040				; IF NOT on a 68040 THEN						<7>
-			btst.l	#FullTblBit,d3		; Check if we want full MMU tables for this block<H12>
-			beq.s	@term				; 	IF Full Tables wanted then					<H12>
-			and.l	#cBitMask,d3		; 		get cache inhibit bit					<H12>
-			bra.s	@fullTables			; 		check table level						<H12>
-										;	ELSE
-@term		and.l	#cBitMask,d3		;   get cache inhibit bit						<7><H12>
-			bra.s	@setCache			; ELSE											<7><H12>
-@on040		and.l	#c040ModeMask,d3	;   get cache mode bits							<7>
-
-@fullTables	bsr.w	CanGoDeeper			;   check if we are at the lowest Level			<7><H12>
-			beq.s	@setCache			; >>EXITROUTINE if NOT on lowest level 			<7><H12>
-			cmp.w	#0,d0				;   check if we would have returned valid		<7>
-			bne.s	@setCache			; >>EXITROUTINE if NOT returning valid			<7>
-			moveq	#2,d0				;   can't have a page descriptor yet, return "doesn't fit" <7>
-@setCache								; ENDIF											<7>
-			lsl.l	#6-cBitNum,d3		; move it into position							<7>
-			move.w	d3,d1				; return it
-	
-@done		movem.l	(sp)+,PageRegs		; restore regs
-			rts
-			
-			ENDWITH						; {Template}
-
-
-;-----
-;	GrabRAM - allocate some space from the chunks of RAM.
-;
-;	The procedure scans the chunks, looking for one that has a non-zero size.
-;	It then determines whether the allocation amount fits in that chunk.  No attempt
-;	is made to look at other chunks (if it doesn't fit in the first non-zero sized one)
-;	in order to preserve the ordering present in the chunk table.
-;
-;   Entry:
-;		a4 - ptr to MakeTable stack frame
-;		d0 - amount to allocate
-;		d2.w - level
-;		d3 - phys addr/flags
-;
-;	Exit:
-;		a0 - ptr to the RAM chunk
-;		d0 - type, as follows:
-;				zero:	valid (allocation was successful)
-;				one:	invalid (no RAM available)
-;				two:	didn't fit (requested size didn't fit in first available chunk)
-;
-;		if successful, RAM chunk's size reduced by allocation amount.
-;
-;   Trashes
-;		d1
-;---
-
-GrabRAM		lea		ramChunks(a4),a0	; point at table of RAM chunks
-			move.l	d0,d1				; save allocation amt
-			moveq	#1,d0				; assume returning "invalid" (no RAM available)
-@loop		cmp.l	#-1,(a0)+			; LOOP while more chunks
-			beq.s	@done				; >>EXITROUTINE if no more chunks
-			tst.l	(a0)+				;   check size of chunk
-			beq.s	@loop				; REPEAT while nothing in this chunk
-			moveq	#2,d0				; assume returning "didn't fit"
-			cmp.l	-4(a0),d1			; check size versus desired size
-			bhi.s	@done				; IF chunk is big enough
-
-			cmp.w	#cpu68040,d7		;   Check whether or not we're on an 040			<H12>
-			beq.s	@fulltbl				;   IF on a 68040 THEN							<H12>
-
-			btst.l	#FullTblBit,d3		; Check if we want full MMU tables for this block	<H12>
-			beq.s	@term				; 	IF Full Tables wanted then						<H12>
-
-@fulltbl	bsr.w	CanGoDeeper			;	  check if on lowest level						<7><H12>
-			bne.s	@valid				;   >>EXITROUTINE if we're not on lowest level		<7>
-										;	ENDIF											<7>
-@term		move.l	-8(a0),d0			;     page addr =  start addr chunk					<H12>
-			add.l	d1,-8(a0)			;     increment start addr by allocation amt
-			sub.l	d1,-4(a0)			;     decrement chunk size by allocation amt
-			move.l	d0,a0				;     return page addr
-@valid		moveq	#0,d0				;     returned type = "valid"
-@done									; ENDIF
-			rts
-
-
-;-----
-;	GrabVideo - allocate some space from the RAM allocated to video
-;
-;   Entry:
-;		a4 - ptr to MakeTable stack frame
-;		a5 - points to InitMMU stack frame 													<3.2>
-;		d0 - amount to allocate
-;		d2.w - level
-;		d3 - phys addr/flags
-;
-;	Exit:
-;		If requested size didn't fit in video RAM chunk
-;			d0 - two (didn't fit)
-;			a0 - undefined
-;		If all video RAM already allocated
-;			d0 - zero (valid page)
-;			a0 - base of video RAM (makes end of buffer wrap to start) 						<3.2>
-;		If requested size successfully allocated from video RAM chunk
-;			d0 - zero (valid page)
-;			a0 - allocated RAM chunk addr
-;			video RAM chunk's size reduced by allocation amount.
-;
-;   Trashes
-;		d1
-;---
-
-GrabVideo	move.l	d0,d1				; save allocation amt
-			move.l	VRAMPhysBase(a5),a0	; assume no vRAM left, wrap to physical buffer base	<9>
-			tst.l	vidSize(a4)			; check remaining video RAM
-			beq.s	@valid				; EXITROUTINE w/valid if none left					<3.2>
-			moveq	#2,d0				; assume returning "didn't fit" (not enuf video RAM left)
-			cmp.l	vidSize(a4),d1		; check if there is enough
-			bhi.s	@done				; EXITROUTINE if not enough left
-
-			cmp.w	#cpu68040,d7		;   Check whether or not we're on an 040			<H12>
-			beq.s	@fulltbl				;   IF on a 68040 THEN							<H12>
-
-			btst.l	#FullTblBit,d3		; Check if we want full MMU tables for this block	<H12>
-			beq.s	@term				; 	IF Full Tables wanted then						<H12>
-
-@fulltbl	bsr.s	CanGoDeeper			;	  check if we'er on the lowest level			<7><H12>
-			bne.s	@valid				;   >>EXITROUTINE if we're not on lowest level		<7>
-										;	ENDIF											<7>
-@term		move.l	vidAddr(a4),a0		; return ptr to video RAM chunk						<H12>
-			add.l	d1,vidAddr(a4)		; bump video addr by allocation amt
-			sub.l	d1,vidSize(a4)		; decrease remaining size by allocation amt
-@valid		moveq	#0,d0				; return "valid"									<3.2>
-@done		rts
-
-
-;-----
-;	GrabEdisk - allocate some space from the RAM allocated to the RAM disk
-;
-;	The procedure scans the chunks, looking for one that has a non-zero size.
-;	It then determines whether the allocation amount fits in that chunk.  No attempt
-;	is made to look at other chunks (if it doesn't fit in the first non-zero sized one)
-;	in order to preserve the ordering present in the chunk table.
-;
-;   Entry:
-;		a4 - ptr to MakeTable stack frame
-;		d0 - amount to allocate
-;		d2.w - level
-;		d3 - phys addr/flags
-;
-;	Exit:
-;		a0 - ptr to the RAM disk chunk
-;		d0 - type, as follows:
-;				zero:	valid (allocation was successful)
-;				one:	invalid (no RAM available)
-;				two:	didn't fit (requested size didn't fit in first available chunk)
-;
-;		if successful, RAM disk chunk size reduced by allocation amount.
-;
-;   Trashes
-;		d1
-;---
-GrabEdisk
-			lea		eDskChunks(a4),a0	; point at table of eDisk chunks
-			move.l	d0,d1				; save allocation amt
-			moveq	#1,d0				; assume returning "invalid" (no RAM available)
-@loop		cmp.l	#-1,(a0)+			; LOOP while more chunks
-			beq.s	@done				; >>EXITROUTINE if no more chunks
-			tst.l	(a0)+				;   check size of chunk
-			beq.s	@loop				; REPEAT while nothing in this chunk
-			moveq	#2,d0				; assume returning "didn't fit"
-			cmp.l	-4(a0),d1			; check size versus desired size
-			bhi.s	@done				; IF chunk is big enough
-
-			cmp.w	#cpu68040,d7		;   Check whether or not we're on an 040			<H12>
-			beq.s	@fulltbl				;   IF on a 68040 THEN							<H12>
-
-			btst.l	#FullTblBit,d3		; Check if we want full MMU tables for this block	<H12>
-			beq.s	@term				; 	IF Full Tables wanted then						<H12>
-
-@fulltbl	bsr.s	CanGoDeeper			;	  check if we'er on the lowest level			<7><H12>
-			bne.s	@valid				;   >>EXITROUTINE if we're not on lowest level		<7><H12>
-										;	ENDIF											<7>
-@term		move.l	-8(a0),d0			;     page addr =  start addr chunk
-			add.l	d1,-8(a0)			;     increment start addr by allocation amt
-			sub.l	d1,-4(a0)			;     decrement chunk size by allocation amt
-			move.l	d0,a0				;     return page addr
-@valid		moveq	#0,d0				;     returned type = "valid"
-@done									; ENDIF
-			rts
-
-
-;-----
-;	CanGoDeeper - check if we can generate tables at at next level
-;
-;	Entry:
-;		d2.w - current level
-;		a4   - points to MakeTable stack frame
-;
-;	Exit
-;		Z flag - ne if we can, eq if we can't
-;
-;	Trashes
-;		none
-;---
-
-DeeperRegs	REG		d0/a0				;													<H12>
-
-CanGoDeeper	
-			movem.l	DeeperRegs,-(sp)	;save working registers								<H12>
-			cmp.w	#cpu68040,d7		; Check whether or not we're on an 040				<7>
-			bne.s	@not040				; IF on a 68040 THEN								<7>
-
-			cmp.w	#3,d2				;   third level is the deepest we can go			<7>
-			bra.s	@done				; ELSE												<7>
-@not040		cmp.w	#4,d2				;   fourth level is the deepest we can go			<7>
-@1			beq.s	@done				;   >>EXITROUTINE w/failure if at deepest level		<7>
-			clr.l	d0					;   so not to mess up bfextu down below				<7>
-			move.w	d2,d0				;   get level
-			addq.w	#1,d0				;   get next level
-			lsl.w	#2,d0				;   multiply by four (= TIx field size)
-			add.w	#12,d0				;   get offset to TIx field
-			move.l	mmuSetupPtr(a4),a0	;   get ptr to MMU setup info
-			bfextu	newtc(a0){d0,4},d0	;   get TIx field for next level (eq if no TIx bits)
-@done									; ENDIF												<7>
-			movem.l	(sp)+,DeeperRegs	; restore regs								<H12>
-			rts			
-
-
-;-----
-;	WritePageNode - write a page node to the intermediate table.
-;
-;	Entry:
-;		d1.w - cache inhibit flag
-;		d2.w - current level
-;		d3.l - logical address span of the node
-;		a0   - page address
-;		a4   - points to MakeTable stack frame
-;
-;	Trashes:
-;		d0/a0
-;---
-
-WritePageNode	
-			moveq	#0,d0				; clear a reg
-			move.w	d2,d0				; get the level
-			lsl.w	#3,d0				; shift level into place
-			or.w	d1,d0				; factor in the cache inhibit flag
-			add.l	a0,d0				; lay in the page address
-			addq.w	#descrPage,d0		; set type = 'page'
-AdvAndWrite	add.l	d3,logicalAddr(a4)	; logical address += span of this entry
-WriteNode	move.l	genPtr(a4),a0		; get ptr to next intermediate table entry
-			move.l	d0,-(a0)			; put entry into intermediate table					<7>
-			move.l	a0,genPtr(a4)		; save ptr to next entry
-			rts
-
-
-;-----
-;	WriteInvalidNode - write an invalid page node to the intermediate table.
-;
-;	Entry:
-;		d2.w - current level
-;		d3.l - logical address span of the node
-;		a4   - points to MakeTable stack frame
-;
-;	Trashes:
-;		d0/a0
-;---
-
-WriteInvalidNode	
-			moveq	#0,d0				; clear a reg
-			move.w	d2,d0				; get the level
-			lsl.w	#3,d0				; shift level into place
-										; NOTE: invalid type = 0, so its already there
-			bra.s	AdvAndWrite			; advance logical address, write node to 
-										; .intermediate table & EXIT
-
-
-;-----
-;	WriteTableNode - write a table node to the intermediate table.
-;
-;	Entry:
-;		d2.w - level
-;		a4   - points to MakeTable stack frame
-;
-;	Trashes:
-;		d0/a0
-;---
-
-WriteTableNode	
-			cmp.w	#cpu68040,d7		; Check whether or not we're on an 040				<7>
-			bne.s	@not040				; IF on a 68040 THEN								<7>
-
-			movea.l	#NoLimit,a0			;   we don't have limit fields						<7>
-			bra.s	@1					; ELSE												<7>
-@not040		bsr.s	Limit				;   get limit field
-										; ENDIF												<7>
-@1			moveq	#0,d0				; clear a reg
-			move.w	d2,d0				; get the level
-			lsl.w	#3,d0				; shift level into place
-			tst.w	a0					; check if low word of a0 is nonzero				<T23>
-			bne.s	@doWrite			; IF it is clear THEN								<T23>
-			addq.w	#descrTbl4,d0		;	set type to '4 byte table descriptor'
-			add.l	a0,d0				;	factor in the limit field
-			or.w	#LongStat,d0		;	put in rest of status field
-@doWrite	bra.s	WriteNode			;	write node to intermediate table & EXIT
-										; ENDIF
-
-;-----
-;	Limit - given current level, looks backwards in intermediate table to see if
-;			a limit can be used on the next deeper level.  
-;
-;	If limit is possible, entries are shifted in the table to get rid of any entries
-;	made obsolete by the limit.
-;
-;	Entry:
-;		d2.w - current level
-;		a4   - points to MakeTable stack frame
-;
-;	Exit:
-;		a0 - limit field
-;---
-
-Limit		move.l	d3,-(sp)			; save work reg
-			bsr.s	CountLeading		; get # leading invalid entries at next level
-			move.w	d0,d3				; save it
-			bsr.s	CountTrailing		; get # trailing invalid entries at next level
-			move.w	d0,d1				; save it
-			or.w	d3,d0				; check for both zero
-			bne.s	@yesLimit			; IF no leading OR trailing invalids
-			movea.l	#NoLimit,a0			;   no limit!
-			bra.s	@haveLimit			;   .
-@yesLimit	cmp.w	d1,d3				; ELSEIF more trailing than leading
-			bhi.s	@doLeading			; .
-			move.w	d1,d0				;   recall # trailing invalids
-			bsr.s	HandleTrailing		;   handle upper limit case
-			bra.s	@haveLimit			;   .
-@doLeading								; ELSE
-			move.w	d3,d0				;   recall # leading invalids
-			bsr.s	HandleLeading		;   handle lower limit case
-@haveLimit								; ENDIF
-			move.l	(sp)+,d3			; restore work reg
-			rts
-
-;-----
-;	CountLeading - count the number of leading invalid entries for the next lower level.
-;
-;	Entry:
-;		d2.w - current level
-;		a4   - points to MakeTable stack frame
-;
-;	Exit:
-;		d0.w - # leading invalid entries
-;---
-
-CountLeading
-			moveq	#0,d0				; deal w/leading invalid entries later...
-			rts
-
-;-----
-;	HandleLeading - purge the leading invalid entries at the next level from
-;					the intermediate table, and return an appropriate limit field.
-;
-;	Entry:
-;		d0.w - # leading invalids
-;		d2.w - current level
-;		a4   - points to MakeTable stack frame
-;
-;	Exit:
-;		a0 - limit field
-;---
-
-HandleLeading
-			move.l		#NoLimit,a0		; deal w/leading invalid entries later...
-			rts
-
-;-----
-;	CountTrailing - count the number of trailing invalid entries for the next lower level.
-;
-;	Entry:
-;		d2.w - current level
-;		a4   - points to MakeTable stack frame
-;
-;	Exit:
-;		d0.w - # trailing invalid entries
-;---
-
-CountTrailing
-			moveq	#0,d0				; # trailing invalids = 0
-			move.l	genPtr(a4),a0		; get ptr to next intermediate table entry
-@loop									; LOOP backwards thru intermediate table
-			move.l	(a0)+,d1			;   get entry										<7>
-			bfextu	d1{30,2},d1			; 	get descriptor type
-			bne.s	@exitLoop			; >>EXITLOOP if not invalid
-			addq.w	#1,d0				;   bump # trailing invalids
-			cmpa.l	intermedTbl(a4),a0	;   check if we're at start of table
-			bne.s	@loop				; REPEAT till start of table
-@exitLoop	rts
-
-
-;-----
-;	HandleTrailing - purge the trailing invalid entries at the next level from
-;					 the intermediate table, and return an appropriate limit field.
-;	Entry:
-;		d0.w - # trailing invalids
-;		d2.w - current level
-;		a4   - points to MakeTable stack frame
-;
-;	Exit:
-;		a0 - limit field
-;---
-
-HandleTrailing
-			move.l	d2,-(sp)			; save work reg
-			exg		d2,d0				; get current level, save # trailers
-			addq.w	#1,d0				; look at level we're getting limit for
-			bsr.s	SpanAndCount		; get max # entries for that level
-			cmp.w	d2,d1				; check max entries against trailing invalids		<T15>
-			blt.s	@invalidLevel		; IF less invalids than max entries THEN			  |
-			sub.w	d2,d1				;	limit = max # - # trailing						  v
-			subq.w	#1,d1				;	limits are zero-based!
-			swap	d1					;	get limit field in hi word
-			clr.w	d1					;	zap low word
-			move.l	d1,a0				;	return it
-			moveq	#0,d0				;	clear a reg
-			move.w	d2,d0				;	get # trailing invalids
-			bra.s	@bumpPtr			;	go bump intermediate table ptr
-@invalidLevel							; ELSE
-			move.l	d1,d0				;	use max number of entries						<T15>
-			move.l	#1,a0				;	return a bad limit								<T23>
-@bumpPtr								; ENDIF												<T15>
-			lsl.l	#2,d0				; get size of their intermediate table entries
-			add.l	d0,genPtr(a4)		; purge entries from intermediate table				<7>
-			move.l	(sp)+,d2			; restore reg
-			rts
-
-
-;-----
-;   SpanAndCount - get the address span of a given table level, and # entries at that level
-;
-;	Entry
-;		d0.w - level
-;		a4 - ptr to MakeTable stack frame
-;
-;	Exit
-;		d0.l - address span
-;		d1.w - count
-;---                                                 
-
-SpanAndCount
-SpanRegs	REG		d2-d3
-			movem.l	SpanRegs,-(sp)		; save regs
-			move.l	mmuSetupPtr(a4),a0	; get ptr to MMU setup info
-			cmp.w	#cpu68040,d7		; check if we are an 040							<7>
-			bne.s	@not040				; IF on a 68040 THEN								<7>
-
-			clr.l	d2					;   clear reg for span bits							<7>
-			clr.l	d3					;	clear reg for entry bits						<7>
-			subq.w	#1,d0				;	convert level into table index					<7>
-			move.b	(TIX040,d0.w*2),d2	;	get # of bits in this level's span				<7>
-			move.b	(TIX040+1,d0.w*2),d3;   get # of bits in entry count for this level		<7>
-			move.l	#14,d0				;   bit # in TC to test for page size on 68040		<7>
-			btst	d0,newtc(a0)		;   check what size pages we're using				<7>
-			beq.s	@8kPages			;	IF we're using 4k pages							<7>
-			subq	#1,d2				;	  span goes down by half						<7>
-			addq	#1,d3				;	  and number of entries doubles					<7>
-@8kPages								;	ENDIF											<7>
-			bra.s	@done				; ELSE												<7>
-@not040		moveq	#32,d2				;   start w/all address bits
-			bfextu	newtc(a0){12,4},d1	;   get # initial shift bits
-			sub.l	d1,d2				;   reduce total bits by initial shift
-			moveq	#16,d1				;   get bit offset to 1st TIx field
-			subq.w	#1,d0				;   adjust level for dbra
-@loopTIx								;   LOOP
-			bfextu	newtc(a0){d1,4},d3	;     get # bits this level
-			sub.l	d3,d2				;     reduce total by # bits this level
-			addq.w	#4,d1				;     bump offset to next TIx field
-			dbra	d0,@loopTIx			;   REPEAT for all levels
-										; ENDIF												<7>
-@done		moveq	#0,d0				; clear return reg
-			bset	d2,d0				; set address span for this level
-			moveq	#0,d1				; clear return reg
-			bset	d3,d1				; set # entries this level
-			movem.l	(sp)+,SpanRegs		; restore regs
-			rts
-
-TIX040									; 68040 built-in table index field sizes (8k pages)	<7>
-LevelOne	dc.b	25,7				; 32M span, 128 entries								<7>
-LevelTwo	dc.b	18,7				; 256k span, 128 entries							<7>
-LevelThree	dc.b	13,5				; 8k span, 32 entries								<7>
-
-;-----
-;	FinalTable - generate the final MMU table from the intermediate table
-;
-;	Entry:
-;		a4 - point to MakeTable stack frame
-;		intermediate table has been created
-;
-;	Exit
-;		a0 - points to newly created MMU table
-;		d0 - has 1st word of crp (limit, descriptor type)
-;---
-
-FinalTable	lea		intermedTbl(a4),a0		; get ptr to intermediate table
-			move.l	a0,genPtr(a4)			; initialize scanning ptr
-			moveq	#1,d0					; start generating at level 1
-			bsr.s	Generate				; generate the table
-			tst.w	doWrap24(a4)			; wrap the tables for 24-bit mode?				<7>
-			beq.s	@noWrap					; IF we need to wrap tables THEN				<7>
-			bsr		Wrap24BitTable			;   wrap tables	for 24-bit mode					<7>
-@noWrap										; ENDIF											<7>
-			move.l	([genPtr,a4],-4),d1		; get next intermediate table entry				<7>
-			add.w	d0,d1					; make type '8 byte' if sub-table is 8 byte
-			and.w	#descrTypeMask,d1		; crp doesn't have extra status field bits
-			cmp.b	#PMMU851,sgTypeMMU(a6)	; check MMU type								  <SM6> CSS
-			bne.s	@done					; IF we are on a 68851
-			bset	#9,d1					;   set 'shared global' bit
-@done										; ENDIF
-			move.l	d1,d0					; return crp
-			rts
-
-;-----
-;	Generate - given a level, generate a (sub) table for that level
-;
-;	Entry
-;		d0.w - level
-;
-;	Exit
-;		d0.w - size (0 = short, 1 = long) of entries at this level
-;		a0   - ptr to generated table
-;---
-
-GenRegs		REG		d2-d4/a1-a2
-Generate	movem.l	GenRegs,-(sp)		; save work regs
-			move.l	d0,d4				; save level
-			bsr.s	CountAndSize		; get #, size table entries needed
-			move.w	d0,d3				; save count
-			move.w	d1,d2				; save size
-			bsr.s 	AllocTbl			; allocate space for the (sub) table
-			move.l	a0,a1				; set up fill ptr for table
-			move.l	a0,a2				; remember table address
-			bra.s	@repeat				; adjust for dbra
-@loop									; LOOP
-			move.l	([genPtr,a4],-4),d0	;   get next intermediate table entry				<7>
-			bfextu	d0{27,2},d1			;   get level of this entry
-			cmp.w	d1,d4				;   check against level we're generating for
-			bhs.s	@notTbl				;   IF entry's level deeper than ours
-			move.w	d4,d0				;     recall level we are working on
-			addq.w	#1,d0				;     bump to deeper level
-			bsr.s	Generate			;     generate sub-table at next deeper level
-			bsr		MakeTableEntry		;     make a 4/8 byte table descriptor at fill ptr	<16>
-			bra.s	@next				;     ...
-@notTbl		bne.s	@weird				;   ELSEIF entry's level = ours
-			bsr		MakePageEntry		;     make a 4/8 byte page/invalid entry at fill ptr
-;fallThru	bra.s	@next				;     ...
-@next									;   ENDIF
-@repeat		dbra	d3,@loop			; REPEAT for all entries at this level
-			move.l	a2,a0				; return ptr to generated table
-			move.w	d2,d0				; return size of entries in generated table
-			movem.l	(sp)+,GenRegs		; restore work regs
-			rts
-
-@weird									; entry's level less deep than ours - SHOULD NEVER HAPPEN!
-			dc.w	$A9FF				; trap to debugger, call Sculley
-
-
-;-----
-;	CountAndSize - return number and size of entries for subtree at given level
-;
-;	Number of entries is obtained by scanning forward in the intermediate table, 
-;	counting entries at this level until a higher (lower in number) level entry
-;	is found.  Size is assumed 4 byte, but is 8 byte if any of the intermediate
-;	table entries encountered at this level are 8 byte.
-;
-;	Entry
-;		d0 - level
-;		a4 points to MakeTable stack frame
-;
-;	Exit
-;		d0.w - number of entries
-;		d1.w - zero if 4 byte descriptors, one if eight byte descriptors
-;---
-
-CountRegs	REG		d2-d4
-CountAndSize
-			movem.l	CountRegs,-(sp)		; save work registers
-			move.w	d0,d2				; save level of interest
-			move.l	genPtr(a4),a0		; get ptr to itermediate table entry
-			moveq	#0,d1				; assume 4 byte descriptors
-			moveq	#0,d0				; count = zero
-@loop									; LOOP
-			move.l	-(a0),d3			;   get next intermediate table entry				<7>
-			bfextu	d3{27,2},d4			;   get level of this entry
-			cmp.w	d4,d2				;   compare level to ours
-			bhi.s	@done				; >>EXITIF level less deep than ours
-			bne.s	@loop				;   COUNTINUELOOP if not same level as ours
-			addq.w	#1,d0				;   bump count
-			bfextu	d3{30,2},d4			;   get type from entry
-			cmp.w	#descrTbl4,d4		;   check it
-			bne.s	@loop				;   CONTINUELOOP if type ≠ "4 byte table"
-			swap	d3					;   get limit field
-			cmp.w	#NoLimit>>16,d3		;   check the limit
-			beq.s	@loop				;   CONTINUELOOP if no limit
-			moveq	#1,d1				;   signal we'll need 8 byte descriptors
-			bra.s	@loop				; REPEAT
-@done		movem.l	(sp)+,CountRegs		; restore work regs
-			rts
-
-
-;-----
-;   AllocTbl - allocate quadlong aligned space for MMU table from BootGlobs
-;
-;	Entry
-;		d0.w - # entries in table
-;		d1.w - size of entries (0 = short, 1 = long)
-;		d4.w - level
-;		a6   - points to BootGlobs
-;
-;   Exit
-;		a0 - ptr to allocated space
-;
-;-----
-
-AllocTbl	and.l	#$FFFF,d0			; clear hi word of # entries
-			addq.w	#2,d1				; convert size into scale factor
-			ext.l	d1					; clear hi word of size
-			lsl.l	d1,d0				; table size = scaled # entries
-			move.l	a6,d1				; get ptr to BootGlobs
-			add.l	sgAllocOff(a6),d1	; calculate current allocation ptr				  <SM6> CSS
-			sub.l	d0,d1				; allocate our table
-			cmpi.w	#cpu68040,d7		; check the type of processor					<16>
-			bne.s	@notAn040			; IF on a 68040 THEN							<16>
-			lea		AlignmentMasks,a0	;	get address of table alignment masks		<16>
-			and.w	(a0,d4.w*2),d1		;	align the table								<16>
-			bra.s	@aligned			; ELSE											<16>
-@notAn040	and.b	#$F0,d1				;   ensure quad-long alignment for 020/030's	<16>
-@aligned								; ENDIF											<16>
-			move.l	d1,a0				; return ptr to allocated space
-			sub.l	a6,d1				; figure out new allocation offset
-			move.l	d1,sgAllocOff(a6)	; update allocation offset						  <SM6> CSS
-			rts
-
-; Masks for aligning 68040 tables on the correct boundaries								<16>
-AlignmentMasks
-Level0		dc.w	0
-Level1		dc.w	$fe00				; align to 512 bytes (SRP ptr)
-Level2		dc.w	$fe00				; align to 512 bytes (ptrs IN 1st level)		<T11>
-Level3		dc.w	$ff00				; align to 256 bytes (ptrs IN 2nd level)		<T11>
-
-;-----
-;	MakeTableEntry - make a 4 or eight byte table descriptor at passed fill ptr
-;
-;	Entry
-;		d0 - size (0 = short, 1 = long) of entries in sub-table
-;		d2 - size (0 = short, 1 = long) of table descriptor to be made
-;		a0 - ptr to sub-table
-;		a1 - fill ptr
-;		a4 - points to MakeTable stack frame (genPtr points to next intermediate entry)
-;
-;	Exit
-;		a1 - fillptr updated to next place to put a descriptor
-;		genPtr(a4) - points to next intermediate table entry
-;---
-
-MakeTableEntry
-			subq.l	#4,genPtr(a4)		; bump scan ptr									<7>
-			move.l	([genPtr,a4]),d1	; get next intermediate table entry				<7>
-			add.w	d0,d1				; make type '8 byte' if sub-table is 8 byte
-			bfextu	d1{30,2},d0			; get descriptor type
-			tst.w	d2					; check descriptor size
-			bne.s	@eightByte			; IF its a 4 byte descriptor
-			add.l	a0,d0				;   merge sub-table address w/type
-			bset	#3,d0				;   set used bit, so processor won't have to
-			move.l	d0,(a1)+			;   lay down descriptor, update fill ptr
-			bra.s	@done				;   ...
-@eightByte								; ELSE (its an eight byte descriptor)
-			bfclr	d1{24,6}			;   clear rest of status field
-			bset	#3,d1				;   set used bit, so processor won't have to
-			move.l	d1,(a1)+			;   lay down limit & status, update fill ptr
-			move.l	a0,(a1)+			;   lay down table address, update fill ptr
-@done									; ENDIF
-			rts
-
-
-;-----
-;	MakePageEntry - make a (4 or eight byte) page or table descriptor at passed fill ptr
-;
-;	Entry
-;		d2 - size (0 = short, 1 = long) of descriptor to be made
-;		a1 - fill ptr
-;		a4 - points to MakeTable stack frame (genPtr points to next intermediate entry)
-;
-;	Exit
-;		a1 - fillptr updated to next place to put a descriptor
-;		genPtr(a4) - points to next intermediate table entry
-;---
-
-MakePageEntry
-			subq.l	#4,genPtr(a4)		; bump scan ptr									<7>
-			move.l	([genPtr,a4]),d0	; get next intermediate table entry				<7>
-			bfextu	d0{25,7},d1			; get descriptor type, cache inhibit bit
-			and.w	#$FF00,d0			; clear out all except page address
-			bfset	d1{27,2}			; set modified, used bits so processor won't have to
-			tst.w	d2					; check descriptor size
-			bne.s	@eightByte			; IF its a 4 byte descriptor
-			add.l	d0,d1				;   merge page address w/status field
-			move.l	d1,(a1)+			;   lay down descriptor, update fill ptr
-			bra.s	@done				;   ...
-@eightByte								; ELSE (its an eight byte descriptor)
-			bfset	d1{1,21}			;   set limit to $7FFF, set up high bits of status
-			move.l	d1,(a1)+			;   lay down limit & status, update fill ptr
-			move.l	d0,(a1)+			;   lay down page address, update fill ptr
-@done									; ENDIF
-			rts
-
-			ENDWITH						; {MakeFrame}
-			ENDWITH						; {InitFrame}
-			ENDWITH						; {MMUSetupInfo}
-
-;----- 
-;	Wrap24BitTable - Wrap the entries in the first and second level tables.  This causes	<7>
-;					 the first byte in an address to be essentially ignored in 24-bit mode.
-;					 Note:  This routine assumes 4-byte descriptors.
-;
-;	Entry
-;		a0 - points to newly created MMU table
-;		a4 - point to MakeTable stack frame
-;
-;	Exit
-;		a0 - ptr to generated table
-;---
-
-WrapRegs	REG		d2/a1-a2
-Wrap24BitTable
-			movem.l	WrapRegs,-(sp)		; save work registers
-			move.l	a0,a2				; save ptr to mmu table
-			move.w	#2,d0				; for level two,
-			bsr.s	SpanAndCount		; find entrys' address span and count
-			mulu.l	d1,d0				; calc span of entire 2nd-level table
-			move.l	#24,d2				; bits in 16 meg chunk
-			lsr.l	d2,d0				; calc how many 16 meg chunks in level
-			and.l	#$ffff,d1			; clear high word of count
-			divu.w	d0,d1				; calc # of entries to duplicate 
-			move.l	(a2),d2				; get table descriptor for first 2nd-level table
-			andi.l	#$fffffff0,d2		; get rid of attribute bits
-			move.l	d2,a1				; get it in an address register
-			subq.l	#2,d0				; (# of copies to make)-1
-			movea.l	a1,a0				; get copy of pointer to table
-			lsl.l	#2,d1				; convert # of entries to bytes
-@chunkLoop
-			adda.l	d1,a0				; point to copy destination
-			clr.l	d2					; clear counter
-@copyLoop
-			move.l	(a1,d2),(a0,d2)		; copy an entry
-			addq.l	#4,d2				; point to next entry
-			cmp.l	d2,d1				; done?
-			bne.s	@copyLoop			; nope, keep looping
-			dbra	d0,@chunkLoop		; do next chunk, if any
-			
-			moveq.l	#1,d0				; for level one --
-			bsr.s	SpanAndCount		; get address span and entry count
-			movea.l	a2,a1				; get a copy of the mmu table pointer
-			adda.l	#4,a1				; bump to point at second entry in table
-			subq.w	#2,d1				; (# of entries to copy) - 1
-@wrapLoop
-			move.l	(a2),(a1)+			; copy an entry
-			dbra	d1,@wrapLoop		; loop through first level table
-			movea.l	a2,a0				; restore a0
-
-			movem.l	(sp)+,WrapRegs		; restore work regs
-			rts							;
-			
-;_____________________________________________________________________________________________
-;	GetRBVSize - return size of RBV video buffer, optionally rounded up.
-;
-;	Entry
-;		d0.l - total memory available
-;		d1.l - MMU page size to round buffer size up to.  Zero if no rounding.
-;		a0   - RBV base address
-;		a2	 - ProductInfo record ptr (for finding slot zero PRAM alias addr)				<8.1>
-;
-;	Exit
-;		d0 - the size
-;
-;	all registers except parameters are preserved
-;_____________________________________________________________________________________________
-
-
-GetRBVSize
-
-		IF hasRBV THEN
-			bra.s	DoRBVSize			; branch around tables, assembler barfs on fwd refs
-
-Trans													; Translations from monitor ID bits
-			dc.w	0									; 000 = reserved (no monitor)
-			dc.w	P15Table-Trans						; x01 = 15" portrait
-			dc.w	IIGSTable-Trans						; 010 = IIgs
-			dc.w	0									; 011 = reserved (no monitor)
-			dc.w	0									; 100 = reserved (no monitor)
-			dc.w	P15Table-Trans						; x01 = 15" portrait
-			dc.w	MacIITable-Trans					; 110 = Mac 2
-			dc.w	0									; 111 = no monitor
-
-; these sizes are ordered to match the option bit ordering in DeclDataRBV.a
-
-SETable		DC.L	$0002AC00			; SE (9" monitor), 8 bits/pixel, 171 Kbyte buffer				<8.9>
-			DC.L	$00005580			; SE (9" monitor, 342x512), 1 bit/pixel, 21.375 Kbyte buffer	<8.9>
-			DC.L	$00015600			; SE (9" monitor), 4 bits/pixel, 85.5 Kbyte buffer				<8.9>
-			DC.L	$0000A600			; SE (9" monitor), 2 bits/pixel, 42.75 Kbyte buffer				<8.9>
-
-IIGSTable	DC.L	$00030000			; IIGS (12" monitor,384x512), 8 bits/pixel, 192 Kbyte buffer	<8.9>
-			DC.L	$00006000			; IIGS (12" monitor,384x512), 1 bit/pixel, 24 Kbyte buffer		<8.9>
-			DC.L	$00018000			; IIGS (12" monitor,384x512), 4 bits/pixel, 96 Kbyte buffer		<8.9>
-			DC.L	$0000C000			; IIGS (12" monitor,384x512), 2 bits/pixel, 48 Kbyte buffer		<8.9>
-
-MacIITable	DC.L	$0004B000			; Mac II (12" monitor,640x480), 8 bits/pixel, 300 Kbyte buffer
-			DC.L	$00009600			; Mac II (12" monitor,640x480), 1 bit/pixel, 37.5 Kbyte buffer
-			DC.L	$00025800			; Mac II (12" monitor,640x480), 4 bits/pixel, 150 Kbyte buffer
-			DC.L	$00012C00			; Mac II (12" monitor,640x480), 2 bits/pixel, 75 Kbyte buffer
-
-P15Table
-			DC.L	$00043F80			; Portrait (15" monitor,640x870), 4 bits/pixel, 272 Kbyte buffer
-			DC.L	$00010FE0			; Portrait (15" monitor,640x870), 1 bit/pixel, 68 Kbyte buffer
-			DC.L	$00021FC0			; Portrait (15" monitor,640x870), 2 bits/pixel, 136 Kbyte buffer
-
-
-GetRBVRegs	REG		d1-d4/a0
-
-DoRBVSize	movem.l	GetRBVRegs,-(sp)	; save regs
-
-			move.l	d1,-(SP)			; save the rounding factor
-
-			moveq	#(1<<RvMonID3)+(1<<RvMonID2)+(1<<RvMonID1),d4 ; get monitor parameters
-			and.b	RvMonP(a0),d4		; keep only the interesting bits
-			lsr.b	#RvMonID1,d4		; make it zero based
-
-; determine the cpu RAM and speed configuration
-
-			moveq	#0,d3				;   d3 used to calc sRsrc id for video modes
-			cmp.l	#$180000,d0			;   was there more than 1MB of RAM?
-			bge.s	@0					;   if ≥, then more than 1MB
-			bset	#3,d3				;   set 1MB flag bit on
-
-@0
-;+++ should do a CPU speed determination here (look at speed ID bits) and set bit 4 of D3
-;+++		RBVPrimaryInit does this test based on TimeDBRA.  Since this code doesn't do it,
-;+++		we don't test this bit below as part of the pRAM verification
-
-			movea.l	a2,a0							; a0 = ptr to productinfo record			<8.1>
-			adda.l	ProductInfo.VideoInfoPtr(a2),a0	; point to the VideoInfo record				<8.1>
-			moveq.l	#0,d2							;											<8.1>
-			move.b	VideoInfo.SlotPramAddr(a0),d2	; set d2 = pram addr for slot zero			<8.1>
-
-			move.w	d2,d0				;														<8.1>
-			addq.w	#4,d0				;   get the last configuration flags from slot 0 pRAM	<8.1>
-
-			bsr		ReadPRAMByte		; read it and weep...						<5>
-
-			eor.b	d3,d0				;   exclusive or to see if anything changed
-
-			btst	#3,d0				;   did the RAM size change?
-			bne.s	@configChanged		;   if set, then it did
-
-;+++			btst	#4,d0				;   did the CPU speed change?
-;+++			bne.s	@configChanged		;   if set, then the configuration changed
-
-; test if the monitor type has changed
-
-			move.w	d2,d0				; d2 = addr of slot zero pram 							<8.1>
-			addq.w	#3,d0				; get the last video sRsrc spID from pRAM				<8.1>
-			bsr		ReadPRAMByte		; read this pRAM
-			bclr	#7,d0				; mask off the spID hi bit
-			move.w	d0,d3				; remember this value in d3
-			and.l	#7,D0				; lo-3 bits = monitor ID
-
-			moveq	#0,d1				; clear this register out as a long in case there's no monitor
-			move.w	(Trans,d4*2),d1		; 0 = none, 1-4 = SE, IIGS, MacII, P15
-			beq.s	@gotSize			; if no monitor, then don't allocate any memory for video
-
-			cmp.b	d0,d4				; is the monitor the same?
-			beq.s	@noChange			; yup, so the saved slot pRAM value is OK
-
-@configChanged							; if we got here, then the CPU configuration has changed
-										; PRESERVE D1 ACROSS THIS SECTION!
-			btst	#3,d3				; was the 1MB bit turned on?
-			beq.s	@10					; if not, then skip
-			bclr	#4,d3				; if 1MB, then ignore CPU speed
-@10
-			or.b	d4,d3				; OR the monitor ID in d4 with the config data in d3 to get
-										;   sRsrc id (with hi-bit off)
-
-; when 1MB/25MHz machines default to 1,2,4 instead of 1,2,4,8, then and extra test will be needed hee
-
-;
-; at this point, we have the valid video sRsrc spID (sans bit 7) in d3.  We use this value to look
-;	up the buffer size in the Trans table declared above
-;
-
-@noChange
-			lea		Trans,a0			; point to table
-			moveq	#0,d1				; clear, in case there's no monitor 		<6.4>
-			move.w	(Trans,d4*2),d1		; 0 = none, 1-4 = SE, IIGS, MacII, P15		<6.4>
-			beq.s	@gotSize			; if no monitor, then no memory for video	<6.4>
-			adda.l	d1,a0				; offset to monitor's table					<6.4>
-			lsr		#3,d3				; get the option bits at the bottom of d3
-			move.l	(a0,d3*4),d1		; get the frame buffer size in d1
-
-			move.l	(SP),d0				; get the rounding factor in d0
-			beq.s	@gotSize			;   IF rounding needed
-			move.l	d1,d2				;     save our size
-			tdivu.l	d0,d3:d2			;     get remainder of size/round factor
-			tst.l	d3					;     check remainder
-			beq.s	@gotSize			;     IF any remainder
-			sub.l	d3,d0				;       get round factor - remainder
-			add.l	d0,d1				;       add to size to get next higher
-										;     ENDIF
-										;   ENDIF
-@gotSize								; ENDIF
-			move.l	d1,d0				; return size
-			move.l	(SP)+,d1			; restore d1
-			movem.l	(sp)+,GetRBVRegs	; restore regs
-		ELSE
-			moveq	#0,d0				; no RBV, no size
-		ENDIF
-
-
-			RTS
-
-
-;_____________________________________________________________________________________________
-;
-; GetVISASize - calculate size of VISA video buffer
-;
-; This routine finds the amount of RAM occupied by the video frame buffer to be used by the 
-;	VISA decoder, and adjusts the chunk table sizes accordingly.  This code is similar to 
-;	that in the Universal primaryInit (in RBVPrimaryInit.a).  It needs to verify the 
-;	connected display, and do some pRAM stuff to make this calculation work correctly.
-;
-; 	Preserves all registers
-;
-;	Inputs  : A2 = pointer to productInfo record
-;			  A3 = VISA base address
-;			  A6 = pointer to RAM chunk table
-;			 
-;	Outputs : none
-;
-;_____________________________________________________________________________________________
-
-			WITH 		StartGlobals
-
-GetVISASize
-
-; I'm a bad dog to include these equates here, but they live in different files in Reality/split sources and
-;	the Reality version can't be included.
-
-sRsrc_VidElsA2Em	EQU		$A8						; special Apple II emulation mode (1,4)
-sRsrc_VidElsGSa		EQU		$A2						; Rubik (1,4)
-
-
-			MOVEM.L		A0/A2/A3/D0/D2/D4,-(SP)				
-			
-			MOVE.B		VsMonP(A3),D4				; get the current monitor information
-			LSR.B		#3,D4						; shift the monitor ID into the low bits
-			AND.B		#7,D4						; clear out other bits
-			CMP.B		#7,D4						; if sense lines read 111 then no connect
-			BEQ.S		@Done						; no changes needed if no connect
-			
-			CMP.B		#2,D4						; if =2, then Rubik display
-			BNE.S		@isJersey					; if =6, then Jersey display
-			LEA			RubikTbl,A1					; point to the Rubik memory table
-			BRA.S		@GetPRAM					;
-@isJersey	LEA			JerseyTbl,A1				; point to the Jersey memory table			
-			
-@GetPRAM	
-			ADD.L		ProductInfo.VideoInfoPtr(A2),A2	; point to the VideoInfo record
-			MOVEQ		#0,D2						; clear out this register
-			MOVE.B		VideoInfo.SlotPramAddr(A2),D2	; get the start of pRAM for built-in video
-			ADDQ		#4,D2						; point to the config byte (see PrimaryInit)
-			
-			MOVE.W		D2,D0						; copy it to this register
-			BSR			ReadPRAMByte				; get the config byte from pRAM in D0, the RAM-less way
-			
-			CMP.B		D4,D0						; was it the same configuration?
-			BNE.S		@ReConfig					; no, so recalculate the default
-			
-; the display configuration is the same, so use the spID in slot pRAM byte 3 to determine allocation
-
-			MOVE.W		D2,D0						; point to pRAM byte again, clearing bits 8-15 of D0
-			SUBQ		#1,D0						; point to byte 3
-			BSR			ReadPRAMByte				; get the config byte from pRAM in D0, the RAM-less way
-
-			CMP.W		#sRsrc_VidElsA2Em,D0		; is it the Apple II emulation mode?
-			BNE.S		@0							; if not, continue
-
-			MOVE.B		#sRsrc_VidElsGSa,D0			; memory allocation for the Apple II mode is same as Rubik (1,4)
-@0
-			LSR.B		#3,D0						; shift lo to make index
-			AND.B		#3,D0						; just the low two bits
-			BRA.S		@GetSize					; 
-			
-; the display configuration is different, so determine the new default
-
-@ReConfig
-			MOVEQ		#0,D0						; zero index register
-			CMP.B		#2,D4						; if =2, then Rubik display, so default is RAM sensitive
-			BNE.S		@GetSize					; if Jersey, then no RAM size variant
-			CMP.L		#$100000,sgTotalRAM(A6)		; is there more than a megabyte of RAM?  <SM6> CSS	
-			BGT.S		@GetSize					; if so, then select variant 0
-			ADDQ		#1,D0						; select variant 1 for Elsie with 1MB on Rubik
-			
-@GetSize
-			MOVE.L		(A1,D0.W*4),D0				; get size for this config.  A1=Monitor table, D0=index in tbl
-			
-; adjust the sgAllocOff field down by the frame buffer size
-
-			MOVE.L		sgTotalRAM(A6),D2			; get total ram  <SM6> CSS
-			SUB.L		D0,D2						; subtract frame buffer size to get base of frame buffer
-			SUB.L		A6,D2						; make frame buffer base relative to pointer to boot globals
-			MOVE.L		D2,sgAllocOff(A6)			;   <SM6> CSS
-			
-@Done
-			MOVEM.L		(SP)+,A0/A2/A3/D0/D2/D4		; restore work registers
-			RTS
-
-RubikTbl	DC.L		$0001B400,$00007000,$0003B400,$00027000			; sizes for Rubik (1,4),(1),(1,4,2Pg),(1,2Pg)
-JerseyTbl	DC.L		$0000B000,$00000000,$0002B000					; sizes for Jersey (1), <extra>, (1,2Pg)		<12>
-
-			
 			ENDWITH							; {MMUConfigInfo}
 			ENDWITH							; {BootGlobs}
 
diff --git a/OS/MPDispatchStub.a b/OS/MPDispatchStub.a
new file mode 100644
--- /dev/null
+++ b/OS/MPDispatchStub.a
@@ -0,0 +1,71 @@
+; This ROM implementation of the MPDispatch trap (AA7F) only implements two
+; selectors, both for writing to the NanoKernel framebuffer/serial log.
+
+; To print a C string:
+;		PEA		@cstring
+;		MOVE	#-3, -(SP)
+;		DC.W	$AA7F
+
+; To print a hex string:
+;		MOVE.L	#value, -(SP)
+;		MOVE	#2, -(SP)		; 1: byte, 2: word, else: long
+;		MOVE	#-2, -(SP)
+;		DC.W	$AA7F
+
+
+MPDispatchStubTrap		PROC	EXPORT
+		CmpI	#-3, $4(SP)
+		BEQ.S	NKxprintf
+
+		CmpI	#-2, $4(SP)		; 
+		BEQ.S	NKPrintHex
+
+		Pea.L	@errStr			; ERROR
+		Clr		-(SP)
+		Bsr		NKxprintf
+
+		MoveQ.L	#$0, D0
+		Move	$4(SP), D0
+		Move.L	D0, -(SP)
+		Move.L	#$2, -(SP)
+		Clr		-(SP)
+		Bsr		NKPrintHex
+		Rts
+
+		string	Pascal
+@errStr	dc.b	'Unknown MPDispatch selector: ', 0, 0
+
+
+NKxprintf
+
+		MoveA.L	$6(SP), A0
+
+@loop	Move.B	(A0)+, D0		; iterate over string to get it in physical RAM?
+		BNE.S	@loop
+
+		MoveA.L	$6(SP), A0
+
+		MoveQ.L	#96, D0			; call NKXprintf
+		dc.w	$fe1f
+
+		MoveA.L	(SP)+, A0		; return
+		AddQ.L	#$6, SP
+		Jmp		(A0)
+
+
+NKPrintHex
+
+		MoveA.L	$A(SP), A0		; r3 arg (value to print)
+		Move.L	$6(SP), D1		; r4 arg (1: byte, 2: 2byte, else: 4byte)
+
+		MoveQ.L	#97, D0			; call NKPrintHex
+		dc.w	$fe1f
+
+		MoveA.L	(SP)+, A0		; return
+		dc.w	$defc, $000A
+;		AddA.W	#$A, SP
+		Jmp		(A0)
+
+
+
+		END
diff --git a/OS/MPDispatchStub.a.idump b/OS/MPDispatchStub.a.idump
new file mode 100644
--- /dev/null
+++ b/OS/MPDispatchStub.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/OS/OS.make b/OS/OS.make
--- a/OS/OS.make
+++ b/OS/OS.make
@@ -75,29 +75,26 @@ RealTimeDir		=	{OSDir}RealTime:
 #include {I2CDir}I2C.make
 
 
-OSObjs	= 							"{ObjDir}clock.a.o"								∂
+OSObjs	= 							"{ObjDir}BCScreen.a.o"							∂
+									"{ObjDir}clock.a.o"								∂
 									"{ObjDir}CrsrDev.a.o"							∂
 									"{ObjDir}CudaMgr.a.o"							∂
 									"{ObjDir}DeferredTaskMgr.a.o"					∂
-									"{ObjDir}DeviceMgr.a.o"							∂
-									"{ObjDir}DockingMgr.a.o"						∂
+									"{ObjDir}DeviceDispatch.o"						∂
 									"{ObjDir}EgretMgr.a.o"							∂
 									"{ObjDir}HwPriv.a.o"							∂
-									"{ObjDir}I2C.a.o"							∂
 									"{ObjDir}Universal.a.o"							∂
-									"{ObjDir}InterruptHandlers.a.o"					∂
-									"{ObjDir}IOPMgr.a.o"							∂
 									"{ObjDir}OSEventMgr.a.o"						∂
 									"{ObjDir}queue.a.o"								∂
 									"{ObjDir}sysUtil.a.o"							∂
 									"{ObjDir}VerticalRetraceMgr.a.o"				∂
 									"{ObjDir}MiscPatches.a.o"						∂
-									"{ObjDir}MagicData.a.o"							∂
 									"{ObjDir}PowerMgr.o"							∂
-									"{ObjDir}PwrControlsPatches.o"					∂
 									"{ObjDir}VMPatches.a.o"							∂
+									"{ObjDir}MPDispatchStub.a.o"					∂
 									"{ObjDir}Dispatch.a.o"							∂
-									"{ObjDir}UniversalTables.a.o"
+									"{ObjDir}UniversalTables.a.o"					∂
+									"{ObjDir}InterruptHandlers.a.o"					∂
 
 
 "{LibDir}OS.lib"				ƒ	{OSObjs}
@@ -280,3 +277,11 @@ OSObjs	= 							"{ObjDir}clock.a.o"								∂
 
 "{ObjDir}VMPatches.a.o"			ƒ	"{OSDir}VMPatches.a"
 	Asm {StdAOpts} -o "{Targ}" "{OSDir}VMPatches.a"
+
+
+"{ObjDir}MPDispatchStub.a.o"	ƒ	"{OSDir}MPDispatchStub.a"
+	Asm {StdAOpts} -o "{Targ}" "{OSDir}MPDispatchStub.a"
+
+
+"{ObjDir}NKEventGroupWrapper.a.o"	ƒ	"{OSDir}NKEventGroupWrapper.a"
+	Asm {StdAOpts} -o "{Targ}" "{OSDir}NKEventGroupWrapper.a"
diff --git a/OS/OSEventMgr.a b/OS/OSEventMgr.a
--- a/OS/OSEventMgr.a
+++ b/OS/OSEventMgr.a
@@ -129,10 +129,11 @@
 				INCLUDE 	'Balloons.a'			; 
 				INCLUDE 	'BalloonsPriv.a'		; 
 				INCLUDE 	'PowerPrivEqu.a'		; 
+				INCLUDE		'Processes.a'
 
 Events			PROC	EXPORT	
 
-				EXPORT	InitEvents,PostEventTrap,GetOSEventTrap,OSEventAvailTrap,FlushEvents
+				EXPORT	InitEvents,PostEventTrap,GetOSEventTrap,OSEventAvailTrap,FlushEvents,NewEMFunction
 				IMPORT	EnqueueTrap,DequeueTrap,SMgrPostMunging
 
 
@@ -330,8 +331,9 @@ FillRecord		MOVE.L	Ticks,EvtTicks(A0)	; fill in the current time
 ;_______________________________________________________________________
 
 OSEventAvailTrap 
-			IMPORT	ptchHMGetBalloons					; <SM6> rb, start
-			IMPORT	ptchHMCallTrackerInContext
+			ANDI.L	#$FFFF,D0
+
+OSEventAvailSkippingAndi
 			with  PowerDispRec
 			MOVEM.L	A0-A1/D0-D2,-(SP)					; we need to save these regs
 
@@ -348,7 +350,40 @@ OSEventAvailTrap
 			BNE.S	@DoNothing							; do nothing on the reentrant case
 
 			ST		hmgOSEventReentrantCount(A0)		; say that we're busy
-			JSR		ptchHMCallTrackerInContext
+
+;	from BalloonExtensions.a: ptchHMCallTrackerInContext
+
+			SUBQ	#$8, SP
+			SUBQ	#$2, SP
+			PEA.L	$2(SP)
+
+			MOVEQ.L	#-$1, D0								; like _GetFrontProcess but not quite
+			MOVE.L	D0, -(SP)
+			MOVE	#$39, -(SP)
+			_OSDispatch
+
+			TST		(SP)+
+			BNE.B	@wasError
+			SUBQ	#$2, SP
+
+			PEA.L	$2(SP)
+			_WakeUpProcess
+
+			TST		(SP)+
+			BNE.B	@wasError
+
+			SUBQ	#$2, SP
+			MOVE	#$FC, D0								; from Balloonptch28.p: HMBalloonBulk
+			_Pack14
+
+			TST		(SP)+
+@wasError	AddQ	#$8, SP
+
+														; from BalloonExtensions.a: ptchHMGetHelpGlobal
+			MOVE.L	ExpandMem,A0							; point to the expand mem ptr
+			MOVE.L	ExpandMemRec.emHelpGlobals(A0),A0		; return the global ptr on the stack
+
+			CLR		hmgOSEventReentrantCount(A0)
 
 @DoNothing
 			MOVEM.L	(SP)+,A0-A1/D0-D2					; restore 'em, <SM6> rb, end
@@ -389,9 +424,12 @@ TstAutoEvent	AND.W	SysEvtMask,D0		; figure in system mask for pseudo-evts
 				MOVE.L	Ticks,D1			; check first threshold
 				MOVE.L	D1,D2
 				SUB.L	KeyTime,D1
+				CMPI.L	#$8000,D1
+				BGE		@skip
 				CMP 	KeyThresh,D1
 				BLT.S	NoEventAvail		; br if not time yet
 
+@skip
 				SUB.L	KeyRepTime,D2		; check second threshold
 				CMP 	KeyRepThresh,D2
 				BLT.S	NoEventAvail		; br if not time yet
@@ -458,7 +496,10 @@ NoEventAvail	BSR.S	FillRecord			; fill in record for null events
 ; Other:		uses D0,D1,D2,A0,A1
 ;_______________________________________________________________________
 	
-GetOSEventTrap	BSR.S	OldOSEventAvail		; first find the event						<SM11>
+GetOSEventTrap	ANDI.L	#$FFFF,D0
+
+GetOSEventSkippingAndi
+				BSR.S	OldOSEventAvail		; first find the event						<SM11>
 				BNE.S	@EventDone			; don't dequeue null or update events
 
 				MOVE.L	A0,-(SP)			; save user's event record ptr
@@ -547,34 +588,38 @@ FlushStop		MOVEM.L (SP)+,D3-D4 		; restore regs
 				EXT.L	D0					; make result long								<07Jun85>
 				MOVE.W	(SP)+, SR			;  on as our result
 				RTS
-
-				END 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
 
 
+NewEMFunction
+				MoveA.L	(A7)+, A1
+				CmpI	#$1, D0
+				BEQ.B	L13
+				CmpI	#$2, D0
+				BEQ.B	L14
+				CmpI	#$3, D0
+				BEQ.B	L15
+				MoveQ.L	#$C, D0
+				DC.W	$A9C9
+L13				Move.L	(A7)+, D0
+				MoveA	(A7)+, A0
+				Move.L	A1, -(A7)
+				Bsr		GetFreeOne
+				Bra.B	L16
+L14				MoveA.L	(A7)+, A0
+				Move.L	(A7)+, D0
+				Move.L	A1, -(A7)
+				Bsr		OSEventAvailSkippingAndi
+				Not.L	D0
+				AndI.L	#$101, D0
+				Bra.B	L16
+L15				MoveA.L	(A7)+, A0
+				Move.L	(A7)+, D0
+				Move.L	A1, -(A7)
+				Bsr		GetOSEventSkippingAndi
+				Not.L	D0
+				AndI.L	#$101, D0
+L16				Move.L	D0, $4(A7)
+				Rts
+
+
+				END
diff --git a/OS/PowerMgr/PowerMgr.make b/OS/PowerMgr/PowerMgr.make
--- a/OS/PowerMgr/PowerMgr.make
+++ b/OS/PowerMgr/PowerMgr.make
@@ -14,7 +14,13 @@
 #
 
 
-"{ObjDir}PowerMgr.o"			ƒ	"{ObjDir}StandardEqu.d"							∂
+PowerMgrObjs					=	"{ObjDir}PowerMgr.c.o"							∂
+									"{ObjDir}PowerMgr.a.o"							∂
+
+"{ObjDir}PowerMgr.o"			ƒ	{PowerMgrObjs}
+	Lib {StdLibOpts} -o "{Targ}" {PowerMgrObjs}
+
+"{ObjDir}PowerMgr.a.o"			ƒ	"{ObjDir}StandardEqu.d"							∂
 									"{IntAIncludes}HardwarePrivateEqu.a"			∂
 									"{IntAIncludes}UniversalEqu.a"					∂
 									"{IntAIncludes}PowerPrivEqu.a"					∂
diff --git a/OS/Queue.a b/OS/Queue.a
--- a/OS/Queue.a
+++ b/OS/Queue.a
@@ -87,49 +87,6 @@ ENQDONE 		SUBQ	#2,A1					;restore A1
 				ENDP
 
 
-;-----------------------------------------------------------------------
-; EnqueueHead -- add a queue element to the head of a queue.  
-;-----------------------------------------------------------------------
-;
-;	Entry:
-;		A0 - points to the queue element
-;		A1 - points to the queue header
-;		All registers are preserved; there are no error conditions.
-;
-; The element is inserted at the beginning of the list.
-;
-;-----------------------------------------------------------------------
-;
-ENQUEUEHEAD		PROC	EXPORT
-				
-				MOVE	SR, -(SP)				;preserve status
-				ADDQ	#2, A1					;point to qHead
-				ORI 	#$0700, SR				;disable interrupts for exclusion
-
-				TST.L	(A1)+					;anything in the queue? (qHead)
-				BNE.S	@doQinsert				;if so, skip ahead
-;
-; the queue is empty so make the head and tail point to the new element
-;
-				MOVE.L	A0, (A1) 				;qTail
-				MOVE.L	A0, -(A1)				;qHead
-				CLR.L	qLink(A0)				;clear the link of the element
-				BRA.S	@enQdone
-;
-; insert the element at the head of the list
-;
-@doQinsert		MOVE.L	A2, -(SP)				;preserve A2
-				MOVE.L	-(A1), A2 				;get ptr to old qHead
-				MOVE.L	A2, qLink(A0)			;update new link to old head
-				MOVE.L	A0, (A1) 				;update qHead
-				MOVE.L	(SP)+, A2				;restore A2
-;
-@enQdone 		SUBQ	#2, A1					;restore A1
-				MOVE	(SP)+, SR				;restore status and go home
-				RTS
-		
-				ENDP
-
 ;
 ;-----------------------------------------------------------------------
 ;
diff --git a/OS/SlotMgr/SlotInterrupts.a b/OS/SlotMgr/SlotInterrupts.a
--- a/OS/SlotMgr/SlotInterrupts.a
+++ b/OS/SlotMgr/SlotInterrupts.a
@@ -97,8 +97,8 @@ SIntCORE 	PROC	EXPORT
 			WITH	SlotIntQElement,slotIntGlobals
 
 			EXPORT	InitSPTbl,InitSDTbl
-			EXPORT	SIntINSTALL,SIntREMOVE,DAFBVia2SlotInt,PSCVIA2SlotInt,NiagraVIA2SlotInt
-			EXPORT	SlotInt,SlotIntCommon,Via2SlotInt,RbvSlotInt,OssSlotInt
+			EXPORT	SIntINSTALL,SIntREMOVE
+			EXPORT	SlotIntCommon
 
 			EXPORT	RunSlotHandlers		; accessed by level 3 Sonic Interrupt on <H2>
 										; Sonora based systems
@@ -232,150 +232,6 @@ SIntREMOVE	bsr.s	GetSlotIntQHead		; a1 := pointer to qheader
 ;
 ;____________________________________________________________________________
 
-SlotInt
-PSCVIA2SlotInt
-			MoveQ	#~$78, D0			; mask for slot bits (active low)
-										; 	(slots c,d,e, onboard video vbl)
-			Or.b	PSCVIA2SInt(a1), D0	; read and mask slot interrupt indicators
-			Not.l	D0					; convert to active high bit mask					
-			Bne.l	SlotIntCommon		; if interrupt pending, service it					
-			Rts							; if not, return from interrupt			<SM4> rb, end			
-
-DAFBVia2SlotInt
-			move.b	#$02,vIFR(a1)		; reset the VIA any slot interrupt flag				<3>
-	if nonSerializedIO then
-			nop							; force write to complete							<SM7>
-	endif
-			moveq.l	#~$7F,d0			; mask for slot bits (active low) (5 slots+Enet+Video)	<3> <9>
-			or.b	vBufA(a1),d0		; read and mask slot interrupt indicators			<3>
-			not.l	d0					; convert to active high bit mask					<3>
-			bne		SlotIntCommon		; if interrupt pending, service it					<3>
-			rts							; if not, return from interrupt						<3>
-
-; ••• These need moved (into HardwarePrivateEqu.a?) •••
-AIV3Base		EQU		$FEE00000			; base address of AIV3 (Apple Integrated VIA 3)
-AIV3SlotInt		EQU		$0002
-VBLIRQ			EQU		6
-
-AIV3Int			EQU		$0003
-AnySlot			EQU		1
-
-NiagraVIA2SlotInt
-			move.b	#$02,vIFR(a1)			; reset the VIA any slot interrupt flag	
-
-			lea		AIV3Base,a0				; get base address
-			btst	#AnySlot,AIV3Int(a0)	; any of our slots interrupting?
-			beq.s	@notOurs				; no, exit
-
-			moveq	#0,D0					; clear the register
-			btst	#VBLIRQ,AIV3SlotInt(a0) ; check for VSC interrupt pending
-			bne.s	@notOurs				; IF VBLIRQ pending THEN
-			ori.b	#%00100000,D0			; 	set slot E interrupt flag
-			bra		SlotIntCommon	
-@notOurs
-			rts								; if not, return from interrupt				<SM6> rb, end			
-
-Via2SlotInt
-		eieioSTP
-			move.b	#$02,vIFR(a1)		; reset the VIA any slot interrupt flag
-		eieioSTP
-			moveq.l	#~$3F,d0			; mask for slot bits (active low)
-		eieioSTP
-			or.b	vBufA(a1),d0		; read and mask slot interrupt indicators
-			not.l	d0					; convert to active high bit mask
-		eieioSTP
-			bne		SlotIntCommon		; if interrupt pending, service it
-			rts							; if not, return from the interrupt
-
-RbvSlotInt
-		eieioSTP
-			move.b	#$82,RvIFR(a1)		; reset the RBV any slot interrupt flag
-		eieioSTP
-			moveq.l	#~$7F,d0			; mask for slot bits (active low)
-		eieioSTP
-			or.b	RvSInt(a1),d0		; get slot interrupt indicators
-		eieioSTP
-			not.l	d0					; convert to active high bit mask
-
-;••••••••••••																		<SM8>
-; for PDM's with EVT1/2 boards, we need a small hack to swap the
-; slot interrupt lines, since they're reversed on the logic board.
-; AMIC versions >= 3 are used on EVT3 and greater boards, so
-; we'll check for it and avoid the hack if it's present.  Remove this hack
-; when we no longer need to support EVT1/2 boards.
-
-		IF hasHMC AND forPDMProto THEN	;											<sm11>
-			TestFor	AMICExists			; do we have an AMIC?
-			beq.s	@hackDone			; no, skip the hack
-			
-			btst.b	#2,RvSEnb(a1)		; see if bit 2 is enabled (set)
-			bne.s	@chkCF1				; yes, we have a new AMIC (>=3), see if CF EVT1
-			move.b	#$84,RvSEnb(a1)		; try setting bit 2
-			btst.b	#2,RvSEnb(a1)		; did it set?
-			beq.s	@doPDMHack			; no, must be AMIC1/2 (EVT1/2)
-			move.b	#$04,RvSEnb(a1)		; else, restore it
-			bra.s	@hackDone			; and skip the hack
-
-@chkCF1		lea		$5ffffffe,a0		; get CPU ID reg							<SM9>
-			move.b	(a0)+,d1			;											<SM9>
-			cmpi.b	#$30,d1				; are we a CF EVT1?							<SM9>
-			bne.s	@hackDone			; no, exit									<SM9>
-			move.b	(a0),d1				;											<SM9>
-			cmpi.b	#$13,d1				; check 2nd byte of id						<SM9>
-			bne.s	@hackDone			; not CF, no hack							<SM9>
-
-			lea		$F0000008, a0		; get Bart ID Register						<SM10>
-			move.l	(a0), d1			;											<SM10>
-			cmp.l	#$43184000, d1		; is this the first rev of Bart				<SM10>
-			bne.s	@hackDone			; new bart, so don't do hack				<SM10>
-
-			move.b	d0,d1				; yes get interrupt bits					<SM9>
-			andi.b	#%00001100,d1		; get slot int bits  ..CB (we loose slot E)	<SM9>
-			lsl.b	#1,d1				; map over into      .DC.					<SM9>
-			andi.b	#%11100011,d0		; keep VBL & slot E (VDS) bits				<SM9>
-			or.b	d1,d0				; 'or' slots C,D into other bits			<SM9>
-			bra.s	@hackDone			; and continue processing					<SM9>
-
-
-@doPDMHack	andi.w	#$78,d0
-			lsr.w	#3,d0
-			move.b	@swapTbl(d0.w),d0
-			lsl.w	#3,d0
-@hackDone
-		ENDIF
-;••••••••••••																		<SM8>
-		
-			and.b	RvSEnb(a1),d0		; only look at enabled ones
-			bne.s	SlotIntCommon		; if interrupt pending, service it
-			rts							; if not, return from the interrupt
-
-		IF hasHMC THEN					;											<SM8>
-@swapTbl	dc.b	$00					; 0000
-			dc.b	$04					; 0001
-			dc.b	$02					; 0010
-			dc.b	$06					; 0011
-			dc.b	$01					; 0100
-			dc.b	$05					; 0101
-			dc.b	$03					; 0110
-			dc.b	$07					; 0111
-			
-			dc.b	$08					; 1000
-			dc.b	$0c					; 1001
-			dc.b	$0a					; 1010
-			dc.b	$0e					; 1011
-			dc.b	$09					; 1100
-			dc.b	$0d					; 1101
-			dc.b	$0b					; 1110
-			dc.b	$0f					; 1111
-		ENDIF
-			
-			
-OssSlotInt
-			moveq.l	#$3F,d0				; mask for slot bits (active high)
-			and.b	OSSIntStat+1(a1),d0 ; get slot interrupt indicators
-			bne.s	SlotIntCommon		; if interrupt pending, service it
-			rts							; if not, return from the interrupt
-
 SlotIntCommon
 			subq.l	#4,sp				; allocate a long (only a byte is used)
 			move.b	d0,(sp)				; save the interrupt pending bit mask
@@ -398,7 +254,6 @@ SlotIntCommon
 
 			movea.l	VIA2RBVOSS,a1		; get base address of chip with slot int reg
 			movea.l	Via2DT+4*ifCA1,a0	; get the handler address
-		eieioSTP
 			jmp		(a0)				; loop until no slots interrupting
 
 @noHandler	_SysError					; no handler for slot interrupt
diff --git a/OS/SlotMgr/SlotMgr.a b/OS/SlotMgr/SlotMgr.a
--- a/OS/SlotMgr/SlotMgr.a
+++ b/OS/SlotMgr/SlotMgr.a
@@ -774,7 +774,7 @@ IdSave$d		EQU		D2			;Save the sResource Id.
 				MOVE.L	a2,a0
 				MOVE.L	a3,a1
 				MOVE.L	d1,d0
-				_BlockMove
+				_BlockMoveData
 				MOVEM.L	(SP)+,A0-A1										;Restore A0-A1, destroyed by _BlockMove.
 				BNE.S	Err1
 				
@@ -1483,12 +1483,6 @@ EndStatLoad		RTS
 ;	Patch out Drivers for any Apple Cards that need it.
 
 BeginGetSlotDrvr
-			IF NOT LC930 THEN
-				Import	GetDriverPatch
-				Bsr		GetDriverPatch						; If GetDriverPatch returns a 
-				Tst.b	D0									;	result >= 0, don’t execute
-				Bge.s	ExitGetSlotDrvr						; Patched, so just return.
-			ENDIF
 ;	This is the original entry-point. It is called by GetDevIndex
 				Export	OrigGetSlotDrvr
 OrigGetSlotDrvr
@@ -1518,240 +1512,6 @@ ExitGetSlotDrvr	RTS
 
 				EJECT
 				
-;____________________________________________________________________________
-;
-; GetDriverPatch and support (called from _SGetDriver).
-;
-;	Entry/Exit:	A0 points to spBlock.
-;
-;	Purpose:	The purpose of GetDriverPatch is to identify Apple
-;				Cards whose Driver code is faulty, and execute fixed
-;				versions from the CPU ROM. It’s job is to
-;				call GetDevIndex to determine whether the card/device
-;				pointed to by the incoming spBlock is one that needs
-;				patching.  If so, it attempts to allocate enough space
-;				for the driver in the system heap, copy it there, and
-;				then return a handle to the driver in spBlock.spResult.
-;				If the driver can’t be loaded (e.g., not enough memory),
-;				the appropriate Slot Manager error is returned.
-;____________________________________________________________________________
-
-GetDriverPatch		Proc	Export
-			With	spBlock,LoadTblRec
-
-@saveRegs	Reg		A0/A3-A5/D3-D4						; Define registers for work/saving, and
-			Movem.l	@saveRegs,-(Sp)						;	store them on the stack.
-			Link	A6,#-spBlockSize					; Get a stack frame.
-			
-			Move.l	A0,A3								; Save spBlockPtr.
-
-; First, look to see if we even need to be attempting to patch the driver on this
-; 	card/device.
-;
-			Bsr		GetDevIndex							; Get the card/device index into D0.
-			Move.l	D0,D3								; If the device index is negative, then
-			Bmi 	@done								; driver doesn’t need patching.<SM9> CSS	
-
-; Next, check to see that we’re pointing to the sResource that has the driver or
-;	driver loader in it (i.e., we don’t want to be opening the driver multiple
-;	times).
-;
-			Lea		LoadTbl,A1							; Point to base of LoadTbl.
-			Mulu	#LTEntrySize,D3						; Adjust index.
-			
-			Move.l	A1,A0								; Point to base of LoadTbl.
-			Move.b	ltSpID(A0,D3),D0					; Get spID.
-			Move.b	ltSpExtDev(A0,D3),D1				; Get spExtDev.
-
-			Moveq	#0,D4								; Clear value holder.
-			Move.b	D0,D4								; Save spID
-			Swap	D4									; 	and
-			Move.b	D1,D4								; Save spExtDev.
-			
-			Move.l	Sp,A0								; Point to local spBlock.
-
-			Move.b	spSlot(A3),spSlot(A0)				; Get pointer to right sResource list:
-			Move.b	spID(A3),spID(A0)					; 	Need spSlot, spID, and 
-			Move.b	D4,spExtDev(A0)						; 	spExtDev.
-			_SRsrcInfo
-			Bne.s	@errRtn
-			
-			Swap	D4									; Get spID.									
-			
-			Move.b	D4,spID(A0)							; Make sure this sResource is the one
-			_SFindStruct								; 	with the driver in it.
-			Bne.s	@errRtn
-
-; Finally, now that we know that we on the right card/device and are looking at the right
-;	sResource, allocate relocatable space in the System heap and tell the caller where that
-;	space is.
-;
-			Move.l	A1,A4								; Point to base of LoadTbl.
-			Add.l	ltAddrOff(A1,D3),A4					; Add offset to driver and save pointer.
-			
-			Move.l	A1,A0								; Point to base of LoadTbl.
-			Add.l	ltSizeOff(A1,D3),A0					; Add offset to driver size and get pointer.
-			Move.l	(A0),D3								; Save driver size.
-			
-			Move.l	D3,D0								; Compact/Reserve some space for ourselves
-			_ResrvMem	,SYS							;	in the System heap.
-			Bne.s	@errRtn								; Get out if we couldn’t reserve the space.
-			
-			Move.l	D3,D0								; Attempt to allocate some space in the
-			_NewHandle	,SYS							;	System heap.
-			Bne.s	@errRtn								; Get out if we couldn’t get the space.
-			
-			Move.l	A0,A5								; Remember allocated handle, and prevent it
-			_HNoPurge									;	from being removed.
-			
-			Move.l	A4,A0								; Get address of driver code.
-			Move.l	(A5),A1								; Get address of allocated space.
-			Move.l	D3,D0								; Get size.
-			_BlockMove									; Move driver into allocated space.
-			
-			Move.l	A3,A0								; Restore spBlockPtr.
-			Move.l	A5,spResult(A0)						; Return driver handle in spResult.
-			
-			Moveq	#0,D0								; Return noErr.
-			Bra.s	@done
-
-@errRtn		Move.l	#smsGetDrvrErr,D0					; Couldn’t load driver error.			
-@done		Unlk	A6									; Restore stack frame.
-			Movem.l	(Sp)+,@saveRegs						; Restore registers.
-			Rts
-			
-;____________________________________________________________________________
-;
-;	GetDevIndex
-;
-;	Entry:		A0	-- points to spBlock.
-;
-;	Exit:		D0	-- contains index (0..n-1) or error value (<0).
-;
-;	Purpose:  The purpose of GetDevIndex is to cycle through a table of 
-;			  card/device identifiers.  If the card/device passed in
-;			  is in the device table, it’s entry is returned.  Otherwise,
-;			  a negative number (-1) is returned.  This is a utility routine
-;			  called by SlotGetDriverPatch and SlotPrimaryInitPatch.
-;
-;	Note:	  This routine Jsr’s (Bsr.l’s) to GetSlotDrvr directly due to
-;			  the fact that we might be coming from our patched out version
-;			  of GetSlotDrvr!  We need to do this so that we can compare
-;			  the version of the driver on the card with the one we know
-;			  about.  This is so that we don’t patch out newer (and
-;			  presumably compatible) versions of the PrimaryInit and Driver.
-;
-;____________________________________________________________________________
-
-			Macro										; Macro for jumping directly int
-			_GetSlotDriver								;	GetSlotDrvr (acting like trap dispatcher).								
-			Movem.l	A1/D1-D2,-(Sp)						; Save registers (A0 i/o, D0 is result).
-			Bsr.l	OrigGetSlotDrvr						; Make call.					<T8>
-			Tst.w	D0									; Act like Slot Manager for result.
-			Movem.l	(Sp)+,A1/D1-D2						; Restore registers.
-			EndMacro									;
-			
-			With	DevTblRec,spBlock,seBlock
-			Export	GetDevIndex 
-GetDevIndex 
-
-@saveRegs	Reg		A3-A5/D3-D4							; Define registers for work/saving, and
-			Movem.l	@saveRegs,-(Sp)						; 	store them on the stack.
-			Link	A6,#-spBlockSize					; Get a stack frame.
-			
-			Move.l	A0,A3								; Save current spBlock to simulate sExec.
-			Move.l	Sp,A0								; Point to stack spBlock.
-
-			Lea		DevTbl,A4							; Point to table of device identifiers.
-			Moveq	#0,D3								; Set entry index to 0.
-			
-@repeat		Move.b	spSlot(A3),spSlot(A0)				; Reset spSlot to the one we want.
-			Clr.w	spID(A0)							; Start search from top, no external devices.		<11>
-			Clr.b	spTBMask(A0)						; No mask (i.e., specific search).
-			Move.w	category(A4),spCategory(A0)			; Look for:  Category,
-			Move.w	cType(A4),spCType(A0)				;			 CType,
-			Move.w	drvrSW(A4),spDrvrSW(A0)				;			 DrvrSW,
-			Move.w	drvrHW(A4),spDrvrHW(A0)				;			 DrvrHW.
-			Clr.l	spParamData(A0)						; Look only for enabled sRsrcs.						<11>
-			Bset	#foneslot,spParamData+3(A0)			; Limit search to this slot only by
-			_GetTypeSRsrc								; 	using the new & improved routine.
-			
-			Bne.s	@until								; If this isn’t the device were looking for,
-														;	then keep going.				
-			
-			_GetSlotDriver								; Otherwise, attempt to load driver (for version #).
-			Bne.s	@dontPatch							; If it couldn’t be loaded, punt.
-			
-			Move.l	spResult(A0),A5						; Save driver handle (to dispose).
-			Move.l	(A5),A0								; Get driver pointer.
-			Lea		drvrName(A0),A0						; Get driver name.
-			
-			Clr.w	D0									; Clear D0.w (for use as index).
-			Move.b	(A0),D0								; Get the length of the driver name.
-			Addq	#2,D0								; Adjust offset to version field.
-			Bclr	#0,D0								; Adjust offset for word alignment.
-			Move.w	(A0,D0.w),D4						; Save the version number.
-			Move.l	A5,A0								; Get driver handle, and
-			_DisposHandle								;	dispose of it.
-			
-			Cmp.w	drvrVers(A4),D4						; If the card’s version ≠ to ours,					<11>
-			Bne.s	@until								;	then keep going.								<11><H5>
-			
-			Move.l	D3,D0								; Otherwise, copy the index into D0,
-			Bra.s	@done								;	and return.
-			
-@until		Adda	#DTEntrySize,A4						; Point to next entry in table, and
-			Addq	#1,D3								;	increment entry index.
-			Tst.w	(A4)								; If this isn’t the final entry, then							
-			Bne.s	@repeat								;	keep checking.
-			
-@dontPatch	Moveq	#-1,D0								; Flag that we don’t want to patch.
-@done		Unlk	A6									; Put stack frame back.
-			Movem.l	(Sp)+,@saveRegs						; Restore registers.
-			Rts		
-			
-			EndWith
-
-			
-;____________________________________________________________________________
-;
-;	Tables for PrimaryInit & GetDriver patches.
-;
-;	Note:  Keep these here and don’t export these labels!
-;____________________________________________________________________________
-
-			Import	TFBDrvr,TFBDrvrSize
-			Import	JMFBDrvr,JMFBDrvrSize
-			
-			Import	TFBPrimaryInit
-			Import	JMFBPrimaryInit
-			
-			Export	JsrTbl
-
-DevTbl		Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwTFB,0	 ; TFB  Entry									<11>
-			Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwJMFB,0 ; JMFB Entry									<11>
-			Dc.w	0									
-					
-			Align	4
-			
-LoadTbl		Dc.l	TFBDrvr-LoadTbl						; Start of TFB driver code.	
-			Dc.l	TFBDrvrSize-LoadTbl					; Length.
-			Dc.b	sRsrcDrvrDir						; TFB’s have an sRsrcDrvrDir.
-			Dc.b	0									; TFB’s are singly deviced.
-			Dc.b	0,0									; Padding.											<11>
-			
-			Dc.l	JMFBDrvr-LoadTbl					; Start of 4•8/8•24 driver code.
-			Dc.l	JMFBDrvrSize-LoadTbl				; Length.
-			Dc.b	sRsrcDrvrDir						; 4•8/8•24’s have an sRsrcDrvrDir.
-			Dc.b	0									; 4•8/8•24’s are singly deviced.
-			Dc.b	0,0									; Padding.
-			
-			Align	4
-			
-JsrTbl		Dc.l	TFBPrimaryInit-JsrTbl				; TFBPrimaryInit
-			Dc.l	JMFBPrimaryInit-JsrTbl				; 4•8/8•24 PrimaryInit
-
-
 ;=========================================================================================
 ;	slotinfo
 ;=========================================================================================
@@ -1971,6 +1731,12 @@ PtrToSlot	Proc	Export
 			MOVE.L	spsPointer(A0),D1				; D1 = sPointer
 			BEQ.S	@Done							; nil pointer - error
 
+			ROL.L	#8,D1
+			MOVE.B	ROMBase,D2
+			CMP.B	D2,D1
+			BEQ.S	@skip_older
+			MOVE.L	spsPointer(A0),D1
+
 ;  Determine the slot
 
 			clr.b	d1								; clear low byte of pointer				<2.1>
@@ -1984,10 +1750,11 @@ PtrToSlot	Proc	Export
 			MOVE.B	ROMBase,D2						; D2 = high byte of ROMBase
 			lsr.b	#4,d2							; shift high nib to low nibble			<2.1>
 			CMP.B	D2,D1							; same?
-			BHI.S	@FoundSlot						; must be other super slot space
+			BNE.S	@FoundSlot						; must be other super slot space
 			
 ;	Pointer is to ram or rom.  Translate it to slot 0.
 			
+@skip_older
 			MOVEQ	#0,D1							; access to host ROM - translate to slot 0
 			BRA.S	@FoundSlot
 
@@ -2553,13 +2320,9 @@ DeleteSRTRec
 
 ;	Last SRT block is empty - free the block.  Traverse SRT to end to nil the link ptr.
 
-@Free		MOVE.B	mmu32Bit,-(SP)				; save current mmu state <SM2> rb
-			MOVE.B	#false32b,D0				; <SM2> rb
-			_SwapMMUMode						; switch to 24 bit mode <SM2> rb
+@Free
 			MOVEA.L	A2,A0						; A0 = ptr to last SRT blk
 			_DisposPtr							; free the block
-			MOVE.B	(SP)+,D0					; recover status <SM2> rb
-			_SwapMMUMode						; restore mmu state <SM2> rb
 			MOVEA.L	sRsrcTblPtr,A1				; get ptr to beginning of SRT
 @Loop1		ADDA.W	#srtBlkSize,A1				; inc to end of blk
 			CMPA.L	srtNext(A1),A2				; found end of link ?
@@ -2697,6 +2460,7 @@ pNewSRTEntry
 
 			MOVE.L	spParamData(A0),D1			; save enable/disable flags
 			_sFindsInfoRecPtr					; get ptr to sinfo record
+			BNE.S	@Done
 			MOVEA.L	spResult(A0),A1				; A1 = ptr to sInfo record
 			MOVE.L	siDirPtr(A1),spsPointer(A0)	; set ptr to ROM directory
 			_sFindStruct						; search the ROM directory
@@ -3438,13 +3202,6 @@ shortvers	ds.w	1								; version and vector offset
 			lsr.b	#4,d0							; look at high nibble
 			cmp.b	#$0B,d0							; long bus exception frame ?
 			bne.s	@RealBusEx						; transfer to real bus exception handler
-			move.b	DFAddr(sp),d0					; get high byte of data fault cycle address
-			cmp.b	#majorSpace,d0					; in super slot space ($60-$E0) ?
-			blo.s	@RealBusEx						; not in slot address space
-			cmp.b	#$FF,d0							; in minor slot space range ?
-			beq.s	@RealBusEx						; not in minor slot space
-			cmp.b	#$F0,d0							; in minor slot space range ?
-			beq.s	@RealBusEx						; not in minor space $F1 - $FE
 
 ;	Have verified that a NuBus read data access caused the bus error.  Need to modify the
 ;	stack frame to return to the address in register a2.  Accomplish this by creating a new
@@ -3486,9 +3243,6 @@ shortvers	ds.w	1								; version and vector offset
 pInstallBus			
 			move.w	sr,-(sp)								; Save current interrupt level.
 			ori.w	#HiIntMask,sr							; disable interrupts
-			moveq	#True32B,d0
-			_SwapMMUMode									; change to 32 bit mode
-			move.b	d0,([sInfoPtr],entryMMUMode)			; save old mmu state
 			move.l	BusErrVct,([sInfoPtr],sysBusExcptn)		; save system bus vector in globals
 			move.l	([SDMJmpTblPtr],BusException*4),BusErrVct	; replace with slot mgr vector
 			move.w	(SP)+,SR								; restore interrupt state
@@ -3514,8 +3268,6 @@ pRestoreBus
 			move.l	d0,-(sp)						; save reg
 			move.w	sr,-(sp)						; Save current interrupt level.
 			ori.w	#HiIntMask,sr					; disable interrupts
-			move.b	([sInfoPtr],entryMMUMode),d0		; get saved mmu mode		
-			_SwapMMUMode								; restore mmu mode
 			move.l	([sInfoPtr],sysBusExcptn),BusErrVct	; restore system exception vector
 			move.w	(sp)+,sr							; restore interrupt state
 			move.l	(sp)+,d0							; restore reg
@@ -3804,9 +3556,10 @@ RemoveCard
 			with	spBlock,sInfoRecord
 
 CheckSlot
-@regs		reg		d1-d3/a1-a4
+@regs		reg		d1-d4/a1-a4
 			movem.l	@regs,-(sp)
 			moveq.l	#0,d3							; set d3 = change status flag
+			moveq.l	#0,d4
 
 ;	get ptr to slot's sInfoRecord so we can check its previous state
 
@@ -3822,6 +3575,12 @@ CheckSlot
 			cmp.w	#smReservedSlot,		\		; check for reserved slot
 					siInitStatusA(a4)
 			beq		@Return							; reserved slots not valid
+			cmp.w	#smEmptySlot,			\		; check for empty slot
+					siInitStatusA(a4)
+			bne.s	@notbad							; empty slots not valid
+
+			moveq.l	#-1,d4
+@notbad
 
 			moveq.l	#0,d1							; zero reg
 			move.b	spSlot(a0),d1					; d1 = slot number
@@ -3859,12 +3618,15 @@ CheckSlot
 ;	Verify the format header  -  a0 = ptr to spblock, a1 = ptr to sInfoRecord
 
 @Verify
-			bsr.l	VerifySlot						; verify the config rom format
+			bsr	VerifySlot							; verify the config rom format
 			tst.w	siInitStatusA(a1)				; is the slot status ok?
 			bne.s	@CheckError						; bad or empty slot - check previous status
 
 ;	Config ROM verifies ok - walk through all the sResources looking for the board sResource
 
+			tst.l	d4
+			bne.s	@Changed
+
 			bsr		GetBoardID						; find the board sRsrc and board id
 			beq.s	@Changed						; no board id - a bad card
 
diff --git a/OS/SlotMgr/SlotMgrInit.a b/OS/SlotMgr/SlotMgrInit.a
--- a/OS/SlotMgr/SlotMgrInit.a
+++ b/OS/SlotMgr/SlotMgrInit.a
@@ -414,10 +414,6 @@ StartSDeclMgr
 			bsr		InitsPram					; initial a slot's PRAM
 			dbra	d1,@Loop
 
-;	Initialize the Docking Manager so built-in video and docking cards can use its facilities
-
-			BSR.L	InitDocking					; initialize the Docking Manager			<H4>
-
 ;	Set up the warm/cold start flag for later.												<SM8>
 
 			Moveq.l	#0,D2						; D2 = flag for cold start.
@@ -1074,9 +1070,11 @@ InitsPRAM
 			tst.w	siInitStatusA(a2)				; is the slot status ok?
 			beq.s	@readPRAM						; slot ok - read board id from pram
 			cmp.w	#smDisabledSlot,siInitStatusA(a2)	; is slot disabled?
-			beq.s	@Done							; don't touch disabled slot's pram
+			beq		@Done							; don't touch disabled slot's pram
 			cmp.w	#smReservedSlot,siInitStatusA(a2)	; is slot reserved?
-			beq.s	@Done							; reserved is the same as disabled
+			beq		@Done							; reserved is the same as disabled
+			cmp.w	#smEmptySlot,siInitStatusA(a2)	; is slot empty?
+			beq		@Done							; empty is the same as disabled
 			bra.s	@writePRAM						; slot status is bad - zero pram
 
 ;	Read PRAM to get the current board id.
@@ -1215,16 +1213,6 @@ doPrimaryInit
 			_sFindStruct
 			bne.s	@Done							; no primary init record - done
 
-			IF NOT LC930 THEN
-
-;	Identify Apple Cards whose PrimaryInit code is faulty, and execute fixed
-;	versions from the CPU ROM.
-			Bsr.s	PatchPrimaryInit					; If PatchPrimaryInit returns a 
-			Tst.b	D0									;	result >= 0, don’t execute
-			Bpl.s	@cleanup							;	normal PrimaryInit.
-			
-			ENDIF
-			
 ;	Load the code and execute the primary init record.
 ;
 			Move.l	A3,spsPointer(A0)					; Restore ptr to board sRsrc.
@@ -1241,66 +1229,6 @@ doPrimaryInit
 
 @done		Rts
 
-;____________________________________________________________________________
-;
-; PatchPrimaryInit and support (called from doPrimaryInit).
-;
-;	Entry:		A0		-- points to spBlock.
-;				A1		-- points to sInfoRecord.
-;				A2		-- (after restore from BigJump) points to sExec param blk.
-;				A3		-- points to board sResource.
-;
-;				D1		-- contains spSlot (we use spBlock.spSlot here, though).
-;	
-;	Exit:		A0-A3	-- preserved.
-;				D1		-- preserved.
-;
-;	Purpose:	The purpose of SlotPrimaryInitPatch is to identify Apple
-;				Cards whose PrimaryInit code is faulty, and execute fixed
-;				versions from the CPU ROM.
-;
-;				SlotPrimaryInitPatch is executed from the (non-exported)
-;				routine doPrimayInit in SlotInfo.a.
-;____________________________________________________________________________
-			
-			IF NOT LC930 THEN
-
-			With	seBlock,spBlock
-			Import	GetDevIndex,JsrTbl
-
-PatchPrimaryInit
-
-@saveRegs	Reg		A0-A3/D1/D3							; Define some work and scratch registers,
-			Movem.l	@saveRegs,-(Sp)						; 	and save them on the stack.
-			
-			Move.l	A0,A3								; Save the spBlockPtr for later.
-			
-			Bsr		GetDevIndex							; Get the device/card index into D0.
-			Move.l	D0,D3								; If the device index is negative, then
-			Bmi.s	@done								;	PrimaryInit doesn’t need patching.
-			
-			Lea		JsrTbl,A1							; Point to base of JsrTbl.
-			Lsl.l	#2,D3								; Adjust index.
-			
-			Move.l	A1,A0								; Copy base address.
-			Add.l	D3,A0								; Point to proper entry.
-			Add.l	(A0),A1								; Load A1 with effective address of PrimaryInit.
-			
-			Move.l 	A3,A0								; Restore spBlockPtr.
-			Move.b	spSlot(A0),seSlot(A2)				; Set the right slot number.
-			Move.b	spFlags(A0),seFlags(A2)				; Set the flags.
-			Move.l	A2,A0								; Set A0 to sExecBlkPtr for fake sExec call.
-			Jsr		(A1)								; Execute the PrimaryInit.
-			
-			Move.l	D3,D0								; Return result code.
-			
-@done		Movem.l	(Sp)+,@saveRegs
-			Rts
-
- 			Endwith
-
-			ENDIF
-
 ;_______________________________________________________________________________________	<h5> djw
 ;	StubCheckSlot	-	check if a slot status has changed
 ;
@@ -1363,48 +1291,6 @@ StubRemoveCard
 ;	spBlock	:	-> spSlot			slot number
 ;				-> spFlags			fWarmStart - if set then a warm start (may be used by primary
 EnableBlockXfer
-			Testfor	BARTExists					; are we on a ColdFusion or PDM
-			bne.s	@goodMach
-			Testfor	MUNIExists					; do we have MUNI Nubus Controller?
-			Beq		@exit						; no, leave
-			
-@goodMach	MoveM.l	A0/D0-D2, -(SP)
-			Clr.b	spID(A0)					; Begin search with ID 0.
-			Clr.b	spExtDev(A0)				; No external device(s).
-			Clr.b	spHwDev(A0)					; No hardware device(s).
-			Clr.b	spTBMask(A0)				; No mask in search.
-			Move.w	#catBoard,spCategory(A0)	; Look for:  Board sRsrc
-			Clr.w	spCType(A0)
-			Clr.w	spDrvrSW(A0)
-			Clr.w	spDrvrHW(A0)
-			Move.l	#(1<<foneslot), spParamData(A0)	; look only in this slot
-			_GetTypeSRsrc						; get slots board sRsrc
-			Bne.s	@done
-			Move.b	#sBlockTransferInfo, spID(A0)
-			_sReadLong							; does slot support block xfers?
-			Bne.s	@done						; no, leave
-			Move.l	spResult(A0), D0			; get sBlockTransferInfo long
-			BTst	#fIsSlave, D0				; handles blk xfer as slave? 
-			Beq.s	@done						; no, leave
-
-			Testfor	BARTExists					; are we on a ColdFusion or PDM
-			beq.s	@muni						; no, must be MUNI
-			BTst	#fSlvXferSz2, D0			; handles blk xfer size of 2?
-			Bne.s	@enable						; yes, go
-			BTst	#fSlvXferSz8, D0			; handles blk xfer size of 8?
-			Bne.s	@enable						; yes, go
-			bra.s	@done						; no, exit
-			
-@muni		BTst	#fSlvXferSz4, D0			; handles blk xfer size of 4?
-			Beq.s	@done						; no, leave
-			
-@enable		MoveQ	#0, D0
-			Move.b	spSlot(A0), D0
-			BSet	#8, D0						; make high word indicate enable blk xfer
-			Move.l	D0, A0
-			_SlotBlockXferCtl			
-
-@done		MoveM.l	(SP)+, A0/D0-D2
 @exit		Rts
 																							;end 	<LW2>
 
diff --git a/OS/StartMgr/Gibbly.r b/OS/StartMgr/Gibbly.r
--- a/OS/StartMgr/Gibbly.r
+++ b/OS/StartMgr/Gibbly.r
@@ -79,35 +79,8 @@ resource 'gbly' (-16385, sysHeap) {
 
 resource 'rovm' ( 0, locked) {
 	{
-	'pixs', -14335; 'pixs', -14334; 'pixs', -10199; 'pixs', -10200; 'pixs', -10201; 'pixs', -10202;
-	'pixs', -10203; 'pixs', -10204; 'pixs', -10205; 'pixs', -10206; 'pixs', -10207; 'pixs', -10208;
-	'CDEF', 0; 'CDEF', 1;
-	'WDEF', 0; 'WDEF', 1; 'WDEF', 126;
-//	'wctb', 0;
-//	'cctb', 0;
-	'CURS', 1; 'CURS', 2; 'CURS', 3; 'CURS', 4;
-	'MBDF', 0;
-	'MDEF', 0;
-//	'ppat', 16; 'ppat', 18;
-	'ics#', -16386;
-	'ics4', -16386;
-	'ics8', -16386;
-	'rtt#', -5728;
-//	'ppcc', -5856;
-	'KCAP', 1; 'KCAP', 2; 'KCAP', 4; 'KCAP', 5; 
-	'KCHR', 0;
-	'KMAP', 0; 'KMAP', 2;
-	'LDEF', 0; 'LDEF', 19; 'LDEF', -32510; 'LDEF', -32512;
-	'PACK', 0; 'PACK', 12;
-	'PACK', 3; 'PACK', 7; 'PACK', 8; 'PACK', 9; 'PACK', 11; 'PACK', 13; 'PACK', 14; 'PACK', 15;
-	'clut', 1; 'clut', 2; 'clut', 4; 'clut', 5; 'clut', 8; 'clut', 9; 'clut', 127;
-//	'ppci', -16409;
-//	'cmtb', -32508; 'cmtb', -32509; 'cmtb', -32510; 'cmtb', -32511; 'cmtb', -32512;
-	'mitq', 0;
-	'proc', -32512; 'proc', -32511; 'proc', -32510; 'proc', -16498; 'proc', -16497; 'proc', -5728, 'proc', -5727;
-	'pslt', 20; 'pslt', 26;
-	'snd ', 1;
-	'wedg', -5759; 'wedg', -5760;
+	'accl', 0; 'accl', 2; 'accl', 4; 'accl', 5; 'accl', 7; 
+	'clut', 1; 'clut', 2; 'clut', 4; 'clut', 8;
 	};
 };
 
diff --git a/OS/StartMgr/SizeMem.a b/OS/StartMgr/SizeMem.a
--- a/OS/StartMgr/SizeMem.a
+++ b/OS/StartMgr/SizeMem.a
@@ -314,446 +314,10 @@
 		WITH DecoderInfo,DecoderKinds,StartGlobals, RAMBankInfo						; <SM3> rb <SM8> CSS
 
 SizeMemory
-			move.l	a6,d3						; save return address
-
-			moveq	#0,d2						; don't know anything about machine
-			BigBSR6	GetHardwareInfo,a0
-			move.l	d3,a2						; now keep return address in a2
-
-			moveq	#0,d3						; clear a reg
-			move.b	d2,d3						; get memory controller type
-			add.w	d3,d3						; adjust for word table index
-			move.w	@splitTbl(d3.w),d3			; get offset to splitter routine
-			jmp		@splitTbl(d3.w)				; SWITCH(controller type)
-
-@splitTbl
-
-;	This table should match the DecoderKinds record in UniversalEqu.a
-
-			dc.w	SizeBanks		-@splitTbl	; unknown
-			dc.w	SizeBanks		-@splitTbl	; Mac Pal	(no splitting required)
-			dc.w	SizeBanks		-@splitTbl	; BBU		(no splitting required)
-			dc.w	SizeBanks		-@splitTbl	; Normandy	(no splitting required)
-			dc.w	@GlueSplit		-@splitTbl	; Mac2Glue
-			dc.w	SizeBanks		-@splitTbl	; MDU		(no splitting required)
-			dc.w	@FMCSplit		-@splitTbl	; OSS FMC
-			dc.w	@VisaSplit		-@splitTbl	; VISA										<T9>
-			dc.w	@OrwellSplit	-@splitTbl	; Orwell									<T9>
-			dc.w	@JAWSSplit		-@splitTbl	; JAWS
-			dc.w	@MSCSplit		-@splitTbl	; MSC										<7> HJR
-			dc.w	@SonoraSplit	-@splitTbl	; Sonora									<H4> SAM
-			dc.w	@NiagraSplit	-@splitTbl	; Niagra									<xxx>
-			dc.w	@YMCASplit		-@splitTbl	; Cyclone EVT4								<SM9> fau
-			dc.w	@djMEMCSplit	-@splitTbl	; djMEMc									<SM10><SM14>
-			dc.w	HMCMerge		-@splitTbl	; HMC (Go directly to the merge routine)	<SM25>									<SM10>
-			dc.w	@PrattSplit		-@splitTbl	; Pratt										<SM15>
-			dc.w	HHeadMerge		-@splitTbl	; HHead (Go directly to the merge routine)									<SM10>
-
+			move.l	a6,a2						; save return address
+			bra		PowerPCMerge
 			Align	4
-;_____________________________________________________________________________________________
-@GlueSplit
-			move.l	VIA2Addr(a0),a5				; Yes, get VIA2 base
-			ori.b	#$C0,VBufA(a5)				; put bank B on 64 meg boundary
-			bra		SizeBanks					; continue with sizing
-
-;_____________________________________________________________________________________________
-@FMCSplit
-			movea.l	FMCAddr(a0),a5				; get the FMC base address
-			move.w	#FMCInit,d2					; config reg value to put bank B on 64 meg boundary
-			moveq.l	#16-1,d3					; loop counter to load 16 bits
-@FMCload	move.b	d2,FMCConfig(a5)			; load in a bit
-			lsr.w	#1,d2						; put next bit into position
-			dbra	d3,@FMCload					; repeat till all bits loaded
-			move.b	d2,FMCLatch(a5)				; latch the config data
-			bra		SizeBanks					; continue with sizing
-
-;_____________________________________________________________________________________________
-;
-;	Make sure that the 4 banks are split apart onto their default 64MB boundaries.
-;	No other changes to the Orwell configuration register are needed because they
-;	have been set up in Universal.a and shouldn't require any changes or reconfiguration.
-;	See {IntAIncludes}HardwarePrivateEqu.a for a full description of this register.
-;_____________________________________________________________________________________________
-			WITH	ProductInfo
-
-@OrwellSplit
-		IF forSTP601 THEN
-			bra		OrwellMerge					; sized memory in HardwareInit.s 		<SM46>
-		ENDIF
-
-		IF forSmurf THEN						;										<SM24> SAM
-			cmp.b	#boxRiscQuadra700,ProductKind(a1)	; if we're on a Risc card		<SM29>
-			beq		SizeBanks					; >>SKIP this							<SM42>
-			cmp.b	#boxRiscQuadra900,ProductKind(a1)	; if we're on a Risc card		<SM29>
-			beq		SizeBanks					; >>SKIP this							<SM42>
-			cmp.b	#boxRiscQuadra950,ProductKind(a1)	; if we're on a Risc card		<SM29>
-			beq		SizeBanks					; >>SKIP this							<SM29>
-		ENDIF
-												; Eclipse/040 Memory Controller INIT	<4>
-			movea.l	DecoderAddr(a0),a5			; get base address of Orwell regs		<SM7>
-			lea		OrBankBCfgAddr(a5),a0		; get address of config regs.
-			move.l	#((ORINITBankB)|\			; get default bank-split values			<T6>
-					(ORINITBankC<<OrBankFieldSize)|\;									<T6>
-					(ORINITBankD<<2*OrBankFieldSize)),d3;								<T6>
-			moveq.l	#(3*OrBankFieldSize)-1,d2	; (18-1) -1 for DBRA,					<T3><T4><T6>
-
-@OrwellLoad	move.l	d3,(a0)+					; send that bit out there
-			lsr.l	#1,d3						; get the next bit in position
-			dbra	d2,@OrwellLoad				; repeat til all bits loaded			<T2>
-
-			move.l	d2,OrLoadBanks(a5)			; initialize DRAM bank starting addrs	<T2>
-												;
-			bra		SizeBanks					; continue with sizing
-
-;_____________________________________________________________________________________________
-@VisaSplit
-			move.l	RBVAddr(a0),a5				; Yes, get VISA base 					<6><SM4> rb, start
-			andi.b	#%00011111,VsExp(a5)	 	; clear size bits. Bits now set to 4MB on PCB						<H5><Begin>	
-											 	; and no memory in SIMMs						
-			movea.l	#$001FFFFE,a0				; Figure out whether we have 2/4mb on PCB by 	
-												; writing to 2/3 MB boundary.					
-			move.l	#$50616E44,(a0)		    	; Write a long word.  Low then high byte is written out to bus	
-			cmp.l	#$50616E44,(a0)		   		; If what we wrote is what we get back then we have 4MB on PCB.	
-			bne.s	@got2MB				
-			ori.b	#%11000000,VsExp(a5) 		; push RAM on PCB up to 8MB boundary so we can check how much RAM in SIMMs	
-			
-;••••••••••••••••••••••••••••••••																	
-; At this point we've determined that there is 4MB on PCB. We must now figure out how much
-; RAM is in the SIMM sockets before going on any further. If we have 8Mb in SIMMs then the
-; size bits are set correctly (we then lose 2Mb of on board memory), but if we have less than
-; 8Mb the size bits are incorrect and if left this way the on board memory will not be sized
-; correctly by the routines that follow and the chunk table will be wrong.
-
-			move.l	a5,a7						; save ptr to VISA base address in a7
-			move.l	a1,a5						; get product info ptr
-			adda.l	ProductInfo.RamInfoPtr(a5),a5
-			adda.l	#RAMInfoSize+4,a5			; '+4' taking into account the end of table mark
-			move.l	#0,a0						; start of bank A
-			move.l	#$00800000,a1				; end of bank A
-			move.l	#0,d0						; no previous banks sized
-			move.l	#$54696e61,d1				; setup signature
-			move.l	#0,d5						; clear bank size nibbles
-			BSR6	SizeBank					; how much memory do we have in Bank A?
-			cmp.l	#$00800000,a0				; SizeBank returns amount of RAM found in A0	
-
-			blt.s	@notMaxMem					; if less than 8mb found then reset size bits and RAM ranges
-
-			sub.l	#RAMInfoSize+4,a5
-			bra	continue
-@notMaxMem
-			ori.b	#%10000000,VsExp(a7)
-			andi.b	#%10011111,VsExp(a7) 		; set Bank A to 4mb, since this is the next size if not 8mb
-			bra		continue
-@got2MB	
-			ori.b	#%11100000,VsExp(a5) 		; set size bits to 10mb (i.e. 2mb on PCB and 8mb in SIMMs)
-									 			; we set Bank A to 8Mb so PCB RAM is pushed out of the way 
-									 			; so we can then get an accurate reading of Bank A RAM.		<SM4> rb, end			<H5><End>
-			bra		SizeBanks					; and continue with sizing
-
-			ENDWITH
-;_____________________________________________________________________________________________
-@NiagraSplit
-@JAWSSplit
-			moveq	#0,d0
-			movea.l	JAWSAddr(a0),a5				; get ptr to JAWS base
-			adda.l	#JAWSMemConfigA,a5
-			move.b	d0,(a5)						; set size reg A
-			adda.w	#JAWSMemConfigB-JAWSMemConfigA,a5
-			move.b	d0,(a5)						; set size reg B
-			adda.w	#JAWSMemConfigC-JAWSMemConfigB,a5
-			move.b	d0,(a5)						; set size reg C
-			bra		SizeBanks					; and continue with sizing <22> rb
-
-;_____________________________________________________________________________________________
-@MSCSplit
-			move.l	RBVAddr(a0),a5				; get MSC base (same as RBV's)			<H3> <SM12> begin
-			ori.b	#(1<<MSCBank8M)|\
-					 (%111<<MSCSize0),MSCConfig(a5)	; make all banks accessable			<H5>
-			MOVEA.L	A1,A5						; point to ProductInfo table			<H5>
-			ADDA.L	ProductInfo.RamInfoPtr(A5),A5	; point to the RAM bank map info	<H5>
-			BRA.S	@MSCRefresh					;										<H5>
-@MSCNextBank									;										<H5>
-			MOVEA.L	D2,A0						; point to the start of this bank		<H5>
-			MOVEQ	#8-1,D0						; make enough long word accesses to 	<H17>
-@RASLoop	TST.L	(A0)+						;   provide 8 RAS cycles of 			<H17>
-			DBRA	D0,@RASLoop					;	memory initialization				<H17>
-@MSCRefresh	ADDQ.L	#4,A5						; skip over the bank end				<H5>
-			MOVE.L	(A5)+,D2					; last RAM bank?						<H5>
-			BPL.S	@MSCNextBank				; -> nope								<H5>
-			bra		SizeBanks					; and continue with sizing				<7> HJR	<SM12> end
-
-;_____________________________________________________________________________________________
-@PrattSplit
-		IF 	forRomulator THEN
-			TestInRAM	a3										; are we in RAM?
-			bne			SizeBanks								; yes, then don't split
-		ENDIF
-			MOVEA.L	A1,A5							; point to ProductInfo table			
-			ADDA.L	ProductInfo.RamInfoPtr(A5),A5	; point to the RAM bank map info
-
-	IF BlackBirdDebug THEN
-			PrattFlashSystem					; IF FlashSystem THEN
-			bne.s	@Continue1					; 	
-			BigLea	RamInfoPrattFlash,a5		;	use phony Flash system RamInfoTables
-@Continue1										;
-	ENDIF										;
-			movea.l	PrattAddr(a0),a0			; get ptr to Pratt
-			move.b	#PrattDefDensity,\			;
-						PrattRAMDensity(a0) 	; set default RAM Density
-
-			move.b	#PrattDefConfig,\			; (don't worry, Pratt will do the right thing if there is Flash)
-						PrattRAMConfig(a0)		; set default RAM Configuration
-
-			;** WARNING ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING **
-			;The following line was added to test Pratt timing for OTPs currently in use for EVT's.
-			;For the final product, we need to decide what this value should really be.
-			;NOTE: This value does not affect execution speed from Flash.
-			move.b	#Pratt150nsROM,\
-						PrattROMSpeed(a0)
-			;** WARNING ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING ** WARNING **
-
-			; wait for at least 2mS so that Pratt has time to initialize the RAM banks to meet all
-			;  vendor specs (the HW spec is really ~500 uS, so we have some margin here)
-			move.w	#$3000,d2
-@stall		dbra	d2,@stall
-			
-			BRA.S	@PrattRefresh				;										
-
-@PrattNextBank									;										
-			MOVEA.L	D2,A0						; point to the start of this bank
-			TST.L	(A0)+						; make 8 accesses to each physical RAM bank (for added confidence)			
-			TST.L	(A0)+						
-			TST.L	(A0)+						
-			TST.L	(A0)+											
-			TST.L	(A0)+									
-			TST.L	(A0)+									
-			TST.L	(A0)+			
-			TST.L	(A0)+
-@PrattRefresh	
-			ADDQ.L	#4,A5						; skip over the bank end				
-			MOVE.L	(A5)+,D2					; last RAM bank?						
-			BPL.S	@PrattNextBank				; -> nope								
-			bra		SizeBanks					; and continue with sizing 
-
-;_____________________________________________________________________________________________
-@SonoraSplit													;										<H4>
-			MOVE.L	RBVAddr(A0),A5								; Get RBV (Sonora VIA2)	<H4>	<H2>
-			ORI.B	#%01111111,SonoraRAMSize(A5)				; Make each bank start at 16mg boundary	<H4><H3>
-																; and make bank 0 assume 4 megs of RAM	<H3>
-			BRA		SizeBanks									; and continue with sizing				<H4>
-
-
-;_____________________________________________________________________________________________
-@YMCASplit														;										
-		IF 	forRomulator THEN
-			TestInRAM	a3										; are we in RAM?
-			bne			SizeBanks								; yes, then don't split 				<SM13>
-		ENDIF
-
-; Set the width options for all 4-pairs of banks to 0 (Standard Mode)  This is necessary because 			<SM11> fau start
-; SizeMem is called multiple times by diagnostics, so the power-up values for the YMCA might be changed
-; by the time the 2nd call is made.
-
-			Move.l	DecoderAddr(A0),A5						; 	Get YMCA's Base address
-			Lea		YMCA_DRAMwidth0(a5),a5				; 	Get the base address for the first bank's width register
-			Clr.l	(A5)+								;	Bank's 0,2
-			Clr.l	(A5)+								;	Bank's 1,3
-			Clr.l	(A5)+								;	Bank's 4,6
-			Clr.l	(A5)+								;	Bank's 5,7										<SM11> fau end
-
-; Write to all 8 bank addresses to set their starting addresses 16 MB apart and to set their size to
-; 16 MBytes.
-			Move.l	DecoderAddr(A0),A5						; 	Get YMCA's Base address
-			Lea		YMCA_DRAMBank0_A20(a5),a5			; 	Get the base address for the first bank's A20 register
-
-			Moveq	#0,D0								;	D0 Contains the starting address
-			Move.w	#8-1,D5								;	No of banks
-			
-@NextBank			
-			Move.w	#BankBdryRegSize-1,d2				;	Size of boundary address register (bits A26..A20 starting at 0)
-			
-@loadBdry	Ror.l	#1,d0								;   Move bit 0 to bit 31
-			move.l	d0,(a5)+							; 	and write it out
-			dbra	d2,@loadBdry						;	continue for all bits
-
-			Rol.l	#BankBdryRegSize,D0					;	Return the address to it's starting position
-			Add.l	#$10,D0								;	Add (16M >> 20) to the address
-
-			Move.l	#%101,D1							;	D1 contains the size bits = 16MB banks
-			Move.w	#BankSizeRegSize-1,d2				;	size of memory bank size bits
-
-@loadSize	Ror.l	#1,d1								;	d1 = nibble size = bank size 
-			move.l	d1,(a5)+							; 	and write it out
-			dbra	d2,@loadSize						;	continue for all bits
-			dbra	d5,@NextBank						;	go look at the next bank
-
-			
-			BRA		YMCASizeBanks						; and continue with sizing				<SM11>
-														;										<SM9> fau, end
-
-;_____________________________________________________________________________________________			<H7> thru next <H7>			
-			WITH	ProductInfo
-
-@djMEMCSplit									;														<SM12>begin
-		IF forSTP601 THEN
-			bra		OrwellMerge		; sized memory in HardwareInit.s, so act exactly like STP Orwell machines	<SM48>
-		ENDIF
-		IF forSmurf THEN						;										<SM23>
-			cmp.b	#boxRiscCentris610,ProductKind(a1)	; if we're on a Risc card		<SM29>
-			beq		SizeBanks							; >>SKIP this					<SM29>
-			cmp.b	#boxRiscCentris650,ProductKind(a1)	; if we're on a Risc card		<SM29>
-			beq		SizeBanks							; >>SKIP this					<SM29>
-			cmp.b	#boxRiscQuadra800,ProductKind(a1)	; if we're on a Risc card		<SM29>
-			beq		SizeBanks							; >>SKIP this					<SM29>
-			cmp.b	#boxRiscQuadra610,ProductKind(a1)	; if we're on a Risc card		<SM30>
-			beq		SizeBanks							; >>SKIP this					<SM30>
-			cmp.b	#boxRiscQuadra650,ProductKind(a1)	; if we're on a Risc card		<SM30>
-			beq		SizeBanks							; >>SKIP this					<SM30>
-		ENDIF									;										<SM23> SAM
-;	We need to determine whether this machine is a WLCD or not.  Get VIA1 information.
-;
-;		Useful VIA1 PortA bits to read:  PA6, PA4, PA2, PA1  ($56)
-;
-;			PA6      = Lego (1), or Frigidaire (0) plastics for Wombat
-;			PA4, PA2 = CPU Speed.  0=20MHz, 1=25MHz, 2=33MHz, 3=40MHz
-;			PA1      = WLCD or Primus (0), or NOT! [reserved] (1)
-;
-
-			move.l	VIA1Addr(a0),a5				; get VIA1 address to get machine/cpu_speed info
-			moveq	#%00101000,d1				; force VIA1 VDirA to have the correct directions
-			move.b	d1,VDirA(a5)				; ... so we can read the CPU ID extension info
-
-;	Preset/Reset the Interleaving Enable register:
-;	----------------------------------------------
-;
-;	To be able to call SizeBanks repeatedly, we need to turn OFF any interleaving we may have
-;	turned on during previous SizeMemory calls.  However, if you are a WLCD, you want to have
-;	enabled the OneBufferedBus flag in the InterleaveEnable register.  _I_ would have put this
-;	bit in a different register (Configuration Register?) but since it's not, we have to make
-;	sure it is correctly set.
-;
-;	For WLCD and Primus, the OneBufferedBus bit MUST be set.
-;	For Wombat(s), the OneBufferedBus bit MUST be CLEARED.
-
-			moveq	#0,d0						; preset InterleaveEnable to NO interleaving				<H8>
-			btst.b	#1,VBufA(a5)				; PA1:  0 = WLCD, ≠0 = NOT WLCD								<H8>
-			bne.s	@writeIntReg				; IF ( machine_type == WLCD ) || ( machine_type == Primus )	<H16>
-			bset	#dj_OneBufferedBusBit,d0	;   set OneBufferedBus bit
-@writeIntReg									; ENDIF
-			LEA		MEMCAddr,A5					; Get djMEMC base
-			move.l	d0,MEMCIntleaveEnable(a5)	; disable interleaving, set/clear OneBufferedBus bit
-
-	; Reset the chip's MemTop
-	
-			MOVEQ	#-1,D0
-			MOVE.L	D0,MEMCmemTop(A5)			; Set MemTop reg to $FF
-
-	; Reset all bank Cfg Regs so each bank starts on a 64 mb boundary in preparation
-	; for sizeBanks. (ie put $110 in Cfg1, $120 in Cfg2, etc.)
-
-;_____________________________________________________________________________								<H8> thru next <H8>
-; MEMC DRAM Bank configuration registers look like this:  | 11-9 | 8 | 7-0 |
-;	Bits 11-9 	are unused.
-; 	Bit 	8	is DRAM addressing mode (0 = 64mb bank, 1 = 4mb or 16mb bank)
-; 	Bits  7-0	are bits 29-22 of the bank's starting physical address.
-;               (i.e. smallest bank size = 4mb)
-;
-;	Hysterical Note:  (BG - 92 June 10)
-;		The High-End HW team says that it is entirely unlikely that we'll
-;		see 64MBit parts any time in the near future, and it's unlikely that
-;		from power/voltage requirements that our boards would be able to
-;		support them.  So instead of writing the Sizing code to make two passes,
-;		one with bit 8 ZERO to check for 64MB banks, then a second pass for
-;		non-64MB parts to see whether or not they are there, we simply assume
-;		they are NOT there and set bit 8 front and make a single pass.
-;_____________________________________________________________________________
-
-			MOVE.L	#$100,D1					; Default bank start address (bits 29-22 of addr)
-			MOVEQ	#dj_MaxBanks-1,D0			; Loop counter (10 banks)									<H8>
-			LEA		MEMCdRAMCfg0(A5),A5			; Get starting bank Cfg reg base
-			
-@Loop		MOVE.L	D1,(A5)+
-			ADD.W	#$10,D1						; Bump the start addr by 64 meg (bits 29-22 of addr)
-			DBRA	D0,@Loop
-
-*			BRA.S	SizeBanks					; and continue with sizing									<H7>
-
-												;															<SM12>end
-
-			ENDWITH
-;=============================================================================================
-SizeBanks
-			movea.l	a1,a5						; pointer to product info table			<2.6>
-			adda.l	ProductInfo.RamInfoPtr(a5),a5	; point to the ram bank map info	<2.6>
-
-	IF BlackBirdDebug THEN
-			btst	#(PrattExists//8),(ProductInfo.BasesValid1+3-(PrattExists/8))(a1)
-			beq.s	@noPratt
-			PrattFlashSystem					; IF FlashSystem THEN
-			bne.s	continue					; 	
-			BigLea	RamInfoPrattFlash,a5		;	use phony Flash system RamInfoTables
-@noPratt
-	ENDIF										;
-
-Continue										; label needed for VISA memory sizing	<H5><SM4> rb
-			moveq	#0,d0						; clear total RAM size						<H8><SM12>
-			sub.l	a3,a3						; initialize the "bank 8-15" information	<H7><SM12>
-			subq.l	#1,a3						; ... to an improbable bank config value	<H8><SM12>
-@SizeBanks2										; label needed for djMEMC sizing 2nd half of table	<H8><SM12><SM13>
-			movea.l	a5,a7						; keep running copy in a7					<SM12>
-			addq.l	#4,a7						; skip over chunk size						<SM12>
-			moveq	#0,d5						; clear bank size nibbles
-			moveq	#0,d6						; clear error bits
-			move.l	#$54696e61,d1				; setup signature
-@nextBank
-			ror.l	#4,d5						; make room for next bank size nibble
-			ror.l	#4,d6						; make room for next bank error nibble
-			movea.l	(a7)+,a0					; get start of bank (or terminator)			<SM12>
-			move.l	a0,d2						; end of table?
-			cmpi.l	#'SamB',d2					; at end of 1st table?						<H8>
-			beq.s	@checkErr					; -> yes, check for errs then continue		<H8>
-			addq.l	#1,d2
-			beq.s	@checkErr					; yes, check for any errors	and quit		<SM12>
-			movea.l	(a7)+,a1					; get end+1 of bank							<SM12>
-
-			BSR6	CheckByteLanes				; any byte lanes valid at start?		<2.3>
-			moveq	#$0F,d3						; byte lane mask
-			and.b	d6,d3						; all byte lanes good here?
-			beq.s	@size						; yes, try next bank					<2.3>
-			cmp.b	#$0F,d3						; were all byte lanes bad?
-			bne.s	@nextBank					; no, leave mask with bad bits
-			eor.b	d3,d6						; yes, clear out bit mask
-			bra.s	@nextBank
-
-@size		BSR6	SizeBank					; find size of this bank
-			bra.s	@nextBank					; now size next bank...
-
-@checkErr	move.l	a7,d2						; Save A7									<H8><SM12>
-			sub.l	a5,d2						; (table end + 8) - table start				<H8><SM12>
-			subq.l	#8,d2						; #entries * 8								<H8><SM12>
-			lsr.w	#1,d2						; / 8 * 4 = # of nibbles to roll
-			rol.l	d2,d5						; d5 = ....dcba
-			rol.l	d2,d6						; d6 = ....dcba
-
-			tst.l	d6							; any errors?
-			bne.s	@badBanks					; -> Yes, return now						<H8> thru next <H8><SM12>
-			
-			move.l	a0,d2						; get the terminator or extend flag in D2	<SM12>
-			cmpi.l	#'SamB',d2					; Extended flag?							<SM12>
-			bne.s	@stitchEm					; -> Nope, we're done						<SM12>
-			move.l	d5,a3						; We have more to do, save D5 in A3			<SM12>
-			
-			move.l	a7,a5						; Point A5 at the 2nd half of RAMInfo		<SM12>
-			bra.s	@SizeBanks2					; -> make the second pass					<SM12><SM13>
-
-@stitchEm	move.l	a3,d2						; have we put anything in A3 yet?			<SM12>
-			addq.l	#1,d2						; if not, it was $FFFFFFFF					<SM12>
-			beq.w	Concat						; IF SomethingInA3 THEN						<SM12>
-			move.l	a3,d6						; Put the extended nibbles in D6			<SM12>
-			exg		d6,d5						; Put low order banks in d5, extended in d6	<SM12>
-			bra.w	Concat						; Sew baby sew!								<SM12>
-
-@badBanks	jmp		(a2)						; yes, return immediately					<H8><SM12>
+; (CDG5) Code removed but comments kept for context
 
 
 
@@ -773,194 +337,7 @@ YMCASizeBanks
 ;   the standard/wide mode is programmed by bank pair:  0/2, 1/3, 4/6, and 5/7.  Any bank can be populated, thus
 ;   have to watch out for nibble sizes of 0.  Well, enough of this.  FAU 10/21/92
 
-			movea.l	a1,a5							; pointer to product info table	
-			movea.l	a1,a7							; save a copy in a7 for the second sizing.
-			adda.l	ProductInfo.RamInfoPtr(a5),a5	; point to the ram bank map info
-
-		IF 	forRomulator THEN
-		
-			TestInRAM	a3						; Are we in RAM?
-			beq.s		@YMCAnotInRAM			; No?  Then carry on.
-												; Yes? Assume Bank A is 4 MB
-			movea.l	a5,A3						; keep running copy in A3
-			add.l	#$0C,A3						; skip over chunk size and bank A
-			move.l	#$00400000,d0				; set RAM size for bank A
-			moveq	#$01,d5						; set bank A size nibbles
-			moveq	#0,d6						; clear error bits
-			move.l	#$54696e61,d1				; setup signature
-
-			bra.s	@YMCAnextBank				; start checking at bank B
-@YMCAnotInRAM
-		ENDIF
-
-			movea.l	a5,A3						; keep running copy in A3
-			addq.l	#4,A3						; skip over chunk size
-			moveq	#0,d0						; clear total RAM size
-			moveq	#0,d5						; clear bank size nibbles
-			moveq	#0,d6						; clear error bits
-			move.l	#$54696e61,d1				; setup signature
-@YMCAnextBank
-			ror.l	#4,d5						; make room for next bank size nibble
-			ror.l	#4,d6						; make room for next bank error nibble
-			movea.l	(A3)+,a0					; get start of bank (or terminator)
-			move.l	a0,d2						; end of table?
-			addq.l	#1,d2
-			beq.s	@YMCAcheckErr				; yes, check for any errors
-			movea.l	(A3)+,a1					; get end+1 of bank
-
-			BSR6	CheckByteLanes				; any byte lanes valid at start?	
-			moveq	#$0F,d3						; byte lane mask
-			and.b	d6,d3						; all byte lanes good here?
-			beq.s	@YMCAsize					; yes, try next bank				
-			cmp.b	#$0F,d3						; were all byte lanes bad?
-			bne.s	@YMCAnextBank				; no, leave mask with bad bits
-			eor.b	d3,d6						; yes, clear out bit mask
-			bra.s	@YMCAnextBank
-
-@YMCAsize	BSR6	SizeBank					; find size of this bank
-			bra.s	@YMCAnextBank				; now size next bank...
-
-@YMCAcheckErr
-			suba.l	a5,A3						; (table end + 8) - table start
-			subq.l	#8,A3						; #entries * 8
-			move.l	A3,d2
-			lsr.w	#1,d2						; / 8 * 4 = # of nibbles to roll
-			rol.l	d2,d5						; d5 = ....dcba
-			rol.l	d2,d6						; d6 = ....dcba
-
-			tst.l	d6							; any errors?
-			bne		@ExitSizeMem				; if so, don't do the wide banks stuff
-
-; Now, resize the memory in wide mode. 
-; Save d5 in a7 and do the sizing with the wide mode.  Note, d0 has the total size of DRAM, but
-; we're going to recalculate this later, once we figure out which bank needs to be in standard mode and
-; which one is in wide mode
-
-;  Get back the RamInfoPtr and the Address of our Decoder
-
-			movea.l	a7,a5								; restore the pointer to the product info table
-			adda.l	ProductInfo.RamInfoPtr(a5),a5		; point to the ram bank map info	<2.6>
-			
-			movea.l	a7,a1								; restore the pointer to the product info
-			adda.l	ProductInfo.DecoderInfoPtr(a1),a1	; point to the decoder info stuff
-			movea.l	DecoderAddr(a1),a1					; And get the decoder address
-
-; Program the width registers to wide mode now
-
-			Lea		YMCA_DRAMwidth0(a1),a1		;   and get the offset to the width options register	
-			Move.l	#-1,(a1)+					;	Bank's 0,2
-			Move.l	#-1,(a1)+					;	Bank's 1,3
-			Move.l	#-1,(a1)+					;	Bank's 4,6
-			Move.l	#-1,(a1)+					;	Bank's 5,7
-
-; Save our nibble sizes for standard mode 
-
-			move.l	d5,a7						; save our standard mode bank sizes
-
-		IF 	forRomulator THEN
-		
-			TestInRAM	a3						; Are we in RAM?
-			beq.s		@2YMCAnotInRAM			; No?  Then carry on.
-												; Yes? Assume Bank A is 4 MB
-			movea.l	a5,A3						; keep running copy in A3
-			add.l	#$0C,A3						; skip over chunk size and bank A
-			move.l	#$00400000,d0				; set RAM size for bank A
-			moveq	#$01,d5						; set bank A size nibbles
-			moveq	#0,d6						; clear error bits
-			move.l	#$54696e61,d1				; setup signature
-
-			bra.s	@2YMCAnextBank				; start checking at bank B
-@2YMCAnotInRAM
-		ENDIF
-			movea.l	a5,A3						; keep running copy in A3
-			addq.l	#4,A3						; skip over chunk size
-			moveq	#0,d0						; clear total RAM size
-			moveq	#0,d5						; clear bank size nibbles
-			moveq	#0,d6						; clear error bits
-			move.l	#$54696e61,d1				; setup signature
-@2YMCAnextBank
-			ror.l	#4,d5						; make room for next bank size nibble
-			ror.l	#4,d6						; make room for next bank error nibble
-			movea.l	(A3)+,a0					; get start of bank (or terminator)
-			move.l	a0,d2						; end of table?
-			addq.l	#1,d2
-			beq.s	@2YMCAcheckErr				; yes, check for any errors
-			movea.l	(A3)+,a1					; get end+1 of bank
-
-			BSR6	CheckByteLanes				; any byte lanes valid at start?
-			moveq	#$0F,d3						; byte lane mask
-			and.b	d6,d3						; all byte lanes good here?
-			beq.s	@2YMCAsize					; yes, try next bank			
-			cmp.b	#$0F,d3						; were all byte lanes bad?
-			bne.s	@2YMCAnextBank				; no, leave mask with bad bits
-			eor.b	d3,d6						; yes, clear out bit mask
-			bra.s	@2YMCAnextBank
-
-@2YMCAsize	BSR6	SizeBank					; find size of this bank
-			bra.s	@2YMCAnextBank				; now size next bank...
-
-@2YMCAcheckErr
-			suba.l	a5,A3						; (table end + 8) - table start
-			subq.l	#8,A3						; #entries * 8
-			move.l	A3,d2
-			lsr.w	#1,d2						; / 8 * 4 = # of nibbles to roll
-			rol.l	d2,d5						; d5 = ....dcba
-			rol.l	d2,d6						; d6 = ....dcba
-
-			tst.l	d6							; any errors?
-			bne		@ExitSizeMem				; if so, don't do the wide banks stuff
-
-; We have finished sizing the memory in wide mode.  a7 has the nibble sizes with standard mode, 
-; and d5 has the nibble sizes in wide mode.
-
-			Move.l	a7,d4				
-			
-; OK, at this point d4 contains the nibble sizes when sized in standard mode and d5 contains the
-; nibble sizes when sized in wide mode.  We now need to determine, for each bank, which nibble contains
-; the largest amount of ram and program the YMCA to the corresponding Std/Wide option.  We'll put the
-; combined nibble sizes into d0 and then move it to d5, as that's what the Concat routine expects.
-
-			Move.l	#$50f30420,a3				; YMCA Width Register
-			Lea		YMCAWidthOffsets,a0			; Offset lookup table
-			clr.w	d1							; Use d1 as our loop/bank counter
-			clr.l	d0							; d0 will contain the combined nibbles					
-
-@LoopBanks			
-			move.b	d4,d2						; we need to compare lower nibbles only (d2: std)
-			andi.b	#$0f,d2						; so mask out higher nibble
-			move.b	d5,d3						; we need to compare nibbles only (d3: wide)
-			andi.b	#$0f,d3						; so mask out higher nibble
-			cmp.b	d3,d2						; d3<-wide, d2<-standard
-			bhs.s	@StdMode					; if d2 is ≥ then program in standard mode					<LW4>
-			or.b	d3,d0						; else, d3 is > so or move nibble into our keeper
-			Tst.b	d3							; Was our bank size 0										<LW4>
-			beq.s	@NextNibble					; Don't set the width register if the size is 0
-			Move.w	(a0,d1.w*2),a1				; get offset for this bank
-			adda.l	a3,a1						; and add the base of the width registers
-			Move.l	#-1,(a1)					; and write it out
-			bra.s	@NextNibble					; go look at next nibble
-@StdMode
-			or.b	d2,d0						; Standard width size into the keeper
-												; program bank d1 to std mode
-			Tst.b	d2							; Was our bank size 0										<LW4>
-			beq.s	@NextNibble					; Don't set the width register if the size is 0
-			Move.w	(a0,d1.w*2),a1				; get offset for this bank
-			adda.l	a3,a1						; and add the base
-			Clr.l	(a1)						; and write it out
-@NextNibble
-			lsr.l	#4,d4						; look at next nibble of standard mode
-			lsr.l	#4,d5						; look at next nibble of wide mode
-			ror.l	#4,d0						; make room for next nibble in our keeper
-			addi.w	#1,d1						; increment our loop counter
-			cmpi.w	#8,d1						; have we done all 8 banks?
-			bne.s	@LoopBanks					; go loop through the banks
-			
-			move.l	d0,d5						; put the nibble sizes into d5
-
-			bra		Concat						; no, then stitch banks together (if possible)
- 
-@ExitSizeMem
-			jmp		(a2)						; yes, return immediately
+; (CDG5) Code removed but comments kept for context
 ;																											<SM11> fau end
 ;_____________________________________________________________________________________________
 ; Routine:	SizeBank
@@ -988,51 +365,7 @@ YMCASizeBanks
 ; This routine assumes that the data cache is OFF.  The addresses passed in
 ; must be on page boundaries, where the page size is in D0.
 ;_____________________________________________________________________________________________
-SizeBank
-			move.l	a0,d4				; save start of bank
-
-			subq.l	#4,a1				; point to end-4 of bank
-@check		move.l	(a1),d2				; save original
-			move.l	d1,(a1)				; write signature at top
-			
-@here		tst.l	(@here)				; Bus capacitance is a no, no.			<H9> SAM
-			
-			cmp.l	(a1),d1				; any RAM there?
-			beq.s	@foundRAM			; yes, check for wrap
-
-			suba.l	(a5),a1				; step back to lower block
-			cmpa.l	a0,a1				; stepped below start?
-			bgt.s	@check				; no, continue looking for RAM
-			bra.s	@exit				; yes, exit
-
-@foundRAM
-			subq.l	#4,a0				; go 4 bytes back from start
-@loop		adda.l	(a5),a0				; add in chunk size
-			cmp.l	(a0),d1				; found lowest occurance of signature?
-			bne.s	@loop				; no, check a little higher up
-
-			move.l	d2,(a0)+			; restore last four bytes we wiped out
-@length		suba.l	d4,a0				; leave a0 with size of bank
-
-			moveq	#0,d3				; n=0
-			move.l	a0,d2				; any ram?
-			beq.s	@stuff				; no, stuff n=0 into size register
-
-			move.l	(a5),d2				; start with smallest chunk size (e.g. 1M)
-@next		addq	#1,d3				; n=n+1
-			cmpa.l	d2,a0				; (2^(n-1))*chunk size = bank size?
-			beq.s	@stuff				; yes, stuff 'n' into d5
-
-; If a0 < d2 then something is wrong!  Stuff 0 into d3 and exit.										<SM10> fau
-
-			blt.s	@NotAPowerofTwo		; Our loop has gone over a possible match, so better bailout	<SM10> fau
-			add.l	d2,d2				; calculate next power of two
-			bra.s	@next
-@NotAPowerofTwo																							;<SM10> fau
-			moveq	#0,d3				; say no memory.
-@stuff		or.b	d3,d5				; 'OR' in 'n' (size of this bank)
-			add.l	a0,d0				; add this banks RAM to total size
-@exit		RTS6
+; (CDG5) Code removed but comments kept for context
 
 
 ;_____________________________________________________________________________________________
@@ -1054,28 +387,7 @@ SizeBank
 ; a0.  This helps service identify missing SIMMs, etc.  It can be called up
 ; to 8 times (for 8, 4-byte-wide banks) before overflowing the result register.
 ;_____________________________________________________________________________________________
-CheckByteLanes							;												<2.3>
-			move.l	(a0),d3				; preserve original value
-			move.l	4(a0),d4			; preserve next value							<2.8>
-			move.l	d1,(a0)				; write signature
-
-			moveq	#4-1,d2
-@next		move.l	#$FFFFFFFF,4(a0)	; take care of stray capacitance on bus			<2.8>
-			cmp.b	(a0,d2.w),d1		; did this byte match?
-			bne.s	@bad				; no, shift in error bit
-
-			not.b	d1					; yes, try compliment to make sure
-			not.b	(a0,d2.w)			; compliment RAM value
-			cmp.b	(a0,d2.w),d1		; did compliment match?
-			beq.s	@shift				; yes, next byte...
-
-@bad		bset	d2,d6				; set bad bit mask								<2.9>
-
-@shift		ror.l	#8,d1				; next signature byte
-			dbra	d2,@next			; do next byte
-			move.l	d3,(a0)				; restore original at start
-			move.l	d4,4(a0)			; restore next value							<2.8>
-			RTS6
+; (CDG5) Code removed but comments kept for context
 
 
 
@@ -1091,55 +403,7 @@ CheckByteLanes							;												<2.3>
 ;
 ; This routine vectors to the appropriate 'stitch' routine, after getting the decoder type.
 ;_____________________________________________________________________________________________
-Concat		move.l	d0,d3						; save last size						<9>
-			moveq	#0,d2						; don't know anything about machine
-			movea.l	#aStack,sp					; set stack pointer value
-			move.l	a2,d4						; save return address
-			BigBSR6	GetHardwareInfo,a0			; get universal info again
-			movea.l	d4,a2						; restore return address
-
-	IF BlackBirdDebug THEN
-			btst	#(PrattExists//8),(ProductInfo.BasesValid1+3-(PrattExists/8))(a1)
-			adda.l	ProductInfo.RamInfoPtr(a1),a1	; point to the ram bank map info
-			beq.s	@Continue1
-			PrattFlashSystem					; IF FlashSystem THEN
-			bne.s	@Continue1					; 	
-			BigLea	RamInfoPrattFlash,a1		;	use phony Flash system RamInfoTables
-@Continue1										;
-	ELSE										;
-			adda.l	ProductInfo.RamInfoPtr(a1),a1	; point to the ram bank map info
-	ENDIF
-			add.b	d2,d2						; decoder type adjusted for word table access
-			ext.w	d2
-			move.w	@mergTbl(d2.w),d1			; get offset to merger routine
-			move.l	(a1)+,d2					; get chunk size in d2 now
-			jmp		@mergTbl(d1.w)				; call routine (d2=chunk size, a1=1st table entry)
-
-@mergTbl
-
-;	This table should match the DecoderKinds record in UniversalEqu.a			<SM9> fau
-
-			dc.w	noMerge			-@mergTbl	; unknown
-			dc.w	noMerge			-@mergTbl	; Mac Pal	(no merging required)
-			dc.w	noMerge			-@mergTbl	; BBU		(no merging required)
-			dc.w	noMerge			-@mergTbl	; Normandy	(no merging required)
-			dc.w	GlueMerge		-@mergTbl	; Mac2Glue
-			dc.w	MDUMerge		-@mergTbl	; MDU		(no merging possible)
-			dc.w	FMCMerge		-@mergTbl	; OSS FMC
-			dc.w	VISAMerge		-@mergTbl	; VISA									<T9>
-			dc.w	OrwellMerge		-@mergTbl	; Orwell								<T9>
-			dc.w	JAWSMerge		-@mergTbl	; JAWS
-			dc.w	MSCMerge		-@mergTbl	; MSC									<7> HJR
-			dc.w	SonoraMerge		-@mergTbl	; Sonora								<H4> SAM
-			dc.w	NiagraMerge		-@mergTbl	; Niagra								<xxx>
-			dc.w	YMCAMerge		-@mergTbl	; YMCA									<SM9> fau
-			dc.w	djMEMCMerge		-@mergTbl	; djMEMC (djMEMC has a max of 10 banks)	<H7><SM12>
-			dc.w	HMCMerge		-@mergTbl	; HMC									<SM18> SAM
-			dc.w	PrattMerge		-@mergTbl	; Pratt									<SM15>
-			dc.w	HHeadMerge		-@mergTbl	; HHead	
-			
-			
-			Align	4
+; (CDG5) Code removed but comments kept for context
 
 
 ;_____________________________________________________________________________________________
@@ -1160,14 +424,164 @@ Concat		move.l	d0,d3						; save last size						<9>
 ; This routine simply writes the chunk table at the top of the bank (pointed to by a1), given
 ; the banks size in d0.  Used ONLY for single bank systems (like MacPlus, SE, Portable).
 ;_____________________________________________________________________________________________
-noMerge											;												<9>
-			moveq	#(3*4)+(1*8),d1				; size of chunk table for this decoder
-			bra		writeChunkTable				; write chunk table and exit...
+; (CDG5) Code removed but comments kept for context
 
 
 
 
 
+;____________________________________________________________________________________________
+; Routine:	PowerPCMerge (emulated system fake stitch and fake chunk table creation)
+; Very similar to OrwellMerge, HMCMerge, HHEadMerge (whose comments are preserved below)
+;____________________________________________________________________________________________
+		export	PowerPCMerge
+
+PowerPCMerge
+		With	NKSystemInfo, ProductInfo, VideoInfo
+		
+		MOVEQ	#0,D5
+
+; Read PRAM to see if the user wants an EDisk.  If the size is > MinRamDiskSize then ask the	<SM21> SAM
+; nanokernel for some RAM.
+
+		MOVE.L	A2,D3										; Save SizeMem's return address
+
+		LongBSR6 GetHardwareInfo							; Get universal info again
+		
+		LSR.W	#8,D2										; Get the boxflag in the low byte	<SM27>
+		MOVE.B	D2,D7										; Save it in D7						<SM27>
+		
+		MOVEQ	#0,D4										; unclear purpose
+		MOVEQ	#1,D4
+
+		MOVE.L	$68FFEFF0,A2								; Read the EDisk size (in % of total RAM) in D1
+		MOVE.B	$128(A2),D1
+		MOVE.L	D3,A2										; Restore the return address
+					
+; Get the MMU page size from the nanokernel.  Count bits in the result to get a shift factor
+
+		MOVEQ	#0,D3										; Clear D3
+		MOVE.L	([ProcessorInfoPtr],ProcessorInfo.PageSize),D0	; Get the Page size from the nano-k
+		BFFFO	D0{15:15},D3								; Get the shift factor (Find First One)
+		NOT.B	D3											; Flip the order (BF instr start at bit 32 -> )
+		ADD.B	#32,D3										; Get the bit number (lsb based)
+
+		MOVE.L	(NKSystemInfoPtr),A5						; Point to the nanokernel SystemInfo record
+		ANDI.L	#$FF,D1										; Clear upper bytes of pram byte
+		BEQ.S	@AfterRAMDiskCheck							; -> No EDisk
+		
+		MOVE.L	PhysicalMemorySize(A5),D2					; Get physical RAM size
+		LSR.L	#8,D2										; Scale the size by 256k chunks
+		MULU.L	D1,D2										; Mult Chunks by ChunkCount from PRAM = EDisk size
+		ADD.L	#$7FFF,D2									; Add an extra 32k to the size
+		AND.W	#$8000,D2									; Round down to 32k boundary
+		CMPI.L	#MinRamDiskSize,D2							; Is this size too small? (user pulled some SIMMs)
+		BCC.S	@notSml
+		MOVE.L	#MinRamDiskSize,D2
+@notSml	CMPI.L	#MaxRamDiskSize,D2
+		BHI.S	@AfterRAMDiskCheck
+
+		MOVE.L	PhysicalMemorySize(A5),D1
+		SUBI.L	#$600000,D1
+		CMP.L	D1,D2
+		BLS.S	@consrv
+		MOVE.L	D1,D2
+@consrv	MOVE.L	D2,D5
+		ADD.L	D2,D7
+
+		MOVE.L	#bRamDisk,D0								; Get the EDisk logical base address
+		LSR.L	D3,D0										; Turn the address into a page number
+		MOVE.L	D0,A0										; Put the logical page number in A0
+
+		LSR.L	D3,D2										; Turn the size into a page count
+		MOVE.L	D2,A1										; Put page count in A1
+
+		MOVEQ	#0,D1										; Indicate no special alignment necessary
+		_nkAllocateMemory									; Get the RAM and map it where we asked
+
+@AfterRAMDiskCheck
+													;										End	<SM48>
+************************************************************************
+; Activate the Dynamically Recompiling Emulator
+
+		MOVEQ		#19,D0										; Only if the low 2 bits of ECR19 == 01
+		_MoveFromECR
+		BNE		@Chunky
+		MOVE.L	A0,D0
+		AND		#3,D0
+		CMP		#1,D0
+		BNE		@Chunky
+
+		MOVE.L	A2,D3										; save return addr around GetHardwareInfo
+		MOVEQ	#0,D2										; tell it nothing
+		BigBSR6	GetHardwareInfo								; single, insulated call
+		MOVE.L	(NKSystemInfoPtr),A2						; reach totally unexpectedly into SystemInfo!
+		MOVE.B	$129(A2),D1									; ...and get the number of Tcache pages
+		MOVE.L	D3,A2										; restore return address
+		MOVE.L	(NKSystemInfoPtr),A5						; restore clobbered A5 ptr
+
+		MOVEQ	#0,D3										; Clear D3
+		MOVE.L	([ProcessorInfoPtr],ProcessorInfo.PageSize),D0	; Get the Page size from the nano-k
+		BFFFO	D0{15:15},D3								; Get the shift factor (Find First One)
+		NOT.B	D3											; Flip the order (BF instr start at bit 32 -> )
+		ADD.B	#32,D3										; Get the bit number (lsb based)
+
+		LSR		#4,D1										; the number we got is (pages - 16)
+		AND		#$F,D1										; and it had better be at least 16
+		BZ.S	@Chunky
+
+		ADDQ	#1,D1										; Calculate size of (number + 16) pages
+		SWAP	D1
+		CLR		D1
+		ADD.L	D1,D7										; (add that to our running total)
+
+		MOVE.L	D1,A0										; ECR22 = T-cache size
+		MOVEQ	#22,D0
+		_MoveToECR
+		MOVE.L	#$69000000,A0								; ECR21 = T-cache pointer
+		MOVEQ	#21,D0
+		_MoveToECR
+
+		MOVE.L	A0,D0										; Allocate memory for the T-cache
+		LSR.L	D3,D0
+		MOVE.L	D0,A0										; A0 = logical page number
+		LSR.L	D3,D1
+		MOVE.L	D1,A1										; A1 = page count
+		MOVEQ	#0,D1										; D1 = no special alignment
+		_nkAllocateMemory									; no error check!
+
+		MOVEQ	#19,D0										; Set low bit of ECR19 to turn on DR!
+		_MoveFromECR
+		MOVE.L	A0,D1
+		BSET	#1,D1
+		MOVE.L	D1,A0
+		_MoveToECR
+
+; Now that RAM has been adjusted by the possible allocation of an EDisk, Video frame buffer
+; and/or DMA buffer, we can construct the RAM chunk table that sits at the top of logical RAM.
+; At this point A5 should be pointing to the nanokernel SystemInfo record.
+		
+@Chunky	MOVE.L	UsableMemorySize(A5),D1						; Get the Useable RAM size from NK
+		MOVE.L	D1,A5										; Put the size (our Memtop) in A5
+
+															; Start from the Top down
+		MOVE.L	D7,-(A5)									; Put our total allocation at the top of L RAM (Inc edisk). <MC8>
+		MOVE.L	D5,-(A5)									; Num bytes used by the EDisk								<MC8>
+		MOVE.L	#$45676773,-(A5)							; Diag long #3
+		MOVE.L	#$616E6420,-(A5)							; Diag long #2
+		MOVE.L	#$53616D20,-(A5)							; Diag long #1
+		MOVE.L	#-1,-(A5)									; Chunk table terminator
+		MOVE.L	D1,-(A5)									; Top of usable RAM
+		CLR.L	-(A5)										; Logical start of RAM
+
+		MOVE.L	A5,A1										; Put Ptr to chunk table in A1 for MergeDone
+		MOVEQ	#0,D6										; Signal no RAM test errors.
+		BRA		MergeDone									; Set the stack and leave
+
+		EndWith
+
+
+
 ;_____________________________________________________________________________________________
 ; Routine:	HMCMerge (emulated system fake stitch and fake chunk table creation)				<SM18> Sam
 ;
@@ -1200,253 +614,7 @@ noMerge											;												<9>
 ; D7 is used as a flag register for the size of the RAM Disk and whether or not to allocate Video RAM
 ; 				bit 31: high = allocate Video RAM (bit is cleared when testing to turn on video or not)
 ;_____________________________________________________________________________________________
-			export	HMCMerge
-
-HMCMerge														;									<SM18> Sam
-		 	With	NKSystemInfo, ProductInfo, VideoInfo
-
-			MOVE.L	A2,D6										; Save SizeMem's return address
-
-			LongBSR6 GetHardwareInfo							; Get universal info again
-			MOVE.L	DecoderInfo.VIA1Addr(A0),A2 				; Get VIA1's base address for RdXByte
-			
-	; Read PRAM locations (FC through FF) and test for one of several factory settings that
-	; tell us to allocate a frame buffer (even if no monitor is connected)
-
-			MOVEQ.L	#0,D7										; Clear the fb allocation flag
-			MOVE.W	#burnInLoc,D1								; 1st burn in byte
-			BSR6	RdXByte										; Read the Factory data
-			MOVE.B	D1,D3										; Save hi byte
-			SWAP	D3
-			LSL.L	#8,D3										; Shift to high byte
-			MOVEQ	#0,D1										; Prep D1 for PRAM data
-			MOVE.W	#burnInLoc+1,D1								; 2nd burn in byte
-			BSR6	RdXByte										; Read the Factory data
-			SWAP	D1											; Save second hi byte
-			OR.L	D1,D3										;
-			MOVEQ	#0,D1										; Prep D1 for PRAM data
-			MOVE.W	#burnInLoc+2,D1								; 3rd burn in byte
-			BSR6	RdXByte										; Read the Factory data
-			LSL.W	#8,D1										; Shift byte to second low byte
-			OR.L	D1,D3										;
-			MOVEQ	#0,D1										; Prep D1 for PRAM data
-			MOVE.W	#burnInLoc+3,D1								; 4th burn in byte
-			BSR6	RdXByte										; Read the Factory data
-			OR.L	D3,D1										; OR in the result
-
-			CMP.L	#burninSig,D1								; Is this one of the factory settings?
-			BEQ		@GetFB										; -> Yes, allocate the frame buffer
-			CMP.L	#burnInSigAlt,D1							; Is this one of the factory settings?
-			BEQ		@GetFB										; -> Yes, allocate the frame buffer
-			CMP.L	#burnInSig12,D1								; Is this one of the factory settings?
-			BEQ		@GetFB										; -> Yes, allocate the frame buffer
-			CMP.L	#burnInSig13,D1								; Is this one of the factory settings?
-			BEQ		@GetFB										; -> Yes, allocate the frame buffer
-			CMP.L	#burnInSig15,D1								; Is this one of the factory settings?
-			BEQ		@GetFB										; -> Yes, allocate the frame buffer
-			CMP.L	#burnInSig16,D1								; Is this one of the factory settings?
-			BEQ		@GetFB										; -> Yes, allocate the frame buffer
-
-	; No factory enable.  Check to see what's connected.  If nothing is connected, do not
-	; allocate the frame buffer.
-
-			MOVE.L	#SonoraVdCtlBase,A0							; Offset from VIA1 base to Sonora Control Regs
-			ADD.L	A2,A0										; Add in VIA1 base. A0 points to SonoraCtrlRegs
-
-			MOVE.B	#$9F,SonoraVdModeReg(A0)					; Disable video (if it was on)			<MC7>
-			MOVE.B	#tristateSonoraSense,SonoraVdSenseRg(A0)	; Tristate the sense lines.
-			BSR6	CheckVidSense
-			CMP.B	#indexedNoConnect,D3						; If Sense == No Connect, check Extended Sense
-			BNE		@GetFB										; Otherwise turn of Video RAM
-
-			MOVEQ	#0,D1										; prep D1 for Extended sense data
-			MOVEQ	#0,D3										; prep D2 for Extended sense data
-				
-	; Sense lines indicate something might be connected.  Check the extended sense.
-
-	; Drive a, Read bc
-
-@DriveA		MOVE.B	#sonoraEnableAMask,SonoraVdSenseRg(A0)		; abc <- 011	
-			BSR6	CheckVidSense
-			ANDI.B	#sonoraAMask,D3								; 0BC				
-			MOVE.B	D3,D1										; 00 00 BC
-			LSL.B	#2,D1										; 00 BC 00
-				
-	; Drive b, Read ac
-
-@DriveB		MOVE.B	#sonoraEnableBMask,SonoraVdSenseRg(A0)		; abc <- 101
-			BSR6	CheckVidSense
-			ANDI.B	#sonoraBMask,D3								; A0C				
-			BCLR	#sonoraSenseLineA,D3						; A0C becomes
-			BEQ.S	@OrIn										;  A0C or
-			BSET	#sonoraSenseLineB,D3						;  A1C
-				
-@OrIn		OR.B	D3,D1										; 00 BC AC
-			LSL.B	#2,D1										; BC AC 00
-
-	; Drive c, Read ab
-
-@DriveC		MOVE.B	#sonoraEnableCMask,SonoraVdSenseRg(A0)		; abc -> 110
-			BSR6	CheckVidSense
-			ANDI.B	#sonoraCMask,D3								; AB0			
-			LSR.B	#1,D3										; 0AB
-			OR.B	D3,D1										; BC AC AB
-			
-			CMP.B	#extendedNoConnect,D1						; Is anything connected?
-			BEQ.S	@NoFB										; -> Nope, leave D7 alone.  Don't allocate the frame buffer
-
-@GetFB		BSET.L	#31,D7										; Set the "Allocate a DRAM frame buffer" flag
-@NoFB
-
-	; Read PRAM to see if the user wants an EDisk.  If the size is > MinRamDiskSize then ask the	<SM21> SAM
-	; nanokernel for some RAM.
-
-			LongBSR6 GetHardwareInfo							; Get universal info again
-			MOVE.L	DecoderInfo.VIA1Addr(A0),A2 				; Get VIA1's base address for RdXByte
-			
-			MOVE.W	#ramDiskPramAddr,D1							; Get the EDisk PRAM byte constant
-			BSR6	RdXByte										; Read the EDisk size (in % of total RAM) in D1
-			MOVE.L	D6,A2										; Restore the return address
-						
-			ADD.L	VideoInfoPtr(A1),A1							; Point A1 to the VideoInfo record for this machine
-			MOVE.L	VRAMLogAddr32(A1),D6						; Get the Logical Frame Buffer base address
-
-	; Get the MMU page size from the nanokernel.  Count bits in the result to get a shift factor
-	
-			MOVEQ	#0,D3										; Clear D3
-			MOVE.L	([ProcessorInfoPtr],ProcessorInfo.PageSize),D0	; Get the Page size from the nano-k
-			BFFFO	D0{15:15},D3								; Get the shift factor (Find First One)
-			NOT.B	D3											; Flip the order (BF instr start at bit 32 -> )
-			ADD.B	#32,D3										; Get the bit number (lsb based)
-
-			MOVEQ	#0,D5										; Clear the EDisk allocation size					<MC9>
-			MOVE.L	(NKSystemInfoPtr),A5						; Point to the nanokernel SystemInfo record
-			ANDI.L	#$FF,D1										; Clear upper bytes of pram byte
-			BEQ.S	@DMABuffer									; -> No EDisk, check DMA Buffer
-			
-			MOVE.L	PhysicalMemorySize(A5),D2					; Get physical RAM size			
-			LSR.L	#8,D2										; Scale the size by 256k chunks
-			MULU.L	D1,D2										; Mult Chunks by ChunkCount from PRAM = EDisk size
-			ADD.L	#$7FFF,D2									; Add an extra 32k to the size
-			AND.W	#$8000,D2									; Round down to 32k boundary
-			CMPI.L	#MinRamDiskSize,D2							; Is this size too small? (user pulled some SIMMs)
-			BLO.S	@DMABuffer									; -> Yes, too small.  No EDisk
-			CMPI.L	#MaxRamDiskSize,D2							; Is it too big?									<MC8>
-			BHI.S	@DMABuffer									; -> Yes, too big.  No EDisk
-
-			MOVE.L	LogicalMemorySize(A5),D0					; Get the logical size (Phys - nk private stuff)					<MC8> till next <MC8>
-			SUB.L	#PDMDMAbufSize,D0							; Subtract the DAM buffer size from Log RAM size
-			TST.L	D7											; Are we going to allocate 614k for a frame buffer?
-			BPL.S	@CheckMinHeap								; -> Nope, 
-			SUB.L	#604*1024,D0								; Subtract the frame buffer size if enabled		
-@CheckMinHeap
-			SUB.L	D2,D0										; Subtract the EDisk size
-			CMP.L	#MinHeapSize,D0								; Will we have at least MinHeapSize free after the EDisk?
-			BLT.S	@DMABuffer									; -> No, do not allocate the EDisk (signed)							<MC9>
-
-			MOVE.L	D2,D5										; Save the number of bytes used by the EDisk in the chunk table.	<MC8>
-			ADD.L	D2,D7										; Add the size to our running allocation counter
-			MOVE.L	#bRamDisk,D0								; Get the EDisk logical base address
-			LSR.L	D3,D0										; Turn the address into a page number
-			MOVE.L	D0,A0										; Put the logical page number in A0
-
-			LSR.L	D3,D2										; Turn the size into a page count
-			MOVE.L	D2,A1										; Put page count in A1
-
-			MOVEQ	#0,D1										; Indicate no special alignment necessary
-			_nkAllocateMemory									; Get the RAM and map it where we asked
-
-	; Allocate space for the DMA buffer
-
-@DMABuffer	MOVE.L	#PDMDMAbufSize,D0							; Get the hard coded DMA buffer size (160k)
-			ADD.L	D0,D7										; Add the DMA buffer size to our counter
-			LSR.L	D3,D0										; Turn the byte count into a page count
-			MOVE.L	D0,A1										; Put page count in A1
-
-			MOVE.L	#PDMDMAlogAddr,D0							; Get the desired logical address
-			LSR.L	D3,D0										; Turn it into a page number
-			MOVE.L	D0,A0										; Put the logical page number in A0
-
-			MOVE.L	#(256*1024)-1,D1							; Align physical address to 256k boundary (AMIC Requirement)
-			LSR.L	D3,D1										; Make that a page alignment
-			_nkAllocateMemory									; Get the DMA buffer RAM.
-	
-	; Due to a DataPath bug, all byte-assembled buffers need to be marked noncacheable (floppy & serial).
-	; Due to an IBM bug, all the rest of the DMA buffers need to be marked noncacheable (marginal parts
-	; don't like Global/ARty being asserted).
-	
-			MOVE.L	#PDMDMAbufSize,D2							; Get the number of bytes to mark noncacheable (all of them)
-			LSR.L	D3,D2										; Convert that to a page count
-			SUBQ	#1,D2										; Make it zero based for DBRA
-			
-			MOVE.L	#PDMDMAlogAddr,D0							; Start of non cacheable range
-			LSR.L	D3,D0										; Turn it into a logical page number
-			MOVE.L	D0,A0										; Put the page number in A0
-			
-@NoCacheLup	_nkMMUMakePageNonCacheable							; Disable the cache for this page		<SM27>
-			LEA		1(A0),A0									; PageNumber++
-			DBRA	D2,@NoCacheLup								; -> Do this for each page 
-
-	; Allocate RAM for the RAM Based Video (NQD writes *past* the end of the buffer.  Get some slop for sloppy...)
-
-			BCLR.L	#31,D7										; If zero don't allocate the frame buffer
-			BEQ.S	@Chunky										; -> Do not allocate the frame buffer
-
-			MOVE.L	#604*1024,D2								; Get 618496 (604k) bytes (max RBV can support w/slop)
-			ADD.L	D2,D7										; Add the frame buffer size to our counter
-			LSR.L	D3,D2										; Turn the byte count into a page count
-			MOVE.L	D2,A1										; Page Count -> A1
-			
-			LSR.L	D3,D6										; Turn the logical video base into page number
-			MOVE.L	D6,A0										; Logical Page # -> A0
-			MOVEQ	#-1,D1										; Force the allocation to start at phys 0 (HMC Requirement)
-			LSR.L	D3,D1										; Make that a page alignment
-			_nkAllocateMemory									; Get the RAM and map it where we asked
-
-	; Make the frame buffer RAM cache mode WriteThrough
-	
-			SUBQ	#1,D2										; Make the RBV page count zero based
-@CacheLupe	_nkMakePageWriteThrough
-			LEA		1(A0),A0									; PageNumber++
-			DBRA	D2,@CacheLupe								; -> Do this for •every• page 
-
-	; Now that RAM has been adjusted by the possible allocation of an EDisk, Video frame buffer
-	; and/or DMA buffer, we can construct the RAM chunk table that sits at the top of logical RAM.
-	; At this point A5 should be pointing to the nanokernel SystemInfo record.
-			
-@Chunky		MOVE.L	UsableMemorySize(A5),D1						; Get the Useable RAM size from NK
-			MOVE.L	D1,A5										; Put the size (our Memtop) in A5
-
-																; Start from the Top down
-			MOVE.L	D7,-(A5)									; Put our total allocation at the top of L RAM (Inc edisk). <MC8>
-			MOVE.L	D5,-(A5)									; Num bytes used by the EDisk								<MC8>
-			MOVE.L	#$68657265,-(A5)							; Old Unused Diag long #3
-			MOVE.L	#$77617320,-(A5)							; Old Unused Diag long #2
-			MOVE.L	#$53616D20,-(A5)							; Old Unused Diag long #1
-			MOVE.L	#-1,-(A5)									; Chunk table terminator
-			MOVE.L	D1,-(A5)									; Top of usable RAM
-			CLR.L	-(A5)										; Logical start of RAM
-
-			MOVE.L	A5,A1										; Put Ptr to chunk table in A1 for MergeDone
-			MOVEQ	#0,D6										; Signal no RAM test errors.
-			BRA		MergeDone									; Set the stack and leave
-
-			EndWith
-
-CheckVidSense
-
-			MOVE.W	#550,D0										; 550 iterations
-@WaitLupe	TST.B	vIER(A2)									; Wait ~1.2µs
-			DBRA	D0,@WaitLupe								; -> Keep looping for ~550µs
-
-			MOVEQ	#0,D3										; D2 used as senseline scratch.
-			MOVE.B	SonoraVdSenseRg(A0),D3						; Read the lines into scratch.
-			LSR.B	#4,D3										; Get inputs out of upper nybble.
-					
-			MOVE.W	#550,D0										; 550 iterations
-@WaitLupe2	TST.B	vIER(A2)									; Wait ~1.2µs
-			DBRA	D0,@WaitLupe2								; -> Keep looping for ~550µs
-			RTS6
+; (CDG5) Code removed but comments kept for context
 
 
 ;_____________________________________________________________________________________________
@@ -1477,80 +645,7 @@ CheckVidSense
 ; Table size: $24 bytes fixed.
 ;
 ;_____________________________________________________________________________________________
-			export	HHEADMerge
-
-HHEadMerge														;									<SM18> Sam
-			With	NKSystemInfo, ProductInfo, VideoInfo
-			
-	; Read PRAM to see if the user wants an EDisk.  If the size is > MinRamDiskSize then ask the	<SM21> SAM
-	; nanokernel for some RAM.
-
-			MOVE.L	A2,D3										; Save SizeMem's return address
-
-			LongBSR6 GetHardwareInfo							; Get universal info again
-			MOVE.L	DecoderInfo.VIA1Addr(A0),A2 				; Get VIA1's base address for RdXByte
-			
-			LSR.W	#8,D2										; Get the boxflag in the low byte	<SM27>
-			MOVE.B	D2,D7										; Save it in D7						<SM27>
-			
-			MOVE.W	#ramDiskPramAddr,D1							; Get the EDisk PRAM byte constant
-			BSR6	RdXByte										; Read the EDisk size (in % of total RAM) in D1
-			MOVE.L	D3,A2										; Restore the return address
-						
-	; Get the MMU page size from the nanokernel.  Count bits in the result to get a shift factor
-	
-			MOVEQ	#0,D3										; Clear D3
-			MOVE.L	([ProcessorInfoPtr],ProcessorInfo.PageSize),D0	; Get the Page size from the nano-k
-			BFFFO	D0{15:15},D3								; Get the shift factor (Find First One)
-			NOT.B	D3											; Flip the order (BF instr start at bit 32 -> )
-			ADD.B	#32,D3										; Get the bit number (lsb based)
-
-			MOVE.L	(NKSystemInfoPtr),A5						; Point to the nanokernel SystemInfo record
-			ANDI.L	#$FF,D1										; Clear upper bytes of pram byte
-			BEQ.S	@Chunky										; -> No EDisk
-			
-			MOVE.L	PhysicalMemorySize(A5),D2					; Get physical RAM size
-			LSR.L	#8,D2										; Scale the size by 256k chunks
-			MULU.L	D1,D2										; Mult Chunks by ChunkCount from PRAM = EDisk size
-			ADD.L	#$7FFF,D2									; Add an extra 32k to the size
-			AND.W	#$8000,D2									; Round down to 32k boundary
-			CMPI.L	#MinRamDiskSize,D2							; Is this size too small? (user pulled some SIMMs)
-			BLO.S	@Chunky										; -> Yes, too small.  No EDisk
-
-			MOVE.L	#bRamDisk,D0								; Get the EDisk logical base address
-			LSR.L	D3,D0										; Turn the address into a page number
-			MOVE.L	D0,A0										; Put the logical page number in A0
-
-			LSR.L	D3,D2										; Turn the size into a page count
-			MOVE.L	D2,A1										; Put page count in A1
-
-			ADD.W	#1,A1										; (Temp Hack bump up by one to work around nk bug)	<SM33>
-			;MOVEQ	#0,D1										; Indicate no special alignment necessary
-			MOVE.L	#16,D1										; (Temp Hack to get around a nk bug)				<SM32>
-			_nkAllocateMemory									; Get the RAM and map it where we asked
-
-	; Now that RAM has been adjusted by the possible allocation of an EDisk, Video frame buffer
-	; and/or DMA buffer, we can construct the RAM chunk table that sits at the top of logical RAM.
-	; At this point A5 should be pointing to the nanokernel SystemInfo record.
-			
-@Chunky		MOVE.L	UsableMemorySize(A5),D1						; Get the Useable RAM size from NK
-			MOVE.L	D1,A5										; Put the size (our Memtop) in A5
-
-																; Start from the Top down
-			LEA		-8(A5),A5									; Leave room for two temp warm start flags <SM31>
-
-			CLR.L	-(A5)										; Old Diag long #3
-			CLR.L	-(A5)										; Old Diag long #2		
-			CLR.L	-(A5)										; Old Diag long #1		
-			MOVE.L	#-1,-(A5)									; Chunk table terminator
-			MOVE.L	D1,-(A5)									; Top of usable RAM
-			CLR.L	-(A5)										; Logical start of RAM
-
-			MOVE.L	A5,A1										; Put Ptr to chunk table in A1 for MergeDone
-			MOVEQ	#0,D6										; Signal no RAM test errors.
-			BRA		MergeDone									; Set the stack and leave
-
-			EndWith
+; (CDG5) Code removed but comments kept for context
 
 
 
@@ -1572,28 +667,7 @@ HHEadMerge														;									<SM18> Sam
 ; This routine stitches banks A,B together for the MacII's glue chip decoder.  It then writes
 ; the chunk table at the top of RAM.
 ;_____________________________________________________________________________________________
-GlueMerge										;												<9>
-			moveq	#$0F,d1						; prepare to mask for size A nibble
-			and.b	d5,d1						; get bank A size nibble
-			bne.s	@sizeBits					; RAM in bank A, leave a1 pointing to bank A start
-			addq	#8,a1						; else, advance to bank B's start
-			lsr.l	#4,d5						; and move bank B's nibble into lsn
-@sizeBits	move.b	@VIASizeTable(d1),d0		; get VIA value
-			movea.l	VIA2Addr(a0),a5				; get VIA 2 base
-			and.b	d0,VBufA(a5)				; stuff in new size bits
-
-			moveq	#(3*4)+(2*8),d1				; size of chunk table for this decoder
-			bra		writeChunkTable				; write chunk table and exit...
-
-@VIASizeTable
-			dc.b	$FF							; [0] A size = 0Mb:	 Start bank B on 64Mb 	boundary
-			dc.b	$3F							; [1] A size = 1Mb:	 Start bank B on  1Mb 	boundary
-			dc.b	$FF							; [2] A size = 2Mb:	 			----
-			dc.b	$7F							; [3] A size = 4Mb:	 Start bank B on  4Mb 	boundary
-			dc.b	$FF							; [4] A size = 8Mb:	 			----
-			dc.b	$BF							; [5] A size =16Mb:	 Start bank B on 16Mb 	boundary
-			dc.b	$FF							; [6] A size =32Mb:	 			----
-			dc.b	$FF							; [7] A size =64Mb:	 Start bank B on 64Mb 	boundary
+; (CDG5) Code removed but comments kept for context
 
 
 
@@ -1615,31 +689,7 @@ GlueMerge										;												<9>
 ; This routine writes the chunk table (containing 1 or 2 entries) at the top of the highest bank,
 ; for the Mac IIci's MDU decoder (no stitching possible with this one).
 ;_____________________________________________________________________________________________
-MDUMerge										;												<9>
-			moveq	#0,a5						; no chunk table started yet
-			adda.w	#16,a1						; point to end of bank info table
-
-@bankLoop	tst.b	d5							; any banks left?
-			beq		MergeDone					; no, exit
-
-			subq	#8,a1						; point to previous bank
-			lsl.l	#4,d5						; yes, shift over next bank
-			move.w	d5,d1
-			lsr.w	#8,d1						; get bank nibble
-			andi.b	#$0F,d1						; mask it
-			beq.s	@bankLoop					; no bank, try next
-
-			BSR6	expandSize					; convert nibble size (in d1) --> real size (in d0)
-			move.l	a5,d1						; already started table?
-			bne.s	@writeChunk					; yes, then don't write tail
-			move.l	(a1),a5						; get base of bank
-			adda.l	d0,a5						; point to end of bank
-			clr.l	-(a5)						; clear test space
-			clr.l	-(a5)						; clear test space
-			move.l	#-1,-(a5)					; write FFFFFFFF
-@writeChunk	move.l	d0,-(a5)					; write size  (0nn00000)
-			move.l	(a1),-(a5)					; write start (0x000000)
-			bra.s	@bankLoop
+; (CDG5) Code removed but comments kept for context
 
 
 
@@ -1662,40 +712,7 @@ MDUMerge										;												<9>
 ; This routine stitches banks A,B together for the Mac IIfx's FMC decoder.  It then writes
 ; the chunk table at the top of RAM.
 ;_____________________________________________________________________________________________
-FMCMerge										;												<9>
-			move.w	#FMCInit,d1					; get initial FMC value (assuming no Parity)
-			btst.l	#RPUExists,d0				; do we have parity?
-			beq.s	@cont						; no, we're ok
-			move.w	#FMCRPUInit,d1
-@cont		move.w	d1,d0
-
-			moveq	#$0F,d1						; prepare to mask for size A nibble
-			and.b	d5,d1						; get A size nibble
-			bne.s	@sizeBits					; yes, leave a1 pointing to bank A start
-			addq	#8,a1						; else, advance to bank B's start
-			lsr.l	#4,d5						; and move bank B's nibble into lsn
-@sizeBits	and.b	@FMCSizeTable(d1),d0		; 'or' in FMC size bits
-
-			movea.l	FMCAddr(a0),a5				; get the FMC base address
-			moveq.l	#16-1,d1					; loop counter to load 16 bits 					<13>
-@FMCload	move.b	d0,FMCConfig(a5)			; load in a bit
-			lsr.w	#1,d0						; put next bit into position
-			dbra	d1,@FMCload					; repeat till all bits loaded					<13>
-			st.b	FMCLatch(a5)				; latch the config data
-
-@writeTable
-			moveq	#(3*4)+(2*8),d1				; max size of chunk table for this decoder
-			bra		writeChunkTable				; write chunk table and exit...
-
-@FMCSizeTable
-			dc.b	$FF							; [0] A size = 0Mb:	 Start bank B on 64Mb 	boundary
-			dc.b	$FF							; [1] A size = 1Mb:	 			----
-			dc.b	$FF							; [2] A size = 2Mb:	 			----
-			dc.b	$3F							; [3] A size = 4Mb:	 Start bank B on 4Mb 	boundary
-			dc.b	$7F							; [4] A size = 8Mb:	 Start bank B on 8Mb 	boundary
-			dc.b	$BF							; [5] A size =16Mb:	 Start bank B on 16Mb 	boundary
-			dc.b	$FF							; [6] A size =32Mb:	 			----
-			dc.b	$FF							; [7] A size =64Mb:	 Start bank B on 64Mb 	boundary
+; (CDG5) Code removed but comments kept for context
 
 
 
@@ -1717,153 +734,7 @@ FMCMerge										;												<9>
 ; This routine stitches banks A,B,C,D together for Eclipse's Orwell decoder.  It then writes
 ; the chunk table at the top of RAM.
 ;_____________________________________________________________________________________________
-			WITH	ProductInfo
-
-OrwellMerge										;												<CCH>
-		IF forSTP601 THEN							;											<SM46>
-			WITH	NKSystemInfo					;											<SM46>
-	
-													;									Start	<SM48>
-	; Read PRAM to see if the user wants an EDisk.  If the size is > MinRamDiskSize
-	;  then ask thenanokernel for some RAM.	
-			MOVE.L	A2,D6							; Save SizeMem's return address	
-
-			MOVEQ.L	#0,D7							; Memory that might get used for RAM disk
-			
-			LongBSR6 GetHardwareInfo				; Get universal info again
-			MOVE.L	DecoderInfo.VIA1Addr(A0),A2 	; Get VIA1's base address for RdXByte
-			
-			MOVE.W	#ramDiskPramAddr,D1				; Get the EDisk PRAM byte constant
-			BSR6	RdXByte							; Read the EDisk size (in % of total RAM) in D1
-			MOVE.L	D6,A2							; Restore the return address>
-
-	; Get the MMU page size from the nanokernel.Count bits in the result to get a shift factor
-	
-			MOVEQ	#0,D3							; Clear D3								
-			MOVE.L	([ProcessorInfoPtr],ProcessorInfo.PageSize),D0	; Get the Page size from the nano-k
-			BFFFO	D0{15:15},D3					; Get the shift factor (Find First One)
-			NOT.B	D3								; Flip the order (BF instr start at bit 32 -> ) 
-			ADD.B	#32,D3							; Get the bit number (lsb based)
-
-			MOVEQ	#0,D5							; Clear the EDisk allocation size
-			MOVE.L	(NKSystemInfoPtr),A5			; Point to the nanokernel SystemInfo record
-			ANDI.L	#$FF,D1							; Clear upper bytes of pram byte
-			BEQ.S	@AfterRAMDiskCheck				; -> No EDisk
-			
-			MOVE.L	PhysicalMemorySize(A5),D2		; Get physical RAM size	
-			LSR.L	#8,D2							; Scale the size by 256k chunks
-			MULU.L	D1,D2							; Mult Chunks by ChunkCount from PRAM = EDisk size
-			ADD.L	#$7FFF,D2						; Add an extra 32k to the size
-			AND.W	#$8000,D2						; Round down to 32k boundary
-			CMPI.L	#MinRamDiskSize,D2				; Is this size too small? (user pulled some SIMMs)
-			BLO.S	@AfterRAMDiskCheck				; -> Yes, too small.  No EDisk
-			CMPI.L	#MaxRamDiskSize,D2				; Is it too big?>
-			BHI.S	@AfterRAMDiskCheck				; -> Yes, too big.  No EDisk
-
-			MOVE.L	LogicalMemorySize(A5),D0		; Get the logical size (Phys - nk private stuff)
-
-@CheckMinHeap																				
-			SUB.L	D2,D0							; Subtract the EDisk size
-			CMP.L	#MinHeapSize,D0					; Will we have at least MinHeapSize free after the EDisk?
-			BLT.S	@AfterRAMDiskCheck				; -> No, do not allocate the EDisk (signed)
-
-			MOVE.L	D2,D5							; Save the number of bytes used by the EDisk in the chunk table.
-			ADD.L	D2,D7							; Add the size to our running allocation counter
-			MOVE.L	#bRamDisk,D0					; Get the EDisk logical base address
-			LSR.L	D3,D0							; Turn the address into a page number
-			MOVE.L	D0,A0							; Put the logical page number in A0
-
-			LSR.L	D3,D2							; Turn the size into a page count
-			MOVE.L	D2,A1							; Put page count in A1
-
-			MOVEQ	#0,D1							; Indicate no special alignment necessary
-			_nkAllocateMemory						; Get the RAM and map it where we asked
-
-@AfterRAMDiskCheck
-													;										End	<SM48>
-
-			MOVE.L	(NKSystemInfoPtr),A5			; Point to the nanokernel SystemInfo record	<SM46>
-			MOVE.L	UsableMemorySize(A5),D1			; Get the Useable RAM size from NK			<SM46>
-			MOVE.L	D1,A5							; Put the size (our Memtop) in A5			<SM46>
-
-													; Start from the Top down					<SM46>			
-			MOVE.L	D7,-(A5)						; Put total allocation at the top of L RAM.	<SM46>
-			MOVE.L	#$52555348,-(A5)				; Old Unused Diag long #3					<SM46>
-			MOVE.L	#$6E757320,-(A5)				; Old Unused Diag long #2					<SM46>
-			MOVE.L	#$4379676E,-(A5)				; Old Unused Diag long #1					<SM46>
-			MOVE.L	#-1,-(A5)						; Chunk table terminator					<SM46>
-			MOVE.L	D1,-(A5)						; Top of usable RAM							<SM46>
-			CLR.L	-(A5)							; Logical start of RAM						<SM46>
-
-			MOVE.L	A5,A1							; Put Ptr to chunk table in A1 for MergeDone<SM46>
-			MOVEQ	#0,D6							; Signal no RAM test errors.				<SM46>
-			BRA		MergeDone						; Set the stack and leave					<SM46>
-			ENDWITH									;											<SM46>
-		ENDIF										;											<SM46>
-		
-		IF forSmurf THEN
-			bra		HMCMerge					; >>SKIP this							<SM5> <SM20>
-		ENDIF
-
-			move.w	d5,d1						;	get a copy of the size for 4 banks
-			swap 	d5							;	put a copy in msw of d5
-			move.w	d1,d5						;	and put a copy in the lsw of d5 too
-			move.l	a1,d6						;	save productinfo ptr for later
-			movea.l	#0,a3						;	clear memory counter
-			move.l	#0,d3						;	start with bank 0 (bank A)
-			bra.s	@bankMapped					;	no need to map bank A
-;
-; This code maps the current bank to begin immediately after the previous bank.
-; It loads Orwell's bank configuration registers, but does not latch them in.
-;
-; a3.l - offset to map current bank at
-; d3.l - bank which we are currently mapping
-;
-@mergeLoop										; 	LOOP
-			move.l	d3,d1						;	  get current bank number
-			subq.l	#1,d1						;	  adjust so Bank 1 has zero offset
-			mulu.l	#OrBankFieldSize,d1			;	  get bit position in register for this bank
-			move.l	DecoderAddr(a0),a5			;	  get base addr of Orwell					<SM7>
-			lea		(OrBankBCfgAddr,a5,d1.w*4),a5	; get base address of bank field for this bank
-			move.l	a3,d1						;	  get addr to map this bank to
-			move.l	#22,d4						;	  bits to shift to get Orwell config value
-			lsr.l	d4,d1						;	  d1 contains config value for this bank
-			move.w	#OrBankFieldSize-1,d4		;	  size of field to load
-@loadCfgReg	move.l	d1,(a5)+					;	  load a bit
-			lsr.l	#1,d1						;	  get next bit into position
-			dbra	d4,@loadCfgReg				;	  continue until entire field is loaded
-;
-; Latch the value we just put into Orwell in.
-;
-			movea.l	DecoderAddr(a0),a5			;	  get base address of Orwell				<SM7>
-			lea		OrLoadBanks(a5),a5			;	  get address of latch location
-			move.b	#$ff,(a5)					;	  latch bank config values in		<14>
-;
-; Increment offset to map next bank to and point to next chunk.  Continue loop if not finished.
-;
-@bankMapped
-			move.l	#$0F,d1						;	  mask for size nibble of current bank
-			and.b	d5,d1						;	  get size nibble for current bank
-			lsr.l	#4,d5						;	  shift size of next bank into low nibble	<14>
-			BSR6	expandSize					; 	  nibble size (in d1) --> real size (in d0)
-			adda.l	d0,a3						;	  calc total amount of memory so far
-@contLoop
-			tst.l	8(a1)						;	  are we at the last bank?
-			bmi.s	@mergeDone					;	  >>EXITLOOP if so
-			adda.l	#8,a1						;	  bump chunk pointer to next entry
-			addq.l	#1,d3						;	  bump bank number
-			bra.s	@mergeLoop					;	ENDLOOP
-;
-; Write chunk table at the end of RAM.  After merging, RAM looks like one big chunk starting at zero.
-;
-@mergeDone
-			move.l	a3,d3						;	get a copy of total amount of memory		<14>
-			move.l	d6,a1						;	restore productinfo ptr						<14>
-@endMerge	moveq	#(3*4)+(4*8),d1				;	size of chunk table for this decoder		<14>
-
-			bra		writeChunkTable				;	and exit									<14>
-
-			ENDWITH
+; (CDG5) Code removed but comments kept for context
 
 ;_____________________________________________________________________________________________
 ; Routine:	SonoraMerge																			<SAM>
@@ -1899,45 +770,7 @@ OrwellMerge										;												<CCH>
 ;
 ;_____________________________________________________________________________________________
 
-RAMCfgBank0Size	EQU		6						; Sonora RAMConfig Bank0Size Bit.  1=Onboard RAM for Carnation
-
-SonoraMerge	MOVE.L	D2,A5						; Save D2 for later 							<H6><SM12>
-			MOVEQ	#1,D4						; SIMM loop counter								<H4><SM12>
-			MOVEQ	#(1<<RAMCfgBank0Size),D6	; Assume RAM in bank 0.
-
-			MOVE.L	D5,D1						; Get a copy of the Nibble/Bank count
-			AND.B	#$0F,D0						; Get Bank A's nibble count
-			BNE.S	@noBank0					; -> No RAM in bank 0/A
-			
-			BCLR.L	#RAMCfgBank0Size,D6			; If no RAM in bank 0 clear the Bank0Size Bit
-@noBank0	
-			LSR.L	#4,D1						; Look at next bank
-
-@SIMMLupe	MOVE.B	D1,D0						; Copy two nibbles
-			AND.B	#$0F,D0						; Strip the upper nibble
-			BEQ.S	@noRAMBank1					; -> branch if no RAM in the first bank of this SIMM
-			
-			MOVE.B	D1,D2						; Copy two nibbles
-			AND.B	#$F0,D2						; Strip the lower nibble
-			BEQ.S	@NoRAMbank2					; -> No RAM in the second bank of this SIMM
-			
-			ADDQ	#1,D0						; Both banks filled. Assume both same size. Bump the SIMM size
-@noRAMbank2	OR.B	D0,D6						; Put this SIMM size in the Cfg reg
-			
-@noRAMbank1	ROR.B	#3,D6						; Rotate the Cfg reg to prep for setting SIMM1 size
-			LSR.L	#4*2,D1						; Shift the Bank sizes reg two banks right
-			DBRA	D4,@SIMMLupe				; Do this twice (once for each SIMM)
-			ROR.B	#2,D6						; Put the config reg back where it belongs
-
-@Done		MOVE.L	A5,D2						; restore D2 									<H6><SM12>
-			MOVE.L	RBVAddr(A0),A5				; Get RBV (Sonora's VIA2) Base Addr				<H2><SM12>
-			MOVE.B	SonoraRAMSize(A5),D0		; Get the Cfg Reg
-			AND.B	#$80,D0						; Mask out all but the HiBit (Slot16MHz)
-			OR.B	D0,D6						; Put the Slot16MHz into our SIMM size and Bank0Size byte
-			MOVE.B	D6,SonoraRAMSize(A5)		; Set the SIMM size & Stich the banks together (magic)
-
-			MOVEQ	#(3*4)+(5*8),D1				; size of chunk table for this decoder (3 longs + 5 banks)
-			BRA		writeChunkTable				; write chunk table and exit...
+; (CDG5) Code removed but comments kept for context
 
 
 ;_____________________________________________________________________________________________
@@ -1965,80 +798,7 @@ SonoraMerge	MOVE.L	D2,A5						; Save D2 for later 							<H6><SM12>
 ;			TBD  
 ;_____________________________________________________________________________________________
 
-YMCAMerge	
-			Move.w	#YMCAMaxSize,d6						; 	Max bank size supported by the YMCA in 2^(n-1)* chunksize
-			movea.l	#0,a3								;	clear memory counter
-			Move.l	DecoderAddr(A0),A5					; 	Get YMCA's Base address									<SM11>
-			Move.l	d5,YMCA_DRAMBank0_A20(a5)			; 	get the base address for the first bank's A20 register
-			
-
-; 	d6.w  will loop through the supported sizes,from largest to smallest
-;   d4.w  will have the bank the size is in
-
-@NextSize												; LOOP (thru memory sizes)
-			Move.l	d5,d3								; 	Get a running copy of the nibble sizes
-			rol.l	#4,d3								; 	adjust it for the 1st time thru nibble loop
-			Moveq	#0,d4								; 	Counter to loop through 8 nibbles
-			Move.l	DecoderAddr(A0),A5					; 	Get YMCA's Base address									<SM11>
-			Lea		YMCA_DRAMBank0_A20(a5),a5			; 	get the base address for the first bank's A20 register
-
-@NextNibble												;    LOOP (thru banks)
-			ror.l	#4,d3								; 		Get the nibble
-			move.w	d3,d1								; 		we will trash d1
-			Andi.w	#$000f,d1							; 		We only want the lowest nibble
-			Cmp.w	d6,d1								; 		Is this the size we're looking for
-			Bne.s	@NoSzMatch							;		nope
-			Swap	d4									;       save our counter and use the other word for the shift count & size counter
-			Move.w	#20,d4								;		# of bits to shift the address to get at the bit we need to program
-			Move.l	A3,D0								;       get the current amount of memory
-			lsr.l	d4,D0								;		the boundary reg's consist of A20 thru A26
-			Move.w	#BankBdryRegSize-1,d4				;		size of boundary address register
-
-@loadBdry	Ror.l	#1,d0								;       Move bit 0 to bit 31
-			move.l	d0,(a5)+							; 		and write it out
-			dbra	d4,@loadBdry						;		continue for all bits
-			Move.w	#BankSizeRegSize-1,d4				;		size of memory bank
-			Move.w	d1,d0								;		Get a copy of nibble size in the msw of d1
-			Swap	d1									;		expand size will trash d1
-			Move.w	d0,d1								;		both words of d1 contain the nibble size
-			BSR6	expandSize							; 		nibble size (in d1) --> real size (in d0)
-			adda.l	d0,a3								;		calc total amount of memory so far
-			swap	d1									;		get d1.w with the nibble size
-
-@loadSize	Ror.l	#1,d1								;		d1 = nibble size = bank size 
-			move.l	d1,(a5)+							; 		and write it out
-			dbra	d4,@loadSize						;		continue for all bits
-			Swap 	D4									;		return our bank counter
-			bra.s	@NextBank							;		go look at the next bank
-@NoSzMatch
-			Adda.l	#40,a5								;		if we didn't match get the base address of the next bank
-@NextBank
-			Addq.w	#1,d4								; 		increment our counter
-			Cmpi.w	#8,d4								; 		Did we loop through the 8 nibbles yet
-			bne.s	@NextNibble							;    ENDLOOP (through banks)
-			Dbra	d6,@NextSize						;  ENDLOOP (through memory sizes)
-			
-			move.l	a3,d3								;	get a copy of total amount of memory		<14>
-
-@Done		MOVEQ	#(3*4)+(8*8),D1						; size of chunk table for this decoder (3 longs + 8 banks)
-			BRA		writeChunkTable						; write chunk table and exit...
-
-;																						<SM9> fau, end
-			ALIGN 4
-
-;																						<SM11> fau, start			
-YMCAWidthOffsets
-;  This table lists the offsets to the YMCA Width base address from the Base Address of the Width Register.
-;  It is indexed by bank and provides the offset from YMCA_DRAMwidth0	
-		
-			dc.w	$0			; Bank 0's offset
-			dc.w	$4			; Bank 1's offset
-			dc.w	$0			; Bank 2's offset			
-			dc.w	$4			; Bank 3's offset
-			dc.w	$8			; Bank 4's offset
-			dc.w	$c			; Bank 5's offset
-			dc.w	$8			; Bank 6's offset
-			dc.w	$c			; Bank 7's offset
+; (CDG5) Code removed but comments kept for context
 
 ;																						<SM11> fau, end
 ;_____________________________________________________________________________________________
@@ -2065,30 +825,7 @@ YMCAWidthOffsets
 ; possible to have the same total RAM configuration but different size bit settings 
 ; (i.e. 6MB total = 2 MB on PCB + 2-2 MB SIMMs in bank A OR 4 MB on PCB and 2-1 MB SIMMs).
 ;_____________________________________________________________________________________________
-VISAMerge										;												<9>
-			move.b	d5,d1						;											<H5><Begin>
-			and.w	#$000F,d1					; get Bank A size nibble
-			move.b	(@VISASizeTable,d1.w),d1	; use size as index into table for "real" size
-			movea.l	RBVAddr(a0),a5				; get size bits 
-			and.b	#%00111111,VsExp(a5)		; zero out bank A size 
-			or.b	d1,VsExp(a5)				; OR in bank A size we just got from table
-			
-			btst	#5,VsExp(a5)				; test size bits to see if 2/4mb in bank B
-			bne.s	@done						; if 4mb then we need to change RAM info tables
-			adda.l	#RAMInfoSize+4,a1			; set a1 to 4mb RAM info table	
-			
-@done
-			moveq	#(3*4)+(2*8),d1				; size of chunk table for this decoder
-			bra		writeChunkTable				; write chunk table and exit...
-
-@VISASizeTable
-			dc.b	$00							; [0] A size = 0MB
-			dc.b	-1							; [1] A size = 1MB illegal
-			dc.b	$40							; [2] A size = 2MB
-			dc.b	$80							; [3] A size = 4MB
-			dc.b	$C0							; [4] A size = 8MB							<H5><End><SM4> rb, end
-
-			ALIGN
+; (CDG5) Code removed but comments kept for context
 
 ;_____________________________________________________________________________________________
 ; Routine:	JAWSMerge/NiagraMerge
@@ -2108,143 +845,7 @@ VISAMerge										;												<9>
 ; This routine stitches banks A-B-C-D,E-F-G-H together for Waimea's JAWS decoder.  It then writes
 ; the chunk table at the top of RAM.
 ;_____________________________________________________________________________________________
-NiagraMerge
-JAWSMerge										;												<9>
-			moveq	#0,d4						; init card size reg
-
-			moveq	#3,d1						; get our special-case value (2 Meg, 1 chunk)	<4>
-			cmp.l	d1,d5						; does bank A have it (with bank B=0)?			<4>
-			bne.s	@checkSpec2					; no, see if bank B is special (with bank A=0)	<4>
-			moveq	#0,d4						; B-A = 0-2 meg, use the 0 table entry			<4>
-			bra.s	@getTable					;												<4>
-			
-@checkSpec2	swap	d1							; now check bank B for 2 Meg in lowest chunk	<4>
-			cmp.l	d1,d5						; with bank A=0									<4>
-			bne.s	@notSpec					; no, use standard lookup						<4>
-			moveq	#$20,d4						; yes, use B-A = 4-0 meg table entry			<4>
-			bra.s	@getTable					;												<4>
-			
-@notSpec	BSR6	@calcSize					; calc bank B size
-			BSR6	@calcSize					; calc bank A size
-
-			moveq	#16-3,d0					; prepare to shift bank A size code into high 3 bits
-			lsl.w	d0,d4						; 00000000 00000bbb aaa00000 00000000
-			lsr.l	d0,d4						; 00000000 00000000 00000000 00bbbaaa
-@getTable	move.b	@JAWSSizeTable(d4.w),d0		; get JAWS size config value
-
-			movea.l	JAWSAddr(a0),a5				; get ptr to JAWS base
-			adda.l	#JAWSMemConfigA,a5
-			move.b	d0,(a5)						; set size reg A
-
-			lsr.b	#2,d0						; move in next 2 bits
-			adda.w	#JAWSMemConfigB-JAWSMemConfigA,a5
-			move.b	d0,(a5)						; set size reg B
-
-			lsr.b	#2,d0						; move in last 2 bits
-			adda.w	#JAWSMemConfigC-JAWSMemConfigB,a5
-			move.b	d0,(a5)						; set size reg C
-
-			moveq	#(3*4)+(8*8),d1				; size of chunk table for this decoder
-			bra		writeChunkTable				; write chunk table and exit...
-
-;............................................................................................
-
-@calcSize	movea.l	a6,a5						; keep return address in a5
-			moveq	#4-1,d1						; count 4 banks
-@nextNib	swap	d1							; keep count in d1.hw
-			move.w	#$0F,d1
-			rol.l	#4,d5						;
-			and.b	d5,d1						; get next size nibble
-			BSR6	expandSize					; nibble size (in d1) --> real size (in d0)
-			add.l	d0,d4						; add to total for this bank
-			swap	d1							; get count back
-			dbra	d1,@nextNib
-
-			swap	d4							; 000x00n0
-			lsr.w	#4,d4						; 000x000n
-
-			cmpi.b	#8,d4						; was it 8?
-			bne.s	@done						; no, then we're done
-			subq.b	#1,d4						; yes, make it a 7.
-@done		jmp		(a5)						; and exit
-
-
-@JAWSSizeTable
-			dc.b	%00000						;[000 000] B:0, A:0
-			dc.b	%00001						;[000 001] B:0, A:1
-			dc.b	%00001						;[000 010] B:0, A:2
-			dc.b	%00010						;[000 011] B:0, A:3
-			dc.b	%00000						;[000 100] B:0, A:4
-			dc.b	%00000						;[000 101] --------
-			dc.b	%00000						;[000 110] B:0, A:6
-			dc.b	%00000						;[000 111] B:0, A:8
-
-			dc.b	%11111						;[001 000] B:1, A:0
-			dc.b	%10011						;[001 001] B:1, A:1
-			dc.b	%00011						;[001 010] B:1, A:2
-			dc.b	%01010						;[001 011] B:1, A:3
-			dc.b	%01001						;[001 100] B:1, A:4
-			dc.b	%00000						;[001 101] --------
-			dc.b	%00110						;[001 110] B:1, A:6
-			dc.b	%01000						;[001 111] B:1, A:8
-
-			dc.b	%11111						;[010 000] B:2, A:0
-			dc.b	%00111						;[010 001] B:2, A:1
-			dc.b	%00011						;[010 010] B:2, A:2
-			dc.b	%10010						;[010 011] B:2, A:3
-			dc.b	%01001						;[010 100] B:2, A:4
-			dc.b	%00000						;[010 101] --------
-			dc.b	%00110						;[010 110] B:2, A:6
-			dc.b	%01000						;[010 111] B:2, A:8
-
-			dc.b	%11101						;[011 000] B:3, A:0
-			dc.b	%00100						;[011 001] B:3, A:1
-			dc.b	%00100						;[011 010] B:3, A:2
-			dc.b	%11001						;[011 011] B:3, A:3
-			dc.b	%10001						;[011 100] B:3, A:4
-			dc.b	%00000						;[011 101] --------
-			dc.b	%01110						;[011 110] B:3, A:6
-			dc.b	%11000						;[011 111] B:3, A:8
-
-			dc.b	%10111						;[100 000] B:4, A:0
-			dc.b	%01001						;[100 001] B:4, A:1
-			dc.b	%00101						;[100 010] B:4, A:2
-			dc.b	%01111						;[100 011] B:4, A:3
-			dc.b	%11011						;[100 100] B:4, A:4
-			dc.b	%00000						;[100 101] --------
-			dc.b	%10110						;[100 110] B:4, A:6
-			dc.b	%00000						;[100 111] B:4, A:8
-
-			dc.b	%00000						;[101 000] --------
-			dc.b	%00000						;[101 001] --------
-			dc.b	%00000						;[101 010] --------
-			dc.b	%00000						;[101 011] --------
-			dc.b	%00000						;[101 100] --------
-			dc.b	%00000						;[101 101] --------
-			dc.b	%00000						;[101 110] --------
-			dc.b	%00000						;[101 111] --------
-
-			dc.b	%10111						;[110 000] B:6, A:0
-			dc.b	%01011						;[110 001] B:6, A:1
-			dc.b	%01011						;[110 010] B:6, A:2
-			dc.b	%01100						;[110 011] B:6, A:3
-			dc.b	%10100						;[110 100] B:6, A:4
-			dc.b	%00000						;[110 101] --------
-			dc.b	%11010						;[110 110] B:6, A:6
-			dc.b	%00000						;[110 111] B:6, A:8
-
-			dc.b	%10111						;[111 000] B:8, A:0
-			dc.b	%01101						;[111 001] B:8, A:1
-			dc.b	%01101						;[111 010] B:8, A:2
-			dc.b	%10101						;[111 011] B:8, A:3
-			dc.b	%10111						;[111 100] B:8, A:4
-			dc.b	%00000						;[111 101] --------
-			dc.b	%10111						;[111 110] B:8, A:6
-			dc.b	%00000						;[111 111] B:8, A:8
-
-
-
-; <22> rb, from Terror for DBLite
+; (CDG5) Code removed but comments kept for context
 
 ;_____________________________________________________________________________________________
 ; Routine:	MSCMerge
@@ -2276,26 +877,7 @@ JAWSMerge										;												<9>
 ;	Bank H can be 0 or 2 or 8
 ;_____________________________________________________________________________________________
 
-MSCMerge										;												<T7>
-			bfffo	d5{0:31},d1					; find the highest bit (bank) set				<H5><SM12>
-			neg.b	d1							;												<H5><SM12>
-			add.b	#32,d1						;												<H5><SM12>
-			asl.b	#MSCSize0-2,d1				; / bank size = highest bank # (upper 3 bits)	<H5><SM12>
-			ori.b	#(1<<MSC25MHz)|(1<<MSCEconoBit)|(1<<MSCFastROM)|(1<<3)|(1<<MSCBank8M),d1 ;	<H5><SM12>
-
-			moveq	#$0F,d0						; find out how much in bank 4					<H5><SM12>
-			swap	d0							;												<H5><SM12>
-			and.l	d5,d0						;												<H5><SM12>
-			swap	d0							; nibble size in low byte						<H5><SM12>
-			subq.b	#$03,d0						; check for 8 MB								<H5><SM12>
-			beq.s	@TwoMegBanks				;												<H5><SM12>
-			bclr	#MSCBank8M,d1				; not 8 MB, clear our Bank8M enable				<H5><SM12>
-@TwoMegBanks
-			movea.l	RBVAddr(a0),a5				; get ptr to MSC (same as RBV's)				<H3>
-			and.b	d1,MSCConfig(a5) 			; set MSC size bits								<H2><H5><SM12>
-
-@done		moveq	#(3*4)+(8*8),d1				; size of chunk table for this decoder			<H14><SM12>
-			bra		writeChunkTable				; write chunk table and exit...
+; (CDG5) Code removed but comments kept for context
 
 ;_____________________________________________________________________________________________
 ; Routine:	PrattMerge																			<SM15>
@@ -2327,74 +909,7 @@ MSCMerge										;												<T7>
 ;	All expansion banks with RAM in them must be the same size. Banks must be loaded in order.
 ;
 ;_____________________________________________________________________________________________
-PrattMerge										;
-
-; find out which banks have memory
-; input:  d5.l -- each non-zero nibble means corresponding bank has memory 
-; output: d4.b -- each non-zero bit means corresponding bank has memory, bits 0-5
-;
-			movea.l	d5,a5						; save a copy of nibble sizes
-			moveq	#0,d0						; initialize count
-			move.b	#PrattBankBits,d4			; load initial mask for RAM Configuration Register (in Pratt)
-@bankloop	move.b	d5,d1						; get copy of nibble sizes
-			andi.b	#$0F,d1						; look at low nibble 
-			bne.s	@next						; nibble non-zero -> memory in bank, so leave bit set
-			bclr	d0,d4						; no memory in this bank, so clear bit 
-@next		lsr.l	#4,d5						; look at next nibble
-			addq	#1,d0						; inc nibble count
-			cmpi.b	#PrattNumbanks-1,d0			; have we looked at all the banks?		
-			ble.s	@bankloop
-			move.l	a5,d5						; restore copy of nibble sizes
-
-; figure out the onboard configuration (Banks A and B) 
-; output: d1 has the onboard memory bank bit configuration bits configured
-;
-			move.b	#PrattDensBits,d1			; load initial mask for RAM Density Register (in Pratt)
-			move.l	d5,d0						; get copy of nibble sizes
-			andi.l	#$0000000F,d0				; find out how much in bank 0
-			bne.s	@check2						; more than 0 MB, go check for 2
-			andi.b	#Pratt0MBbank,d1			; there is no RAM on the daughter card
-			bra.s	@getExpMem
-@check2		cmpi.l	#1,d0						; check for 2 MB (nibble size = 1 for 2MB chunksize)
-			bne.s	@check4						; more than 2MB, go check for 4
-			andi.b	#Pratt2MBbank,d1			; there are 2MB
-			bra.s	@getExpMem					; 												
-@check4		cmpi.l	#2,d0						; check for 4MB (nibble size = 2 for 2MB chunksize)
-			bne.s	@set8						; more than 4MB, must be 8
-			andi.b	#Pratt4MBbank,d1			; there are 4 MB
-			bra.s	@getExpMem
-@set8		andi.b	#Pratt8MBbank,d1			; set 8 MB bank size
-
-; find out size of expansion memory banks
-; output: d1 has the expansion memory bank size bit configured
-;
-@getExpMem	move.l	#$00000F00,d0				; find out how much in bank C (D,E,F must be the same size)					
-			and.l	d5,d0						;  the formula is (2^(n-1) * 2) MB where "n" is the nibble value
-			bne.s	@check2e
-			andi.b	#Pratt0MBExBank,d1
-			bra.s	@writeConfigRegs
-@check2e	cmpi.l	#$00000100,d0				; check for 2 MB (nibble size = 1)
-			bne.s	@check4e
-			andi.b	#Pratt2MBExBank,d1
-			bra.s	@writeConfigRegs
-@check4e	cmpi.l	#$00000200,d0				; check for 4 MB (nibble size = 2)
-			bne.s	@set8e
-			andi.b	#Pratt4MBExBank,d1
-			bra.s	@writeConfigRegs
-@set8e		andi.b	#Pratt8MBExBank,d1			; set config for 8MB banks on the expansion card
-
-@writeConfigRegs
-			movea.l	PrattAddr(a0),a5			; get ptr to Pratt 							<SM16>
-		IF 	forRomulator THEN
-			TestInRAM	a0						; are we in RAM?
-			bne.s		@done					; yes, then don't really muck with RAM Config registers
-		ENDIF
-			move.b	d1,PrattRAMDensity(a5) 		; set Pratt RAM density register value
-			move.b	d4,PrattRAMConfig(a5)		; set Pratt RAM config register value
-			bset.b	#0,PrattRefresh(a5)			; set Pratt Refresh rate to be generated every 33 clocks.
-
-@done		moveq	#(3*4)+(6*8),d1				; size of chunk table for this decoder			
-			bra		writeChunkTable				; write chunk table and exit...
+; (CDG5) Code removed but comments kept for context
 
 
 ;_____________________________________________________________________________________________ <H7> thru next <H7>
@@ -2418,131 +933,7 @@ PrattMerge										;
 ;			to abuse it during this part of the code.													<H8>
 ;_____________________________________________________________________________________________
 
-			WITH	ProductInfo
-
-djMEMCMerge
-		IF forSmurf THEN
-			bra		HMCMerge					; >>SKIP this							<SM5> <SM20>
-		ENDIF
-
-			LEA		MEMCAddr+MEMCDRAMCfg0,A0	; Point A0 to the first bank's Cfg reg
-			
-			MOVEQ	#0,D0
-			SUBA.L	A3,A3						; A3 = 0
-			MOVEQ	#dj_MaxBanks-1,D1			; # of banks minus 1									<H8>
-
-@Loop		MOVE.L	A3,D4						; Get running size in D4
-			SWAP	D4							; Poor man's BFEXTU D4{22:8},D4
-			LSR.W	#6,D4
-
-			MOVE.L	(A0),D0
-			MOVE.B	D4,D0						; Move bits 22-29 of addrs into bits 7-0 of cfg reg
-			MOVE.L	D0,(A0)+
-	
- 			MOVEQ	#$0F,D4						; Nibble mask
-			CMPI.B	#2-1,D1						; Are we on the first set of 8 banks?
-			BHI.S	@D5							; -> Yes, use D5 for the first 8
-
-@D6			AND.B	D6,D4						; Get the nibble	(banks 8 thru 15)
-			ROR.L	#4,D6						; prep for next time
-			BRA.S	@Comm
-
-@D5			AND.B	D5,D4						; Get the nibble	(banks 0 thru 7)
-			ROR.L	#4,D5						; Roll around for next time
-					
-@Comm		TST.B	D4							; Any RAM in this bank?
-			BEQ.S	@NextOne					; -> Nope, lupe sum more
-			
-			SUBQ	#1,D4						; Multiplying by powers of 2 (start at 2^1)
-			MOVE.L	D2,D0						; chunkSize
-			LSL.L	D4,D0						; This bank's size in bytes
-
-			ADD.L	D0,A3						; Add this bank's size to the running total
-@NextOne	DBRA	D1,@Loop
-			ROL.L	#8,D6						; Fix D6 (contains only 2 banks, but should be in LSB)
-			
-			MOVE.L	A3,D0						; Get total RAM in d0
-			SWAP	D0							; Poor man's BFEXTU D4{22:8},D4
-			LSR.W	#6,D0
-			MOVE.L	D0,MEMCAddr+MEMCmemTop		; Move bits 22-29 of addrs into bits 7-0 of MemTop reg
-
-; -----------------------------------------------------------------------------------------
-;
-;	Put in interleave enabling code HERE.
-;
-;	It must go here because if you turn it on after the chunk table is built, interleaving
-;	"scrambles" the banks and the chunk table would get scrambled as well.
-;
-;	At this point, we can thrash A0
-;
-;	Bank information is stored in D5 & D6.  D5 = banks 0-7, D6 = banks 8&9
-;	Organization of D5 and D6 is:
-;
-;	+-------------------------------------------------------+
-;	| bank | bank | bank | bank | bank | bank | bank | bank |
-;	|  7   |  6   |  5   |  4   |  3   |  2   |  1/9 |  0/8 |	D5/D6 bank value positions
-;	+-------------------------------------------------------+
-; -----------------------------------------------------------------------------------------
-
-		IF forRomulator THEN					; if you're running a ROM in RAM, you dont EVER					<H15><SM10>
-			bra		@skipInterleave				; want to turn on interleaving.  it could make your day			<H15><SM10>
-		ENDIF									; very unhappy													<H15><SM10>
-;	Only allow interleave enable on djMEMC versions > 0.														<H10> thru next <H10><SM10>
-;	Version 0 parts cause the machine to lock up if interleaving is enabled.
-
-			lea		MEMCAddr+MEMCIntleaveEnable,a0;   get interleave enable reg. address
-			moveq	#$0E,d0						; mask for djMEMC version number, shifted 1 bit to the left
-			rol.l	#8,d0						; shift mask to correct location
-			and.l	(a0),d0						; check djMEMC version
-			beq.s	@skipInterleave				; IF djMEMC_Version != 0 THEN									<H10><SM10>
-
-;	make sure banks are the same size first
-
-			move.l	d5,d1						;   get 1st 8 banks info
-			move.l	d1,d0
-			ror.l	#4,d0						;   such that d0 = (d1 >> 4), or bank pairs in same bit positions
-			eor.l	d0,d1						;   XOR them to see if they're the same
-			andi.l	#$0F0F0F0F,d1				;   AND to get only bottom nibble of each byte
-			moveq.l	#1,d0						;   starting bit of bank 0&1 in interleave reg.
-			move.l	(a0),d4						;   get current OneBufferedBit value from interleave reg.
-			andi.w	#$FFE0,d4					;   force the Interleaved bank bits to be unset
-@chkNextPair
-			tst.b	d5							;   test this bank PAIR
-			beq.s	@nextpair					;   BRIF both banks empty
-			tst.b	d1							;   test if both banks EQUAL
-			bne.s	@nextpair					;   IF BankX == BankX+1 THEN
-			or.w	d0,d4						;      set appropriate bit
-@nextpair										;   ENDIF
-			ror.l	#8,d5						;   point to next bank pair
-			ror.l	#8,d1						;   point to next XORed bank-pair results
-			rol.l	#1,d0						;   rotate bit to next interleave bit
-			cmpi.b	#%10000,d0					;   checking banks 8&9 yet?
-			bne.s	@chkNextPair				;   if still working with banks 0-7
-
-;	if you're here, then we need to test banks 8&9, found in D6.
-
-			tst.b	d6							;   are both banks empty?
-			beq.s	@setInterleave				;   IF Bank8&9 != EMPTY
-			move.b	d6,d1						;     get info for bank 8
-			move.b	d1,d0						;                      &9
-			andi.b	#$0F,d1						;     isolate bank 8
-			ror.b	#4,d0						;     align them so nibbles for 8&9 are the same
-			andi.b	#$0F,d0						;     isolate bank 9
-			cmp.b	d0,d1						;     check if bank 8 is same size as bank 9
-			bne.s	@setInterleave				;     IF Bank8 == Bank9 THEN
-			ori.b	#%10000,d4					;         set bit for banks 8&9
-@setInterleave									;   ENDIF
-			move.l	d4,(a0)						;   and write it out to the interleave config reg.
-
-@skipInterleave									; ENDIF															<H10><SM12>
-			MOVEQ	#(3*4)+(10*8),D1			; size of chunk table for this decoder (3 longs + 10 banks)
-			BRA		newWriteChunkTable			; write chunk table and exit... (ext nibbles in D6)
-
-
-			ENDWITH
-; -----------------------------------------------------------------------------------------						<H7>
-
-			align	2							;																<SM12>
+; (CDG5) Code removed but comments kept for context
 
 ;_____________________________________________________________________________________________
 ; Routine:	expandSize
@@ -2557,14 +948,7 @@ djMEMCMerge
 ; This routine converts the nibble size in d1 to a real size (in bytes) in d0, based on a
 ; chunk size in d2.
 ;_____________________________________________________________________________________________
-expandSize
-			moveq	#0,d0						; assume no RAM
-			tst.w	d1							; any RAM?
-			beq.s	@exit						; no, exit
-			move.l	d2,d0						; yes, get chunk size
-			subq.w	#1,d1						; count it
-			lsl.l	d1,d0						; multiply by correct power of 2
-@exit		RTS6
+; (CDG5) Code removed but comments kept for context
 
 
 
@@ -2593,35 +977,7 @@ expandSize
 ; test longs at the end of the table - same as always).
 ;_____________________________________________________________________________________________
 
-writeChunkTable									;											<11>			<SM12>
-			moveq	#0,d6						; clear the extended nibble count for the old guys 			<H7><SM12>
-newWriteChunkTable								; new entry point for machines with > 8 banks of memory		<H7><SM12>
-			movea.l	(a1),a5						; get start of bank
-			move.l	a5,a0						; running bank start ptr
-			adda.l	d3,a5						; point to end of bank
-			suba.l	d1,a5						; allocate space for test space/chunk table
-			move.l	a5,a7						; remember start of chunk table
-
-@loop		moveq	#$0F,d1						; prepare to mask for size nibble
-			and.b	d5,d1						; get bank size nibble
-			beq.s	@next						; skip if no RAM in this bank
-			BSR6	expandSize					; convert nibble size (in d1) --> real size (in d0)
-			move.l	a0,(a7)+					; write start
-			move.l	d0,(a7)+					; write length
-			add.l	d0,a0						; calculate next start
-@next		lsr.l	#4,d5						; shift in next bank nibble
-			bne.s	@loop						; continue if more banks
-
-			move.l	d6,d5						; do we have more banks to do? ( > 8)						<H7><SM12>
-			beq.s	@finishup					; -> Nope, no more											<H7><SM12>
-			clr.l	d6							; clr the extended nibble sizes (so we only do this once) 	<H7><SM12>
-			bra.s	@loop						; do more banks												<H7><SM12>
-
-@finishup	subq.l	#1,d5						; = FFFFFFFF												<SM12>
-			move.l	d5,(a7)+					; write FFFFFFFF (terminator)
-@fill		clr.l	(a7)+						; clear test space
-			move.w	a7,d0						; at end of bank
-			bne.s	@fill						; no, keep clearing
+; (CDG5) Code removed but comments kept for context
 
 ;.............................................................................................
 MergeDone
@@ -2631,6 +987,8 @@ MergeDone
 
 ;_____________________________________________________________________________________________				<SM12>begin
 ;
+;	The comment below only applies to pre-CDG5 ROMs that did sound:
+;
 ;	For machines with a sound buffer in high RAM (i.e., ASC-based machines), we'll move the
 ;	RAM chunk table below the sound buffer.  This will avoid collisions with large MMU tables.
 ;	We need to do this here because SizeMem gets called more than once (by diagnostics), so
@@ -2659,20 +1017,6 @@ MergeDone
 ;															+-------------------+
 ;_____________________________________________________________________________________________
 
-			MOVE.L	A2,D3						; save the return address									<H13>
-			MOVEQ	#0,D2						; get the decoder type										<H13>
-			BigBSR6	GetHardwareInfo,a0			;															<H13>
-			MOVEA.L	(SP),A6						; point to the chunk table									<H13>
-			LEA		@Resume,A2					; (BSR2)													<H13>
-			BRA.S	SizeSoundBuffer				; get the size of a sound buffer in high RAM (if any)		<H13>
-@Resume		BEQ.S	@Done						; -> no sound buffer										<H13>
-			SUB.L	D0,(SP)						; adjust the address of the new chunk table					<H13>
-			SUB.L	A6,D1						; calculate the size of the chunk table						<H13>
-@MoveChunks	MOVE.B	-(A1),-(A0)					; move the RAM chunk table to its new home					<H13>
-			SUBQ.L	#1,D1						;															<H13>
-			BGT.S	@MoveChunks					;															<H13>
-@Done		MOVEA.L	D3,A2						; restore the return address								<H13>
-
 			moveq	#0,d6						; Z flag set to indicate no error(s)						<15>
 			jmp		(a2)
 
@@ -2696,40 +1040,8 @@ MergeDone
 ;_____________________________________________________________________________________________
 
 SizeSoundBuffer									;															<H13>
-			LEA		@bufSizeTbl-4,A1
-			MOVEQ	#0,D0						; assume no sound buffer in high RAM
-@FindDecoder
-			ADDQ.W	#4,A1						; skip over the previous routine offset
-			MOVE.W	(A1)+,D0					; get the next decoder type
-			BEQ.S	@Done						; -> end of list
-			CMP.B	D2,D0						; does the decoder match?
-			BNE.S	@FindDecoder				; -> no, try the next one
-			MOVE.L	(A1)+,D0					; yes, get offset from top of RAM to start of sound buffer
-
-			MOVEA.L	A6,A1						; point to the start of the chunk table
-			BRA.S	@FirstChunk					;  and start looking
-@FindLastChunk
-			ADDQ.W	#8,A1						; skip over the previous chunk start/size
-@FirstChunk	TST.L	(A1)						; are we at the end of the table?
-			BPL.S	@FindLastChunk				; -> nope, keep going
-
-			MOVE.L	-(A1),D1					; calculate the address of the end of the last chunk
-			ADD.L	-(A1),D1
-			MOVEA.L	D1,A1						;  and save it
-			MOVEA.L	D1,A0						; calculate where the end of the moved chunk table will be
-			SUBA.L	D0,A0						; (this is also the start of the sound buffer)
-@Done		TST.L	D0							; set the CCR
-			JMP		(A2)
-
-
-; IMPORTANT: Because of the way that ConfigureRAM works (in StartInit), the following table sizes must be
-;			  multiples of 1024.
-@bufSizeTbl	DC.W	DecoderKinds.MSCDecoder		; MSC
-			DC.L	(8*1024)
-			DC.W	DecoderKinds.PrattDecoder	; Pratt (for Blackbird)
-			DC.L	(32*1024)					; Sound can use a FIFO size up to 32K (includes modem sound buffer)
-
-			DC.W	0							; end of list												<SM12>end
+			MOVEQ	#0,D0						; (CDG5) ROM does not do sound, so no buffer
+			JMP		(A2)						; vestigial routine, return no error
 
 
 
diff --git a/OS/StartMgr/StartAlert.a b/OS/StartMgr/StartAlert.a
--- a/OS/StartMgr/StartAlert.a
+++ b/OS/StartMgr/StartAlert.a
@@ -396,7 +396,23 @@ DrawBox 	MOVE.L	DSDrawProc,D0			; is a custom dialog draw procedure specified?
 			BSET	#7,DSDrawProc			; make it a one-shot
 			RTS 							; go to it
 
-@StdProc	LEA 	DSAlertRect,A0			; pt A0 at rect
+@StdProc	MOVE	D6,D0
+			BSR.S	FindObject
+			BEQ.S	@old
+
+			CMPI	#12,-2(A0)
+			BLT.S	@old
+			MOVE	10(A0),D0
+			BSR.S	FindObject
+			BEQ.S	@old
+
+			MOVE.L	(A0)+,DSAlertRect
+			MOVE.L	(A0),DSAlertRect+4
+			PEA.L	DSAlertRect
+			BSR		NewAlertFunc
+			ADDQ	#4,SP
+
+@old		LEA 	DSAlertRect,A0			; pt A0 at rect
 			TST.B	(A0)					; is this a system alert? (vs system error?)
 			BPL.S	DrawSysAlert			; yes, draw normal, do _MovePortTo
 
@@ -465,6 +481,56 @@ DrawBox2	MOVE.L	A0, -(SP)				; rect for EraseRect
 NoButtons 	RTS
 
 
+
+
+NewAlertFunc
+			Link	A6, #-$8
+			MoveM.L	A1-A3, -(A7)
+			MoveA.L	$8(A6), A3
+			Lea.L	-$8(A6), A2
+			MoveA.L	(A5), A0
+			Lea.L	-$74(A0), A0
+			Move.L	(A0)+, (A2)
+			Move.L	(A0), $4(A2)
+			SubQ	#$2, A7
+			Move	(MBarHeight), (A7)
+			Move	(A7)+, D0
+			Add		D0, (A2)
+			Move.L	A3, -(A7)
+			Move	$6(A2), D0
+			Add		$2(A2), D0
+			AsR		#$1, D0
+			Move	D0, -(A7)
+			Move	$6(A3), D0
+			Add		$2(A3), D0
+			AsR		#$1, D0
+			Sub		D0, (A7)
+			Move	(A2), D0
+			Add		$4(A2), D0
+			AsR		#$1, D0
+			Move	D0, -(A7)
+			Move	(A3), D0
+			Add		$4(A3), D0
+			AsR		#$1, D0
+			Sub		D0, (A7)
+			_OffsetRect
+			Move	(A3), D0
+			Sub		(A2), D0
+			Ext.L	D0
+			Neg.L	D0
+			DivS	#$3, D0
+			Move.L	A3, -(A7)
+			Clr		-(A7)
+			Move	D0, -(A7)
+			_OffsetRect
+			MoveM.L	(A7)+, A1-A3
+			Unlk	A6
+			Rts
+
+
+
+
+
 ;---------------------------------------------------------------------------
 ; DoButtons draws some buttons as specified by the buttonList data structure
 ; defined by the ID in D0, and then hit-tests the mouse position against
@@ -683,6 +749,7 @@ CmdLoop		MOVE.L	SP,A0					; Point to event record on stack
 			_OffsetRect 					; offset it
 			BSR 	MBDoErase				; erase it
 
+			MOVE.B	#$20,(A6)
 			MOVE.W	D3,-(SP)				; char width
 			NEG.W	(SP)					; negative movement
 			CLR.W	-(SP)					; delta V = 0
@@ -791,7 +858,7 @@ DMCmd		MOVE.L	#$007001B0,-(SP)		; push BR
 			RTS 							; and return
 
 Print6Hx	SWAP	D0
-			BSR.S	Print2Hx
+			BSR.S	Print4Hx
 			SWAP	D0
 
 Print4Hx	MOVE.W	D0,-(SP)
diff --git a/OS/StartMgr/StartBoot.a b/OS/StartMgr/StartBoot.a
--- a/OS/StartMgr/StartBoot.a
+++ b/OS/StartMgr/StartBoot.a
@@ -294,10 +294,6 @@ BootMe		PROC	EXPORT
 			EXPORT	InitSys7Toolbox
 			EXPORT	OpenSlots
 
-
-			BSR		CheckForROMDisk					; Check if we would like to boot a ROM disk				<SM33>
-			TST.W	D0								; Did we find a bootable ROM disk?						<SM33>
-			BEQ.S	@foundBootDisk					; If so then we've got startup device, now call BBs		<SM33>
 			BSR		FindStartupDevice				; Find the startup device & load boot blocks.
 													; (see StartSearch.a)
 
@@ -350,7 +346,8 @@ MyExecMask	EQU		BBNewMask+BBExecMask
 			CMP.B	#MyExecMask,D1					; Are these new executable boot blocks?
 			BNE.S	@NoExec							; If not, don't execute them
 
-@ExecBB		LEA		MyIOPBA6(A6),A0					; point to parameter block								<SM30>
+@ExecBB		BSR		MessWithZones
+			LEA		MyIOPBA6(A6),A0					; point to parameter block								<SM30>
 			MOVE.L	A0,D7							; set it where Boot blocks want it						<SM30>
 			JSR 	BBEntry(A6) 					; Execute the boot blocks
 @NoExec
@@ -372,17 +369,13 @@ ReBoot		move.w	BootDrive,D3					; Get current boot drive number
 			MOVE.W	#EjectCode,CSCode(A0)
 			MOVE.W	D3,IODrvNum(A0) 				; d3 = BootDrive, must be a drive# here!
 			_Control								; eject the bad diskette
-			BNE.S	@DisableNextTime				; If not ejectable, don't try again
 
 			move.b	(sp)+,d0						; restore DiskInPlace byte
+			tst		-$3f0(a6)
+			bne.b	@DisableNextTime
 			cmpi.b	#8,d0							; were we ejectable?
 			bge		@DisableNextTime				; no, don't boot from this drive again
 
-; ((( -------------------- Systems with HD20 --------------------
-			CMP.W	#$FFFE,BtDskRfN					; HD20's can pretend they're ejectable
-			BNE.S	@1								; Branch if it's not an HD20
-; ))) -------------------- Systems with HD20 --------------------
-
 @DisableNextTime
 			MOVE.W	BootMask,D0
 			BCLR	D3,D0
@@ -400,6 +393,41 @@ ReBoot		move.w	BootDrive,D3					; Get current boot drive number
 
 
 
+
+
+
+MessWithZones
+			MoveM.L   D0/A0-A1, -(A7)
+			Move.L    (ApplZone), D0
+			Cmp.L     (SysZone), D0
+			BEQ.B     (* + $4)
+			_InitApplZone
+			MoveA.L   (SysZone), A0
+			AddA.L    #$A00000, A0
+			MoveA.L   A7, A1
+			SubA.L    (DefltStack), A1
+			SubA.L    #$40000, A1
+			SubA.L    #$64000, A1
+			CmpA.L    A0, A1
+			BHI.B     (* + $4)
+			MoveA.L   A1, A0
+			_SetApplBase
+			MoveA.L   (SysZone), A0
+			Move.L    A0, (ApplZone)
+			Move.L    A0, (TheZone)
+			Move.L    (A0), (HeapEnd)
+			MoveA.L   A7, A0
+			SubA.L    (DefltStack), A0
+			SubA.L    #$40000, A0
+			_SetApplLimit
+			MoveM.L   (A7)+, D0/A0-A1
+			Rts
+
+
+
+
+
+
 ;________________________________________________________________________________________________
 		IF 0 THEN									;	<SM49>														<SM49>
 			IMPORT	IRQException					;
@@ -508,124 +536,131 @@ getDiskInPlace										; find the drive queue element
 @done		rts
 
 
-;________________________________________________________________________________________________			<SM33>
-; CheckForROMDisk
-;
-; The following code supports the "Ginty" ROM disk architecture (System Disk in ROM).
-; The idea is to pass control to the ROM disk so it can decide whether or not
-; to boot from the ROM disk.  If there is no ROM disk present or this particular machine
-; does not support it then we continue as usual in the boot process.
-;
-; Input:	nothing
-; Output:	D0.W = non-zero if no ROM disk was found or if one was it was non-bootable
-;			D0.W = zero means we found a bootable ROM disk.  The code in the ROM disk
-;					already called FinderStartupDevice.
-;________________________________________________________________________________________________
-
-CheckForROMDisk
-			move.l	UnivROMFlags,d0					; get external features flag
-			btst.l	#ProductInfo.SupportsROMDisk,d0 ; see if machine supports ROM disks?
-			beq.s	@noROMDisk						; if not then just continue as usual
-
-			bsr.s	FindROMDisk						; check if we have a ROM disk
-			beq.s	@foundROMDisk
-
-			move.l	UnivROMFlags,D0					; get external feature flags
-			btst.l	#ProductInfo.V8ChipBit,D0		; are we on a VISA decoder machine?
-			beq.s	@NoROMDisk						; if not then we're done
-;
-; ---- At this pt we need to check ROM space one more time but with the C/D slot bit XOR'ed in the ----
-; ---- Miscellaneous Setup Register ($50F26009), we need to do this because we cannot tell if we   ----
-; ---- have a PDS/PCMCIA flash card installed or a ROM exp. SIMM.  With this bit cleared no DSACK  ----
-; ---- is generated by the ASIC and with it set DSACK is generated by the PDS card attached.       ----
-
-			move.l	#$50F26009,A0					; Miscellaneous Setup Register in VIA2 space
-			bfchg	(A0){4:1}						; complement the C/D bit field in setup register
-			bsr.s	FindROMDisk						; check for bootable ROM disk
-			beq.s	@foundROMDisk					;
-
-			move.l	#$50F26009,A0					; Miscellaneous Setup Register in VIA2 space
-			bfchg	(A0){4:1}						; set field back to original setting
-			bra.s	@NoROMDisk						;
-;
-;	At this point, A0 points to the beginning of the header for the RomDisk driver.
-;	(A0 gets set in routine FindROMDisk)
-;
-@foundROMDisk
-			with	GintyHeader
-
-			move.l	HdrBootCode(A0),D0				; get the offset to search routine
-			beq.s	@NoROMDisk						; it's zero, so no search routine
-			adda.l	HdrBootCode(A0),A0				; point to search routine
-			jsr		(A0)							; call the ROM Disk search/open routine
-			tst.w	D0								; see if it found the boot blocks
-			beq.s	@FoundDevice					; ready to boot (A6 points to boot blocks)
-
-; ------------ If we get here, we didn't find a ROMDisk ------------
-;
-@noROMDisk	st		d0								; set d0 to TRUE to indicate no ROM disk
-@FoundDevice
-			rts
+;--------------------------------------------------------------------
+; Open all slot drivers which request to be opened at Start time.
+; Destroys	no registers.
+; Note: *** A0, A1, D3 & D4 must be preserved by OpenSDrvr,OpenBDrvrs and AddVidDevice.
+;--------------------------------------------------------------------
+
+OpenSlots
+			WITH	spBlock, seBlock
+
+			MOVEM.L	A0-A1/D0-D4,-(SP)				; Save registers
+
+			LEA		-IOQElSize(SP),SP				; Allocate parameter block for device manager calls.
+			MOVE.L	SP,A1
+			CLR.B	IOPermssn(A1)					; r/w permissions
+
+			SUB 	#spBlockSize,SP					; Allocate parameter block for SDM calls.
+			MOVE.L	SP,A0
+			CLR.B	spSlot(A0)						; Start with slot #0.
+			CLR.B	spExtDev(A0)
+			CLR.B	D3								; Start with sResource ID #0
+
+;  Search for next sResource and open the driver if the fOpenAtStart flag is set (or sRsrc_Flags are missing).
+													;REPEAT
+@Repeat		MOVE.B	D3,spId(A0)						;  Restore the sResource Id
+			_sNextsRsrc								;  Find next sResource
+			BNE.S	@Done							;  Done if no more sResources
+													;
+			MOVE.B	spId(A0),D3						;  Save the sResource id
+			MOVE.L	spsPointer(A0),D4				;  Save the sPointer
+
+			MOVE.B	#sRsrcFlags,spId(A0)			;  Read the sResource flags
+			_sReadWord								;  IF sRsrc_Flags are missing THEN
+			BNE.S	@10								;     default = flag is set, Open the drvr
+			MOVE.W	spResult+2(A0),D0
+			BTST.L	#fOpenAtStart,D0				;  IF fOpenAtStart flag is not set THEN
+			BEQ.S	@Repeat							;  	 do not open the driver
+
+@10			MOVE.B	#sRsrcBootRec,spId(A0)
+			_sFindStruct							;  IF there is no sBoot Record THEN
+			BNE.S	@20								;	 Branch
+													;  ELSE
+			MOVE.B	D3,spId(A0)						;    Restore the sResource Id
+			MOVE.L	D4,spsPointer(A0)				;  	 Restore the sPointer
+			BSR		OpenBDrvrs						;    Open all drivers for this device
+			BRA.S	@Repeat							;  	 continue with loop
+
+@20			MOVE.B	D3,spId(A0)						;  Restore the sResource Id
+			BSR		OpensDrvr						;  Try to open the driver
+			BNE.S	@Repeat							;  If error THEN it can't be opened
+
+;  If it is a video card, then install into device chain
+
+			CMP.L	#(CatDisplay<<16)++TypVideo,spCategory(A0)	; Check for proper <Category><Type>
+			BNE.S	@Repeat							; continue loop if not
+			CMP.W	#DrSWApple,spDrvrSW(A0)			; Check for an Apple driver interface
+			BNE.S	@Repeat							;  =>no, not a video card
+			BSR		AddVidDevice					;  else add video device to device list
+
+@Until		BRA.S	@Repeat							;UNTIL (no more sResources)
+
+@Done		LEA		IOQElSize+spBlockSize(SP),SP	;Deallocate parameter blocks.
+
+
+;-------------------------------------
+; Clear flag so InitGraf will load screen configuration from system file
+; (Flag was set in InitVidDeflt to avoid initialization before all devices open)
+;-------------------------------------
+
+			MOVE.L	DeviceList,A0					;get first device in list
+			MOVE.L	(A0),A0							;point to this device
+			BCLR	#AllInit,GDFlags(A0)			;say devices not initialized
+
+			MOVEM.L	(SP)+,A0-A1/D0-D4				;Restore registers
+			RTS
 
 
 ;------------------------------------------------------------------------------------------------
-;	Search through ROM looking for the special ROM disk header info.
-;	If found, check for boot blocks.  Adapted from code in EDiskDrvr.a.
-;
-;	Returns EQ if we found a ROM disk with boot blocks, NE if not.
-;	If ROM disk found then A0 contains a ptr to the ROM Disk header.
-;
-;	Destroys D0,A0
-
-FindROMDisk
-			movem.l	d1/a2-a4,-(sp)					; save registers
-
-			movea.l	RomBase,a2						; start searching at the base of ROM
-			move.l	a2,d1
-			addi.l	#ROMSize,d1						; end of ROM space to search
-@RomDiskLoop
-			move.w	sr,-(sp)						; save old interrupt mask
-			ori.w	#HiIntMask,sr					; disable interrupts (stealing BusErrVct)
-			move.l	BusErrVct,-(sp)					; save old bus error vector
-			lea		@NotFound,a0					; new handler address
-			move.l	a0,BusErrVct					; setup bus error handler
-			movea.l	sp,a4							; mark the stack
-
-			lea		HeaderTemplate,a3				; point to expected values
-			lea		HdrBlockSize(a2),a0				; point to header data
-			moveq.l	#(HdrDeviceSize-HdrBlockSize)/4-1,d0	; loop counter
-@SigCmpLoop
-			cmpm.l	(a0)+,(a3)+						; compare the values
-			dbne	d0,@SigCmpLoop					; compare the blocks
-@NotFound
-			movea.l	a4,sp							; pop stack in case of bus error
-			move.l	(sp)+,BusErrVct					; restore bus error vector
-			move.w	(sp)+,sr						; restore interrupt mask
-			addq.w	#1,d0							; see if we had a match
-			bne.s	@NextBlock						; no, check next block
-			move.l	a2,a0							; save our position in ROM
-			moveq	#0,d0							; set cc to EQ
-			bra.s	@Done							; return EQ
-@NextBlock
-			adda.l	#RomDiskAlign,a2				; point to next block to check
-			move.l	d1,a0
-			cmpa.l	a0,a2							; see if end reached
-			blo.s	@RomDiskLoop					; search the entire space
-			moveq	#1,d0							; set cc to NE
-@Done
-			movem.l	(sp)+,d1/a2-a4					; restore registers
-			rts
-
-			endwith									; GintyHeader
-
-
-			string	asis							; no length on strings
-			align	2
-HeaderTemplate
-			dc.w	512								; signature block size
-			dc.w	1								; version number 1
-			dc.b	'Ginty '						; 12 byte signature
-			dc.b	'HYGWGA'						; (brought to you by et. al)
+; PROCEDURE:OpenBDrvrs
+; Execute sBoot code to load in all drivers for this hw device
+;  	A0 -> Pointer to SDM parameter block.
+; Destroys	no registers
+; Called by : OpenSlots.
+;------------------------------------------------------------------------------------------------
+
+OpenBDrvrs	MOVE.B	spSlot(A0),-(SP)				;Save slot
+			MOVE.B	spId(A0),-(SP)					;Save Id
+			MOVEM.L	D0-D3/A0-A1,-(SP)				;Save registers.
+
+			SUB		#seBlockSize,SP					;Allocate parameter block for code executed by _sExec.
+			MOVE.L	SP,A1
+			MOVE.L	A1,spsExecPBlk(A0)				;Save pointer to se parameter block.
+
+
+;  Get the default OS of Startup Device (Use the same OS type to load the drivers)
+			MOVE.L	A0,D3							;Save A0
+			SUBQ.L	#2,SP							;Make room for parameters
+			MOVE.L	SP,A0							;Point to the parameter block
+			_GetOSDefault							;Get info about the default device
+			MOVE.W	(SP)+,D2						;D2 <- <Reserved><OSType>
+			MOVE.L	D3,A0							;Restore A0
+
+
+;  Set the parameters for the code in sExec.
+			MOVE.B	spSlot(A0),seSlot(A1)			;Slot,
+			MOVE.B	spId(A0),sesRsrcId(A1)			;sResource.
+			CLR.B	sePartition(A1)					;Partition,
+			CLR.B	seDevice(A1)					;Device, and
+			MOVE.B	D2,seOSType(A1)					;Default OS
+			LSR.L	#8,D2
+			MOVE.B	D2,seReserved(A1)				;Reserved field
+			MOVE.B	#sbState1,seBootState(A1)		;State of StartBoot code.
+
+
+;  Execute the code in the sBoot record.
+			MOVE.B	#sRsrcBootRec,spId(A0)			;Execute the code:
+			_sExec									;  On entry to the boot code, A0 points to the SE parameter block.
+
+
+;  Exit.
+			ADD		#seBlockSize,SP					;De-Allocate SE parameter block.
+			MOVEM.L	(SP)+,D0-D3/A0-A1				;Restore registers.
+			MOVE.B	(SP)+,spId(A0)					;Restore Id
+			MOVE.B	(SP)+,spSlot(A0)				;Restore slot
+
+			RTS
 
 
 ;______________________________________________________________________________________
@@ -638,259 +673,9 @@ HeaderTemplate
 ;______________________________________________________________________________________
 
 InitSys7Toolbox
-			_InitAllPacks							; Make sure the Packs are available at this time
-
-			BSR.L	NewGestaltSelectors				;
-
-			; Don't call ShutInit here since it blows away existing shutdown tasks <SM56>
-
-			BSR.L	ALIASMGRINSTALL
-
-			BSR.L	SetupGlobals					; Comm Toolbox											<SM26>
-			BSR.L	SetupGestalt					;														<SM26>
-
-			BSR.L	InitDialogMgrGlobals
-			BSR.L	InitScrollSpeedGlobals			; scrollbar scrolling speed
-			BSR.L	ExtBTreeInstall
-			BSR.L	PPCINSTALL
-			BSR.L	NMINIT
-			BSR.L	InitValidateMenuBarSemaphore
-			BSR.L	InitSystemMenuList
-			BSR.L	MiscPatchesInstall
-			CLR.L	-(SP)							; unused parameter for system builds
-			BSR.L	__InitComponentManager
-			BSR.L	ClearSysErrorUpdateRect			; ToolboxEventMgrPatches
-			BSR.L	TSMgrInstall
-			BSR.L	HelpMgrInstall
-			BSR.L	ADDFONTSTOCHAIN					; FontFolder											<SM15>
-
-	; ADBSecondaryInitialization					; <SM49> SAM (from here down...)
-
-			BSR.L	InitADBDrvr						; Another reinit
-
-			
-	; Display Manager
-	
-		IF hasDisplayMgr THEN						; <52>
-			SUBQ	#2,A7
-			_DMInstallDisplayManager				; Display Manager
-			ADDQ	#2,A7
-		ENDIF										; <52>
-
-	; SlotMgrSecondaryInitializationIIci
-
-			SUB.W	#spBlock.spBlockSize,SP			; Make room for a slot parameter block on the stack
-			MOVEA.L	SP,A0							; Point A0 to the record
-			BSET	#fWarmStart,spBlock.spFlags(A0)	; Set warm start flag
-			_SecondaryInit							; Wake everybody up again
-			ADD.W	#spBlock.spBlockSize,SP			; Remove the param block from the stack
-			BSR		OpenSlots						; Open all slot drivers...
-
-	; ColorQDSecondaryInitialization
-
-			JSR		DavesRandomVideoStuff			; re-do CheckDevices and video driver patching.
-			MOVE.L	(a5),-(sp)						; point to the same globals we are using now
-			_InitGraf								; catch all the new devices
-			_InitPalettes							; me too...
-
-	; SetUpIconCluts
-
-			PEA		([ExpandMem],ExpandMemRec.emIconCluts)
-			JSR		MakeIconData
-
-	; FontMgrSecondaryInitialization
-
-			_InitFonts								; Reinit the font manager (in case a new one's just been loaded)
-
-	; File System Cache
-
-			BSR		AdjustBarrier								; Get the limit to bufPtr in A2
-			BTST	#extensionsEnabledBit,ExtensionsEnabledByte	; Have extensions been disabled?
-			BNE.S	@normal										; -> No. Use the default limit
-
-			MOVE.L	BufPtr,d2						; Extensions disabled.  Limit the cache to 64k
-			SUB.L	#$10000,d2						; give the cache 64K
-			BRA.S	@continue						; -> Join the common code
-
-@normal		MOVE.L	BootGlobals.bufPtrLimit(a5),d2	; Get the current limit
-			ADD.L	#elbowRoomCacheCantHave,d2		; Reserve 32k or so to assure we can boot
-@continue	BSR.L	CacheInstall					; Install the disk cache
-	;
-	;
-			BSR.L	LateLoad						; Wait for SCSI devices present last time (that may not be ready yet)
-													; Load their drivers if they come up to speed.
-
-	; VM Final Initialization
-
-	; If VM loaded, we need to call MemoryDispatch with selector (-1) so VM can hold the system heap,
-	; unhold the boot stack, patch the cursor task, and enable user mode.
-
-			TST.L	VMGlobals						; Has VM installed itself?
-			BMI.S	@noVM							; -> No.  No Memory Dispatch
-
-@hasVM		MOVEQ	#-1,D0							; Finish VM initialization selector
-			_MemoryDispatch							; Call VM.
-			BRA.S	@Done							; ->> Jump to end
-
-@noVM		LEA		AfterBootSetApplBase,A0			; Patch _SetAppBase to call _InitZone before and after
-			MOVE.W	#$A057,D0						; it calls the real SetAppBase.  Do this only if VM is
-			_SetTrapAddress ,NewOS					; not installed, or you'll look like a Cyclone.
-
-@Done		RTS										; Return to boot3 (or Gibbly)
-													; 									<SM449> SAM  (End of today's mods)
-; •• End of InitSys7Toolbox ••
-;______________________________________________________________________________________
-
-;--------------------------------------------------------------------
-; Open all slot drivers which request to be opened at Start time.
-; Destroys	no registers.
-; Note: *** A0, A1, D3 & D4 must be preserved by OpenSDrvr,OpenBDrvrs and AddVidDevice.
-;--------------------------------------------------------------------
-
-OpenSlots
-			WITH	spBlock, seBlock
-
-			MOVEM.L	A0-A1/D0-D4,-(SP)				; Save registers
-
-			LEA		-IOQElSize(SP),SP				; Allocate parameter block for device manager calls.
-			MOVE.L	SP,A1
-			CLR.B	IOPermssn(A1)					; r/w permissions
-
-			SUB 	#spBlockSize,SP					; Allocate parameter block for SDM calls.
-			MOVE.L	SP,A0
-			CLR.B	spSlot(A0)						; Start with slot #0.
-			CLR.B	spExtDev(A0)
-			CLR.B	D3								; Start with sResource ID #0
-
-;  Search for next sResource and open the driver if the fOpenAtStart flag is set (or sRsrc_Flags are missing).
-													;REPEAT
-@Repeat		MOVE.B	D3,spId(A0)						;  Restore the sResource Id
-			_sNextsRsrc								;  Find next sResource
-			BNE.S	@Done							;  Done if no more sResources
-													;
-			MOVE.B	spId(A0),D3						;  Save the sResource id
-			MOVE.L	spsPointer(A0),D4				;  Save the sPointer
-
-			MOVE.B	#sRsrcFlags,spId(A0)			;  Read the sResource flags
-			_sReadWord								;  IF sRsrc_Flags are missing THEN
-			BNE.S	@10								;     default = flag is set, Open the drvr
-			MOVE.W	spResult+2(A0),D0
-			BTST.L	#fOpenAtStart,D0				;  IF fOpenAtStart flag is not set THEN
-			BEQ.S	@Repeat							;  	 do not open the driver
-
-@10			MOVE.B	#sRsrcBootRec,spId(A0)
-			_sFindStruct							;  IF there is no sBoot Record THEN
-			BNE.S	@20								;	 Branch
-													;  ELSE
-			MOVE.B	D3,spId(A0)						;    Restore the sResource Id
-			MOVE.L	D4,spsPointer(A0)				;  	 Restore the sPointer
-			BSR		OpenBDrvrs						;    Open all drivers for this device
-			BRA.S	@Repeat							;  	 continue with loop
-
-@20			MOVE.B	D3,spId(A0)						;  Restore the sResource Id
-			BSR		OpensDrvr						;  Try to open the driver
-			BNE.S	@Repeat							;  If error THEN it can't be opened
-
-;  If it is a video card, then install into device chain
-
-			CMP.L	#(CatDisplay<<16)++TypVideo,spCategory(A0)	; Check for proper <Category><Type>
-			BNE.S	@Repeat							; continue loop if not
-			CMP.W	#DrSWApple,spDrvrSW(A0)			; Check for an Apple driver interface
-			BNE.S	@Repeat							;  =>no, not a video card
-			BSR		AddVidDevice					;  else add video device to device list
-
-@Until		BRA.S	@Repeat							;UNTIL (no more sResources)
-
-@Done		LEA		IOQElSize+spBlockSize(SP),SP	;Deallocate parameter blocks.
-
-
-;-------------------------------------
-; Clear flag so InitGraf will load screen configuration from system file
-; (Flag was set in InitVidDeflt to avoid initialization before all devices open)
-;-------------------------------------
-
-			MOVE.L	DeviceList,A0					;get first device in list
-			MOVE.L	(A0),A0							;point to this device
-			BCLR	#AllInit,GDFlags(A0)			;say devices not initialized
-
-			MOVEM.L	(SP)+,A0-A1/D0-D4				;Restore registers
-			RTS
-
-
-;------------------------------------------------------------------------------------------------
-; PROCEDURE:OpenBDrvrs
-; Execute sBoot code to load in all drivers for this hw device
-;  	A0 -> Pointer to SDM parameter block.
-; Destroys	no registers
-; Called by : OpenSlots.
-;------------------------------------------------------------------------------------------------
-
-OpenBDrvrs	MOVE.B	spSlot(A0),-(SP)				;Save slot
-			MOVE.B	spId(A0),-(SP)					;Save Id
-			MOVEM.L	D0-D3/A0-A1,-(SP)				;Save registers.
-
-			SUB		#seBlockSize,SP					;Allocate parameter block for code executed by _sExec.
-			MOVE.L	SP,A1
-			MOVE.L	A1,spsExecPBlk(A0)				;Save pointer to se parameter block.
-
-
-;  Get the default OS of Startup Device (Use the same OS type to load the drivers)
-			MOVE.L	A0,D3							;Save A0
-			SUBQ.L	#2,SP							;Make room for parameters
-			MOVE.L	SP,A0							;Point to the parameter block
-			_GetOSDefault							;Get info about the default device
-			MOVE.W	(SP)+,D2						;D2 <- <Reserved><OSType>
-			MOVE.L	D3,A0							;Restore A0
-
-
-;  Set the parameters for the code in sExec.
-			MOVE.B	spSlot(A0),seSlot(A1)			;Slot,
-			MOVE.B	spId(A0),sesRsrcId(A1)			;sResource.
-			CLR.B	sePartition(A1)					;Partition,
-			CLR.B	seDevice(A1)					;Device, and
-			MOVE.B	D2,seOSType(A1)					;Default OS
-			LSR.L	#8,D2
-			MOVE.B	D2,seReserved(A1)				;Reserved field
-			MOVE.B	#sbState1,seBootState(A1)		;State of StartBoot code.
-
-
-;  Execute the code in the sBoot record.
-			MOVE.B	#sRsrcBootRec,spId(A0)			;Execute the code:
-			_sExec									;  On entry to the boot code, A0 points to the SE parameter block.
-
-
-;  Exit.
-			ADD		#seBlockSize,SP					;De-Allocate SE parameter block.
-			MOVEM.L	(SP)+,D0-D3/A0-A1				;Restore registers.
-			MOVE.B	(SP)+,spId(A0)					;Restore Id
-			MOVE.B	(SP)+,spSlot(A0)				;Restore slot
 
 			RTS
 
-AdjustBarrier	;																				<38>
-
-; Adjust BootGlobals.bufPtrLimit(a5) to have:
-;	MAX( sysHeap.bkLim + minProcessMgrSpace, static limits (i.e. boot globals & vm limits) )
-
-; Trashes:	a0/d0
-
-			move.l	SysZone,a0
-			move.l	a0,d0							; copy baseAddr of SysZone
-			move.l	bkLim(a0),a0
-			add.l	#initialSysHeapSize,d0
-			cmp.l	d0,a0							; if heap is small because we’re on a small RAM machine
-			bhs.s	@enoughReservedForSysHeap		;   pretend heap is at initialSysHeapSize because it will
-													;   be that big soon anyway.
-			move.l	d0,a0							;   Set to be the minimum we’d ever consider.
-@enoughReservedForSysHeap
-			add.l	#minProcessMgrSpace,a0			; where the process mgr heap would end if we
-													; created it right now
-			cmp.l	BootGlobals.bufPtrLimit(a5),a0	; processMgrHeap.bkLim > current barrier?
-			bls.s	@dont							; if not, don’t adjust
-
-			move.l	a0,BootGlobals.bufPtrLimit(a5)	; set new barrier
-@dont
-			rts
 
 			ENDP
 
diff --git a/OS/StartMgr/StartErr.a b/OS/StartMgr/StartErr.a
--- a/OS/StartMgr/StartErr.a
+++ b/OS/StartMgr/StartErr.a
@@ -235,57 +235,6 @@ SysErrInit	PROC	EXPORT					;												<C152>
 			ENDP							;												<C152>
 
 
-;----------------------------------------------------------------------
-; Routine		Debugger (Arg1, Arg2...ArgN, ParamSize, CmdWord)
-; Arguments 	Highly variable
-; Function		Dispatch debugger call to current installed debugger,
-;				else ignore. (_Debugger trap)
-;----------------------------------------------------------------------
-
-Debugger	PROC	EXPORT					;												<C152>
-			EXPORT	DebugProlog				;												<C152>
-
-			MOVEM.L A0-A7/D0-D7,SEVars		; save all regs
-
-			BSET	#7,MacJmpFlag			; in the debugger 								<v1.2>
-
-			LINK	A6,#0					; no locals
-			LEA 	8(A6),A0				; pt A0 at args
-			MOVE.W	(A0)+,D0				; get command word
-			MOVE.W	(A0)+,SECmdSize 		; stash size of param list
-			BSR.S	DebugProlog 			; set up call for debuggers, set CC=existence
-			BLE.S	DebugErr				; V true, so either Z or (NOT N) means no inited debugger
-
-; Now we know there's a debugger, so call it.
-; A0 = ptr to last command parameter, A1 = ptr to debugger entry pt.
-
-			BSET	#15,D0					; set high bit of word to flag trap call
-			JSR 	(A1)					; call debugger!!!!
-
-DebugAdios	UNLK	A6						; restore A6
-			MOVEM.L SEVars,A0-A7/D0-D7		; restore all regs
-			MOVE.L	(SP)+,A0				; get return address
-			ADD.W	SECmdSize,SP			; pop params
-			ADDQ.L	#4,SP					; pop command word & size word
-			BCLR	#7,MacJmpFlag			; out of the debugger 							<v1.2>
-			JMP 	(A0)					; and return
-
-
-DebugErr	MOVEQ	#SENoDB,D0				; return "no debugger" error
-			BRA.S	DebugAdios
-
-; Utility for setting CC's for existance of debugger, pointing A1 to debugger code entry.
-; Must preserve D0.
-
-DebugProlog
-			MOVE.L	MacJmp,A1				; get ptr in A1									<v1.2>
-			MOVE.B	MacJmpFlag,D3			; get flags										<v1.2>
-			ADD.B	D3,D3					; init flag now high bit, set CC's
-			RTS 							; and return
-
-			ENDP							;												<C152>
-
-
 ;----------------------------------------------------------------------
 ; Routine		ToDeepShit
 ; Arguments 	(SP)	(input) 		Return address to exception receiver
@@ -320,23 +269,15 @@ ToDeepShit	PROC	EXPORT					;												<C152>
 ; Now clear stack of exception info, saving SR and PC unless re-entered.  A special case	<13Jul85>
 ; is class 0 exception on the 68000, which has 4 words of info on top of the usual SR/PC.	<13Jul85>
 
-			TST.B	CPUFlag 				; 0-000, 1-010, 2-020, etc. 					<13Jul85>
-			BNE.S	@1						;												<13Jul85>
-
-			CMPI.W	#2,D0					; 1 or 2 means nasty bus error frame			<13Jul85>
-			BGT.S	@1						;												<13Jul85>
-			MOVE.L	(SP)+,SE000BE			; save fcn code, access address, and instruction word	<04Nov85> JTC
-			MOVE.L	(SP)+,SE000BE+4 		; ...the other 4 bytes of the eight 					<04Nov85> JTC
-@1
-			TST.B	MacJmpFlag				; minus means we're re-entering					<13Jul85>
-			BMI.S	@3						;												<13Jul85>
+			TST.B	$BFF
+			BMI.S	@3
 
 			MOVE	(SP)+,SESR				; SR on top for all CPUs						<13Jul85>
 			MOVE.L	(SP)+,SEPC				; next is the saved PC							<13Jul85>
-			BRA.S	SysErr2					; bypass nonsaving pop							<13Jul85><1.4>
+			BRA		SysErr2					; bypass nonsaving pop							<13Jul85><1.4>
 
 @3			ADDQ.W	#6,SP					; kill SR and PC								<13Jul85><1.4>
-			BRA.S	SysErr2
+			BRA		SysErr2
 			NOP								; appease the assembler gods <12> kc
 			ENDP							;							 <C152>
 
@@ -396,8 +337,6 @@ SystemError	PROC	EXPORT					;												<C152>
 
 SysErr1		MOVE.W	SR,SESR 				; save SR										<13Jul85>
 			MOVE.L	(SP)+,SEPC				; clean PC for fall-through to SysErr2			<13Jul85>
-			TST.B	CPUFlag 				; zero for 68000								<02Nov85>  JTC
-			BEQ.S	SysErr2 				; no need for dummy frame on old cpu			<02Nov85>  JTC
 			CLR.W	-(SP)					;												<02Nov85>  JTC
 
 ; entry point for standard system exceptions (address error, etc)
@@ -407,71 +346,9 @@ SysErr2
 			BMI.S	@0						; yes, skip reg saving
 			MOVE.L	SP,SEA7 				; save true PC
 @0											; deleted obsolete stack-cleansing instructions <13Jul85>
-			BSET	#7,MacJmpFlag			; prevent re-entrancy, vote Republican			<v1.2>
+			BSET.B	#7,MacJmpFlag			; prevent re-entrancy, vote Republican			<v1.2>
 
-			cmpi.w	#13,d0					; was it an NMI?								<1.5>
-			bne.w	@continue				; no, proceed									<1.5>
 
-		    TestFor RBVExists				;												<1.5>
-			beq.s	@noRBV					;												<1.5>
-
-			btst.b	#ProductInfo.PGCInstalled,UnivRomFlags+3	; see if we have a PGC chip		<9><4><H5><SM4>
-			beq.s	@continue									; no, handle normal NMI-- there is no parity 	<4><SM5>
-
-			move.l	VIA,A0					; get VIA1 base									<1.5>
-		eieioSTP
-			btst	#vPGCEnb,VBufB(a0)		; is parity enabled?							<1.5>
-		eieioSTP
-			bne.s	@continue				; no, proceed									<1.5>
-		eieioSTP
-			bclr	#vPGCErr,vDirB(a0)		; make parity error bit an input				<1.5>
-		eieioSTP
-			move.b	VBufB(a0),d1			; read parity error flag						<2.1>
-		eieioSTP
-			bset	#vPGCErr,vDirB(a0)		; back to an output								<1.5>
-		eieioSTP
-			btst	#vPGCErr,d1				; was NMI caused by parity error?				<1.5>
-			bne.s	@continue				; no, restore ddr and proceed					<1.5>
-		eieioSTP
-			bset	#vPGCEnb,VBufB(a0)		; yes, disable parity (so we won't get int again<1.5>
-		eieioSTP
-			bra.s	@parityErr				; and blast the warm start flag
-@noRBV
-
-			WITH 	DecoderInfo
-		    TestFor RPUExists				; do we have RPU parity?
-			beq.s	@continue				; no, skip...
-
-			movea.l	OSS,a0					; get OSS address
-		eieioSTP
-			move.w	OSSIntStat(a0),d1
-		eieioSTP
-			btst	#OSSIntRPU,d1			; did the RPU cause the interrupt?
-			beq.s	@continue				; no, handle normal NMI
-		eieioSTP
-			clr.b	OSSMskRPU(a0)			; disable RPU parity interrupts					<2>
-		eieioSTP
-			movea.l	UnivInfoPtr,a0
-			adda.l	ProductInfo.DecoderInfoPtr(a0),a0
-			movea.l	RPUAddr(a0),a0			; get RPU base
-			st.b	rpuReset(a0)			; reset serial ptr
-			move.l	(a0),d1
-			bset.l	#16,d1					; clear the parity error
-			move.l	d1,(a0)
-@parityErr
-		IF Supports24Bit THEN				;												<SM7>
-			moveq	#true32B,d0				; 32 bit mode to look at BootGlobs 				<1.9>
-			_SwapMMUMode					; switch to 32 bit mode							<1.9>
-			move.l	BootGlobPtr,a1			; get ptr to boot globals (near top of RAM) 	<1.6><1.8>
-			clr.l	StartGlobals.sgWarmStart(a1) ; <SM3> CSS clear boot-globs warm start flag
-			_SwapMMUMode					; switch back to previous mode (in d0)			<1.9>
-		ELSE
-			move.l	BootGlobPtr,a1			; get ptr to boot globals (near top of RAM) 	<1.6><1.8>
-			clr.l	StartGlobals.sgWarmStart(a1) ; <SM3> CSS clear boot-globs warm start flag
-		ENDIF
-			clr.l	WarmStart				; clear low memory global warm start flag		<1.6>
-			moveq	#dsParityErr,d0			; yes, set parity error code					<1.5><1.7>
-@continue									;												<1.5>
 			cmpi.w	#dsNoPatch,d0			; is this Error can't find patch ?				<SM6> rb
 			beq.s	@PreCubeE				; change the error message then					<SM6> rb
 			cmpi.w	#dsBadPatch,d0			; is this a can't load patch message ?			<SM6> rb
@@ -482,10 +359,10 @@ SysErr2
 
 			MOVE.W	D0,DSErrCode			; Save the possibly modified ErrCode			<SM7>
 
-; now we've set up all regs, etc.  Time to decide whether to call the debuggers
-; or just call the Deepshit code
+			MOVE.L	MacJmp,A1
+			MOVE.B	MacJmpFlag,D3
+			ADD.B	D3,D3
 
-			BSR 	DebugProlog 			; any debuggers?
 			BPL.S	Call2DS 				; yes, but not initialized (init bit not set)
 			BNE.S	CallDB					; yes, initialized, call 'em
 
diff --git a/OS/StartMgr/StartFail.a b/OS/StartMgr/StartFail.a
--- a/OS/StartMgr/StartFail.a
+++ b/OS/StartMgr/StartFail.a
@@ -287,23 +287,12 @@ CritErr		MOVEM.L A0-A7/D0-D7,SERegs			; save all regs for debug					<26Aug85>
 
 			LSR.L	#2,D3						; Compute number of longs on screen.		<C152>
 
-		if hasMMU then							;											<1.7>
-			MOVEQ	#true32b,D0					; set 32-bit addressing mode	
-			_SwapMMUMode						;
-			MOVE.B	D0,-(SP)					; save the previous mode
-		endif									;											<1.7>
-
 			MOVEQ	#-1,D0						; This should be black.						<C152>
 
 @FillLoop	MOVE.L	D0,(A2)+					; Fill a long.								<C152>
 			SUBQ.L	#1,D3						; Countdown.								<C152>
 			BHI.S	@FillLoop					; Loop until done.							<C152>
 
-		if hasMMU then							;									<1.7>
-			MOVE.B	(SP)+,D0					; get the previous addressing mode back
-			_SwapMMUMode						; flip back to previous addressing mode
-		endif									;									<1.7>
-			
 ; Okay, here are the values we still consider important at this point:
 ;
 ;	A3		=	pointer to the center of the screen.
@@ -343,7 +332,7 @@ CritErr		MOVEM.L A0-A7/D0-D7,SERegs			; save all regs for debug					<26Aug85>
 
 			BSR6	DeadMac 					; plot the dead Mac icon
 
-SkipDisplay	BigJmp	TMRestart,a0				; go to Test Manager entry point			<C27/30may86><1.4><2.0><2.1>
+SkipDisplay	BRA.S	*
 
 TinyTable	DC.W	$0000,$FFFF,$FFFF,$FFFF		; whiteColor
 			DC.W	$0000,$0000,$0000,$0000		; black
@@ -370,13 +359,6 @@ TinyTable	DC.W	$0000,$FFFF,$FFFF,$FFFF		; whiteColor
 ;-----------------------------------------------------------------------------
 
 FailData	
-		if hasMMU then							;									<1.7>
-			MOVEQ	#true32b,D1					; put in D1 for a second
-			EXG		D1,D0						; get true32b in D0, save D0 in D1
-			_SwapMMUMode						; switch to 32-bit addressing
-			MOVE.B	D0,-(SP)					; save the previous addressing mode
-			EXG		D1,D0						; get D0 back in D0
-		endif									;									<1.7>
 FailLoop
 			ROL.L	#4,D0						; get nibble in low order
 
@@ -409,11 +391,6 @@ chLoop		MOVE.B	(A1),D5 					; get the next byte
 
 			DBRA	D4,FailLoop					; loop until all characters are drawn
 			
-		if hasMMU then							;									<1.7>
-			MOVE.B	(SP)+,D0					; get the old addressing mode back
-			_SwapMMUMode						; restore the addressing mode
-		endif									;									<1.7>
-			
 			JMP		(A6)						; return to caller
 						
 ;----------------------------------------------------------------------------
@@ -458,12 +435,6 @@ DeadMac
 			LEA		SadMacIcon,A0				;point to the "Sad Mac" icon				<1.3>
 			MOVE.L	IconTLAddr,A2				; figure out where the topLeft corner is	<1.3>
 
-		if hasMMU then							;											<1.7>
-			MOVEQ	#true32b,D0					; flip to 32-bit mode						
-			_SwapMMUMode						; switch to 32-bit addressing			
-			MOVE.B	D0,-(SP)					; save the previous mode
-		endif									;											<1.7>
-
 			MOVEQ	#6,D1						; move the icon down 6 lines				<1.9>
 			MULU	D2,D1						; 											<1.9>
 			ADDA.L	D1,A2						;											<1.3><1.9>
@@ -476,10 +447,6 @@ DeadMac
 			ADDA.W	D2,A2						; move down to the next screen line			<1.3><1.9>
 			DBRA	D1,@BlastIcon				; keep looping until all 32 lines are copied<1.3><1.9>
 
-		if hasMMU then							;											<1.7>
-			MOVE.B	(SP)+,D0					; switch back to previous addressing mode
-			_SwapMMUMode						; flip back
-		endif									;											<1.7>
 			RTS6								; return to caller							<1.3>
 
 
diff --git a/OS/StartMgr/StartInit.a b/OS/StartMgr/StartInit.a
--- a/OS/StartMgr/StartInit.a
+++ b/OS/StartMgr/StartInit.a
@@ -1135,6 +1135,42 @@ ioNuBusTTxlat	EQU		$500FC040					; I/O space and nuBus $6-$7 with serialized wri
 			IMPORT	INITSCSIBOOT
 		ENDIF  
 
+;	CDG5 imports:
+
+			IMPORT	CheckSCSITargetCapable
+			IMPORT	CodePrepare
+			IMPORT	CodeRegister
+			IMPORT	DebugInit
+			IMPORT	DebugInit
+			IMPORT	DeviceMgr_BCScreen
+			IMPORT	DeviceMgr_BCScreen
+			IMPORT	ExpansionBusMgrFirstFunc
+			IMPORT	FindATADevices
+			IMPORT	GestaltCudaFunc
+			IMPORT	GetGrayPage
+			IMPORT	GetRealProc
+			IMPORT	InitATAMgr
+			IMPORT	InitBCScreen
+			IMPORT	InitBCScreen
+			IMPORT	InitDeviceDispatch
+			IMPORT	InitEtherPrintfLib
+			IMPORT	InitExpansionMgr
+			IMPORT	InitExpMgrVars
+			IMPORT	InitFireWire
+			IMPORT	InitLANDisk
+			IMPORT	InitNativePowerMgr
+			IMPORT	InitStorage
+			IMPORT	InitSystemExperts
+			IMPORT	InitUSB
+			IMPORT	LoadNDRV
+			IMPORT	LoadPCCardLib
+			IMPORT	MoveUnivInfoToSysHeap
+			IMPORT	MoveUnivInfoToSysHeap
+			IMPORT	RSetKMap
+			IMPORT	SearchDrivers
+			IMPORT	SizeMemory
+			IMPORT	WangBacklight
+
 
 MyROM		MAIN	Export
 
@@ -1145,16 +1181,11 @@ MyROM		MAIN	Export
 			EXPORT	InitDefGamma
 			EXPORT	InitSCC
 			EXPORT	OpensDrvr
-			EXPORT	PMSPSwOS
 			EXPORT	RomLoc
 			EXPORT	StartBoot
-			EXPORT	StartInit1
-			EXPORT	WDCBSwOS
 			EXPORT	TCOff
 			EXPORT	SetUpTimeK						; <SM142>
 
-			EXPORT	DynamicBoxFlag
-
 *************************************************************************************************
 *																								*
 *									S T A R T   O F   R O M										*
@@ -1216,6 +1247,9 @@ GOOFYDoEject
 			BRA.L	DoEject							; branch island to eject code
 
 
+			STRING	AsIs
+			DC.L	'Copyright (c) 1983-2002 Apple Computer, Inc.  All Rights Reserved.'
+
 
 *************************************************************************************************
 *																								*
@@ -1223,56 +1257,12 @@ GOOFYDoEject
 *																								*
 *************************************************************************************************
 
-TCOff		dc.l	0								; for turning off MMU below
+TCOff		dc.w	0								; for turning off MMU below
 
 Start
 StartBoot	MOVE	#$2700,SR						; Disable processor interrupts.
 
-	IF NOT ROMinRAM THEN							; 														<SM52>
-			sub.l	d0,d0							; D0 = 0
-			bset	#CACR_DE_040,d0					; set Data Cache Enable bit on 040s						<T22>
-			movec	d0,CACR							; attempt to enable data cache (temporarily)
-			movec	CACR,d0							; check and see if it's still there
-			btst	#CACR_DE_040,d0					; see if the bit exists in CACR							<T22>
-			beq.s	@not040							; IF we're on a 68040 THEN
-			
-			MACHINE	MC68040							;	need this for the MOVEC D0,TC below
-
-			cinva	bc								;	make sure caches are invalidated
-			sub.l	d0,d0							;	clear d0
-			movec	d0,CACR							;	disable both instruction and data caches
-			movec	d0,TC							;	make sure that the MMU is disabled
-			move.l	#nuBusTTxlat,D0					;	get value to translate upper nuBus space			<T18>
-			movec	d0,DTT0							;	use serialized writes on this space 				<T18>
-			move.l	#ioNuBusTTxlat,D0				;	get value to translate i/o and nuBus space			<T18>
-			movec	d0,DTT1							;	use serialized writes on this space 				<T18>
-			bra.s	@not030							;	step around the rest of the 020/030 cache/tc stuff
-
-			MACHINE	MC68030							;	set it back to what works for 020/030
-@not040												; ELSE
-			move.l	#(1<<CACR_WA_030),d0			;	CACR value w/WA bit for 030
-			movec	d0,CACR							;	disable both instruction & data caches
-			movec	CACR,d0							;	hmmm, maybe we are an 030
-			tst.l	d0								;	see if WA bit is still on
-			beq.s	@not030							;	IF we are an 030 processor
-			lea		TCOff,a0						;     point to TC value that disabled the MMU
-			pmove	(a0),tc							;     turn off MMU
-													;	ENDIF
-@not030
-
-		  IF	forRomulator THEN
-			TestInRam	A0
-			bne.s	@dontReset						; don't reset if running in RAM
-		  ENDIF
-
-;	NOTE: The MMU must be disabled before doing a RESET if the MMU tables are in RAM, especially
-;	on machines with Overlay bits.  RESET will cause the hardware to enter Overlay Mode, and RAM
-;	will go away, and ROM data will be returned instead, so the MMU will not be able to access
-;	the translation tables.
-
 			RESET									; ***** Reset The World *****
-@dontReset
-	ENDIF											; 														<SM52>
 
 ; <60>, check what WakeUp does, does it return here again after changing clock ?
 
@@ -1287,11 +1277,12 @@ StartBoot	MOVE	#$2700,SR						; Disable processor interrupts.
 			
 			BSR6	JumpIntoROM						; init the hardware
 	
-		IF hasPwrControls THEN						; If we're on a portable,
-			BigBSR6	PortableCheck					; check to see if we are coming out of sleep
-		ENDIF
-			BRA.L	StartTest1						; run new universal diagnostics
-StartInit1											; Jumped to from StartTest1. <C11>
+			MOVE	#$2600,SP						; make a small 9.5k stack (not used)
+			MOVEQ	#0,D7
+			MOVEQ	#0,D6
+			MOVE	#$11,D7
+			BSR6	SizeMemory						; (CDG5) previously called by StartTest1
+			MOVE.L	(SP),A6							; allocates fixed areas and returns table
 
 ;-----
 ;	here, after running the diagnostics, we have:
@@ -1367,12 +1358,7 @@ getHInfo	move.l	a6,-(sp)						; save regs												<SM44>
 			BSR		WhichCPU						; get CPU type in low word of d7
 			bsr		WhichBoard						; get logic board type in hi word of d7
 
-			btst.l	#hwCbMMU+16,d2					; HwCfgFlags in high word of d2
-			bne.s	@hasMMU							;  yes, InitMMU
-													;  no,  InitNonMMU
-			bsr		InitNonMMU						; init a4,a5,a6 for non MMU based machines
-			bra.s	@done
-
+			; (CDG5) do not bother with the no-mmu case any more
 @hasMMU		bsr.l	InitMMU							; generate MMU tables, enable MMU						<SM15>
 													; returns a4 -> BootGlobs
 			
@@ -1421,7 +1407,7 @@ getHInfo	move.l	a6,-(sp)						; save regs												<SM44>
 			LEA		HeapStart,A1					; A1 <- pointer to end of system globals.
 			BSR		FillWithOnes					; Fill system globals with ones.
 
-			BSR		InitRomVectors					; initialize ROM vectorization
+			BSR.L	InitRomVectors					; initialize ROM vectorization
 
 			MOVEM.L	(SP)+,D0-D6/A0-A1				; restore Universal info								<SM82>
 
@@ -1440,7 +1426,7 @@ getHInfo	move.l	a6,-(sp)						; save regs												<SM44>
 			MOVE.B	D7,CpuFlag						; save type of CPU we have
 			swap	d7								;
 
-			bsr		DynamicBoxFlag					; Calculate the Boxflag based on Family type and CPU speed <mc2>
+			; (CDG5) removed call to DynamicBoxFlag: we are always NewWorld
 			
 @StoreBox	move.b	d7,BoxFlag						; ... and save it in lomem
 
@@ -1448,119 +1434,15 @@ getHInfo	move.l	a6,-(sp)						; save regs												<SM44>
 			MOVE.L	A5,BufPtr						; save the top of useable memory
 			MOVE.L	A6,MemTop						;  and the top of available memory
 
-			; Here, we check to see if a special bit is set on PRAM, which tells us							<SM99> rb, start
-			; that the user want's his ROM to run from RAM for a slightly faster machine.
-			; We copy the ROM image into RAM and then re-initialize vectorization with the new RAM/ROM.
-	
-			IMPORT	PramIO
-			
-			MOVEM.L	D0-D6/A0-A4,-(SP)				; save Universal info
-			CLR.W	-(SP)							; make buffer space in stack for PRAM data
-			MOVE.L	SP,A3							; set buffer pointer
-			MOVE.L	#(0<<31)|\						; read PRAM command
-					 (1<<16)|\						; 1 byte please
-					 (11<<0),D3						; from address X
-			BSR.L	PramIO							; read PRAM
-			MOVE.W	(SP)+,D0						; get the byte read from PRAM
-			ANDI.W	#$0100,D0						; let's see if bit 1 was set in our byte
-			BEQ.W	NoROMinRAM						; if bit is clear, don't use RAM for the ROM <SM99>
-			
-			LEA		BaseOfRom,A0					; set source address
-			MOVE.L	A0,ROMBase						; save in ROMBase since it's not setup yet
-			MOVE.L	$40(A0),D3						; get the ROM size in D3
-			SUBA.L	D3,A5							; Subtract the ROM size from BufPtr
-			MOVE.L	A5,D0							; let's make sure A5 is aligned
-			ANDI.L	#$0000000F,D0					; mask up to 15 bytes of mis-alignement
-			SUBA.L	D0,A5							; and adjust A5 for 16 byte alignment
-			MOVE.L	A5,BufPtr						; and set the new BufPtr
-			MOVE.L	A5,A1							; set Destination address
-			
-			MOVE.L	D3,D0							; set count
-			MOVEQ.L	#16,D2							; set copy amount per loop (16 for non 040)
-			CMPI.B	#cpu68040,CPUFlag				; are we in an 040 ?
-			BNE.S	@CopyLongs						; if not, then copy longs only
-			MOVEQ.L	#32,D2							; set copy amount per loop
-			BRA.S	@Copy16							; do the copy thing, based on BlockMove040
-			NOP										; no warnings please
-			
-			ALIGN	16								; align with a cache line
-			MACHINE MC68040							; for move 16
-@Copy16
-			MOVE16	(A0)+,(A1)+						; copy 16 bytes
-			SUB.L	D2,D0							; decrement our count by 32 bytes
-			MOVE16	(A0)+,(A1)+						; copy another 16...
-			BHI.S	@Copy16							; and keep copying until we have 2 Meg
-			
-@JumpIntoRAM
-			LEA		InRAM,A0						; get our address in RAM (almost)
-			MOVE.L	ROMBase,D5						; save old ROMBase in D5								<SM104> rb
-			SUBA.L	ROMBase,A0						; get rid of the ROM offset
-			MOVE.L	BufPtr,A5						; get BufPtr (ROMBase soon) in a5
-			MOVE.L	A5,ROMBase						; set the new ROM base
-			ADDA.L	A0,A5							; add offset to InRAM routine
-			JMP		(A5)							; and go there !
-			NOP										; fill me in
-			
-@CopyLongs
-			MOVE.L	(A0)+,(A1)+						; copy 4 bytes
-			MOVE.L	(A0)+,(A1)+						; copy 8 bytes
-			MOVE.L	(A0)+,(A1)+						; copy 12 bytes
-			MOVE.L	(A0)+,(A1)+						; copy 16 bytes
-			SUB.L	D2,D0							; decrement our count by 16 bytes
-			BHI.S	@CopyLongs						; and copy more if nessesary
-			BRA.S	@JumpIntoRAM					; now jump into RAM
-			NOP										; just for the fun of it.
-			
-			ALIGN	16
-			
-InRAM
-			BSR		InitROMVectors					; re - initialize vectorization with new ROM addr
-			; Now that the ROM vectors have been re-initialized from RAM, the actual table entries still	<SM104> rb, start
-			; point to ROM since these were created at compile time.  So now we need to adjust every entry
-			; in the RAM copy of the tables so that it points to its RAM equivalent.  From then on
-			; InitROMVectors can be called and the RAM table entries will be used, as expected.
-			
-			MOVE.L	#$2010,D0						; get start address for ROM vector adjustments			
-			SUB.L	ROMBase,D5						; adjust our saved ROMBase, D5 is now the difference
-@WalkList	
-			MOVE.L	D0,A0							; get vector address in a0
-			MOVE.L	(A0),D1							; get the table address
-			CMPI.L	#-1,D1							; is it an empty table ?
-			BEQ.S	@NextTable						; if so, try the next table
-			
-			MOVE.L	D1,A1							; get the table address in a1
-			MOVE.L	(A1),A2							; get decription table in a2
-			MOVE.L	8(A2),D3						; get vector count for this table in D3
-			
-@AdjustEntry
-			SUB.L	D5,(A1)+						; adjust this entry so it points in the RAM copy of ROM
-			DBRA	D3,@AdjustEntry					; fix all entries in this table
-			
-@NextTable	
-			ADDI.L	#4,D0							; add offset to next vector address
-			CMPI.L	#$2104,D0						; have we reached the current limit ?
-			BNE.S	@WalkList						; if not the limit, keep looking
-			
-			SUB.L	D5,UnivInfoPtr					; adjust the info record so int handlers are in RAM		<SM108> rb
-			
-NoROMinRAM											;														<SM104> rb, end
-			MOVEM.L	(SP)+,D0-D6/A0-A4				; restore Universal info
-													; DONE, WE ARE RUNNING FROM A RAM COPY OF ROM			<SM99> rb, end
+			; (CDG5) no copy-ROM-to-RAM code: NewWorld ROM is always in RAM,
+			; but the UnivInfoPtr reload below may have been kept just to be safe
 			move.l	UnivInfoPtr,a1					; reload a1 in case the info record was adjusted in RAM	<SM108> rb
 			
 			bsr		SetupHWBases					; setup the hardware base address low mems
 
 			BSR		InitSCC							; init the SCC
 
-			move.w	d2,-(sp)						; save D2 around this call								<T28>
-			BSR		InitIWM
-			move.w	(sp)+,d2						; restore D2											<T28>
-
-		IF NOT hasAsyncSCSI THEN	; we do HW init later with new SCSI Manager
-			bsr.l	InitSCSIHw						;
-		ENDIF
-		
-			BSR.L	InitSndHW						; go initialize the sound hardware
+			; (CDG5) no InitIWM, legacy InitSCSIHw or InitSndHW needed for NewWorld
 
 			bsr.l	InitMMUGlobals					; set up MMU globals
 
@@ -1584,13 +1466,7 @@ NoROMinRAM											;														<SM104> rb, end
 	IF forRomulator THEN
 			Moveq.l	#$0,D0							; Set up to disable the caches if we’re debugging.
 	ELSE
-			cmp.b	#cpu68040,CpuFlag				; check if we're on an 040
-			bne.s	@not040							; NO  ... enable 020/030 cache(s)
-
-			move.l	#(1<<CACR_IE_040),d0			; YES ... turn on IE		  
-			Ori.l	#(1<<CACR_DE_040),D0			; and the DE.
-			bra.s	@EEC							; enable any external caches (?)
-@not040
+			; (CDG5) removed runtime check for 68040 cache
 			MOVE.L	#(1<<CACR_EI_020_030|\			; WA=1, DBE=1, CD=1, ED=1, IBE=1, CI=1, EI=1
 					  1<<CACR_CI_020_030|\			;
 					  1<<CACR_IBE_030|\				;
@@ -1643,7 +1519,6 @@ BootRetry	MOVE	#$2700,SR						; disable interrupts
 			MOVE.L	A0,SP							; Set the stack pointer there
 			SUBA.W	#BootStackSize,A0				; Give ourselves some stack space
 
-			BSET.B	#MMStartMode,MMFlags			; set for 32 bit system heap
 			_SetApplLimit							; Don't let the System Heap crash our stack
 
 			BSR.L	InitMemoryDispatch				; go set up the MemoryDispatch globals
@@ -1658,15 +1533,16 @@ BootRetry	MOVE	#$2700,SR						; disable interrupts
 			Move.l	#emRecSize,(a0)					; size													<SM40>
 			ENDWITH									;														<SM40>
 
+			BSR.L	MoveUnivInfoToSysHeap			; (CDG5) UnivInfo generated by OF bootloader
+			BSR.L	initGestalt						; (CDG5) initialize Gestalt much earlier than before
+			BSR.L	CreateAltiVecBufForEmulator		; (CDG5) VRSAVE buffer?
+
 			BSR.L	InitIntHandler					; initialize interrupt vectors and dispatch tables
-			BSR.L	InstallPrivTrap					; setup FPPriv if there's an FPU						<T15>
-
-			BSR.L	InitPmgrVars					; initialize Power Manager variables if on a portable	<T10>
-													; (otherwise disable all of its traps)
 
 			BSR		CheckForEgretOrCuda				; Do we have an Egret/Caboose/Cuda?						<mc2>
 			BNE.S	@EInitDone						; -> Nope, don't be callin' shit
 			BSR.L	InitEgretOrCuda					; Initialize Egret or Cuda Manager
+			BSR.L	GestaltCudaFunc					; (CDG5) part of Gestalt
 @EInitDone
 
 
@@ -1680,17 +1556,45 @@ BootRetry	MOVE	#$2700,SR						; disable interrupts
 *************************************************************************************************
 
 			
-			BSR		InitSwitcherTable				; initialize Switcher's table (do we still need this?)
+			; (CDG5) removed InitSwitcherTable (that's a table of lowmem global locations)
 
-			BSR		GetPRAM							; get 20 bytes PRAM, and TIME
-			BSR		SetPRAM32						; Always set PRAM to 32bit								<SM50><SM62>
 			BSR.L	InitRSRCMgr						; initialize the Resource Manager
 			BSR.L	NMInit							; Initialize the Notification Manager
-			BSR.L	InitTimeMgr						; Initialize the Time Manager
 		
 			CLR.W	-(SP)							; pass the INIT message to ShutDown
 			_ShutDown								;  to initialize the queue
 
+			BSR.L	InitExpMgrVars					; (CDG5) Expansion Mgr needs GoNative, so bring it up now
+	CASE	ON
+	IMPORT 	GoNative
+		BSR.L	GoNative							; Load all those NCODs!
+	CASE	OFF
+		BPL.S	@noPower							; -> No errors.  Keep booting							<SM132> SAM
+		MOVE.W	#dsGNLoadFail,D0					; Fatal GoNative load error.							
+		_SysError									; Put up a dialog and die.
+@noPower
+			BSR.L	CodeRegister					; (CDG5) these are all related
+			BSR.L	CodePrepare
+			BSR.L	ExpansionBusMgrFirstFunc
+
+			BSR.L	CompBootStackOld				; (CDG5) now we need a better stack and heap
+			MOVE.L	A0,SP
+			SUBA.W	#BootStackSize,A0
+			_SetApplLimit
+
+			BSR		InitSystemExperts				; (CDG5) searches the System file for 'expt' resources
+
+			CLR.L	-(SP)							; who wrote this?
+			MOVE.L	(SP)+,PmgrBase
+			MOVE.L	ToolScratch,-(SP)
+			LEA.L	SetUpTimeK,A0
+			MOVE.L	A0,ToolScratch
+			BSR		InitNativePowerMgr				; (CDG5) NativePowerMgrLib: PMInitialize
+			BSR.L	InitEtherPrintfLib				; (CDG5) packaged as Trampoline Parcel -- for debugging?
+			MOVE.L	(SP)+,ToolScratch
+
+			BSR		GetPRAM							; (CDG5 moved) get 20 bytes PRAM, and TIME
+
 			BSR		InitSlots						; inits slot cards, grays the screen(s)
 
 			BSR.L	InitDTQueue						; initialize the Deferred Task Manager Queue
@@ -1708,7 +1612,10 @@ BootRetry	MOVE	#$2700,SR						; disable interrupts
 ; Gestalt must now be initialized before IO drivers															<SM39>																<SM39> RLM
 ;------------------------------------------------------------------------									<SM39>
 
-			BSR.L	initGestalt						; initialize Gestalt									<SM39>
+			; (CDG5) Gestalt has actually moved up a few steps
+
+			BSR.L	RSetKMap						; (CDG5) ADB routine, used to be called at PwrMgr wakeup
+			BSR.L	DebugInit						; (CDG5) part of PPC Debugger Nub
 
 			moveq	#10,D0
 			_NewHandle	,Sys,Clear					; Get space for a Heap utilities list
@@ -1717,52 +1624,56 @@ BootRetry	MOVE	#$2700,SR						; disable interrupts
 			move.l	D0,$1E0C						; Stuff it in the magic location
 @noHU
 			
-			Cmpi.b	#cpu68040,CPUFlag				; Are we less than an 040?								<T7><SM9>
-			Blo.s	@no040BM						; Yes? Then use original BlockMove.						<T7><SM9>
-			Move.w	#$A02E,D0						; BlockMove trap.										<T7><SM9>
-			BigLea	BlockMove68040,A0				; New routine.											<T7><SM9>
-			_SetTrapAddress							; Set new routine.										<T7><SM9>
+			; (CDG5) a special 68040 BlockMove used to get installed here
 @no040BM
 
 ;—————————————————————————————————————————————————————————————————————	<SM101> SAM
 ; Install Code Fragment Mangaer (GoNative)								<tcn>
 ;—————————————————————————————————————————————————————————————————————
 
-			MOVE.L	#gestaltSysArchitecture,d0		; Are we running on a PowerPC machine?					<SM101> SAM
-			_Gestalt
-			BNE.S	@NoPower						; Error, assume 68k
-			CMP.W	#gestaltPowerPC,A0				; PowerPC?
-			BNE.S	@NoPower						; -> Nope, assume 68k
-			
-		CASE	ON
-		IMPORT 	GoNative
-			BSR.L	GoNative						; Load all those NCODs!
-		CASE	OFF
-			BPL.S	@noPower						; -> No errors.  Keep booting							<SM132> SAM
-			
-			MOVE.W	#dsGNLoadFail,D0				; Fatal GoNative load error.							
-			_SysError								; Put up a dialog and die.
-@noPower
+			; (CDG5) nope, GoNative gets installed much earlier
+
+			BSR.L	INSTALLBASSCOMMON				; Init Bass before anyone calls _InitFonts (like _InitGraf) <SM112>
+			BSR.L	FORCEINITFONTSCALL				; More Bass init stuff										<SM112>
+
+			BSR		InitCrsrMgrMiddle
+			BSR.L	InitCrsrDev						; initialize Cursor globals								<H9>
+													; (InitCrsrDev must preceed InitADB)
 
 ;----------------------------------------------------------------
 ; Install Drivers (Disk, Sound, Video).
 ;----------------------------------------------------------------
 
+			SUBQ	#2,SP							; (CDG5) init Display Manager
+			MOVEQ.L	#-1,D0							; >hides the nanokernel log until QD comes up
+			_DisplayDispatch
+			ADDQ	#2,SP
+
 			LEA 	DrvQHdr, A1 					; Initialize the drive queue.
 			BSR.L 	InitQueue
 
-			BSR		InitIOPStuff					;
 			BSR 	InitDeviceMgr					; Init unit I/O table and install the drivers.
-			BSR		LoadDrivers						; load the standard drivers
 
+			BSR.L	InitDeviceDispatch				; (CDG5) trap AA6A, function unclear
+
+			BTST.B	#$6, ($2400)
+			BNE.B	@definitely
+			BTst.B	#$0, ($DD0)
+			BEQ.B	@dont
+@definitely
+
+			BSR		SetScsiIdFromPram				; taken from SCSIMgrInit.a
 			BSR.L	InitSCSIMgr						; Init old and new SCSI Mgrs
+@dont
+			
+			BSR.L	InitExpansionMgr				; (CDG5) manager poorly understood
 
-			BSR.L	INSTALLBASSCOMMON				; Init Bass before anyone calls _InitFonts (like _InitGraf) <SM112>
-			BSR.L	FORCEINITFONTSCALL				; More Bass init stuff										<SM112>
+			BSR.L	SearchDrivers					; (CDG5)
+
+			BSR		LoadDrivers						; load the standard drivers
 
-			BSR.L	InitCrsrDev						; initialize Cursor globals								<H9>
-													; (InitCrsrDev must preceed InitADB)
 			BSR.L	InitADB							; initialize ADB interface
+			BSR.L	InitUSB							; (CDG5) self-evident
 
 			BSR		InitCrsrMgr						; Initialize cursor variables
 
@@ -1770,13 +1681,9 @@ BootRetry	MOVE	#$2700,SR						; disable interrupts
 ; Initialize Reliability Manager
 ;----------------------------------------------------------------
 
-			BSR.L	InitReliability					; initialize the Reliability Manager
+; (CDG5) No, don't init the Reliability Manager
 
-			BSR		CheckForEgretOrCuda				; call check routine									<T2>
-			BNE.S	@NoEgret						; Egret not installed
-			BSR.L	EgretDFACandPDM					; install additional Egret features						<SM16>
-@NoEgret
-			BSR		CheckForResetPRAM				; see if PRAM needs to be nuked
+			BSR.L	InitBCScreen					; (CDG5) BCScreen == geometry control?
 
 			BSR.L	TEGlobalInit					; initialize TextEdit vectors
 
@@ -1814,11 +1721,7 @@ BootRetry	MOVE	#$2700,SR						; disable interrupts
 			BSR		DrawBeepScreen					; Horst Beepmanh’s patented gray screen
 			
 ; On machines with Civic, check to see if we want to boot off the composite out      						<SM63>
-
-			TestFor	CivicExists
-			Beq.s	@NoCivic						; don't do it for Non-Civic Based cpu's
-			bsr		CheckForTV						; see if we need to set the "Drive CompOut Flag"
-@NoCivic
+; (CDG5) no "Civic" composite video output
 			
 			MOVE.L	#WmStConst,WarmStart			; write warm start constant to indicate warm start
 
@@ -1830,40 +1733,40 @@ BootRetry	MOVE	#$2700,SR						; disable interrupts
 ; Initialize the Sound Manager
 ;----------------------------------------------------------------
 
-			MOVEM.L	A0-A2/A6/D0-D2,-(SP)			; save our important Address
-
-			case	obj
-			import	InitSoundMgr
-			bsr.l	InitSoundMgr
-			case	off
-
-			MOVEM.L	(SP)+,A0-A2/A6/D0-D2			; restore our important Address
+; (CDG5) Sound Manager ripped out
 
 
 ;----------------------------------------------------------------
 ; Initialize the File System.
 ;----------------------------------------------------------------
 
+			BSR.L	InitFireWire					; (CDG5) last chance to boot from FW?
 			MOVE	#40,D0							; Inital number of file control blocks
 			_InitFS
 
+			BTST	#$1, $2409
+			BEQ.B	@dont_do_mysterious_thing
+			BSR.L	LoadPCCardLib
+@dont_do_mysterious_thing
+
 ;----------------------------------------------------------------
 ; <65>, Other Terror changes...
 ;----------------------------------------------------------------
 
-			BSR.L	SetupDockBases					; initialize docking bar base addresses					<H3><SM16>
-*			BSR.L	SCSIDiskMode					; check if we should be in SCSI Disk Mode				<SM16>
+	BSR.L	CheckSCSITargetCapable
 
-		IF hasAsyncSCSI THEN						; <SM162> \/  
-			BSR.L	ISITT							; check if we're running SCSI 4.3
-			TST.B	D0								; are we?
-			BEQ.S	@noAsyncSCSI					; -> no, don't don't initialize for new
-													; 	 style boot.
+	BTst.B	#5, $2408
+	BEQ.B	@nodiskmode
+			BSR.L	SCSIDiskMode					; check if we should be in SCSI Disk Mode				<SM16>
+@nodiskmode
+	
 			BSR.L	INITSCSIBOOT					; allocate some memory for SCSI booting
 													; and load third party SIMs (SCSI Interface
 													; modules
-@noAsyncSCSI
-			ENDIF									; <SM162> /\   
+
+			BSR.L	InitATAMgr						; (CDG5) unclear workings
+			BSR.L	FindATADevices
+			BSR		InitStorage
 
 
 *************************************************************************************************
@@ -1953,58 +1856,8 @@ BootRetry	MOVE	#$2700,SR						; disable interrupts
 ;________________________________________________________________________________________
 
 WhichCPU
-			MACHINE	MC68020
-
-			moveq.l	#2,d7							; setup index to see if index scaling works
-			jmp		@CheckIndexScale-2(d7.w*2)		; decide if scaling works
-
-@CheckIndexScale
-			bra.s	@NoIndexScale					; 68000/68010 don't have index scaling
-
-@HasIndexScale										; 68020/68030/68040 do have index scaling
-			sub.l	d7,d7							; D7 = 0 (testing for 040)
-
-			bset	#CACR_DE_040,d7					; set DE (data cache enable) in CACR
-			movec	d7,CACR							; enable data cache
-			movec	CACR,d7							; IF CACR != 0 THEN we're on an 040
-			bclr	#CACR_DE_040,d7					; see if the bit exists in CACR
-			movec	d7,CACR							; put it back in cache reg
-			beq.s	@notAn040						; NO  ... check for 020/030
-
-			MACHINE	MC68040							; YES ... needed to execute a 040 CINVA inst.
-
-			cinva	bc								; invalidate both caches, dont push data from d-cache
-													; NOTE - I-cache is still enabled here
-			moveq	#cpu68040,d7					; return that we're running on an 040
-			rts
-
-			MACHINE	MC68020
-@notAn040
-			move.w	#(1<<CACR_EI_020_030|\			; set EI, (enable inst. cache)
-					  1<<CACR_CI_020_030|\			;     CI, (flush inst cache)
-					  1<<CACR_CD_030|\				;     CD, (flush data cache)
-					  1<<CACR_WA_030),d7			; ... in 020/030 CACR
-			movec.l	d7,cacr							; and go for it
-			movec.l	cacr,d7							; read back the actual CACR
-			lsl.w	#3,d7							; ccr.x := write allocate bit (68030 only)
-			moveq.l	#2>>1,d7						; setup to shift in ccr.x
-			addx.l	d7,d7							; d7 := 2 if 68020, d7 := 3 if 68030
-			rts										; all done
-
-@NoIndexScale										; 68000/68010 don't have index scaling
-			move.l	sp,d7							; mark the stack
-			clr.w	-(sp)							; fake a 68010 exception format word
-			bsr.s	@doRTE							; push a return address, sr, and RTE back
-			exg.l	d7,sp							; restore the stack
-			sub.l	sp,d7							; d7 := -2 if 68000, d7 := 0 if 68010
-			addq.l	#2,d7							; d7 :=  0 if 68000, d7 := 2 if 68010
-			lsr.l	#1,d7							; d7 :=  0 if 68000, d7 := 1 if 68010
-			rts										; all done
-
-@doRTE		move.w	sr,-(sp)						; push the SR to complete exception frame
-			rte										; pop the exception frame and return
-
-			SETMACHINE
+			moveq.l	#2,d7							; (CDG5) always return 68020 on PowerPC
+			rts										; (CDG5) no check
 
 
 ;________________________________________________________________________________________
@@ -2048,61 +1901,56 @@ WhichBoard	swap	d7								; get CPU type in hi word
 ;________________________________________________________________________________________
 
 SetUpTimeK	
-			cmpi.b	#cpu68040,CPUFlag		; check if running on one of those nasty 040s
-			blt.s	@doIt
+		   MoveM.L   D1-D2/A1-A4, -(A7)
+		   Move      SR, -(A7)
+		   OrI       #$700, SR
+		   Move.L    ($64), -(A7)
+		   BTst.B    #$6, ($2400)
+		   BNE.B     L8
+		   BTst.B    #$1, ($2400)
+		   BNE       L12
+		   Bra       L13
+L8:        MoveQ.L   #$0, D0
+		   Move      ([$68FFEFD0.L],$80), D0
 
-;	If we are 040'ish, check if the Cache Switch has requested to disable processor
-;	caches.  The Cache Switch CDEV sets PRAM location $8A bit 7 if caches will be
-;	disabled.  We are taking the initiative here and THIS is the place we will turn
-;	OFF caches for the duration.  We want to make sure that we do this BEFORE we
-;	calculate the timing values, as they will change depending on whether caches are
-;	on or off.
+		   MoveM.L   D0-D2/A0, -(A7)
+		   MoveA.L   ([$68FFEFD0.L],$18), A0
 
-			movem.l	d0-d3/a0-a3,-(sp)		; save registers before mucking around				<H22>
-			move.l	UnivInfoPtr,a1			; retrieve ProductInfo record pointer				<H22>
-			move.l	a1,a2					; leave A1 alone - call the routine with A2			<H22>
-			move.l	a1,a0					; leave A1 alone - get pointer in A0 for call		<H23>
-			adda.l	ProductInfo.ClockPRAMPtr(a2),a2; get pointer to primitives table			<H22>
-			move.l	4*cpXPRAMIO(a2),d0		; get the offset to the routine						<H22>
-			beq.s	@restore				; if no trap-less routine, then run with caches ON	<H22>
-			add.l	ProductInfo.DecoderInfoPtr(a1),a0; required for the PramIO call				<H23>
-			adda.l	d0,a2					; form trapless _ReadXPram subroutine address		<H22>
-			clr.w	-(sp)					; make room on the stack
-			movea.l	sp,a3					; set up for call to _ReadXPRam						<H22>
-			move.l	UnivROMFlags,d1			; D1, A0, A1, A3 need to set for StandardXPramIO	<H22>
-			move.l	#$0001008A,d3			; 1 byte at $8A
-			jsr		(a2)					; dont have traps yet. go there directly			<H22>
-			move.w	(sp)+,d0				; get the byte
-			tst.w	d0						; check if top bit is set
-			bpl.s	@restore				; top bit not set - run with caches on
+		   Tst.L     A0
+		   BNE.B     L10
+		   MoveA.L   ([$68FFEFF0.L],$100), A0
 
-			MACHINE	MC68040
-			CPUSHA	BC						; make sure return addresses make it to memory
-			MACHINE	MC68020
-
-			moveq.l	#0,d0
-			movec	d0,CACR					; turn OFF all caches
-@restore
-			movem.l	(sp)+,d0-d3/a0-a3		; restore registers after mucking around			<H22>
-@doit		
-			move.l	AutoInt1,-(sp)					; Save current auto interrupt vector.
-			move.w	sr,-(sp)						; Save current interrupt level.
-			ori.w	#HiIntMask,sr					; disable interrupts
-
-			TestFor	GrandCentralExists				; Do we have a Grand Central
-			beq.b	@viaIntsEnabled					; Nope, so carry on
-			movea.l	UnivInfoPtr,a0					; Get the GC base address from
-			adda.l	ProductInfo.DecoderInfoPtr(a0),a0	; the universal info
-			movea.l	DecoderInfo.GrandCentralAddr(a0),a0	; and then
-			ori.l	#1<<gcifDevVia,gcInterruptMask(a0)	; enable Lvl 1 interrupts
-@viaIntsEnabled
-			movea.l	VIA,a1							; Point to the VIA.
+		   Move.L    #$80000000, D1
+		   CmpI.L    #$1F, D0
+		   BGT.B     L9
+		   ROR.L     D0, D1
+		   Or.L      D1, $14(A0)
+		eieioSTP
+		   Bra       L11
+L9:        SubI.L    #$20, D0
+		   ROR.L     D0, D1
+		   Or.L      D1, $4(A0)
 		eieioSTP
-			bclr.b	#5,vACR(a1)						; Set Timer 2 to Timed Interrupt mode.
+		   Bra       L11
+L10:       AddA.L    #$10000, A0
+		   LsL.L     #$5, D0
+		   Move.L    $0(A0,D0.W), D1
+		   BClr.L    #$7, D1
+		   Move.L    D1, $0(A0,D0.W)
+		eieioSTP
+L11:       MoveM.L   (A7)+, D0-D2/A0
+		   Bra.B     L13
+L12:       MoveA.L   ($DD8), A0
+		   AddA.L    (A0), A0
+		   MoveA.L   $E4(A0), A0
+		   OrI.L     #$400, $24(A0)
+
+L13:       MoveA.L   ($1D4), A1
+		   BClr.B    #$5, $1600(A1)
 		eieioSTP
-			move.b	#$FF,vT2CH(a1)					; Make sure timer won't accidentally trigger.
+		   Move.B    #$FF, $1200(A1)
 		eieioSTP
-			move.b	#(1<<ifIRQ)+(1<<ifT2),vIER(a1)	; Enable Timer 2 interrupts.
+		   Move.B    #$A0, $1C00(A1)
 		eieioSTP
 
 ;	Load timer with number of VIA ticks per millisecond - 3.  There are 3 clocks of overhead
@@ -2131,15 +1979,26 @@ SetUpTimeK
 			andi.w	#$F8FF,sr						; enable interrupts
 			jmp		(a0)							; call the routine to time
 @timedOut	not.w	d0								; convert to number of loop executions.
+
+			bne.s	@skip_the_thing
+			move.w	#$ffff, d0
+@skip_the_thing
+
 			movea.w	(a4)+,a0						; get the address of the lowmem
 			move.w	d0,(a0)							; store the result
+
+			btst	#6,$2400          
+			beq.b	@dont
+			MOVE.B   ([$68FFEFD0],$0083),([$68FFEFD0],$008D) ; VIAIntBit+1 -> CompletedInts+1
+@dont
+
 			tst.w	(a4)							; see if any more routines to time
 			bne.s	@nextRoutine					; time all routines in the table
-		eieioSTP
 			move.b	#(0<<ifIRQ)+(1<<ifT2),vIER(a1)	; Disable Timer 2 interrupts.
 		eieioSTP
-			move.w	(sp)+,sr						; Restore previous interrupt level.
-			move.l	(sp)+,AutoInt1					; Restore previous auto interrupt vector.
+			MOVE.L   (A7)+,$0064
+			MOVE     (A7)+,SR
+			MOVEM.L  (A7)+,D1/D2/A1-A4 
 			rts
 
 TimerInt	nop
@@ -2156,11 +2015,8 @@ TimingTable	dc.w	DbraTime-*,TimeDBRA				; simple DBRA loop timing
 
 
 DbraTime	
-		eieioSTP
 			move.b	d1,vT2C(A1)						; load low order byte
-		eieioSTP
 			move.b	d2,vT2CH(A1)					; load high order byte & go.
-		eieioSTP
 @loop		
 			dbra	d0,@loop						; time an empty DBRA loop
 			jmp		(a2)							; return if loop expires
@@ -2168,23 +2024,35 @@ DbraTime
 
 SCCTime		
 			movea.l	SCCRd,a0						; point to SCC base read address
-		eieioSTP
 			move.b	d1,vT2C(A1)						; load low order byte
-		eieioSTP
 			move.b	d2,vT2CH(A1)					; load high order byte & go.
-		eieioSTP
 @loop		
-			btst.b	#0,(A0)							; typical SCC access
-			dbra	d0,@loop						; time the SCC DBRA loop
+			btst.b	#3,$DD3
+			bne.s	@differentloop
+			dbra	d0,*							; time the SCC DBRA loop
 			jmp		(a2)							; return if loop expires
+@differentloop
+			btst.b	#0,(a0)
+			dbra	d0,@differentloop
+			jmp		(a2)
 
 
 SCSITime	
+			TestFor	SCSI96_1Exists
+			bne.s	@normalTest
+
+			btst.b	#6, $2400
+			beq.s	@normalTest
+
+			move.b	d1, vT2C(a1)					; load low order byte
+			move.b	d2, vT2CH(a1)					; load high order byte & go.
+			dbra	d0, *
+			jmp		(a2)
+
+@normalTest
 			movea.l	SCSIBase,a0						; point to SCSI base address
 			move.b	d1, vT2C(a1)					; load low order byte
-		eieioSTP
 			move.b	d2, vT2CH(a1)					; load high order byte & go.
-		eieioSTP
 			TestFor	SCSI96_1Exists					; use macro to check if we have
 			beq.s	@loop80							;   SCSI96. Bra. if not
 @loop96		
@@ -2239,11 +2107,8 @@ SCSITime
 
 VIATime		
 			lea		vIER(a1),a0						; <40x008BC> point to a VIA register					<H11>
-		eieioSTP
 			move.b	d1,vT2C(A1)						; <40x008C0> load low order byte						<H11>
-		eieioSTP
 			move.b	d2,vT2CH(A1)					; <40x008C4> load high order byte & go.					<H11>
-		eieioSTP
 @loop		
 			btst.b	#0,(A0)							; <40x008CA> typical VIA access loop					<H11>
 			dbra	d0,@loop						; <40x008CE> time the VIA DBRA loop						<H11>
@@ -2312,13 +2177,20 @@ FillWithOnes
 ;________________________________________________________________________________________
 
 CompBootStack
+			btst	#$06,$240B
+			beq.s	CompBootStackOld
+			move.l	#$007EFFE0,A0					; 8 M - 64 K - 32 b
+			rts
+
+CompBootStackOld
 			move.l	BufPtr,d0						; get top useable memory
 			move.l	sysZone,a0						; get start system heap
 			sub.l	a0,d0							; get (top useable - sys heap start)
 			lsr.l	#1,d0							; divide by two
-			andi.w	#$FFFE,d0						; force it to be even									<SM81>
-			add.l	d0,a0							; get sys heap + (top - sysHeap)/2
-			suba.w	#BootGlobalsSize,a0				; leave room for QuickDraw stuff.
+			add.l	a0,d0							; get sys heap + (top - sysHeap)/2
+			sub.w	#BootGlobalsSize,d0				; leave room for QuickDraw stuff.
+			andi.w	#$FFF0,d0						; force it to be even									<SM81>
+			move.l	d0,a0
 			rts
 
 
@@ -2406,17 +2278,6 @@ ConfigureRAM
 SetUpSysAppZone
 			lea 	SysHeap,a0						; point at normal system heap template
 
-			move.b	MMFlags,-(sp)					; save the memory Manager flag
-			btst.b	#MMSysHeap,MMFlags				; check type of System Heap
-			beq.s	@do24							; IF we want a 32 bit heap
-			bset.b	#MMStartMode,MMFlags			;   set for 32 bit system heap
-			btst.b	#mmHighSysHeap,MMFlags			;   check for the 'black hole'
-			beq.s	@knowHeap						;   IF we have 'black hole' between lowmem & sysHeap
-			lea		SysHoleHeap,a0					;     get addr 'black hole' zone template
-			bra.s	@knowHeap						;   ENDIF
-@do24		bclr.b	#MMStartMode,MMFlags			;   set for 24 bit system heap
-@knowHeap											; ENDIF
-
 			_InitZone								; set up initial system heap
 			Move.L	theZone,SysZone 				; save pointer to the new zone
 			Move.L	SysZone,RamBase					; setup RamBase to system heap
@@ -2435,189 +2296,27 @@ SetUpSysAppZone
 			MOVE.L	SP,A0							; Use the current sp when it’s lower
 @3			SUBA.W	#BootStackSize,A0				; Give ourselves some stack space
 			_SetApplLimit							; Don't let the System Heap crash our stack
-			MOVE.B	(SP)+,MMFlags					; restore memory manager flag
-			
-			_MoreMasters							; Create 768 master pointers at the bottom of			<SM132> SAM
-			_MoreMasters							; the heap.  This is approximately the number of
-			_MoreMasters							; relocatable objects in the system heap for
-			_MoreMasters							; System 7.1 and a set of standard inits.
-			_MoreMasters							; (We need 6 calls to MoreMasters to get 768 of them.
-													; _InitZone will create one block of "4*dfltMasters"
-			RTS										; MPs for us.)
+
+			move.l	d3,-(sp)
+			moveq.l	#2,d3
+@trap_blk
+			_MoreMasters
+			_MoreMasters
+			_MoreMasters
+			_MoreMasters
+			_MoreMasters
+			_MoreMasters
+			_MoreMasters
+			_MoreMasters
+			dbf		d3,@trap_blk
+			move.l	(sp)+,d3
+			rts
 
 SysHeap		DC.L	HeapStart
 			DC.L	HeapStart+SysZoneSize
 			DC.W	4*dfltMasters					; Master Pointer allocation size = 128 (MPs)
 			DC.L	0
 
-SysHoleHeap	dc.l	HoleSysHeap						; start address
-			dc.l	HoleSysHeap+SysZoneSize			; size
-			dc.w	2*dfltMasters					; # master ptrs
-			dc.l	0								; no growzone proc
-
-
-;________________________________________________________________________________________
-;
-; Routine:	CheckForResetPRAM
-;
-; Inputs:	none
-; Outputs:	none
-; Trashes:	D0, A0, A1
-;
-; Function:	if the cmd-option-R-P keys are down, it resets PRAM and then reboots the machine
-;
-; If the byte 76 contains a value of 2 in it then some of the PRAM information will be saved.
-; If the value is any other value (0,1,3) then the value will be set to zero.
-; The information which is saved is:
-;	all PassWord information (address/size)
-;								04/04		PSWD
-;								0E/02		pswd checksum and flags
-;								AB/03		PSWD
-;	All AUX information			40/06		A/UX
-;	Sensitive Boot Parms		76/01		Reserved for StartMgr
-;	Default OS Type				77/01		Default OS
-;	Default Boot Device			78/04		Default Boot Device
-;________________________________________________________________________________________
-
-CheckForResetPRAM
-
-ck4rpRegs	REG		D1-D2
-
-; hi-byte == size, lo-byte == address
-PSWDPRAM	equ		$00040004						; 4 bytes at password location $04
-PSWDChkFlg	equ		$0002000E						; 2 bytes at password location $0E ($0E = Checksum, $0F = Flags)
-AUXPRAM		equ		$00060040						; 6 bytes at A/UX location $40
-OSTypePRAM	equ		$00020076						; 2 bytes at Default OS $76 ($76 = reserved/save PRAM or not, $77 = Default OS)
-ClearPRAM	equ		$00010076						; 1 byte at reserved byte (used if value is 1 or 3)
-DefBoot		equ		$00040078						; 4 bytes at Default Boot Device $78
-PSWDspace	equ		$000400AB						; 4 bytes at password location $AB (only use 3, but I alocate 4 on the stack)
-PSWDmore	equ		$000300AB						; the actual 3 bytes which I use at location $AB
-
-			movem.l	ck4rpRegs, -(sp)				;					<SM139> \/ \/ \/
-			
-			bsr		Ck4LimitPRAMClear				; supposed to allow bypassing security with reset?
-			sne		D2								; D2=true if limit clear
-													;					<SM139> /\ /\ /\
-			lea		@Keys,a1						; keys to check for
-			lea		KeyMap,a0						; compare to the Key Down Map
-			moveq.l	#4-1,d0							; compare loop count
-@loop		cmpm.l	(a0)+,(a1)+						; check for exactly this combo
-			dbne	d0,@loop						; examine the entire key map
-			bne.s	@noMatch						; if not equal, don't reset PRAM
-			
-			tst.b	D2
-			beq.s	@normNuke
-			bra.s	@savesome
-@noMatch
-			movem.l	(sp)+, ck4rpRegs
-			rts										; otherwise, just return
-
-
-; \/ \/ \/ \/  Save security-related items (mainly for AIX)				<SM138> thru next
-
-@savesome
-			subq.w	#PSWDPRAM>>16,sp				; allocate buffer on stack
-			movea.l	sp,a0							; get buffer ptr
-			move.l	#PSWDPRAM,d0					; get #, addr PRAM bytes
-			_ReadXPram								; read the PSWD info
-			
-			subq.w	#PSWDChkFlg>>16,sp				; 
-			movea.l	sp,a0							; 
-			move.l	#PSWDChkFlg,d0					; 
-			_ReadXPram								; read the PSWD checksum & Flags
-			
-			subq.w	#PSWDspace>>16,sp				; 
-			movea.l	sp,a0							; 
-			move.l	#PSWDmore,d0					; 
-			_ReadXPram								; read the PSWD info
-
-			subq.w	#AUXPRAM>>16,sp					; 
-			movea.l	sp,a0							; 
-			move.l	#AUXPRAM,d0						; 
-			_ReadXPram								; read the AUX info
-			
-			subq.w	#OSTypePRAM>>16,sp				; 
-			movea.l	sp,a0							; 
-			move.l	#OSTypePRAM,d0					; 
-			_ReadXPram								; read the Default OS
-			
-			subq.w	#DefBoot>>16,sp					; 
-			movea.l	sp,a0							; 
-			move.l	#DefBoot,d0						; 
-			_ReadXPram								; read the Default Boot Device
-			
-; /\ /\ /\ /\  															<SM138> from prev
-
-@normNuke	subq.w	#RelPram>>16,sp					; 
-			movea.l	sp,a0							; 
-			move.l	#RelPram,d0						; 
-			_ReadXPram								; read the reliability MGR info
-			
-		; kill signatures in extended and old PRAM so that InitUtil writes default values out
-
-			movea.l	a1,a0							; point to table data
-			move.l	(a0)+,d0						; get PRAM len/addr, point to data
-			_WriteXPRam								; kill the extended PRAM signature
-			lea		SysParam,a0						; standard PRAM buffer address
-			moveq.l	#-1,d0							; mask/data to write
-			move.b	d0,(a0)							; kill the signature in the buffer
-			_WriteParam								; write the buffer to PRAM
-			
-			_InitUtil								; Init PRAM
-			
-			movea.l	sp,a0							; 
-			move.l	#RelPram,d0						; 
-			_WriteXPram								; restore the reliability MGR info
-			adda.w	#RelPram>>16,sp					; clean up the stack
-
-			tst.b	D2								; flag set telling us not to clear everything?	<SM139>
-			beq.s	@normNuke3						; no-> don't restore them (we didn't save them earlier)
-			
-; \/ \/ \/ \/  Restore security-related items							<SM138> thru next
-
-			movea.l	sp,a0							; get buffer ptr
-			move.l	#DefBoot,d0						; get #, addr PRAM bytes
-			_WriteXPram								; restore the Default Boot Device
-			adda.w	#DefBoot>>16,sp					; clean up the stack
-			
-			movea.l	sp,a0							; 
-			move.l	#OSTypePRAM,d0					; 
-			_WriteXPram								; restore the Default clean of OS
-			adda.w	#OSTypePRAM>>16,sp				; 
-			
-			movea.l	sp,a0							; 
-			move.l	#AUXPRAM,d0						; 
-			_WriteXPram								; restore the AUX info
-			adda.w	#AUXPRAM>>16,sp					; 
-			
-			movea.l	sp,a0							; 
-			move.l	#PSWDmore,d0					; 
-			_WriteXPram								; restore the PSWD info
-			adda.w	#PSWDspace>>16,sp				; 
-			
-			movea.l	sp,a0							; 
-			move.l	#PSWDChkFlg,d0					; 
-			_WriteXPram								; restore the PSWD Checksum & Flags
-			adda.w	#PSWDChkFlg>>16,sp				; 
-			
-			movea.l	sp,a0							; 
-			move.l	#PSWDPRAM,d0					; 
-			_WriteXPram								; restore the PSWD info
-			adda.w	#PSWDPRAM>>16,sp				; 
-
-; /\ /\ /\ /\  															<SM138> from prev
-
-@normNuke3	bra		Start							; re-boot the machine
-
-
-@Keys		dc.l	$00800000						; R
-			dc.l	$08008004						; P, Cmd, Opt
-			dc.l	$00000000
-			dc.l	$00000000
-
-			dc.l	$0004000C						; XPRAM signature len/addr
-			dc.l	'Gone'							; invalidate XPRam signature with this
-
 
 ;________________________________________________________________________________________
 ;
@@ -2665,54 +2364,6 @@ GetPRAM		_InitUtil								; seed low memory PRAM buffer
 			RTS
 
 
-;________________________________________________________________________________________
-;
-; Routine:	SetPRAM32
-;
-; Inputs:	none
-; Outputs:	none
-; Trashes:	none
-;
-; Function:	force Memory Manager start mode to 32-bit mode
-;________________________________________________________________________________________
-
-SetPRAM32	movem.l	a0/d0,-(sp)						; save a0 and d0
-			subq.l	#4,sp							; create space on stack
-			move.l 	sp,a0 							; get pointer to useful buffer							<SM50>
-
-			MOVE.L	#$1008a,d0						; Command to read 1 byte at addr 8a 					<SM50>
-			_ReadXPRam								;														<SM50>
-			
-			move.l 	sp,a0 							; get pointer to useful buffer							<SM50>
-			ori.b	#5,(a0)							; set PRAM to 32 bit mode	
-			MOVE.L	#$1008a,d0						; Command to write 4 bytes at addr 8a					<SM50>
-			_WriteXPRam 							;														<SM50>
-			addq.l	#4,sp							; dispose space on stack
-			movem.l	(sp)+,a0/d0						; restore a0/d0
-			rts
-
-;________________________________________________________________________________________
-;
-; Routine:	InitNonMMU
-;
-; Inputs:	A6	-	pointer to memory table in high memory
-;
-; Outputs:	A4	-	points to memory table
-;			A5	-	points to top of useable RAM
-;			A6	-	points to top of total RAM
-;
-; Trashes:	none
-;
-; Function:	sets up A4, A5, A6 for non-MMU based machines and points jSwapMMU to an RTS.
-;________________________________________________________________________________________
-
-InitNonMMU 	move.l	a6,a4							; get ptr to memory table
-			move.l	(a4),a6
-			add.l	4(a4),a6						; calculate top of all memory
-			move.l	a6,a5							; top useable memory = top all memory
-			rts
-
-
 
 *************************************************************************************************
 *																								*
@@ -2804,18 +2455,7 @@ InitGlobalVars
 ; jump table.
 ;
 			Move.l	ROMBase,A0						; Get ROMBase
-			TestFor	ASCExists						; Do we really have an ASC?
-			Beq.s	@noASC							; -> No. Set SoundBase = ROMBase
-			Move.l	ASCBase, A0						; We do have an ASC. Get its base from universal
-@noASC
 			Move.l	A0,SoundBase					; Set up SoundBase
-
-	IF ROMinRAM THEN
-			CMPI.L	#$40800000,SoundBase			; if running from RAM, Set sound base to ROM		<LW5> rb
-			BHI.S	@BaseOK							; if SoundBase points to higher than 40800000		<LW5> rb
-			MOVE.L	#$40800000,SoundBase			; is ok, otherwise point to real ROM				<LW5> rb
-@BaseOK												;													<LW5> rb
-	ENDIF
 ;--------------------------------------
 
 			LEA 	VBLQueue,A1
@@ -2938,6 +2578,11 @@ InitCrsrMgr	MOVE.L	#$000F000F,D0
 			move.l	(a1)+,(a0)+						;   move the bytes in
 			move.l	(a1),(a0)
 
+			RTS
+
+MouseBytes	dc.b		4,10,15,255,255,83,77,72
+
+InitCrsrMgrMiddle
 			LEA 	GrafEnd,A1						; end of cursor globals
 			BigLea	CrsrDevHandleVBL,A0				; install cursor VBL task							<H9>
 			MOVE.L	A0,-(A1)						; JCrsrTask
@@ -2962,113 +2607,6 @@ InitCrsrMgr	MOVE.L	#$000F000F,D0
 			MOVE.W	D0,CrsrNew						; flag cursor as changed, turn on tracking
 			MOVE.L	D0,MouseMask					; No jerkiness with $FFFFFFFF mask
 
-		IF forTNTDebug THEN
-; set up a Time Manager task to call jVBLTask
-			
-initDummyVBL
-			moveq.l	#tmXQSize, d0					; allocate a block in the system heap
-			_NewPtr	,SYS,CLEAR						;  to hold the Time Manager task structure
-			lea		dummyVBL, a1
-			move.l	a1, tmAddr(a0)
-			move.l	#'eada', (a0)					; identify queue type to VM
-			_InsXTime
-			move.l	#-16626, d0
-			move.l	jPrimeTime, a1
-			jmp		(a1)
-			
-			RTS
-
-dummyVBL	
-			movea.l a1, a0
-			move.l	#-16626,d0			; 60.15 Hz
-			movea.l jPrimeTime, a1
-			move.l	jCrsrTask,-(sp)		; return address from PrimeTime to CrsrTask
-			jmp		(a1)				; restart time manager task
-		ENDIF
-			
-			RTS
-
-MouseBytes	dc.b		4,10,15,255,255,83,77,72
-
-
-;________________________________________________________________________________________
-;
-; Routine:	InitSwitcherTable
-;
-; Inputs:	none
-; Outputs:	none
-; Trashes:	A0,A1
-;
-; Function:	Installs a table telling Switcher what low memory locations to save/restore
-;			between applications in addition to the Switcher's own table (but always
-;			including the dispatch table).  The Switcher's table:
-;
-;				$100:	$02 bytes		(monkey lives)
-;				$108:	$14 bytes		(MemTop, BufPtr, StkLowPt, HeapEnd, TheZone)
-;				$130:	$04 bytes		(ApplLimit)
-;				$15C:	$04 bytes		(SEvtEnb, DSWndUpdate, FontFlag, IntFlag)
-;				$2AA:	$04 bytes		(ApplZone)
-;				$31E:	$22 bytes		(MinStack, DefltStack, mmDefFlags, GZRootHnd, GZRootPtr,
-;											GZMoveHnd, DSDrawProc, EjectNotify, IAZNotify).
-;				$800:	$2FC bytes		(ToolBox globals)
-;
-;			Table defining our additional switchables
-;
-;			Format is:
-;				address (word), byte count (word)	; save bytecount bytes at address
-;				.
-;				.
-;				0 (longword)						; terminates list
-;________________________________________________________________________________________
-
-OurSwitch	DC.W	OSTable,	4*numOStrap			; OS dispatch table
-			DC.W	ToolTable,	4*numTBtrap			; Toolbox dispatch table
-			DC.W	$0B80,		$26					; new switchables
-			DC.W	$0BAE,		$52					; new switchables
-			DC.W	HFSFlags,	2					; TFS flags (PMSP status) & Cache flags
-			DC.W	DefVRefNum,	2					; Default VRefNum/WDRefNum
-			DC.W	DefVCBPtr,	4
-			DC.W	ScrDmpEnb,	2
-			DC.W	CurDirStore,4
-			DC.W	MBProcHndl,	4
-
-			DC.W	$0100,		$0002				; SysCom//MonkeyLives
-			DC.W	$0108,		$0014				; memtop,bufptr,stklowpt,etc.
-			DC.W	$015C,		$0004				; SEvtEnb,DSWndUpdate,FontFlag,IntFlag
-			DC.W	$031E,		$0022				; MinStack,DefltSTack,mmDefFlags,etc.
-			DC.W	$0800,		$02FC				; toolbox globals,etc.
-			DC.W	ApplLimit,	$0004
-			DC.W	ApplZone,	$0004
-			DC.W	AuxWinHead,	$0004
-			DC.W	AuxCtlHead,	$0004
-			DC.W	BNMQHd,		$0004
-			DC.W	MenuCInfo,	$0004
-			DC.W	MenuDisable,$0008
-			DC.W	theGDevice,	$0004
-
-WDCBSwitch	DC.W	0,0,0 							; WDCB table
-PMSPSwitch	DC.W	0,0,SPHdrSize-2					; PMSP hook
-			DC.W	0,0 							; terminate with a long of zeroes
-SwitchLen	EQU 	*-OurSwitch
-
-;----------------------------------------------------------------
-; These constant values are stored in ROM rather than defined as EQUs for
-; use at compile time simply because we have a brain-damaged (c.f. Jobs on HP)
-; development system.
-;----------------------------------------------------------------
-WDCBSwOS	DC.W	WDCBSwitch-OurSwitch
-PMSPSwOS	DC.W	PMSPSwitch-OurSwitch
-
-
-InitSwitcherTable
-			MOVEQ	#SwitchLen,D0					; allocate a switcher table in
-			_NewPtr ,SYS,CLEAR						;  the system heap
-			MOVE.L	A0,A1							; make it the destination
-			LEA 	OurSwitch,A0					; template table
-			MOVEQ	#SwitchLen,D0					; copy it - needs to be updated with
-			_BlockMove								;  WDCBSwitch, PMSPSwitch later
-
-			MOVE.L	A1,SwitcherTPtr 				; Set the pointer up for Switcher
 			RTS
 
 
@@ -3181,6 +2719,11 @@ SetupMiscSCSI
 			bra.s	@SCSIHskDone
 @80based
 		ENDIF
+
+
+			btst.b	#6, ($2400)
+			bne.b	@SCSIHskDone
+
 			btst.l	#SCSIDackExists,d0				; see if we have SCSI Dack
 			bne.s	@SCSIDackDone					; if we do, it's setup ok
 			move.l	SCSIHsk,SCSIDMA					; if not, use hsk instead
@@ -3222,37 +2765,6 @@ InitSlots	BSR.L	InitSDTbl						; init slot int dispatch table
 			BRA		Critical						; Critical error
 
 
-;________________________________________________________________________________________
-;
-; Routine:	InitIOPStuff
-;
-; Inputs:	none
-; Outputs:	none
-; Trashes:	???
-;
-; Function:	initializes the I/O system by building the Unit Table and issuing initialization
-;			calls to all the component drivers.
-;________________________________________________________________________________________
-
-InitIOPStuff
-		IF IopADB | hasIopScc | hasIopSwim THEN
-			BSR.L	InitIOPMgr						; fire up the IOP manager
-		  IF hasIopSWIM THEN
-			TestFor	SWIMIOPExists					; see if we have a SWIM IOP
-			beq.s	@noSwimIOP						; if not, skip it
-			BSR.L	EnableSwimIOPInts				; Enable SWIM IOP interrupts
-@noSwimIOP
-		  ENDIF
-		  IF hasIopScc THEN
-			TestFor	SCCIOPExists					; see if we have a SCC IOP
-			beq.s	@noSCCIOP						; if not, skip it
-			BSR.L	SCCIOPBypass
-@noSCCIOP
-		  ENDIF
-		ENDIF
-			rts
-
-
 ;________________________________________________________________________________________
 ;
 ; Routine:	InitDeviceMgr
@@ -3269,7 +2781,7 @@ InitDeviceMgr	; Compute the size of the unit table and allocate it.
 			MOVEQ	#UnitEntries,D0 				; get number of entries in unit table
 			MOVE.W	D0,UnitNtryCnt					; save for IOCore checking
 
-			MOVE.L	#MaxUTEntries*4,D0				; reserve more memory so table can grow					<SM84>
+			MOVE.L	#MaxUTEntries*2,D0				; reserve more memory so table can grow					<SM84>
 			_NewPtr ,SYS,CLEAR						; allocate it and zero out the memory
 			MOVE.L	A0,UTableBase					; and save its address
 
@@ -3295,55 +2807,6 @@ LoadDrivers
 			MOVE.L	SP,A0
 			CLR.B	IOPermssn(A0)					; r/w permissions
 
-		IF hasNewAge THEN
-			TestFor	NewAgeExists					; do we have a NewAge?									<SM16>
-			Beq.S	@NoNewAge						; no ? then try old floppy								<SM16>
-
-			move.l	SP,A0							; iopb on stack
-			clr.b	IOPermssn(A0)					; clear r/w permissions
-			lea		NewAgeName,a1					; get new age driver name								<SM16>
-			move.l	a1,IOFileName(a0)				; set it up												<SM16>
-			_Open									; and open the driver									<SM16><SM21>
-@NoNewAge
-		ENDIF
-
-			TestFor	IWMExists						; do we have an IWM or SWIM?
-		IF hasIopSwim THEN
-			BNE.S	@OpenSony						; -> yes, open the driver
-			TestFor	SWIMIOPExists					; how about an IOP-based version?
-		ENDIF
-
-		IF hasSwim3 THEN
-			BNE.S	@OpenSony						; -> yes, open the driver
-			TestFor	SWIM3Exists						; how about a SWIM3 based version?
-		ENDIF
-			BEQ.S	@NoFloppy						; -> nope, no floppy controller
-
-@OpenSony
-			MOVE.L	SP,A0							; iopb on the stack
-			CLR.B	IOPermssn(A0)					; r/w permissions
-			LEA 	DiskName,A1						
-			MOVE.L	A1,IOFileName(A0)				
-			_Open									;OPEN Floppy disk driver
-
-;
-;—————————  NetBoot Driver  —————————
-;
-@NoFloppy	
-		IF hasNetBoot	THEN
-			SUBQ.W	#4,SP
-			MOVE.L	#'DRVR',-(SP)					; resource type
-			PEA		NetBootName						; resource name
-			_GetNamedResource						; try to get the handle to the .netBoot driver
-			TST.L	(SP)+							; does the driver exist?
-			BEQ.S	@NoNetBoot						; -> no, try don't open it
-
-			LEA		NetBootName, A1
-			MOVE.W	#49,D2							;  and resource ID										<SM84>
-			BSR		InstallDriver					; go install the driver									<SM84>
-@NoNetBoot
-		ENDIF
-
 ;
 ;—————————  RAM Disk Driver  —————————
 ;
@@ -3351,42 +2814,73 @@ LoadDrivers
 ; to enable the EDisk, make sure that it is included in the rom resources
 
 		IF hasEDisk THEN
-			LEA 	EDiskName,A1					
-			MOVE.W	#48,D2							;  and resource ID										<SM84>
+			LEA.L 	EDiskName,A1					
+			MOVEQ.L	#$30,D2							;  and resource ID										<SM84>
 			BSR		InstallDriver					; go install the driver									<SM84>
 		ENDIF
 
-	IF NOT forTNTDebug THEN
+
+;
+;—————————  LAN Disk Driver  —————————
+;
+
+			BSR		InitLANDisk						; (CDG5) NewWorld network boot
+
+
+;
+;—————————  BCScreen Driver  —————————
+;
+
+
+			IF		hasBCScreen THEN
+
+			SUBQ.L	#2,SP
+			MOVE.L	SP,-(SP)
+			MOVE.L	#$3FF,-(SP)
+			MOVE.L	#$36,-(SP)
+			CLR.L	-(SP)
+			PEA.L	BCScreenName
+			MOVE.L	#-16515, -(SP)
+			BSR.L	LoadNDRV						; (CDG5)
+			DC.W	$DEFC, $001A
+			;ADDA	#$1A, A7
+
+			ENDIF
+
+
 ;
-;—————————  Sound Driver  —————————
+;—————————  Backlight Driver  —————————
 ;
-		IF hasDSP THEN
-			TestFor	DSPExists						; If we have a DSP, we assume we're doing sound through it. <SM57>
-			BNE.s	@DoneSoundDriver				; if we have a Cyclone/DSP then don't load sound driver	<SM53>
-		ENDIF
-
-			MOVE.L	SP,A0							; iopb on the stack
-			CLR.B	IOPermssn(A0)					; r/w permissions
-			LEA 	SndName,A1
-			MOVE.L	A1,IOFileName(A0)
-			_Open									; OPEN sound driver
-@DoneSoundDriver
-	ENDIF
-
-			MOVE.L	SP,A0							; iopb on the stack <sm125>
-			CLR.B	IOPermssn(A0)					; r/w permissions   <sm125>
-			BSR		FROVideo						; open the default video driver and setup video globals	<SM19>
-			LEA	 	IOQElSize(SP),SP				; deallocate parameter block for device manager calls.
 
 		IF hasPwrControls THEN
-			TestFor	hwCbPwrMgr						; <61>, is this a Power Mgr mac ?
-			beq.s	@noBacklight					; <61>, if not, skip
-			LEA		BacklightName,A1				; get the backlight driver's name						<SM84>
+			BTst.B    #$0, (HWCfgFlags)
+			BEQ.B     @noBacklight
+			BTst.B    #$6, ($2409)
+			BNE.B     @noBacklight
+			Move.L    #'only', -(A7)
+			LEA.L	BacklightName,A1				; get the backlight driver's name						<SM84>
 			MOVE.W	#-16511,D2						;  and resource ID										<SM84>
 			BSR		InstallDriver					; go install the driver									<SM84>
+			AddQ      #$4, A7
 @noBacklight
-		ENDIF
 	
+			  MoveA.L   A7, A0
+			  Clr.B     $1B(A0)
+			  Bsr       FROVideo
+			  Lea.L     $32(A7), A7
+			  BTst.B    #$6, ($2409)
+			  BEQ.B     @skipALine
+			  Bsr.L     WangBacklight
+@skipALine
+
+			  BTst.B    #$3, ($DD3)
+			  BEQ       @exitDrivers
+		ENDIF
+
+
+
+
+
 
 ;
 ;—————————  Serial Drivers  —————————
@@ -3398,21 +2892,30 @@ LoadDrivers
 ; table, remaining closed and inactive until opened by a client.
 
 			subq	#4,sp							; allocate space for return value
-			move.l	#'SERD',-(sp)					; push serial driver resource type
-
-			TestFor	SerialDMA
-			bne.b	@SerialDMA
-			clr.w	-(sp)							; classic serial driver is 'SERD' (0)
-			bra.b	@CallSERD
-@SerialDMA	move.w	#1,-(sp)						; SerialDMA driver is 'SERD' (1)
-
-@CallSERD	move.w	#mapTrue,ROMMapInsert			; get resource from ROM
+			move.l	#'nsrd',-(sp)					; push serial driver resource type
+			move.w	#1,-(sp)						; SerialDMA driver is 'SERD' (1)
+			move.w	#mapTrue,ROMMapInsert			; get resource from ROM
 			_GetResource
 			move.l	(sp)+,d0						; did it get the handle?
 			beq.b	@exitDrivers
-			movea.l	d0,a0
-			movea.l	(a0),a0
-			jsr		(a0)							; call the install code
+			movea.l	d0,a2
+			movea.l	(a2),a1
+			SubQ      #$4, A7
+			Move.L    A2, -(A7)
+			dc.w $a9a5 ; _SizeResource
+			Move.L    (A7)+, D1
+			Move.L    D1, D0
+			dc.w $A440 ; _ResrvMemSys
+			Move.L    D1, D0
+			_NewHandle ,Sys
+			Move.L    A0, D0
+			BEQ.B     (* + $E)
+			_HLock
+			Move.L    D1, D0
+			MoveA.L   (A0), A1
+			MoveA.L   (A2), A0
+			_BlockMove
+			jsr		(a1)							; call the install code
 
 @exitDrivers
 			rts
@@ -3420,8 +2923,6 @@ LoadDrivers
 
 			STRING	PASCAL
 
-DiskName	DC.W	'.Sony'
-
 SndName 	DC.W	'.Sound'						;														<SM83>
 
 		IF hasEDisk THEN
@@ -3439,6 +2940,12 @@ BacklightName
 			DC.W	'.Backlight'
 		ENDIF
 
+		IF hasBCScreen THEN
+BCScreenName
+			DC.W	'.BCScreen'						; (CDG5)
+		ENDIF
+
+
 			STRING	ASIS
 
 
@@ -3480,11 +2987,34 @@ DrawBeepScreen
 ;	of the menu bar (because the screen background is white on LCD screens vs black on CRTs)
 
 			BSR.L	LCDScreenChk					; is this an LCD screen ? 								<SM16><SM68>
-			BEQ.S	@DoNormalBeepScreen				; -> no, do the normal stuff							<SM16><SM68>
+			BEQ.B	@DoNormalBeepScreen				; -> no, do the normal stuff							<SM16><SM68>
 			
+			CLR.B	ntsc
+
 			PEA 	ScreenBits+bounds(A2)			;  screen rectangle										<SM84>
+			CLR.B	-(SP)
+			JSR		GetGrayPage
+			TST.B	(SP)+
+			BNZ.B	@graypage_returned_nonzero
+
+;graypage_returned_zero
 			PEA		gray(A2)						;  fill pattern
-			_FillRect								; fill the screen with 50% gray
+			BRA.B	@graypage_endif
+
+@graypage_returned_nonzero
+			MOVE.L	ExpandMem,A0
+			ST.B	$341(A0)
+			PEA		@GrayColor
+			_RGBForeColor
+			PEA		black(A2)
+
+@graypage_endif
+
+			_FillRect
+
+			MOVEQ	#5,D0
+			DC.W	$ABE0 ; QDExtensions2, ?showCursor selector
+
 			RTS
 @DoNormalBeepScreen
 		ENDIF										;														<SM81>
@@ -3510,11 +3040,27 @@ DrawBeepScreen
 
 			_PenNormal								; restore the pen
 
+			PEA		@GrayColor
+			_RGBForeColor
+
+			MOVE.L	#$00100010, -(SP)				;  rounding factor
+			PEA 	black(A2)						;  fill pattern
+			BRA.B	@skipOldPatternSelection
+
 			MOVE.L	#$00100010, -(SP)				;  rounding factor
 			PEA 	gray(A2)						;  fill pattern
+@skipOldPatternSelection
 			_FillRoundRect							; fill the screen with 50% gray
+
+			MOVEQ	#5,D0
+			DC.W	$ABE0 ; QDExtensions2, ?showCursor selector
+
 			RTS
 
+@GrayColor
+			DC.W	$8888, $8888, $8888
+
+
 
 ;________________________________________________________________________________________
 ;
@@ -3536,8 +3082,33 @@ FROVideo	MOVE.L	A0,A1							; save the param block pointer for _Open
 			LINK	A6,#-spBlockSize				; allocate space for a slot parameter block
 			MOVE.L	SP,A0							;  and point to it
 
-			BSR.S	OpnVidDeflt						; open the default video device, set video params
-			BEQ.S	@End							; -> got it
+			BTST.B	#6, ($240B)
+			BEQ.B	@TryDefault
+
+			MoveM.L   D0-D7/A0-A4, -(A7)
+			Move.L    ($1FB8), -(A7)
+			MoveA.L   ($2b6), A3
+			MoveA.L   $1E0(A3), A3
+			Move.L    $C(A3), -(A7)
+			Lea.L     InitVidDeflt_RTS, A2
+			Move.L    A2, ($1FB8)
+			Move.L    A2, $C(A3)
+			SubQ      #$2, A7
+			Clr.L     -(A7)
+			Move      #$2EB, D0
+			_DisplayDispatch
+			Move      (A7)+, D0
+			MoveA.L   ($2b6), A3
+			MoveA.L   $1E0(A3), A3
+			Move.L    (A7)+, $C(A3)
+			Move.L    (A7)+, ($1FB8)
+			Tst       D0
+			MoveM.L   (A7)+, D0-D7/A0-A4
+			BNE.B     @End
+
+@TryDefault
+			BSR		OpnVidDeflt						; open the default video device, set video params
+			BEQ		@End							; -> got it
 
 ;	the default video device is bad, so go search for a video sRsrc...
 
@@ -3553,23 +3124,26 @@ FROVideo	MOVE.L	A0,A1							; save the param block pointer for _Open
 
 @NextVidsRsrc
 			_sNextTypesRsrc							; search for a video sRsrc
-			BNE.S	@FakeIt							; -> couldn't find one, so allocate a dummy screen
+			BNE		@End							; -> couldn't find one, so allocate a dummy screen
 
+			BSR		OpensDrvr						; open the video driver
+			BNE.S	@NextVidsRsrc					; -> couldn't do it, so go look some more
+
+			MOVE	$18(A1), -(SP)
 			BSR		RdVidParam						; read the video parameters
+			TST		D0
 			BNE.S	@NextVidsRsrc					; -> error, so go search some more
 
-			BSR		OpensDrvr						; open the video driver
-			BNE.S	@NextVidsRsrc					; -> couldn't do it, so go look some more
-
 			BSR		InitVidDeflt					; initialize the default video device
 			BNE.S	@NextVidsRsrc					; -> error during initialization, so go looking
 
+			BRA.S	@End
+
+			BSR		InitDummyScreenWrapper
+
 @End		UNLK	A6								; get rid of the slot parameter block
 			RTS
 
-@FakeIt		BSR		InitDummyScreen					; allocate a dummy screen, GDevice
-			BRA.S	@End							;  and return
-
 
 ;________________________________________________________________________________________
 ;
@@ -3604,12 +3178,14 @@ OpnVidDeflt	MOVE.L	A0,A2							; save A0
 			CMP.W	#DrSwApple,spDrvrSW(A0)			; does it have an Apple driver interface (software only)?
 			BNE.S	@Error							; -> no, keep on searching
 
-			BSR.S	RdVidParam						; a video sRsrc was found, so read the video parameters
-			BNE.S	@Error							; -> error during the read
-
 			BSR		OpensDrvr						; open the video driver
 			BNE.S	@Error							; -> couldn't do it
 
+			MOVE	$18(A1), -(SP)
+			BSR		RdVidParam						; a video sRsrc was found, so read the video parameters
+			TST		D0
+			BNE.S	@Error							; -> error during the read
+
 			BSR		InitVidDeflt					; initialize the default video device
 @Error		RTS
 
@@ -3629,7 +3205,8 @@ OpnVidDeflt	MOVE.L	A0,A2							; save A0
 ;			then saved in low memory as needed.
 ;________________________________________________________________________________________
 
-RdVidParam	MOVEM.L	A1-A2/D3,-(SP)
+RdVidParam	LINK	A6, #-$94
+			MOVEM.L	A0-A2/D3,-(SP)
 			MOVE.B	spId(A0),D3						; save the ID
 
 			CLR.B	spExtDev(A0)					;	no external devices
@@ -3651,6 +3228,7 @@ RdVidParam	MOVEM.L	A1-A2/D3,-(SP)
 @gotBase	MOVE.L	spResult(A0),ScreenBytes		; save it
 
 			MOVE.B	D3,spId(A0)						; restore the sRsrc ID
+			MOVE	$18(A1), -(SP)
 			BSR		GetDefVidMode					; get the default video mode
 			MOVE.B	D0,spId(A0)						;  and save it
 
@@ -3686,9 +3264,9 @@ RdVidParam	MOVEM.L	A1-A2/D3,-(SP)
 			MOVEQ	#0,D0							; no errors
 
 @End		MOVE.B	D3,spId(A0)						; restore ID for caller
-			MOVEM.L	(SP)+,A1-A2/D3
-			TST.W	D0
-			RTS
+			MOVEM.L	(SP)+,A0-A2/D3
+			UNLK	A6
+			RTD		#2
 
 @Error		MOVEQ	#1,D0							; bad video card (woof)
 			BRA.S	@End
@@ -3755,34 +3333,76 @@ OpensDrvr	MOVE.L	A2,-(SP)
 ;________________________________________________________________________________________
 
 InitVidDeflt
-			MOVEM.L	D1-D2/A0-A1,-(SP)				; save all registers
-			CLR.L	-(SP)							; make room for GDevice handle
-			MOVE	ioRefNum(A1),-(SP)				; push the device's refNum
-
-			BSR.S	GetDefVidMode					; get the default video mode
-			MOVE.L	D0,-(SP)						;  and push it
-
-			_NewGDevice								; allocate a new GDevice (in the system heap)
-													;strips refNum and video mode
-			MOVE.L	(SP)+,A0						;save current device in A0
-
-;	install default video card as primary display device
-
-			MOVE.L	A0,TheGDevice					; make this the default destination
-			MOVE.L	A0,DeviceList					; make this device head of list
-			MOVE.L	A0,MainDevice					; make it the main device
-			MOVE.L	A0,SrcDevice					; make it the default source for copyBits
-			MOVE.L	A0,CrsrDevice					; make it the one owning the cursor
-			MOVE.L	(A0),A1							; point to this device
-			ORI.W	#$B800,GDFlags(A1)				; set flags: ScrnActive,MainScrn,ScreenDevice,Allinit
+			MOVEM.L	D1-D2/A0-A3,-(SP)				; save all registers
+			SubQ      #$4, A7
+			MoveA.L   A7, A2
+			Move      $18(A1), -(A7)
+			Bsr       GetDefVidMode
+			Move.L    ($1FB8), -(A7)
+			MoveA.L   ($2b6), A3
+			MoveA.L   $1E0(A3), A3
+			Move.L    $C(A3), -(A7)
+			Lea.L     InitVidDeflt_RTS, A3
+			Move.L    A3, ($1FB8)
+			Move.L    A3, (12)
+			SubQ      #$4, A7
+			MoveA.L   A7, A3
+			SubQ      #$2, A7
+			Move.L    A3, -(A7)
+			Move      $18(A1), -(A7)
+			Move.L    D0, -(A7)
+			Clr.L     -(A7)
+			Clr.L     -(A7)
+			Clr.L     -(A7)
+			Clr.L     -(A7)
+			Move      #$D23, D0
+			_DisplayDispatch
+			Move      (A7)+, D0
+			MoveA.L   (A7)+, A3
+			Tst       D0
+			BNE.B     @skip
+			SubQ      #$2, A7
+			Move.L    A3, -(A7)
+			Move.L    A2, -(A7)
+			Clr.B     -(A7)
+			Move      #$51F, D0
+			_DisplayDispatch
+			Tst       (A7)+
+			BNE.B     @skip
+			SubQ      #$2, A7
+			Move.L    A3, -(A7)
+			Clr.L     -(A7)
+			Move      #$40B, D0
+			_DisplayDispatch
+			Tst       (A7)+
+			BNE.B     @skip
+			SubQ      #$2, A7
+			Move.L    (A2), -(A7)
+			Move.L    A2, -(A7)
+			Clr.B     -(A7)
+			Move      #$520, D0
+			_DisplayDispatch
+			Tst       (A7)+
+			BNE.B     @skip
+			MoveA.L   (A2), A0
+@skip
+			MoveA.L   ($2b6), A3
+			MoveA.L   $1E0(A3), A3
+			Move.L    (A7)+, $C(A3)
+			Move.L    (A7)+, ($1FB8)
+			AddQ      #$4, A7
 
 			BSR		InitDefGamma					; initialize gamma correction for this device
 
-			MOVEM.L	(SP)+,D1-D2/A0-A1				;restore all registers
+			MOVEM.L	(SP)+,D1-D2/A0-A3				;restore all registers
 			MOVEQ	#0,D0							;no error
 			RTS
 
 
+InitVidDeflt_RTS
+			RTS
+
+
 ;________________________________________________________________________________________
 ;
 ; Routine:	GetDefVidMode
@@ -3797,14 +3417,15 @@ InitVidDeflt
 ;________________________________________________________________________________________
 
 GetDefVidMode
+			LINK	A6, #-$58
+
 			MOVE.L	spsPointer(A0),-(SP)			; save the sPointer,
 			MOVE.B	spId(A0),-(SP)					;  the id,
-			MOVE.L	A1,-(SP)						;  and registers
+			MOVEM.L	A1-A2,-(SP)						;  and registers
 
-			LEA		-SizesPRAMRec(SP),SP			; make room for parameter RAM info
-			MOVE.L	SP,A1							;  and point to it
+			LEA		-SizesPRAMRec*3(A6),A1			; make room for parameter RAM info
+			MOVE.L	A1,(A0)							;  and point to it
 
-			MOVE.L	A1,spResult(A0)					; pass the pointer to the buffer
 			_SReadPRAMRec							; get parameter RAM record
 			BNE.S	@OneBit							; -> it's invalid, so default to one bit mode
 
@@ -3819,11 +3440,11 @@ GetDefVidMode
 			MOVEQ	#0,D0
 			MOVE.B	2(A1),D0						; get the default mode
 
-@ValidMode	LEA		SizesPRAMRec(SP),SP				; clean up the stack
-			MOVE.L	(SP)+,A1						; restore registers,
+@ValidMode	MOVEM.L	(SP)+,A1-A2						; restore registers,
 			MOVE.B	(SP)+,spId(A0)					;  the id,
 			MOVE.L	(SP)+,spsPointer(A0)			;  and the sPointer
-			RTS
+			UNLK	A6
+			RTD		#2
 
 @OneBit		MOVE.B	#OneBitMode,2(A1)				; Set default to OneBitMode
 			MOVE.L	A1,spsPointer(A0)				; Pass pointer to buffer
@@ -3952,6 +3573,14 @@ InitDefGamma
 			BRA.S	@SetIt							; set it
 
 
+InitDummyScreenWrapper ; f52
+			MOVE.L	(DeviceList), D0
+			BEQ.B	InitDummyScreen
+			CMPI.L	#$FFFFFFFF, D0
+			BEQ.B	InitDummyScreen
+			RTS
+
+
 ;________________________________________________________________________________________
 ;
 ; Routine:	InitDummyScreen
@@ -4081,6 +3710,7 @@ AddVidDevice
 			MOVE	ioRefNum(A1),-(SP)				; push the device's refNum
 
 			BSR.S	GetDefVidMode					; D0 <- the default video mode
+			MOVE	$18(A1), -(SP)
 			MOVE.L	D0,-(SP)						; Push it
 
 			_NewGDevice								; allocate a new GrafDevice (in system heap)
@@ -4130,6 +3760,10 @@ InitSCC
 			bsr.l	SCCIOPHwInit					; initialize the IOP hardware registers
 @NoIOP												; fall thru -- IOP boots in bypass mode
 		ENDIF
+
+			btst.b	#3, ($DD3)
+			beq.b	@dontInitSCC
+
 			movea.l	SCCWr,a0						; point to SCC base write address (chan B)
 			movea.l	SCCRd,a1						; point to SCC base read address (chan B)
 			tst.b	(a1)							; synchronize SCC accesses
@@ -4139,89 +3773,6 @@ InitSCC
 			rts
 
 
-;________________________________________________________________________________________
-;
-; Routine:	InitIWM
-;
-; Inputs:	none
-; Outputs:	none
-; Trashes:	D0, D2, A0
-;
-; Function:	initializes the IWM/SWIM/SWIM2 floppy disk controller
-;________________________________________________________________________________________
-
-InitIWM		TestFor	IWMExists						; see if we really have an IWM
-			beq		ExitInitIWM						; if not, nothing to init
-
-			MOVEA.L	IWM,A0							; get floppy controller base address
-
-InitSWIM2	MOVE.L	BusErrVct,-(SP)					; save the old bus error vector							<H5>
-			PEA		@Resume							;  and point it to ours									<H5>
-			MOVE.L	(SP)+,BusErrVct					;														<H5>
-			MOVE.L	SP,D2							; save the stack pointer in case we bus error			<H5>
-
-			MOVEQ	#noDriveErr,D0					; assume the chip isn't there							<H5>
-			TST.B	q6L|rPhase(A0)					; access the chip (may bus error!)						<H5>
-			MOVEQ	#noErr,D0						; if we got here, the chip may be connected				<H5>
-			
-@Resume		MOVEA.L	D2,SP							; trash the exception frame if we bus errored			<H5>
-			MOVE.L	(SP)+,BusErrVct					; restore the previous bus error vector					<H5>
-			TST.W	D0								; set the CCR											<H5>
-			BNE		ExitInitIWM						; -> IWM/SWIM/SWIM2 is not currently connected			<H5>
-
-;  If we got here, at least we didn't bus error.  That doesn't mean we really have
-;  a IWM/SWIM, though, so lets do some more checking...
-
-			MOVE.B	#$F8,wZeroes(A0)				; try to switch to the IWM register set					<H7>
-		IF nonSerializedIO THEN						;
-			nop										; allow write to complete								<SM55>
-		ENDIF
-			MOVEQ	#$F5-256,D2						;														<H7>
-			MOVE.B	D2,wPhase(A0)					; write a value to the phase register					<H7>
-		IF nonSerializedIO THEN						;
-			nop										; allow write to complete								<SM55>
-		ENDIF
-			MOVE.B	D0,rPhase(A0)					; drive the bus in case the chip's not there			<H7>
-		IF nonSerializedIO THEN						;
-			nop										; allow write to complete								<SM55>
-		ENDIF
-			CMP.B	rPhase(A0),D2					; did we get back what was originally written?			<H7>
-			BEQ.S	ExitInitIWM						; -> yes, we've got a SWIM2								<H7>
-
-;  At this point, we know we don't have a SWIM2 connected.  We either have an IWM/SWIM or no chip...
-
-@NotSWIM2	TST.B	q7L(A0)							; select "Read Handshake"								<H7>
-			TST.B	q6L(A0)							;														<H7>
-			MOVE.B	D0,q7H(A0)						;														<H7>
-			MOVEQ	#%00111111,D2					; mask to just the low 6 bits							<H7>
-			AND.B	q6L(A0),D2						;  and read the register								<H7>
-			TST.B	q7L(A0)							; back into a read mode									<H7>
-			CMPI.B	#%00111111,D2					; did we get what we expected?							<H7>
-			BNE.S	ExitInitIWM						; -> no, it's isn't IWM or SWIM							<H7>
-
-			MOVEQ	#IWMInitMode,D0 				; initial mode setting
-@1			MOVE.B	#$BE,wZeroes(A0)				; disable enabled if in ISM mode
-			MOVE.B	#$F8,wZeroes(A0)				; switch SWIM to the IWM register set
-			TST.B	Q7L(A0)							; and get out of write mode
-			TST.B	MtrOff(A0)						; change the IWM mode now
-			TST.B	Q6H(A0) 						; set IWM to sense state
-			MOVE.B	Q7L(A0),D2						; sense the mode register
-			BTST	#5,D2							; no disks should be enabled
-			BNE.S	@1								; keep waiting
-
-			AND.B	D0,D2							; see if low bits match mode we want
-			CMP.B	D0,D2
-			BEQ.S	@2								; if so, we are done
-
-			MOVE.B	D0,Q7H(A0)						; set to twiggy mode
-			TST.B	Q7L(A0) 						; set IWM back to sense state
-			BRA.S	@1								; loop back just to check
-
-@2			TST.B	Q6L(A0) 						; and back to read mode
-
-ExitInitIWM	RTS
-
-
 ;________________________________________________________________________________________
 ;
 ; Routine:	InstallDriver
@@ -4250,7 +3801,7 @@ InstallDriver
 			move.l	UTableBase,a0					; point to utable array
 			move.l	(a0,d1),a0						; get handle to dce in a3
 			move.l	(a0),a0							; get pointer to dce
-			move.l	a1,dCtlDriver(a0)				; load driver
+			move.l	(a1),dCtlDriver(a0)				; load driver
 
 			move.l	(a1),a1							; get pointer to driver
 			move.w	drvrFlags(a1),dCtlFlags(a0)		; copy data to dce
@@ -4258,7 +3809,9 @@ InstallDriver
 			move.w	drvrEMask(a1),dCtlEMask(a0)
 			move.w	drvrMenu(a1),dCtlMenu(a0)
 
-			bset.b	#dNeedLock,dCtlFlags+1(a0)		; set the handle bit
+			bclr.b	#dNeedLock,dCtlFlags+1(a0)		; set the handle bit
+			cmpi.l	#'only', $4(sp)
+			beq.b	@exit
 
 @openDrvr	move.l	a2,a1							; load pointer to driver name
 			bra.s	OpenDRVR						; open the driver (a1/)
@@ -4391,124 +3944,105 @@ CheckForEgretOrCuda									;														<T2>
 		ENDIF
 
 
-;___________________________________________________________________________								<SM63>		
-; CheckForTV: Checks for the Cmd-Option-T-V keys down, and if so, set 
-; the PRAM bit that specifies we do that and Re-Boot
-;
-; Destroys	A0-A1/D0/D1.
-;___________________________________________________________________________
-		WITH 		spBlock,SP_Params
-CheckForTV
-			lea		@TVKeys,a1						; keys to check for								
-			lea		KeyMap,a0						; compare to the Key Down Map					
-			moveq.l	#4-1,d0							; compare loop count
-@loop		cmpm.l	(a0)+,(a1)+						; check for exactly this combo
-			dbne	d0,@loop						; examine the entire key map
-			beq.s	@tvmatch						; if equal, reset PRAM
-			rts										; otherwise, just return
-			
-@tvmatch	SUBA		#spBlockSize,SP				; make an slot parameter block on stack
-			MOVE.L		SP,A0						; get pointer to parm block now
-			MOVE.B		#0,spSlot(A0)				; put slot in pBlock
-			CLR.B		spExtDev(A0)				; external device = 0
 
-; Read the slot pRAM to determine what the currently saved mode is.  
-; The flag are in SP_FLAGS, which are in VendorUse5 byte.
-			
-			SUBA		#SizesPRAMRec,SP			; allocate block for pRAM record
-			MOVE.L		SP,spResult(A0)				; point to it
-			_sReadPRAMRec							; read it
-			Bne			@ErrorReturn				; should not fail, but if so...
-			Move.b		SP_Flags(SP),D0				; Get the current flags
-			Bset		#spCompOut,D0				; Set it, which means to enable
-			Move.b		D0,SP_Flags(SP)				; write out the sp_flags byte
-			MOVE.L		SP,spsPointer(A0)			; set up parameter block
-			_sPutPRAMRec							; write the new record out
-			Bne			@ErrorReturn				; any errors?
-			Adda		#SizesPRAMRec+spBlockSize,SP; Deallocate buffer and
-			jmp			Start														
-@ErrorReturn			
-			Adda		#SizesPRAMRec+spBlockSize,SP; Deallocate buffer and
-			rts
-			
-@TVKeys		dc.l	$00020200						; V, T
-			dc.l	$00008004						; Cmd, Opt
-			dc.l	$00000000
-			dc.l	$00000000
-		ENDWITH	
 
-;________________________________________________________________________________________	<SM121>
-;
-; Routine:	DynamicBoxFlag
+;………………………………………………………………………………………………………………………………………………………………………………………………………………………
 ;
-; Inputs:	D7.w	BoxFlag from the Universal tabke
+;	Taken from SCSIMgrInit.a
 ;
-; Outputs:	D7.w	Adjusted BoxFlag for this machine
+;——— Do PRAM stuff : Bytes 2 & 3 are allocated for SCSI stuff
 ;
-; Trashes:	D0-D1, A0-A1
+;	——— Byte 2 ———
+;  bit	-  def: meaning
+;	7	-	0 : If set, disable the SCSIReset on machine reset
+;	6	-	1 : unused
+;	5	-	0 : unused
+;	4	-	0 : unused (on PDM debug, affects Read DMA reads)
+;	3	-	1 : validity bit (both must be 1 for bytes 2&3 to be valid, else init them)
+;	2	-	1 : \
+;	1	-	1 :  — Host ID (i.e. SCSI ID of this Macintosh)
+;	0	-	1 : /
 ;
-; Function:	Calculates the boxflag based on box type and CPU clock rates.
-;			Look Ma! We have only one Universal table entry per family!
+;	——— Byte 3 ———
+;	7	-	0 : unused
+;	6	-	1 : unused
+;	5	-	0 : unused
+;	4	-	0 : unused (on PDM debug, affects Read DMA writes)
+;	3	-	1 : validity bit (see above)
+;	2	-	0 : \
+;	1	-	0 :  — "Internal Drive" ID (i.e. zero generally because nobody changes this)
+;	0	-	0 : /
 ;
-;________________________________________________________________________________________
 
-DynamicBoxFlag
-			TestFor	HMCDecoder						; do we have an HMC decoder?
-			beq.s	@rts							; -> Nope, just use the boxflag from the uTables.
-			
-			MOVEM.L	D0-D6/A0-A4/A6,-(SP)			; save Universal info
-;			CMPI.B	#boxPDMEvt1,D7					; Is this an Evt1?						; removing evt1 suprt
-;			BEQ.S	@Done							; -> Yes, never muck with the boxflag	; <mc2>
-	
-			BigBSR6	GetCPUIDReg						; Get the CPU id
-			BNE.S	@Done							; -> Failed (can't happen)
-
-			AND.W	#%00000011,D0					; Just look at bits 0 & 1
-
-			MOVE.L	([ProcessorInfoPtr],\
-					  ProcessorInfo.CPUClockRateHz),D1 ; Get the CPU clock rate
-						
-			MOVEQ	#-1,D2							; Clear the  counter
-			LEA		@SpeedTable,A0					; Point to the list of clock rates
-@Lupe		CMP.L	(A0)+,D1						; Is the bus clock rate less than the entry?
-			BLS.S	@GotIt							; -> Yes, go with the current delay factor
-			ADDQ	#1,D2
-			BRA.S	@Lupe
-			
-@GotIt		LSL.W	#2,D0							; Mult the box bit by the size of the table
-			LEA		(@BoxTable,D0),A0
-			MOVE.B	(A0,D2),D7						; Get the boxflag
-
-@Done		MOVEM.L	(SP)+,D0-D6/A0-A4/A6			; save Universal info
-@rts		RTS										; Return
-
-@SpeedTable											; PDM CPU clock rate mapping table
-			DC.L	10000000						; 50.001 MHz
-			DC.L	60000000						; 66.001 MHz
-			DC.L	73000000						; 80.001 MHz
-			DC.L	100000000						; 100.001 MHz
-			DC.L	-1								; end of table
-
-@BoxTable	EQU		*
-@WLCDboxes	DC.B	boxPDM50WLCD					; QFC
-			DC.B	boxPDM66WLCD
-			DC.B	boxPDM80WLCD
-			DC.B	boxPDM
-
-@notboxes	DC.B	boxPDM50WLCD					; QFC (wlcd post evt1)
-			DC.B	boxPDM66WLCD
-			DC.B	boxPDM80WLCD
-			DC.B	boxPDM
-
-@shitboxes	DC.B	boxPDM50L						; Lego
-			DC.B	boxPDM66L
-			DC.B	boxPDM80L
-			DC.B	boxPDM
+SetScsiIdFromPram
+
+			subq.l	#2,sp					; make space for PRAM SCSI id					<v1.4>
+			move.l	sp,a0					; address of PRAM return buffer
+
+			move.l	#$00020002,d0			; read 2 bytes of PRAM at offset 2	<C613>
+			_ReadXPRam						; get the SCSI id
+			move.w	(sp),d0					; check high bits for validity		<A324>
+			and.w	#$0808,d0				; look at upper bit in lower nibble	<SM15> pdw
+			cmp.w	#$0808,d0				; equal to magic pattern?			<C613>
+			beq.s	@GotID					; yes, so use those SCSI IDs		<A324>
+
+;--- if invalid, reinitialize values to defaults
+@SetID
+			move.w	#(($48+7)<<8) + ($48+0),(sp)	; defaults: CPU=7,hd=0	<C613>
+			move.l	sp,a0					; address of new PRAM value
+			move.l	#$00020002,d0			; write 2 bytes of PRAM to offset 2	<C613>
+			_WriteXPRam						; save the IDs in parameter RAM		<C613>
+@GotID
+			move.w	(sp)+, d0
 			
-@FridgBoxes	DC.B	boxPDM							; Fridge
-			DC.B	boxPDM66F
-			DC.B	boxPDM80F
-			DC.B	boxPDM100F
+			lsr.w	#8,d0					; get CPU SCSI ID for shift count
+			and.w	#$7,d0					; mask all but the ID bit
+
+			moveq.l	#1,d1					; 1 << SCSI id
+			lsl.b	d0,d1					; form the SCSI id mask
+			move.b	d1,SCSIDrvrs			; clear all SCSI driver flags but our own
+
+			rts
+
+
+
+
+CreateAltiVecBufForEmulator
+OnePage		equ		$1000
+
+			move.l	#gestaltPowerPCProcessorFeatures, d0
+			_Gestalt
+			bne.s	@done
+
+			move.l	a0, d0
+			and.l	#1<<gestaltPowerPCHasVectorInstructions, d0
+			bz.s	@done
+
+			move.l	#OnePage * 2, d0		; allocate 2 pages but only use one
+			_NewPtr	,sys,clear
+			bne.s	@done
+
+			lea		$68FFF000, a2			; emulator data page
+
+			move.l	a0, d0					; align up to page boundary
+			add.l	#OnePage-1, d0
+			and.l	#-OnePage, d0
+
+			move.l	d0, $E0(a2)				; save logical ptr
+			move.l	#$FE000000, $E8(a2)
+			clr.l	$EC(a2)
+
+			move.l	d0, a0
+			move.l	#OnePage, a1
+			_LockMemory
+
+			bsr.l	GetRealProc
+			bmi.s	@done
+
+			move.l	a0, $E4(a2)				; save physical ptr
+
+@done
+			rts
 
 			ENDPROC									; {MyROM}
 
diff --git a/OS/StartMgr/StartMgr.make b/OS/StartMgr/StartMgr.make
--- a/OS/StartMgr/StartMgr.make
+++ b/OS/StartMgr/StartMgr.make
@@ -27,18 +27,18 @@
 
 StartMgrObjs			=	"{ObjDir}StartTop.a.o"								∂
 							"{ObjDir}StartInit.a.o"								∂
+							"{ObjDir}OpenFirmware.c.o"							∂
+							"{ObjDir}PPCDebuggerNub.c.o"						∂
+							"{ObjDir}PPCDebuggerNub.a.o"						∂
 							"{ObjDir}StartSearch.a.o"							∂
+							"{ObjDir}StartLibGlue.c.o"							∂
 							"{ObjDir}StartBoot.a.o"								∂
 							"{ObjDir}StartFail.a.o"								∂
 							"{ObjDir}StartErr.a.o"								∂
 							"{ObjDir}StartAlert.a.o"
 
 
-StartTestObjs			=	"{ObjDir}USTStartTest.a.o"							∂
-							"{ObjDir}ExceptionSupport.a.o"						∂
-							"{ObjDir}UTEKernel.c.o"								∂
-							"{ObjDir}SONIC_Test.c.o"							∂
-							"{ObjDir}SizeMem.a.o"
+StartTestObjs			=	"{ObjDir}SizeMem.a.o"
 
 
 Boot3Objects			=	"{ObjDir}Boot3.a.o"									∂
diff --git a/OS/StartMgr/StartSearch.a b/OS/StartMgr/StartSearch.a
--- a/OS/StartMgr/StartSearch.a
+++ b/OS/StartMgr/StartSearch.a
@@ -180,7 +180,7 @@ NumFlashX		EQU		3						; number of times to flash X before going
 FloppyRefNum	EQU		-5						; floppy driver refnum
 IntHDRefNum		EQU		-33						; refnum of driver for SCSI ID 0
 
-DefaultTimeOut	EQU		20						; number of seconds timeout if PRAM is pristine
+DefaultTimeOut	EQU		25						; number of seconds timeout if PRAM is pristine
 MaxTimeOut		EQU		31						; maximum number of seconds allowed as timeout
 PollDelay		EQU		15						; delay (in ticks) between poll drive SCSILoads
 
@@ -211,7 +211,7 @@ Locals	RECORD	{link},INCR
 frameSize	equ	*
 
 flashTime		ds.l	1		; time to flash icon
-startTicks		ds.l	1		; Ticks when we first get into FindStartupDevice
+startTicks		ds.l	1		; Ticks when we first get into FindStartupDevice ; 8 lower
 
 ckPartition		ds.b	1		; flag = we need to check to see if the partition #s match
 noDefaultDrive	ds.b	1		; flag = we have no default drive
@@ -220,7 +220,7 @@ forcedBoot		ds.b	1		; flag = boot has been forced to a non-default device
 
 csPB			ds		CntrlParam		; pb for Control and Status
 
-pmCommandPB		ds		pmCommandRec	; pb for sending SleepReq to power manager
+pmCommandPB		ds		pmCommandRec	; pb for sending SleepReq to power manager ; 8 lower
 
 startPRAM		;(ds.l 1)
 lsdExtDevID		ds.b	1    	; slot device ExtDevID (for SCSI target/lun)
@@ -229,6 +229,8 @@ lsdRefNum		;(ds.w 1)		; SCSI device refnum
 lsdSlotNum		ds.b	1    	; slot number
 lsdSRsrcID		ds.b	1    	; sRsrc ID (for native SCSI, bus #; for plug-in, sRsrc ID)
 
+				ds.b	8
+
 link			ds.l	1		; old A4 = (A4)
 
 		ENDR
@@ -245,6 +247,7 @@ A4_locals		EQU		A4
 A5_bootGlobs	EQU		A5
 A6_bootBlocks	EQU		A6
 
+
 ;________________________________________________________________________________________
 ;
 ; Routine:	FindStartupDevice
@@ -276,11 +279,19 @@ FindStartupDevice	PROC	EXPORT
 
 			BSR		LoadSlotDrivers				; Default is a slot device, execute boot code
 												; When booting a Mac OS, execution will continue here
+			MOVEQ.L	#0, D7
 			MOVE.L	Ticks, startTicks(A4)		; Init the time we got here	in case we have PowerMgr
 
 			BSR		LoadSCSIDrivers				; Load all the drivers we can
 			BSR		WaitForPollDrive			; Wait until the boot drive has warmed up
-			BRA.S	@FirstEntry					; First time through: keep original goal
+
+			CLR.B	-6(A4)
+			
+			BSR		LoadATADrivers
+
+			BSR		OpenLANDiskDriver
+
+			BRA		@FirstEntry					; First time through: keep original goal
 
 @NextPass
 		IF hasPwrControls THEN					;													<SM7>
@@ -294,7 +305,7 @@ FindStartupDevice	PROC	EXPORT
 			BLS.S	@nosleep
 @sleepnow
 			LEA		pmCommandPB(A4), A0			; A0 gets pointer to parameter block
-			MOVE.W	#SleepReq, pmCommand(A0)	; PMGR command, Go to sleep
+			MOVE.W	#PmgrPWRoff, pmCommand(A0)
 			MOVE.W	#4, pmLength(A0)			; Four bytes of data to send
 			LEA		pmData(A0), A1
 			MOVE.L	A1, pmSBuffer(A0)			; pointer to send buffer
@@ -307,16 +318,48 @@ FindStartupDevice	PROC	EXPORT
 			ENDWITH
 		ENDIF									;													<SM7>
 
-			CMPI.W	#FloppyRefNum,D4			; do we have floppy set as the default?
-			BEQ.S	@NoChange					; -> yes, keep looking for floppies
-			LEA		IsItAnything,A3				; no, from now on, any device will do
-@NoChange
+
+			Move.L	D7, D7
+			BNE.B	@twenty_six
+			SubA.L	A0, A0
+			_InternalWait
+			BNE.B	@skip_blah
+			MoveQ.L	#$19, D0
+@skip_blah
+			MulU	#$3C, D0
+			Add.L	-$56(A4), D0
+			Cmp.L	(Ticks), D0
+			BCS.B	@twenty_six
+			MoveQ.L	#$F, D0
+			Add.L	(Ticks), D0
+@before_cmp
+			Cmp.L	(Ticks), D0
+			BCC.B	@before_cmp
+			Bra.B	@after_less_stuff
+@twenty_six
+			MoveQ.L	#$1, D7
+			Lea.L	IsItAnything, A3
+@after_less_stuff
+			IMPORT	ATAGiveTime
+			Bsr.L	ATAGiveTime
+@after_stuff
+
+
 			BSR		LoadSCSIDrivers				; load more drivers if we can
+			BSR		OpenLANDiskDriver
 
 @TryAgain
 			BSR		VisualUpdate				; Update dynamic user feedback
 
+			IMPORT	PMIDLERELATEDDRIVERCALL
+			BSR.L	PMIDLERELATEDDRIVERCALL
+			IMPORT	INTERC_2750
+			BSR.L	INTERC_2750
+
+
 @FirstEntry
+			BSR		DaFuq
+
 			BSR		FindNextCandidate			; Find the next potential Startup Device.
 			BEQ.S	@NextPass					; Branch if we're at the end of the queue.
 
@@ -381,6 +424,7 @@ EmbarkOnSearch
 			SUBQ.W	#4,SP						; make room for parameters on the stack
 			MOVE.L	SP,A0						;  and point to them
 			_GetDefaultStartup					; get info about the default device
+			CLR		-4(A4)
 			MOVE.L	(SP), startPRAM(A4)			; store for later partition check
 			MOVE.W	(SP)+,D3					; D3.L = <xx><xx><device-ID><partition>
 			MOVE.W	(SP)+,D4					; get the driver's refNum/<slot#><sRsrc#>
@@ -413,19 +457,8 @@ EmbarkOnSearch
 
 			SUBA.L	A2,A2						; initialize the drive queue pointer
 
-			LEA		IsItFloppyOrDefault,A3		; ASSUME match default or floppy devices.
+			LEA		IsItDefault,A3
 
-	CASE	OBJ
-			IMPORT	Ck4OnlyLoadFromDefault		; :SCSIMgr4pt3:BootItt.a
-			BSR.L	Ck4OnlyLoadFromDefault		; supposed to limit our search to default device?
-	CASE	OFF
-			BEQ.S	@ck4NoDefault
-			LEA		IsItDefault, A3				; match only default device
-@ck4NoDefault			
-			TST.B	noDefaultDrive(A4)			; is there a default drive?	<MC2>
-			BEQ.S	@HaveDefault				; -> yes
-			LEA		IsItAnything,A3				; no, match any device
-@HaveDefault
 			MOVE.L	Ticks,flashTime(A4)			; let flash time expire immediately.
 			CLR.W	D6							; clear visual state information.
 
@@ -453,9 +486,8 @@ EmbarkOnSearch
 			move.w	D4, D1					; get refNum (maybe)
 			not.w	D1						; convert refNum to unit number
 			sub.w	#$20, D1				; convert to SCSI ID
-			blt.s	@exit					; out of range -> use previous value
 			cmpi.w	#$07, D1
-			bgt.s	@exit					; out of range -> use previous value
+			bhi.s	@exit					; out of range -> use previous value
 
 			move.b	SCSIPoll, D0
 			and.b	#$F8, D0				; strip out old internal HD SCSI ID
@@ -569,9 +601,7 @@ LoadSlotDrivers
 
 LoadSCSIDrivers
 	IF hasAsyncSCSI THEN
-			BSR.L	ISITT						; check if we're running SCSI 4.3
-			TST.B	D0							; are we?
-			BEQ.S	@UseOldSCSI					; -> no, use the old code to load drivers
+			CLR.B	forcedBoot(A4)
 
 			PEA		forcedBoot(A4)				; ptr to flag indicating a forcedBoot
 			CLR.L	-(SP)						; load all drivers
@@ -589,26 +619,99 @@ LoadSCSIDrivers
 			RTS	
 @UseOldSCSI
 	ENDIF
-	
-; there is a new mechanism to disable loading of poll drive, so, check power
-; user command, "command, shift, option and delete keys", if those keys are
-; not down, go load the poll drive.
-; Make sure that command, shift, option and delete keys are not down
-
-			MOVEQ	#-1,D0						; try to load all SCSI devices
-			CMPI.W	#CmdShiftOptDel,KeyMap+6	; are command, shift, option and delete keys down?
-			BNE.S	@GoLoadD					; -> no, continue
-			MOVEQ	#$07,D1
-			AND.B	SCSIPoll,D1					; get the SCSI ID of the poll drive
-			BCLR	D1,D0						;  and clear the bit in the available drive list
-
-@GOLoadD	move.l	d6,-(sp)					; save d6										<LW3>pdw
-			move.l	a0,-(sp)					; save a0
-			moveq.l	#0, D6						; allow drivers to munge heap					<LW3>pdw
-			BSR.L	SCSILoad					; try to load driver(s) from disk
-			move.l	(sp)+,a0					; restore a0
-			move.l	(sp)+,d6					; restore d6									<LW3>pdw
-			RTS
+
+
+
+
+LoadATADrivers
+			BTst.B	#$7, ($B23)
+			BEQ		@L3
+			MoveM.L	D1-D7/A0-A6, -(A7)
+			Move	D4, -$8(A4)
+			Move.L	-$C(A4), D5
+			Move.L	#$FF, D2
+			Move.L	D5, D1
+			AndI	#$F800, D1
+			CmpI	#$2000, D1
+			BEQ.B	@L0
+			AndI.L	#$FFFF00FF, D3
+			CmpI	#$FFCA, D5
+			BEQ.B	@L0
+			Bra.B	@L2
+@L0			_DisableDynWait
+			_GetTimeOut
+			BNE.B	@L1
+			MoveQ.L	#$19, D0
+@L1			Move.L	D0, -(A7)
+			MoveQ.L	#$0, D0
+			Move.B	-$9(A4), D0
+			LsL		#$8, D0
+			Move.B	-$C(A4), D0
+			Move.L	D0, -(A7)
+			IMPORT	ATAMgr_5d9b0
+			BSR.L	ATAMgr_5d9b0
+			AddQ	#$8, A7
+			CmpI	#$0, D0
+			BEQ.B	@L2
+			Move	D0, -$8(A4)
+			IMPORT	ATAGiveTime
+@L2			BSR.L	ATAGiveTime
+			MoveM.L	(A7)+, D1-D7/A0-A6
+			Move	-$8(A4), D4
+@L3			Rts
+
+
+
+PostATA
+			MoveM.L	D0-D3/A0-A2, -(A7)
+			MoveA.L	([$2B6],$288), A2
+
+			Move.L	A2, D0
+			BEQ.B	@return
+			Move	$6(A2), D1
+			MoveQ.L	#$0, D2
+
+@loop		MoveA.L	$14(A2,D2.L), A1
+			Move.L	A1, D0
+			BEQ.B	@return
+			Move	$C8(A1), D0
+
+			Clr		D3
+			Cmp		D3, D0
+			BEQ.B	@skip
+			MoveA.L	$C4(A1), A0
+			Move.L	A0, D0
+			BEQ.B	@return
+			Jsr		(A0)
+			Bra.B	@return
+			
+@skip		AddQ	#$4, D2
+			SubQ	#$1, D1
+			BNE.B	@loop
+
+@return		MoveM.L	(A7)+, D0-D3/A0-A2
+			Rts
+
+
+
+OpenLANDiskDriver
+			Lea.L	@DriverName, A1
+			Lea.L	-$32(A7), A7
+			MoveA.L	A7, A0
+			Move.L	A1, $12(A0)
+			DC.W	$A000
+			Tst		D0
+			BNE.B	@L7
+			Move	$18(A0), D4
+@L7			Lea.L	$32(A7), A7
+			Rts
+
+			STRING	Pascal
+@DriverName	DC.B	'.LANDisk'
+			ALIGN	2
+
+
+
 
 
 ;________________________________________________________________________________________
@@ -655,9 +758,7 @@ WaitForPollDrive
 @WaitForIt
 
 		IF hasAsyncSCSI THEN
-			BSR.L	ISITT						; check if we're running SCSI 4.3
-			TST.B	D0							; are we?
-			BEQ.S	@UseOldSCSI					; -> no, use the old code to load drivers
+			CLR.B	forcedBoot(A4)
 			PEA		forcedBoot(A4)				; ptr to flag indicating a forcedBoot
 			PEA		1							; only look for the startup device
 			BSR.L	ITTBOOT						; get the startup device's refnum in D0
@@ -676,47 +777,7 @@ WaitForPollDrive
 @UseOldSCSI
 	ENDIF
 
-; make sure that command, shift, option and delete keys are not down
-		
-			MOVE.W	KeyMap+6,D0					; get keys down
-			CMP.W	#CmdShiftOptDel,D0			; are command, shift, option and delete keys down?
-			BEQ.S	@RawExit					; -> exit if so
-
-			MOVEQ	#$07,D1
-			AND.B	SCSIPoll,D1					; Get SCSI ID of poll drive
-			MOVEQ	#0,D0						; Clear register
-			BSET	D1,D0						; Set the bit for the drive
-
-; Call SCSILoad with bit map in D0 and heap_munge_flag in D6
-
-			move.l	d6,-(sp)					; save d6										<LW3>pdw
-			move.l	a0,-(sp)					; save a0
-			moveq.l	#0, D6						; allow drivers to munge heap					<LW3>pdw
-			BSR.L	SCSILoad					; Try to load driver for poll disk
-			move.l	(sp)+,a0					; restore a0
-			move.l	(sp)+,d6					; restore d6									<LW3>pdw
-			BEQ.S	@MyExit						; Branch if warmed up, but driver is invalid
-
-			MOVEQ	#IntHDRefNum,D0				; Refnum for ID 0
-			SUB.W	SCSIPoll,D0					; Convert to refnum for poll drive
-			MOVE.W	D0,D1						; Put back in D1 for comparison
-			
-			
-; Let's see if the poll hard disk is actually in the queue
-@ExamDQ		SUBA.L	A2,A2						; Start at beginning of drive queue
-@FindIntHD	
-			BSR		NextDQEntry					; Get the next drive queue entry
-			BEQ.S	@EndOfQueue					; Branch if we're out of queue entries
-
-			CMP.W	dqRefNum(A2),D1				; Is it our trusty poll hard disk?
-
-			BNE.S	@FindIntHD					; Nope, see if the next one's it
-
-@Warm_n_Toasty									; We found the drive; it must have warmed up
-			BRA.S	@MyExit						; That's all folks
-
 @ckTimeout
-@EndOfQueue
 			CMP.L	Ticks,D5					; Should the poll HD be visible by now?
 			BLO.S	@NoDrivePresent				; Yes, so quit waiting for it
 			MOVEQ.L	#PollDelay,D0				; Get number of ticks to wait before retrying
@@ -969,6 +1030,7 @@ Ck4SupportsPartition
 ; now check this driver to see if it "follows new rules" and responds
 ;	to driverGestalt status call
 ;
+			move.l	(A0), A0
 			move.w	dCtlFlags(A0), D0				; does it Follow New Rules?
 			btst	#FollowsNewRules, D0			; (word-relative bit #)
 			beq.s	@notSupported					; no -> skip driverGestalt call
@@ -1010,9 +1072,29 @@ Ck4SupportsPartition
 ;________________________________________________________________________________________
 
 IsItDefault
+			tst		-4(A4)
+			bne.s	@skipsomestuff
+
+			pea.l	-4(A4)
+			import	GetStartupDevice
+			jsr		GetStartupDevice			; (CDG5) native StartLib
+			lea.l	$4(SP), SP
+			tst		D0
+			bne.s	@notTheDisk
+@skipsomestuff
+			
+			move	-4(A4), D0
+			cmp		6(A2), D0
+			beq.s	@isTheDisk
+			bra.s	@notTheDisk
+
 			cmp.w	dqRefNum(A2), D4			; is this driver for the default device?
 			bne.s	@notTheDisk					; no-> definitely no the disk then
 
+			import	ZeroD0
+			bsr		ZeroD0
+			bne.s	@notTheDisk
+
 			move.b	#1, foundDrvr(A4)			; so we know to clr ckPartition if end-of-Q
 			tst.b	ckPartition(A4)				; do we need to check the partition num?
 			beq.s	@isTheDisk					; no-> well then, it is the right disk
@@ -1085,7 +1167,16 @@ ItsDefault	RTS									;  and return BEQ if so
 ;________________________________________________________________________________________
 
 IsItAnything
-			CMP		D0,D0						; return BEQ
+			CMP		8(A2), D4
+			BNE.S	@beq
+
+			BSR		ZeroD0
+			BNE.S	@bne
+
+@beq		MOVEQ.L	#0, D0
+			RTS
+
+@bne		MOVEQ.L	#1, D0
 			RTS
 
 
@@ -1129,15 +1220,18 @@ VisualUpdate
 @NoSwitch	BCHG	#FlashParity,D6				; Switch parity.
 			BNE.S	@XorQ						; Branch if we need X or ? showing.
 			LEA		DiskIcon,A0					; plot the plain disk icon
+			MOVE	#-20021,D0
 			BRA.S	PlotMyIcon
 
 @XorQ		TST.B	D6							; Are we showing an ?
 			BEQ.S	@ShowQ						; Branch if so.
 			SUBQ.B	#1,D6						; Eventually, we go back to a ?.
 			LEA		XDiskIcon,A0				;  but for now, plot the disk icon with the X
+			MOVE	#-20023,D0
 			BRA.S	PlotMyIcon
 
 @ShowQ		LEA		QDiskIcon,A0				; plot the disk icon with the question mark
+			MOVE	#-20022,D0
 			BRA.S	PlotMyIcon
 
 @DoneDisk	RTS
@@ -1158,7 +1252,73 @@ VisualUpdate
 
 HappyMac	BSR.S	EraseMyIcon					; erase what's on the screen where the icon goes
 			LEA		HappyIcon,A0				; plot the happy mac icon
-			BSR.S	PlotMyIcon
+			MOVE	#-20020,D0
+
+
+;________________________________________________________________________________________
+;
+; Routine:	PlotMyIcon
+;
+; Inputs:	A0	-	pointer to ICN# to plot
+;			D0	-	ID of cicn to try first
+;
+; Outputs:	none
+;
+; Trashes:	D0-D2, A0-A1
+;
+; Function:	plots an icon, centered on the main video device
+;________________________________________________________________________________________
+
+PlotMyIcon
+			MOVE.L	A0,-(SP)
+			MOVE	#$FFFF,ROMMapInsert
+			SUBQ	#4,SP
+			MOVE	D0,-(SP)
+			_GetCIcon
+			MOVE.L	(SP)+,D2
+			MOVE.L	(SP)+,A0
+
+			BEQ.S	@useOld
+
+			MOVE.L	D2,-(SP)
+			BSR		PushIconRect
+			MOVE.L	SP,-(SP)
+			MOVE.L	D2,-(A7)
+			_PlotCIcon
+			ADDQ	#8,SP
+			_DisposeCIcon
+			RTS
+
+@useOld		MOVE.L	A0,D2						; save the pointer to the ICN#
+
+;  put the source bitmap on the stack (icon's bit image)
+
+			BSR.S	PushIconRect				;  bounds = 32x32 rectangle, centered on the main screen
+			MOVE.W	#32/8,-(SP)					;  rowBytes
+			MOVE.L	D2,-(SP)					;  baseAddr = pointer to the icon
+
+;  put the mask bitmap on the stack (icon's mask image)
+
+			LEA		bitMapRec(SP),A0			; point to the end of this bitmap so we can make a copy
+			MOVE.L	-(A0),-(SP)					;  bounds
+			MOVE.L	-(A0),-(SP)
+			MOVE.W	-(A0),-(SP)					;  rowBytes
+			MOVEA.L	-(A0),A1
+			PEA		128(A1)						;  baseAddr = pointer to icon's mask
+
+;  now copy the icon to the screen using CopyMask...
+
+			MOVE.L	A0,-(SP)					;  srcBits
+			PEA		4(SP)						;  maskBits
+			MOVEA.L	grafGlobals(A5),A1			; point to QuickDraw's globals
+			MOVEA.L	thePort(A1),A1				; and from there get the current grafport
+			PEA		portBits(A1)				;  dstBits
+			PEA		bounds(A0)					;  srcRect
+			MOVE.L	(SP),-(SP)					;  maskRect
+			MOVE.L	(SP),-(SP)					;  dstRect
+			_CopyMask							; blast it
+
+			LEA		2*bitmapRec(SP),SP			; clean up the stack
 			RTS
 
 
@@ -1175,61 +1335,31 @@ HappyMac	BSR.S	EraseMyIcon					; erase what's on the screen where the icon goes
 ; Function:	erases the ICN# in the center of the main screen
 ;________________________________________________________________________________________
 
-EraseMyIcon	MOVEM.L	D0-D2/A0-A1,-(SP)
+EraseMyIcon	MOVEM.L	D0-D2/A0-A2,-(SP)
 			BSR.S	PushIconRect				; push the icon's rectangle onto the stack
 			MOVE.L	SP,-(SP)					;  and point to it
-			MOVE.L	grafGlobals(A5),A0			; point to the QuickDraw globals
-			PEA		gray(A0)					;  and use 50% gray as the background
+
+
+
+			MOVE.L	grafGlobals(A5),A2			; point to the QuickDraw globals
+			TST.B	($B3E)
+			BNE.S	@anyway
+			MOVE.L	ExpandMem,A0
+			TST.B	$341(A0)
+			BEQ.B	@otherthing
+@anyway		PEA.L	@theColor
+			_RGBForeColor
+			PEA.L	-16(A2)
+			BRA.S	@ffs
+@otherthing
+			PEA.L	-24(A2)
+@ffs
 			_FillRect							; erase the rectangle with the desktop pattern
 			ADDQ.W	#8,SP						; clean up the stack
-			MOVEM.L	(SP)+,D0-D2/A0-A1
+			MOVEM.L	(SP)+,D0-D2/A0-A2
 			RTS
 
-
-;________________________________________________________________________________________
-;
-; Routine:	PlotMyIcon
-;
-; Inputs:	A0	-	pointer to ICN# to plot
-;
-; Outputs:	none
-;
-; Trashes:	D0-D2, A0-A1
-;
-; Function:	plots an icon, centered on the main video device
-;________________________________________________________________________________________
-
-PlotMyIcon	MOVE.L	A0,D2						; save the pointer to the ICN#
-
-;  put the source bitmap on the stack (icon's bit image)
-
-			BSR.S	PushIconRect				;  bounds = 32x32 rectangle, centered on the main screen
-			MOVE.W	#32/8,-(SP)					;  rowBytes
-			MOVE.L	D2,-(SP)					;  baseAddr = pointer to the icon
-
-;  put the mask bitmap on the stack (icon's mask image)
-
-			LEA		bitMapRec(SP),A0			; point to the end of this bitmap so we can make a copy
-			MOVE.L	-(A0),-(SP)					;  bounds
-			MOVE.L	-(A0),-(SP)
-			MOVE.W	-(A0),-(SP)					;  rowBytes
-			MOVEA.L	-(A0),A1
-			PEA		128(A1)						;  baseAddr = pointer to icon's mask
-
-;  now copy the icon to the screen using CopyMask...
-
-			MOVE.L	A0,-(SP)					;  srcBits
-			PEA		4(SP)						;  maskBits
-			MOVEA.L	grafGlobals(A5),A1			; point to QuickDraw's globals
-			MOVEA.L	thePort(A1),A1				; and from there get the current grafport
-			PEA		portBits(A1)				;  dstBits
-			PEA		bounds(A0)					;  srcRect
-			MOVE.L	(SP),-(SP)					;  maskRect
-			MOVE.L	(SP),-(SP)					;  dstRect
-			_CopyMask							; blast it
-
-			LEA		2*bitmapRec(SP),SP			; clean up the stack
-			RTS
+@theColor	DC.W	$8888, $8888, $8888
 
 
 ;________________________________________________________________________________________
@@ -1322,7 +1452,54 @@ XDiskIcon	DC.L	$7FFFFFF0,$81000108,$81007104,$81008902,$81008901,$81008901,$8100
 			DC.L	$FFFFFFFF,$FFFFFFFF,$FFFFFFFF,$FFFFFFFF,$FFFFFFFF,$FFFFFFFF,$FFFFFFFF,$FFFFFFFE
 
 		ENDWITH
-			ENDPROC
+;			ENDPROC
+
+
+
+
+
+
+
+DaFuq ; proc export ; but has no callers yet?
+;			IMPORT	NextDQEntry
+;			IMPORT	SelectDevice
+;			IMPORT	GetStartupInfo
+
+
+			MOVEM.L	D0-D2/A0-A2,-(SP)
+			SUB.L	A2,A2
+@loop
+			MOVE	#$A002,D0
+			_GetOSTrapAddress
+			MOVE.L	ROMBase,A1
+			CMP.L	A0,A1
+			BCS.S	@return
+			BSR		NextDQEntry
+			BEQ.S	@return
+			BSR		SelectDevice
+			BSR		GetStartupInfo
+			BRA.S	@loop
+@return
+			MOVEM.L	(SP)+,D0-D2/A0-A2
+			RTS
+
+;			ALIGN	16
+
+
+
+
+
+
+
+ZeroD0 PROC	EXPORT
+			MOVEQ.L	#0, D0
+			RTS
+
+;			ALIGN	16
+
+
+
+
 
 
 
@@ -1665,104 +1842,6 @@ AppPhne			EQU		$09961010
 			ENDPROC
 
 
-;________________________________________________________________________________________
-;
-; Routine:	Ck4LimitPRAMClear
-;
-; Inputs:	none
-;
-; Outputs:	Z:	NE = only boot from Default device
-;				EQ = boot from Floppy or Default
-; 			D0:	NE = only boot from Default device
-;				EQ = boot from Floppy or Default
-;
-; Trashes:	D0, A0
-;
-;________________________________________________________________________________________
-
-Ck4LimitPRAMClear	PROC	EXPORT
-
-			IMPORT	ValidatePRAM76					; StartSearch.a
-			bsr		ValidatePRAM76
-			subq.w	#2,sp							; allocate buffer on stack
-			movea.l	sp, A0							; get buffer ptr
-			MOVE.L	#$00010076, D0					; Read 1 bytes starting at loc $76
-			_ReadXPRam
-			move.b	(sp)+, D0
-			and.b	#1, D0							; low bit
-			rts
-
-			ENDPROC
-		
-			
-;________________________________________________________________________________________
-;
-; Routine:	ValidatePRAM76
-;
-; Inputs:	none
-;
-; Outputs:	none
-;
-; Trashes:	none
-;
-; Function:	Validates byte $76 of xpram: counts set bits in lower 6 and compares with
-;			upper two bits.  If not equal, zeros out the byte.
-;
-; Note: Byte $76 (previously reserved but used by OSDefault stuff) is
-;		being defined as sensitive boot bits generally having to do with
-;		security issues driven by AIX but these functions can be used
-;		by other OSes as well.  The upper two bits of byte $76 are a
-;		"checksum" of the other 6 bits (i.e. count of bits set).  This
-;		is desired because of the danger if one of these bits is set 
-;		accidentally by some bogus client.  Failing this checksum will
-;		cause the byte to revert to 00 - a safe value. Currently defined
-;		bits are:
-;			0: limit PRAM clear - don't clear PSWD, AUXPRAM, OSType, DefBoot
-;			1: only load drivers from default device, don't boot from floppy
-;			2: ignore CmdShiftOptDel
-;
-;________________________________________________________________________________________
-vp76trashedRegs	REG	D0-D2/A0
-
-ValidatePRAM76	PROC	EXPORT
-
-			movem.l	vp76trashedRegs, -(sp)
-			
-			subq.w	#2, sp							; allocate buffer on stack
-			movea.l	sp, A0							; get buffer ptr
-			MOVE.L	#$00010076, D0					; Read 1 bytes starting at loc $76
-			_ReadXPRam								; Get it from PRAM.
-			move.b	(sp)+, D0
-			
-			move.b	#0, D2							; zero reg for addx
-			moveq.l	#0, D1							; clear checksum
-			and.b	#$3F, D0						; get data bits (strip sum bits)
-@bitloop			
-			lsr.b	#1, D0							; get a bit
-			addx.b	D2, D1							; add that bit to checksum
-			tst.b	D0								; loop until no more bits
-			bne.s	@bitloop
-			
-			and.b	#3, D1							; only 2 low bits are valid
-			
-			move.b	(A0), D0						; get byte 76 again
-			lsr.b	#6, D0							; get only checksum bits
-			
-			cmp.b	D0, D1							; valid signature?
-			beq		@valid							; Yes, don't clear all
-
-			move.b	#00, -(sp)						; clean up bogus value
-			movea.l	sp, A0							; get buffer ptr
-			move.l	#$00010076, D0					; get #, addr PRAM bytes
-			_WriteXPram								; write out zeros to 76
-			move.b	(sp)+, D0
-@valid
-			movem.l	(sp)+, vp76trashedRegs
-			rts
-			
-			ENDP
-			
-
 ;----------------------------------------------------------------------	
 ; Get information about the current default video device.
 ;
diff --git a/OS/SysUtil.a b/OS/SysUtil.a
--- a/OS/SysUtil.a
+++ b/OS/SysUtil.a
@@ -311,12 +311,22 @@ SetDateTimeTrap
 ;
 ;______________________________________________________________________
 
-DelayTrap	ANDI.W 	#$F8FF,SR			; have to let interrupts in 			<SM7> rb
-			MOVE.L	Ticks,D0
-			ADD.L	A0,D0
+DelayTrap	MOVEM.L	D1-D3/A0-A1,-(SP)
+			ANDI.W 	#$F8FF,SR			; have to let interrupts in 			<SM7> rb
+			MOVE.L	Ticks,D3
+			ADD.L	A0,D3
+			BRA.S	@enter
 
-@1			CMP.L	Ticks,D0			; have enough ticks ticked?
+@1			CLR.L	-(SP)
+			MOVE.L	#$10,-(SP)
+			MOVE	#$FFCB,-(SP)
+			DC.W	$AA7F				; InternalWait?
+			ADDQ.L	#4,SP
+
+@enter		CMP.L	Ticks,D3			; have enough ticks ticked?
 			BHI.S	@1					; -> No. Keep waiting.			<SM9> (now use unsigned comparison)
+			MOVE.L	D3,D0
+			MOVEM.L	(SP)+,D1-D3/A0-A1
 			RTS
 
 
@@ -1012,9 +1022,12 @@ InitUtil	CLR.W	-(SP)					; assume no reset of PRam values				<30Oct85> LAK
 			DBRA	D1,@1
 
 			BSR 	WritePram				; and put initial values into clk chip
+			LEA.L	SysParam,A0				; don't trust the above WriteParam?
+			MOVE.B	#$A8,(A0)
+			MOVE.L	#$10010,D0
+			_WriteXPRam
 
-CkNewPram	BTST	#6,HWCfgFlags			; new clock chip present?						<30oct85> BBM
-			BEQ.S	ClkXit					; exit if not									<30oct85> BBM
+CkNewPram
 			LEA 	GetParam,A0 			; get pointer to useful buffer					<30oct85> BBM
 
 			MOVE.L	#$4000C,D0				; Command to read 4 bytes at addr C 			<30oct85> BBM
@@ -1026,10 +1039,6 @@ CkNewPram	BTST	#6,HWCfgFlags			; new clock chip present?						<30oct85> BBM
 			BEQ.S	ClkXit					; exit if so									<30oct85> BBM
 
 			MOVE.W	#PRInitErr,(SP) 		; report non-zero result						<30Oct85> LAK
-			MOVE.L	D1,(A0) 				; store out true validity bytes 				<30oct85> BBM
-			MOVE.L	#$4000C,D0				; Command to write 4 bytes at addr C			<30oct85> BBM
-			_WriteXPRam 					;												<30oct85> BBM
-
 			MOVEQ	#32,D1					; starting address to clear out XPRam			<30oct85> BBM
 @0			MOVEQ	#4,D0					; number of bytes to write
 			SWAP	D0						; finish the command byte						<30oct85> BBM
@@ -1041,25 +1050,23 @@ CkNewPram	BTST	#6,HWCfgFlags			; new clock chip present?						<30oct85> BBM
 			CMP.B	#8,D1					; Check if we wrote the last address			<30oct85> BBM
 			BNE.S	@0						; if not loop back untill we are done			<30oct85> BBM
 
-			MOVEM.L	A1,-(SP)				;Save A1
 			LEA		PRAMInitTbl,A0			;Copy the data from the PRAMInit table.			<C518>
-			LEA		GetParam,A1				;  into the GetParam buffer.					<C518>
-			MOVEQ	#5-1,D0					;Loop 5 times  (20 bytes)						<C518><C779>
-@10			MOVE.L	(A0)+,(A1)+				;Copy 4 bytes									<C518>
-			DBRA	D0,@10					;Branch if not done.							<C518>
+			LEA		ReadTime,A1
 
-			MOVE.L	#$00140076,D0			;Write 20 bytes beginning at PRAM address $76	<C518><C779>
-			LEA		GetParam,A0				;  from the buffer								<C518>
-			_WriteXPRam 					;  into the PRAM.								<C518>
+			SUB.L	A0,A1
+			MOVE.L	A1,D0
+			SWAP	D0
+			ORI		#$76,D0
+			_WriteXPRam
 
-	; Write the default memory mgr flags to location $8A.  Since this is the only xpram whose default
-	; is non zero, we write it explicitly (as opposed to writing a default table full of zeros)			<MC2>
+			LEA.L	GetParam,A0
+			MOVE.L	#'NuMc',(A0)
+			MOVE.L	#$4000C,D0
+			_WriteXPRam
 
-			LEA		MMFlags,A0				; Point A0 at the Memory Manager flags lomem				<MC2>
-			MOVE.B	#MMFlagsDefault,(A0)	; Put the default MMFlags into MMFlags
-			MOVE.L	#MMPRAMloc,D0			; Write MMFlags to PRAM
-			_WriteXPRam 					; Store it.
-			MOVEM.L	(SP)+,A1				;Restore A1
+			IMPORT	InterC_29c0_Wireless
+			MACHINE	MC68030
+			BSR.L	InterC_29c0_Wireless
 
 ClkXit		MOVE.W	(SP)+,D0				; pass back error code							<30oct85> LAK
 			BNE.S	@1						; br if we had to reset clock/pram				<30oct85> LAK
@@ -1070,7 +1077,7 @@ ClkXit		MOVE.W	(SP)+,D0				; pass back error code							<30oct85> LAK
 
 ;  original 20-byte parameter RAM initialization values
 
-PRAMInit	DC.B	$A8						; old PRAM validity byte						<2.7>
+PRAMInit	DC.B	$77						; old PRAM validity byte						<2.7>
 			DC.B	0						; AppleTalk node ID hint for modem port			<2.7>
 			DC.B	0						; AppleTalk node ID hint for printer port		<2.7>
 			DC.B	(0<<4)+(0<<0)			; serial port usage		= neither port in use	<2.7>
@@ -1107,7 +1114,7 @@ PRAMInit	DC.B	$A8						; old PRAM validity byte						<2.7>
 			DC.B	((32/4)<<4)+ \			; •	double-click time	= 32 ticks				<2.7>
 					(32/4)					; •	caret-blink time	= 32 ticks				<2.7>
 
-			DC.B	3						; ram cache size in 32K blocks (96k default)	<SM9>
+			DC.B	32						; ram cache size in 32K blocks (96k default)	<SM9>
 
 			DC.B	(1<<7)+ \				; •	color desk pattern	= 1 (use if CQD around)	<2.7><H5/6>
 					(1<<6)+ \				; •	mouse scaling		= 1 (on)				<2.7>
@@ -1118,7 +1125,7 @@ PRAMInit	DC.B	$A8						; old PRAM validity byte						<2.7>
 											;Start Manager									<C518>
 PRAMInitTbl	DC.B	00						;  [$76]		Reserved.						<C518>
 			DC.B	01						;  [$77]		Default OS.						<C518>
-			DC.W	$FFFF,$FFDF				;  [$78-$7B]	Default boot.					<C774>
+			DC.W	$0000,$6666				;  [$78-$7B]	Default boot.					<C774>
 			
 											;Sound Manager?									<C518>
 			DC.W	0						;  [$7C-$7D]	Sound alert id					<C518>
@@ -1135,6 +1142,32 @@ PRAMInitTbl	DC.B	00						;  [$76]		Reserved.						<C518>
 											;Reserved										<C779>
 			DC.B	0,0						;  [$88-$89]									<C779>
 
+
+OtherDamnTable
+			DC.L	$25000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000070
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000000
+			DC.L	$00000001
+			DC.W	$000A
+
 ;________________________________________________________________________________________
 ;
 ; Routine:	ReadTime
@@ -1485,163 +1518,4 @@ Exit	MOVE.W	D2,D0					; put error number in D0
 		RTS								; return to caller (Return address should be on stack)
 
 		ENDPROC							; SysEnvirons								<C982>
-
-;----- <2.4>
-;
-;	The Reliability Manager 
-;
-;	This new "manager" is responsible for monitoring the operation of the machine
-;	and recording pertinent information in parameter RAM.
-;
-;	Written by Bob Herold, May 24, 1989
-;
-;-----
-
-;-----
-;	InitReliability - sets time of 1st power on, and initializes the Usage Statistics time 
-;					  manager task
-;
-;	The time of 1st power on is kept as the number of 48 hour periods since Jan 1 1989.  To
-;	calculate this, we first get the number of seconds since Jan 1 1989.  On 020 and higher
-;	machines, we could divide by the number of seconds in 48 hours.  To work on 68000
-;	machines, we separate out factors of two to get the divisor into the 16 bit range:
-;
-;			# 48 hrs since Jan 1 1989	= (# secs since Jan 1 1989) / (# secs in 48 hours)
-;										= (# secs) / (60 * 60 * 24 * 2)
-;										= (# secs) / (2*2*15) * (2*2*15) * (2*2*2*3) * 2
-;										= (# secs) / (15 * 15 * 3) * 2^^8
-;										= ((# secs) / 2^^8) / (15 * 15 * 3)
-;---						
-
-InitReliability	PROC	EXPORT
-			IMPORT		RelTimeTask, RelDeferredTimeTask
-			
-			IF hasPowerMgr THEN
-			rts
-			ELSE
-
-;---
-;	Initialize the 'time of 1st power on'
-;---
-
-			subq		#RelPram>>16,sp				; allocate buffer on stack
-			move.l		Time,d1						; get current # secs
-			sub.l		#Jan1st89,d1				; get # secs since Jan 1 1989
-			blo.s		@doneStart					; if earlier, clock chip set wrong!
-			movea.l		sp,a0						; get buffer ptr
-			move.l		#RelPram,d0					; get #, addr PRAM bytes
-			_ReadXPram								; read 'em and weep
-			move.l		(sp),d0						; get 'da bytes
-			and.l		#Rel1stMask,d0				; mask all except 1st powered on time
-			bne.s		@doneStart					; if already set, do nothing
-			lsr.l		#8,d1						; divide # secs by 2^^8
-			divu.w		#15*15*3,d1					; get # 48 hour periods (see comment above)
-			moveq		#Rel1stBit,d0				; get shift count
-			lsl.l		d0,d1						; shift our value into position
-			and.l		#Rel1stMask,d1				; mask unneeded high bits
-			and.l		#-1-Rel1stMask,(sp)			; zero our bits in result
-			or.l		d1,(sp)						; overlay our value into result
-			move.l		#RelPram,d0					; get #, addr PRAM bytes
-			_WriteXPram								; write out 1st power on time
-@doneStart	addq		#RelPram>>16,sp				; de-allocate buffer
-
-;---
-;	Set up time manager task for power on time measurement
-;---
-
-			WITH		RelGlobals
-			
-			moveq		#rlRecSize,d0				; get size Reliability Mgr globals
-			move.b		d0,d1						; save for later
-			_NewPtr		,sys,clear					; allocate space for it
-			bne.s		@done						; don't bother if no room
-			move.l		ExpandMem,a1				; get ptr to low memory expansion
-			move.l		a0,ExpandMemRec.emReliability(a1) ; save ptr to Reliability globals there
-			move.b		d1,rlGlobalsSize(a0) 		; save size of globals
-			move.b		#rlRecVers,rlGlobalsVers(a0); save version number of globals
-			bclr		#usRelTaskRun,UnSwitchedFlags; signal we are timing
-
-; Initialize a deferred task queue element to schedule execution of the original Time Manager
-; task, now called RelDeferredTimeTask. Pass a pointer to the Time Manager task in dtParm so
-; that the original code still gets its expected parameter in A1.
-
-			move.w		#dtQType,rlDeferredTask.qType(a0)
-			lea			RelDeferredTimeTask,a1
-			move.l		a1,rlDeferredTask.dtAddr(a0)
-			lea			rlTimeBlock(a0),a1
-			move.l		a1,rlDeferredTask.dtParm(a0)
-			
-			lea			rlTimeBlock(a0),a0			; point to time manager task block
-			lea			RelTimeTask,a1				; point to our time task
-			move.l		a1,tmAddr(a0)				; stuff it into task block
-			_InsXTime								; install our task
-			move.l		#RelMsCount,d0				; get # ms between calls
-			clr.l		tmWakeUp(a0)				; signal its the first time
-			_PrimeTime								; fire up time mgr task			
-@done		rts
-
-			ENDWITH									; {RelGlobals}
-
-			ENDIF
-
-			ENDPROC									; {InitReliability}
-			
-
-;-----
-;	RelTimeTask - the time manager task for doing all this reliability stuff
-;
-;	Called by the Time Manager
-;
-;	Entry
-;		a0 - points to this routine (not too useful, huh?)
-;		a1 - points to task block (now there's something useful!)
-;
-;
-;	RelDeferredTimeTask - the deferred Time Manager task for doing all this reliability stuff
-;
-;	Called by the Deferred Task Manager
-;
-;	Entry
-;		A1 - dtParm points to the originating Time Manager task block
-;---
-
-RelTimeTask	PROC	EXPORT
-
-; If PRAM is in Egret/CUDA, _ReadXPram and _WriteXPram require interrupts enabled
-; to execute efficiently. Therefore, the periodic Reliability task now uses the
-; Deferred Task Manager to be more interrupt-friendly.
-
-; This helps MIDI SysEx dumps and other interrupt tasks run more punctually.
-
-			lea			tmXQSize(a1),a0				; deferred task element follows TM task element
-			_DTInstall
-			rts
-			
-
-			entry		RelDeferredTimeTask
-
-RelDeferredTimeTask
-
-			subq		#RelPram>>16,sp				; allocate buffer on stack
-			movea.l		sp,a0						; get buffer ptr
-			move.l		#RelPram,d0					; get #, addr PRAM bytes
-			_ReadXPram								; read 'em and weep
-			move.l		(sp),d0						; get 'da bytes
-			move.l		d0,d1						; save a copy
-			and.l		#RelPwrMask,d0				; mask to get power on time
-			addq.l		#1,d0						; increment power on time
-			and.l		#RelPwrMask,d0				; mask again, in case of rollover
-			and.l		#-1-RelPwrMask,d1			; zero power on time bits
-			or.l		d0,d1						; replace the power on time bits
-			move.l		d1,(a0)						; put new PRAM value in buffer
-			move.l		#RelPram,d0					; get #, addr PRAM bytes
-			_WriteXPRAM								; write 'em back
-			addq		#RelPram>>16,sp				; deallocate buffer
-			move.l		a1,a0						; get ptr to task block
-			move.l		#RelMsCount,d0				; get # ms between calls
-			_PrimeTime								; re-fire up time mgr task
-			rts
-
-			ENDPROC									; {RelTimeTask}
-			
 		END
diff --git a/OS/TrapDispatcher/Dispatch.a b/OS/TrapDispatcher/Dispatch.a
--- a/OS/TrapDispatcher/Dispatch.a
+++ b/OS/TrapDispatcher/Dispatch.a
@@ -225,6 +225,7 @@ Dispatcher 	proc	export
 			export	BadTrap
 			import	SysErr1
 			import	BlockMove68020
+			import	FLUSHCRANGE
 	If hasNewHeapMgr Then
 			import	PramIO				; <SM8 BT>
 	endif
@@ -342,13 +343,21 @@ EMT1010		equ		ATrap68020
 FindTableEntry
 			_AssumeEq	OldDisp,ToolDisp-1	; OldDisp is next to, and lower than ToolDisp
 			lsl.w	#16-ToolDisp,d1		; ccr.c <- ToolDisp, ccr.n <- OldDisp
-			bpl.s	@oldTrap			; if OldDisp = 0, it's an old style trap
+			bpl.s	@newOldTrap			; if OldDisp = 0, it's an old style trap
 			bcc.s	@osTrap				; if ToolDisp = 0, it's a new style OS trap
 										; otherwise, it's a new style ToolBox trap
 
 @toolTrap	andi.w	#numTrapMask,d0		; clear all but trap bits
 			lea		(ToolTable,d0.w*4),a1	; index into the Toolbox table
-			bra		CacheFlush			; flush inst cache and return (destroys only reg D1)	<SM14>
+			rts
+
+@newOldTrap	bcc.s	@oldTrap
+			move.l	d0,d1
+			btst.l	#11,d1
+			bsr.s	@toolTrapInstead
+			subi	#$c000,d1
+			cmpi	#$1000,d1
+			rts
 
 @oldTrap	andi.w	#$01FF,d0			; clear irrelevant bits
 			moveq.l	#-$0057,d1			; setup to check for ToolBox range
@@ -358,10 +367,11 @@ FindTableEntry
 			addq.w	#$0057-$004F,d1		; d1 := TrapNum - $004F
 			ble.s	@osTrap				; $0000 … $004F are OS traps
 			subq.w	#$0054-$004F,d1		; d1 := TrapNum - $0054
+@toolTrapInstead
 			bne.s	@toolTrap			; $0054 is an OS trap, $50…$53,$55,$56 are tool box
 @osTrap		andi.w	#$00FF,d0			; only 8 bits for OS trap numbers
 			lea		(OSTable,d0.w*4),a1	; index into the OS table
-			bra.s	CacheFlush			; flush inst cache and return (destroys only reg D1)
+			rts
 
 			Title	'Dispatch - Get / Set Trap Address'
 
@@ -383,10 +393,8 @@ kComeFromHeader			equ		(kBranchOverJMPLOpcode << 16) + kJMPLOpcode		;	<SM14>
 
 GetTrapAddressTrap						; <SM3> rb
 
-			bsr		TrapAddressBits			; makes sure trap word is correct		<SM14>begin
-			move	ccr,-(sp)				; save condition register
-			bsr.s	OldGetTrapAddress		; call the old GetTrapAddress
-			move	(sp)+,ccr				; get condition codes back
+			bsr.s	FindTableEntry
+			move.l	(a1),a0
 			bcs.s	@done					; come-from patches bypass our trickery
 @next
 			cmp.l	#kComeFromHeader,(a0)	; does this have the come-from header?
@@ -397,13 +405,6 @@ GetTrapAddressTrap						; <SM3> rb
 			moveq	#0,d0					; must zero the result code again
 			rts
 
-OldGetTrapAddress							;									;	<SM14>end
-
-			bsr.s	FindTableEntry		; locate the dispatch table entry
-			movea.l	(a1),a0				; get the routine address from the table
-			moveq.l	#noErr,d0			; return with success
-			rts							; all done
-
 
 ;_______________________________________________________________________
 ;
@@ -423,29 +424,28 @@ SetTrapAddressTrap						; <SM3> rb
 
 			move.l	(a0),d2					; get header of trap, and check for bus errors		<5><SM14>begin
 
-			bsr		TrapAddressBits			; makes sure trap word is correct			<SM4> rb
+			bsr.s	FindTableEntry			; locate the dispatch table entry
+
+			exg.l	d0,a0
 			bcs.s	OldSetTrapAddress		; come-from patches bypass our trickery
 
 			cmp.l	#kComeFromHeader,d2		; headers can only be used on come-from patches		<5>
 			beq.s	@illegalHeader			; saw a header, so I must system error				<5>
 
-			movem.l	d0-d1/a0,-(sp)			; save trap address, number, and bits
-			bsr		OldGetTrapAddress		; call the old GetTrapAddress
-			move.l	#0,a1					; no come-froms found yet
-@next
+			movea.l	(a1),a0
+
 			cmp.l	#kComeFromHeader,(a0)+	; does this have the come-from header?
-			bne.s	@done					; no we are done
+			bne.s	OldSetTrapAddress
+@next
 			move.l	a0,a1					; remember this address
 			move.l	(a0),a0					; go on to the next
-			bra.s	@next
-@done
-			movem.l	(sp)+,d0-d1/a0			; restore trap address, number, and bits
+			cmp.l	#kComeFromHeader,(a0)+	; does this have the come-from header?
+			beq.s	@next
+			move.l	d0,(a1)
 
-			cmp.l	#0,a1					; any come-froms found?
-			beq.s	OldSetTrapAddress		; no, go do the real SetTrapAddress
-			move.l	a0,(a1)					; set the trap address
-			move.l	jCacheFlush,-(sp)		; get the cache flush vector						<9>
-			rts								; call it, and then return to the trap dispatcher	<9>
+			lea		-2(a1),a0
+			lea		6,a1
+			bra.l	FLUSHCRANGE
 
 @illegalHeader
 			move.w	#dsBadPatchHeader,d0	; get error code									<5>
@@ -453,16 +453,13 @@ SetTrapAddressTrap						; <SM3> rb
 
 OldSetTrapAddress
 	
-			bsr.s	FindTableEntry			; locate the dispatch table entry
-			move.l	a0,(a1)					; install the new routine address into the table
+			move.l	d0,(a1)					; install the new routine address into the table
 			moveq.l	#noErr,d0				; return with success
-
-			move.l	jCacheFlush,-(sp)		; get the cache flush vector						<9>
-			rts								; call it, and then return to the trap dispatcher	<9><SM14>end
+			rts
 
 ;_______________________________________________________________________
 ;
-; Macros:		CacheFlush, vCacheFlush
+; Macros:		CacheFlush, vCacheFlush, DummyCacheFlush
 ;
 ; Function: 	Flush the 68020 Cache.  For programs that do self modifying code, etc.
 ;
@@ -481,13 +478,6 @@ CacheFlush
 			rts							; jump through the vector
 
 vCacheFlush
-			move.l	d1,-(SP)			; save this f*&%$ng register						<5>
-			movec.l	cacr,d1				; get current cache state of 68020
-			addq.w	#1<<3,d1			; flush the instruction cache				<1.4>
-			movec.l	d1,cacr				; write back to the control register
-			move.l	(SP)+,d1			; restore register									<5>
-			rts							; all done
-
 vCacheFlush68040						; 68040 cache flushing for self-modifying programs	<3>
 
 ;	NOTE - since the 040 I-Cache never gets "dirty", it only needs to be invalidated.		<3>
@@ -502,6 +492,9 @@ vCacheFlush68040						; 68040 cache flushing for self-modifying programs	<3>
 			rts							; return to caller - no registers destroyed			<3>
 
 			MACHINE	MC68020				; reset to previous MACHINE directive				<3>
+
+DummyCacheFlush
+			rts
 			Title	'Dispatch - InitDispatcher'
 
 ;_______________________________________________________________________
@@ -666,18 +659,14 @@ OSLoop		move.l	(a2)+,d1			; get the next entry from the ROM dispatch table
 	EndIf	;	Not NewBuildSystem
 ;	now install the trap dispatcher
 
+			btst.b	#2,$240a
+			beq.s	@noInstallFlusher
+			lea		DummyCacheFlush,a0
+			move.l	a0,jCacheFlush
+@noInstallFlusher
+
 			lea		EMT1010,a0			; point to the dispatcher
 
-			TestFor has68kEmulator		; Are we emulating a 68020?										<SM7> SAM
-			beq.s	@noEmu				; -> Nope.														<SM7>
-			lea		Rts020Disp,A1		; Point A1 to an rts (hopefully near some cache resident code)	<SM7>
-			bra.s	@StuffFlush			; -> Install it													<SM7>
-			
-@noEmu		cmpi.b	#cpu68040,CpuFlag	; check if we need to install 040 Cache Flush routine	<3>
-			bne.s	@notAn040			; NO  ... perform 020/030 cache-flush					<3>
-			lea		vCacheFlush68040,a1	; YES ... get addr. of 040 cache flush routine			<3>
-@StuffFlush	move.l	a1,jCacheFlush		; ... and install it									<3>
-@notAn040								;														<3>
 			move.l	a0,Line1010			; install the Line-A exception handler
 			
 		IF forRomulator THEN			; register the Line-A handler with the nub 				<SM6>
@@ -711,60 +700,5 @@ BadTrap
 ; <SM4> rb, start 		from PatchProtector.a
 
 
-TrapAddressBits	proc	export
-
-; TrapAddressBits
-;
-;	In:
-;		d0.w	trap number
-;		d1.w	[GS]etTrapAddress trap word
-;
-;	Out:
-;		d1.w	(modified) [GS]etTrapAddress trap word
-;		ccr		CC if it is not a come-from, CS if it is a come-from
-
-; bits in trap numbers and Set/GetTrapAddress opcodes
-
-TrapNumber				record	0
-toolboxBit				equ		11
-						endr
-
-TrapAddressOpcode		record	0
-newBit					equ		9
-toolboxBit				equ		10
-						endr
-
-		btst	#TrapAddressOpcode.newBit,d1		; is this N[GS]etTrapAddress?
-		bnz.s	@notFullWord						; yes, don’t handle it
-		btst	#TrapAddressOpcode.toolboxBit,d1	; is this normal [GS]etTrapAddress?
-		bz.s	@notFullWord						; yes, don’t handle it
-
-@fullWord
-		; adjust the trap bits
-
-		bset	#TrapAddressOpcode.newBit,d1		; is this NGetTrapAddress?
-		btst	#TrapNumber.toolboxBit,d0			; is the trap a Toolbox trap?
-		bnz.s	@toolbox							; yes, leave the bit set
-		bclr	#TrapAddressOpcode.toolboxBit,d1	; clear bit for OS
-@toolbox
-
-		cmp.w	#$C000,d0					; is this a come-from trap word?
-		blo.s	@notComeFrom				; no, it is not
-		cmp.w	#$D000,d0					; is it a come-from trap word?
-		bhs.s	@notComeFrom				; no, it is not
-@comeFrom
-		; oooh... carry is set for us, we can return
-		rts
-
-@notFullWord
-@notComeFrom
-		and		#$FE,ccr					; clear the carry bit
-		rts
-
-				endproc
-
-; <SM4> rb, end
-
-
 			end
 
diff --git a/OS/Universal.a b/OS/Universal.a
--- a/OS/Universal.a
+++ b/OS/Universal.a
@@ -427,7 +427,7 @@ JumpIntoROM
 @TryAgain	moveq.l	#0,d2				; figure it out from scratch
 			bsr6	GetHardwareInfo		; figure out what we are running on
 			btst.l	#ROMExists,d0		; see if we have a ROM
-			beq.s	@TryAgain			; if not, we're screwed, but try again anyway
+			beq.s	norom				; if not, we're screwed
 
 ;	Now figure out what the new base of ROM should be,
 
@@ -453,6 +453,7 @@ intoROM									; now we are in ROM
 
 			adda.l	d3,sp				; relocate the stack to rom addresses			<T13>
 
+norom
 			lea		GotBusError,a0		; get the handler address						<T12>
 			move.l	a0,d0				; value to search for							<T12>
 @loop		cmp.l	-(a0),d0			; check for a match								<T12>
@@ -478,8 +479,6 @@ intoROM									; now we are in ROM
 
 @TryAgain	moveq.l	#0,d2				; figure it out from scratch					<T12>
 			bsr6	GetHardwareInfo		; figure out what we are running on				<T12>
-			btst.l	#ROMExists,d0		; see if we have a ROM							<T12>
-			beq.s	@TryAgain			; if not, we're screwed, but try again anyway	<T12>
 		  
 	IF NOT ROMinRAM THEN				;												<SM22> rb
 			bsr6	InitVIAs			; initialize the VIAs (turns off vOverlay)		<T12>
@@ -502,33 +501,14 @@ intoROM									; now we are in ROM
 			move.l	d0,d3				; save a copy of d0								<SM11>
 			move.l	#EgretFWMask,d0		; mask for Egret Firmware						<SM10>{rbm}<2>
 			and.l	d1,d0				; isolate the field								<SM10>{rbm}<2>
-			sub.l	#Egret8,d0			; see if we have Egret FW						<SM10>{rbm}<2>
-			beq.w	@DoEgretInit		; do Egret 8 FW INIT, LC/si			<SM10>{rbm}<2>	<SM38>
-			sub.l	#Egret8,d0			; see if we have Caboose FW						<SM10>{rbm}<2>
-			beq.s	@CudaDone			; just exit Quadra900		<SM10>{rbm}<2>	<SM39> PN
-			sub.l	#Egret8,d0			; see if we have Cuda FW						<SM10>{rbm}<2>
+			beq.s	@CudaDone
+
+			cmpi.l	#$3000000, D0
 			bne.s	@CudaDone			; if not, just exit								<SM10>{rbm}<2>
 
 	IF NOT ROMinRAM THEN				;												<SM22> rb
 			BigBSR6	CudaInit			;Setup Cuda Sysnc Ack with System				<SM10>{rbm}<2>
-			bra.s	@CudaDone			;														<SM38>
 	ENDIF								;												<SM22> rb
-@DoEgretInit							;														<SM38>
-			movea.l	DecoderInfo.VIA1Addr(a0),a1	; get VIA 1 base address						<SM38>
-			move.w	#4000,d0			;														<SM38>
-@wait	
-		eieioSTP	
-			tst.b	(a1)				; sync to hardware for 1.2µS per access					<SM38>
-		
-			dbra	d0,@wait			; Egret must see idle before command, it's busy			<SM38>
-										; doing ADB reset for 3mSec so delay in idle state		<SM38>
-		eieioSTP	
-			move.l	#(NopCmd<<16)|pseudoPkt,d0 ;												<SM38>
-			moveq	#0,d2				; no bytes to send										<SM38>
-			bsr6	SendEgretCmd		; send the command to disable async. messages			<SM38>
-			moveq.l	#0,d2				; figure it out from scratch							<SM38>
-			bsr6	GetHardwareInfo		; restore all the registers we trashed 					<SM38>
-			move.l	d0,d3				; by calling SendEgretCmd								<SM38>
 @CudaDone
 			move.l	d3,d0				; restore d0									<SM11>
 	
@@ -786,10 +766,8 @@ intoROM									; now we are in ROM
 
 			move.l	VIA1Addr(a0),a2				; get VIA1 address to get machine/cpu_speed info
 			moveq	#%00101000,d3				; force VIA1 VDirA to have the correct directions
-	eieioSTP
 			move.b	d3,VDirA(a2)				; ... so we can read the CPU ID extension info
 			moveq	#%00010100,d3				; get VBufA, bits PA4, PA2 (dont need PA6, PA1)
-	eieioSTP
 			and.b	VBufA(a2),d3				; get plastics_type/cpu_speed information
 @hasValue	lsr.b	#2,d3						; shift over to get PA2 in LSBit
 			btst	#4-2,d3						; test PA4.  remember it's been shifted from bit pos. 4->2
@@ -802,7 +780,6 @@ intoROM									; now we are in ROM
 			tst.w	(@MachineTbl,d4.w*2)		; if entry is zero, you've hit EndOfTable
 			beq.s	@unknownMachine				; deal with unknown machine
 			moveq.l	#%01010110,d0				; CPU ID mask value for VIA
-	eieioSTP
 			and.b	VBufA(a2),d0				; get CPU ID value
 			cmp.b	(@MachineTbl+1,d4.w*2),d0	; is it this machine?
 			bne.s	@nextEntry					; no, try again
@@ -922,11 +899,10 @@ intoROM									; now we are in ROM
 		ALIGN	16						; <60><62> rb, for the 040 emulator...
 
 			dc.l	0,0,0,0								; end of list
-			dc.l	(GotBusError-BaseOfRom)+$40A00000	; base of Elsie II ROM			<SM22> rb
-			dc.l	(GotBusError-BaseOfRom)+$00A00000	; base of Elsie ROM		<51>
 			dc.l	(GotBusError-BaseOfRom)+$40000000	; alternate base of normal ROM <58> rb
 			dc.l	(GotBusError-BaseOfRom)+$40800000	; base of normal ROM
 			dc.l	(GotBusError-BaseOfRom)+$00000000	; base of overlay ROM
+			dc.l	(GotBusError-BaseOfRom)+$FFC00000	; base of NewWorld ROM?
 		
 GotBusError	btst.l	#beok,d7			; indicate that bus error occured
 			move.l	a5,a7				; restore stack
@@ -962,9 +938,6 @@ InitVIAs
 			movea.l	VIA1Addr(a0),a2		; get VIA base address					<SM5> rb
 			movea.l	a1,a3				; get product info ptr					<SM5> rb
 			adda.l	VIA1InitPtr(a3),a3	; point to the init info				<SM5> rb
-
-			btst.l	#PSCExists,d0		; is this a Cyclone ?			<SM5> rb<SM4> rb, start <SM26>
-			beq.s	@WombatVIAInit		; if not, check if we're a Wombat
 ;
 ;	This change is valid only for the Cyclone VIA1 Info Table...  
 ;	The other machine tables will have to be updated to follow this initialization
@@ -972,68 +945,16 @@ InitVIAs
 ;	in a different order than in previous ROMS...  THIS MUST BE UPDATED!!!!
 ;	gjs	????
 ;
-		eieioSTP
-			move.b	(a3)+,vDirA(a2)		; init direction for port A				<P9> gjs
-		eieioSTP
 			move.b	(a3)+,vBufA(a2)		; init output port A					<P9> gjs
-		eieioSTP
-			move.b	(a3)+,vDirB(a2)		; init direction for port B				<P9> gjs
+			move.b	(a3)+,vDirA(a2)		; init direction for port A				<P9> gjs
 		eieioSTP
 			move.b	(a3)+,vBufB(a2)		; init output port B					<P9> gjs
+			move.b	(a3)+,vDirB(a2)		; init direction for port B				<P9> gjs
 		eieioSTP
 			move.b	(a3)+,vPCR(a2)		; init peripheral control reg			<SM7> rb
-		eieioSTP
 			move.b	(a3)+,vACR(a2)		; init auxiliary control reg			<SM7> rb
-		eieioSTP
 			move.b	#$7F,vIER(a2)		; Disable all VIA interrupts.			<SM7> rb
-		eieioSTP
-			bra.s	@VIA1done			; cool, keep going						<SM5> rb
 
-@WombatVIAInit							;										<SM31>
-	IF hasDJMEMC THEN					;										<SM36> rb
-			cmpi.b	#djMEMCDecoder,d2	; are we on a Wombat?					<SM31><SM41>
-			bne.s	@doOldVIAInit		; if not, initialize VIAs the old way	<SM31><SM41>
-		eieioSTP
-			move.b	(a3)+,vBufA(a2)		; init output port A					<SM31>
-		eieioSTP
-			move.b	(a3)+,vDirA(a2)		; init direction for port A				<SM31>
-		eieioSTP
-			move.b	#$1C,vACR(a2)		; enable shift-out on ACR						<H25><SM31>
-		eieioSTP
-			move.b	#0,vSR(a2)			; preset shift register with an ADB resetCmd	<H25><SM31>
-		eieioSTP
-			move.b	(a3)+,vBufB(a2)		; init output port B							<SM31>
-		eieioSTP
-			move.b	(a3)+,vDirB(a2)		; init direction for port B				<SM31>
-		eieioSTP
-			move.b	-2(a3),vBufB(a2)	; (re-)init output port B				<H25><SM31>
-		eieioSTP
-			move.b	(a3)+,vPCR(a2)		; init peripheral control reg			<SM31>
-		eieioSTP
-			move.b	(a3)+,vACR(a2)		; init auxiliary control reg			<SM31>
-		eieioSTP
-			move.b	#$7F,vIER(a2)		; Disable all VIA interrupts.			<SM31>
-		eieioSTP
-			bra.s	@VIA1done			; cool, keep going						<SM31>
-	ENDIF								;										<SM36> rb
-	
-@doOldVIAInit								;									<SM4> rb, start
-		eieioSTP
-			move.b	(a3)+,vBufA(a2)		; init output port A
-		eieioSTP
-			move.b	(a3)+,vDirA(a2)		; init direction for port A
-		eieioSTP
-			move.b	(a3)+,vBufB(a2)		; init output port B
-		eieioSTP
-			move.b	(a3)+,vDirB(a2)		; init direction for port B
-		eieioSTP
-			move.b	(a3)+,vPCR(a2)		; init peripheral control reg
-		eieioSTP
-			move.b	(a3)+,vACR(a2)		; init auxiliary control reg
-		eieioSTP
-			move.b	#$7F,vIER(a2)		; Disable all VIA interrupts.
-		eieioSTP
-	
 @VIA1done
 			btst.l	#VIA2Exists,d0		; see if we have VIA2
 			beq.s	@VIA2done			; if not, skip it
@@ -1048,40 +969,27 @@ InitVIAs
 			
 			
 			Move.b	PSCVIA2SInt(A2), D3	; get PortA (slots) current values
-		eieioSTP
 			Or.b	(A3)+, D3			; or in via2 init info values
-		eieioSTP
 			Move.b	D3, PSCVIA2SInt(A2)	; save new values
-		eieioSTP
 			Move.b	#$7F, PSCVIA2IER(A2) ; disable all VIA2 interrupts.
-		eieioSTP
 			Move.b	#$40, PSCVIA2IFR(A2) ; clear sound frame int.
-		eieioSTP
 			Bra.s	@VIA2done			; this takes care of Cyclones
 	
 		
 @NonPSC									;										<SM4> rb, end <SM26>
 	ENDIF								;										<SM36> rb
 	
-		eieioSTP
 			move.b	vBufA(a2),d3		; get current values
-		eieioSTP
 			or.b	(a3)+,d3			; or in the default values
-		eieioSTP
 			move.b	d3,vBufA(a2)		; init output port A
-		eieioSTP
 			move.b	(a3)+,vDirA(a2)		; init direction for port A
 		eieioSTP
 			move.b	(a3)+,vBufB(a2)		; init output port B
-		eieioSTP
 			move.b	(a3)+,vDirB(a2)		; init direction for port B
 		eieioSTP
 			move.b	(a3)+,vPCR(a2)		; init peripheral control reg
-		eieioSTP
 			move.b	(a3)+,vACR(a2)		; init auxiliary control reg
-		eieioSTP
 			move.b	#$7F,vIER(a2)		; Disable all VIA2 interrupts.
-		eieioSTP
 
 ; Simulate the Macintosh VBL interrupt by using timer 1 to output a square wave on PB7 of VIA #2.
 ; On NuMac, this output is tied to the CA1 pin of VIA #1 which is used for VBL on a Mac.
@@ -1095,71 +1003,10 @@ InitVIAs
 
 @T2Count	equ		((704*370)/20)/2-2	; VIA ticks per half-cycle
 
-		eieioSTP
 			move.b	#@T2Count**$FF,vT1C(a2) ; Load low byte into counter/latch.
-		eieioSTP
 			move.b	#@T2Count>>8,vT1CH(a2)	; Load high byte and off we go!
-		eieioSTP
 @VIA2done
 
-			btst.l	#RBVExists,d0		; see if we have an RBV
-			beq.s	@RBVdone			; if not, skip it
-
-			movea.l	RBVAddr(a0),a2		; get RBV base address
-		eieioSTP
-			move.b	#$7F,RvIER(a2)		; disable all  interrupts
-		eieioSTP
-			move.b	#$8F,RvDataB(a2)	; initialize data reg. B			<1.3>
-		eieioSTP
-
-			BTST	#MSCChipBit,D1		; are we using an MSC variant?					<H8>
-			BEQ.S	@NoMSC				; -> no, continue on							<H29><SM31>
-
-;	This is the point where we check to see if an external FPU is attached to 				<H31>
-;	the system.  In the	 case of Escher, the onboard FPU will power up disabled,			<H31>
-;	but we want to enable it here if we don't detect anything else sitting on 				<H31>
-;	the coprocessor bus.																	<H31>
-;
-;	The idea is to move VBR DOWN the difference between the F-Line and
-;	BusError, so that if you were to execute an F-Line instruction and
-;	couldn't handle it, you would end up fetching the address of the
-;	BusErrVector and going thru the BusErrVector.  The BusErr handler
-;	expects A6 to contain the address of where it should return TO.
-
-			movec	VBR,d3					; retrieve VBR									
-			sub.l	#Line1111-BusErrVct,d3	; temporarily move VBR down
-			movec	d3,VBR					; shuffle VBR for F-Line test
-			moveq	#1,d3					; non-zero value in D3 for later comparison
-			move.l	a7,a5					; sp to restore if you dont have an FPU
-			move.l	a6,a3					; save return address
-			bset	#beok,d7				; set bus error expected flag
-			lea		@noFPU,a6				; where to come back to if you dont have an FPU
-
-			FNOP							; execute suspect command
-			clr.l	d3						; if you got here, you already have an FPU
-
-@noFPU		tst.b	d3						;
-			beq.s	@ignore					; already using an FPU so ignore internal
-			bclr	#MSCEnableFPU,RvDataB(a2);enable onboard FPU
-@ignore
-			movec	VBR,d3					; return VBR to it's old value
-			add.l	#Line1111-BusErrVct,d3
-			movec	d3,VBR					; ... so everyone is happy						
-			bclr	#beok,d7				; release bus error expected flag				
-			move.l	a3,a6					; restore return address						<H31>
-
-			MOVE.B	#$7F,RvSEnb(A2)		; disable all slot interrupts					<H29><SM31>
-		eieioSTP
-			RTS6						;												<H29><SM31>
-@NoMSC									;												<H29><SM31>
-
-		eieioSTP
-			move.b	#1<<RvVIDOff,RvMonP(a2)	; turn off onboard video					<SM31>
-		eieioSTP
-			move.b	#$FF,RvSEnb(a2)		; set all slots to be interrupt enabled			<SM31>
-		eieioSTP
-@RBVdone
-
 			rts6
 
 
@@ -1205,6 +1052,13 @@ GetHardwareInfo
 			bra		HasNoCPUIDReg		;	->CONTINUE in GetHardwareInfo using old recognition method <SM7> rb
 @foundCPUIDReg							; ENDIF
 
+
+			cmpi.l	#'Hnfo',([$68FFEFD0],$70)	; NKHWInfo.Signature, fix this later
+			bne.s	@tryOldWay
+			import	InfoNewWorld
+			biglea	InfoNewWorld,a1
+			bra		Matched
+@tryOldWay
 			biglea	CPUIDProductLookup-4,a2	; get address of CPUID product lookup table
 @MatchLoop								; LOOP (through product info entries to match CPU ID)
 			addq.w	#4,a2				;	bump to next entry
@@ -1217,10 +1071,6 @@ GetHardwareInfo
 			btst	#11,d0				;	is the complete CPU ID in the CPUID register?
 			beq		Matched				;	-> yes, we've got it
 
-			cmpi.b	#PrattDecoder,\			;	IF Decoder is a Pratt THEN								<K4>
-						DecoderKind(a1)		;		Found Match											<K4>
-			beq		Matched					;		{ For Now just handle one case }					<K4>
-
 			movea.l	DecoderInfoPtr(a1),a0 ;	get the pointer to this machine's decoder table
 			adda.l	a1,a0
 			move.l	DefaultBases(a0),d0	;	 and get the default bases flags
@@ -1280,19 +1130,137 @@ UnknownCPU	bra.s	UnknownCPU			; Ack!
 HasNoCPUIDReg							; fall through to @MatchLoop
 
 			tst.b	d2					; check address decoder kind
-			beq.s	FindDecoder			; if unknown decoder, search for it.
+			beq		FindDecoder			; if unknown decoder, search for it.
 
 ;	The ProductKind and DecoderKind are setup in D2, find the matching ProductInfo record.
 
 			biglea	ProductLookup-4,a0	; point before the first product to check for
 @MatchLoop	addq.w	#4,a0				; point to next product to check for
 			move.l	(a0),d0				; see if end of list reached
-			beq.s	FindDecoder			; if end, look start over, looking for decoder first
+			beq		FindDecoder			; if end, look start over, looking for decoder first
 			lea		(a0,d0.l),a1		; a1 := pointer to ProductInfo record
 			cmp.w	ProductKind(a1),d2	; see if product and decoder match
 			bne.s	@MatchLoop			; if not, keep searching
 
 FoundMatch
+			Move.L    BasesValid1(A1), D0
+			BTst.L    #$1E, D0
+			BEQ       @skipAllThis
+			MoveA.L   ([$68FFEFD0],$8), A0 ; NKHWInfo.UniversalInfoTableBase
+			Move.B    $12(A1), D0
+			Move.B    D0, $12(A0)
+			Move      $14(A1), D0
+			Move      D0, $14(A0)
+			Move.B    $16(A1), D0
+			Move.B    D0, $16(A0)
+			Move      $10(A1), D0
+			Or        D0, $10(A0)
+			MoveA.L   (A0), A2
+			AddA.L    A0, A2
+			Move.L    $24(A1), D0
+			Or.L      D0, $24(A0)
+			Or.L      D0, -$1C(A2)
+			Move.L    $28(A1), D0
+			Or.L      D0, $28(A0)
+			Or.L      D0, -$18(A2)
+			Move.L    $2C(A1), D0
+			Or.L      D0, $2C(A0)
+			Or.L      D0, -$14(A2)
+			MoveA.L   A1, A2
+			SubA.L    A0, A2
+			Move.L    A1, D0
+			MoveA.L   $8(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $8(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $4(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $4(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $C(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $C(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $38(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $38(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $3C(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $3C(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $40(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $40(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $44(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $44(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $48(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $48(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $4C(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $4C(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $50(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $50(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $64(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $64(A0)
+			MoveA.L   D0, A1
+			MoveA.L   $5C(A1), A1
+			Tst.L     A1
+			BEQ.B     (* + $4)
+			AddA.L    A2, A1
+			Move.L    A1, $5C(A0)
+			MoveA.L   D0, A2
+			MoveA.L   A2, A1
+			Move.B    $68(A1), D0
+			Move.L    D0, $68(A0)
+			MoveQ.L   #$0, D0
+			Move      ([$68FFEFD0],$76), D0 ; NKHWInfo.CPU_ID
+			Move      D0, $58(A0)
+			biglea    CPUIDProductLookup,a2
+			Lea.L     $8(A2), A2
+			Tst.L     (A2)
+			BEQ.B     @is_single_entry_table
+			Cmp.L     (A2), D0
+			BNE.B     (* + -$A)
+			Move.L    $4(A2), D0
+			Bra.B     @common_path
+@is_single_entry_table
+			Move.L    $60(A1), D0
+@common_path
+			Move.L    D0, $60(A0)
+			MoveA.L   A0, A1
+@skipAllThis
 
 			movea.l	DecoderInfoPtr(a1),a0	; get offset to DecoderInfo record
 			adda.l	a1,a0				; make it absolute
@@ -1331,39 +1299,16 @@ MapFound	movea.l	d0,a2				; now save return address in A2
 			and.l	VIAIdMask(a1),d0	; mask them
 			cmp.l	VIAIdMatch(a1),d0	; see if they match
 			bne.s	@MatchLoop			; if not, try the next product
-			bra.s	FoundMatch			; if found, return the info
+			bra		FoundMatch			; if found, return the info
 
 
 CheckBases
 			move.l	DefaultBases(a0),d0	; get the default base flags
 			movea.l	a6,a0				; save return address
-			btst.l	#RBVExists,d0		; see if RBV might be allowed
-			beq.s	@RBVDone			; if not, don't test for one
-			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info
-			movea.l	RBVAddr(a1,a2.l),a2
-			lea		RvIER(a2),a2		; base address of RBV VIER register
-			bsr6	TestForRvIER		; see if RBV exists
-			beq.s	@RBVDone			; if found, has RBV and VDAC
-			bclr.l	#RBVExists,d0		; no RBV, clear the bit
-			bclr.l	#VDACExists,d0		; if no RBV, then assume no VDAC either
-@RBVDone
-
-			bclr.l	#VIA2Exists,d0		; see if VIA2 might be allowed
+			bclr.l	#VIA2Exists,d0
 			beq.s	@VIA2Done			; if not, don't test for one
 			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info
-			movea.l	VIA2Addr(a1,a2.l),a2	; get VIA2 base address
-	
-	IF hasPSC THEN							;									<SM36> rb
-			btst.l	#PSCExists, D0			; do we have PSC?					<SM4> rb, start  <SM26>
-			Beq.s	@noPSC					; no, do horror style VIA2 init		<SM26>
-
-			
-			lea		PSCVIA2IER(a2),a2		; base address of PSC VIA2 VIER register
-			Bra.s	@gotVIA2
-
-@noPSC									;										<SM26>
-	ENDIF								;										<SM36> rb
-	
+			movea.l	VIA2Addr(a1,a2.l),a2
 			lea		VIER(a2),a2			; base address of VIA2 VIER register
 @gotVIA2								;										<SM4> rb, end
 			bsr6	TestForVIER			; see if VIA2 exists
@@ -1371,31 +1316,6 @@ CheckBases
 			bset.l	#VIA2Exists,d0		; has VIA2, set the bit
 @VIA2Done
 
-	IF hasIopSwim THEN					;										<SM36> rb
-			bclr.l	#SWIMIOPExists,d0	; see if SWIMIOP might be allowed
-			beq.s	@SWIMIOPDone		; if not, don't test for one
-			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info
-			movea.l	SWIMIOPAddr(a1,a2.l),a2
-			bsr6	TestForIOP			; see if SWIM IOP exists
-			bne.s	@SWIMIOPDone		; if not found, has regular IWM
-			bclr.l	#IWMExists,d0		; no regular IWM, clear the bit
-			bset.l	#SWIMIOPExists,d0	; has SWIMIOP, set the bit
-@SWIMIOPDone
-	ENDIF								;										<SM36> rb
-	
-	IF hasIopScc THEN					;										<SM36> rb
-			bclr.l	#SCCIOPExists,d0	; see if SCCIOP might be allowed
-			beq.s	@SCCIOPDone			; if not, don't test for one
-			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info
-			movea.l	SCCIOPAddr(a1,a2.l),a2
-			bsr6	TestForIOP			; see if SCC IOP exists
-			bne.s	@SCCIOPDone			; if not found, has regular SCC
-			bset.l	#SCCIOPExists,d0	; has SCCIOP, set the bit
-			bclr.l	#SCCrdExists,d0		; no regular SCC, clear the bit
-			bclr.l	#SCCwrExists,d0		; no regular SCC, clear the bit
-@SCCIOPDone
-	ENDIF								;										<SM36> rb
-	
 			bclr.l	#SCSIDMAExists,d0	; see if SCSIDMA might be allowed
 			beq.s	@SCSIDMADone		; if not, don't test for one
 			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info
@@ -1435,57 +1355,12 @@ CheckBases
 @SCSI96Done
 	ENDIF										;											<SM36> rb
 	
-			bclr.l	#RPUExists,d0		; see if RPU might be allowed
-			beq.s	@RPUDone			; if not, don't test for one
-			movea.l	DecoderInfoPtr(a1),a2	; get offset to decoder info
-			movea.l	RPUAddr(a1,a2.l),a2
-			bsr6	TestForRPU			; see if SCSI DMA exists
-			bne.s	@RPUDone			; if not found, no parity chip
-			bset.l	#RPUExists,d0		; has SCSI DMA, set the bit
-@RPUDone
-
 			movea.l	a0,a6						; restore return address
 			movea.l	a1,a0						; get product info pointer
 			adda.l	DecoderInfoPtr(a0),a0		; get decoder info pointer
 			
 CheckOptionals
 			move.l	HwCfgWord(a1),d2			; access hardware cfg flags						<8>
-			btst.l	#hwCbFPU+16,d2				; should FPU be installed						
-			beq.s	FPUDone						; branch if it shouldn't be installed			<SM28>		
-			movea.l	a6,a2						; save return address							
-			bra		TestForFPU					; see if FPU installed							
-FPUReturn	movea.l	a2,a6						; restore return address						<SM28>
-			beq.s	FPUDone						; branch if FPU found							
-			bclr.l	#hwCbFPU+16,d2				; otherwise,clear FPU installed flag			
-
-FPUDone	
-
-			bset.l	#beok,d7					; allow bus errors						<H12><H11 begin>
-			movea.l	a7,a5						; mark the stack for bus error handler	<H12>
-
-			bclr.l	#SonicExists,d0				; see if Sonic might be allowed
-			beq.s	@SonicDone					; if not, don't test for one
-			move.l	a1,d1						; save a1								<H12>
-			move.l	SonicAddr(a0),a1			; get Sonic Base Address				<H12>
-			movea.l	a6,a2						; save return address	
-			bsr6	TestForSonic				; see if Sonic exists
-			movea.l	a2,a6						; restore return address
-			move.l	d1,a1						; restore a1							<H12>
-			bne.s	@SonicDone					; if not found, no Sonic chip
-			bset.l	#SonicExists,d0				; has Sonic, set the bit					 <H11 end>
-@SonicDone
-
-			bclr.l	#PatchROMExists,d0			; see if PatchRom might be allowed		<H14>.start
-			beq.s	@PatchROMDone				; if not, don't test for one
-			move.l	a1,d1						; save a1								<H12>
-			move.l	PatchRomAddr(a0),a1			; get PatchRom Base Address				<H12>
-			movea.l	a6,a2						; save return address	
-			bsr6	TestForPatchRom				; see if PatchRom exists
-			movea.l	a2,a6						; restore return address
-			move.l	d1,a1						; restore a1							<H12>
-			bne.s	@PatchRomDone				; if not found, no PatchRom chip
-			bset.l	#PatchRomExists,d0			; has PatchRom, set the bit				<H14>.end
-@PatchROMDone
 
 ; External features checked after CheckOptionals so that d1 can be used as a scratch register 
 CheckFeatures							;												<11>
@@ -1538,32 +1413,6 @@ CheckExtBases1
 			move.l	DefaultBases1(a0),d0	; get the default base flags for #32-63
 			movea.l	a6,a0					; save return address
 
-;---------------
-; Call "TestFor…" routines here to verify devices for #32-63							<SM17>
-;---------------
-;																					begin <SM32> fau
-;  See if we have a Muni
-
-			btst.l	#MuniExists-32,d0			; see if MUNI might be allowed
-			beq.s	@MuniDone					; if not, don't test for one
-			movea.l	DecoderInfoPtr(a1),a2		; get offset to decoder info
-			movea.l	(MUNIAddr,a1,a2.l),a2		; get MUNI's base addresses
-			bsr6	TestForMUNI					; and go test for it
-			beq.s	@MUNIDone					; if found, has MUNI
-			bclr.l	#MUNIExists-32,d0			; no MUNI, clear the bit
-@MUNIDone
-
-;  See if we have a BART																<SM53>
-
-			btst.l	#BartExists-32,d0			; see if BART might be allowed
-			beq.s	@BartDone					; if not, don't test for one
-			movea.l	DecoderInfoPtr(a1),a2		; get offset to decoder info
-			movea.l	(BartAddr,a1,a2.l),a2		; get BART's base addresses
-			bsr6	TestForBART					; and go test for it
-			beq.s	@BartDone					; if found, has BART
-			bclr.l	#BartExists-32,d0			; no BART, clear the bit
-@BartDone
-;																					end <SM32> fau
 			movea.l	a0,a6					; restore return address
 			movea.l	a1,a0					; get product info pointer
 			adda.l	DecoderInfoPtr(a0),a0	; get decoder info pointer
@@ -1697,12 +1546,9 @@ CheckForMDU
 
 			lea		CheckNextMap,a6		; if bus errors, not an MDU
 			movea.l	RBVAddr(a0),a2
-		eieioSTP
 			tst.b	(a2)				; RBV should never bus error
 			movea.l	VDACAddr(a0),a2
-		eieioSTP
 			tst.b	(a2)				; VDAC should never bus error
-		eieioSTP
 			bra.w	MapFound			; it's a MDU decoder
 	ENDIF								;										<SM36> rb
 	
@@ -1800,12 +1646,9 @@ CheckForVISADecoder
 			
 			lea		CheckNextMap,a6		; if bus errors, not an MDU
 			movea.l	RBVAddr(a0),a2
-		eieioSTP
 			tst.b	(a2)				; VISA should never bus error
 			movea.l	VDACAddr(a0),a2
-		eieioSTP
 			tst.b	(a2)				; VDAC should never bus error
-		eieioSTP
 			bra.w	MapFound			; if not, it's a VISA decoder
 	ENDIF								;											<SM36> rb
 
@@ -1977,227 +1820,30 @@ CheckForUnknown
 TestForVIER								; A2 := address of VIER register to test
 			moveq.l	#0,d2				; D2 := wrap offset to test
 TestVIERWrap							; A2 := address of VIER register to test
-		eieioSTP
 			tst.b	(a2,d2.l)			; make sure wrap address can be accessed
-		eieioSTP
 			move.b	(a2),d1				; save old VIER value
-		eieioSTP
 
 			rol.w	#8,d1				; save it in the next byte
 			st.b	d1					; test pattern := $FF
 			move.b	d1,(a2)				; set all bits of VIER
 		eieioSTP
 @loop		neg.b	d1					; pattern of bit to clear
-		eieioSTP
 			move.b	d1,(a2)				; clear the lowest order bit
+		eieioSTP
 			add.b	d1,d1				; shift the test pattern
 			beq.s	@exit				; exit when all bits shifted out
 			neg.b	d1					; convert to mask of bits that should be set
-		eieioSTP
 			cmp.b	(a2,d2.l),d1		; see if they are set at the wrap address
-		eieioSTP
 			bne.s	@exit				; if not, exit
 			cmp.b	(a2),d1				; see if they are set at the standard address
-		eieioSTP
 			beq.s	@loop				; if so, keep testing
 @exit		ror.w	#8,d1				; get saved VIER value
-		eieioSTP
 			move.b	#$7F,(a2)			; prepare to restore (clear all bits)
 		eieioSTP
 			move.b	d1,(a2)				; restore original VIER value
-		eieioSTP
 			lsr.w	#8,d1				; 0 if VIER found
 			rts6
 
-;_______________________________________________________________________
-;
-;  Routine:		TestForRvIER
-;  Inputs:		A2 - Address of the RvIER register to test
-;				A6 - return address
-;				A5, A7, D7, VBR - setup for bus error handler
-;
-;  Outputs:		ccr.z - 0 (bne) if not a valid RvIER register, or bus error.
-;					  - 1 (beq) if valid RvIER register found.
-;
-;  Destroys:	D1, D2
-;  Called by:	BSR6
-;
-;  Function:	Checks to see if the specified I/O register is a RBV IER
-;				(interrupt enable) register, by first setting all bits of
-;				the register, and then clearing each bit individually.
-;				There are some reserved bits in the RvIER register, which
-;				are ignored by this test.
-;
-;_______________________________________________________________________
-
-TestForRvIER							; A2 := address of RvIER register to test
-			move.b	(a2),d1				; save old RvIER value
-			rol.w	#8,d1				; save it in the next byte
-			st.b	d1					; test pattern := $FF
-		eieioSTP
-			move.b	d1,(a2)				; set all bits of RvIER
-@loop
-			neg.b	d1					; pattern of bit to clear
-		eieioSTP
-			move.b	d1,(a2)				; clear the lowest order bit
-			add.b	d1,d1				; shift the test pattern
-			beq.s	@exit				; exit when all bits shifted out
-			neg.b	d1					; convert to mask of bits that should be set
-		eieioSTP
-			move.b	(a2),d2				; get the RvIER value
-			eor.b	d1,d2				; compare them
-			andi.b	#$9F,d2				; ignore the reserved bits
-			beq.s	@loop				; if match found, keep testing
-@exit		ror.w	#8,d1				; get saved RvIER value
-		eieioSTP
-			move.b	#$7F,(a2)			; prepare to restore (clear all bits)
-		eieioSTP
-			move.b	d1,(a2)				; restore original RvIER value
-		eieioSTP
-			lsr.w	#8,d1				; 0 if RvIER found
-			rts6
-
-;_______________________________________________________________________
-;
-;  Routine:		TestForSCC
-;  Inputs:		A2 - Base write address of the SCC to test for.
-;				D2 - offset to SCC read base address from write base
-;				A6 - return address
-;				A5, A7, D7, VBR - setup for bus error handler
-;
-;  Outputs:		ccr.z - 0 (bne) if SCC not found, or bus error.
-;					  - 1 (beq) if valid SCC found.
-;
-;  Destroys:	D1
-;  Called by:	BSR6
-;
-;  Function:	Checks to see if the specified I/O registers point to an
-;				SCC.  The read and write addresses may be specified separatly
-;				since some address decoders require this.  An SCC is detected
-;				by writing a two byte signature to the time constant register
-;				and reading it back.  The old value is saved and restored to
-;				make this test non-destructive.  In order to meet SCC timing
-;				requirements on systems like the Mac Plus that do not provide
-;				a hardware holdoff, extra delays are introduced between SCC
-;				accesses.
-;
-;_______________________________________________________________________
-
-TestForSCC								; A2 := address of SCCrd
-										; D2 := offset of SCCwr-SCCrd
-		eieioSTP
-			tst.b	bCtl(a2,d2.l)			; reset register pointer to reg 0
-			ror.b	#8,d1				; kill some time, non-destructive
-
-		eieioSTP
-			move.b	#13,bCtl(a2)		; point to register 13, time const high
-			ror.b	#8,d1				; kill some time, non-destructive
-		eieioSTP
-			move.b	bCtl(a2,d2.l),d1	; save old time const high byte
-			ror.b	#8,d1				; kill some time, non-destructive
-		eieioSTP
-			move.b	#12,bCtl(a2)		; point to register 12, time const low
-			lsl.l	#8,d1				; make room for low byte, kill time
-		eieioSTP
-			move.b	bCtl(a2,d2.l),d1	; save old time const low byte
-			ror.b	#8,d1				; kill some time, non-destructive
-
-		eieioSTP
-			move.b	#13,bCtl(a2)		; point to register 13, time const high
-			ror.b	#8,d1				; kill some time, non-destructive
-		eieioSTP
-			move.b	#'G',bCtl(a2)		; load in signature high byte
-			ror.b	#8,d1				; kill some time, non-destructive
-		eieioSTP
-			move.b	#12,bCtl(a2)		; point to register 12, time const low
-			ror.b	#8,d1				; kill some time, non-destructive
-		eieioSTP
-			move.b	#'D',bCtl(a2)		; load in signature low byte
-			ror.b	#8,d1				; kill some time, non-destructive
-
-		eieioSTP
-			move.b	#13,bCtl(a2)		; point to register 13, time const high
-			lsl.l	#8,d1				; make room for byte, kill time
-		eieioSTP
-			move.b	bCtl(a2,d2.l),d1	; read back signature high byte
-			ror.b	#8,d1				; kill some time, non-destructive
-		eieioSTP
-			move.b	#12,bCtl(a2)		; point to register 12, time const low
-			lsl.l	#8,d1				; make room for byte, kill time
-		eieioSTP
-			move.b	bCtl(a2,d2.l),d1	; read back signature low byte
-			subi.w	#'GD',d1			; see if signature matched
-			ror.l	#8,d1				; setup to restore, kill some time
-
-		eieioSTP
-			move.b	#12,bCtl(a2)		; point to register 12, time const low
-			ror.l	#8,d1				; position saved low byte of time const
-		eieioSTP
-			move.b	d1,bCtl(a2)			; restore original time const low byte
-			ror.b	#8,d1				; kill some time, non-destructive
-		eieioSTP
-			move.b	#13,bCtl(a2)		; point to register 13, time const high
-			lsr.l	#8,d1				; get the high byte
-		eieioSTP
-			move.b	d1,bCtl(a2)			; restore original time const high byte
-
-			lsr.l	#8,d1				; test signature for match
-			rts6						; all done
-
-;_______________________________________________________________________
-;
-;  Routine:		TestForIOP
-;  Inputs:		A2 - Base address of IOP to test for.
-;				A6 - return address
-;				A5, A7, D7, VBR - setup for bus error handler
-;
-;  Outputs:		ccr.z - 0 (bne) if IOP not found, or bus error.
-;					  - 1 (beq) if valid IOP found.
-;
-;  Destroys:	D1, D2
-;  Called by:	BSR6
-;
-;  Function:	Checks to see if the specified I/O registers point to an
-;				IOP.  Since the IOP chip generates it's own DSACK, a Bus
-;				Error may occur if it doesn't exist, which would cause this
-;				routine to return through the bus error handler, indicating
-;				that an IOP doesn't exist.  If no bus errors occur, we
-;				verify that a long word read from the IOPRamData register
-;				causes the IOPRamAddr register to incement by 4.  All of the
-;				IOP registers used are saved and restored, making this test
-;				non-destructive.
-;
-;_______________________________________________________________________
-
-TestForIOP								; A2 := Base address of IOP to test
-		eieioSTP
-			move.b	iopStatCtl(a2),d1	; save status/ctl register value
-			moveq.l	#(1<<iopIncEnable)+(1<<iopRun),d2	; mask for bits to save
-			and.b	d1,d2				; get those bits
-			swap	d1					; save old status ctl reg
-		eieioSTP
-			move.w	iopRamAddr(a2),d1	; save Ram Address register value
-			ori.b	#(1<<iopIncEnable),d2	; enable increment								<2.5>
-		eieioSTP
-			move.b	d2,iopStatCtl(a2)	; enable register pointer incrementing
-		eieioSTP
-			tst.l	iopRamData(a2)		; read and ignore 4 bytes of Ram
-		eieioSTP
-			move.w	iopRamAddr(a2),d2	; save updated Ram Address register value
-		eieioSTP
-			move.w	d1,iopRamAddr(a2)	; restore Ram Address register value
-			subq.w	#4,d2				; back off the 4 byte increment
-			sub.w	d1,d2				; check for increment
-			swap	d1					; get status ctl reg
-			andi.b	#-1-(1<<iopInt0Active)-(1<<iopInt1Active),d1
-		eieioSTP
-			move.b	d1,iopStatCtl(a2)	; restore status/ctl register
-			tst.w	d2					; d2 = 0 if IOP found
-		eieioSTP
-			rts6
-
-
-
 ;_______________________________________________________________________
 ;
 ;  Routine:		TestForSCSIDMA
@@ -2223,9 +1869,7 @@ TestForIOP								; A2 := Base address of IOP to test
 ;_______________________________________________________________________
 
 TestForSCSIDMA							; A2 := Base address of SCSI DMA to test
-		eieioSTP
 			tst.l	$80(a2)				; try to read the control register
-		eieioSTP
 			cmp.b	d1,d1				; if no bus error, assume that it exists
 			rts6
 
@@ -2257,201 +1901,12 @@ TestForSCSIDMA							; A2 := Base address of SCSI DMA to test
 ;	reality, not there.  So the CMPI above actually checks to see if the data stuck.	<T14>
 
 TestForSCSI96							; A2 = Base address of SCSI port to test
-		eieioSTP
 			tst.b	$c0(a2)				; try to read configuration #3 register (r/w)
-		eieioSTP
 			cmpi.b	#$04, $c0(a2)		; ...verify data written in config. regr 3		<T14>
-		eieioSTP
 			rts6
 
 
 
-
-;_______________________________________________________________________
-;
-;  Routine:		TestForRPU
-;  Inputs:		A2 - Base address of RPU to test for.
-;				A6 - return address
-;				A5, A7, D7, VBR - setup for bus error handler
-;
-;  Outputs:		ccr.z - 0 (bne) if RPU not found, or bus error.
-;					  - 1 (beq) if valid RPU found.
-;
-;  Destroys:	D1,D2
-;  Called by:	BSR6
-;
-;  Function:	Checks to see if the RPU (Ram Parity Unit) is present by writing
-;				to the WWP bit of the chip (the only r/w bit) and reading back,
-;				making sure bus capacitance doesn't make it look valid.
-;
-;_______________________________________________________________________
-TestForRPU								;
-		eieioSTP
-			tst.b	(a2)				; x 	First 4 reads are unique
-		eieioSTP
-			tst.b	(a2)				; x 	
-		eieioSTP
-			tst.b	(a2)				; PDCA	Read out the parity daisy chain bits
-		eieioSTP
-			tst.b	(a2)				; PDCB	and toss them (no where to save them)
-
-		eieioSTP
-			st.b	rpuReset(a2)		;reset the RPU serial pointer
-		eieioSTP
-			move.b	(a2),d2				;save the WWP bit
-
-		eieioSTP
-			st.b	rpuReset(a2)		;reset the RPU serial pointer
-		eieioSTP
-			st.b	(a2)				;set the WWP bit
-		eieioSTP
-			clr.b	rpuReset(a2)		;force bus low, reset pointer
-			moveq	#1,d1				;check bit 0
-		eieioSTP
-			and.b	(a2),d1				;read WWP bit
-			seq.b	d1					;d1=FF if WWP bit was 0
-			beq.s	@exit				;exit if WWP bit=0
-
-		eieioSTP
-			st.b	rpuReset(a2)		;reset the RPU serial pointer
-			clr.b	(a2)				;clear the WWP bit
-		eieioSTP
-			st.b	rpuReset(a2)		;force bus high, reset pointer
-			moveq	#1,d1				;check bit 0
-		eieioSTP
-			and.b	(a2),d1				;read WWP bit
-
-@exit
-		eieioSTP
-			st.b	rpuReset(a2)		;reset pointer for exit
-			move.b	d2,(a2)				;restore WWP bit
-			tst.b	d1					;test result
-		eieioSTP
-			rts6
-
-;_______________________________________________________________________			<SM32>
-;
-;  Routine:		TestForMUNI
-;  Inputs:		A2 - Address of the MUNI Control register to test
-;				A6 - return address
-;				A5, A7, D7, VBR - setup for bus error handler
-;
-;  Outputs:		ccr.z - 0 (bne) if not a valid MUNI Control register, or bus error.
-;					  - 1 (beq) if valid MUNI Control register found.
-;
-;  Destroys:	D1, D2
-;  Called by:	BSR6
-;
-;  Function:	Checks to see if the specified MUNI Control register
-;				exists by writing to it and seeing if we get a bus error.
-;  				If we do, then we have no MUNI.
-;				Since the MUNI chip generates it's own
-;				DSACK, a Bus Error may occur if it doesn't exist, which would
-;				cause this routine to return through the bus error handler,
-;				indicating that it doesn't exist.  For now we just simply test
-;				to see if we can read the control register without getting
-;				a bus error.  If we are successful, we assume that the chip
-;				exists.  This test may need to be improved in the future.
-;
-;
-;_______________________________________________________________________
-
-TestForMUNI									; A2 := address of MUNI register to test
-		eieioSTP
-			tst.l	MUNI_Control(a2)		; try to read the control register
-		eieioSTP
-			cmp.b	d1,d1					; if no bus error, assume that it exists
-			rts6
-
-
-
-;_______________________________________________________________________			<SM53>
-;
-;  Routine:		TestForBart
-;  Inputs:		A2 - Address of BART
-;				A6 - return address
-;				A5, A7, D7, VBR - setup for bus error handler
-;
-;  Outputs:		ccr.z - 0 (bne) if no BART, or bus error.
-;					  - 1 (beq) if BART found.
-;
-;  Destroys:	D1, D2
-;  Called by:	BSR6
-;
-;  Function:	Checks to see if  BART exists by accessing it and seeing if 
-;				we get a bus error.  If we do, then we don't have a BART.  This
-;				test should be extended in the future to check the version register
-;				in BART.
-;
-;
-;_______________________________________________________________________
-
-TestForBart									; A2 := address of BART register to test
-		eieioSTP
-			tst.b	(a2)					; try to read BART
-			cmp.b	d1,d1					; if no bus error, assume that it exists
-		eieioSTP
-			rts6
-
-
-
-;																			<SM28> fau start
-;_______________________________________________________________________
-;
-;  Routine:		TestForFPU
-;  Inputs:		A5, A7, D7, VBR - setup for bus error handler
-;
-;  Outputs:		ccr.z - 0 (bne) if FPU not found.
-;					  - 1 (beq) if FPU available.
-;
-;  Destroys:	A6, D1, sfc
-;  Called by:	BRA
-;
-;  Function:	Checks to see if an FPU is installed.
-;
-;	NOTE:	this routine is BRA'nched to, not BSR6'ed, so that A6 is				
-;			available for trashing in this routine.									
-;
-;	NOTE2:	this needed to be changed because with an 040LC you're					
-;			no longer guaranteed to have an on-board FPU.							
-;_______________________________________________________________________
-TestForFPU
-
-	IF ROMinRAM THEN					; 									<SM22> rb 
-			movec 	CACR,d1				; MacsBug does not like the fpu		<SM22> rb
-			cmp.b	d1,d1				; code when booting from RAM		<SM22> rb
-			bra		FPUReturn			;									<SM22> rb
-	ELSE								;									<SM22> rb
-	
-;	New, Improved method of on-the-fly checking for and FPU							
-
-			movec	VBR,d1				;   retrieve VBR
-
-;	The idea is to move VBR DOWN the difference between the F-Line and
-;	BusError, so that if you were to execute an F-Line instruction and
-;	couldn't handle it, you would end up fetching the address of the
-;	BusErrVector and going thru the BusErrVector.  The BusErr handler
-;	expects A6 to contain the address of where it should return TO.
-
-			sub.l	#Line1111-BusErrVct,d1; temporarily move VBR down
-			movec	d1,VBR				;   shuffle VBR for F-Line test
-			moveq	#1,d1				;   non-zero value in D1 for later comparison
-			lea		@noFPU,a6			;   where to come back to if you dont have an FPU
-		eieioSTP
-			FNOP						;   execute suspect command
-		eieioSTP
-			clr.l	d1					;   if you got here, you have an FPU
-
-@noFPU		move.l	d1,a6				;   save D1
-			movec	VBR,d1				;   return VBR to it's old value
-			add.l	#Line1111-BusErrVct,d1
-			movec	d1,VBR				;   ... so everyone is happy
-			move.l	a6,d1				;   restore D1
-			tst.b	d1					;   return CCR.Z to CheckOptionals
-@exit		bra		FPUReturn			;   and return to CheckOptionals	<SM28> fau end
-
-	ENDIF								;									<SM22> rb
-
 ;_______________________________________________________________________
 ;
 ;  Routine:		GetVIAInputs
@@ -2484,151 +1939,64 @@ GetVIAInputs
 			beq.s	@noVIA1				; if not, skip it
 			movea.l	VIA1Addr(a0),a1		; get the VIA1 base address
 
-		eieioSTP
 			move.b	vBufA(a1),d2		; save port A
-		eieioSTP
 
 			lsl.w	#8,d2				; make room for direction bits
 			move.b	vDirA(a1),d2		; save direction bits
 			move.b	d2,d1				; get prior direction bits
-		eieioSTP
 			and.b	AvoidVIA1A(a0),d1	; if we need to avoid any output, don't make them input
-		eieioSTP
 			move.b	d1,vDirA(a1)		; change bits to inputs
 		eieioSTP
 			move.b	vBufA(a1),d1		; get port A inputs
-		eieioSTP
 			move.b	d2,vDirA(a1)		; restore direction bits
 			lsr.w	#8,d2				; get saved port A
-		eieioSTP
 			move.b	d2,vBufA(a1)		; restore port A
 
 			lsl.w	#8,d1				; make room for port B bits
-		eieioSTP
 			move.b	vBufB(a1),d2		; save port B
 			lsl.w	#8,d2				; make room for direction bits
-		eieioSTP
 			move.b	vDirB(a1),d2		; save direction bits
-		eieioSTP
 			move.b	d2,d1				; get prior direction bits
 			and.b	AvoidVIA1B(a0),d1	; if we need to avoid any output, don't make them input
-		eieioSTP
 			move.b	d1,vDirB(a1)		; change bits to inputs
 		eieioSTP
 			move.b	vBufB(a1),d1		; get port B inputs
-		eieioSTP
 				move.b	d2,vDirB(a1)		; restore direction bits
-		eieioSTP
 			lsr.w	#8,d2				; get saved port B
 			move.b	d2,vBufB(a1)		; restore port B
-		eieioSTP
 @noVIA1
 			swap	d1					; VIA1 info to high word
 			btst.l	#VIA2Exists,d0		; see if VIA2 exists
 			beq.s	@noVIA2				; if not, skip it
-		eieioSTP
 			movea.l	VIA2Addr(a0),a1		; get the VIA2 base address
-		eieioSTP
 
 			move.b	vBufA(a1),d2		; save port A
-		eieioSTP
 			lsl.w	#8,d2				; make room for direction bits
 			move.b	vDirA(a1),d2		; save direction bits
-		eieioSTP
 			move.b	d2,d1				; get prior direction bits
 			and.b	AvoidVIA2A(a0),d1	; if we need to avoid any output, don't make them input
-		eieioSTP
 			move.b	d1,vDirA(a1)		; change bits to inputs
 		eieioSTP
 			move.b	vBufA(a1),d1		; get port A inputs
-		eieioSTP
 			move.b	d2,vDirA(a1)		; restore direction bits
-		eieioSTP
 			lsr.w	#8,d2				; get saved port A
 			move.b	d2,vBufA(a1)		; restore port A
-		eieioSTP
 
 			lsl.w	#8,d1				; make room for port B bits
 			move.b	vBufB(a1),d2		; save port B
-		eieioSTP
 			lsl.w	#8,d2				; make room for direction bits
 			move.b	vDirB(a1),d2		; save direction bits
-		eieioSTP
 			move.b	d2,d1				; get prior direction bits
 			and.b	AvoidVIA2B(a0),d1	; if we need to avoid any output, don't make them input
-		eieioSTP
 			move.b	d1,vDirB(a1)		; change bits to inputs
 		eieioSTP
 			move.b	vBufB(a1),d1		; get port B inputs
-		eieioSTP
 			move.b	d2,vDirB(a1)		; restore direction bits
-		eieioSTP
 			lsr.w	#8,d2				; get saved port B
 			move.b	d2,vBufB(a1)		; restore port B
-		eieioSTP
 @noVIA2
 			rts6						; all done
 
-;_______________________________________________________________________  
-;
-;  Routine:		TestForSonic
-;  Inputs:		A1 - Base address of Sonic to test.
-;				A6 - return address
-;				A5, A7, D7, VBR - setup for bus error handler
-;
-;  Outputs:		ccr.z - 0 (bne) if Sonic not found, or bus error.
-;					  - 1 (beq) if Sonic found.
-;
-;  Destroys:	none
-;  Called by:	BSR6
-;
-;  Function:	Checks to see if we have a Sonic Ethernet chip.    An access to a non-existent
-;				address MUST cause us to BusError.  		
-;
-;_______________________________________________________________________
-
-TestForSonic							; A1 = Base address of Sonic Chip to test			<H12 begin>
-		eieioSTP
-			tst.b	(a1)				; try to read the Command Register		
-		eieioSTP
-			bset	#7,(a1)				; send a SW Reset to Sonic							<H30><SM40>
-		eieioSTP
-		
-			cmp		d1,d1				; set ccr.z because no bus error if we made it here	
-			
-			rts6						; return with flags set								
-
-
-;_______________________________________________________________________  
-;
-;  Routine:		TestForPatchROM
-;  Inputs:		A1 - Base address of PatchROM to test.
-;				A6 - return address
-;				A5, A7, D7, VBR - setup for bus error handler
-;
-;  Outputs:		ccr.z - 0 (bne) if PatchROM not found, or bus error.
-;					  - 1 (beq) if PatchROM found.
-;
-;  Destroys:	a1
-;  Called by:	BSR6
-;
-;  Function:	Checks to see if we have a PatchROM.    An access to a non-existent
-;				address MUST cause us to BusError.  		
-;
-;_______________________________________________________________________
-
-TestForPatchROM							; A1 = Base address of PatchROM to test			<H12 begin>
-		eieioSTP
-			tst.b	(a1)				; try to read the first byte	
-		eieioSTP
-			movea.l	$4(a1),a1			; load signature into a1
-		eieioSTP
-			exg		a1,d1				; because we have no free registers
-			cmpi.l	#'romp',d1			; set ccr.z if signtures match
-			exg		a1,d1				; because we have no free registers
-			rts6						; return with flags set								
-
-
 ;__________________________________________________________________________________________________
 ;
 ;  Routine:		GetCPUIDReg
@@ -2662,198 +2030,17 @@ TestForPatchROM							; A1 = Base address of PatchROM to test			<H12 begin>
 	IF hasCPUIDRegister THEN				; <SM24> rb <SM36> rb
 	
 GetCPUIDReg
-	IF ROMinRAM THEN						; 										<SM22> rb
-			move.l #$A55A2830,d0			; ••• HACK, force Cyclone, make your	<SM22> rb
-			cmp.w d0,d0						; ModifyReadOnly hack here. Cyclone		<SM22> rb
-			jmp (a6)						; needs this because the MMU is 		<SM22> rb
-	ENDIF									; hiding the CPUIDReg one we booted		<SM22> rb
-
-	
-
-		IF forSmurf THEN
-	
-			; Read the CPUID bits from the via register.  Orwells/djmemc both have
-			; via addrs at $50F0000 (but for smurfs, use $50000000)
-			
-
-			movea.l	#$50000000,a2			; get the VIA1 base address
-			
-			;now get the cpuid bits from the via register
-			move.b	vBufA(a2),d2			; save port A
-			lsl.w	#8,d2					; make room for direction bits
-			move.b	vDirA(a2),d2			; save direction bits
-			move.b	d2,d1					; get prior direction bits
-			move.b	#0,vDirA(a2)			; change bits to inputs
-			move.b	vBufA(a2),d1			; get port A inputs
-			move.b	d2,vDirA(a2)			; restore direction bits
-			lsr.w	#8,d2					; get saved port A
-			move.b	d2,vBufA(a2)			; restore port A
-			
-			; d1.b  now contains the cpuid bits. so use $56 to mask out leaving us with the 
-			; cpuid bits PA6, PA4, PA2, PA1
-			
-			andi.b #$56,d1					; d1.b now contains the cpu id bits from the via
-
-			; now find out if we are on a machine with a djmemc decoder or and orwell.
-			; djmec have a 12 bit register, bits 11..9 contain the version number for the djmemc...
-			; Game Plan: read from the 12 bit register.  if bits 11..9 = 010 then djmec
-
-			lea	#MEMCAddr,a2					; Orwell or djmec decoder addr.
-	
-			move.l	MEMCIntleaveEnable(a2),d0	; read the 12 bit register at the base of DJMEMC/Orwell
-			andi.w	#$0E00,d0					; mask out all bits except version bits at bit 11..9			
-			cmpi.w 	#$0200,d0					; the version number for djmec is 010 for bits 11..9
-			
-			beq.s	@tryCentris610				; if equal than on djmec machine..via id bits will match
-												; those for wombat machines			
-@tryQ700
-			cmpi.b	#$40,d1						; is it a quadra700
-			bne.s	@tryQ900
-			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center
-					$1235,D0					;	return emulator CPU ID
-			BRA		@success		
-@tryQ900
-			cmpi.b	#$50,d1						; is it a quadra900
-			bne.s	@tryQ950
-			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center
-					$1236,D0					;	return emulator CPU ID
-			BRA		@success	
-@tryQ950	; if here it must be Q950
-
-			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center
-					$1237,D0					;	return emulator CPU ID
-			BRA		@success	
-
-
-@tryCentris610	
-			cmpi.b	#$40,d1						; is it a Centris610?
-			bne.s	@tryCentris650
-			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center
-					$1204,D0					;	return emulator CPU ID
-			BRA		@success	
-
-@tryCentris650	
-			cmpi.b	#$46,d1						; is it a Centris650?
-			bne.s	@tryQ800
-			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center
-					$1200,D0					;	return emulator CPU ID
-			BRA		@success	
-@tryQ800	
-			cmpi.b	#$12,d1						; is it a Quadra800?
-			bne.s	@tryQ610
-			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center
-					$1201,D0					;	return emulator CPU ID
-			BRA		@success
-
-@tryQ610	
-			cmpi.b	#$44,d1						; is it a Quadra610?
-			bne.s	@tryQ650
-			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center
-					$1202,D0					;	return emulator CPU ID
-			BRA		@success
-
-@tryQ650	;if here assume Smurf card is in Q650
-			MOVE.W	#(cpuIDRISC)|\				; 	CPU ID: RISC design center
-					$1203,D0					;	return emulator CPU ID
-			BRA		@success
-
-
-		ENDIF								; forSmurf
-
-			LEA		CPUIDReg,A2				; Get CPU ID reg address
-
-											; FIRST - try to read it as a LONG.   <SM43>,<SM44>
-			MOVE.L	(A2),D0					; read the register (bus err if it doesn't exist)
-			MOVEQ	#0,D1					; clear pattern register
-@FlipBits									; LOOP (to write different patterns in CPUID reg)
-			MOVE.L	D1,(A2)					;	write next pattern to CPUID register location
-			CMP.L	(A2),D0					;	does it read back the same as the first time?
-			BNE.S	@tryPDMIDReg			;	-> no.  try reading it the other way.
-			NOT.L	D1						;	flip the bits in the write pattern
-			BNE.S	@FlipBits				;	-> try the next write pattern
-			SWAP	D0						;	look at the signature
-			CMPI.W	#cpuIDSig,D0			;	is it a valid signature?
-			BNE.S	@tryPDMIDReg			;	-> no.  try reading it the other way.
-			SWAP	D0						;	look at the decoder-specific stuff
-			bra		@success				; yay, we're done.
-
-@tryPDMIDReg								; SECOND - see if it's a byte-wide only reg (like on PDM)
-			move.b	(a2), d0				; read high byte (bus err if it doesn't exist)
-			move.b	#$6a, (a2)				; write/read to be sure it's really there
-			cmp.b	(a2), d0				; match previous read?
-			bne		@noCPUIDReg				; no.  must not really be the CPUID reg.
-			lsl.l	#8, d0					; shift high byte over
-			
-			move.b	1(a2), d0				; read next byte
-			move.b	#$6f, 1(a2)				; write/read to be sure it's really there
-			cmp.b	1(a2), d0				; match previous read?
-			bne		@noCPUIDReg				; no.  must not really be the CPUID reg.
-			lsl.l	#8, d0					; shift next byte over
-			
-			move.b	2(a2), d0				; read next byte
-			move.b	#$65, 2(a2)				; write/read to be sure it's really there
-			cmp.b	2(a2), d0				; match previous read?
-			bne		@noCPUIDReg				; no.  must not really be the CPUID reg.
-			lsl.l	#8, d0					; shift next byte over
-			
-			move.b	3(a2), d0				; read last byte
-			move.b	#$20, 3(a2)				; write/read to be sure it's really there
-			cmp.b	3(a2), d0				; match previous read?
-			bne		@noCPUIDReg				; no.  must not really be the CPUID reg.
-			
-			swap	d0						; check the signature
-			cmpi.w	#cpuIDSig, d0			; is it valid?
-			bne		@noCPUIDReg				; nope, exit with Z cleared.
-			swap	d0						; yay!  we're probably a PDM!  (how cool if we are.)
-
-			cmpi.w	#$3010, d0				; could we be an EVT2 but don't know it? <SM45>
-			bne		@success				; nope
-			
-			move.b	$50F32008, d1			; read SCSI DMA ctl reg
-			movea.w	d1, a2					; remember the original setting
-			ori.b	#$0C, d1				; poke the extra bits
-			move.b	d1, $50F32008			; save the updated value
-			nop
-			move.b	$50F32008, d1			; read SCSI DMA ctl reg again
-			andi.b	#$0C, d1				; did they stick?
-			beq.s	@success				; nope, don't dick with the CPUID
-
-			move.w	a2, d1					; restore the original setting
-			move.b	d1, $50F32008			
-			nop
-
-@ck4FastSCSI
-			move.b	#$02, $50f11030			; do cResetChip cmd
-			nop
-			move.b	#$00, $50f11030			; cNOP required after HW or SW reset
-
-			move.b	#$40, $50f110b0			; turn on Features enable then,
-			move.b	#$80, $50f11030			; send a DMA NOP command then,
-			nop
-			cmp.b	#$A2, $50f110e0			; read the SCSI chip ID - an FC96?
-			beq.s	@isFastSCSI				; yes -> we have Fast SCSI (i.e. we're on a Cold Fusion)
-
-@noFastSCSI			
-			move.b	#$02, $50f11030			; cResetChip again
-			nop
-			move.b	#$00, $50f11030			; cNOP required after HW or SW reset
-
-			move.b	#$11, d0				; we're an AMIC2 - change CPUID to $3011 
-			bra.s	@success				; 
-
-@isFastSCSI
-			move.b	#$02, $50f11030			; cResetChip again
-			nop
-			move.b	#$00, $50f11030			; cNOP required after HW or SW reset
-
-			move.b	#$13, d0				; we're a Cold Fusion - change CPUID to $3013 
-
-@success	
-		IF forSTP601 THEN
-			ori.w #(cpuIDRISC),d0
-		ENDIF
-			CMP.W	D0,D0					;	set ccr.z to indicate success
-@noCPUIDReg	JMP		(A6)					; END
+			move.l	([$68FFEFD0],$70),d0	; NKHWInfo.Signature
+			cmpi.l	#'Hnfo',d0
+			bne.s	@noHnfo
+			move	([$68FFEFD0],$76),d0	; NKHWInfo.CPU_ID
+			bra		@eq
+@noHnfo
+			bra.s	@ne
+@eq
+			cmp		d0,d0
+@ne
+			rts6
 
 	ENDIF									; <SM24> rb
 			end
diff --git a/OS/UniversalTables.a b/OS/UniversalTables.a
--- a/OS/UniversalTables.a
+++ b/OS/UniversalTables.a
@@ -497,112 +497,38 @@ UnivTables	Proc
 ;												       Tempest25   :    1   0   1   1	    ID = $B
 ;												       Tempest33   :    1   0   0   0	    ID = $8
 ;———————————————————————————————————————————————————————————————————————————————————————————————
-			EXPORT	ProductLookup,CPUIDProductLookup,DecoderLookup
+			EXPORT	ProductLookup,CPUIDProductLookup,DecoderLookup,InfoNewWorld
 
 			ALIGN	4
 
 CPUIDProductLookup
-		IF hasHMC THEN									;													<SM46>
-			dc.l	InfoPDM-*							; PDM
-			dc.l	InfoPDMcoldFusion-*					; PDM (Cold Fusion)									<SM70>
-			dc.l	InfoPDMCarlSagan-*					; PDM (Carl Sagan)									<SM88>
-		ENDIF											;													<SM46>
-		IF hasPratt THEN
-			dc.l	InfoBlackbird-*						; Blackbird											<SM39>
-		ENDIF
-		IF hasMSC THEN
-			dc.l	InfoYeager-*						; Yeager with real MBT chip
-			dc.l	InfoPowerBookDuo210-*				; PowerBook Duo 210
-			dc.l	InfoPowerBookDuo230-*				; PowerBook Duo 230
-			dc.l	InfoPowerBookDuo235-*				; PowerBook Duo 235 (230+active matrix)
-			;dc.l	InfoEscher-*						; Escher 33MHz											<H65>
-		ENDIF
-		IF hasSonora THEN
-			dc.l	InfoVail16-*						; Vail 16 Mhz
-			dc.l	InfoLCIII-*							; Vail 25 Mhz
-			dc.l	InfoVail33-*						; Vail 33 Mhz										<SM29>
-		ENDIF
-		IF hasDJMEMC THEN
-			dc.l	InfoWombat20-*						; Wombat @ 20 Mhz in Lego packaging					<H52><SM29>
-			dc.l	InfoCentris650-*					; Wombat @ 25 Mhz in Lego packaging					<H41><SM29>
-			dc.l	InfoQuadra650-*						; Wombat @ 33 Mhz in Lego packaging					<H41><SM29>
-			dc.l	InfoQuadra800-*						; Wombat @ 33 Mhz in Frigidaire packaging			<H41><H45><SM29>
-			dc.l	InfoWombat40-*						; Wombat @ 40 Mhz in Lego packaging					<H41><SM29>
-			dc.l	InfoWombat40F-*						; Wombat @ 40 Mhz in Frigidaire packaging			<H52><H61><SM29>
-			dc.l	InfoCentris610-*					; WLCD @ 20 Mhz										<H41><SM29>
-			dc.l	InfoQuadra610-*						; WLCD @ 25 Mhz										<H41><SM29>
-			dc.l	InfoWLCD33-*						; WLCD @ 33 Mhz										<H64><SM29>
-			IF forSmurf THEN
-				dc.l	InfoRiscQuadra800-*				; Quadra800 w/Smurf card 							<SM86>
-				dc.l	InfoRiscCentris650-*			; Centris650 w/Smurf card							<SM86>
-				dc.l	InfoRiscCentris610-*			; Centris610 w/Smurf card							<SM89>
-				dc.l	InfoRiscQuadra610-*				; Quadra610 w/Smurf card 							<SM89>
-				dc.l	InfoRiscQuadra650-*				; Quadra650 w/Smurf card 							<SM89>
-			ENDIF	
-		IF forSTP601 THEN
-			dc.l	InfoSTPCentris650-*					; Centris650 w/STP card 							<SM86>
-			dc.l	InfoSTPQuadra650-*					; Quadra650 w/STP card								<SM86>
-			dc.l	InfoSTPQuadra40F-*					; 40mhz wombat w/STP card								<SM89>
-			dc.l	InfoSTPQuadra800-*					; Quadra800 w/STP card								<SM89>
-			dc.l	InfoSTPCentris610-*					; Centris610 w/STP card 							<SM89>
-			dc.l	InfoSTPQuadra610-*					; Quadra610 w/STP card 								<SM89>
-		ENDIF	
-		ENDIF
-		IF hasYMCA AND hasPSC THEN									;													<SM46>
-			dc.l	InfoCyclone33-*						; Cyclone 33 Mhz									<SM19> fau
-			dc.l	InfoQuadra840AV-*					; Cyclone 40 Mhz									<SM40> fau
-			dc.l	InfoCentris660AV-*					; Tempest 25 Mhz									<SM26> fau
-			dc.l	InfoTempest33-*						; Tempest 33 Mhz									<SM40> fau
-		ENDIF											;													<SM46>
-		IF hasOrwell AND forSmurf THEN
-			dc.l	InfoRiscQuadra700-*					; Quadra 700 w/Risc Card							<SM86>
-			dc.l	InfoRiscQuadra900-*					; Quadra 900 w/Risc Card							<SM86>
-			dc.l	InfoRiscQuadra950-*					; Quadra 950 w/Risc Card							<SM86>
-		ENDIF
-		IF hasGrandCentral THEN
-			dc.l	InfoTNTProto1-*
-		ENDIF
-			dc.l	InfoUnknownUnknown-*				; totally lost
+			dc.l	InfoNewWorld-*
 			dc.l	0									; end of list
 
 
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 ;
-;	Decoder Lookup Table
+;	Table of Unclear Purpose
+;
+;———————————————————————————————————————————————————————————————————————————————————————————————
+
+			;	These look like CPUID fields?
+			dc.l	$3035
+			dc.l	$0190
+			dc.l	$3041
+			dc.l	$01F8
+			dc.l	0
+			dc.l	0
+
+
+;———————————————————————————————————————————————————————————————————————————————————————————————
+;
+;	Product Lookup Table
 ;
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 
 ProductLookup
-		IF hasVISADecoder THEN							;													<SM46>
-			dc.l	InfoMacLC-*							; Macintosh LC										<12><SM17>
-		ENDIF											;													<SM46>
-		IF forSTP601 THEN
-			dc.l	InfoSTPQuadra700-*					; Quadra 700 w/STP Card								<SM86>
-			dc.l	InfoSTPQuadra900-*					; Quadra 900 w/STP Card								<SM86>
-			dc.l	InfoSTPQuadra950-*					; Quadra 950 w/STP Card								<SM86>
-		ENDIF
-		IF hasOrwell THEN
-			dc.l	InfoQuadra700-*						; Quadra 700, 1 direct slot, 2 NuBus slots			<T7>
-			dc.l	InfoQuadra900-*						; Quadra 900, 1 direct slot, 5 NuBus slots			<13>
-			dc.l	InfoQuadra950-*						; Quadra 950, 1 direct slot, 5 NuBus slots			<5>
-		ENDIF
-		IF hasJaws THEN
-			dc.l	InfoPowerBook170-*					; PowerBook 140 and 170								<8>
-		ENDIF
-		IF hasNiagra THEN
-			dc.l	InfoPowerBook180-*					; PowerBook 180										<H9>
-		ENDIF
-		IF hasVISADecoder THEN
-			dc.l	InfoVISAUnknown-*					; unknown VISA decoder based machine				<12>
-		ENDIF
-		IF hasJaws THEN
-			dc.l	InfoJAWSUnknown-*					; unknown JAWS based machine						<25>
-		ENDIF
-		IF hasMDU THEN									;													<SM46>
-			dc.l	InfoMacIIsi-*						; Macintosh IIsi	 								<3><SM46>
-		ENDIF											;													<SM46>
-			dc.l	InfoUnknownUnknown-*				; totally lost
-			dc.l	0									; end if list, no match, check decoder again
+			dc.l	0									; end of list
 
 
 ;———————————————————————————————————————————————————————————————————————————————————————————————
@@ -612,22 +538,6 @@ ProductLookup
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 
 DecoderLookup
-		IF hasVISADecoder THEN							;													<SM46>
-			dc.l	VISADecoderTable-*					; check for VISA decoder							<SM5>
-		ENDIF											;													<SM46>
-		IF hasNiagra THEN
-			dc.l	Niagratable-*						; check for Niagra decoder
-		ENDIF
-		IF hasJaws THEN
-			dc.l	JAWStable-*							; check for JAWS decoder							<25><61>
-		ENDIF
-		IF hasOrwell THEN
-			dc.l	OrwellDecoderTable-*				; check for Orwell memory controller				<13><19>
-		ENDIF
-		IF hasMDU THEN
-			dc.l	MDUtable-*							; check for MDU decoder								<SM46>
-		ENDIF
-			dc.l	UnknownDecoderTable-*				; always find something
 
 
 ;———————————————————————————————————————————————————————————————————————————————————————————————
@@ -636,3250 +546,62 @@ DecoderLookup
 ;
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 
+	
+			IMPORT	SndCntlNW, NWClockPRAM, DummyADBTable, NWIntTbl
 
-		IF hasPratt THEN								;													<SM39>
-			IMPORT	SndCntlBlackbird, PrattIntTbl
-			IMPORT	PrattPMgrPrims,ImmgBabyRock	
-
-;	PowerBook Blackbird product table
+;	NewWorld product table (the only one)
 
 			ALIGN	4
-InfoBlackbird
-			dc.l	PrattTable-InfoBlackbird			; offset to decoder info		
-			dc.l	RamInfoPratt-InfoBlackbird			; offset to ram bank info
-			dc.l	VideoInfoPratt-InfoBlackbird		; offset to video info
-			dc.l	NuBusInfoPratt-InfoBlackbird		; offset to NuBus info			
+InfoNewWorld
+			dc.l	0									; no decoder info
+			dc.l	RamInfoNewWorld-InfoNewWorld		; offset to ram bank info
+			dc.l	VideoInfoNewWorld-InfoNewWorld		; offset to video info
+			dc.l	NuBusInfoNewWorld-InfoNewWorld		; offset to NuBus info
 			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
 					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present (option)
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)|\						; Apple Desktop Bus present.
-					(1<<hwCbPwrMgr)						; Power Manager present
-			dc.b	boxBlackbird						; product kind 								
-			dc.b	PrattDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration		
+					(1<<hwCbMMU)						; Some kind of MMU present
+			dc.b	BoxExtended							; product kind
+			dc.b	26									; decoder kind
+			dc.w	$3FFF   							; ROM85, New ROMs, Power Off ability.
+			dc.b	4									; default ROM Resource configuration
 			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					VDACExists,\						; VDAC (CSC) is valid
-					SONICExists							; SONIC is valid									
-			BitVector32 \								; Flags for valid base addresses 32-63
-					SingerExists,\						; PrattAddr is valid
-					PrattExists							; SingerAddr is valid
+			BitVector32									; Flags for valid base addresses 0-31
+			BitVector32	\								; Flags for valid base addresses 32-63
+					30
 			BitVector32									; Flags for valid base addresses 64-95
 			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ADBPwrMgr)|\						;	PMGR ADB
-					(ClockPwrMgr)|\						;	PMGR clock/pram
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input					<LW7>
+					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input
 					(Sound16Bit)|\						; has 16-bit hardware
 					(SoundStereoIn)|\					; has stereo sound input
 					(SoundStereoOut)|\					;	has stereo sound output
+					(SoundStereoMixing)|\				;	has stereo mixing
 					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				
 					(1<<SoundLineLevel)|\				; requires line level on sound input port
-					(1<<PMgrNewIntf)|\					; serial PMgr interface and new protocol
 					(1<<SupportsIdle)|\					; supports idle mode
 					(1<<hasNewMemMgr)|\					; supports idle mode
 					(1<<SoftVBL)						; SoftVBL is valid		
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$12,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 1, PA2 = 0, PA1 = 1
-			dc.l	VIA1InitPratt-InfoBlackbird			; VIA1 init info
-			dc.l	VIA2InitPratt-InfoBlackbird			; VIA2 needs init
-			dc.l	SndCntlBlackBird-InfoBlackbird		; sound control vector table
-			dc.l	PMGRClockPRAM-InfoBlackbird			; clock/PRAM vector table
-			dc.l	PMGRADBTable-InfoBlackbird			; ADB/DebugUtil vector table						
-			dc.l	PrattPMgrPrims-InfoBlackbird		; Power Manager primitives							
-			dc.l	PrattIntTbl-InfoBlackbird			; interrupt handlers table					<SM38>
-			dc.l	ImmgBabyRock-InfoBlackbird			; use BabyRock Internal Modem Manager					
-			dc.w	cpuIDPortable|\						; CPU ID: portable design center
-					cpuIDinBoard|\						; CPU ID: supplemental ID in Mother/Daughter board ID registers
-					8									; CPU ID: Blackbird ID is 8
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoTIM-InfoBlackbird			; offset to ICON info								<SM74>		
-
-		ENDIF											; {hasPratt}
-
-
-
-		IF hasMSC THEN
-			IMPORT	SndCntlPBDuo210, MSCPmgrPrims, MSCIntTbl,MBTPmgrPrims
-
-			ALIGN	4
-InfoPowerBookDuo210
-			dc.l	MSCTable-InfoPowerBookDuo210		; offset to decoder info
-			dc.l	RAMInfoMSC-InfoPowerBookDuo210		; offset to ram bank info
-			dc.l	VideoInfoMSC-InfoPowerBookDuo210	; offset to video info
-			dc.l	NuBusInfoMSC-InfoPowerBookDuo210	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present (option)
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)|\						; Apple Desktop Bus present.
-					(1<<hwCbPwrMgr)						; Power Manager present
-			dc.b	boxPowerBookDuo210					; product kind										<H29>
-			dc.b	MSCDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid									<H6>
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr (GSC) is valid							<H9>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ADBPwrMgr)|\						;	PMGR ADB
-					(ClockPwrMgr)|\						;	PMGR clock/pram
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input					<LW7>
-					(1<<SupportsIdle)|\					;	supports idle mode
-					(1<<PMgrNewIntf)|\					;	serial PMgr interface and new protocol
-					(1<<MSCChipBit)						;	MSC variant of the RBV							<H5>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$00,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitMSC-InfoPowerBookDuo210		; VIA1 init info
-			dc.l	0									; no VIA2 to init
-			dc.l	SndCntlPBDuo210-InfoPowerBookDuo210	; sound control vector table
-			dc.l	PMGRClockPRAM-InfoPowerBookDuo210	; clock/PRAM vector table							<H4>
-			dc.l	PMGRADBTable-InfoPowerBookDuo210	; ADB/DebugUtil vector table						<H30>
-			dc.l	MSCPmgrPrims-InfoPowerBookDuo210	; Power Manager primitives							<SM33>
-			dc.l	MSCIntTbl-InfoPowerBookDuo210		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDPortable|\						; CPU ID: portable design center
-					cpuIDinReg|\						; CPU ID: register contains complete ID
-					4									; CPU ID: PowerBook Duo 210 is 4
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoDBLite-InfoPowerBookDuo210	; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoPowerBookDuo230
-			dc.l	MSCTable-InfoPowerBookDuo230		; offset to decoder info
-			dc.l	RAMInfoMSC-InfoPowerBookDuo230		; offset to ram bank info
-			dc.l	VideoInfoMSC-InfoPowerBookDuo230	; offset to video info
-			dc.l	NuBusInfoMSC-InfoPowerBookDuo230	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present (option)
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)|\						; Apple Desktop Bus present.
-					(1<<hwCbPwrMgr)						; Power Manager present
-			dc.b	boxPowerBookDuo230					; product kind										<H29>
-			dc.b	MSCDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid									<H6>
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr (GSC) is valid							<H9>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ADBPwrMgr)|\						;	PMGR ADB
-					(ClockPwrMgr)|\						;	PMGR clock/pram
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input					<LW7>
-					(1<<SupportsIdle)|\					;	supports idle mode
-					(1<<PMgrNewIntf)|\					;	serial PMgr interface and new protocol
-					(1<<MSCChipBit)						;	MSC variant of the RBV							<H5>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$00,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitMSC-InfoPowerBookDuo230		; VIA1 init info
-			dc.l	0									; no VIA2 to init
-			dc.l	SndCntlPBDuo210-InfoPowerBookDuo230	; sound control vector table
-			dc.l	PMGRClockPRAM-InfoPowerBookDuo230	; clock/PRAM vector table							<H4>
-			dc.l	PMGRADBTable-InfoPowerBookDuo230	; ADB/DebugUtil vector table						<H30>
-			dc.l	MSCPmgrPrims-InfoPowerBookDuo230	; Power Manager primitives							<SM33>
-			dc.l	MSCIntTbl-InfoPowerBookDuo230		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDPortable|\						; CPU ID: portable design center
-					cpuIDinReg|\						; CPU ID: register contains complete ID
-					5									; CPU ID: PowerBook Duo 230 is 5
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoDBLite-InfoPowerBookDuo230	; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoPowerBookDuo235
-			dc.l	MSCTable-InfoPowerBookDuo235		; offset to decoder info
-			dc.l	RAMInfoMSC-InfoPowerBookDuo235		; offset to ram bank info
-			dc.l	VideoInfoMSC-InfoPowerBookDuo235	; offset to video info
-			dc.l	NuBusInfoMSC-InfoPowerBookDuo235	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present (option)
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)|\						; Apple Desktop Bus present.
-					(1<<hwCbPwrMgr)						; Power Manager present
-			dc.b	boxPowerBookDuo250					; product kind										<SM100>
-			dc.b	MSCDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid									<H6>
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr (GSC) is valid							<H9>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ADBPwrMgr)|\						;	PMGR ADB
-					(ClockPwrMgr)|\						;	PMGR clock/pram
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input					<LW7>
-					(1<<SupportsIdle)|\					;	supports idle mode
-					(1<<PMgrNewIntf)|\					;	serial PMgr interface and new protocol
-					(1<<MSCChipBit)						;	MSC variant of the RBV							<H5>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$00,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitMSC-InfoPowerBookDuo235		; VIA1 init info
-			dc.l	0									; no VIA2 to init
-			dc.l	SndCntlPBDuo210-InfoPowerBookDuo235	; sound control vector table
-			dc.l	PMGRClockPRAM-InfoPowerBookDuo235	; clock/PRAM vector table							<H4>
-			dc.l	PMGRADBTable-InfoPowerBookDuo235	; ADB/DebugUtil vector table						<H30>
-			dc.l	MSCPmgrPrims-InfoPowerBookDuo235	; Power Manager primitives							<SM33>
-			dc.l	MSCIntTbl-InfoPowerBookDuo235		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDPortable|\						; CPU ID: portable design center
-					cpuIDinReg|\						; CPU ID: register contains complete ID
-					6									; CPU ID: PowerBook Duo 235 is 6
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoDBLite-InfoPowerBookDuo235	; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoYeager
-			dc.l	MSCTable-InfoYeager				; offset to decoder info
-			dc.l	RAMInfoMSC-InfoYeager				; offset to ram bank info
-			dc.l	VideoInfoMSC-InfoYeager			; offset to video info
-			dc.l	NuBusInfoMSC-InfoYeager			; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present (option)
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)|\						; Apple Desktop Bus present.
-					(1<<hwCbPwrMgr)						; Power Manager present
-			dc.b	boxYeagerC							; product kind										<H29>
-			dc.b	MSCDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid									<H6>
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr (GSC) is valid							<H9>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ADBPwrMgr)|\						;	PMGR ADB
-					(ClockPwrMgr)|\						;	PMGR clock/pram
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(1<<SupportsIdle)|\					;	supports idle mode
-					(1<<PMgrNewIntf)|\					;	serial PMgr interface and new protocol
-					(1<<MSCChipBit)						;	MSC variant of the RBV							<H5>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$00,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitMSC-InfoYeager				; VIA1 init info
-			dc.l	0									; no VIA2 to init
-			dc.l	SndCntlPBDuo210-InfoYeager			; sound control vector table
-			dc.l	PMGRClockPRAM-InfoYeager			; clock/PRAM vector table							<H4>
-			dc.l	PMGRADBTable-InfoYeager				; ADB/DebugUtil vector table						<H30>
-			dc.l	MBTPmgrPrims-InfoYeager				; Power Manager primitives							<SM33>
-			dc.l	MSCIntTbl-InfoYeager				; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDPortable|\						; CPU ID: portable design center
-					cpuIDinReg|\						; CPU ID: register contains complete ID
-					0									; CPU ID: Yeager is 16
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoDBLite-InfoYeager			; offset to ICON info								<SM74>		
-
-
-		ENDIF											; {hasMSC}
-
-
-		IF hasNiagra THEN
-			IMPORT	SndCntlPB180, NiagraPMgrPrims, NiagraIntTbl
-
-;	PowerBook 180 product table
-
-			ALIGN	4
-InfoPowerBook180
-			dc.l	NiagraTable-InfoPowerBook180		; offset to decoder info		
-			dc.l	RamInfoNiagra-InfoPowerBook180		; offset to ram bank info
-			dc.l	VideoInfoNiagra-InfoPowerBook180	; offset to video info
-			dc.l	NuBusInfoNiagra-InfoPowerBook180	; offset to NuBus info			
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)|\						; Apple Desktop Bus present.
-					(1<<hwCbPwrMgr)						; Power Manager present
-			dc.b	boxPowerBook180						; product kind 								
-			dc.b	NiagraDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration		
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					VDACExists,\						; VDACAddr (GSC) is valid							<H9>
-					JAWSExists							; JAWSAddr is valid
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(ADBPwrMgr)|\						;	PowerManager ADB
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing								<H28>
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<SupportsIdle)|\					;	and has idle
-					(1<<NiagraExistsBit)				;	Niagra a variant of Jaws
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$12,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 1, PA2 = 0, PA1 = 1
-			dc.l	VIA1InitNiagra-InfoPowerBook180		; VIA1 init info
-			dc.l	VIA2InitNiagra-InfoPowerBook180		; VIA2 init info
-			dc.l	SndCntlPB180-InfoPowerBook180		; sound control vector table
-			dc.l	RTCClockPRAM-InfoPowerBook180		; clock/PRAM vector table
-			dc.l	PMGRADBTable-InfoPowerBook180		; ADB/DebugUtil vector table						<H30>
-			dc.l	NiagraPMgrPrims-InfoPowerBook180	; Power Manager primitives							<SM33>
-			dc.l	NiagraIntTbl-InfoPowerBook180		; interrupt handlers table							<SM38>
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoTIM-InfoPowerBook180		; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoNiagraUnknown
-			dc.l	NiagraTable-InfoNiagraUnknown		; offset to decoder info
-			dc.l	RamInfoNiagra-InfoNiagraUnknown		; offset to ram bank info
-			dc.l	VideoInfoNiagra-InfoNiagraUnknown	; offset to video info
-			dc.l	NuBusInfoNiagra-InfoNiagraUnknown	; offset to NuBus info			
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)|\						; Apple Desktop Bus present.
-					(1<<hwCbPwrMgr)						; Power Manager present
-			dc.b	BoxUnknown							; product kind
-			dc.b	NiagraDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32									; use default bases for this decoder
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(ADBPwrMgr)|\ 						; PowerManager ADB									<SM29>
-					(SoundPlayAndRecord)|\				; can Play and Record simultaneously				<H42><SM29>
-					(1<<SupportsIdle)|\					; and has idle										<SM29>
-					(1<<NiagraExistsBit)				; Niagra a variant of Jaws							<SM29>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00,$00,$00,$00						; anything with this decoder matches
-			dc.l	VIA1InitNiagra-InfoNiagraUnknown	; VIA1 init info
-			dc.l	VIA2InitNiagra-InfoNiagraUnknown	; VIA2 init info
-			dc.l	0									; no sound control vector table
-			dc.l	RTCClockPRAM-InfoNiagraUnknown		; clock/PRAM vector table
-			dc.l	PMGRADBTable-InfoNiagraUnknown		; ADB/DebugUtil vector table						<H30>
-			dc.l	NiagraPMgrPrims-InfoNiagraUnknown	; Power Manager primitives							<SM33>
-			dc.l	NiagraIntTbl-InfoNiagraUnknown		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoTIM-InfoNiagraUnknown		; offset to ICON info								<SM74>		
-
-		ENDIF											; {hasNiagra}
-
-
-		IF hasSonora THEN
-			IMPORT	SndCntlLCIII, SonoraIntTbl
-
-;	Vail 16 MHZ product table
-
-			ALIGN	4
-InfoVail16
-			dc.l	SonoraTable-InfoVail16				; offset to decoder info
-			dc.l	RamInfoVail-InfoVail16				; offset to ram bank info
-			dc.l	VideoInfoVail-InfoVail16			; offset to video info
-			dc.l	NuBusInfoVail-InfoVail16			; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present (option)
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxVail16							; product kind										<H23>
-			dc.b	SonoraDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration (non-FPU for now)
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBV is valid
-					VDACExists,\						; VDACAddr (SONORA) is valid				<H56>	<SM63> CSS
-					PatchRomExists						; PatchRomAddr is valid
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Egret8)|\							;	Egret Eight firmware							<SM63> CSS
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundPlayAndRecord)|\				; can Play and Record simultaneously				<H47><H42><SM29>
-					(1<<SonoraExistsBit)|\				; SonoraExistsBit is valid							<H34>
-					(1<<hasHardPowerOff)				; hasHardPowerOff is valid							<H63><SM29>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00,$00,$00,$00						; anything with this decoder matches
-			dc.l	VIA1InitVail-InfoVail16				; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	SndCntlLCIII-InfoVail16				; sound control vector table						<H10><H62><SM29>
-			dc.l	EgretClockPRAM-InfoVail16			; clock/PRAM vector table							<H4>
-			dc.l	EgretADBTable-InfoVail16			; ADB/DebugUtil vector table						<H30>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	SonoraIntTbl-InfoVail16				; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDHiVol|\						; CPU ID: hi volume design center					<H10>
-					cpuIDinReg|\						; CPU ID: register contains complete ID
-					0									; CPU ID: Vail 16 Mhz
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoMacLC-InfoVail16			; offset to ICON info								<SM74>		
-
-
-;	Vail 25 MHZ product table
-
-			ALIGN	4
-InfoLCIII
-			dc.l	SonoraTable-InfoLCIII				; offset to decoder info
-			dc.l	RamInfoVail-InfoLCIII				; offset to ram bank info
-			dc.l	VideoInfoVail-InfoLCIII				; offset to video info
-			dc.l	NuBusInfoVail-InfoLCIII				; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present (option)
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxLCIII							; product kind
-			dc.b	SonoraDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration (non-FPU for now)
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBV is valid
-					VDACExists,\						; VDACAddr (SONORA) is valid						<SM29>
-					PatchRomExists						; PatchRomAddr is valid
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Egret8)|\							;	Egret Eight firmware							<SM63> CSS
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(1<<SonoraExistsBit)|\				; SonoraExistsBit is valid							<H34>
-					(1<<hasHardPowerOff)				; hasHardPowerOff is valid							<H63><SM29>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00,$00,$00,$00						; anything with this decoder matches
-			dc.l	VIA1InitVail-InfoLCIII				; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	SndCntlLCIII-InfoLCIII				; sound control vector table						<H10><H62><SM29>
-			dc.l	EgretClockPRAM-InfoLCIII			; clock/PRAM vector table							<H4>
-			dc.l	EgretADBTable-InfoLCIII				; ADB/DebugUtil vector table						<H30>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	SonoraIntTbl-InfoLCIII				; interrupt handlers table							<SM38>
-			dc.w	cpuIDHiVol|\						; CPU ID: hi volume design center					<H10>
-					cpuIDinReg|\						; CPU ID: register contains complete ID
-					Vail25IDField						; CPU ID: Vail 25 Mhz								<SM29>
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoMacLC-InfoLCIII				; offset to ICON info								<SM74>		
-
-
-;	Vail 33 MHZ product table
-
-			ALIGN	4
-InfoVail33
-			dc.l	SonoraTable-InfoVail33				; offset to decoder info
-			dc.l	RamInfoVail-InfoVail33				; offset to ram bank info
-			dc.l	VideoInfoVail-InfoVail33			; offset to video info
-			dc.l	NuBusInfoVail-InfoVail33			; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present (option)
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxVail33							; product kind
-			dc.b	SonoraDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration (non-FPU for now)
-			dc.b	0									; unused
-			BitVector32	\								; Flags for valid base addresses  0-31				<SM29>	
-					ROMExists,\							; ROMAddr is valid									<SM29>
-					DiagROMExists,\						; DiagROMAddr is valid								<SM29>
-					VIA1Exists,\						; VIA1Addr is valid									<SM29>
-					SCCRdExists,\						; SCCRdAddr is valid								<SM29>
-					SCCWrExists,\						; SCCWrAddr is valid								<SM29>
-					IWMExists,\							; IWMAddr is valid									<SM29>
-					SCSIExists,\						; SCSIAddr is valid									<SM29>
-					SCSIDackExists,\					; SCSIDackAddr is valid								<SM29>
-					SCSIHskExists,\						; SCSIHskAddr is valid								<SM29>
-					ASCExists,\							; ASCAddr is valid									<SM29>
-					RBVExists,\							; RBV is valid										<SM29>
-					VDACExists,\						; VDACAddr (SONORA) is valid						<SM29>
-					SONICExists,\						; SONIC is valid									<SM29>
-					PatchRomExists						; PatchRomAddr is valid								<SM29>
-			BitVector32									; Flags for valid base addresses 32-63				<SM29>
-			BitVector32									; Flags for valid base addresses 64-95				<SM29>
-			dc.l	(ClockEgret)|\						; Has Egret clock/pram
-					(ADBEgret)|\						; Egret ADB
-					(Egret8)|\							;	Egret Eight firmware							<SM63> CSS
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(1<<SonoraExistsBit)|\				; SonoraExistsBit is valid							<H34>
-					(1<<hasHardPowerOff)				; hasHardPowerOff is valid							<H63>
-			dc.l	0									; Flags for valid ext feature flags 32-63			<SM29>
-			dc.l	0									; Flags for valid ext feature flags 64-95			<SM29>
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00,$00,$00,$00						; anything with this decoder matches
-			dc.l	VIA1InitVail-InfoVail33				; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	SndCntlLCIII-InfoVail33				; sound control vector table <H62>
-			dc.l	EgretClockPRAM-InfoVail33			; clock/PRAM vector table
-			dc.l	EgretADBTable-InfoVail33			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	SonoraIntTbl-InfoVail33				; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDHiVol|\						; CPU ID: hi volume design center
-					cpuIDinReg|\						; CPU ID: register contains complete ID
-					Vail33IDField						; CPU ID: Vail 33 Mhz
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoMacLC-InfoVail33			; offset to ICON info								<SM74>		
-
-
-		ENDIF											; {hasSonora}
-
-
-		IF hasDJMEMC THEN
-			IMPORT	DJMEMCIntTbl, SndCntlQuadra800
-
-;	20MHz Wombat product table  (Lego plastics)
-
-			ALIGN	4
-InfoWombat20
-			dc.l	djMEMCTable-InfoWombat20			; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoWombat20			; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoWombat20			; offset to video info
-			dc.l	NuBusInfoWombat-InfoWombat20		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip optional.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxWombat20							; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<H53><SM29>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$42,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 1			<H43>
-			dc.l	VIA1InitWombat-InfoWombat20			; VIA1 init info
-			dc.l	VIA2InitWombat-InfoWombat20			; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoWombat20		; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoWombat20			; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoWombat20			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoWombat20			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDHiEnd)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoLego-InfoWombat20			; offset to ICON info								<SM74>		
-
-
-;	25MHz Wombat product table  (Lego plastics)
-
-			ALIGN	4
-InfoCentris650
-			dc.l	djMEMCTable-InfoCentris650			; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoCentris650		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoCentris650		; offset to video info
-			dc.l	NuBusInfoWombat-InfoCentris650		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxCentris650						; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<H53><SM29>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$46,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 1, PA1 = 1			<H43>
-			dc.l	VIA1InitWombat-InfoCentris650		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoCentris650		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoCentris650		; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoCentris650			; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoCentris650			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoCentris650			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDHiEnd)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoLego-InfoCentris650			; offset to ICON info								<SM74>		
-
-
-;	33MHz Wombat product table  (Lego plastics)
-
-			ALIGN	4
-InfoQuadra650
-			dc.l	djMEMCTable-InfoQuadra650			; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoQuadra650			; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoQuadra650			; offset to video info
-			dc.l	NuBusInfoWombat-InfoQuadra650		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxQuadra650						; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$52,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 1, PA2 = 0, PA1 = 1			<H43>
-			dc.l	VIA1InitWombat-InfoQuadra650		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoQuadra650		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoQuadra650		; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoQuadra650			; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoQuadra650			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoQuadra650			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDHiEnd)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoLego-InfoQuadra650			; offset to ICON info								<SM74>		
-
-
-;	33MHz Wombat product table  (Frigidaire plastics)
-
-			ALIGN	4
-InfoQuadra800
-			dc.l	djMEMCTable-InfoQuadra800			; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoQuadra800			; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoQuadra800			; offset to video info
-			dc.l	NuBusInfoWombat-InfoQuadra800		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip optional.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxQuadra800						; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version								<SM29>
-			BitVector32	\								; Flags for valid base addresses  0-31				<SM29>
-					ROMExists,\							; ROMAddr is valid									<SM29>
-					DiagROMExists,\						; DiagROMAddr is valid								<SM29>
-					VIA1Exists,\						; VIA1Addr is valid									<SM29>
-					VIA2Exists,\						; VIA2Addr is valid									<SM29>
-					SCCRdExists,\						; SCCRdAddr is valid								<SM29>
-					SCCWrExists,\						; SCCWrAddr is valid								<SM29>
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<SM29>
-					IWMExists,\							; IWMAddr is valid									<SM29>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<SM29>
-					SONICExists,\						; SONIC is valid									<SM29>
-					PatchROMExists,\					; Patch ROM is valid								<SM29>
-					DAFBExists							; has DAFB video									<SM29>
-			BitVector32									; Flags for valid base addresses 32-63				<SM29>
-			BitVector32									; Flags for valid base addresses 64-95				<SM29>
-			dc.l	(ClockRTC)|\						; Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					; has stereo sound output
-					(SoundStereoMixing)|\				; has stereo mixing
-					(SoundPlayAndRecord)|\				; can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				; Wombat-style memory controller
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							; Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63			<SM29>
-			dc.l	0									; Flags for valid ext feature flags 64-95			<SM29>
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$12,$00,$00,$00						; VIA1: PA6 = 0, PA4 = 1, PA2 = 0, PA1 = 1			<H43><H46>
-			dc.l	VIA1InitWombat-InfoQuadra800		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoQuadra800		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoQuadra800		; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoQuadra800			; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoQuadra800			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoQuadra800			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDHiEnd)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoFrigidaire-InfoQuadra800	; offset to ICON info								<SM74>		
-
-
-;	40MHz Wombat product table (Lego plastics)
-
-			ALIGN	4
-InfoWombat40
-			dc.l	djMEMCTable-InfoWombat40			; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoWombat40			; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoWombat40			; offset to video info
-			dc.l	NuBusInfoWombat-InfoWombat40		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxWombat40							; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$56,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 1, PA2 = 1, PA1 = 1			<H43>
-			dc.l	VIA1InitWombat-InfoWombat40			; VIA1 init info
-			dc.l	VIA2InitWombat-InfoWombat40			; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoWombat40		; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoWombat40			; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoWombat40			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoWombat40			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDHiEnd)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoLego-InfoWombat40			; offset to ICON info								<SM74>		
-
-
-;	40MHz Wombat product table (Frigidaire package)
-
-			ALIGN	4
-InfoWombat40F
-			dc.l	djMEMCTable-InfoWombat40F			; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoWombat40F			; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoWombat40F			; offset to video info
-			dc.l	NuBusInfoWombat-InfoWombat40F		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxWombat40F						; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	0									; unused
-			BitVector32	\								; Flags for valid base addresses  0-31				<SM29>
-					ROMExists,\							; ROMAddr is valid									<SM29>
-					DiagROMExists,\						; DiagROMAddr is valid								<SM29>
-					VIA1Exists,\						; VIA1Addr is valid									<SM29>
-					VIA2Exists,\						; VIA2Addr is valid									<SM29>
-					SCCRdExists,\						; SCCRdAddr is valid								<SM29>
-					SCCWrExists,\						; SCCWrAddr is valid								<SM29>
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<SM29>
-					IWMExists,\							; IWMAddr is valid									<SM29>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<SM29>
-					SONICExists,\						; SONIC is valid									<SM29>
-					PatchROMExists,\					; Patch ROM is valid								<SM29>
-					DAFBExists							; has DAFB video									<SM29>
-			BitVector32									; Flags for valid base addresses 32-63				<SM29>
-			BitVector32									; Flags for valid base addresses 64-95				<SM29>
-			dc.l	(ClockRTC)|\						; Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					; has stereo sound output
-					(SoundStereoMixing)|\				; has stereo mixing
-					(SoundPlayAndRecord)|\				; can Play and Record simultaneously
-					(1<<djMEMCChipBit)|\				; Wombat-style memory controller
-					(ADBXcvr) 							; Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63			<SM29>
-			dc.l	0									; Flags for valid ext feature flags 64-95			<SM29>
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1	
-			dc.b	$16,$00,$00,$00						; VIA1: PA6 = 0, PA4 = 1, PA2 = 1, PA1 = 1
-			dc.l	VIA1InitWombat-InfoWombat40F		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoWombat40F		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoWombat40F		; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoWombat40F			; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoWombat40F			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoWombat40F			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDHiEnd)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoFrigidaire-InfoWombat40F	; offset to ICON info								<SM74>		
-
-
-;	20MHz WLCD product table  (QFC plastics)
-
-			ALIGN	4
-InfoCentris610
-			dc.l	djMEMCTable-InfoCentris610			; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoCentris610		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoCentris610		; offset to video info
-			dc.l	NuBusInfoWLCD-InfoCentris610		; offset to NuBus info								<H50><SM29>
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; No FPU chip present, but user could upgrade to 68RC040.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxCentris610						; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(1<<hasHardPowerOff)|\				; hasHardPowerOff is valid							<H63><SM29>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$40,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 0			<H43>
-			dc.l	VIA1InitWombat-InfoCentris610		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoCentris610		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoCentris610		; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoCentris610			; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoCentris610			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoCentris610				; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDHiEnd)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoCentris610			; offset to ICON info								<SM74>		
-
-
-
-;	25MHz WLCD product table  (QFC plastics)
-
-			ALIGN	4
-InfoQuadra610
-			dc.l	djMEMCTable-InfoQuadra610			; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoQuadra610			; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoQuadra610			; offset to video info
-			dc.l	NuBusInfoWLCD-InfoQuadra610			; offset to NuBus info								<H50><SM29>
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxQuadra610						; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(1<<hasHardPowerOff)|\				; hasHardPowerOff is valid							<H63><SM29>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$44,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 1, PA1 = 0			<H43>
-			dc.l	VIA1InitWombat-InfoQuadra610		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoQuadra610		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoQuadra610		; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoQuadra610			; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoQuadra610			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoQuadra610			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDHiEnd)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoQuadra610			; offset to ICON info								<SM74>		
-
-
-
-;	33MHz WLCD product table  (QFC package)
-
-			ALIGN	4
-InfoWLCD33
-			dc.l	djMEMCTable-InfoWLCD33				; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoWLCD33			; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoWLCD33			; offset to video info
-			dc.l	NuBusInfoWLCD-InfoWLCD33			; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxWLCD33							; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; ROM Resource configuration for optional FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version								<SM29>
-			BitVector32	\								; Flags for valid base addresses  0-31				<SM29>
-					ROMExists,\							; ROMAddr is valid									<SM29>
-					DiagROMExists,\						; DiagROMAddr is valid								<SM29>
-					VIA1Exists,\						; VIA1Addr is valid									<SM29>
-					VIA2Exists,\						; VIA2Addr is valid									<SM29>
-					SCCRdExists,\						; SCCRdAddr is valid								<SM29>
-					SCCWrExists,\						; SCCWrAddr is valid								<SM29>
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<SM29>
-					IWMExists,\							; IWMAddr is valid									<SM29>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<SM29>
-					SONICExists,\						; SONIC is valid									<SM29>
-					PatchROMExists,\					; Patch ROM is valid								<SM29>
-					DAFBExists							; has DAFB video									<SM29>
-			BitVector32									; Flags for valid base addresses 32-63				<SM29>
-			BitVector32									; Flags for valid base addresses 64-95				<SM29>
-			dc.l	(ClockRTC)|\						; Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					; Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					; has stereo sound output
-					(SoundStereoMixing)|\				; has stereo mixing
-					(SoundPlayAndRecord)|\				; can Play and Record simultaneously
-					(1<<djMEMCChipBit)|\				; Wombat-style memory controller
-					(1<<hasHardPowerOff)|\				; hasHardPowerOff is valid
-					(ADBXcvr) 							; Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63			<SM29>
-			dc.l	0									; Flags for valid ext feature flags 64-95			<SM29>
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1
-			dc.b	$50,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 1, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitWombat-InfoWLCD33			; VIA1 init info
-			dc.l	VIA2InitWombat-InfoWLCD33			; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoWLCD33			; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoWLCD33				; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoWLCD33				; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoWLCD33				; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDHiEnd)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoWLCD33				; offset to ICON info								<SM74>		
-
-	
-		IF forSmurf THEN
-		
-;	Centris610 with a Smurf card
-
-			ALIGN	4
-InfoRiscCentris610
-			dc.l	djMEMCTable-InfoRiscCentris610		; offset to decoder info
-			dc.l	RamInfoRISCDJMEMC-InfoRiscCentris610; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoRiscCentris610	; offset to video info
-			dc.l	NuBusInfoWLCD-InfoRiscCentris610	; offset to NuBus info								<H50><SM29>
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; No FPU chip present, but user could upgrade to 68RC040.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxRiscCentris650					; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(1<<hasHardPowerOff)|\				; hasHardPowerOff is valid							<H63><SM29>
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$40,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 0			<H43>
-			dc.l	VIA1InitWombat-InfoRiscCentris610	; VIA1 init info
-			dc.l	VIA2InitWombat-InfoRiscCentris610	; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoRiscCentris610	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoRiscCentris610		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoRiscCentris610		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoRiscCentris610		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; HiEnd design center
-					$1204								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoRiscCentris610		; offset to ICON info								<SM74>		
-
-
-;	Wombat product table w/Smurf...a centris650 (Lego plastics)
-
-			ALIGN	4
-InfoRiscCentris650											;													<SM48>
-			dc.l	djMEMCTable-InfoRiscCentris650		; offset to decoder info
-			dc.l	RamInfoRISCDJMEMC-InfoRiscCentris650; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoRiscCentris650	; offset to video info
-			dc.l	NuBusInfoWombat-InfoRiscCentris650	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxRiscCentris650					; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<H53><SM29>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(ADBXcvr)							;	Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$46,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 1, PA1 = 1			<H43>
-			dc.l	VIA1InitWombat-InfoRiscCentris650	; VIA1 init info
-			dc.l	VIA2InitWombat-InfoRiscCentris650	; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoRiscCentris650	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoRiscCentris650		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoRiscCentris650		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoRiscCentris650		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; CPU ID: RISC design center
-					$1200								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoLego-InfoRiscCentris650		; offset to ICON info								<SM74>		
-
-;	Quadra610 with a smurf card
-
-			ALIGN	4
-InfoRiscQuadra610
-			dc.l	djMEMCTable-InfoRiscQuadra610		; offset to decoder info
-			dc.l	RamInfoRISCDJMEMC-InfoRiscQuadra610	; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoRiscQuadra610		; offset to video info
-			dc.l	NuBusInfoWLCD-InfoRiscQuadra610		; offset to NuBus info								<H50><SM29>
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxRiscCentris650					; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(1<<hasHardPowerOff)|\				; hasHardPowerOff is valid							<H63><SM29>
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$44,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 1, PA1 = 0			<H43>
-			dc.l	VIA1InitWombat-InfoRiscQuadra610	; VIA1 init info
-			dc.l	VIA2InitWombat-InfoRiscQuadra610	; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoRiscQuadra610	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoRiscQuadra610		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoRiscQuadra610		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoRiscQuadra610		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; HiEnd design center
-					$1202								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoRiscQuadra610		; offset to ICON info								<SM74>		
-
-;	Quadra650 with a smurf card
-
-			ALIGN	4
-InfoRiscQuadra650
-			dc.l	djMEMCTable-InfoRiscQuadra650		; offset to decoder info
-			dc.l	RamInfoRISCDJMEMC-InfoRiscQuadra650	; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoRiscQuadra650		; offset to video info
-			dc.l	NuBusInfoWombat-InfoRiscQuadra650	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxRiscCentris650					; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$52,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 1, PA2 = 0, PA1 = 1			<H43>
-			dc.l	VIA1InitWombat-InfoRiscQuadra650	; VIA1 init info
-			dc.l	VIA2InitWombat-InfoRiscQuadra650	; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoRiscQuadra650	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoRiscQuadra650		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoRiscQuadra650		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoRiscQuadra650		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; CPU ID: RISC design center
-					$1203								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoLego-InfoRiscQuadra650		; offset to ICON info								<SM74>		
-
-
-;	Quadra800 with a Risc card
-
-			ALIGN	4
-InfoRiscQuadra800
-			dc.l	djMEMCTable-InfoRiscQuadra800		; offset to decoder info
-			dc.l	RamInfoRISCDJMEMC-InfoRiscQuadra800	; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoRiscQuadra800		; offset to video info
-			dc.l	NuBusInfoWombat-InfoRiscQuadra800	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip optional.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxRiscCentris650					; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version								<SM29>
-			BitVector32	\								; Flags for valid base addresses  0-31				<SM29>
-					ROMExists,\							; ROMAddr is valid									<SM29>
-					VIA1Exists,\						; VIA1Addr is valid									<SM29>
-					VIA2Exists,\						; VIA2Addr is valid									<SM29>
-					SCCRdExists,\						; SCCRdAddr is valid								<SM29>
-					SCCWrExists,\						; SCCWrAddr is valid								<SM29>
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<SM29>
-					IWMExists,\							; IWMAddr is valid									<SM29>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<SM29>
-					SONICExists,\						; SONIC is valid									<SM29>
-					PatchROMExists,\					; Patch ROM is valid								<SM29>
-					DAFBExists							; has DAFB video									<SM29>
-			BitVector32									; Flags for valid base addresses 32-63				<SM29>
-			BitVector32									; Flags for valid base addresses 64-95				<SM29>
-			dc.l	(ClockRTC)|\						; Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					; has stereo sound output
-					(SoundStereoMixing)|\				; has stereo mixing
-					(SoundPlayAndRecord)|\				; can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				; Wombat-style memory controller
-					(ADBXcvr) 							; Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95			<SM29>
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$12,$00,$00,$00						; VIA1: PA6 = 0, PA4 = 1, PA2 = 0, PA1 = 1			<H43><H46>
-			dc.l	VIA1InitWombat-InfoRiscQuadra800	; VIA1 init info
-			dc.l	VIA2InitWombat-InfoRiscQuadra800	; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoRiscQuadra800	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoRiscQuadra800		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoRiscQuadra800		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoRiscQuadra800		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; HiEnd design center
-					$1201								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoFrigidaire-InfoRiscQuadra800; offset to ICON info								<SM74>		
-
-		ENDIF											; {for smurf}
-
-
-		ENDIF											; {hasDJMEMC}
-
-
-		IF forSTP601 THEN
-		
-;	25MHz STP Wombat product table  (Lego plastics)
-
-			ALIGN	4
-InfoSTPCentris650
-			dc.l	djMEMCTable-InfoSTPCentris650		; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoSTPCentris650		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoSTPCentris650		; offset to video info
-			dc.l	NuBusInfoWombat-InfoSTPCentris650	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxSTPC650							; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<H53><SM29>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$46,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 1, PA1 = 1			<H43>
-			dc.l	VIA1InitWombat-InfoSTPCentris650	; VIA1 init info
-			dc.l	VIA2InitWombat-InfoSTPCentris650	; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoSTPCentris650	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoSTPCentris650		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoSTPCentris650		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoSTPCentris650		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	((cpuIDRISC))|\						; RISC design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoLego-InfoSTPCentris650		; offset to ICON info								<SM74>		
-
-
-;	33MHz STP Wombat product table  (Lego plastics)
-
-			ALIGN	4
-InfoSTPQuadra650
-			dc.l	djMEMCTable-InfoSTPQuadra650		; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoSTPQuadra650		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoSTPQuadra650		; offset to video info
-			dc.l	NuBusInfoWombat-InfoSTPQuadra650	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.	
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxSTPQ650							; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$52,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 1, PA2 = 0, PA1 = 1			<H43>
-			dc.l	VIA1InitWombat-InfoSTPQuadra650		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoSTPQuadra650		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoSTPQuadra650	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoSTPQuadra650		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoSTPQuadra650		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoSTPQuadra650		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; risc design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoLego-InfoSTPQuadra650		; offset to ICON info								<SM74>		
-
-
-;	33MHz STP Wombat product table  (Frigidaire plastics)
-
-			ALIGN	4
-InfoSTPQuadra800
-			dc.l	djMEMCTable-InfoSTPQuadra800		; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoSTPQuadra800		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoSTPQuadra800		; offset to video info
-			dc.l	NuBusInfoWombat-InfoSTPQuadra800	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.	
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxSTPQ800							; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version								<SM29>
-			BitVector32	\								; Flags for valid base addresses  0-31				<SM29>
-					ROMExists,\							; ROMAddr is valid									<SM29>
-					DiagROMExists,\						; DiagROMAddr is valid								<SM29>
-					VIA1Exists,\						; VIA1Addr is valid									<SM29>
-					VIA2Exists,\						; VIA2Addr is valid									<SM29>
-					SCCRdExists,\						; SCCRdAddr is valid								<SM29>
-					SCCWrExists,\						; SCCWrAddr is valid								<SM29>
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<SM29>
-					IWMExists,\							; IWMAddr is valid									<SM29>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<SM29>
-					SONICExists,\						; SONIC is valid									<SM29>
-					PatchROMExists,\					; Patch ROM is valid								<SM29>
-					DAFBExists							; has DAFB video									<SM29>
-			BitVector32									; Flags for valid base addresses 32-63				<SM29>
-			BitVector32									; Flags for valid base addresses 64-95				<SM29>
-			dc.l	(ClockRTC)|\						; Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					; has stereo sound output
-					(SoundStereoMixing)|\				; has stereo mixing
-					(SoundPlayAndRecord)|\				; can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				; Wombat-style memory controller
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							; Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95			<SM29>
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$12,$00,$00,$00						; VIA1: PA6 = 0, PA4 = 1, PA2 = 0, PA1 = 1			<H43><H46>
-			dc.l	VIA1InitWombat-InfoSTPQuadra800		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoSTPQuadra800		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoSTPQuadra800	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoSTPQuadra800		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoSTPQuadra800		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoSTPQuadra800		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; risc design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoFrigidaire-InfoSTPQuadra800	; offset to ICON info								<SM74>		
-
-
-;	40MHz STP Wombat product table  (Frigidaire plastics)
-
-			ALIGN	4
-InfoSTPQuadra40F
-			dc.l	djMEMCTable-InfoSTPQuadra40F			; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoSTPQuadra40F			; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoSTPQuadra40F			; offset to video info
-			dc.l	NuBusInfoWombat-InfoSTPQuadra40F		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxSTPQ800							; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version								<SM29>
-			BitVector32	\								; Flags for valid base addresses  0-31				<SM29>
-					ROMExists,\							; ROMAddr is valid									<SM29>
-					DiagROMExists,\						; DiagROMAddr is valid								<SM29>
-					VIA1Exists,\						; VIA1Addr is valid									<SM29>
-					VIA2Exists,\						; VIA2Addr is valid									<SM29>
-					SCCRdExists,\						; SCCRdAddr is valid								<SM29>
-					SCCWrExists,\						; SCCWrAddr is valid								<SM29>
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<SM29>
-					IWMExists,\							; IWMAddr is valid									<SM29>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<SM29>
-					SONICExists,\						; SONIC is valid									<SM29>
-					PatchROMExists,\					; Patch ROM is valid								<SM29>
-					DAFBExists							; has DAFB video									<SM29>
-			BitVector32									; Flags for valid base addresses 32-63				<SM29>
-			BitVector32									; Flags for valid base addresses 64-95				<SM29>
-			dc.l	(ClockRTC)|\						; Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					; has stereo sound output
-					(SoundStereoMixing)|\				; has stereo mixing
-					(SoundPlayAndRecord)|\				; can Play and Record simultaneously
-					(1<<djMEMCChipBit)|\				; Wombat-style memory controller
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							; Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95			<SM29>
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1	
-			dc.b	$16,$00,$00,$00						; VIA1: PA6 = 0, PA4 = 1, PA2 = 1, PA1 = 1
-			dc.l	VIA1InitWombat-InfoSTPQuadra40F		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoSTPQuadra40F		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoSTPQuadra40F		; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoSTPQuadra40F			; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoSTPQuadra40F			; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoSTPQuadra40F			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; HiEnd design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoFrigidaire-InfoSTPQuadra40F	; offset to ICON info								<SM74>		
-
-
-;	20MHz STP WLCD product table  (QFC plastics)
-
-			ALIGN	4
-InfoSTPCentris610
-			dc.l	djMEMCTable-InfoSTPCentris610		; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoSTPCentris610		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoSTPCentris610		; offset to video info
-			dc.l	NuBusInfoWLCD-InfoSTPCentris610		; offset to NuBus info								<H50><SM29>
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.	
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxSTPC610							; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(1<<hasHardPowerOff)|\				; hasHardPowerOff is valid							<H63><SM29>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$40,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 0			<H43>
-			dc.l	VIA1InitWombat-InfoSTPCentris610	; VIA1 init info
-			dc.l	VIA2InitWombat-InfoSTPCentris610	; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoSTPCentris610	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoSTPCentris610		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoSTPCentris610		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoSTPCentris610		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; risc design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoSTPCentris610		; offset to ICON info								<SM74>		
-
-
-;	25MHz STP WLCD product table  (QFC plastics)
-
-			ALIGN	4
-InfoSTPQuadra610
-			dc.l	djMEMCTable-InfoSTPQuadra610		; offset to decoder info
-			dc.l	RamInfoDJMEMC-InfoSTPQuadra610		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoSTPQuadra610		; offset to video info
-			dc.l	NuBusInfoWLCD-InfoSTPQuadra610		; offset to NuBus info								<H50><SM29>
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.	
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxSTPQ610							; product kind
-			dc.b	djMEMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					PatchROMExists,\					; Patch ROM is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags  0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<djMEMCChipBit)|\				;	Wombat-style memory controller
-					(1<<hasHardPowerOff)|\				; hasHardPowerOff is valid							<H63><SM29>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1: PA6 PA4, PA2, PA1						<H43>
-			dc.b	$44,$00,$00,$00						; VIA1: PA6 = 1, PA4 = 0, PA2 = 1, PA1 = 0			<H43>
-			dc.l	VIA1InitWombat-InfoSTPQuadra610		; VIA1 init info
-			dc.l	VIA2InitWombat-InfoSTPQuadra610		; VIA2 init info
-			dc.l	SndCntlQuadra800-InfoSTPQuadra610	; sound control vector table						<SM42>
-			dc.l	RTCClockPRAM-InfoSTPQuadra610		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoSTPQuadra610		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	DJMEMCIntTbl-InfoSTPQuadra610		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; risc design center
-					(cpuIDinVIA)|\						; supplemental ID in VIA1
-					$3AD								; specific ID
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoSTPQuadra610		; offset to ICON info								<SM74>		
-
-
-		ENDIF											; {forSTP601}
-
-
-		IF hasYMCA AND hasPSC THEN						; used to be MMC									<SM46>
-
-			IMPORT	SndCntlCyclone, PSCIntTbl
-
-;	33 MHz Cyclone product table
-
-			ALIGN	4
-InfoCyclone33
-			dc.l	CycloneDecoderTable-InfoCyclone33	; offset to decoder info for EVT4 					<SM19>
-			dc.l	RamInfoCyclone-InfoCyclone33		; offset to ram bank info							<SM19>
-			dc.l	VideoInfoCyclone-InfoCyclone33		; offset to video info
-			dc.l	NuBusInfoCyclone-InfoCyclone33		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxCyclone33						; product kind
-			dc.b	YMCADecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					NewAgeExists,\						; NewAge is valid
-					SCSI96_1Exists,\					; SCSI 96 is valid
-					PSCExists							; PSC DMA is valid
-			BitVector32	\								; Flags for valid base addresses 32-63
-					DSPExists,\							; DSP is valid
-					MaceExists, \						; MACE is valid
-					MUNIExists, \						; MUNI is valid										<SM34>
-					CivicExists,\						; Civic video is valid
-					SebastianExists 					; Sebastian CLUT DAC is valid				
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware						
-					(SoundHasSoundIn)|\					;	Has Sound In									<LW7>
-					(Sound16Bit)|\						;	Has 16-bit hardware								<LW7>
-					(SoundStereoIn)|\					;	has stereo sound input							<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing								
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<LW7>				
-					(1 << SoundLineLevel)				;	requires line level on sound input port			<LW7>				
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<SerialDMA//32)|\				;	hardware requires SerialDMA driver
-					(SHALPSC)|\							;	using PSC HAL
-					(1<<hasEnhancedLTalk//32)			;	has CURIO LocalTalk enhancements
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$07									; CPU ID.											<SM19>
-			dc.b	$00,$00,$00							; Filler.							
-			dc.l	VIA1InitCyclone-InfoCyclone33		; VIA1 init info
-			dc.l	VIA2InitCyclone-InfoCyclone33		; VIA2 init info
-			dc.l	SndCntlCyclone-InfoCyclone33		; sound control vector table	
-			dc.l	CudaClockPRAM-InfoCyclone33			; clock/PRAM vector table		
-			dc.l	CudaADBTable-InfoCyclone33			; ADB/DebugUtil vector table						<SM35>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	PSCIntTbl-InfoCyclone33				; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDHiEnd|\						; CPU ID: hi end design center		
-					cpuIDinMMC|\						; CPU ID: Extended ID in MMC.
-					$30									; CPU ID: Cyclone Family is ID $30			
-			dc.w	0									; spare												<SM74>
-			dc.l	FrigidaireIcon-InfoCyclone33		; offset to ICON info •• fake for now ••			<SM74>		
-
-
-;	40 MHz Cyclone product table
-
-			ALIGN	4
-InfoQuadra840AV
-			dc.l	CycloneDecoderTable-InfoQuadra840AV	; offset to decoder info for EVT4 				
-			dc.l	RamInfoCyclone-InfoQuadra840AV		; offset to ram bank info						
-			dc.l	VideoInfoCyclone-InfoQuadra840AV	; offset to video info
-			dc.l	NuBusInfoCyclone-InfoQuadra840AV	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxQuadra840AV						; product kind
-			dc.b	YMCADecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					NewAgeExists,\						; NewAge is valid
-					SCSI96_1Exists,\					; SCSI 96 is valid
-					PSCExists							; PSC DMA is valid
-			BitVector32	\								; Flags for valid base addresses 32-63
-					DSPExists,\							; DSP is valid
-					MaceExists, \						; MACE is valid
-					MUNIExists, \						; MUNI is valid										<SM34>
-					CivicExists,\						; Civic video is valid
-					SebastianExists 					; Sebastian CLUT DAC is valid				
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware						
-					(SoundHasSoundIn)|\					;	Has Sound In									<LW7>
-					(Sound16Bit)|\						;	Has 16-bit hardware								<LW7>
-					(SoundStereoIn)|\					;	has stereo sound input							<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing								
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<LW7>				
-					(1 << SoundLineLevel)				;	requires line level on sound input port			<LW7>				
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<SerialDMA//32)|\				;	hardware requires SerialDMA driver
-					(SHALPSC)|\							;	using PSC HAL
-					(1<<hasEnhancedLTalk//32)			;	has CURIO LocalTalk enhancements
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$0F									; CPU ID.  update for EVT6				<LW3>																						
-			dc.b	$00,$00,$00							; Filler.							
-			dc.l	VIA1InitCyclone-InfoQuadra840AV		; VIA1 init info
-			dc.l	VIA2InitCyclone-InfoQuadra840AV		; VIA2 init info
-			dc.l	SndCntlCyclone-InfoQuadra840AV		; sound control vector table	
-			dc.l	CudaClockPRAM-InfoQuadra840AV		; clock/PRAM vector table		
-			dc.l	CudaADBTable-InfoQuadra840AV		; ADB/DebugUtil vector table						
-			dc.l	0									; no Power Manager primitives					
-			dc.l	PSCIntTbl-InfoQuadra840AV			; interrupt handlers table							
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDHiEnd|\						; CPU ID: hi end design center		
-					cpuIDinMMC|\						; CPU ID: Extended ID in MMC.
-					$30									; CPU ID: Cyclone Family is ID $30			
-			dc.w	0									; spare												<SM74>
-			dc.l	FrigidaireIcon-InfoQuadra840AV		; offset to ICON info •• fake for now ••			<SM74>		
-
-
-;	25 MHz Tempest product table
-
-			ALIGN	4
-InfoCentris660AV
-			dc.l	CycloneDecoderTable-InfoCentris660AV; offset to decoder info (Same as Cyclone)		
-			dc.l	RamInfoTempest-InfoCentris660AV		; offset to ram bank info			
-			dc.l	VideoInfoTempest-InfoCentris660AV	; offset to video info (Same as Cyclone)
-			dc.l	NuBusInfoTempest-InfoCentris660AV	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxCentris660AV						; product kind
-			dc.b	YMCADecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					NewAgeExists,\						; NewAge is valid
-					SCSI96_1Exists,\					; SCSI 96 is valid
-					PSCExists							; PSC DMA is valid
-			BitVector32	 								; Flags for valid base addresses 32-63		(Leave empty so that features are checked)		<SM34>
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware						
-					(SoundHasSoundIn)|\					;	Has Sound In									<LW7>
-					(Sound16Bit)|\						;	Has 16-bit hardware								<LW7>
-					(SoundStereoIn)|\					;	has stereo sound input							<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing								
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<LW7>				
-					(1 << SoundLineLevel)|\				;	requires line level on sound input port			<LW7>				
-					(1<<hasHardPowerOff)				;   hasHardPowerOff is valid						<SM32>
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<SerialDMA//32)|\				;	hardware requires SerialDMA driver
-					(SHALPSC)|\							;	using PSC HAL
-					(1<<hasEnhancedLTalk//32)			;	has CURIO LocalTalk enhancements
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$0B									; CPU ID.														
-			dc.b	$00,$00,$00							; Filler.							
-			dc.l	VIA1InitCyclone-InfoCentris660AV	; VIA1 init info (Same as Cyclone)
-			dc.l	VIA2InitCyclone-InfoCentris660AV	; VIA2 init info (Same as Cyclone)
-			dc.l	SndCntlCyclone-InfoCentris660AV		; sound control vector table (Same as Cyclone)	
-			dc.l	CudaClockPRAM-InfoCentris660AV		; clock/PRAM vector table (Same as Cyclone)		
-			dc.l	CudaADBTable-InfoCentris660AV		; ADB/DebugUtil vector table						<SM35>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	PSCIntTbl-InfoCentris660AV			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDHiEnd|\						; CPU ID: hi end design center		
-					cpuIDinMMC|\						; CPU ID: Extended ID in MMC.
-					$30									; CPU ID: Cyclone Family is ID $30			
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoCentris660AV		; offset to ICON info •• fake for now ••			<SM74>		
-
-
-;	33 MHz Tempest product table
-
-			ALIGN	4
-InfoTempest33
-			dc.l	CycloneDecoderTable-InfoTempest33	; offset to decoder info (Same as Cyclone)		
-			dc.l	RamInfoTempest-InfoTempest33		; offset to ram bank info			
-			dc.l	VideoInfoTempest-InfoTempest33		; offset to video info (Same as Cyclone)
-			dc.l	NuBusInfoTempest-InfoTempest33		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxTempest33						; product kind
-			dc.b	YMCADecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					NewAgeExists,\						; NewAge is valid
-					SCSI96_1Exists,\					; SCSI 96 is valid
-					PSCExists							; PSC DMA is valid
-			BitVector32	 								; Flags for valid base addresses 32-63				<SM34>
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware						
-					(SoundHasSoundIn)|\					;	Has Sound In									<LW7>
-					(Sound16Bit)|\						;	Has 16-bit hardware								<LW7>
-					(SoundStereoIn)|\					;	has stereo sound input							<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing								
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<LW7>				
-					(1 << SoundLineLevel)|\				;	requires line level on sound input port			<LW7>				
-					(1<<hasHardPowerOff)				;   hasHardPowerOff is valid						<SM32>
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<SerialDMA//32)|\				;	hardware requires SerialDMA driver
-					(SHALPSC)|\							;	using PSC HAL
-					(1<<hasEnhancedLTalk//32)			;	has CURIO LocalTalk enhancements
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$08									; CPU ID.														
-			dc.b	$00,$00,$00							; Filler.							
-			dc.l	VIA1InitCyclone-InfoTempest33		; VIA1 init info (Same as Cyclone)
-			dc.l	VIA2InitCyclone-InfoTempest33		; VIA2 init info (Same as Cyclone)
-			dc.l	SndCntlCyclone-InfoTempest33		; sound control vector table (Same as Cyclone)	
-			dc.l	CudaClockPRAM-InfoTempest33			; clock/PRAM vector table (Same as Cyclone)		
-			dc.l	CudaADBTable-InfoTempest33			; ADB/DebugUtil vector table						<SM35>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	PSCIntTbl-InfoTempest33				; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDHiEnd|\						; CPU ID: hi end design center		
-					cpuIDinMMC|\						; CPU ID: Extended ID in MMC.
-					$30									; CPU ID: Cyclone Family is ID $30			
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoTempest33			; offset to ICON info •• fake for now ••			<SM74>		
-
-		ENDIF											; hasYMCA
-		
-		
-		IF hasHMC THEN									;													<SM46>
-
-;	ProductInfo table for PDM
-
-			IMPORT	SndCntlPDM, AMICIntTbl				; <SM75><SM76>
-
-			ALIGN	4
-InfoPDM													; PDM Family										<SM71>
-			dc.l	HMCDecoderTable-InfoPDM				; offset to decoder info
-			dc.l	RamInfoPDM-InfoPDM					; offset to ram bank info
-			dc.l	VideoInfoPDM-InfoPDM				; PDM built in video
-			dc.l	NuBusInfoPDM-InfoPDM				; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						;   SCSI port present
-					(1<<hwCbClock)|\					;   New clock chip present
-					(0<<hwCbFPU)|\						;   No FPU chip present.
-					(1<<hwCbMMU)|\						;   Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						;   Apple Desktop Bus present.
-			dc.b	boxPDM50WLCD						; product kind
-			dc.b	HMCDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability?
-			dc.b	4									; default ROM Resource configuration for non-FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							;   ROMAddr is valid
-					VIA1Exists,\						;   VIA1Addr is valid
-					RBVExists,\							;   RBVAddr is valid
-					SCCRdExists,\						;   SCCRdAddr may be valid	
-					SCCWrExists,\						;   SCCWrAddr may be valid	
-					ASCExists,\							;   ASC isn't valid, but say it is	
-					SCSI96_1Exists						;   1st SCSI96 is valid		
-			BitVector32 								; Flags for valid base addresses 32-63 (leave empty)<SM83>
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware
-					(SoundHasSoundIn)|\					;	Has Sound In
-					(Sound16Bit)|\						;	Has 16-bit hardware
-					(SoundStereoIn)|\					;	has stereo sound input
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing								
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously
-					(1<<SoundLineLevel)|\				;	requires line level on sound input port			<SM79>				
-					(1<<hasHardPowerOff)|\				; 	hasHardPowerOff is valid
-					(1<<hasNewMemMgr)					;	hasNewMemMgr support (ie Figment can be switched on)
 			dc.l	\									; Flags for valid ext feature flags 32-63
 					(1<<has68kEmulator//32)|\			;	This ROM starts up with a 68k emulator
-					(1<<SerialDMA//32)|\				;	hardware requires SerialDMA driver
-					(SHALAMIC)|\						;	using AMIC HAL
-					(1<<hasEnhancedLTalk//32)			;	gots Enhanced curio LTalk						<MC5>
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$00,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitPDM-InfoPDM					; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	SndCntlPDM-InfoPDM					; sound control vector table <SM75>
-			dc.l	CudaClockPRAM-InfoPDM				; clock/PRAM vector table
-			dc.l	CudaADBTable-InfoPDM				; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives
-			dc.l	AMICIntTbl-InfoPDM					; interrupt handlers table
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; CPU ID: RISC design center
-					(cpuIDinReg)|\						; CPU ID: ID only in Reg
-					$3011								; CPU ID: PDM ID is $3011
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQFC-InfoPDM					; offset to ICON info								<SM74>		
-
-			ALIGN	4
-InfoPDMcoldFusion										; Cold Fusion										<SM80> SAM
-			dc.l	HMCcfDecoderTable-InfoPDMcoldfusion	; offset to decoder info
-			dc.l	RamInfoPDM-InfoPDMcoldfusion		; offset to ram bank info
-			dc.l	VideoInfoPDM-InfoPDMcoldfusion		; PDM built in video
-			dc.l	NuBusInfoCFusion-InfoPDMcoldfusion	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						;   SCSI port present
-					(1<<hwCbClock)|\					;   New clock chip present
-					(0<<hwCbFPU)|\						;   No FPU chip present.
-					(1<<hwCbMMU)|\						;   Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						;   Apple Desktop Bus present.
-			dc.b	boxPDM66F							; product kind
-			dc.b	HMCDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, ColorQD
-			dc.b	4									; default ROM Resource configuration for non-FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							;   ROMAddr is valid
-					VIA1Exists,\						;   VIA1Addr is valid
-					RBVExists,\							;   RBVAddr is valid
-					SCCRdExists,\						;   SCCRdAddr may be valid	
-					SCCWrExists,\						;   SCCWrAddr may be valid	
-					ASCExists,\							;   ASC isn't valid, but say it is	
-					SCSI96_1Exists,\					;   1st SCSICF96 is valid (internal)
-					SCSI96_2Exists						;   1st SCSIC96 is valid (external)		
-			BitVector32 								; Flags for valid base addresses 32-63 (leave empty)	<GMR>
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware
-					(SoundHasSoundIn)|\					;	Has Sound In
-					(Sound16Bit)|\						;	Has 16-bit hardware
-					(SoundStereoIn)|\					;	has stereo sound input
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing								
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously
-					(1 << SoundLineLevel)|\				;	requires line level on sound input port
-					(1<<hasNewMemMgr)					;	hasNewMemMgr support (ie Figment can be switched on)
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)|\			;	This ROM starts up with a 68k emulator
-					(1<<SerialDMA//32)|\				;	hardware requires SerialDMA driver
-					(SHALAMIC)|\						;	using AMIC HAL
-					(1<<hasEnhancedLTalk//32)			;	gots Enhanced curio LTalk						<MC5>
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$00,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitPDM-InfoPDMcoldfusion		; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	SndCntlPDM-InfoPDMcoldfusion		; sound control vector table
-			dc.l	CudaClockPRAM-InfoPDMcoldfusion		; clock/PRAM vector table
-			dc.l	CudaADBTable-InfoPDMcoldfusion		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives
-			dc.l	AMICIntTbl-InfoPDMcoldfusion		; interrupt handlers table
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; CPU ID: RISC design center
-					(cpuIDinReg)|\						; CPU ID: ID only in Reg
-					$3013								; CPU ID: ColdFusion ID is $3013
-			dc.w	0									; spare
-			dc.l	IconInfoFrigidaire-InfoPDMcoldfusion; offset to ICON info
-
-			ALIGN	4
-
-InfoPDMCarlSagan										; Carl Sagan										<SM88>
-			dc.l	HMCDecoderTable-InfoPDMCarlSagan	; offset to decoder info
-			dc.l	RamInfoPDM-InfoPDMCarlSagan			; offset to ram bank info
-			dc.l	VideoInfoPDM-InfoPDMCarlSagan		; PDM built in video
-			dc.l	NuBusInfoCFusion-InfoPDMCarlSagan	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						;   SCSI port present
-					(1<<hwCbClock)|\					;   New clock chip present
-					(0<<hwCbFPU)|\						;   No FPU chip present.
-					(1<<hwCbMMU)|\						;   Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						;   Apple Desktop Bus present.
-			dc.b	boxPDM66L							; product kind
-			dc.b	HMCDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, ColorQD
-			dc.b	4									; default ROM Resource configuration for non-FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							;   ROMAddr is valid
-					VIA1Exists,\						;   VIA1Addr is valid
-					RBVExists,\							;   RBVAddr is valid
-					SCCRdExists,\						;   SCCRdAddr may be valid	
-					SCCWrExists,\						;   SCCWrAddr may be valid	
-					ASCExists,\							;   ASC isn't valid, but say it is	
-					SCSI96_1Exists						;   1st SCSICF96 is valid (internal)
-			BitVector32 \								; Flags for valid base addresses 32-63
-					AwacsExists,\						;   AwacsAddr is valid
-					MaceExists, \						;	MACE is valid
-					AMICExists,\						;	AMIC DMA IO controller exists
-					SWIM3Exists,\						;	SWIM3 DMA floppy controller exists
-					BartExists							; 	BART (NuBus controller) exists					<SM83>
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware
-					(SoundHasSoundIn)|\					;	Has Sound In
-					(Sound16Bit)|\						;	Has 16-bit hardware
-					(SoundStereoIn)|\					;	has stereo sound input
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing								
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously
-					(1 << SoundLineLevel)|\				;	requires line level on sound input port
-					(1<<hasNewMemMgr)					;	hasNewMemMgr support (ie Figment can be switched on)
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)|\			;	This ROM starts up with a 68k emulator
-					(1<<SerialDMA//32)|\				;	hardware requires SerialDMA driver
-					(SHALAMIC)|\						;	using AMIC HAL
-					(1<<hasEnhancedLTalk//32)			;	gots Enhanced curio LTalk						<MC5>
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$00,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitPDM-InfoPDMCarlSagan		; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	SndCntlPDM-InfoPDMCarlSagan			; sound control vector table
-			dc.l	CudaClockPRAM-InfoPDMCarlSagan		; clock/PRAM vector table
-			dc.l	CudaADBTable-InfoPDMCarlSagan		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives
-			dc.l	AMICIntTbl-InfoPDMCarlSagan			; interrupt handlers table
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; CPU ID: RISC design center
-					(cpuIDinReg)|\						; CPU ID: ID only in Reg
-					$3012								; CPU ID: Carl Sagan ID is $3012
-			dc.w	0									; spare
-			dc.l	IconInfoLego-InfoPDMCarlSagan		; offset to ICON info
-
-
-	ENDIF												; hasHMC
-
-	IF hasGrandCentral THEN
-
-			IMPORT	GCIntTbl, SndCntlPDM
-
-; TNT bringup board product table
-
-			ALIGN	4
-InfoTNTProto1
-			dc.l	HHeadDecoderTable-InfoTNTProto1		; offset to decoder info for EVT4
-			dc.l	RamInfoTNT-InfoTNTProto1			; offset to ram bank info
-			dc.l	VideoInfoTNT-InfoTNTProto1			; Pseudo TNT built in video
-			dc.l	NuBusInfoTNT-InfoTNTProto1			; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						;   SCSI port present
-					(1<<hwCbClock)|\					;   New clock chip present
-					(0<<hwCbFPU)|\						;   No FPU chip present.
-					(1<<hwCbMMU)|\						;   Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						;   Apple Desktop Bus present.
-			dc.b	BoxTNTProto1						; product kind
-			dc.b	HHeadDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							;   ASC isn't valid, but say it is	
-					SCSI96_1Exists,\					; SCSI 96 bus 1 is valid (internal)
-					SCSI96_2Exists						; SCSI 96 bus 2 is valid (external)
-			BitVector32	\								; Flags for valid base addresses 32-63
-					MaceExists, \						; MACE is valid
-					SWIM3Exists, \						; MUNI is valid
-					AwacsExists, \						; Awacs is valid
-					GrandCentralExists					; Grand Central is valid
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware
-					(SoundHasSoundIn)|\					;	Has Sound In
-					(Sound16Bit)|\						;	Has 16-bit hardware
-					(SoundStereoIn)|\					;	has stereo sound input
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundStereoMixing)|\				;	has stereo mixing								
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously
-					(1 << SoundLineLevel)|\				;	requires line level on sound input port
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(1<<SoftVBL)						; 	SoftVBL is valid		
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)|\			;	This ROM starts up with a 68k emulator
-					(1<<hasEnhancedLTalk//32)			;	has CURIO LocalTalk enhancements
+					(1<<37//32)|\
+					(1<<38//32)|\
+					(1<<50//32)
 			dc.l	0									; Flags for valid ext feature flags 64-95
 			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00									; CPU ID
-			dc.b	$00,$00,$00							; Filler
-			dc.l	VIA1InitTNT-InfoTNTProto1			; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	SndCntlPDM-InfoTNTProto1			; sound control vector table <SM75>
-			dc.l	CudaClockPRAM-InfoTNTProto1			; clock/PRAM vector table
-			dc.l	CudaADBTable-InfoTNTProto1			; ADB/DebugUtil vector table
+			dc.b	$00,$00,$00,$00						; anything with this decoder matches
+			dc.l	$1a4								; VIA1 init info
+			dc.l	0									; no VIA2 init info
+			dc.l	SndCntlNW-InfoNewWorld				; sound control vector table
+			dc.l	NWClockPRAM-InfoNewWorld			; clock/PRAM vector table
+			dc.l	DummyADBTable-InfoNewWorld			; ADB/DebugUtil vector table
 			dc.l	0									; no Power Manager primitives
-			dc.l	GCIntTbl-InfoTNTProto1				; interrupt handlers table
-			dc.l	0									; internal modem manager					
-			dc.w	cpuIDHiEnd|\						; CPU ID: hi end design center
-					(cpuIDinReg)|\						; CPU ID: ID only in Reg
-					$3020								; CPU ID: PDM ID is $3011
+			dc.l	NWIntTbl-InfoNewWorld				; interrupt handlers table
+			dc.l	0									; no internal modem manager					
+			dc.w	cpuIDRISC|\							; CPU ID: RISC design center
+					cpuIDinReg|\						; CPU ID: register contains complete ID
+					$35									; specific ID
 			dc.w	0									; spare
-			dc.l	IconInfoFrigidaire-InfoTNTProto1	; offset to ICON info
-
-	ENDIF											; {hasGrandCentral}
-
-
-
-;_______________________________________________________________________
-;
-;	•••	The following applies only to older CPUs that do not support the
-;	•••	CPUID register identification scheme.
-;
-;   The tables below figure out which logic board we are running on.  Some VIA bits
-;	have been dedicated to this task starting with the Mac II.  On other machines,
-;	we need to be more clever to determine which board it is.
-;
-;   For 020/030 based machines, the VIA bits are used.  For the Mac II, IIx, IIcx and
-;   SE30 machines, the ID bits are PA6 on VIA1 aand PB3 on VIA2.  Note that on the
-;   Mac II, PB3 on VIA 2 is normally an output that controls the MMU, but when read as an
-;   input it is pulled high internal to the VIA.
-;
-;		PA6 PB3 machine
-;
-;        0   0   Mac IIx
-;        0   1   Mac II
-;        1   0   Mac SE 30
-;		 1   1   Mac IIcx
-;
-;   For newer machines, Via 1 port A has four bits dedicated to a logic board ID.  These bits
-;	are defined as follows:
-;
-;		PA6 PA4 PA2 PA1 machine																				<5.0>
-;		 1   1   1   1	Aurora 25MHz, CX package  	IIci
-;		 1   1   1   0	Elsie (was Foursquare)		LC														<12>
-;		 1   1   0   1	F19   						IIfx
-;		 1   0   1   1  Aurora 16MHz, CX package
-;		 0   1   1   1	Erickson					IIsi
-;		 0   0   1   1  Aurora 16MHz, SE package	(reserved for future)
-;		 1   1   0   0	Eclipse						Quadra900												<13>
-;		 1	 0	 0	 0	Spike						Quadra700
-;		 0   1   0   1	TIM							PowerBook170											<36>
-;		 0   1   1   0	Waimea																				<36>
-
-
-		IF hasOrwell THEN
-			IMPORT	SndCntlQuadra700, SndCntlQuadra900, Quadra700IntTbl, Quadra900IntTbl
-
-			ALIGN	4
-InfoQuadra700
-			dc.l	OrwellDecoderTable-InfoQuadra700	; offset to decoder info
-			dc.l	RAMInfo2Bank4Meg-InfoQuadra700		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoQuadra700			; DAFB built in video
-			dc.l	NuBusInfoQuadra700-InfoQuadra700	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxQuadra700						; product kind
-			dc.b	OrwellDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					OrwellExists,\						; OrwellAddr in valid								<SM62> CSS
-					SONICExists,\						; SONIC is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					; 	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output	
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$40,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitQuadra700-InfoQuadra700		; VIA1 init info
-			dc.l	VIA2InitQuadra700-InfoQuadra700		; VIA2 init info
-			dc.l	SndCntlQuadra700-InfoQuadra700		; sound control vector table
-			dc.l	RTCClockPRAM-InfoQuadra700			; clock/PRAM vector table							<H4>
-			dc.l	ViaADBTable-InfoQuadra700			; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	Quadra700IntTbl-InfoQuadra700		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQuadra700-InfoQuadra700		; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoQuadra900
-			dc.l	OrwellDecoderTable-InfoQuadra900	; offset to decoder info
-			dc.l	RamInfoQuadra900-InfoQuadra900		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoQuadra900  		; DAFB built in video								<58>
-			dc.l	NuBusInfoQuadra900-InfoQuadra900	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.									<58>
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxQuadra900						; product kind										<57>
-			dc.b	OrwellDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<47>
-					SWIMIOPExists,\						; SWIMIOPAddr is valid
-					SCCIOPExists,\						; SCCIOPAddr is valid
-					OrwellExists,\						; OrwellAddr is valid				<SM62> CSS
-					SONICExists,\						; SONIC is valid									<58>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<58>
-					PatchROMExists,\					; Patch ROM is valid								<H15><SM5>
-					SCSI96_2Exists,\					; 2nd SCSI96 is valid								<58>
-					DAFBExists							; has DAFB video									<58>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/PRAM							<58>
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<58><LW7>
-					(Caboose)|\							;	Caboose firmware								<SM4><P1>
-					(SoundStereoOut)|\					;	has stereo sound output							<58>
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(KeyswCaboose)|\					;	has a Caboose-flavored power keyswitch			<58>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBIop) 							;	IOP ADB											<58>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$50,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 1, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitQuadra900-InfoQuadra900		; VIA1 init info
-			dc.l	VIA2InitQuadra900-InfoQuadra900		; VIA2 init info
-			dc.l	SndCntlQuadra900-InfoQuadra900		; sound control vector table						<t23>
-			dc.l	EgretClockPRAM-InfoQuadra900		; clock/PRAM vector table							<H4>
-			dc.l	QuadraADBTable-InfoQuadra900		; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	Quadra900IntTbl-InfoQuadra900		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQuadra900-InfoQuadra900		; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoQuadra950
-			dc.l	OrwellDecoderTable-InfoQuadra950 	; offset to decoder info
-			dc.l	RamInfoQuadra900-InfoQuadra950 		; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoQuadra950  		; DAFB built in video
-			dc.l	NuBusInfoQuadra900-InfoQuadra950	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.	
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxQuadra950						; product kind
-			dc.b	OrwellDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<47>
-					SWIMIOPExists,\						; SWIMIOPAddr is valid
-					SCCIOPExists,\						; SCCIOPAddr is valid
-					OrwellExists,\						; OrwellAddr is valid				<SM62> CSS
-					SONICExists,\						; SONIC is valid									<58>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<58>
-					SCSI96_2Exists,\					; 2nd SCSI96 is valid								<58>
-					PatchROMExists,\					; Patch ROM is valid								<H15><SM5>
-					DAFBExists							; has DAFB video									<58>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/PRAM							<58>
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<58><LW7>
-					(Caboose)|\							;	Caboose firmware								<SM4><P1>
-					(SoundStereoOut)|\					;	has stereo sound output							<58>
-					(SoundStereoMixing)|\				;	has stereo mixing								<H13>
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(KeyswCaboose)|\					;	has a Caboose-flavored power keyswitch			<58>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBIop) 							;	IOP ADB											<58>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$10,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 1, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitQuadra900-InfoQuadra950		; VIA1 init info
-			dc.l	VIA2InitQuadra900-InfoQuadra950		; VIA2 init info
-			dc.l	SndCntlQuadra900-InfoQuadra950		; sound control vector table						<t23>
-			dc.l	EgretClockPRAM-InfoQuadra950		; clock/PRAM vector table							<H4>
-			dc.l	QuadraADBTable-InfoQuadra950		; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	Quadra900IntTbl-InfoQuadra950		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQuadra900-InfoQuadra950		; offset to ICON info								<SM74>		
-
-
-;	ProductInfo table for 601 Smurf cards running in Quadra 700's
-
-		IF forSmurf THEN
-			ALIGN	4
-InfoRiscQuadra700											;													<SM11>
-			dc.l	OrwellDecoderTable-InfoRiscQuadra700; offset to decoder info
-			dc.l	RamInfoRiscQuadra-InfoRiscQuadra700	; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoRiscQuadra700		; DAFB built in video
-			dc.l	NuBusInfoQuadra700-InfoRiscQuadra700; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxRiscQuadra700					; product kind
-			dc.b	OrwellDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					OrwellExists,\						; OrwellAddr is valid				<SM62> CSS
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid									<SM21>
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockRTC)|\						; Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					; Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					; has stereo sound output	
-					(SoundPlayAndRecord)|\				; can Play and Record simultaneously
-					(ADBXcvr) 							; Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$40,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitQuadra700-InfoRiscQuadra700	; VIA1 init info
-			dc.l	VIA2InitQuadra700-InfoRiscQuadra700	; VIA2 init info
-			dc.l	SndCntlQuadra700-InfoRiscQuadra700	; sound control vector table
-			dc.l	RTCClockPRAM-InfoRiscQuadra700		; clock/PRAM vector table
-			dc.l	ViaADBTable-InfoRiscQuadra700		; ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	Quadra700IntTbl-InfoRiscQuadra700	; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; CPU ID: RISC design center
-					$1235								; CPU ID: Risc Card ID is $1234
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQuadra700-InfoRiscQuadra700	; offset to ICON info								<SM74>		
-
-
-;	ProductInfo table for 601 Smurf cards running in Quadra 900's
-
-			ALIGN	4
-InfoRiscQuadra900
-			dc.l	OrwellDecoderTable-InfoRiscQuadra900; offset to decoder info
-			dc.l	RamInfoRiscQuadra-InfoRiscQuadra900 ; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoRiscQuadra900  	; DAFB built in video
-			dc.l	NuBusInfoQuadra900-InfoRiscQuadra900; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.	
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxRiscQuadra900					; product kind
-			dc.b	OrwellDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<47>
-					SWIMIOPExists,\						; SWIMIOPAddr is valid
-					SCCIOPExists,\						; SCCIOPAddr is valid
-					OrwellExists,\						; OrwellAddr is valid				<SM62> CSS
-					SONICExists,\						; SONIC is valid									<58>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<58>
-					SCSI96_2Exists,\					; 2nd SCSI96 is valid								<58>
-					DAFBExists							; has DAFB video									<58>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/PRAM							<58>
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<58><LW7>
-					(Caboose)|\							;	Caboose firmware								<SM4><P1>
-					(SoundStereoOut)|\					;	has stereo sound output							<58>
-					(SoundStereoMixing)|\				;	has stereo mixing								<H13>
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(KeyswCaboose)|\					;	has a Caboose-flavored power keyswitch			<58>
-					(ADBIop) 							;	IOP ADB											<58>
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$50,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 1, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitQuadra900-InfoRiscQuadra900	; VIA1 init info
-			dc.l	VIA2InitQuadra900-InfoRiscQuadra900	; VIA2 init info
-			dc.l	SndCntlQuadra900-InfoRiscQuadra900	; sound control vector table						<t23>
-			dc.l	EgretClockPRAM-InfoRiscQuadra900	; clock/PRAM vector table							<H4>
-			dc.l	QuadraADBTable-InfoRiscQuadra900	; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	Quadra900IntTbl-InfoRiscQuadra900	; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; CPU ID: RISC design center
-					$1236								; CPU ID: Risc Card ID is $1236
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQuadra900-InfoRiscQuadra900	; offset to ICON info								<SM74>		
-
-;	ProductInfo table for 601 Smurf cards running in Quadra 950's
-
-			ALIGN	4
-InfoRiscQuadra950
-			dc.l	OrwellDecoderTable-InfoRiscQuadra950; offset to decoder info
-			dc.l	RamInfoRiscQuadra-InfoRiscQuadra950 ; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoRiscQuadra950  	; DAFB built in video
-			dc.l	NuBusInfoQuadra900-InfoRiscQuadra950; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.	
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxRiscQuadra950					; product kind
-			dc.b	OrwellDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<47>
-					SWIMIOPExists,\						; SWIMIOPAddr is valid
-					SCCIOPExists,\						; SCCIOPAddr is valid
-					OrwellExists,\						; OrwellAddr is valid				<SM62> CSS
-					SONICExists,\						; SONIC is valid									<58>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<58>
-					SCSI96_2Exists,\					; 2nd SCSI96 is valid								<58>
-					DAFBExists							; has DAFB video									<58>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/PRAM							<58>
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<58><LW7>
-					(Caboose)|\							;	Caboose firmware								<SM4><P1>
-					(SoundStereoOut)|\					;	has stereo sound output							<58>
-					(SoundStereoMixing)|\				;	has stereo mixing								<H13>
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(KeyswCaboose)|\					;	has a Caboose-flavored power keyswitch			<58>
-					(ADBIop) 							;	IOP ADB											<58>
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$10,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 1, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitQuadra900-InfoRiscQuadra950	; VIA1 init info
-			dc.l	VIA2InitQuadra900-InfoRiscQuadra950	; VIA2 init info
-			dc.l	SndCntlQuadra900-InfoRiscQuadra950	; sound control vector table						<t23>
-			dc.l	EgretClockPRAM-InfoRiscQuadra950	; clock/PRAM vector table							<H4>
-			dc.l	QuadraADBTable-InfoRiscQuadra950	; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	Quadra900IntTbl-InfoRiscQuadra950	; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	(cpuIDRISC)|\						; CPU ID: RISC design center
-					$1237								; CPU ID: Risc Card ID is $1237
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQuadra900-InfoRiscQuadra950	; offset to ICON info								<SM74>		
-
-		ENDIF											; {forSmurf}
-	
-	  ENDIF												; {hasOrwell}
-	
-		IF forSTP601 THEN
-
-
-;	ProductInfo table STP Quadra 700's
-
-			ALIGN	4
-InfoSTPQuadra700
-			dc.l	OrwellDecoderTable-InfoSTPQuadra700	; offset to decoder info
-			dc.l	RAMInfo2Bank4Meg-InfoSTPQuadra700	; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoSTPQuadra700		; DAFB built in video
-			dc.l	NuBusInfoQuadra700-InfoSTPQuadra700	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.	
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxSTPQ700							; product kind
-			dc.b	OrwellDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)
-					IWMExists,\							; IWMAddr is valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					OrwellExists,\						; OrwellAddr in valid								<SM62> CSS
-					SONICExists,\						; SONIC is valid
-					DAFBExists							; has DAFB video
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM
-					(SoundHasSoundIn)|\					; 	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					;	has stereo sound output	
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBXcvr) 							;	Has transceiver ADB
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$40,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 0, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitQuadra700-InfoSTPQuadra700	; VIA1 init info
-			dc.l	VIA2InitQuadra700-InfoSTPQuadra700	; VIA2 init info
-			dc.l	SndCntlQuadra700-InfoSTPQuadra700	; sound control vector table
-			dc.l	RTCClockPRAM-InfoSTPQuadra700		; clock/PRAM vector table							<H4>
-			dc.l	ViaADBTable-InfoSTPQuadra700		; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	Quadra700IntTbl-InfoSTPQuadra700	; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQuadra700-InfoSTPQuadra700	; offset to ICON info								<SM74>		
-
-
-;	ProductInfo table STP Quadra 900's
-
-			ALIGN	4
-InfoSTPQuadra900
-			dc.l	OrwellDecoderTable-InfoSTPQuadra900	; offset to decoder info
-			dc.l	RamInfoQuadra900-InfoSTPQuadra900	; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoSTPQuadra900  	; DAFB built in video								<58>
-			dc.l	NuBusInfoQuadra900-InfoSTPQuadra900	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.			
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxSTPQ900							; product kind
-			dc.b	OrwellDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<47>
-					SWIMIOPExists,\						; SWIMIOPAddr is valid
-					SCCIOPExists,\						; SCCIOPAddr is valid
-					OrwellExists,\						; OrwellAddr is valid				<SM62> CSS
-					SONICExists,\						; SONIC is valid									<58>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<58>
-					PatchROMExists,\					; Patch ROM is valid								<H15><SM5>
-					SCSI96_2Exists,\					; 2nd SCSI96 is valid								<58>
-					DAFBExists							; has DAFB video									<58>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/PRAM							<58>
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<58><LW7>
-					(Caboose)|\							;	Caboose firmware								<SM4><P1>
-					(SoundStereoOut)|\					;	has stereo sound output							<58>
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(KeyswCaboose)|\					;	has a Caboose-flavored power keyswitch			<58>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBIop) 							;	IOP ADB											<58>
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$50,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 1, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitQuadra900-InfoSTPQuadra900	; VIA1 init info
-			dc.l	VIA2InitQuadra900-InfoSTPQuadra900	; VIA2 init info
-			dc.l	SndCntlQuadra900-InfoSTPQuadra900	; sound control vector table						<t23>
-			dc.l	EgretClockPRAM-InfoSTPQuadra900		; clock/PRAM vector table							<H4>
-			dc.l	QuadraADBTable-InfoSTPQuadra900		; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	Quadra900IntTbl-InfoSTPQuadra900	; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQuadra900-InfoSTPQuadra900	; offset to ICON info								<SM74>		
-
-
-;	ProductInfo table STP Quadra 950's
-
-			ALIGN	4
-InfoSTPQuadra950
-			dc.l	OrwellDecoderTable-InfoSTPQuadra950 ; offset to decoder info
-			dc.l	RamInfoQuadra900-InfoSTPQuadra950 	; offset to ram bank info
-			dc.l	VideoInfoDAFB-InfoSTPQuadra950  	; DAFB built in video
-			dc.l	NuBusInfoQuadra900-InfoSTPQuadra950	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(0<<hwCbFPU)|\						; FPU chip present.			
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxSTPQ950							; product kind
-			dc.b	OrwellDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration for FPU-based machine	<T15><T19>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid (means Batman in this case)		<47>
-					SWIMIOPExists,\						; SWIMIOPAddr is valid
-					SCCIOPExists,\						; SCCIOPAddr is valid
-					OrwellExists,\						; OrwellAddr is valid				<SM62> CSS
-					SONICExists,\						; SONIC is valid									<58>
-					SCSI96_1Exists,\					; 1st SCSI96 is valid								<58>
-					SCSI96_2Exists,\					; 2nd SCSI96 is valid								<58>
-					PatchROMExists,\					; Patch ROM is valid								<H15><SM5>
-					DAFBExists							; has DAFB video									<58>
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/PRAM							<58>
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<58><LW7>
-					(Caboose)|\							;	Caboose firmware								<SM4><P1>
-					(SoundStereoOut)|\					;	has stereo sound output							<58>
-					(SoundStereoMixing)|\				;	has stereo mixing								<H13>
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(KeyswCaboose)|\					;	has a Caboose-flavored power keyswitch			<58>
-					(1<<hasNewMemMgr)|\					;	hasNewMemMgr support (ie Figment can be switched on)
-					(ADBIop) 							;	IOP ADB											<58>
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$10,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 1, PA2 = 0, PA1 = 0
-			dc.l	VIA1InitQuadra900-InfoSTPQuadra950	; VIA1 init info
-			dc.l	VIA2InitQuadra900-InfoSTPQuadra950	; VIA2 init info
-			dc.l	SndCntlQuadra900-InfoSTPQuadra950	; sound control vector table						<t23>
-			dc.l	EgretClockPRAM-InfoSTPQuadra950		; clock/PRAM vector table							<H4>
-			dc.l	QuadraADBTable-InfoSTPQuadra950		; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	Quadra900IntTbl-InfoSTPQuadra950	; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoQuadra900-InfoSTPQuadra950	; offset to ICON info								<SM74>		
-			
-			
-		ENDIF											; {forSTP601}
-
-
-
-		IF hasJaws THEN
-			IMPORT	SndCntlPB170, JawsPmgrPrims, JawsIntTbl
-
-			ALIGN	4
-InfoPowerBook170										; table for PowerBook 140 and 170					<8>
-			dc.l	JAWSTable-InfoPowerBook170			; offset to decoder info		
-			dc.l	RAMInfoJaws-InfoPowerBook170		; offset to ram bank info
-			dc.l	VideoInfoJaws-InfoPowerBook170		; offset to video info
-			dc.l	NuBusInfoJaws-InfoPowerBook170		; offset to NuBus info			
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)|\						; Apple Desktop Bus present.
-					(1<<hwCbPwrMgr)						; Power Manager present
-			dc.b	boxPowerBook170						; product kind 								
-			dc.b	JAWSDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration		
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					JAWSExists							; JAWSAddr is valid
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockRTC)|\						;	Has RTC clock/PRAM								<H4>
-					(ADBPwrMgr)|\						;	PowerManager ADB								<5>
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<T16><LW7>
-					(SoundStereoOut)|\					;	has stereo sound output							<t32>
-					(SoundStereoMixing)|\				;	has stereo mixing								<H13>
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(1<<SupportsIdle)					;	and has idle
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$12,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 1, PA2 = 0, PA1 = 1
-			dc.l	VIA1InitJaws-InfoPowerBook170		; VIA1 init info
-			dc.l	VIA2InitJaws-InfoPowerBook170		; VIA2 init info
-			dc.l	SndCntlPB170-InfoPowerBook170		; sound control vector table<t23> djw
-			dc.l	RTCClockPRAM-InfoPowerBook170		; clock/PRAM vector table	<H4>
-			dc.l	PMGRADBTable-InfoPowerBook170		; ADB/DebugUtil vector table<H14>
-			dc.l	JawsPmgrPrims-InfoPowerBook170		; Power Manager primitives							<SM33>
-			dc.l	JawsIntTbl-InfoPowerBook170			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoTIM-InfoPowerBook170		; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoJAWSUnknown
-			dc.l	JAWSTable-InfoJAWSUnknown			; offset to decoder info							<25>
-			dc.l	RamInfoJAWS-InfoJAWSUnknown			; offset to ram bank info
-			dc.l	VideoInfoJaws-InfoJAWSUnknown		; offset to video info
-			dc.l	NuBusInfoJaws-InfoJAWSUnknown		; offset to NuBus info			
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)|\						; Apple Desktop Bus present.
-					(1<<hwCbPwrMgr)						; Power Manager present
-			dc.b	BoxUnknown							; product kind
-			dc.b	JAWSDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration				<2.1>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32									; use default bases for this decoder
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	0									; use default external features for this decoder
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00,$00,$00,$00						; anything with this decoder matches
-			dc.l	VIA1InitJaws-InfoJAWSUnknown		; VIA1 init info
-			dc.l	VIA2InitJaws-InfoJAWSUnknown		; VIA2 init info
-			dc.l	0									; no sound control vector table
-			dc.l	RTCClockPRAM-InfoJAWSUnknown		; clock/PRAM vector table							<H4>
-			dc.l	PMGRADBTable-InfoJAWSUnknown		; ADB/DebugUtil vector table						<H14>
-			dc.l	JawsPmgrPrims-InfoJAWSUnknown		; Power Manager primitives							<SM33>
-			dc.l	JawsIntTbl-InfoJAWSUnknown			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; no CPU ID register
-			dc.l	IconInfoTIM-InfoJAWSUnknown			; offset to ICON info								<SM74>		
-
-		ENDIF											; {hasJaws}
-
-
-
-		IF hasVISADecoder THEN
-			IMPORT	SndCntlLC, RBVEgretIntTbl
-
-			ALIGN	4
-InfoMacLC
-			dc.l	VISADecoderTable-InfoMacLC			; offset to decoder info
-			dc.l	RamInfoVISA-InfoMacLC				; offset to ram bank info
-			dc.l	VideoInfoVISA-InfoMacLC				; offset to video info
-			dc.l	NuBusInfoVISA-InfoMacLC				; offset to NuBus info			
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present <?, Elsie has yet another clock>
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxMacLCII							; product kind										<SM25>
-			dc.b	VISADecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, no Power Off ability.
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr is valid
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Egret8)|\							;	Egret Eight firmware							<SM4><P1>
-					(1<<V8ChipBit)|\					;	and VISA variant of RBV/MDU						<14><15>
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<23><SM27><LW7>
-					(1<<SupportsROMDisk)|\				; supports ROM disk (Ginty)							<SM27>
-					(1<<hasHardPowerOff)				;   hasHardPowerOff is valid						<SM32>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$54,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 1, PA2 = 1, PA1 = 0
-			dc.l	VIA1InitMacLC-InfoMacLC				; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	SndCntlLC-InfoMacLC					; sound control vector table						<SM17>
-			dc.l	EgretClockPRAM-InfoMacLC			; clock/PRAM vector table							<H4>
-			dc.l	EgretADBTable-InfoMacLC				; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	RBVEgretIntTbl-InfoMacLC			; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoMacLC-InfoMacLC				; offset to ICON info								<SM74>		
-
-
-
-			ALIGN	4
-InfoVISAUnknown
-			dc.l	VISADecoderTable-InfoVISAUnknown	; offset to decoder info
-			dc.l	RamInfoVISA-InfoVISAUnknown			; offset to ram bank info
-			dc.l	VideoInfoVISA-InfoVISAUnknown		; offset to video info
-			dc.l	NuBusInfoVISA-InfoVISAUnknown		; offset to NuBus info			
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxUnknown							; product kind
-			dc.b	VISADecoder							; decoder kind
-			dc.w	$7FFF								; ROM85, New ROMs, no Power Off ability.
-			dc.b	4									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32									; use default bases for this decoder
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	0									; use default external features for this decoder
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00,$00,$00,$00						; anything with this decoder matches
-			dc.l	VIA1InitMacLC-InfoVISAUnknown		; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	0									; no sound control vector table
-			dc.l	EgretClockPRAM-InfoVISAUnknown		; clock/PRAM vector table	<H4>
-			dc.l	EgretADBTable-InfoVISAUnknown		; ADB/DebugUtil vector table<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	RBVEgretIntTbl-InfoVISAUnknown		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	IconInfoMacLC-InfoVISAUnknown		; offset to ICON info								<SM74>		
-
-
-		ENDIF											; {hasVISADecoder}
-
-
-
-			IMPORT	VIAIntTbl
-InfoUnknownUnknown
-			dc.l	UnknownDecoderTable-InfoUnknownUnknown	; offset to decoder info
-			dc.l	0									; no ram bank info
-			dc.l	0									; no built in video
-			dc.l	0									; no NuBus info
-			dc.w	0									; hwCfgFlags
-			dc.b	BoxUnknown							; product kind
-			dc.b	UnknownDecoder						; decoder kind
-			dc.w	$FFFF   							; ROM85
-			dc.b	1									; default ROM Resource configuration				<2.1>
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32									; use default bases for this decoder
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	0									; use default external features for this decoder
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00,$00,$00,$00						; anything with this decoder matches
-			dc.l	0									; no VIA1 to init
-			dc.l	0									; no VIA2 to init
-			dc.l	0									; no sound control vector table						<t21>
-			dc.l	RTCClockPRAM-InfoUnknownUnknown		; clock/PRAM vector table							<H4>
-			dc.l	0									; no ADB/DebugUtil vector table
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	VIAIntTbl-InfoUnknownUnknown		; interrupt handlers table							<SM38>
-			dc.l	0									; internal modem manager					
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare												<SM74>
-			dc.l	0									; no Icon info										<SM74>
-
+			dc.l	IconInfoNewWorld-InfoNewWorld		; offset to ICON info
+			dc.l	$190
 
 
 ;———————————————————————————————————————————————————————————————————————————————————————————————
@@ -3889,2038 +611,58 @@ InfoUnknownUnknown
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 
 			ALIGN	16
-	
-		IF hasPratt THEN
-;-----------------------------------------------------------------------------------------
-; Pratt Decoder
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Flags for valid base addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					VDACExists,\						; VDAC (CSC) is valid
-					SONICExists							; SONIC is valid									
-			BitVector32 \								; Flags for valid base addresses 32-63
-					SingerExists,\						; PrattAddr is valid
-					PrattExists							; SingerAddr is valid
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features 0-31
-					(ADBPwrMgr)|\						;	PMGR ADB
-					(ClockPwrMgr)|\						;	PMGR clock/pram
-					(SoundHasSoundIn)|\					; 	Has 8-bit mono sound input						<LW7>
-					(Sound16Bit)|\						; has 16-bit hardware
-					(SoundStereoOut)|\					;	has stereo sound output
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				
-					(1<<SoundLineLevel)|\				; requires line level on sound input port
-					(1<<SupportsIdle)					;	and has idle
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$00,$00,$00						; no special VIA bits to avoid changing
-			dc.l	0									; no identify routine - supports CPU ID reg	
-			dc.b	PrattDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	3,0
-			dc.l	$50F80000							; Pratt Base Address 
-PrattTable	dc.l	$40000000							; ROM - valid
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F04000							; SCC read - valid
-			dc.l	$50F04000							; SCC write - valid
-			dc.l	$50F16000							; IWM - valid
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$50F10000							; SCSI - optional
-			dc.l	$50F06000							; SCSIDack - optional
-			dc.l	$50F06000							; SCSIHsk - optional
-			dc.l	$50F02000							; VIA2 - valid
-			dc.l	$50F14000							; ASC - valid
-			dc.l	$00000000							; RBV - unused
-			dc.l	$50f20000							; VDAC (CSC) - valid										
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; Orwell - unused									
-			dc.l	$00000000							; JAWS - unused
-			dc.l	$50f0a000							; Sonic - valid
-			dc.l	$00000000							; 1st (internal) SCSI96 - unused
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; DAFB - unused
-			dc.l	$00000000							; PSCAddr - unused
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; PatchROMAddr - unused
-			dc.l	$50140000							; SingerAddr - valid
-			dc.l	$50080000							; Pratt Base Address 
-			
 
-		ENDIF											; {hasPratt}
-
-		IF hasHMC THEN									;													<SM46>
-		
-;-----------------------------------------------------------------------------------------
-; HMC Decoder (PDM)																							<SM21>
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							;   ROMAddr is valid
-					VIA1Exists,\						;   VIA1Addr is valid
-					RBVExists,\							;   RBVAddr is valid
-					SCCRdExists,\						;   SCCRdAddr may be valid	
-					SCCWrExists,\						;   SCCWrAddr may be valid	
-					ASCExists,\							;   ASC isn't valid, but say it is	
-					SCSI96_1Exists						; 1st SCSI96 is valid		
-			BitVector32 \								; Default valid addresses 32-63
-					AwacsExists,\						;	AwacsAddr exists
-					MaceExists, \						;	MACE exists
-					AMICExists,\						;	AMIC DMA IO controller exists						<SM55>
-					SWIM3Exists,\						;	SWIM3 DMA floppy controller exists					<SM56>
-					BartExists							; 	BART (NuBus controller) may exist					<SM83>
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware
-					(Sound16Bit)|\						;	Has 16-bit mono/stereo sound input
-					(SoundStereoOut)|\					;	has stereo sound output
-					(1<<hasHardPowerOff)|\				; 	hasHardPowerOff is valid		
-					(1<<hasNewMemMgr)					; 	hasNewMemMgr support (ie Figment can be switched on)	
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$C0,$00,$00						; dont trigger SoftIRQ, A/UX interrupt scheme
-			dc.l	0									; no routine to identify this map
-			dc.b	HMCDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$50F40000							; HMC Base Address
-HMCDecoderTable											; PDM Memory Map
-			dc.l	$40800000							; ROM - valid
-			dc.l	$00000000							; DiagROM - unused
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F04000							; SCC read - valid
-			dc.l	$50F04000							; SCC write - valid
-			dc.l	$00000000							; IWM - unused
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$00000000							; VIA2 - unused
-			dc.l	$40800000							; ASC - fake addr
-			dc.l	$50F26000							; RBV - valid
-			dc.l	$50F24000							; VDAC - valid
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; unused 21
-			dc.l	$00000000							; JAWS - unused	
-			dc.l	$00000000							; Sonic - unused	
-			dc.l	$50F10000							; 1st (internal) SCSI96 - valid
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; DAFB - unused
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; PatchRomAddr - unused
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-			dc.l	$00000000							; SingerAddr unused 32
-			dc.l	$00000000							; DSPAddr unused 33
-			dc.l	$50F0A000							; MACEAddr - valid
-			dc.l	$00000000							; MuniAddr unused 35
-			dc.l	$50F31000							; Base of AMIC DMA controller (PDM) 				<SM37)
-			dc.l	$00000000							; Base of Pratt decoder
-			dc.l	$50F16000							; Base of SWIM3 chip								<SM56>
-			dc.l	$50F14000							; Base of AWACS
-			dc.l	$00000000							; Base of Civic
-			dc.l	$00000000							; Base of Sebastian
-			dc.l	$F0000000							; Base of BART
-
-;-----------------------------------------------------------------------------------------
-; HMC Decoder (ColdFusion - differs from PDM only in SCSI & soft power)										<SM81>
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							;   ROMAddr is valid
-					VIA1Exists,\						;   VIA1Addr is valid
-					RBVExists,\							;   RBVAddr is valid
-					SCCRdExists,\						;   SCCRdAddr may be valid	
-					SCCWrExists,\						;   SCCWrAddr may be valid	
-					ASCExists,\							;   ASC isn't valid, but say it is	
-					SCSI96_1Exists,\					; Internal 53CF96 is valid		
-					SCSI96_2Exists						; External 53C96 (curio) is valid		
-			BitVector32 \								; Default valid addresses 32-63
-					AwacsExists,\						;	AwacsAddr exists
-					MaceExists, \						;	MACE exists
-					AMICExists,\						;	AMIC DMA IO controller exists					<SM55>
-					SWIM3Exists,\						;	SWIM3 DMA floppy controller exists				<SM56>
-					BartExists							; 	BART (NuBus controller) may exist				<MC4><MC6>
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Cuda)|\							;	Cuda firmware
-					(Sound16Bit)|\						;	Has 16-bit mono/stereo sound input
-					(SoundStereoOut)|\					;	has stereo sound output
-					(1<<hasNewMemMgr)					; hasNewMemMgr support (ie Figment can be switched on)	
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$C0,$00,$00						; dont trigger SoftIRQ, A/UX interrupt scheme
-			dc.l	0									; no routine to identify this map
-			dc.b	HMCDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$50F40000							; HMC Base Address
-HMCcfDecoderTable											; PDM Memory Map
-			dc.l	$40800000							; ROM - valid
-			dc.l	$00000000							; DiagROM - unused
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F04000							; SCC read - valid
-			dc.l	$50F04000							; SCC write - valid
-			dc.l	$00000000							; IWM - unused
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$00000000							; VIA2 - unused
-			dc.l	$40800000							; ASC - fake addr
-			dc.l	$50F26000							; RBV - valid
-			dc.l	$50F24000							; VDAC - valid
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; unused 21
-			dc.l	$00000000							; JAWS - unused	
-			dc.l	$00000000							; Sonic - unused	
-			dc.l	$50F11000							; 1st (internal) SCSICF96 - valid
-			dc.l	$50F10000							; 2nd (external) SCSIC96 - valid
-			dc.l	$00000000							; DAFB - unused
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; PatchRomAddr - unused
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-			dc.l	$00000000							; SingerAddr unused 32
-			dc.l	$00000000							; DSPAddr unused 33
-			dc.l	$50F0A000							; MACEAddr - valid
-			dc.l	$00000000							; MuniAddr unused 35
-			dc.l	$50F31000							; Base of AMIC DMA controller (PDM) 				<SM37)
-			dc.l	$00000000							; Base of Pratt decoder
-			dc.l	$50F16000							; Base of SWIM3 chip								<SM56>
-			dc.l	$50F14000							; Base of AWACS
-			dc.l	$00000000							; Base of Civic
-			dc.l	$00000000							; Base of Sebastian
-			dc.l	$F0000000							; Base of BART
-		ENDIF											; hasHMC											<SM46>
-		
-		
-		IF hasOrwell THEN
-			IMPORT	CheckForOrwell
-;-----------------------------------------------------------------------------------------
-; Orwell Decoder
-;-----------------------------------------------------------------------------------------
-		  IF forSmurf THEN
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					SCCRdExists,\						; SCCRdAddr may be valid	
-					SCCWrExists,\						; SCCWrAddr may be valid	
-					SWIMIOPExists,\						; SWIMIOPAddr may be valid
-					SCCIOPExists,\						; SCCIOPAddr may be valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid		
-					OrwellExists,\						; Orwell MCA is valid								<SM62> CSS
-					SONICExists,\						; SONIC is valid on the Smurf Card
-					DAFBExists							; DAFB video is valid
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	0 									; Default ext features  0-31
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$C0,$00,$00						; dont trigger SoftIRQ, A/UX interrupt scheme
-			dc.l	CheckForOrwell-OrwellDecoderTable	; routine to identify this map
-			dc.b	OrwellDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$5000E000							; Orwell Base Address
-OrwellDecoderTable										; Orwell Memory Map	
-			dc.l	$40800000							; ROM - valid
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50000000							; VIA1 - valid
-			dc.l	$5000C020							; SCC read - valid
-			dc.l	$5000C020							; SCC write - valid
-			dc.l	$5001E000							; IWM - valid
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$50002000							; VIA2 - valid
-			dc.l	$50014000							; ASC - valid
-			dc.l	$00000000							; RBV - unused
-			dc.l	$F9800000							; VDAC - used
-			dc.l	$00000000							; SCSIDMA - valid
-			dc.l	$5001E020							; SWIMIOP - valid
-			dc.l	$5000C020							; SCCIOP - valid
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$5000E000							; Orwell - valid									<SM62> CSS
-			dc.l	$00000000							; JAWS - unused	
-			dc.l	$5000A000							; Sonic - valid										<45>
-			dc.l	$5000F000							; 1st (internal) SCSI96 - valid						<58>
-			dc.l	$5000F402							; 2nd (external) SCSI96 - valid						<58>
-			dc.l	$F9800000							; DAFB - valid 
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$E0000000							; PatchRomAddr - valid	
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-		  ELSE											; {forSmurf}
-		
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					SCCRdExists,\						; SCCRdAddr may be valid	
-					SCCWrExists,\						; SCCWrAddr may be valid	
-					SWIMIOPExists,\						; SWIMIOPAddr may be valid
-					SCCIOPExists,\						; SCCIOPAddr may be valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid		
-					SCSI96_2Exists,\					; 2nd SCSI96 may be valid
-					OrwellExists,\						; Orwell MCA is valid								<SM62> CSS
-					SONICExists,\						; SONIC is valid
-					DAFBExists							; DAFB video is valid
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(1<<hasNewMemMgr)					; hasNewMemMgr support (ie Figment can be switched on)	
-		IF forSTP601 THEN
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-		ELSE											; 
-			dc.l	0 									; Default ext features 32-63
-		ENDIF
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$C0,$00,$00						; dont trigger SoftIRQ, A/UX interrupt scheme<16><47>
-			dc.l	CheckForOrwell-OrwellDecoderTable	; routine to identify this map
-			dc.b	OrwellDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$50F0E000							; Orwell Base Address								<SM13>
-OrwellDecoderTable										; Eclipse Memory Map								<13>
-			dc.l	$40800000							; ROM - valid
-			dc.l	$58000000							; DiagROM - valid									<16>
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F0C020							; SCC read - valid 									<58>
-			dc.l	$50F0C020							; SCC write - valid 								<58>
-			dc.l	$50F1E000							; IWM - valid 										<58>
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$50F02000							; VIA2 - valid
-			dc.l	$50F14000							; ASC - valid
-			dc.l	$00000000							; RBV - unused
-			dc.l	$F9800000							; VDAC - used 										<58>
-			dc.l	$00000000							; SCSIDMA - valid 									<58>
-			dc.l	$50F1E020							; SWIMIOP - valid
-			dc.l	$50F0C020							; SCCIOP - valid
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$5000E000							; Orwell - valid									<SM62> CSS
-			dc.l	$00000000							; JAWS - unused										<25>
-			dc.l	$50F0A000							; Sonic - valid										<45>
-			dc.l	$50F0F000							; 1st (internal) SCSI96 - valid						<58>
-			dc.l	$50F0F402							; 2nd (external) SCSI96 - valid						<58>
-			dc.l	$F9800000							; DAFB - valid 										<58>
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$E0000000							; PatchRomAddr - valid								<H15><SM5>
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-		  ENDIF											; {forSmurf}
-		ENDIF											; {hasOrwell}
-
-
-		IF hasJaws THEN
-			IMPORT	CheckForJAWS
-;-----------------------------------------------------------------------------------------
-; JAWS Decoder
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					JAWSExists							; JAWS is valid
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features  0-31
-					(ClockNoPram)|\						;	has PowerManager clock, but not PwrMgr pram
-					(ADBPwrMgr)|\						;	PowerManager ADB
-					(1<<SupportsIdle)					;	and has idle
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$00,$00,$00						; no special VIA bits to avoid changing
-			dc.l	CheckForJAWS-JAWStable				; routine to identify this map
-			dc.b	JAWSDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$50F80000							; JAWS Base Address
-JAWStable	dc.l	$40800000							; ROM - valid
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F04000							; SCC read - valid
-			dc.l	$50F04000							; SCC write - valid
-			dc.l	$50F16000							; IWM - valid
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$50F10000							; SCSI - optional
-			dc.l	$50F06000							; SCSIDack - optional
-			dc.l	$50F06000							; SCSIHsk - optional
-			dc.l	$50F02000							; VIA2 - valid
-			dc.l	$50F14000							; ASC - valid
-			dc.l	$00000000							; RBV - unused
-			dc.l	$00000000							; VDAC - unused
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; unused 21											<SM10>
-			dc.l	$50F80000							; JAWS - valid										<25>
-			dc.l	$00000000							; Sonic - unused									<45>
-			dc.l	$00000000							; 1st (internal) SCSI96 - unused
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; DAFB - unused
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; unused 29
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-		ENDIF											; {hasJaws}
-
-
-		IF hasNiagra THEN
-			IMPORT	CheckForNiagra
-;-----------------------------------------------------------------------------------------
-; Niagra Decoder
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Default valid addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					JAWSExists							; JAWS is valid
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features 0-31
-					(ClockRTC)|\						;	RTC clock/PRAM 
-					(ADBPwrMgr)|\						;	PowerManager ADB
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H42>
-					(1<<SupportsIdle)|\					;	and has idle
-					(1<<NiagraExistsBit)				;	Niagra a variant of Jaws
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$00,$00,$00						; no special VIA bits to avoid changing
-			dc.l	CheckForNiagra-NiagraTable			; routine to identify this map
-			dc.b	NiagraDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$50F80000							; Niagra Base Address
-NiagraTable	dc.l	$40800000							; ROM - valid
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F04000							; SCC read - valid
-			dc.l	$50F04000							; SCC write - valid
-			dc.l	$50F16000							; IWM - valid
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$50F10000							; SCSI - optional
-			dc.l	$50F06000							; SCSIDack - optional
-			dc.l	$50F06000							; SCSIHsk - optional
-			dc.l	$50F02000							; VIA2 - valid
-			dc.l	$50F14000							; ASC - valid
-			dc.l	$00000000							; RBV - unused
-			dc.l	$50F20000							; VDAC - valid										<SM2>
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; Orwell - unused									<SM29>
-			dc.l	$50F80000							; JAWS - valid
-			dc.l	$00000000							; Sonic - unused
-			dc.l	$00000000							; 1st (internal) SCSI96 - unused
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; DAFB - unused
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; PatchROMAddr - unused
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-		ENDIF											; {hasNiagra}
-
-
-		IF hasMSC THEN
-;-----------------------------------------------------------------------------------------
-; MSC Decoder
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid									<H6>
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr (GSC) is valid							<H9>
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features  0-31
-					(ADBPwrMgr)|\						; 	PMGR ADB
-					(ClockPwrMgr)|\						;	 PMGR clock/pram
-					(SoundHasSoundIn)|\					; 	Has 8-bit mono sound input						<LW7>
-					(1<<SupportsIdle)|\					; 	supports idle mode
-					(1<<PMgrNewIntf)|\					; 	serial PMgr interface and new protocol
-					(1<<MSCChipBit)						; 	MSC variant of the RBV							<H5>
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$00,$00,$00						; no special VIA bits to avoid changing
-			dc.l	0									; no identify routine - supports CPU ID reg			<H10>
-			dc.b	MSCDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	3,0
-			dc.l	$FFFFFFFF							; No Base Address for this decoder
-MSCTable
-	IF ROMinRAM THEN									;													<SM18>
-			dc.l	$00400000							; ROM - hacked			• HACK 4 Meg				<SM18>
-	ELSE												;													<SM18>
-			dc.l	$40800000							; ROM - valid
-	ENDIF												;													<SM18>
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F04000							; SCC read - valid
-			dc.l	$50F04000							; SCC write - valid
-			dc.l	$50F16000							; IWM - valid										<H6><H11>
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$50F10000							; SCSI - valid
-			dc.l	$50F12000							; SCSIDack - valid
-			dc.l	$50F06000							; SCSIHsk - valid
-			dc.l	$00000000							; VIA2 - unused
-			dc.l	$50F14000							; ASC - valid
-			dc.l	$50F26000							; RBV - valid
-			dc.l	$50F20000							; VDAC - valid (GSC)								<H9>
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; Orwell - unused									<SM29>
-			dc.l	$00000000							; JAWS - unused
-			dc.l	$00000000							; Sonic - unused
-			dc.l	$00000000							; 1st (internal) SCSI96 - unused
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; DAFB - unused
-			dc.l	$00000000							; unused 27											<H5>
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; PatchROM - unused
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-		ENDIF											; {hasMSC}
-
-
-		IF hasSonora THEN
-;-----------------------------------------------------------------------------------------
-; Sonora Decoder
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid (Actually, SWIM2)
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists,\						; VDACAddr is valid									<SM29>
-					SONICExists,\						; SONIC is valid
-					PatchROMExists						; PatchRomAddr is valid								<H33>
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features  0-31
-					(ClockEgret)|\						; 	Has Egret clock/pram
-					(ADBEgret)|\						; 	Egret ADB
-					(SoundHasSoundIn)|\					; 	Has 8-bit mono sound input						<LW7>
-					(SoundStereoOut)|\					; 	has stereo sound output							<t32>
-					(SoundPlayAndRecord)|\				; 	can Play and Record simultaneously				<H42>
-					(1<<SonoraExistsBit)				; 	Has Sonora Memory Controller					<H33>
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$00,$00,$00						; no special VIA bits to avoid changing
-			dc.l	0									; no identify routine - supports CPU ID reg			<H10>
-			dc.b	SonoraDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$FFFFFFFF							; No Base Address for this decoder
-SonoraTable
-			dc.l	$40800000							; √ROM - valid
-			
-;•••••••••••••••••••••••••••••																				<H38>
-;
-;	NOTE: Singapore has built their board testers using $50FC0000 as the DiagROM
-;	address. So, I need to change it here (since Vail is a Sonora machine). They will
-;	use the correct address in the future.
-;
-;			dc.l	$58000000							; √DiagROM - valid
-			dc.l	$50FC0000							; √DiagROM - valid
-
-;•••••••••••••••••••••••••••••
-			dc.l	$50F00000							; √VIA1 - valid
-			dc.l	$50F04000							; √SCC read - valid
-			dc.l	$50F04000							; √SCC write - valid
-			dc.l	$50F16000							; √IWM - SWIM2 address
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$50F10000							; √SCSI - valid
-			dc.l	$50F12000							; √SCSIDack - valid
-			dc.l	$50F06000							; √SCSIHsk - valid
-			dc.l	$00000000							; VIA2 - unused
-			dc.l	$50F14000							; √ASC - valid
-			dc.l	$50F26000							; √RBV - valid
-			dc.l	$50F24000							; √VDAC - valid
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; Orwell - unused									<SM29>
-			dc.l	$00000000							; JAWS - unused
-			dc.l	$50F0A000							; √Sonic - valid
-			dc.l	$00000000							; 1st (internal) SCSI96 - unused
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; DAFB - unused
-			dc.l	$00000000							; unused 27											<H5>
-			dc.l	$00000000							; ROMPhysAddr - unused								<H19>
-			dc.l	$5FF00000							; √PatchROM - valid <H33>							<SM29>
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-		ENDIF											; {hasSonora}
-
-
-		IF hasDJMEMC THEN
-;-----------------------------------------------------------------------------------------
-; djMEMC Decoder 	•••• This info is not up to date ••••
-;-----------------------------------------------------------------------------------------
-	IF forSmurf THEN									;												<SM48>
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					IWMExists,\							; IWMAddr is valid (Actually, SWIM2)
-					SCCRdExists,\						; SCCRdAddr may be valid
-					SCCWrExists,\						; SCCWrAddr may be valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					DAFBExists							; DAFB video is valid
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features  0-31
-					SoundPlayAndRecord					;	can Play and Record simultaneously				<H42>
-					 									;	(we better know what features we have)
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$C0,$00,$00						; dont trigger SoftIRQ, A/UX interrupt scheme
-			dc.l	0									; routine to identify this map
-			dc.b	djMEMCDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$FFFFFFFF							; djMEMC Base Address???
-djMEMCTable
-			dc.l	$40800000							; ROM - valid
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50000000							; VIA1 - valid
-			dc.l	$5000C020							; SCC read - valid
-			dc.l	$5000C020							; SCC write - valid
-			dc.l	$5001E000							; IWM - valid
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$50002000							; VIA2 - valid
-			dc.l	$50014000							; ASC - valid
-			dc.l	$00000000							; RBV - unused
-			dc.l	$F9800000							; VDAC - used
-			dc.l	$00000000							; SCSIDMA - valid
-			dc.l	$00000000							; SWIMIOP - valid
-			dc.l	$00000000							; SCCIOP - valid
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; Orwell - valid									<SM29>
-			dc.l	$00000000							; JAWS - unused
-			dc.l	$5000A000							; Sonic - valid
-			dc.l	$50010000							; 1st (internal) SCSI96 - valid
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$F9800000							; DAFB - valid
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$5F000000							; PatchRomAddr - valid								<SM29>
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31											<H41>
-
-		ELSE											; {forSmurf}
-
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					SCCRdExists,\						; SCCRdAddr may be valid
-					SCCWrExists,\						; SCCWrAddr may be valid
-					SCSI96_1Exists,\					; 1st SCSI96 is valid
-					SONICExists,\						; SONIC is valid
-					DAFBExists							; DAFB video is valid
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features  0-31
-					(SoundPlayAndRecord	)|\				;	can Play and Record simultaneously				<H42>
-					\ 									;	(we better know what features we have)
-					(1<<hasNewMemMgr)					; hasNewMemMgr support (ie Figment can be switched on)	
-		IF forSTP601 THEN
-			dc.l	\									; Flags for valid ext feature flags 32-63
-					(1<<has68kEmulator//32)				;	This ROM starts up with a 68k emulator
-		ELSE											; 
-			dc.l	0 									; Default ext features 32-63
-		ENDIF
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$C0,$00,$00						; dont trigger SoftIRQ, A/UX interrupt scheme
-			dc.l	0									; routine to identify this map
-			dc.b	djMEMCDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$FFFFFFFF							; djMEMC Base Address???
-djMEMCTable
-			dc.l	$40800000							; ROM - valid
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F0C020							; SCC read - valid
-			dc.l	$50F0C020							; SCC write - valid
-			dc.l	$50F1E000							; IWM - valid
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$50F02000							; VIA2 - valid
-			dc.l	$50F14000							; ASC - valid
-			dc.l	$00000000							; RBV - unused
-			dc.l	$F9800000							; VDAC - used
-			dc.l	$00000000							; SCSIDMA - valid
-			dc.l	$00000000							; SWIMIOP - valid
-			dc.l	$00000000							; SCCIOP - valid
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; Orwell - valid									<SM29>
-			dc.l	$00000000							; JAWS - unused
-			dc.l	$50F0A000							; Sonic - valid
-			dc.l	$50F10000							; 1st (internal) SCSI96 - valid
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$F9800000							; DAFB - valid
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$5FF00000							; PatchRomAddr - valid								<SM29>
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31											<H41>
-		ENDIF											; {forSmurf}
-		ENDIF											; {hasDJMEMC}
-
-
-		IF hasYMCA THEN									; this is really YMCA now							<SM46>
-;-----------------------------------------------------------------------------------------
-; YMCA Decoder
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					NewAgeExists,\						; NewAge is valid
-					SCSI96_1Exists,\					; SCSI 96 is valid
-					PSCExists							; PSC DMA is valid
-			BitVector32	\								; Default valid addresses 32-63
-					DSPExists,\							; DSP is valid
-					MaceExists, \						; MACE is valid
-					MUNIExists, \						; MUNI is valid										<SM34>
-					CivicExists,\						; Civic video is valid
-					SebastianExists 					; Sebastian CLUT DAC is valid				
-			BitVector32									; Default valid addresses 64-95
-			dc.l	0 									; Default ext features  0-31
-										 				; 	(we better know what features we have)
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95				
-			dc.b	$00,$30,$00,$00						; special VIA bits to avoid changing,
-														; VIA1 PB4=1,PB5=1, for Cuda	1/27/92	gjs			<P9>
-			dc.l	0									; no identify routine - supports CPU ID reg			<P5>
-			dc.b	YMCADecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$50F30400							; YMCA Base Address									<SM19>
-CycloneDecoderTable
-	IF ROMinRAM THEN									;													<SM18>
-			dc.l	$00400000							; ROM - hacked			• HACK 4 Meg				<SM18>
-	ELSE												;													<SM18>
-			dc.l	$40800000							; ROM - valid
-	ENDIF												;													<SM18>
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F04000							; SCC read - valid
-			dc.l	$50F04000							; SCC write - valid
-			dc.l	$00000000							; IWM - unused
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$50F02000							; VIA2 - valid										<SM7>
-			dc.l	$00000000							; ASC - unused										<SM15>
-			dc.l	$00000000							; RBV - unused
-			dc.l	$00000000							; VDAC - valid									<SM7>
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; Unused21 - valid									<SM10><SM19>
-			dc.l	$00000000							; JAWS - unused
-			dc.l	$00000000							; Sonic - unused
-			dc.l	$50F18000							; 1st (internal) SCSI96 - unused
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; Civic - valid
-			dc.l	$50F31000							; PSC DMA - valid
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; PatchROMAddr - unused
-			dc.l	$50F2A000							; NewAge - valid
-			dc.l	$00000000							; Unused31
-			dc.l	$00000000							; Singer - unused
-			dc.l	$50F31000							; DSP (really PSC's base address) - valid			<SM23>
-			dc.l	$50F1C000							; MACE - valid							  			<SM23>
-			dc.l	$50F30000							; MUNI - valid							  			<SM34>
-			dc.l	$00000000							; AMIC DMA controller - unused
-			dc.l	$00000000							; Pratt decoder - unused
-			dc.l	$00000000							; SWIM3 chip  - unused
-			dc.l	$00000000							; AWACS chip  - unused
-			dc.l	$50036000							; Civic - valid
-			dc.l	$50F30800							; Sebastian - valid									<SM7>
-
-
-	ENDIF												;													<SM20> <SM46>
-
-
-		IF hasVISADecoder THEN
-			IMPORT	CheckForVISADecoder
-;-----------------------------------------------------------------------------------------
-; VISA Decoder
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr is valid
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features  0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Has Egret ADB
-					(1<<V8ChipBit)						;	and V8 variant of RBV/MDU
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$00,$00,$00						; no special VIA bits to avoid changing
-			dc.l	CheckForVISADecoder-VISADecoderTable; routine to identify this map
-			dc.b	VISADecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$FFFFFFFF							; No Base Address for this decoder
-VISADecoderTable
-			dc.l	$40A00000							; ROM - valid										<H20><SM5><SM17><SM18>
-			dc.l	$50F80000							; DiagROM - valid									<12><8>
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F04000							; SCC read - valid
-			dc.l	$50F04000							; SCC write - valid
-			dc.l	$50F16000							; IWM - valid
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$50F10000							; SCSI - valid
-			dc.l	$50F12000							; SCSIDack - valid
-			dc.l	$50F06000							; SCSIHsk - valid
-			dc.l	$00000000							; VIA2 - unused
-			dc.l	$50F14000							; ASC - valid
-			dc.l	$50F26000							; RBV - valid
-			dc.l	$50F24000							; VDAC - valid
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; unused 21
-			dc.l	$00000000							; unused 22
-			dc.l	$00000000							; unused 23
-			dc.l	$00000000							; 1st (internal) SCSI96 - unused
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; DAFB - unused
-			dc.l	$00000000							; unused 27
-			dc.l	$00A00000							; ROMPhysAddr - unused								<SM17>
-			dc.l	$00000000							; unused 29
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-		ENDIF											; {hasVISADecoder}
-
-
-		IF hasGrandCentral THEN
-;-----------------------------------------------------------------------------------------
-; HammerHead Decoder Table
-;-----------------------------------------------------------------------------------------
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					SCSI96_1Exists,\					; SCSI 96 bus 1 is valid
-					SCSI96_2Exists						; SCSI 96 bus 2 is valid
-			BitVector32	\								; Default valid addresses 32-63
-					MaceExists, \						; MACE is valid
-					SWIM3Exists,\						; SWIM3 is valid
-					AwacsExists,\						; Awacs is valid
-					GrandCentralExists					; Grand Central DMA is valid
-			BitVector32									; Default valid addresses 64-95
-			dc.l	0 									; Default ext features  0-31
-										 				; 	(we better know what features we have)
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95				
-			dc.b	$00,$30,$00,$00						; special VIA bits to avoid changing,
-														; VIA1 PB4=1, PB5=1, for Cuda
-			dc.l	0									; no identify routine -- use CPU ID register
-			dc.b	HHeadDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$F8000000							; HammerHead Base Address
-HHeadDecoderTable
-			dc.l	$40800000							; ROM - valid
-			dc.l	$00000000							; DiagROM - unused
-			dc.l	$F3016000							; VIA1 - valid
-			dc.l	$F3012000							; SCC read - valid
-			dc.l	$F3012000							; SCC write - valid
-			dc.l	$00000000							; IWM - unused
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$00000000							; VIA2 - unused
-			dc.l	$00000000							; ASC - unused
-			dc.l	$00000000							; RBV - unused
-			dc.l	$00000000							; VDAC - unused
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; Unused21 - unused
-			dc.l	$00000000							; JAWS - unused
-			dc.l	$00000000							; Sonic - unused
-			dc.l	$F3018000							; 1st (internal) SCSI96 - valid
-			dc.l	$F3010000							; 2nd (external) SCSI96 - valid
-			dc.l	$00000000							; Civic - unused
-			dc.l	$00000000							; PSC DMA - unused
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; PatchROMAddr - unused
-			dc.l	$00000000							; NewAge - unused
-			dc.l	$00000000							; Unused31
-			dc.l	$00000000							; Singer - unused
-			dc.l	$00000000							; DSP (really PSC's base address) - unused
-			dc.l	$F3011000							; MACE - valid
-			dc.l	$00000000							; MUNI - unused
-			dc.l	$00000000							; AMIC DMA controller - unused
-			dc.l	$00000000							; Pratt decoder - unused
-			dc.l	$F3015000							; SWIM3 chip  - valid
-			dc.l	$F3014000							; AWACS chip  - valid
-			dc.l	$00000000							; Civic - unused
-			dc.l	$00000000							; Sebastian - unused
-			dc.l	$00000000							; BART - unused
-			dc.l	$F3000000							; Grand Central - valid
-
-		ENDIF											; {hasGrandCentral}
-
-
-
-;-----------------------------------------------------------------------------------------
-; Unknown Decoder
-;-----------------------------------------------------------------------------------------
-			IMPORT	CheckForUnknown
-
-			BitVector32									; Default valid addresses  0-31
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	0 									; Default ext features  0-31
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$00,$00,$00						; no special VIA bits to avoid changing
-			dc.l	CheckForUnknown-UnknownDecoderTable	; routine to identify this map
-			dc.b	UnknownDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$FFFFFFFF							; No Base Address for this decoder
-UnknownDecoderTable
-			dc.l	$00000000							; ROM - unused
-			dc.l	$00000000							; DiagROM - unused
-			dc.l	$00000000							; VIA1 - unused
-			dc.l	$00000000							; SCC read - unused
-			dc.l	$00000000							; SCC write - unused
-			dc.l	$00000000							; IWM - unused
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$00000000							; VIA2 - unused
-			dc.l	$00000000							; ASC - unused
-			dc.l	$00000000							; RBV - unused
-			dc.l	$00000000							; VDAC - unused
-			dc.l	$00000000							; SCSIDMA - unused
-			dc.l	$00000000							; SWIMIOP - unused
-			dc.l	$00000000							; SCCIOP - unused
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; unused 21											<SM10>
-			dc.l	$00000000							; JAWS - unused										<25>
-			dc.l	$00000000							; Sonic - unused									<45>
-			dc.l	$00000000							; 1st (internal) SCSI96 - unused					<T9>
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused					<T9>
-			dc.l	$00000000							; DAFB - unused										<T26>
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused								<T33>
-			dc.l	$00000000							; unused 29
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-			
 
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 ;	RAM Info Tables
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 
-		IF hasMDU THEN									;													<SM46>
-RAMInfo2Bank1Meg										; common 2 bank RAM model:
-			dc.l	$00100000							;	1 Meg is smallest bank
-			dc.l	$00000000,$04000000					;	64 Meg Bank A	
-			dc.l	$04000000,$08000000					;	64 Meg Bank B
-			dc.l	$FFFFFFFF							;	end of table
-		ENDIF											;													<SM46>
-
-		IF hasOrwell | hasYMCA THEN						;													<SM47>
-RAMInfo2Bank4Meg										; common 2 bank RAM model:
-			dc.l	$00400000							;	4 MB is smallest bank
-			dc.l	$00000000,$04000000					;	64 MB Bank A	
-			dc.l	$04000000,$08000000					;	64 MB Bank B
-			dc.l	$FFFFFFFF							;	end of table
-		ENDIF											;													<SM47>
-
-		IF hasVISADecoder THEN
-RamInfoVISA
-			dc.l	$00100000							; 1 MB is smallest bank
-			dc.l	$00000000,$00800000					; 8 MB Bank A
-			dc.l	$00800000,$00A00000					; 2 MB Bank B
-			dc.l	$FFFFFFFF							; end of table	
-RamInfoMacLCII											; Special case 4MB on PCB for LC II					<SM20>
-			dc.l	$00100000							; 1 MB is smallest bank
-			dc.l	$00000000,$00400000					; 4 MB Bank A
-			dc.l	$00400000,$00800000					; 4 MB Bank B
+RamInfoNewWorld
+			dc.l	$00800000							; 8 MB is smallest bank
+			dc.l	$00000000,$40000000					; 1 GB Bank A
 			dc.l	$FFFFFFFF							; end of table
-		ENDIF											; {hasVISADecoder}
-
-		IF hasOrwell THEN
-RamInfoQuadra900										; Quadra 900 supports 4 banks of memory
-			dc.l	$00400000							; 4 MB is smallest bank
-			dc.l	$00000000,$04000000					; 64 MB Bank A	
-			dc.l	$04000000,$08000000					; 64 MB Bank B
-			dc.l	$08000000,$0C000000					; 64 MB Bank C
-			dc.l	$0C000000,$10000000					; 64 MB Bank D
-			dc.l	$FFFFFFFF							; End of table
-
-		 IF forSmurf THEN
-RamInfoRiscQuadra										; Smurf Card supports 1 12M bank of memory
-			dc.l	$00C00000							; 12 MB is smallest bank
-			dc.l	$00000000,$00C00000					; 12 MB Bank	
-			dc.l	$FFFFFFFF							; End of table
-		 ENDIF											;  {forSmurf}
-		ENDIF											; {hasOrwell}
-
-		IF hasJaws THEN
-RAMInfoJaws
-			dc.l	$00080000							; 512K is smallest bank	
-			dc.l	$00000000,$00200000					; 2 Meg Bank A
-			dc.l	$00200000,$00400000					; 2 Meg Bank B
-			dc.l	$00400000,$00600000					; 2 Meg Bank C
-			dc.l	$00600000,$00800000					; 2 Meg Bank D
-			dc.l	$FFFFFFFF							; End of table
-		ENDIF											; {hasJaws}
-
-		IF hasNiagra THEN
-RamInfoNiagra
-			dc.l	$00080000							; 512K is smallest bank								<SM29>
-			dc.l	$00000000,$00200000					; 2 Meg Bank 0										<SM29>
-			dc.l	$00200000,$00400000					; 2 Meg Bank 1										<SM29>
-			dc.l	$00400000,$00600000					; 2 Meg Bank 2										<SM29>
-			dc.l	$00600000,$00800000					; 2 Meg Bank 3										<SM29>
-			dc.l	$00800000,$00A00000					; 2 Meg Bank 4										<SM29>
-			dc.l	$00A00000,$00C00000					; 2 Meg Bank 5										<SM29>
-			dc.l	$00C00000,$00E00000					; 2 Meg Bank 6										<SM29>
-			dc.l	$00E00000,$01000000					; 2 Meg Bank 7	(16 Meg Total)						<SM29>
-			dc.l	$FFFFFFFF							; End of table
-		ENDIF											; {hasNiagra}
-
-		IF hasMSC THEN
-RAMInfoMSC
-			dc.l	$00200000							; 2 Meg is smallest bank allowed
-			dc.l	$00000000,$00200000					; 2 Meg Bank A
-			dc.l	$00200000,$00400000					; 2 Meg Bank B
-			dc.l	$00400000,$00600000					; 2 Meg Bank C
-			dc.l	$00600000,$00800000					; 2 Meg Bank D
-			dc.l	$00800000,$01000000					; 8 Meg Bank E										<H40>
-			dc.l	$01000000,$01800000					; 8 Meg Bank F										<H40>
-			dc.l	$01800000,$02000000					; 8 Meg Bank G										<H40>
-			dc.l	$02000000,$02800000					; 8 Meg Bank H										<H40>
-			dc.l	$FFFFFFFF							; end of table
-		ENDIF											; {hasMSC}
-
-		IF hasPratt THEN
-RAMInfoPratt
-			dc.l	$00200000							; 2 Meg is smallest bank allowed					<SM39>
-			dc.l	$00000000,$00800000					; 8 Meg Bank A
-			dc.l	$00800000,$01000000					; 4 Meg Bank B
-			dc.l	$01000000,$01800000					; 8 Meg Bank C
-			dc.l	$01800000,$02000000					; 8 Meg Bank D
-			dc.l	$02000000,$02800000					; 8 Meg Bank E
-			dc.l	$02800000,$03000000					; 8 Meg Bank F
-			dc.l	$FFFFFFFF							; end of table
-		ENDIF											; {hasPratt}
-
-		IF hasPratt THEN
-			EXPORT	RamInfoPrattFlash
-RamInfoPrattFlash
-			dc.l	$00200000							; 2 Meg is smallest bank allowed					<SM39>
-			dc.l	$00000000,$00800000					; 8 Meg Bank A
-			dc.l	$00800000,$01000000					; 8 Meg Bank B
-			dc.l	$01000000,$01800000					; 8 Meg Bank C
-			dc.l	$01800000,$02000000					; 8 Meg Bank D										
-			dc.l	$FFFFFFFF							; end of table
-		ENDIF											; {hasPratt}
-
-		IF hasSonora THEN
-RamInfoVail
-			dc.l	$00100000							; 1 Meg is smallest bank allowed
-			dc.l	$00000000,$01000000					; 16 Meg Bank A/0
-			dc.l	$01000000,$02000000					; 16 Meg Bank B/1
-			dc.l	$02000000,$03000000					; 16 Meg Bank C/2
-			dc.l	$03000000,$04000000					; 16 Meg Bank D/3
-			dc.l	$04000000,$05000000					; 16 Meg Bank E/4
-			dc.l	$FFFFFFFF							; end of table
-		ENDIF											; {hasSonora}
-
-		IF hasDJMEMC THEN
-RamInfoDJMEMC
-			dc.l	$00400000							; 4 Meg is smallest bank allowed					<SM29>
-			dc.l	$00000000,$04000000					; 64 Meg Bank 0	(built in)							<SM29>
-			dc.l	$04000000,$08000000					; 64 Meg Bank 1 (built in)							<SM29>
-			dc.l	$08000000,$0C000000					; 64 Meg Bank 2	(SIMM 0A) socket 0					<SM29>
-			dc.l	$0C000000,$10000000					; 64 Meg Bank 3	(SIMM 1A)							<SM29>
-			dc.l	$10000000,$14000000					; 64 Meg Bank 4	(SIMM 0B) socket 1					<SM29>
-			dc.l	$14000000,$18000000					; 64 Meg Bank 5	(SIMM 1B)							<SM29>
-			dc.l	$18000000,$1C000000					; 64 Meg Bank 6	(SIMM 2A) socket 2					<SM29>
-			dc.l	$1C000000,$20000000					; 64 Meg Bank 7	(SIMM 3A) 							<SM29>
-			dc.l	$53616D42							; ('SamB') End of 1st half table (Sizebanks can		<H49><SM29>
-														; only handle 8 banks. So we must break the sizing	<SM29>
-			dc.l	$00400000							; into two parts.)									<SM29>
-			dc.l	$20000000,$24000000					; 64 Meg Bank 8	(SIMM 2B) socket 3					<SM29>
-			dc.l	$24000000,$28000000					; 64 Meg Bank 9	(SIMM 3B) 640 Meg! Yeah! Can you say<SM29>
-			dc.l	$FFFFFFFF							; end of table			 long RAM test?!!			<H41><SM29>
-
-		 IF forSmurf THEN
-RamInfoRiscDJMEMC										; Smurf Card supports 1 12M bank of memory	 <SM47>
-			dc.l	$00C00000							; 12 MB is smallest bank
-			dc.l	$00000000,$00C00000					; 12 MB Bank	
-			dc.l	$FFFFFFFF							; End of table
-		 ENDIF											;  {forSmurf}
-
-		ENDIF											; {hasDJMEMC}
-
-		IF hasYMCA THEN									;													<SM46>
-
-RamInfoCyclone											; Cyclone EVT4 supports 8 banks of memory
-			dc.l	$00100000							; 1 MB is smallest bank
-			dc.l	$00000000,$01000000					; 16 MB Bank 0	
-			dc.l	$01000000,$02000000					; 16 MB Bank 1
-			dc.l	$02000000,$03000000					; 16 MB Bank 2
-			dc.l	$03000000,$04000000					; 16 MB Bank 3
-			dc.l	$04000000,$05000000					; 16 MB Bank 4
-			dc.l	$05000000,$06000000					; 16 MB Bank 5
-			dc.l	$06000000,$07000000					; 16 MB Bank 6
-			dc.l	$07000000,$08000000					; 16 MB Bank 7
-			dc.l	$FFFFFFFF							; End of table
-
-RamInfoTempest											; Tempest supports 8 banks of memory ????
-			dc.l	$00100000							; 1 MB is smallest bank
-			dc.l	$00000000,$01000000					; 16 MB Bank 0	
-			dc.l	$01000000,$02000000					; 16 MB Bank 1
-			dc.l	$02000000,$03000000					; 16 MB Bank 2
-			dc.l	$03000000,$04000000					; 16 MB Bank 3
-			dc.l	$04000000,$05000000					; 16 MB Bank 4
-			dc.l	$05000000,$06000000					; 16 MB Bank 5
-			dc.l	$06000000,$07000000					; 16 MB Bank 6
-			dc.l	$07000000,$08000000					; 16 MB Bank 7
-			dc.l	$FFFFFFFF							; End of table
-
-		ENDIF											;													<SM20><SM46>
-
-
-	IF hasHMC THEN
-RamInfoPDM												; PDM supports .. memory (Emulator maps all into 1 bank)
-			dc.l	$10000000							; 256 MB											<SM57>
-			dc.l	$00000000,$10000000					; 
-			dc.l	$FFFFFFFF							; End of table
-
-	ENDIF
-
-	IF hasGrandCentral THEN
-RamInfoTNT												; PDM supports .. memory (Emulator maps all into 1 bank)
-			dc.l	$10000000							; 256 MB											<SM57>
-			dc.l	$00000000,$10000000					; 
-			dc.l	$FFFFFFFF							; End of table
-
-	ENDIF												; (hasGrandCentral)
 
 
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 ;	Video Info Tables
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 
-		IF hasVISADecoder THEN							;													<SM46>
-VideoInfoVISA
-			dc.l	$50F40000							; Physical base address of screen					<H23>
-			dc.l	$50F40000							; Logical 32 bit base address of screen				<H23>
-			dc.l	$50F40000							; Logical 24 bit base address of screen				<H23>
-			dc.b	$0B									; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($0B-$09)*sizeSPRAMRec)	; PRAM address for RBV slot zero
-			dc.b	sRsrcBFBasedDir						; Use the BoxFlag-based sRsrc directory directory.	<H22>
-			dc.b	0									; Use boxFlag to identify board sRsrc.				<H11>	
-			dc.w	0									; <unused>
-		ENDIF											;													<SM46>
-		
-		IF hasJaws THEN
-VideoInfoJaws
-			dc.l	$FEE08000							; Physical base address of screen
-			dc.l	$FEE08000							; Logical 32 bit base address of screen
-			dc.l	$FEE08000							; Logical 24 bit base address of screen				<39>
-			dc.b	$0B									; Slot number to use for PRAM storage				<25>
-			dc.b	SmPRAMTop+(($0B-$09)*sizeSPRAMRec)	; PRAM address for  slot zero						<25>
-			dc.b	sRsrcBFBasedDir						; Use the BoxFlag-based sRsrc directory directory.	<H22>
-			dc.b	0									; Use boxFlag to identify board sRsrc.				<H11>	
-			dc.w	0									; <unused>
-		ENDIF											; {hasJaws}
-
-		IF hasDAFB THEN
-VideoInfoDAFB											;													<T14>
-			dc.l	$F9000000							; Physical base address of screen					<H19><SM5>
-			dc.l	$F9000000							; Logical 32 bit base address of screen				<H19><SM5>
-			dc.l	0									; no Logical 24 bit base address for DAFB			<T14>
-			dc.b	$09									; Slot number to use for PRAM storage				<T14>
-			dc.b	SmPRAMTop+(($09-$09)*sizeSPRAMRec)	; PRAM address for  slot zero						<T14>
-			dc.b	sRsrcBFBasedDir						; Use the BoxFlag-based sRsrc directory directory.	<H22>
-			dc.b	0									; Use boxFlag to identify board sRsrc.				<H11>	
-			dc.w	drHwDAFB							; Uses the DAFB video driver.
-		ENDIF											; {hasDAFB}
-
-		IF hasNiagra THEN
-VideoInfoNiagra
-			dc.l	$60040000							; Physical base address of screen					<H54><SM29>
-			dc.l	$60040000							; Logical 32 bit base address of screen				<H54><SM29>
-			dc.l	$00000000							; Logical 24 bit base address of screen			
-			dc.b	$0B									; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($0B-$09)*sizeSPRAMRec)	; PRAM address for  slot zero
-			dc.b	sRsrcBFBasedDir						; Use the BoxFlag-based sRsrc directory directory.	<H22>
-			dc.b	0									; Use boxFlag to identify board sRsrc.				<H17>	
-			dc.w	drHwGSC								; Uses the GSC (DBLite) video driver.
-		ENDIF											; {hasNiagra}
-
-		IF hasMSC THEN
-VideoInfoMSC
-			dc.l	$60000000							; Physical base address of screen
-			dc.l	$60000000							; Logical 32 bit base address of screen
-			dc.l	$00000000							; Logical 24 bit base address of screen (always access in 32-bit mode)
-			dc.b	$0B									; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($0B-$09)*sizeSPRAMRec)	; PRAM address for slot zero
-			dc.b	sRsrcBFBasedDir						; Use the BoxFlag-based sRsrc directory directory.	<H39>
-			dc.b	0									; Use boxFlag to identify board sRsrc.				<H17>	
-			dc.w	drHwGSC								; Uses the GSC (DBLite) video driver.
-
-VideoInfoEscher
-			dc.l	$60000000				; Physical base address of screen
-			dc.l	$60000000				; Logical 32 bit base address of screen
-			dc.l	0						; No logical 24-bit address.
-			dc.b	$0B						; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($0B-$09)*\	; PRAM address for slot zero
-					sizeSPRAMRec)
-			dc.b	sRsrcCSCDir				; Use the CSC sRsrc directory directory.
-			dc.b	sRsrc_BdEscher			; Use the Escher-family board sRsrc.
-			dc.w	drHwCSC					; Uses the CSC video driver.
-			
-VideoInfoYeager
-			dc.l	$60000000				; Physical base address of screen
-			dc.l	$60000000				; Logical 32 bit base address of screen
-			dc.l	0						; No logical 24-bit address.
-			dc.b	$0B						; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($0B-$09)*\	; PRAM address for slot zero
-					sizeSPRAMRec)
-			dc.b	sRsrcCSCDir				; Use the CSC sRsrc directory directory.
-			dc.b	sRsrc_BdYeager			; Use the Yeager-family board sRsrc.
-			dc.w	drHwCSC					; Uses the CSC video driver.
-
-		ENDIF											; {hasMSC}
-
-		IF hasPratt THEN
-VideoInfoPratt
-			dc.l	$60000000							; Physical base address of screen					<SM39>
-			dc.l	$60000000							; Logical 32 bit base address of screen				
-			dc.l	$00000000							; No logical 24-bit base address?			
-			dc.b	$0C									; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($0C-$09)*sizeSPRAMRec)	; PRAM address for  slot zero
-			dc.b	sRsrcCSCDir							; Use the CSC sRsrc directory directory.	
-			dc.b	sRsrc_BdBlackBird					; Use the BlackBird-family board sRsrc.			
-			dc.w	drHwCSC								; Uses the CSC video driver.
-		ENDIF											; {hasPratt}
-
-		IF hasSonora THEN
-VideoInfoVail
-			dc.l	$60B00000							; Physical base address of screen					<H24><SM29>
-			dc.l	$60B00000							; Logical 32-bit base address of screen				<H24><SM29>
-			dc.l	$00B00000							; Logical 24-bit base address of screen				<H24><SM29>
-			dc.b	$0B									; Slot number to use for PRAM storage				<H32>
-			dc.b	SmPRAMTop+(($0B-$09)*sizeSPRAMRec)	; PRAM address for slot zero						<H9>
-			dc.b	sRsrcSonoraDir						; Use the Sonora sRsrc directory directory.			<H17>
-			dc.b	sRsrc_BDVail						; Use the Vail-Family board sRsrc.					<H17>
-			dc.w	drHwSonora							; Uses the Sonora video driver.
-		ENDIF											; {hasSonora}
-
-		IF hasYMCA THEN									;													<SM46>
-VideoInfoCyclone										;													<P3>
-			dc.l	$50100000							; Physical base address of screen					<SM2>
-			dc.l	$50100000							; Logical 32 bit base address of screen
-			dc.l	0									; No logical 24-bit base address.
-			dc.b	$09									; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($09-$09)*sizeSPRAMRec)	; PRAM address for slot zero
-			dc.b	sRsrcCivicDir						; Use the Civic sRsrc directory directory.			<P6>
-			dc.b	sRsrc_BDCyclone						; Use the Cyclone-Family board sRsrc.
-			dc.w	drHwCivic							; Uses the Civic video driver.
-
-VideoInfoTempest										;													<P3>
-			dc.l	$50100000							; Physical base address of screen					
-			dc.l	$50100000							; Logical 32 bit base address of screen
-			dc.l	0									; No logical 24-bit base address.
-			dc.b	$09									; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($09-$09)*sizeSPRAMRec)	; PRAM address for slot zero
-			dc.b	sRsrcCivicDir						; Use the Civic sRsrc directory directory.			
-			dc.b	sRsrc_BDTempest						; Use the Tempest-Family board sRsrc.				
-			dc.w	drHwCivic							; Uses the Civic video driver.
-		ENDIF											;													<SM46>
-		
-		IF hasHMC THEN									;													<SM46>
-VideoInfoPDM
-			dc.l	$00000000							; Physical base address of screen
-			dc.l	$60B00000							; Logical 32-bit base address of screen
-			dc.l	0									; No logical 24-bit base address.
-			dc.b	$09									; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($09-$09)*sizeSPRAMRec)	; PRAM address for slot zero
-			dc.b	sRsrcSonoraDir						; Use the Sonora sRsrc directory directory.
-			dc.b	sRsrc_BdPDM							; Use the PDM-family board sRsrc.
-			dc.w	drHwSonora							; Uses the Sonora video driver.
-		ENDIF											;													<SM46>
-
-		IF hasGrandCentral THEN									;													<SM46>
-VideoInfoTNT
-			dc.l	$E0200000							; Physical base address of screen
-			dc.l	$E0200000							; Logical 32-bit base address of screen
-			dc.l	0									; No logical 24-bit base address.
-			dc.b	$0E									; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($0E-$09)*sizeSPRAMRec)	; PRAM address for slot zero
-			dc.b	sRsrcATIDir							; Use the ATI sRsrc directory directory.
-			dc.b	1									; Use the ATI-family board sRsrc.
-;			dc.b	sRsrc_BdATI							; Use the PDM-family board sRsrc.
-			dc.w	drHwATI								; Uses the ATI video driver.
-		ENDIF											;													<SM46>
-
+VideoInfoNewWorld
+			dc.w	-1
 
 
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 ;	NuBus Info Tables
 ;———————————————————————————————————————————————————————————————————————————————————————————————
 
-		IF hasVISADecoder THEN	
-NuBusInfoVISA		 									; beginning of change								<24><4>
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
-			dc.b	0|\									; slot 1
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 2
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 3
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 4
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 5
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 6
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 7
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 8
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 9
-					(1<<hasPRAM)|\
-					(1<<slotDisabled)
-			dc.b	0|\									; slot A
-					(1<<hasPRAM)|\
-					(1<<slotReserved)					;													<H20>
-			dc.b	0|\									; slot B
-					(1<<slotReserved)					;													<H20>
-			dc.b	0|\									; slot C
-					(1<<hasPRAM)|\
-					(1<<slotReserved)					;													<H20>
-			dc.b	0|\									; slot D
-					(1<<hasPRAM)|\
-					(1<<slotReserved)					;													<H20>
-			dc.b	0|\									; slot E
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<directSlot)
-			dc.b	0									; slot F	(end of change)
-		ENDIF											; {hasVISADecoder}
-
-
-
-		IF hasOrwell THEN
-NuBusInfoQuadra700										; slot info for Quadra 700							<T7>
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|\									; slot 9	("slot" space used for on-board video,
-					(1<<slotDisabled)|\					;            but the interrupt used for ethernet)
-					(1<<canInterrupt)					;
-			dc.b	0									; slot A
-			dc.b	0									; slot B
-			dc.b	0									; slot C
-			dc.b	0|\									; slot D
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot E	(either Slot E or PDS, if card present)
-					(1<<hasPRAM)|\						;
-					(1<<canInterrupt)|\					;
-					(1<<hasConnector)					;
-			dc.b	0									; slot F
-
-NuBusInfoQuadra900										; slot info for 040 Quadra 900						<24>
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|\									; slot 9	("slot" space used for on-board video)	<47>
-					(1<<slotDisabled)|\					;            this should not currently be looked at	<47>
-					(1<<canInterrupt)					;			 by the SlotMgr.						<47>
-			dc.b	0|\									; slot A
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot B
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot C
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot D
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot E	(either Slot E or PDS, if card present)	<47>
-					(1<<hasPRAM)|\						;													<47>
-					(1<<canInterrupt)|\					;													<47>
-					(1<<hasConnector)					;													<47>
-			dc.b	0									; slot F
-		ENDIF											; {hasOrwell}
-
-		IF hasJaws THEN
-NuBusInfoJaws
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
+NuBusInfoNewWorld
+			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
+			dc.b	0|(1<<slotDisabled)					; slot 1
+			dc.b	0|(1<<slotDisabled)					; slot 2
+			dc.b	0|(1<<slotDisabled)					; slot 3
+			dc.b	0|(1<<slotDisabled)					; slot 4
+			dc.b	0|(1<<slotDisabled)					; slot 5
+			dc.b	0|(1<<slotDisabled)					; slot 6
+			dc.b	0|(1<<slotDisabled)					; slot 7
+			dc.b	0|(1<<slotDisabled)					; slot 8
 			dc.b	0|(1<<slotDisabled)					; slot 9
 			dc.b	0|(1<<slotDisabled)					; slot A
 			dc.b	0|(1<<slotDisabled)					; slot B
-			dc.b	0|(1<<slotDisabled)					; slot C
-			dc.b	0|(1<<slotDisabled)					; slot D
-			dc.b	0|(1<<slotDisabled)					; slot E
+			dc.b	0|(1<<slotDisabled)|(1<<hasPRAM)	; slot C
+			dc.b	0|(1<<slotDisabled)|(1<<hasPRAM)	; slot D
+			dc.b	0|(1<<slotDisabled)|(1<<hasPRAM)	; slot E
 			dc.b	0									; slot F
-		ENDIF											; {hasJaws}
-
-		IF hasNiagra THEN
-NuBusInfoNiagra
-			dc.b	0|\									; slot 0											<H54>
-					(1<<hasPRAM)|\						;													  |
-					(1<<canInterrupt)					;													  v
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0|\									; slot 6	<=== LCD video goes here
-					(1<<slotDisabled)					;
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|\									; slot 9	<=== Bus Err from Niagra
-					(1<<slotDisabled)					;
-			dc.b	0|\									; slot A	<=== Bus Err from Niagra
-					(1<<slotDisabled)					;
-			dc.b	0|\									; slot B	<=== PRAM used for LCD video
-					(1<<slotDisabled)					;
-			dc.b	0|\									; slot C	<=== Monet
-					(1<<hasPRAM)|\						;
-					(1<<canInterrupt)					;
-			dc.b	0|\									; slot D	<=== Monet
-					(1<<hasPRAM)|\						;
-					(1<<canInterrupt)					;
-			dc.b	0|\									; slot E	<=== External VSC video goes here
-					(1<<hasPRAM)|\						;	
-					(1<<canInterrupt)|\					;
-					(1<<dockingSlot)					;
-			dc.b	0									; slot F											<H54>
-		ENDIF											; {hasNiagra}
-
-		IF hasMSC THEN
-NuBusInfoMSC
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0|(1<<slotDisabled)					; slot 6	<=== video goes here
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|(1<<slotDisabled)					; slot 9	<=== PRAM used for Power Manager
-			dc.b	0									; slot A
-			dc.b	0|(1<<slotDisabled)					; slot B	<=== PRAM used for LCD video
-			dc.b	0|\									; slot C	<=== NuBus slot on docking station
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot D	<=== NuBus slot on docking station
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot E	<=== connector bars go here
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<directSlot)|\
-					(1<<dockingSlot)
-			dc.b	0									; slot F
-		ENDIF											; {hasMSC}
-
-		IF hasPratt THEN
-NuBusInfoPratt
-			dc.b	0|\									; slot 0	<=== CSC video goes here											<SM39>
-					(1<<hasPRAM)|\													  
-					(1<<canInterrupt)													  
-			dc.b	0|\									; slot 1
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 2
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 3
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 4
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 5
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 6	<=== LCD video goes here
-					(1<<slotDisabled)					;
-			dc.b	0|\									; slot 7
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 8
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 9	<=== PRAM used for Power Manager
-					(1<<slotDisabled)					;
-			dc.b	0|\									; slot A	<=== PDS Slot
-					(1<<hasPRAM)|\													  
-					(1<<canInterrupt)													  
-			dc.b	0|\									; slot B	<=== Comms card Slot
-					(1<<hasPRAM)|\													  
-					(1<<canInterrupt)													  
-			dc.b	0|\									; slot C
-					(1<<slotDisabled)
-			dc.b	0|\									; slot D	
-					(1<<slotDisabled)					;
-			dc.b	0|\									; slot E	<=== External VSC video goes here
-					(1<<hasPRAM)|\						;	
-					(1<<canInterrupt)|\					;
-					(1<<dockingSlot)					;
-			dc.b	0|\									; slot F	
-					(1<<slotDisabled)					;
-		ENDIF											; {hasPratt}
-
-		IF hasSonora THEN
-NuBusInfoVail
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0|(1<<slotDisabled)					; slot 6	<=== Video goes here for 32 bit mode	<H32>
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0									; slot 9
-			dc.b	0									; slot A
-			dc.b	0|(1<<slotDisabled)					; slot B	<=== PRAM used for video, 24 bit video space	<H32>
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot C
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot D
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot E
-			dc.b	0									; slot F
-		ENDIF											; {hasSonora}
-
-		IF hasDJMEMC THEN
-NuBusInfoWombat											; similar to Quadra700 except it has 3 slots, not 2	<H41> thru next <H41>
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|\									; slot 9	("slot" space used for on-board video,
-					(1<<slotDisabled)|\					;			 interrupt used for built-in ethernet)
-					(1<<canInterrupt)					;            
-			dc.b	0									; slot A
-			dc.b	0									; slot B
-			dc.b	0|\									; slot C
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot D
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot E	(either Slot E or PDS, if card present)
-					(1<<hasPRAM)|\						;
-					(1<<canInterrupt)|\					;
-					(1<<hasConnector)					;
-			dc.b	0									; slot F
-
-NuBusInfoWLCD											; slot info for WLCD(s)
-			dc.b	0|\									; slot 0
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|\									; slot 9	("slot" space used for on-board video,
-					(1<<slotDisabled)|\					;			 interrupt used for built-in ethernet)
-					(1<<canInterrupt)					;            
-			dc.b	0									; slot A
-			dc.b	0									; slot B
-			dc.b	0									; slot C
-			dc.b	0									; slot D
-			dc.b	0|\									; slot E	(PDS or NuBus adapter, if card present)
-					(1<<hasPRAM)|\						;
-					(1<<canInterrupt)|\					;
-					(1<<hasConnector)					;
-			dc.b	0									; slot F											<H41>
-		ENDIF											; {hasDJMEMC}
-
-		IF hasYMCA THEN									;													<SM46>
-NuBusInfoCyclone										;													<SM2>
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0	-> Built-in Video, Ethernet, etc….
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0|(1<<slotDisabled)					; slot 5	-> Built-in video’s VRAM is here (Super5).
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|(1<<slotDisabled)					; slot 9	-> Built-in Video PRAM
-			dc.b	0|\									; slot A
-					(1<<hasPRAM)
-			dc.b	0|\									; slot B
-					(1<<hasPRAM)
-			dc.b	0|\									; slot C	-> Physical Slot.
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot D	-> Physical Slot.
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot E	-> Physical Slot.
-					(1<<hasPRAM)|\						;
-					(1<<canInterrupt)|\					;
-					(1<<hasConnector)					;
-			
-			dc.b	0									; slot F	-> End of table (Slot Manager/VM doesn’t use).
-
-NuBusInfoTempest										;													<SM26>
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0	-> Built-in Video, Ethernet, etc….
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0|(1<<slotDisabled)					; slot 5	-> Built-in video’s VRAM is here (Super5).
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|(1<<slotDisabled)					; slot 9	-> Built-in Video PRAM
-			dc.b	0|\									; slot A
-					(1<<hasPRAM)
-			dc.b	0|\									; slot B
-					(1<<hasPRAM)
-			dc.b	0|\									; slot C	
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<directSlot)
-			dc.b	0|\									; slot D
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<directSlot)
-			dc.b	0|\									; slot E	-> Physical Slot.
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)					;
-			dc.b	0									; slot F	-> End of table (Slot Manager/VM doesn’t use).
-		ENDIF											; {hasYMCA}											<SM46>
-		
-		IF hasHMC THEN									;													<SM46>
-NuBusInfoPDM
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0	-> Built-in Video, Ethernet, etc….
-			dc.b	0									; slot 1	-> ???
-			dc.b	0									; slot 2	-> ???
-			dc.b	0									; slot 3	-> ???
-			dc.b	0									; slot 4	-> ???
-			dc.b	0									; slot 5	-> 
-			dc.b	0|\									; slot 6	-> ???	
-					(1<<slotDisabled)|\
-					(1<<hasPRAM)
-			dc.b	0									; slot 7	-> ???
-			dc.b	0									; slot 8	-> ???
-			dc.b	0|\									; slot 9	-> Built-in Video PRAM, Ethernet interrupts,
-					(1<<slotDisabled)|\					;			   2nd Meg of ROM in 24-bit mode.
-					(1<<canInterrupt)					;
-			dc.b	0									; slot A	-> ???
-			dc.b	0									; slot B	-> ???		
-			dc.b	0									; slot C	-> ???
-			dc.b	0									; slot D	-> ???
-			dc.b	0|\									; slot E	-> Physical Slot.
-					(1<<hasPRAM)|\						;
-					(1<<canInterrupt)|\					;
-					(1<<hasConnector)					;
-			dc.b	0									; slot F	-> End of table (Slot Manager/VM doesn’t use).
-
-NuBusInfoCFusion
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0	-> Built-in Video, Ethernet, etc….
-			dc.b	0									; slot 1	-> ???
-			dc.b	0									; slot 2	-> ???
-			dc.b	0									; slot 3	-> ???
-			dc.b	0									; slot 4	-> ???
-			dc.b	0									; slot 5	-> 
-			dc.b	0|\									; slot 6	-> ???	
-					(1<<slotDisabled)|\
-					(1<<hasPRAM)
-			dc.b	0									; slot 7	-> ???
-			dc.b	0									; slot 8	-> ???
-			dc.b	0|\									; slot 9	-> Built-in Video PRAM, Ethernet interrupts,
-					(1<<slotDisabled)|\					;			   2nd Meg of ROM in 24-bit mode.
-					(1<<canInterrupt)					;
-			dc.b	0									; slot A	-> ???
-			dc.b	0|\									; slot B	-> Physical Slot.		
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot C	-> Physical Slot.
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot D	-> Physical Slot.
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot E	-> Video Expansion (HPV or Plinaria).
-					(1<<hasPRAM)|\						;
-					(1<<canInterrupt)|\					;
-					(1<<hasConnector)					;
-			dc.b	0									; slot F	-> End of table (Slot Manager/VM doesn’t use).
-			
-		ENDIF											; {hasHMC}											<SM46>
-
-		IF hasGrandCentral THEN									;													<SM46>
-NuBusInfoTNT
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0	-> Built-in Video, Ethernet, etc….
-			dc.b	0|\									; slot 1	-> ???	
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 2	-> ???	
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 3	-> ???	
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 4	-> ???	
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 5	-> ???	
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 6	-> ???	
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 7	-> ???
-					(1<<slotDisabled)
-			dc.b	0|\									; slot 8	-> ???
-					(1<<slotDisabled)					;			   
-			dc.b	0|\									; slot 9	-> ???
-					(1<<slotDisabled)					;			   
-			dc.b	0|\									; slot A	-> ???
-					(1<<slotDisabled)
-			dc.b	0|\									; slot B	-> ???		
-					(1<<slotDisabled)
-			dc.b	0|\									; slot C	-> ???
-					(1<<slotDisabled)|\
-					(1<<hasPRAM)
-			dc.b	0|\									; slot D	-> ???
-					(1<<slotDisabled)|\
-					(1<<hasPRAM)
-			dc.b	0|\									; slot E	-> ???.
-					(1<<slotDisabled)|\
-					(1<<hasPRAM)
-			dc.b	0									; slot F	-> End of table (Slot Manager/VM doesn’t use).
-
-		ENDIF											; (hasGrandCentral)
 
 
 IconTable												;													<SM74>
-		IF hasOSS THEN
-IconInfo6Slot											; Macintosh II,IIx,IIfx table
-			dc.l	DisketteIcon-IconInfo6Slot			;	drive 1 logical icon,
-			dc.l	Right6SlotIcon-IconInfo6Slot		;	physical icon,
-			dc.w	$0003								;	primary int removable, 800K Sony
-
-			dc.l	DisketteIcon-IconInfo6Slot			;	drive 2 logical icon,
-			dc.l	Left6SlotIcon-IconInfo6Slot			;	physical icon,
-			dc.w	$0803								;	secondary int removable, 800K Sony
-		ENDIF
-		
-		IF hasMDU THEN									;
-IconInfo3Slot											; Macintosh IIcx/Aurora table
-			dc.l	DisketteIcon-IconInfo3Slot			;	drive 1 logical icon,
-			dc.l	Int3SlotIcon-IconInfo3Slot			;	physical icon (small box)
-			dc.w	$0003								;	primary int removable, 800K Sony
-
-			dc.l	DisketteIcon-IconInfo3Slot			;	drive 2 logical icon,
-			dc.l	Ext3SlotIcon-IconInfo3Slot			;	physical icon, (small box)
-			dc.w	$0103								;	primary ext removable 800K Sony
-
-IconInfoMacIIsi											; Macintosh IIsi table
-			dc.l	DisketteIcon-IconInfoMacIIsi		;	drive 1 logical icon,				
-			dc.l	IntMacIIsiIcon-IconInfoMacIIsi		;	physical icon (small box)			
-			dc.w	$0003								;	primary int removable, 800K Sony
-
-			dc.l	DisketteIcon-IconInfoMacIIsi		;	drive 2 logical icon,	
-			dc.l	ExtMacIIsiIcon-IconInfoMacIIsi		;	physical icon, (small box)
-			dc.w	$0103								;	primary ext removable 800K Sony
-		ENDIF
-		
-		IF hasVISADecoder | hasSonora THEN
-IconInfoMacLC											; Macintosh LC Table
-			dc.l	DisketteIcon-IconInfoMacLC			;	drive 1 logical icon,
-			dc.l	RightMacLCIcon-IconInfoMacLC		;	physical icon,
-			dc.w	$0004								;	primary int removable, SuperDrive
-
-			dc.l	DisketteIcon-IconInfoMacLC			;	drive 2 logical icon,
-			dc.l	LeftMacLCIcon-IconInfoMacLC			;	physical icon,
-			dc.w	$0804								;	secondary int removable, SuperDrive
-		ENDIF
-		
-		IF hasOrwell THEN
-IconInfoQuadra700										; Quadra 700 Table
-			dc.l	DisketteIcon-IconInfoQuadra700		;	drive 1 logical icon,
-			dc.l	Quadra700Icon-IconInfoQuadra700		;	physical icon,
-			dc.w	$0004								;	primary int removable, SuperDrive
-
-			dc.l	DisketteIcon-IconInfoQuadra700		;	drive 2 logical icon,
-			dc.l	Quadra700Icon-IconInfoQuadra700		;	physical icon,
-			dc.w	$0104								;	secondary ext removable, SuperDrive (Actually there is none...)
-		
-IconInfoQuadra900										; Quadra 900/950 Table
-			dc.l	DisketteIcon-IconInfoQuadra900		;	drive 1 logical icon,
-			dc.l	Quadra900Icon-IconInfoQuadra900		;	physical icon,
-			dc.w	$0004								;	primary int removable, SuperDrive
-
-			dc.l	DisketteIcon-IconInfoQuadra900		;	drive 2 logical icon,
-			dc.l	Quadra900Icon-IconInfoQuadra900		;	physical icon,
-			dc.w	$0104								;	secondary ext removable, SuperDrive (Actually there is none...)
-		ENDIF
-
-		IF hasJaws | hasNiagra | hasPratt THEN			;
-IconInfoTim												; Tim Table
-			dc.l	DisketteIcon-IconInfoTim			;	drive 1 logical icon,
-			dc.l	TimIcon-IconInfoTim					;	physical icon,
-			dc.w	$0004								;	primary int removable, SuperDrive
-
-			dc.l	DisketteIcon-IconInfoTim			;	drive 2 logical icon,
-			dc.l	TimIcon-IconInfoTim					;	physical icon,
-			dc.w	$0104								;	secondary ext removable, SuperDrive (Actually there is none...)
-		ENDIF
-		
-		IF hasMSC THEN
-IconInfoDBLite											; DB-Lite table
-			dc.l	DisketteIcon-IconInfoDBLite			;	drive 1 logical icon,
-			dc.l	DBLiteIcon-IconInfoDBLite			;	physical icon,
-			dc.w	$0104								;	primary ext removable, SuperDrive
-
-			dc.l	DisketteIcon-IconInfoDBLite			;	drive 2 logical icon,
-			dc.l	DBLiteIcon-IconInfoDBLite			;	physical icon,
-			dc.w	$0904								;	secondary ext removable, SuperDrive
-		ENDIF
-		
-		IF hasDJMEMC | hasYMCA | hasHMC THEN			;
-IconInfoLego											; Wombat (or others) in a Lego package
-			dc.l	DisketteIcon-IconInfoLego			;	drive 1 logical icon,
-			dc.l	LegoIcon-IconInfoLego				;	physical icon,
-			dc.w	$0004								;	primary int removable, SuperDrive
-
-			dc.l	DisketteIcon-IconInfoLego			;	drive 2 logical icon,
-			dc.l	LegoIcon-IconInfoLego				;	physical icon,
-			dc.w	$0104								;	secondary ext removable, SuperDrive (Actually there is none...)
-
-IconInfoFrigidaire										; Wombat (or others) in a Frigidaire package
-			dc.l	DisketteIcon-IconInfoFrigidaire		;	drive 1 logical icon,
-			dc.l	FrigidaireIcon-IconInfoFrigidaire	;	physical icon,
-			dc.w	$0004								;	primary int removable, SuperDrive
-
-			dc.l	DisketteIcon-IconInfoFrigidaire		;	drive 2 logical icon,
-			dc.l	FrigidaireIcon-IconInfoFrigidaire	;	physical icon,
-			dc.w	$0104								;	secondary ext removable, SuperDrive (Actually there is none...)
-		
-IconInfoQFC												; WLCD, PDM (or others) in a QFC package
-			dc.l	DisketteIcon-IconInfoQFC			;	drive 1 logical icon,
-			dc.l	QFCIcon-IconInfoQFC					;	physical icon,
+IconInfoNewWorld
+			dc.l	DisketteIcon-IconInfoNewWorld		;	drive 1 logical icon,
+			dc.l	DisketteIcon-IconInfoNewWorld		;	physical icon,
 			dc.w	$0004								;	primary int removable, SuperDrive
 
-			dc.l	DisketteIcon-IconInfoQFC			;	drive 2 logical icon,
-			dc.l	QFCIcon-IconInfoQFC					;	physical icon,
+			dc.l	DisketteIcon-IconInfoNewWorld		;	drive 2 logical icon,
+			dc.l	DisketteIcon-IconInfoNewWorld		;	physical icon,
 			dc.w	$0104								;	secondary ext removable, SuperDrive (Actually there is none...)
-		ENDIF											;
 
 
 
@@ -5948,387 +690,6 @@ DisketteIcon
 			_AssumeEq	(DisketteIcon-IconTable),((DisketteIcon-IconTable)>>1)<<1
 
 
-		IF hasOSS THEN
-;  Mac II Left Sony icon
-
-Left6SlotIcon
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$FFFF,$FFFF
-			dc.w	$8000,$0001,$8000,$0001,$903F,$C7F9,$8000,$0001
-			dc.w	$8004,$0001,$800E,$0001,$801F,$0001,$8004,$0001
-			dc.w	$8004,$0001,$8004,$0001,$8000,$0001,$FFFF,$FFFF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-			
-			_AssumeEq	(Left6SlotIcon-IconTable),((Left6SlotIcon-IconTable)>>1)<<1
-		
-;  Mac II Right Sony icon
-
-Right6SlotIcon
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$FFFF,$FFFF
-			dc.w	$8000,$0001,$8000,$0001,$903F,$C7F9,$8000,$0001
-			dc.w	$8000,$0081,$8000,$01C1,$8000,$03E1,$8000,$0081
-			dc.w	$8000,$0081,$8000,$0081,$8000,$0001,$FFFF,$FFFF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-			
-			_AssumeEq	(Right6SlotIcon-IconTable),((Right6SlotIcon-IconTable)>>1)<<1
-		ENDIF
-
-
-		IF hasMDU THEN
-;  small box Mac II Internal Sony icon
-
-Int3SlotIcon
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0080,$0000,$0080,$0000,$0080
-			dc.w	$0000,$0080,$0000,$03E0,$0000,$01C0,$0000,$0080
-			dc.w	$0000,$0000,$FFFF,$FFFF,$8000,$0001,$FFFF,$FFFF
-			dc.w	$8000,$0001,$8000,$0001,$8000,$0001,$FFFF,$FFFF
-			dc.w	$8000,$0FF9,$8000,$0001,$8000,$0001,$A000,$0001
-			dc.w	$8000,$0001,$FFFF,$FFFF,$8000,$0001,$FFFF,$FFFF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0080,$0000,$0080,$0000,$0080
-			dc.w	$0000,$0080,$0000,$03E0,$0000,$01C0,$0000,$0080
-			dc.w	$0000,$0000,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-
-			_AssumeEq	(Int3SlotIcon-IconTable),((Int3SlotIcon-IconTable)>>1)<<1
-
-;  small box Mac II External Sony icon
-
-Ext3SlotIcon
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0010
-			dc.w	$0000,$0010,$FFFF,$FC10,$8000,$0410,$FFFF,$FC7C
-			dc.w	$8000,$0438,$FFFF,$FC10,$8001,$F400,$A000,$05FF
-			dc.w	$8000,$0501,$FFFF,$FD7D,$8000,$0501,$FFFF,$FDFF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0010
-			dc.w	$0000,$0010,$FFFF,$FC10,$FFFF,$FC10,$FFFF,$FC7C
-			dc.w	$FFFF,$FC38,$FFFF,$FC10,$FFFF,$FC00,$FFFF,$FDFF
-			dc.w	$FFFF,$FDFF,$FFFF,$FDFF,$FFFF,$FDFF,$FFFF,$FDFF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-			
-			_AssumeEq	(Ext3SlotIcon-IconTable),((Ext3SlotIcon-IconTable)>>1)<<1
-
-; Macintosh IIsi internal drive icon.
-
-IntMacIIsiIcon
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0400,$0000,$0400,$0000,$0400
-			dc.w	$0000,$1F00,$0000,$0E00,$0000,$0400,$0000,$0000
-			dc.w	$1FFF,$FFF8,$1000,$0008,$1000,$7FC8,$1000,$0008
-			dc.w	$1300,$0008,$1000,$0008,$1FFF,$FFF8,$0800,$0010
-			dc.w	$0FFF,$FFF0,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-	
-			
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0400,$0000,$0400,$0000,$0400
-			dc.w	$0000,$1F00,$0000,$0E00,$0000,$0400,$0000,$0000
-			dc.w	$1FFF,$FFF8,$1FFF,$FFF8,$1FFF,$FFF8,$1FFF,$FFF8
-			dc.w	$1FFF,$FFF8,$1FFF,$FFF8,$1FFF,$FFF8,$0FFF,$FFF0
-			dc.w	$0FFF,$FFF0,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-
-			_AssumeEq	(IntMacIIsiIcon-IconTable),((IntMacIIsiIcon-IconTable)>>1)<<1
-
-; Macintosh IIsi external drive icon.
-
-ExtMacIIsiIcon
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0010,$0000,$0010,$0000,$0010,$FFFF,$FC7C
-			dc.w	$8000,$0438,$803F,$E410,$8000,$0400,$A000,$05FF
-			dc.w	$8000,$0501,$FFFF,$FD7D,$4000,$0901,$7FFF,$F9FF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-	
-						
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0010,$0000,$0010,$0000,$0010,$FFFF,$FC7C
-			dc.w	$FFFF,$FC38,$FFFF,$FC10,$FFFF,$FC00,$FFFF,$FDFF
-			dc.w	$FFFF,$FDFF,$FFFF,$FDFF,$7FFF,$F9FF,$7FFF,$F9FF
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-
-			_AssumeEq	(ExtMacIIsiIcon-IconTable),((ExtMacIIsiIcon-IconTable)>>1)<<1
-		ENDIF
-		
-
-		IF hasVISADecoder | hasSonora THEN
-;  Macintosh LC left drive icon.
-
-LeftMacLCIcon
-			dc.w	$0000,$0000,$0080,$0000,$0080,$0000,$0080,$0000
-			dc.w	$0080,$0000,$03E0,$0000,$01C0,$0000,$0080,$0000
-			dc.w	$0000,$0000,$FFFF,$FFFF,$8000,$0001,$8FF8,$1FF1
-			dc.w	$8000,$0001,$8000,$0001,$FFFF,$FFFF,$2000,$0004
-			dc.w	$3FFF,$FFFC,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			
-			dc.w	$01C0,$0000,$01C0,$0000,$01C0,$0000,$01C0,$0000
-			dc.w	$0FF8,$0000,$07F0,$0000,$03E0,$0000,$01C0,$0000
-			dc.w	$0080,$0000,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$3FFF,$FFFC
-			dc.w	$3FFF,$FFFC,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-
-			_AssumeEq	(LeftMacLCIcon-IconTable),((LeftMacLCIcon-IconTable)>>1)<<1
-
-;  Macintosh LC right drive icon.
-
-RightMacLCIcon
-			dc.w	$0000,$0000,$0000,$0100,$0000,$0100,$0000,$0100
-			dc.w	$0000,$0100,$0000,$07C0,$0000,$0380,$0000,$0100
-			dc.w	$0000,$0000,$FFFF,$FFFF,$8000,$0001,$8000,$1FF1
-			dc.w	$8000,$0001,$8000,$0001,$FFFF,$FFFF,$2000,$0004
-			dc.w	$3FFF,$FFFC,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			
-			dc.w	$0000,$0380,$0000,$0380,$0000,$0380,$0000,$0380
-			dc.w	$0000,$1FF0,$0000,$0FE0,$0000,$07C0,$0000,$0380
-			dc.w	$0000,$0100,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF
-			dc.w	$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$FFFF,$3FFF,$FFFC
-			dc.w	$3FFF,$FFFC,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-			
-			_AssumeEq	(RightMacLCIcon-IconTable),((RightMacLCIcon-IconTable)>>1)<<1
-		ENDIF
-		
-
-		IF hasOrwell THEN
-;  Quadra 900 icon.
-
-Quadra900Icon
-			dc.w	$0000,$0000,$0FFF,$F000,$0800,$1000,$08FF,$F000
-			dc.w	$0880,$1080,$0880,$1180,$08BF,$D3F8,$0880,$1180
-			dc.w	$0880,$1080,$0880,$1000,$0880,$1000,$0880,$1000
-			dc.w	$0880,$1000,$0880,$1000,$0880,$1000,$0880,$1000
-			dc.w	$0880,$1000,$0880,$1000,$0880,$1000,$0880,$1000
-			dc.w	$0880,$1000,$08BF,$D000,$0880,$1000,$08BF,$D000
-			dc.w	$0880,$1000,$08BF,$D000,$0880,$1000,$08BF,$D000
-			dc.w	$0880,$1000,$08BF,$D000,$0880,$1000,$0FFF,$F000
-			
-			dc.w	$0000,$0000,$0FFF,$F000,$0FFF,$F000,$0FFF,$F000
-			dc.w	$0FFF,$F080,$0FFF,$F180,$0FFF,$F3F8,$0FFF,$F180
-			dc.w	$0FFF,$F080,$0FFF,$F000,$0FFF,$F000,$0FFF,$F000
-			dc.w	$0FFF,$F000,$0FFF,$F000,$0FFF,$F000,$0FFF,$F000
-			dc.w	$0FFF,$F000,$0FFF,$F000,$0FFF,$F000,$0FFF,$F000
-			dc.w	$0FFF,$F000,$0FFF,$F000,$0FFF,$F000,$0FFF,$F000
-			dc.w	$0FFF,$F000,$0FFF,$F000,$0FFF,$F000,$0FFF,$F000
-			dc.w	$0FFF,$F000,$0FFF,$F000,$0FFF,$F000,$0FFF,$F000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-
-			_AssumeEq	(Quadra900Icon-IconTable),((Quadra900Icon-IconTable)>>1)<<1
-
-
-;  Quadra 700 icon.
-
-Quadra700Icon
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$1FFF,$8000,$1000,$8000,$1000,$8000,$17A0,$8000
-			dc.w	$1020,$8400,$17A0,$8C00,$1020,$9FC0,$17A0,$8C00
-			dc.w	$1020,$8400,$17A6,$8000,$1026,$8000,$1780,$8000
-			dc.w	$1000,$8000,$1780,$8000,$1000,$8000,$1780,$8000
-			dc.w	$1000,$8000,$1780,$8000,$1000,$8000,$1780,$8000
-			dc.w	$1000,$8000,$1780,$8000,$1000,$8000,$1782,$8000
-			dc.w	$1000,$8000,$1782,$8000,$1000,$8000,$1FFF,$8000
-
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$1FFF,$8000,$1FFF,$8000,$1FFF,$8000,$1FFF,$8000
-			dc.w	$1FFF,$8400,$1FFF,$8C00,$1FFF,$9FC0,$1FFF,$8C00
-			dc.w	$1FFF,$8400,$1FFF,$8000,$1FFF,$8000,$1FFF,$8000
-			dc.w	$1FFF,$8000,$1FFF,$8000,$1FFF,$8000,$1FFF,$8000
-			dc.w	$1FFF,$8000,$1FFF,$8000,$1FFF,$8000,$1FFF,$8000
-			dc.w	$1FFF,$8000,$1FFF,$8000,$1FFF,$8000,$1FFF,$8000
-			dc.w	$1FFF,$8000,$1FFF,$8000,$1FFF,$8000,$1FFF,$8000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-
-			_AssumeEq	(Quadra700Icon-IconTable),((Quadra700Icon-IconTable)>>1)<<1
-		ENDIF
-		
-
-		IF hasJaws | hasNiagra | hasPratt THEN
-;  PowerBook 140/170, Dartanian/Dartanian LC icon.
-
-TimIcon
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0002,$0000,$0005,$0000,$0009
-			dc.w	$0000,$0012,$0000,$0024,$0000,$0048,$0000,$0090
-			dc.w	$0000,$0120,$0000,$0240,$0000,$0480,$0000,$0900
-			dc.w	$0000,$0E00,$0000,$1C00,$00DB,$7E00,$01FF,$C210
-			dc.w	$7F00,$4230,$803F,$427F,$8000,$4230,$FFFF,$FC10
-			
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0002,$0000,$0007,$0000,$000F
-			dc.w	$0000,$001E,$0000,$003C,$0000,$0078,$0000,$00F0
-			dc.w	$0000,$01E0,$0000,$03C0,$0000,$0780,$0000,$0F00
-			dc.w	$0000,$0E00,$0000,$1C00,$00DB,$7E00,$01FF,$FE10
-			dc.w	$7FFF,$FE30,$FFFF,$FE7F,$FFFF,$FE30,$FFFF,$FC10
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-
-			_AssumeEq	(TimIcon-IconTable),((TimIcon-IconTable)>>1)<<1
-		ENDIF
-
-
-		IF hasMSC THEN
-;  DBLite icon.
-
-DBLiteIcon	dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0002
-			dc.w	$0000,$0005,$0000,$0009,$0000,$0012,$0000,$0024
-			dc.w	$0000,$0048,$0000,$0090,$0000,$0120,$0000,$0240
-			dc.w	$0000,$0480,$0000,$0900,$0000,$1E00,$006D,$9C00
-			dc.w	$7FFF,$FE00,$8000,$0200,$8000,$0200,$7FFF,$FC00
-			dc.w	$0000,$0000,$0000,$0000,$003F,$FE20,$0020,$0260
-			dc.w	$0027,$F2FE,$0020,$0260,$003F,$FE20,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0002
-			dc.w	$0000,$0007,$0000,$000F,$0000,$001E,$0000,$003C
-			dc.w	$0000,$0078,$0000,$00F0,$0000,$01E0,$0000,$03C0
-			dc.w	$0000,$0780,$0000,$0F00,$0000,$1E00,$006D,$9C00
-			dc.w	$7FFF,$FE00,$FFFF,$FE00,$FFFF,$FE00,$7FFF,$FC00
-			dc.w	$0000,$0000,$0000,$0000,$003F,$FE20,$003F,$FE60
-			dc.w	$003F,$FEFE,$003F,$FE60,$003F,$FE20,$0000,$0000
-			dc.w	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			dc.w	$0 ;old HD-20 driver drive ID string (null here)
-
-			_AssumeEq	(DBLiteIcon-IconTable),((DBLiteIcon-IconTable)>>1)<<1
-		ENDIF
-		
-
-		IF hasDJMEMC | hasYMCA | hasHMC THEN
-;  Lego icon
-
-LegoIcon
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0080,$0000,$0080,$0000,$0080,$0000,$0080
-			DC.W	$0000,$03E0,$0000,$01C0,$0000,$0080,$0000,$0000
-			DC.W	$0000,$0000,$7FFF,$FFFE,$4000,$0002,$5800,$0FF2
-			DC.W	$5800,$0002,$4000,$0002,$7FFF,$FFFE,$4004,$0002
-			DC.W	$5554,$0002,$4004,$0002,$5554,$0002,$4004,$0002
-			DC.W	$7FFF,$FFFE,$4000,$0002,$4000,$0002,$7FFF,$FFFE
-
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$01C0
-			DC.W	$0000,$01C0,$0000,$01C0,$0000,$01C0,$0000,$07F0
-			DC.W	$0000,$07F0,$0000,$03E0,$0000,$01C0,$0000,$0080
-			DC.W	$0000,$0000,$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE
-			DC.W	$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE
-			DC.W	$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE
-			DC.W	$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE
-			DC.W	$0 ;old HD-20 driver drive ID string (null here)
-			
-			_AssumeEq	(LegoIcon-IconTable),((LegoIcon-IconTable)>>1)<<1
-		
-		
-;  Fridgidaire Sony icon
-
-FrigidaireIcon
-			DC.W	$0000,$0000,$0000,$0000,$000F,$FFC0,$0010,$0120
-			DC.W	$0010,$0120,$0010,$0120,$0010,$0120,$021F,$FF20
-			DC.W	$0310,$0120,$3F93,$F920,$0310,$0120,$021F,$FF20
-			DC.W	$0010,$0120,$0010,$0120,$0010,$0120,$0010,$0120
-			DC.W	$001F,$FF20,$0010,$0120,$0010,$0120,$0010,$0120
-			DC.W	$0010,$0120,$0010,$0120,$0010,$0120,$0030,$01B0
-			DC.W	$0030,$0130,$0030,$61B0,$0030,$6130,$0030,$01B0
-			DC.W	$0030,$0130,$003F,$FFF0,$003E,$01F0,$0000,$0000
-
-			DC.W	$0000,$0000,$0000,$0000,$000F,$FFC0,$001F,$FFE0
-			DC.W	$001F,$FFE0,$001F,$FFE0,$061F,$FFE0,$071F,$FFE0
-			DC.W	$7F9F,$FFE0,$7FDF,$FFE0,$7F9F,$FFE0,$071F,$FFE0
-			DC.W	$061F,$FFE0,$001F,$FFE0,$001F,$FFE0,$001F,$FFE0
-			DC.W	$001F,$FFE0,$001F,$FFE0,$001F,$FFE0,$001F,$FFE0
-			DC.W	$001F,$FFE0,$001F,$FFE0,$001F,$FFE0,$003F,$FFF0
-			DC.W	$003F,$FFF0,$003F,$FFF0,$003F,$FFF0,$003F,$FFF0
-			DC.W	$003F,$FFF0,$003F,$FFF0,$003E,$01F0,$0000,$0000
-			DC.W	$0 ;old HD-20 driver drive ID string (null here)
-			
-			_AssumeEq	(FrigidaireIcon-IconTable),((FrigidaireIcon-IconTable)>>1)<<1
-
-
-;  QFC Sony icon
-
-QFCIcon
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000	
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0040
-			DC.W	$0000,$0040,$0000,$0040,$0000,$0040,$0000,$01F0	
-			DC.W	$0000,$00E0,$0000,$0040,$0000,$0000,$0000,$0000
-			DC.W	$7FFF,$FFFE,$4020,$0802,$5820,$0BFA,$5820,$0802
-			DC.W	$4020,$0802,$4820,$081A,$7FFF,$FFE6,$3FFF,$FFFC
-			
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
-			DC.W	$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE
-			DC.W	$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE,$7FFF,$FFFE	
-			DC.W	$0 ;old HD-20 driver drive ID string (null here)
-			
-			_AssumeEq	(QFCIcon-IconTable),((QFCIcon-IconTable)>>1)<<1
-		ENDIF
-
-
 
 
 
@@ -6343,31 +704,21 @@ QFCIcon
 dINPUT		EQU		0
 dOUTPUT		EQU		1
 
-
-		IF hasVISADecoder | hasMDU THEN
-VIA1InitMacIIsi
-VIA1InitMacLC
-			dc.b	\									; vBufA initial value								<9>
-					(6)|\								; sound volume level initially 1
+VIA1InitNewWorld
+			dc.b	\									; vBufA initial value
 					(0<<vSync)|\						; Synchronous modem disabled (active high)
-					(0<<vCpuId2)|\						; CPU Identification bit 2 is an input
-					(1<<vHeadSel)|\						; head select line is an output
-					(0<<vCpuId3)|\						; CPU Identification bit 3 is an input
-					(0<<vSCCWrReq)						; SCC write/request line is an input
+					(1<<4)|\							; 
+					(0<<6)								; 
 
 			dc.b	\									; vDIRA initial value
-			 		(vSound)|\							; sound volume bits are outputs
 					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dINPUT<<vCpuId2)|\					; CPU Identification bit 2 is an input
-					(dOUTPUT<<vHeadSel)|\				; head select line is an output
-					(dINPUT<<vCpuId3)|\					; CPU Identification bit 3 is an input
-					(dINPUT<<vSCCWrReq)					; SCC write/request line is an input
+					(dOUTPUT<<4)|\						; 
+					(dOUTPUT<<6)						; 
 
 			dc.b	\									; vBufB initial value
 					(1<<vXcvrSesBit)|\					; Egret interrupt (xcvr session)
-					(0<<vViaFullBit)|\					; Egret via full
-					(0<<vSysSesbit)|\					; Egret system session
-					(1<<vPGCEnb)						; Parity Checking is initially disabled
+					(1<<vViaFullBit)|\					; Egret via full
+					(1<<vSysSesbit)						; Egret system session
 
 			dc.b	\									; vDIRB initial value
 					(dINPUT<<vXcvrSesBit)|\				; xcvr session is an input
@@ -6386,1413 +737,15 @@ VIA1InitMacLC
 					(%111<<2)|\							; SR enabled for Egret				
 					(%0<<5)|\							; T2 timed interrupt
 					(%00<<6)							; T1 timed interrupt, PB7 disabled
-		ENDIF											; {hasVISADecoder | hasMDU}
 
-
-
-		IF hasOrwell THEN
-VIA1InitQuadra700
-			dc.b	\									; vBufA initial value
-					(0<<vCpuId0)|\						; CPU Identification bit 0 is an input
-					(0<<vCpuId1)|\						; CPU Identification bit 1 is an input
-					(0<<vSync)|\						; Synchronous modem disabled (active high)
-					(0<<vCpuId2)|\						; CPU Identification bit 2 is an input
-					(1<<vHeadSel)|\						; head select line is an output
-					(0<<vCpuId3)|\						; CPU Identification bit 3 is an input
-					(0<<vSCCWrReq)						; SCC write/request line is an input
-
-			dc.b	\									; vDIRA initial value
-					(dINPUT<<vCpuId0)|\					; CPU Identification bit 0 is an input
-					(dINPUT<<vCpuId1)|\					; CPU Identification bit 1 is an input
-					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dINPUT<<vCpuId2)|\					; CPU Identification bit 2 is an input
-					(dOUTPUT<<vHeadSel)|\				; head select line is an output
-					(dINPUT<<vCpuId3)|\					; CPU Identification bit 3 is an input
-					(dINPUT<<vSCCWrReq)					; SCC write/request line is an input
-
-			dc.b	\									; vBufB initial value
-			 		(1<<vRTCData)|\						; real time clock data is one
-					(1<<vRTCClk)|\						; real time clock clock is high
-					(1<<vRTCEnb)|\						; clock initially disabled
-					(0<<vFDBInt)|\						; Front Desk bus interrupt is an input
-					(1<<vFDesk1)|\						; FDB state bit 0 is initially state 3
-					(1<<vFDesk2)|\						; FDB state bit 1 is initially state 3
-					(1<<vAUXIntEnb)|\					; switch to AUX interrupt priority scheme is active-low
-					(1<<vSWInt)							; software interrupt is active-low
-
-			dc.b	\									; vDIRB initial value
-			 		(dOUTPUT<<vRTCData)|\				; real time clock data initially an output
-					(dOUTPUT<<vRTCClk)|\				; real time clock clock is an output
-					(dOUTPUT<<vRTCEnb)|\				; clock enable is an output
-					(dINPUT<<vFDBInt)|\					; Front Desk bus interrupt is an input
-					(dOUTPUT<<vFDesk1)|\				; FDB state bit 0 is an output
-					(dOUTPUT<<vFDesk2)|\				; FDB state bit 1 is an output
-					(dOUTPUT<<vSWInt)|\					; software interrupt is an output
-					(dOUTPUT<<vAUXIntEnb)				; switch to AUX interrupt scheme is an output
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%001<<1)|\							; CA2 ??? ind input neg active edge (keyswitch in "Secure"' sense line)		<t32>
-					(%0<<4)|\							; CB1 input neg active edge (ADB clock)					
-					(%001<<5)							; CB2 ind input neg active edge	(ADB data)			<t32>
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled									
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-
-VIA1InitQuadra900
-			dc.b	\									; vBufA initial value
-					(0<<vCpuId0)|\						; CPU Identification bit 0 is an input
-					(0<<vCpuId1)|\						; CPU Identification bit 1 is an input
-					(0<<vCpuId2)|\						; CPU Identification bit 2 is an input
-					(0<<vCpuId3)						; CPU Identification bit 3 is an input
-
-			dc.b	\									; vDIRA initial value
-					(dINPUT<<vCpuId0)|\					; CPU Identification bit 0 is an input
-					(dINPUT<<vCpuId1)|\					; CPU Identification bit 1 is an input
-					(dINPUT<<vCpuId2)|\					; CPU Identification bit 2 is an input
-					(dINPUT<<vCpuId3)					; CPU Identification bit 3 is an input
-
-			dc.b	\									; vBufB initial value
-					(1<<vEclipseLED)|\					; turn Eclipse LED on just for show					<47>
-					(1<<vXcvrsesbit)|\					; Egret interrupt (xcvr session)					<47>
-					(0<<vViafullbit)|\					; Egret VIA full									<47>
-					(0<<vSysSesbit)|\					; Egret system session								<47>
-					(1<<vSWInt)|\						; software interrupt is active-low
-					(1<<vAUXIntEnb)						; switch to AUX interrupt priority scheme is active-low
-
-			dc.b	\									; vDIRB initial value
-					(dOUTPUT<<vEclipseLED)|\			; LED is an output									<47>
-					(dINPUT<<vXcvrsesbit)|\				; xcvr session is an input							<47>
-					(dOUTPUT<<vViafullbit)|\			; VIA full is an output								<47>
-					(dOUTPUT<<vSysSesbit)|\				; system session is an output						<47>
-					(dOUTPUT<<vSWInt)|\					; software interrupt is an output
-					(dOUTPUT<<vAUXIntEnb)				; switch to AUX interrupt scheme is an output
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%001<<1)|\							; CA2 ??? ind input neg active edge (keyswitch in "Secure"' sense line)		<t32>
-					(%0<<4)|\							; CB1 input neg active edge (ADB clock)				<47>
-					(%001<<5)							; CB2 ind input neg active edge	(ADB data)			<t32>
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%111<<2)|\							; SR enabled for Egret								<47>
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-
-VIA2InitQuadra700										;													<T7>
-			dc.b	\									; vBufA initial value
-					(0<<v2EnetIRQ)|\					; on-board ethernet interrupt			
-					(0<<v2IRQ2)|\						; no Slot A
-					(0<<v2IRQ3)|\						; no slot B 
-					(0<<v2IRQ4)|\						; no slot C
-					(0<<v2IRQ5)|\						; slot D interrupt 
-					(0<<v2IRQ6)|\						; slot E interrupt
-					(0<<v2VideoIRQ)|\					; on-board video interrupt
-					(1<<v2SyncOnGreen)					; default to putting sync signal on green			<T35>
-
-			dc.b	\									; vDIRA initial value
-					(dINPUT<<v2EnetIRQ)|\				; on-board ethernet interrupt is an input			
-					(dINPUT<<v2IRQ2)|\					; no Slot A (but leave as inputs anyway)
-					(dINPUT<<v2IRQ3)|\					; no slot B 
-					(dINPUT<<v2IRQ4)|\					; no slot C
-					(dINPUT<<v2IRQ5)|\					; slot D interrupt is an input
-					(dINPUT<<v2IRQ6)|\					; slot E interrupt is an input
-					(dINPUT<<v2VideoIRQ)|\				; on-board video interrupt is an input
-					(dOutput<<v2SyncOnGreen)			; for enabling/disabling Sync-on-Green				<T35>
-
-			dc.b	\									; vBufB initial value
-					(0<<v2ConfigLE)|\					; DFAC latch enable is an output					<T17>
-					(1<<v2BusLk)|\						; Bus unlocked	(input when not in use)
-					(1<<v2PowerOff)|\					; Power Off is an input when not in use				<T17>
-					(0<<v2ConfigData)|\					; DFAC config data is an output						<T17>
-					(0<<v2ConfigClk)|\					; DFAC clock										<T17>
-					(0<<v2Speed)|\						; 25/33 Mhz input
-					(0<<v2VBL)							; 60Hz pseudo VBL output
-
-			dc.b	\									; vDIRB initial value
-					(dOUTPUT<<v2ConfigLE)|\				; DFAC latch enable is an output					<T17>
-					(dINPUT<<v2BusLk)|\					; Bus unlocked
-					(dINPUT<<v2PowerOff)|\				; Power Off is an input when not in use				<T17>
-					(dOUTPUT<<v2ConfigData)|\			; DFAC config data is an output						<T17>
-					(dOUTPUT<<v2ConfigClk)|\			; DFAC clock										<T17>
-					(dINPUT<<v2Speed)|\					; 25/33 Mhz input
-					(dOUTPUT<<v2VBL)					; 60Hz pseudo VBL output
-
-			dc.b	\									; vPCR initial value [CA2, CB2 reversed from 4Square]
-					(%0<<0)|\							; CA1 input neg active edge (Any Slot interrupt)
-					(%001<<1)|\							; CA2 ind input neg active edge	(SWIM IOP)			<t32>
-					(%0<<4)|\							; CB1 input neg active edge (ASC interrupt)
-					(%001<<5)							; CB2 ind input neg active edge	(SCSI DMA IRQ interrupt)	<t32>
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled
-					(%0<<5)|\							; T2 timed interrupt
-					(%11<<6)							; T1 continuous interrupt, square wave output
-
-VIA2InitQuadra900										;													<13>
-			dc.b	\									; vBufA initial value
-					(0<<v2EnetIRQ)|\					; on-board ethernet interrupt is an input			<47>
-					(0<<v2IRQ2)|\						; slot A interrupt is an input
-					(0<<v2IRQ3)|\						; slot B interrupt is an input
-					(0<<v2IRQ4)|\						; slot C interrupt is an input
-					(0<<v2IRQ5)|\						; slot D interrupt is an input
-					(0<<v2IRQ6)|\						; slot E interrupt is an input
-					(0<<v2VideoIRQ)|\					; on-board video interrupt is/will be an input
-					(1<<v2SyncOnGreen)					; default to putting sync signal on green			<T35>
-
-			dc.b	\									; vDIRA initial value
-					(dINPUT<<v2EnetIRQ)|\				; on-board ethernet interrupt is an input			<47>
-					(dINPUT<<v2IRQ2)|\					; slot A interrupt is an input
-					(dINPUT<<v2IRQ3)|\					; slot B interrupt is an input
-					(dINPUT<<v2IRQ4)|\					; slot C interrupt is an input
-					(dINPUT<<v2IRQ5)|\					; slot D interrupt is an input
-					(dINPUT<<v2IRQ6)|\					; slot E interrupt is an input
-					(dINPUT<<v2VideoIRQ)|\				; on-board video interrupt is an input
-					(dOutput<<v2SyncOnGreen)			; for enabling/disabling Sync-on-Green				<T35>
-
-			dc.b	\									; vBufB initial value
-					(1<<v2Keyswitch)|\					; initial value is ON (=1, 0=SECURE)				<T24><T27>
-					(1<<v2BusLk)|\						; Bus unlocked	(input when not in use)
-					(0<<v2Speed)|\						; 25/33 Mhz input
-					(0<<v2VBL)							; 60Hz pseudo VBL output
-
-			dc.b	\									; vDIRB initial value
-					(dINPUT<<v2Keyswitch)|\				; now connected as an INPUT from the keyswitch		<T24><T27><T29>
-					(dINPUT<<v2PowerOff)|\				; now connected as an INPUT from the keyswitch		<T24><T27><T29>
-					(dINPUT<<v2BusLk)|\					; Bus unlocked
-					(dOUTPUT<<v2SndInSel0)|\			; sound input select bit 0 (pb3) is an output		<t32>
-					(dINPUT<<v2Speed)|\					; 25/33 Mhz input
-					(dOUTPUT<<v2SndInSel1)|\			; sound input select bit 1 (pb6) is an output		<t32>
-					(dOUTPUT<<v2VBL)					; 60Hz pseudo VBL output
-
-			dc.b	\									; vPCR initial value [CA2, CB2 reversed from 4Square]
-					(%0<<0)|\							; CA1 input neg active edge (Any Slot interrupt)
-					(%001<<1)|\							; CA2 ind input neg active edge	(SWIM IOP)			<t32>
-					(%0<<4)|\							; CB1 input neg active edge (ASC interrupt)
-					(%001<<5)							; CB2 ind input neg active edge	(SCSI DMA IRQ interrupt)	<t32>
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled
-					(%0<<5)|\							; T2 timed interrupt
-					(%11<<6)							; T1 continuous interrupt, square wave output
-		ENDIF											; {hasOrwell}
-
-		IF hasJaws | hasNiagra THEN
-VIA1InitNiagra
-VIA1InitJaws											; <8> HJR
-			dc.b	\									; vBufA initial value								<25>
-					(1)|\								; 0 via test
-					(0<<vCpuId0)|\						; 1 CPU Identification bit 0 is an input
-					(0<<vCpuId1)|\						; 2 CPU Identification bit 1 is an input
-					(0<<vSync)|\						; Synchronous modem disabled (active high)
-					(0<<vCpuId2)|\						; 4 CPU Identification bit 2 is an input
-					(1<<vHeadSel)|\						; 5 head select line is an output
-					(0<<vCpuId3)|\						; 6 CPU Identification bit 3 is an input
-					(0<<vSCCWrReq)						; 7 SCC write/request line is an input
-
-			dc.b	\									; vDIRA initial value
-			 		(dINPUT<< 0)|\						; 0 via test
-					(dINPUT<<vCpuId0)|\					; 1 CPU Identification bit 0 is an input
-					(dINPUT<<vCpuId1)|\					; 2 CPU Identification bit 1 is an input
-					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dINPUT<<vCpuId2)|\					; 4 CPU Identification bit 2 is an input
-					(dOUTPUT<<vHeadSel)|\				; 5 head select line is an output
-					(dINPUT<<vCpuId3)|\					; 6 CPU Identification bit 3 is an input
-					(dINPUT<<vSCCWrReq)					; 7 SCC write/request line is an input
-
-
-			dc.b	\									; vBufB initial value
-					(1<<vRTCData)|\						; 0 real time clock data is one
-					(1<<vRTCClk)|\						; 1 real time clock clock is high
-					(1<<vRTCEnb)|\						; 2 clock initially disabled
-					(1<<vSndEnb)						; sound is disabled
-
-			dc.b	\									; vDIRB initial value
-					(dOUTPUT<<vRTCData)|\				; 0 real time clock data initially an output
-					(dOUTPUT<<vRTCClk)|\				; 1 real time clock clock is an output
-					(dOUTPUT<<vRTCEnb)|\				; 2 clock enable is an output
-					(dOUTPUT<<vSndEnb)					; sound enable is an output
-
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%001<<1)|\							; CA2 ind input neg active edge	(1 sec interrupt)	<t32>
-					(%0<<4)|\							; CB1 input neg active edge (PwrMgr interrupt)
-					(%001<<5)							; CB2 ind input neg active edge	(modem snd enable)	<t32>
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-
-VIA2InitNiagra
-VIA2InitJaws											;	<8> HJR
-			dc.b	$00									; vBufA initial value (all zeros)
-			dc.b	$00									; vDIRA initial value (all inputs)
-
-			dc.b	\									; vBufB initial value
-					(0<<v2ConfigLE)|\					; DFAC latch enable is an output					<25>
-					(1<<v2PMack)|\						; 1 Power mgr handshake acknowledge is an input
-					(1<<v2PMreq)|\						; 2 Power mgr handshake not requesting
-					(0<<v2ConfigData)|\					; 3 DFAC config data is an output					<25>
-					(0<<v2ConfigClk)|\					; 4 DFAC clock										<25>
-					(1<<v2HMMU)|\						; 5 HMMU											<25>
-					(1<<v2CDis2)|\						; 6 CDIS cache enabled								<25>
-					(1<< v2ModemRST )					; 7 modem reset										<25>
-
-			dc.b	\									; vDIRB initial value
-					(dOUTPUT<<v2ConfigLE)|\				; DFAC latch enable is an output					<25>
-					(dINPUT<<v2PMack)|\					; 1 Power mgr handshake acknowledge is an input
-					(dOUTPUT<<v2PMreq)|\				; 2 Power mgr handshake request is an output
-					(dOUTPUT<<v2ConfigData)|\			; 3 DFAC config data is an output					<25>
-					(dOUTPUT<<v2ConfigClk)|\			; 4 DFAC clock										<25>
-					(dOUTPUT<< v2HMMU )|\				; 5 HMMU											<25>
-					(dINPUT<<v2CDis2)|\					; 6 CDIS											<25>
-					(dOUTPUT<<v2ModemRST )				; 7 modem reset										<25>
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (Any Slot interrupt)
-					(%001<<1)|\							; CA2 ind input neg active edge	(SCSI DRQ interrupt)<t32>
-					(%0<<4)|\							; CB1 input neg active edge (ASC interrupt)
-					(%001<<5)							; CB2 ind input neg active edge	(SCSI IRQ interrupt)<t32>
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-		ENDIF											; {hasJaws | hasNiagra}
-
-		IF hasMSC THEN
-VIA1InitMSC												; via1 initialization
-			dc.b	0									; vBufA initial value (all bits are inputs)
-
-			dc.b	0									; vDIRA initial value (all bits are inputs)
-
-			dc.b	0									; vBufB initial value (all bits are inputs)
-
-			dc.b	0									; vDIRB initial value (all bits are inputs)
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%001<<1)|\							; CA2 (PG&E interrupt)
-					(%0<<4)|\							; CB1 (no connection)
-					(%000<<5)							; CB2 (no connection)
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%111<<2)|\							; SR shifts out with CB1 (external clock) -> PMGR
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-		ENDIF											; {hasMSC}
-
-		IF hasPratt THEN
-VIA1InitPratt
-			dc.b	\									; vBufA initial value								<SM39>
-					(0<<vSync)|\			; Synchronous modem disabled
-					(1<<vHeadSel)|\			; SCC write/request line is an input
-					(0<<vSCCWrReq)						; 7 SCC write/request line is an input
-
-			dc.b	\									; vDIRA initial value
-					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dOUTPUT<<vHeadSel)|\	; head select line is an output
-					(dINPUT<<vSCCWrReq)					; 7 SCC write/request line is an input
-
-
-			dc.b	\									; vBufB initial value
-					(1<<vENetIDClk)|\					; 0 Ethernet ID ROM clock is high
-					(1<<vSndEnb)						; sound is disabled
-
-			dc.b	\									; vDIRB initial value
-					(dOUTPUT<<vENetIDClk)|\				; 0 EthernetID ROM clock is an output
-					(dINPUT<<vENetIDData)|\				; 1 EthernetID ROM data is an input
-					(dINPUT<<vSDMCable)|\				; 3 SCSI Disk Mode sense is an input
-					(dINPUT<<vSDMDiskID)|\				; 4-6 SCSI Disk Mode ID bit are input
-					(dOUTPUT<<vSndEnb)					; sound enable is an output
-
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%001<<1)|\							; CA2 ind input neg active edge	(1 sec interrupt)	
-					(%0<<4)|\							; CB1 input neg active edge (PwrMgr interrupt)
-					(%001<<5)							; CB2 ind input neg active edge	(modem snd enable)	
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\				; PA latch disable
-					(%0<<1)|\				; PB latch disable
-					(%111<<2)|\				; SR shifts out with CB1 (external clock) -> PMGR
-					(%0<<5)|\				; T2 timed interrupt
-					(%00<<6)				; T1 timed interrupt, PB7 disabled
-		
-VIA2InitPratt
-			dc.b	\						; vBufA initial value
-					(0<<v2EnetIRQ)|\		; on-board ethernet interrupt			
-					(0<<v2IRQ2)|\			; no Slot A
-					(0<<v2IRQ3)|\			; no slot B 
-					(0<<v2IRQ4)|\			; no Slot C
-					(0<<v2IRQ5)|\			; no Slot D 
-					(0<<v2IRQ6)|\			; slot E interrupt
-					(0<<v2VideoIRQ)			; on-board video interrupt
-
-			dc.b	\						; vDIRA initial value
-					(%00000000)|\			; hard-coded (@reset) values in the chip
-					(dINPUT<<v2EnetIRQ)|\	; on-board ethernet interrupt is an input			
-					(dINPUT<<v2IRQ6)|\		; slot E interrupt is an input
-					(dINPUT<<v2VideoIRQ)	; on-board video interrupt is an input
-
-;	the only changeable bits are BusLock (1), FC3 (3) and PowerSaver (4)
-;	(the rest are hard-coded in the chip.  
-			dc.b	\						; vBufB initial value
-					(1<<v2PMack)|\			; slot E interrupt
-					(1<<v2PMreq)			; on-board video interrupt
-
-			dc.b	\						; vDIRB initial value
-					(%00000000)				; hard-coded in the chip
-
-;	the only active/changeable bit in PCR is bit 6.
-			dc.b	\						; vPCR initial value
-					(%00000000)
-
-;	there are no changeable bits in the ACR
-			dc.b	\						; vACR initial value
-					(%00000000)				; hard-coded values in the chip
-
-		ENDIF											; {hasPratt}
-
-
-		IF hasSonora THEN
-VIA1InitVail
-			dc.b	\									; vBufA initial value								<9>
-					(0<<vSync)|\						; Synchronous modem disabled (active high)
-					(1<<vHeadSel)						; SCC write/request line is an input
-
-			dc.b	\									; vDIRA initial value
-					(dINPUT<<vTestJ)|\					; Factory Burn-in is an input						<H7>
-					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dOUTPUT<<vHeadSel)|\				; head select line is an output
-					(dINPUT<<vSCCWrReq)					; SCC write/request line is an input
-
-			dc.b	\									; vBufB initial value
-					(1<<vXcvrsesbit)|\					; Egret interrupt (xcvr session)
-					(0<<vViafullbit)|\					; Egret via full
-					(0<<vSysSesbit)|\					; Egret system session
-					(1<<vSndEnb)						; sound is disabled									<H7>
-
-			dc.b	\									; vDIRB initial value
-					(dINPUT<<vXcvrsesbit)|\				; xcvr session is an input
-					(dOUTPUT<<vViafullbit)|\			; viafull is an output
-					(dOUTPUT<<vSysSesbit)|\				; system session is an output
-					(dOUTPUT<<vSndEnb)					; sound reset is an output
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%000<<1)|\							; CA2 (no connection)
-					(%0<<4)|\							; CB1 input neg active edge (Egret clock)
-					(%001<<5)							; CB2 input neg active edge	(Egret data)
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%111<<2)|\							; SR enabled for Egret
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-		ENDIF											; {hasSonora}
-
-
-		IF hasDJMEMC THEN
-VIA1InitWombat
-			dc.b	\									; vBufA initial value
-					(0<<vCpuId0)|\						; CPU Identification bit 0 is an input
-					(0<<vCpuId1)|\						; CPU Identification bit 1 is an input
-					(0<<vSync)|\						; Synchronous modem disabled (active high)
-					(0<<vCpuId2)|\						; CPU Identification bit 2 is an input
-					(1<<vHeadSel)|\						; head select line is an output
-					(0<<vCpuId3)|\						; CPU Identification bit 3 is an input				<SM29>
-					(0<<vSCCWrReq)						; SCC write/request line is an input
-
-			dc.b	\									; vDIRA initial value
-					(dINPUT<<vCpuId0)|\					; CPU Identification bit 0 is an input
-					(dINPUT<<vCpuId1)|\					; CPU Identification bit 1 is an input
-					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dINPUT<<vCpuId2)|\					; CPU Identification bit 2 is an input
-					(dOUTPUT<<vHeadSel)|\				; head select line is an output
-					(dINPUT<<vCpuId3)|\					; CPU Identification bit 3 is an input				<H48><SM29>
-					(dINPUT<<vSCCWrReq)					; SCC write/request line is an input
-
-			dc.b	\									; vBufB initial value
-			 		(1<<vRTCData)|\						; real time clock data is one
-					(1<<vRTCClk)|\						; real time clock clock is high
-					(1<<vRTCEnb)|\						; clock initially disabled
-					(0<<vFDBInt)|\						; Front Desk bus interrupt is an input
-					(1<<vFDesk1)|\						; FDB state bit 0 is initially state 3
-					(1<<vFDesk2)|\						; FDB state bit 1 is initially state 3
-					(1<<vAUXIntEnb)|\					; switch to AUX interrupt priority scheme is active-low
-					(1<<vSWInt)							; software interrupt is active-low
-
-			dc.b	\									; vDIRB initial value
-			 		(dOUTPUT<<vRTCData)|\				; real time clock data initially an output
-					(dOUTPUT<<vRTCClk)|\				; real time clock clock is an output
-					(dOUTPUT<<vRTCEnb)|\				; clock enable is an output
-					(dINPUT<<vFDBInt)|\					; Front Desk bus interrupt is an input
-					(dOUTPUT<<vFDesk1)|\				; FDB state bit 0 is an output
-					(dOUTPUT<<vFDesk2)|\				; FDB state bit 1 is an output
-					(dOUTPUT<<vSWInt)|\					; software interrupt is an output
-					(dOUTPUT<<vAUXIntEnb)				; switch to AUX interrupt scheme is an output
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%001<<1)|\							; CA2 ??? ind input neg active edge (keyswitch in "Secure"' sense line)		<t32>
-					(%0<<4)|\							; CB1 input neg active edge (ADB clock)					
-					(%001<<5)							; CB2 ind input neg active edge	(ADB data)			<t32>
-
-;	This is here because the Proto1&2 VIA cell in BIOS does not correctly
-;	deal with writes to Port{A,B} before the direction bits for the that
-;	port are set correctly (output enables, that is).
-;			IF forWombat THEN
-;			dc.b	\									; vACR initial value
-;					(%0<<0)|\							; PA latch disable
-;					(%0<<1)|\							; PB latch disable
-;					(%111<<2)|\							; SR disabled									
-;					(%0<<5)|\							; T2 timed interrupt
-;					(%00<<6)							; T1 timed interrupt, PB7 disabled
-;			ELSE
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled									
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-;			ENDIF
-
-VIA2InitWombat
-			dc.b	\									; vBufA initial value
-					(0<<v2EnetIRQ)|\					; on-board ethernet interrupt			
-					(0<<v2IRQ2)|\						; no Slot A
-					(0<<v2IRQ3)|\						; no slot B 
-					(0<<v2IRQ4)|\						; slot C interrupt
-					(0<<v2IRQ5)|\						; slot D interrupt 
-					(0<<v2IRQ6)|\						; slot E interrupt
-					(0<<v2VideoIRQ)						; on-board video interrupt
-
-			dc.b	\									; vDIRA initial value
-					(dINPUT<<v2EnetIRQ)|\				; on-board ethernet interrupt is an input			
-					(dINPUT<<v2IRQ2)|\					; no Slot A (but leave as inputs anyway)
-					(dINPUT<<v2IRQ3)|\					; no slot B 
-					(dINPUT<<v2IRQ4)|\					; slot C interrupt is an input
-					(dINPUT<<v2IRQ5)|\					; slot D interrupt is an input
-					(dINPUT<<v2IRQ6)|\					; slot E interrupt is an input
-					(dINPUT<<v2VideoIRQ)				; on-board video interrupt is an input
-
-			dc.b	\									; vBufB initial value
-					(0<<v2ConfigLE)|\					; DFAC latch enable is an output
-					(1<<v2BusLk)|\						; Bus unlocked	(input when not in use)
-					(1<<v2PowerOff)|\					; Power Off is an input when not in use
-					(0<<v2ConfigData)|\					; DFAC config data is an output
-					(0<<v2ConfigClk)|\					; DFAC clock
-					(0<<v2MicCtl)|\						; microphone control input
-					(0<<v2VBL)							; 60Hz pseudo VBL output
-
-			dc.b	\									; vDIRB initial value
-					(dOUTPUT<<v2ConfigLE)|\				; DFAC latch enable is an output
-					(dINPUT<<v2BusLk)|\					; Bus unlocked
-					(dINPUT<<v2PowerOff)|\				; Power Off is an input when not in use
-					(dOUTPUT<<v2ConfigData)|\			; DFAC config data is an output
-					(dOUTPUT<<v2ConfigClk)|\			; DFAC clock
-					(dINPUT<<v2MicCtl)|\				; microphone control
-					(dOUTPUT<<v2VBL)					; 60Hz pseudo VBL output
-
-			dc.b	\									; vPCR initial value [CA2, CB2 same as Q700/Q900]
-					(%0<<0)|\							; CA1 input neg active edge (Any Slot interrupt)
-					(%001<<1)|\							; CA2 ind input pos active level (SCSI DRQ)
-					(%0<<4)|\							; CB1 input neg active edge (ASC interrupt)
-					(%001<<5)							; CB2 ind input neg active edge	(SCSI IRQ interrupt)
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled
-					(%0<<5)|\							; T2 timed interrupt
-					(%11<<6)							; T1 continuous interrupt, square wave output		<H41>
-		ENDIF											; {hasDJMEMC}
-
-
-		IF hasYMCA THEN									;													<SM46>
-		
-;	Initialize the VIA1 Direction Register before the Data Register
-
-VIA1InitCyclone
-
-; PSC VIA1 vDirA/vBufA Notes:
-;
-; Because ReqA and ReqB are really used for DMA, they are not wire-ORed to the vSCCWrReq bit
-; as on most Macintoshes. This bit instead reads the logical OR of ReqA and ReqB, either of
-; which can be masked. This allows WReqA to be used in the traditional sense even while WReqB
-; is indicating DMA activity.
-;
-; NOTE:	PSC revisions earlier than 343S1100-a do not support masking!
-;		For these revisions, vSCCWrReq should be reprogrammed as an ouput and latched with
-;		a "1" so that polling does not occur on port A due to DMA activity on port B.
-
-			dc.b	\									; vDIRA initial value								<P9>
-					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dOUTPUT<<vReqBEnable)|\			; enable for ReqB term of SCCWReq function			<LW5>
-					(dOUTPUT<<vReqAEnable)|\			; enable for ReqA term of SCCWReq function			<LW5>
-					(dINPUT<<vSCCWrReq)					; SCC wait/request line is an input					<LW5>
-
-			dc.b	\									; vBufA initial value								<P9>							<P3>
-					(0<<vSync)|\						; disable external SCC BRG clock
-					(0<<vReqBEnable)|\					; disable ReqB term of SCCWReq function				<LW5>
-					(1<<vReqAEnable)					; enable ReqA term of SCCWReq function				<LW5>
-
-			dc.b	\									; vDIRB initial value								<P9>
-					(dOUTPUT<<vRMP0)|\					; Wink is an output.
-					(dOUTPUT<<vRMP1)|\					; Wink is an output.
-					(dOUTPUT<<vRMP2)|\					; Wink is an output.
-					(dINPUT<<vCudaTREQ)|\				; Cuda transaction request is an input.
-					(dOUTPUT<<vCudaBYTEACK)|\			; Cuda byte acknowledge is an output.
-					(dOUTPUT<<vCudaTIP)|\				; Cuda interface transaction in progress is an output
-					(dOUTPUT<<vJMPDude6)|\				; Hmmm is an output.
-					(dOUTPUT<<vJMPDude7)				; Hmmm is an output.
-
-			dc.b	\									; vBufB initial value								<P9>
-					(0<<vRMP0)|\						; Reserved for RMP.
-					(0<<vRMP1)|\						; Reserved for RMP.
-					(0<<vRMP2)|\						; Reserved for RMP.
-					(1<<vCudaTREQ)|\					; Cuda transaction request
-					(1<<vCudaBYTEACK)|\					; Cuda byte acknowledge								<P6>
-					(1<<vCudaTIP)|\						; Cuda interface transaction in progress			<P6>
-					(0<<vJMPDude6)|\					; Reserved for JMP.
-					(0<<vJMPDude7)						; Reserved for JMP.
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%000<<1)|\							; CA2 (no connection)
-					(%0<<4)|\							; CB1 input neg active edge (Cuda clock)
-					(%000<<5)							; CB2 input neg active edge	(Cuda data)
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%111<<2)|\							; SR enabled for Cuda
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-
-VIA2InitCyclone											;													<T7>
-			dc.b	\									; vBufA initial value
-					(0<<v2IRQ2)|\						; no Slot A
-					(0<<v2IRQ3)|\						; no slot B 
-					(0<<v2IRQ4)|\						; slot C interrupt 
-					(0<<v2IRQ5)|\						; slot D interrupt 
-					(0<<v2IRQ6)|\						; slot E interrupt
-					(0<<v2VideoIRQ)						; built-in video interrupt
-
-			dc.b	0									; align to word boundary
-		ENDIF											; {hasYMCA}											<SM46>
-		
-		
-		IF hasHMC THEN									;													<SM46>			
-VIA1InitPDM												;													<SM21>
-			dc.b	\									; vBufA initial value
-					(0<<vSync)|\						; Synchronous modem disabled (active high)
-					(1<<vHeadSel)|\						; set head select line high
-					(0<<vSCCWrReq)						; set SCC write/request line low
-
-			dc.b	\									; vDIRA initial value
-					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dOUTPUT<<vHeadSel)|\				; head select line is an output
-					(dINPUT<<vSCCWrReq)					; SCC write/request line is an input
-
-			dc.b	\									; vBufB initial value
-					(1<<vCudaTREQ)|\					; Cuda transaction request
-					(1<<vCudaBYTEACK)|\					; Cuda byte acknowledge								<P6>
-					(1<<vCudaTIP)|\						; Cuda interface transaction in progress			<P6>
-					(1<<vSndEnb)						; sound is disabled									<H7>
-
-			dc.b	\									; vDIRB initial value
-					(dINPUT<<vCudaTREQ)|\				; Cuda transaction request is an input.
-					(dOUTPUT<<vCudaBYTEACK)|\			; Cuda byte acknowledge is an output.
-					(dOUTPUT<<vCudaTIP)|\				; Cuda interface transaction in progress is an output
-					(dOUTPUT<<vSndEnb)					; sound reset is an output
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%000<<1)|\							; CA2 (no connection)
-					(%0<<4)|\							; CB1 input neg active edge (Cuda clock)
-					(%000<<5)							; CB2 input neg active edge	(Cuda data)
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%111<<2)|\							; SR enabled for Egret
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-		ENDIF											; {hasHMC}											<SM46>
-
-		IF hasGrandCentral THEN									;													<SM46>			
-VIA1InitTNT												;													<SM21>
-			dc.b	\									; vBufA initial value
-					(0<<vSync)|\						; Synchronous modem disabled (active high)
-					(0<<vReqBEnable)|\					; disable ReqB term of SCCWReq function				<LW5>
-					(1<<vReqAEnable)					; enable ReqA term of SCCWReq function				<LW5>
-
-			dc.b	\									; vDIRA initial value
-					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dOUTPUT<<vReqBEnable)|\			; enable for ReqB term of SCCWReq function			<LW5>
-					(dOUTPUT<<vReqAEnable)|\			; enable for ReqA term of SCCWReq function			<LW5>
-					(dINPUT<<vSCCWrReq)					; SCC write/request line is an input
-
-			dc.b	\									; vBufB initial value
-					(1<<vCudaTREQ)|\					; Cuda transaction request
-					(1<<vCudaBYTEACK)|\					; Cuda byte acknowledge								<P6>
-					(1<<vCudaTIP)						; Cuda interface transaction in progress			<P6>
-
-			dc.b	\									; vDIRB initial value
-					(dINPUT<<vCudaTREQ)|\				; Cuda transaction request is an input.
-					(dOUTPUT<<vCudaBYTEACK)|\			; Cuda byte acknowledge is an output.
-					(dOUTPUT<<vCudaTIP)					; Cuda interface transaction in progress is an output
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%000<<1)|\							; CA2 (no connection)
-					(%0<<4)|\							; CB1 input neg active edge (Cuda clock)
-					(%000<<5)							; CB2 input neg active edge	(Cuda data)
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%111<<2)|\							; SR enabled for Egret
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-		ENDIF											; {hasGrandCentral}											<SM46>
-
-
-		IF hasMDU THEN									;													<SM46>
-			
-			IMPORT	SndCntlMacIIsi      ;	
-			ALIGN	4
-InfoMacIIsi
-			dc.l	MDUTable-InfoMacIIsi				; offset to decoder info		
-			dc.l	RAMInfo2Bank1Meg-InfoMacIIsi		; offset to ram bank info
-			dc.l	VideoInfoMacIIsi-InfoMacIIsi		; offset to video info
-			dc.l	NuBusInfoMacIIsi-InfoMacIIsi		; offset to NuBus info			
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxMacIIsi							; product kind 										<49>							
-			dc.b	MDUDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	4									; default ROM Resource configuration		
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr is valid
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockEgret)|\						;	Has Egret clock/pram
-					(ADBEgret)|\						;	Egret ADB
-					(Egret8)|\							;	Egret Eight firmware							<SM4><P1>
-					(SoundHasSoundIn)|\					;	Has 8-bit mono sound input						<23><LW7>
-					(SoundStereoOut)|\					;	has stereo output								<H13>
-					(SoundPlayAndRecord)|\				;	can Play and Record simultaneously				<H24>
-					(SoundStereoMixing)					;	has stereo mixing								<H13>
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$16,$00,$00,$00						; VIA1 PA6 = 0, PA4 = 1, PA2 = 1, PA1 = 1
-			dc.l	VIA1InitMacIIsi-InfoMacIIsi			; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	SndCntlMacIIsi-InfoMacIIsi			; sound control vector table  <SM53> PN
-			dc.l	EgretClockPRAM-InfoMacIIsi			; clock/PRAM vector table							<H4>
-			dc.l	EgretADBTable-InfoMacIIsi			; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.l	RBVEgretIntTbl-InfoMacIIsi			; interrupt handlers table     <SM53> PN
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare
-			dc.l	IconInfoMacIIsi-InfoMacIIsi			; offset to ICON info								<SM74>		
-			
-			
-			
-			ALIGN	4
-			IMPORT	CheckForMDU
-
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					VIA2Exists,\						; VIA2Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr is valid
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features  0-31
-					(ClockRTC)|\		 				;	Has RTC clock/pram
-					(ADBXcvr)							;	transceiver ADB
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$00,$00,$00						; no special VIA bits to avoid changing
-			dc.l	CheckForMDU-MDUtable				; routine to identify this map
-			dc.b	MDUDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$FFFFFFFF							; No Base Address for this decoder
-MDUtable	
-			dc.l	$40800000							; ROM - valid
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$50F04000							; SCC read - optional
-			dc.l	$50F04000							; SCC write - optional
-			dc.l	$50F16000							; IWM - optional
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$50F10000							; SCSI - optional
-			dc.l	$50F12000							; SCSIDack - optional
-			dc.l	$50F06000							; SCSIHsk - optional
-			dc.l	$50F02000							; VIA2 - optional
-			dc.l	$50F14000							; ASC - valid
-			dc.l	$50F26000							; RBV - optional
-			dc.l	$50F24000							; VDAC - optional
-			dc.l	$50F18000							; SCSIDMA - optional
-			dc.l	$50F1E020							; SWIMIOP - optional
-			dc.l	$50F0C020							; SCCIOP - optional
-			dc.l	$00000000							; OSS - unused
-			dc.l	$00000000							; FMC - unused
-			dc.l	$00000000							; RPU - unused
-			dc.l	$00000000							; unused 21											<SM10>
-			dc.l	$00000000							; JAWS - unused										<25>
-			dc.l	$00000000							; Sonic - unused									<45>
-			dc.l	$00000000							; 1st (internal) SCSI96 - unused
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; DAFB - unused	
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; unused 29
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-
-VideoInfoMDU
-			dc.l	0									; Physical base address of screen
-			dc.l	$FBB08000							; Logical 32 bit base address of screen
-			dc.l	$FBB08000							; Logical 24 bit base address of screen
-			dc.b	$0B									; Slot number to use for PRAM storage
-			dc.b	SmPRAMTop+(($0B-$09)*sizeSPRAMRec)	; PRAM address for RBV slot zero
-			dc.b	sRsrcBFBasedDir						; Use the BoxFlag-based sRsrc directory directory.	<H22>
-			dc.b	0									; Use boxFlag to identify board sRsrc.				<H11>	
-
-VideoInfoMacIIsi										;													<33>
-			dc.l	0									; Physical base address of screen					<33>
-			dc.l	$FEE08000							; Logical 32 bit base address of screen				<33>
-			dc.l	$FEE08000							; Logical 24 bit base address of screen				<40>
-			dc.b	$0E									; Slot number to use for PRAM storage				<33>
-			dc.b	SmPRAMTop+(($0E-$09)*\				; PRAM address for RBV slot zero					<33>	
-					sizeSPRAMRec)
-			dc.b	sRsrcBFBasedDir						; Use the BoxFlag-based sRsrc directory directory.	<H22>
-			dc.b	0									; Use boxFlag to identify board sRsrc.				<H11>	
-			
-NuBusInfoMacIIsi										; slot info for Macintosh IIsi 						<24>
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|\									; slot 9
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<directSlot)
-			dc.b	0|\									; slot A
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<directSlot)
-			dc.b	0|\									; slot B
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<directSlot)
-			dc.b	0|(1<<hasPRAM)						; slot C
-			dc.b	0|(1<<hasPRAM)						; slot D
-			dc.b	0|(1<<slotDisabled)					; slot E
-			dc.b	0									; slot F
-
-VIA1InitMDU
-			dc.b	\									; vBufA initial value
-					(1)|\								; sound volume level initially 1
-					(0<<vSync)|\						; Synchronous modem disabled (active high)
-					(0<<vCpuId2)|\						; CPU Identification bit 2 is an input
-					(1<<vHeadSel)|\						; head select line is an output
-					(0<<vCpuId3)|\						; CPU Identification bit 3 is an input
-					(0<<vSCCWrReq)						; SCC write/request line is an input
-
-			dc.b	\									; vDIRA initial value
-			 		(vSound)|\							; sound volume bits are outputs
-					(dOUTPUT<<vSync)|\					; Synchronous modem is an output
-					(dINPUT<<vCpuId2)|\					; CPU Identification bit 2 is an input
-					(dOUTPUT<<vHeadSel)|\				; head select line is an output
-					(dINPUT<<vCpuId3)|\					; CPU Identification bit 3 is an input
-					(dINPUT<<vSCCWrReq)					; SCC write/request line is an input
-
-			dc.b	\									; vBufB initial value
-			 		(1<<vRTCData)|\						; real time clock data is one
-					(1<<vRTCClk)|\						; real time clock clock is high
-					(1<<vRTCEnb)|\						; clock initially disabled
-					(0<<vFDBInt)|\						; Front Desk bus interrupt is an input
-					(1<<vFDesk1)|\						; FDB state bit 0 is initially state 3
-					(1<<vFDesk2)|\						; FDB state bit 1 is initially state 3
-					(1<<vPGCEnb)|\						; Parity Checking is initially disabled
-					(1<<vSndEnb)						; sound is disabled
-
-			dc.b	\									; vDIRB initial value
-			 		(dOUTPUT<<vRTCData)|\				; real time clock data initially an output
-					(dOUTPUT<<vRTCClk)|\				; real time clock clock is an output
-					(dOUTPUT<<vRTCEnb)|\				; clock enable is an output
-					(dINPUT<<vFDBInt)|\					; Front Desk bus interrupt is an input
-					(dOUTPUT<<vFDesk1)|\				; FDB state bit 0 is an output
-					(dOUTPUT<<vFDesk2)|\				; FDB state bit 1 is an output
-					(dOUTPUT<<vPGCEnb)|\				; PGC enable is an output
-					(dOUTPUT<<vSndEnb)					; sound enable is an output
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (60Hz interrupt)
-					(%000<<1)|\							; CA2 input neg active edge	(1 sec interrupt)
-					(%0<<4)|\							; CB1 input neg active edge (ADB clock)
-					(%000<<5)							; CB2 input neg active edge	(ADB data)
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-
-
-		ENDIF											;													<SM46>
-		
-		
-
-	IF 0 THEN								;																<SM33>
-;••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
-;•																												•
-;•		This is the old CPU graveyard.  All of the universal tables for the old CPUs will be put here until		•
-;•		it's decided that they'll never be used again, at which point, they can be removed entirely.			•
-;•																												•
-;••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••••
-
-ProductLookup
-		IF hasMDU THEN
-			dc.l	InfoMacIIci-*						; Macintosh IIci
-			dc.l	InfoMacIIciPGC-*					; Macintosh IIci, PGC installed
-		ENDIF
-		IF hasOSS THEN
-			dc.l	InfoMacIIfx-*						; Macintosh IIfx
-		ENDIF
-		IF hasMDU THEN
-			dc.l	InfoMDUUnknown-*					; unknown MDU based machine
-		ENDIF
-		IF hasOss THEN
-			dc.l	InfoOSSUnknown-*					; unknown OSS based machine
-		ENDIF
-			DC.L	0
-
-
-DecoderLookup
-		IF hasOSS THEN
-			dc.l	OSSFMCtable-*						; check for OSS/FMC decoder
-		ENDIF
-			DC.L	0
-
-
-		IF hasMDU THEN
-
-			ALIGN	4
-InfoMacIIci	dc.l	MDUTable-InfoMacIIci				; offset to decoder info
-			dc.l	RAMInfo2Bank1Meg-InfoMacIIci		; offset to ram bank info
-			dc.l	VideoInfoMDU-InfoMacIIci			; offset to video info
-			dc.l	NuBusInfoMacIIci-InfoMacIIci		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxMacIIci							; product kind (same boxFlag, with or without PGC)
-			dc.b	MDUDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	1									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr is valid
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(0<<PGCInstalled)|\					;	the optional PGC chip is NOT installed
-					(ClockRTC)|\		 				;	Has RTC clock/pram
-					(ADBXcvr)							;	transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$46,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 0, PA2 = 1, PA1 = 1
-			dc.l	VIA1InitMDU-InfoMacIIci				; VIA1 init info
-			dc.l	0									; no VIA2 to init
-			dc.l	0									; no sound control vector table
-			dc.l	RTCClockPRAM-InfoMacIIci			; clock/PRAM vector table							<H4>
-			dc.l	ViaADBTable-InfoMacIIci				; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.w	0									; no CPU ID register
-			dc.w	0									; allow room for expansion
-			dc.l	IconInfo3Slot-InfoMacIIci			; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoMacIIciPGC
-			dc.l	MDUTable-InfoMacIIciPGC				; offset to decoder info
-			dc.l	RAMInfo2Bank1Meg-InfoMacIIciPGC		; offset to ram bank info
-			dc.l	VideoInfoMDU-InfoMacIIciPGC			; offset to video info
-			dc.l	NuBusInfoMacIIci-InfoMacIIciPGC		; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxMacIIci							; product kind (same boxFlag, with or without PGC)
-			dc.b	MDUDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	1									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr is valid
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(1<<PGCInstalled)|\					;	the optional PGC chip is installed
-					(ClockRTC)|\		 				;	Has RTC clock/pram
-					(ADBXcvr)							;	transceiver ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$56,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 1, PA2 = 1, PA1 = 1
-			dc.l	VIA1InitMDU-InfoMacIIciPGC			; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	0									; no sound control vector table
-			dc.l	RTCClockPRAM-InfoMacIIciPGC			; clock/PRAM vector table							<H4>
-			dc.l	ViaADBTable-InfoMacIIciPGC			; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare
-			dc.l	IconInfo3Slot-InfoMacIIciPGC		; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoMDUUnknown
-			dc.l	MDUTable-InfoMDUUnknown				; offset to decoder info
-			dc.l	RAMInfo2Bank1Meg-InfoMDUUnknown		; offset to ram bank info
-			dc.l	VideoInfoMDU-InfoMDUUnknown			; offset to video info
-			dc.l	NuBusInfoSixSlotNoVid-InfoMDUUnknown; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxUnknown							; product kind
-			dc.b	MDUDecoder							; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	1									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32									; use default bases for this decoder
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	0									; use default external features for this decoder
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00,$00,$00,$00						; anything with this decoder matches
-			dc.l	VIA1InitMDU-InfoMDUUnknown			; VIA1 init info
-			dc.l	VIA2InitMDUUnknown-InfoMDUUnknown	; VIA2 init info
-			dc.l	0									; no sound control vector table
-			dc.l	RTCClockPRAM-InfoMDUUnknown			; clock/PRAM vector table							<H4>
-			dc.l	ViaADBTable-InfoMDUUnknown			; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare
-			dc.l	IconInfo3Slot-InfoMDUUnknown		; offset to ICON info								<SM74>		
-
-
-
-NuBusInfoMacIIci
-			dc.b	0|(1<<hasPRAM)|(1<<canInterrupt)	; slot 0
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|(1<<hasPRAM)						; slot 9
-			dc.b	0|(1<<hasPRAM)						; slot A
-			dc.b	0|(1<<slotDisabled)					; slot B
-			dc.b	0|\									; slot C
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot D
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot E
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0									; slot F
-
-
-VIA2InitMDUUnknown
-			dc.b	\									; vBufA initial value
-					(0<<v2IRQ1)|\						; slot 1 interrupt is an input
-					(0<<v2IRQ2)|\						; slot 2 interrupt is an input
-					(0<<v2IRQ3)|\						; slot 3 interrupt is an input
-					(0<<v2IRQ4)|\						; slot 4 interrupt is an input
-					(0<<v2IRQ5)|\						; slot 5 interrupt is an input
-					(0<<v2IRQ6)|\						; slot 6 interrupt is an input
-					(0<<v2RAM0)|\						; or ram size bit 0 with 0
-					(0<<v2RAM1)							; or ram size bit 1 with 0
-
-			dc.b	\									; vDIRA initial value
-					(dINPUT<<v2IRQ1)|\					; slot 1 interrupt is an input
-					(dINPUT<<v2IRQ2)|\					; slot 2 interrupt is an input
-					(dINPUT<<v2IRQ3)|\					; slot 3 interrupt is an input
-					(dINPUT<<v2IRQ4)|\					; slot 4 interrupt is an input
-					(dINPUT<<v2IRQ5)|\					; slot 5 interrupt is an input
-					(dINPUT<<v2IRQ6)|\					; slot 6 interrupt is an input
-					(dOUTPUT<<v2RAM0)|\					; ram size bit 0 is an output
-					(dOUTPUT<<v2RAM1)					; ram size bit 1 is an output
-
-			dc.b	\									; vBufB initial value
-					(1<<v2CDis)|\						; cache disabled
-					(1<<v2BusLk)|\						; Bus unlocked	(input when not in use)
-					(1<<v2PowerOff)|\					; Power on	(input when not in use)
-					(1<<vFC3)|\							; don't flush cache
-					(0<<v2TM1A)|\						; NuBus timeout bits are inputs
-					(0<<v2TM0A)|\						; NuBus timeout bits are inputs
-					(0<<v2SndExt)|\						; sound/speaker mode is an input
-					(0<<v2VBL)							; 60Hz pseudo VBL output
-
-			dc.b	\									; vDIRB initial value
-					(dOUTPUT<<v2CDis)|\					; cache disabled
-					(dINPUT<<v2BusLk)|\					; Bus unlocked
-					(dINPUT<<v2PowerOff)|\				; Power on
-					(dOUTPUT<<vFC3)|\					; don't flush cache
-					(dINPUT<<v2TM1A)|\					; NuBus timeout bits are inputs
-					(dINPUT<<v2TM0A)|\					; NuBus timeout bits are inputs
-					(dINPUT<<v2SndExt)|\				; sound/speaker mode is an input
-					(dOUTPUT<<v2VBL)					; 60Hz pseudo VBL output
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (Any Slot interrupt)
-					(%000<<1)|\							; CA2 input neg active edge	(SCSI DMA IRQ interrupt)
-					(%0<<4)|\							; CB1 input neg active edge (ASC interrupt)
-					(%000<<5)							; CB2 input neg active edge	(SWIM IOP)
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled
-					(%0<<5)|\							; T2 timed interrupt
-					(%11<<6)							; T1 continuous interrupt, square wave output
-
-		ENDIF											; {hasMDU}
-
-		IF hasOSS THEN
-
-			ALIGN	4
-InfoMacIIfx
-			dc.l	OSSFMCTable-InfoMacIIfx				; offset to decoder info
-			dc.l	RAMInfo2Bank1Meg-InfoMacIIfx		; offset to ram bank info
-			dc.l	0									; no built in video
-			dc.l	NuBusInfoSixSlotNoVid-InfoMacIIfx	; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	boxMacIIfx							; product kind
-			dc.b	OSSFMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32	\								; Flags for valid base addresses 0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					SCCRdExists,\						; SCCRdAddr is valid
-					SCCWrExists,\						; SCCWrAddr is valid
-					IWMExists,\							; IWMAddr is valid
-					SCSIExists,\						; SCSIAddr is valid
-					SCSIDackExists,\					; SCSIDackAddr is valid
-					SCSIHskExists,\						; SCSIHskAddr is valid
-					ASCExists,\							; ASCAddr is valid
-					RBVExists,\							; RBVAddr is valid
-					VDACExists							; VDACAddr is valid
-			BitVector32									; Use default base addrs for this machine
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	\									; Flags for valid ext feature flags 0-31
-					(ClockRTC)|\						;	Has RTC clock/pram
-					(ADBIop) 							;	Has IOP ADB
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$56,$00,$00,$00						; Check VIA1 PA6, PA4, PA2, PA1
-			dc.b	$52,$00,$00,$00						; VIA1 PA6 = 1, PA4 = 1, PA2 = 0, PA1 = 1
-			dc.l	VIA1InitOSS-InfoMacIIfx				; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	0									; no sound control vector table
-			dc.l	RTCClockPRAM-InfoMacIIfx			; clock/PRAM vector table							<H4>
-			dc.l	IOPADBTable-InfoMacIIfx				; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.w	0									; no CPU ID register
-			dc.w	0									; allow room for expansion
-			dc.l	IconInfo6Slot-InfoMacIIfx			; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-InfoOSSUnknown
-			dc.l	OSSFMCTable-InfoOSSUnknown			; offset to decoder info
-			dc.l	RAMInfo2Bank1Meg-InfoOSSUnknown		; offset to ram bank info
-			dc.l	0									; no built in video
-			dc.l	NuBusInfoSixSlotNoVid-InfoOSSUnknown; offset to NuBus info
-			dc.w	0|\									; hwCfgFlags
-					(1<<hwCbSCSI)|\						; SCSI port present
-					(1<<hwCbClock)|\					; New clock chip present
-					(1<<hwCbFPU)|\						; FPU chip present.
-					(1<<hwCbMMU)|\						; Some kind of MMU present (see MMUType for what kind).
-					(1<<hwCbADB)						; Apple Desktop Bus present.
-			dc.b	BoxUnknown							; product kind
-			dc.b	OSSFMCDecoder						; decoder kind
-			dc.w	$3FFF								; ROM85, New ROMs, Power Off ability.
-			dc.b	2									; default ROM Resource configuration
-			dc.b	ProductInfoVersion					; ProductInfo version
-			BitVector32									; use default bases for this decoder
-			BitVector32									; Flags for valid base addresses 32-63
-			BitVector32									; Flags for valid base addresses 64-95
-			dc.l	0									; use default external features for this decoder
-			dc.l	0									; Flags for valid ext feature flags 32-63
-			dc.l	0									; Flags for valid ext feature flags 64-95
-			dc.b	$00,$00,$00,$00						; don't check any VIA bits
-			dc.b	$00,$00,$00,$00						; anything with this decoder matches
-			dc.l	VIA1InitOSS-InfoOSSUnknown			; VIA1 init info
-			dc.l	0									; no VIA2 init info	
-			dc.l	0									; no sound control vector table
-			dc.l	RTCClockPRAM-InfoOSSUnknown			; clock/PRAM vector table							<H4>
-			dc.l	IOPADBTable-InfoOSSUnknown			; ADB/DebugUtil vector table						<H14>
-			dc.l	0									; no Power Manager primitives						<SM33>
-			dc.w	0									; no CPU ID register
-			dc.w	0									; spare
-			dc.l	IconInfo6Slot-InfoOSSUnknown		; offset to ICON info								<SM74>		
-
-
-			ALIGN	4
-			IMPORT	CheckForOSSFMC
-
-			BitVector32	\								; Default valid addresses  0-31
-					ROMExists,\							; ROMAddr is valid
-					DiagROMExists,\						; DiagROMAddr is valid
-					VIA1Exists,\						; VIA1Addr is valid
-					ASCExists,\							; ASCAddr is valid
-					SCSIDMAExists,\						; SCSIDMAAddr is valid
-					SWIMIOPExists,\						; SWIMIOPAddr is valid
-					SCCIOPExists,\						; SCCIOPAddr is valid
-					OSSExists,\							; OSSAddr is valid
-					FMCExists,\							; FMCAddr is valid
-					RPUExists							; RPUAddr is valid
-			BitVector32									; Default valid addresses 32-63
-			BitVector32									; Default valid addresses 64-95
-			dc.l	\ 									; Default ext features  0-31
-					(ClockRTC)|\		 				;	Has RTC clock/pram
-					(ADBIop)							;	Has IOP ADB
-			dc.l	0 									; Default ext features 32-63
-			dc.l	0 									; Default ext features 64-95
-			dc.b	$00,$00,$00,$00						; no special VIA bits to avoid changing
-			dc.l	CheckForOSSFMC-OSSFMCtable			; routine to identify this map
-			dc.b	OSSFMCDecoder
-			dc.b	DecoderInfoVersion					; DecoderInfo version
-			dcb.b	2,0
-			dc.l	$50F1C000							; FMC Base Address
-OSSFMCtable	dc.l	$40800000							; ROM - valid
-			dc.l	$58000000							; DiagROM - valid
-			dc.l	$50F00000							; VIA1 - valid
-			dc.l	$00000000							; SCC read - unused
-			dc.l	$00000000							; SCC write - unused
-			dc.l	$00000000							; IWM - unused
-			dc.l	$00000000							; PWM - unused
-			dc.l	$00000000							; Sound - unused
-			dc.l	$00000000							; SCSI - unused
-			dc.l	$00000000							; SCSIDack - unused
-			dc.l	$00000000							; SCSIHsk - unused
-			dc.l	$00000000							; VIA2 - unused
-			dc.l	$50F10000							; ASC - valid
-			dc.l	$00000000							; RBV - unused
-			dc.l	$00000000							; VDAC - unused
-			dc.l	$50F08000							; SCSIDMA - valid
-			dc.l	$50F12020							; SWIMIOP - valid
-			dc.l	$50F04020							; SCCIOP - valid
-			dc.l	$50F1A000							; OSS - valid
-			dc.l	$50F1C000							; FMC - valid
-			dc.l	$50F1E000							; RPU - (optional)
-			dc.l	$00000000							; unused 21											<SM10>
-			dc.l	$00000000							; JAWS - unused										<25>
-			dc.l	$00000000							; Sonic - unused									<45>
-			dc.l	$00000000							; 1st (internal) SCSI96 - unused
-			dc.l	$00000000							; 2nd (external) SCSI96 - unused
-			dc.l	$00000000							; DAFB - unused
-			dc.l	$00000000							; unused 27
-			dc.l	$00000000							; ROMPhysAddr - unused
-			dc.l	$00000000							; unused 29
-			dc.l	$00000000							; unused 30
-			dc.l	$00000000							; unused 31
-
-	
-VIA1InitOSS
-			dc.b	\									; vBufA initial value
-					(1)|\								; sound volume level initially 1
-					(0<<vCpuId2)|\						; CPU Identification bit 2 is an input
-					(0<<vCpuId3)						; CPU Identification bit 3 is an input
-
-			dc.b	\									; vDIRA initial value
-					(vSound)|\							; sound volume bits are outputs
-					(dINPUT<<vCpuId2)|\					; CPU Identification bit 2 is an input
-					(dINPUT<<vCpuId3)					; CPU Identification bit 3 is an input
-
-			dc.b	\									; vBufB initial value
-			 		(1<<vRTCData)|\						; real time clock data is one
-					(1<<vRTCClk)|\						; real time clock clock is high
-					(1<<vRTCEnb)|\						; clock initially disabled
-					(1<<vSndEnb)						; sound is disabled
-
-			dc.b	\									; vDIRB initial value
-					(dOUTPUT<<vRTCData)|\				; real time clock data initially an output
-					(dOUTPUT<<vRTCClk)|\				; real time clock clock is an output
-					(dOUTPUT<<vRTCEnb)|\				; clock enable is an output
-					(dOUTPUT<<vSndEnb)					; sound enable is an output
-
-			dc.b	\									; vPCR initial value
-					(%0<<0)|\							; CA1 input neg active edge (unused)
-					(%000<<1)|\							; CA2 input neg active edge	(1 sec interrupt)
-					(%0<<4)|\							; CB1 input neg active edge (unused)
-					(%000<<5)							; CB2 input neg active edge	(unused)
-
-			dc.b	\									; vACR initial value
-					(%0<<0)|\							; PA latch disable
-					(%0<<1)|\							; PB latch disable
-					(%000<<2)|\							; SR disabled
-					(%0<<5)|\							; T2 timed interrupt
-					(%00<<6)							; T1 timed interrupt, PB7 disabled
-
-		ENDIF											; {hasOSS}
-
-
-NuBusInfoSixSlotNoVid
-			dc.b	0									; slot 0
-			dc.b	0									; slot 1
-			dc.b	0									; slot 2
-			dc.b	0									; slot 3
-			dc.b	0									; slot 4
-			dc.b	0									; slot 5
-			dc.b	0									; slot 6
-			dc.b	0									; slot 7
-			dc.b	0									; slot 8
-			dc.b	0|\									; slot 9
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot A
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot B
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot C
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot D
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0|\									; slot E
-					(1<<hasPRAM)|\
-					(1<<canInterrupt)|\
-					(1<<hasConnector)
-			dc.b	0									; slot F
-
-
-	ENDIF												; obsolete tables •••••••••••••••••••••••••••••••••	<SM33>
-
-
-
-			ENDWITH										; {DecoderKinds,DecoderInfo,ProductInfo,NuBusInfo}
+			dc.b	$00
+			dc.b	$58
+			dc.b	$00
+			dc.b	$00
+			dc.b	$00
+			dc.b	$00
+			dc.b	$00
+			dc.b	$00
 
 			EndProc
 
diff --git a/OS/VerticalRetraceMgr.a b/OS/VerticalRetraceMgr.a
--- a/OS/VerticalRetraceMgr.a
+++ b/OS/VerticalRetraceMgr.a
@@ -115,7 +115,18 @@ VBLCore 	proc	export
 ; Registers Used: D0,D1,D2,A0,A1													<30Apr85>
 ;_______________________________________________________________________
 
-VInstall	lea 	VBLQueue,a1 		; get address of queue				<1.4>
+VInstall
+
+			lea 	VBLQueue+2,a1
+@loop		move.l	(a1),d1
+			beq.s	@dontflunk
+			move.l	d1,a1
+			cmp.l	a0,a1
+			bne.s	@loop
+			moveq.l	#0,d0
+			rts
+
+@dontflunk	lea 	VBLQueue,a1 		; get address of queue				<1.4>
 
 VInstallCommon							; common code shared with SlotVInstall
 			cmpi.w 	#vType,VBLType(a0)	; is it the proper type?
@@ -197,7 +208,6 @@ PseudoVBLInt
 			jsr		(a1)				; restart time manager task
 			bra.s	BumpTicks			
 VBLInt
-		eieioSTP
 			move.b	#1<<ifCA1,vIFR(a1)	; clear and re-enable vertical retrace interrupts
 		eieioSTP
 BumpTicks
@@ -297,13 +307,36 @@ RunVBLs		lea		qHead-vblink(a1),a0	; setup to fetch head of list
 GetSlotVBLQHdr
 			ext.w	d0					; ignore high byte
 			cmpi.w	#sLastSlot,d0		; check for valid slot #
-			bgt.s	@slotTooBig			; return error if too big
+			bhi.s	@slotTooBig			; return error if too big
 			movea.l	([SlotQDT],d0.w*4,slotVBLPtrs),a1	; point to the VBL queue header
+@return
 			rts							; return with success
 
-@slotTooBig	move.w	#smSlotOOBErr,d0	; return with slot # error
+@slotTooBig	
+			move.l	([$2b6],$260),a1
+			move.l	a1,d1
+			beq.s	@skipthis
+
+			move.l	(a1),d1
+			beq.s	@skipthis
+
+			movem.l	d0/d2/a0,-(sp)
+
+			sub.l	a0,a0
+			move.l	d1,a1
+			move.l	#'vbl ',d1
+			jsr		(a1)
+
+			move.l	a0,a1
+			movem.l	(sp)+,d0/d2/a0
+			move.l	a1,d1
+			bne.s	@return
+
+@skipthis
 			addq.w	#4,sp				; pop the return address
+			move.w	#smSlotOOBErr,d0	; return with slot # error
 			rts							; return to callers caller
+
 			endwith
 
 ;_______________________________________________________________________
@@ -415,7 +448,7 @@ DoVBLTask	bsr.s	GetSlotVBLQHdr		; find the VBL Queue for the slot
 ; Registers Used: A0
 ;_______________________________________________________________________
 
-InitVBLQs		LEA		DoVBLTask,A0			; and save hook to  
+InitVBLQs		LEA.L	DoVBLTask,A0			; and save hook to  
 				MOVE.L	A0,JVBLTask				;  VBL task execute routine
 				CLR.L	ScrnVBLPtr				; init main screen ptr save global
 				RTS								; exit to caller
diff --git a/Patches/MiscPatches.a b/Patches/MiscPatches.a
--- a/Patches/MiscPatches.a
+++ b/Patches/MiscPatches.a
@@ -155,6 +155,8 @@
 			include 'fontPrivate.a'				; <CEL-41>
 			include	'universalEqu.a'
 			include	'PowerPrivEqu.a'
+			include	'Processes.a'
+			include	'TextServices.a'
 
 PwrCycCount		EQU			$AA					; <1>
 	
@@ -243,19 +245,46 @@ SynchIdleTimeProc	PatchProc	_SynchIdleTime
 				_PPC											; PPC trap <PN>
 
 				WITH	PMgrRec,PowerDispRec					;
-				BRA.S	@Done									; <PN> branch always because we are SM ROM
-				Testfor	hwCbPwrMgr								; do we have a power manager?
+				BTST.B	#0,$DD5
 				BEQ.S	@Done									; no power cycling
-				MOVE.L	PMgrBase,A0								; Get the Power Manager Globals
-				MOVE.W	PwrCycSyncCount(A0),D0					; Get the number of syncIdle before IdleMind
-				ADDI.W	#1,PMgrScratch.SyncCounter(A0)			; Increment scratch counter
-				CMP.W	PMgrScratch.SyncCounter(A0),D0			; Have we done enough SyncIdles
-				BLT.S	@Done
-				CLR.W	PMgrScratch.SyncCounter(A0)				; reset counter
 				MOVEQ	#IdleMindDisp,D0						; Set the selector to IdleMind
 				_PowerDispatch
 @Done
-				rts
+
+				BTst.B		#$1, ($2409)
+				BEQ.B		@skipDriverCall
+				IMPORT		PMIdleRelatedDriverCall
+				MACHINE		MC68030
+				Bsr.L		PMIdleRelatedDriverCall
+@skipDriverCall
+
+				MoveA.L		([$2B6],$288), A0
+				Move.L		A0, D0
+				BEQ.B		@return
+				MoveM.L		D1-D3/A1-A2, -(A7)
+				Move		$6(A0), D1
+				MoveQ.L		#$0, D2
+
+@loop			MoveA.L		$14(A0,D2.L), A1
+				Move.L		A1, D0
+				BEQ.B		@continue
+				Move		$C8(A1), D0
+				Clr			D3
+				Cmp			D3, D0
+				BEQ.B		@continue
+				MoveA.L		$C4(A1), A2
+				Move.L		A2, D0
+				BEQ.B		@continue
+				Jsr			(A2)
+				Bra.B		@exit
+@continue		AddQ		#$4, D2
+				SubQ		#$1, D1
+				BNE.B		@loop
+
+@exit			MoveM.L		(A7)+, D1-D3/A1-A2
+
+@return			Rts
+
 
 				ENDPROC											; SynchIdleTimeProc
 
@@ -314,30 +343,48 @@ CleanupApp		PatchProc	_CleanupApplication
 				MOVE.L		applZone,A0				; point to zone hdr
 				MOVE.L		A0,-(SP)				; push start ptr
 				MOVE.L		(A0),-(SP)				; push zone trailer
-				_sbKillSomeCaches
+				MOVE.W		#sbKillSomeCaches,D0
+				_SplineMgr							; like _sbKillSomeCaches but with non-quick move
 				ADDQ		#4,SP					; ignore result
 		
-		IF hasCommToolbox THEN
-				;
-				; Clean up CommToolbox if necessary
-				;
-				import		CleanUpCommToolbox
-				JSR		CleanupCommToolbox
-		ENDIF		
-
-		IF hasEditionMgr THEN								; <36>
-				;
-				; Check if app was doing Edition Manager stuff that needs cleaning up
-				;
-				MOVE.L		ExpandMem, A0					; get expanded memory area
-				MOVE.L		ExpandMemRec.emDataPub(A0), D0	; get dp globals
-				BEQ.S		@noEditionMgr					; if not allocated, no need to do cleanup
-				SUBQ		#2,SP							; place holder for result
-				_QuitEditionPack							; call pack11 clean up
-				TST.W		(SP)+							; ignore result
-@noEditionMgr				
-		ENDIF
-		
+
+				MoveA.L		ExpandMem, A0
+				MoveA.L		$64(A0), A0
+
+				Tst.L		$70(A0)
+				BEQ.B		@skipAll
+
+				SubQ		#$8, SP
+				Clr			-(SP)
+				Pea.L		$2(SP)
+
+				_GetCurrentProcess
+
+				Tst			(SP)+
+				BNE.B		@dont
+
+				Clr			-(SP)
+				Pea.L		$2(SP)
+				Clr			-(SP)
+
+				_InlineAware
+
+				Tst.B		(SP)+
+				BEQ.B		@dont
+
+				Clr			-(SP)
+				Move		#$2, -(SP)
+				Pea.L		$4(SP)
+
+				Move		#$16, D0
+				_TSMDispatch
+				AddQ		#$2, SP
+@dont
+
+				AddQ		#$8, SP
+@skipAll
+
+
 				;
 				; Clean up Compoents and Component insetances belong to this app.
 				;
@@ -346,10 +393,8 @@ CleanupApp		PatchProc	_CleanupApplication
 				;
 				; Clean up the Palette Manager if there is one.
 				;
-				CMP.W	#$3FFF,ROM85				; do we have color QD? 
-				BHI.S	@noPMgrExit
-				_PMgrExit
-@noPmgrExit
+				MOVE.W	#selectPMgrExit,D0				; _PMgrExit
+				_PaletteDispatch
 
 				;
 				; Clean up Sound Manager
@@ -409,107 +454,5 @@ CleanupApp		PatchProc	_CleanupApplication
 				
 				ENDPROC								; CleanupApp
 
-;___________________________________________________________________________________
-;
-;			FUNCTION get70MgrAttr(selector : OSType; VAR response : LONGINT) : OSErr;
-;
-;			Generic Gestalt function for testing for existence of System 7.0
-;			features.  Since this patch is for 7.0 only, it always returns 1 in the
-;			response.  If your particular feature requires more bits set in the
-;			response, don't use this routine.  Currently, this is the function
-;			for the gestaltDBAccessMgrAttr and gestaltEditionMgrAttr selectors.
-;
-;			Registers A0 and A1 are destroyed.
-;
-;___________________________________________________________________________________
-
-get70MgrAttr	PROC
-
-				MOVE.L		(SP)+,A0			; return address
-				MOVE.L		(SP)+,A1			; address of result
-				
-				MOVE.L		#1,(A1)				; 7.0 features always under 7.0!
-
-				ADDA.W		#4,SP				; pop the selector type
-				MOVE.W		#noErr,(SP)			; it always works
-				JMP			(A0)
-
-				ENDPROC							; get70MgrAttr
-
-
-
-;___________________________________________________________________________________
-;
-;	Additional patch code goes here
-;
-;___________________________________________________________________________________
-
-;___________________________________________________________________________________
-;
-;			dimg entry - Dictionary Manager
-;
-;___________________________________________________________________________________
-
-DictionaryDispatch		PatchProc	_DictionaryDispatch
-
-DictionaryHandle	EQU			ExpandMemRec.emDictionaryMgrPackHandle
-DictionaryUseCount	EQU			ExpandMemRec.emDictionaryMgrUseCount
-
-				MOVE.L		ExpandMem,A1						; get expand mem into A1
-				MOVE.L		DictionaryHandle(A1),A0				; move the handle to the code into A0
-				ADD.W		#DictionaryUseCount,A1				; A1 = pointer to use count
-				_ProcHelper										; let ProcHelper take over
-				
-				ENDPROC											; DictionaryDispatch
-
-;___________________________________________________________________________________
-;
-;	Install Gestalt functions for gestaltDBAccessMgrAttr, gestaltEditionMgr,
-; 	gestaltStandardFileAttr, and gestaltAppleEventsAttr
-;
-;	!!!! all just return 1 for system 7.0 !!!!!
-;
-;___________________________________________________________________________________
-
-MiscPatchesInstall	InstallProc
-
-			IMPORT	get70MgrAttr
-			
-		IF hasDataAccessMgr THEN							; <37>				
-			MOVE.L			#gestaltDBAccessMgrAttr, D0		; Data Access Manager
-			lea				get70MgrAttr, A0
-			_NewGestalt
-		ENDIF
-		
-
-		IF hasEditionMgr THEN								; <37>							
-			MOVE.L			#gestaltEditionMgrAttr, D0		; Edition Manager
-			lea				get70MgrAttr, A0
-			_NewGestalt
-		ENDIF
-		
-			MOVE.L			#gestaltStandardFileAttr, D0	; Standard File
-			leaResident		get70MgrAttr, A0
-			_NewGestalt
-	
-		IF hasAppleEventMgr THEN							; <37>							
-			MOVE.L			#gestaltAppleEventsAttr, D0		; AppleEvent Manager
-			lea				get70MgrAttr, A0
-			_NewGestalt
-		ENDIF
-
-;___________________________________________________________________________________
-;	Gestalt function for the dictionary manager.  
-;		just returns 1 for CubeE
-;____________________________________________________________________________________
-			MOVE.L			#gestaltDictionaryMgrAttr, D0	; Dictionary Manager
-			lea				get70MgrAttr, A0		
-			_NewGestalt
-
-			
-			RTS
-
-			ENDPROC
-
 
 			END ; of file
\ No newline at end of file
diff --git a/QuickDraw/BitMaps.a b/QuickDraw/BitMaps.a
--- a/QuickDraw/BitMaps.a
+++ b/QuickDraw/BitMaps.a
@@ -1071,12 +1071,42 @@ NXTDST	MOVE.L	(A4)+,D1					;GET NEXT DST DEVICE
 		MOVE.L	srcDevice,A1				;handle to source gDevice
 		move.l	(a1),a1						;pointer to source gDevice
 		move.l	gdRect(a1),d0				;get rect top.left
-		move.l	theGDevice,a1				;handle to destination gDevice
-		move.l	(a1),a1						;pointer to destination gDevice
-		cmp.l	gdRect(a1),d0				;dest and src gDevice have same top-left?
-		beq.s	nxtdst						;devices overlap, skip drawing
-		
-		
+		move.l	theGDevice,a0				;handle to destination gDevice
+		move.l	(a0),a0						;pointer to destination gDevice
+
+		CMP		$24(A0), D0
+		BGT.S	@L5
+		BLT.S	@L2
+		SWAP	D0
+		CMP		gdRect+0(A0), D0
+		BGT.S	@L6
+		BLT.S	@L3
+		MOVE.L	gdRect+4(A1), D0
+		CMP		gdRect+6(A0), D0
+		BLT.S	@L7
+		BGT.S	@L4
+		BRA.S	nxtdst
+@L2		SWAP	D0
+		CMP		gdRect+0(A0), D0
+		BGT.S	@cont
+@L3		MOVE.L	gdRect+4(A1), D0
+		CMP		gdRect+6(A0), D0
+		BLT.S	@cont
+@L4		SWAP	D0
+		CMP		gdRect+4(A0), D0
+		BLT.S	@cont
+		BRA.S	nxtdst
+@L5		SWAP	D0
+		CMP		gdRect+0(A0), D0
+		BLT.S	@cont
+@L6		MOVE.L	gdRect+4(A1), D0
+		CMP		gdRect+6(A0), D0
+		BGT.S	@cont
+@L7		SWAP	D0
+		CMP		gdRect+4(A0), D0
+		BGT.S	@cont
+		BRA.S	nxtdst
+
 @cont
 ;
 ; End of <KON 2/19/90>
@@ -1711,11 +1741,91 @@ DSTRECT		EQU		MASKRECT-4		 	;long, addr of Rect
 MODE		EQU 	DSTRECT-2			;WORD
 MASKRGN 	EQU 	MODE-4				;LONG, RGNHANDLE
 
-VARSIZE		EQU		0
+VARSIZE		EQU		-4
 
 share	LINK	A6,#VARSIZE					;ALLOCATE STACK FRAME
 		MOVEM.L	D3-D7/A2-A4,-(SP)			;SAVE WORK REGISTERS FOR DEVLOOP
-		
+
+		CLR.L	-4(A6)
+		MOVE.L	MASKBITS(A6), D0
+		BEQ		@skip
+		MOVEA.L	D0, A0
+		CMPI	#$1, $20(A0)
+		BNE		@skip
+		MOVEA.L	$16(A6), A0
+		MOVEA.L	$E(A6), A1
+		MOVE	$4(A0), D0
+		SUB		(A0), D0
+		SUB		$4(A1), D0
+		ADD		(A1), D0
+		BGT.B	@L0
+		MOVE	$6(A0), D0
+		SUB		$2(A0), D0
+		SUB		$6(A1), D0
+		ADD		$2(A0), D0
+		BLE		@skip
+@L0		SUBQ	#$4, SP
+		DC.W	$AA18						;_GetCTable
+		MOVE.L	(SP)+, D3
+		BEQ		@skip
+		SUBQ	#$2, SP
+		PEA.L	-4(A6)
+		MOVE	#$2, -(SP)
+		PEA.L	MASKRECT(A6)
+		MOVE.L	D3, -(SP)
+		CLR.L	-(SP)
+		PEA		4
+		MOVE.L	#$160000,D0					;_QDExtensions -> _NewGWorld
+		DC.W	$AB1D
+		MOVE	(SP)+, D4
+		BNE.B	@L1
+		TST.L	-4(A6)
+		BNE.B	@L2
+@L1		SUBQ	#$2, SP
+		PEA.L	-4(A6)
+		MOVE	#$2, -(SP)
+		PEA.L	MASKRECT(A6)
+		MOVE.L	D3, -(SP)
+		CLR.L	-(SP)
+		CLR.L	-(SP)
+		MOVE.L	#$160000,D0					;_QDExtensions -> _NewGWorld
+		DC.W	$AB1D
+		MOVE	(SP)+, D4
+@L2		MOVE.L	D3, -(SP)
+		DC.W	$AA24						;_DisposCTable
+		TST		D4
+		BNE.B	@skip
+		MOVE.L	-4(A6), D0
+		BEQ.B	@skip
+		MOVEA.L	D0, A3
+		SUBQ	#$8, SP
+		PEA.L	$4(SP)
+		PEA.L	$4(SP)
+		MOVE.L	#$80005,D0					;_QDExtensions -> _GetGWorld
+		DC.W	$AB1D
+		MOVE.L	-4(A6), -(SP)
+		CLR.L	-(SP)
+		MOVE.L	#$80006,D0					;_QDExtensions -> _SetGWorld
+		DC.W	$AB1D
+		MOVE.L	MASKBITS(A6), -(SP)
+		PEA.L	$2(A3)
+		MOVE.L	MASKRECT(A6), -(SP)
+		PEA.L	$10(A3)
+		CLR		-(SP)
+		CLR.L	-(SP)
+		DC.W	$A8EC						;_CopyBits
+		SUBQ	#$2, SP
+		MOVE.L	$2(A3), -(SP)
+		MOVE.L	#$40001,D0					;_QDExtensions -> _LockPixels
+		DC.W	$AB1D
+		ADDQ	#$2, SP
+		MOVEA.L	$2(A3), A0
+		_HLock
+		MOVE.L	(A0), MASKBITS(A6)
+		MOVE.L	#$80005,D0					;_QDExtensions -> _GetGWorld
+		DC.W	$AB1D
+@skip
+
 ; SET UP REGISTERS FOR CALLING CMDEVLOOP
 		
 		MOVE.L	DSTBITS(A6),A1				;GET DST BIT/PIXMAP
@@ -1763,7 +1873,15 @@ SRCOK	MOVE.L	DSTBITS(A6),A0				;POINT TO DSTBITS
 		
 NOTPORT	MOVE.L	DSTBITS(A6),A1				;Pass DSTBITS (not derefed)		<BAL 28May89>
 		JSR		CMDevLoop					;AND DRAW THE IMAGE
-		
+
+		MOVE.L	-4(A6),D0
+		BEQ.S	@skipQDCall
+
+		MOVE.L	D0,-(SP)
+		MOVE.L	#$40004,D0					;_QDExtensions -> _DisposeGWorld
+		DC.W	$AB1D
+@skipQDCall
+
 		MOVEM.L	(SP)+,D3-D7/A2-A4			;RESTORE WORK REGISTERS
 		UNLINK	PARAMSIZE,'KopyMask'
 
@@ -2296,9 +2414,9 @@ cutOutDevices
 		move.l	pmTable(a0),a0				;get handle to source color table
 		move.l	(a0),a0						;deref it
 		cmp.l	ctSeed(a0),d1				;do the color tables seeds match ?
-		beq.s	@next
+		beq		@next
 
-		movem.l	d1/a1,-(sp)					;save our scratch registers
+		movem.l	d1/a1-a3,-(sp)					;save our scratch registers
 
 		clr.b	-(sp)						;make space for boolean result
 		pea		tempRect1(a6)				;pointer to the SrcRect in global coordinates
@@ -2307,7 +2425,34 @@ cutOutDevices
 		pea		tempRect2(a6)				;pointer to the result
 		_SectRect							;get the intersection
 		tst.b	(sp)+						;if they didn't intersect at all, then skip to
-		beq.s	@skip						;..the next device
+		beq		@skip						;..the next device
+
+		move.l	(a1),a0
+		move.l	GDPMap(a0),a0
+		move.l	(a0),a0
+		move.l	pmTable(a0),a0
+		move.l	(a0),a0
+		move.l	(DeviceList),a2
+@again	move.l	(a2),a2
+		move.l	GDPMap(a2),a3
+		move.l	(a3),a3
+		move.l	pmTable(a3),a3
+		move.l	(a3),a3
+		move.l	(a3),d0
+		cmp.l	(a0),d0
+		bne		@done
+		sub.l	#8,sp
+		clr.b	-(sp)
+		pea.l	tempRect1(a6)
+		pea.l	$22(a2)
+		pea.l	$a(sp)
+		_SectRect
+		tst.b	(sp)+
+		add.l	#8,sp
+		bne		@skip
+@done	move.l	GDNextGD(a2),d0
+		move.l	d0,a2
+		bne.s	@again
 
 		lea		tempRect2(a6),a0			;point to our temp rect
 		pea		topleft(a0)					;convert the temp rect back to local coordinates
@@ -2323,7 +2468,7 @@ cutOutDevices
 		move.l	d6,-(sp)
 		_DiffRgn
 
-@skip	movem.l	(sp)+,d1/a1					;restore our scratch registers
+@skip	movem.l	(sp)+,d1/a1-a3				;restore our scratch registers
 
 @next	move.l	(a1),a0						;deref the current device list handle
 		move.l	GDNextGD(a0),d0				;get the next device handle into D0
diff --git a/QuickDraw/CCrsrCore.a b/QuickDraw/CCrsrCore.a
--- a/QuickDraw/CCrsrCore.a
+++ b/QuickDraw/CCrsrCore.a
@@ -102,330 +102,60 @@
 
 cursorShadow	EQU		0
 
+
+ShieldCursor PROC  EXPORT		
+;---------------------------------------------------------
+;
+;  PROCEDURE ShieldCursor(shieldRect: Rect; offset: Point);
+;
+;  ALL REGS PRESERVED.
+;
+;  Lifted from LCursor.a
+;
+		IMPORT	QDNew_OtherShieldCursor
+
+		MOVEM.L D0-D2/A0-A1,-(SP)			;SAVE REGS
+		MOVE.L	28(SP),D0
+		MOVE.L 	24(SP),D1
+		MOVE.L	D0,-(SP)					;PUSH GLOBAL TOP
+		MOVE.L	D1,-(SP)					;PUSH GLOBAL LEFT
+		JSR 	QDNew_OtherShieldCursor
+		MOVEM.L (SP)+,D0-D2/A0-A1			;RESTORE REGS
+		RTD		#8
+
+
 CRSRCORE	PROC	EXPORT
-			EXPORT	CrsrVBLTask
-
 			EXPORT	InitCrTable
 			EXPORT	PinRect
 
-			IMPORT	ScrnAddress
-			IMPORT	ScrnSize
-			IMPORT	ScrnBitMap
-			IMPORT	PATCONVERT						; expand routine for color cursors/patterns
-			IMPORT	AllocCrsr						; proc at end of file
-			IMPORT	SETCRSRDATA						; PROC AT END OF FILE
-			IMPORT	SHFTTBL							; TO CONVERT DEPTH TO SHIFT
-			IMPORT	RGetHSize
+			IMPORT	_HideCursor
+			IMPORT	_ShowCursor
+			IMPORT	_ShieldCursor
+			IMPORT	_ScrnAddress
+			IMPORT	_ScrnSize
+			IMPORT	_InitCursor
+			IMPORT	_SetCursor
+			IMPORT	_ObscureCursor
+			IMPORT	AllocCrsr
+			IMPORT	_SetCCursor
 
-			IMPORT	BLITCURSOR,UNBLITCURSOR			; Cursor Pixelling		<dvb 19sep88>
-			EXPORT	DRAWCURSOR,ERASECURSOR			; Cursor Displaying		<dvb 19sep88>
-			EXPORT	CursorSect
-			EXPORT	GETMAINCRSR						;JUST USED INTERNALLY
 ;
 ; offset table for jump table initialization
 ;
 InitCrTable
-				DC.W	HideCursor-InitCrTable
-				DC.W	ShowCursor-InitCrTable
-				DC.W	ShieldCursor-InitCrTable
-				DC.W	ScrnAddress-InitCrTable
-				DC.W	ScrnSize-InitCrTable
-				DC.W	InitCursor-InitCrTable
-				DC.W	SetCursor-InitCrTable
-				DC.W	ObscureCursor-InitCrTable
+				DC.W	_HideCursor-InitCrTable
+				DC.W	_ShowCursor-InitCrTable
+				DC.W	_ShieldCursor-InitCrTable
+				DC.W	_ScrnAddress-InitCrTable
+				DC.W	_ScrnSize-InitCrTable
+				DC.W	_InitCursor-InitCrTable
+				DC.W	_SetCursor-InitCrTable
+				DC.W	_ObscureCursor-InitCrTable
 				DC.W	AllocCrsr-InitCrTable
-				DC.W	SetCCursor-InitCrTable
+				DC.W	_SetCCursor-InitCrTable
 
 
 ;_______________________________________________________________________
-;
-; CrsrVBLTask - executed once each vertical retrace
-;
-
-; ugly equs - stay here for now!
-adbCount	EQU	0						; word: number of valid error deltas
-MaxCnt		EQU	adbCount+2				; word: limit on number of error deltas
-Err7		EQU	MaxCnt+2				; word: time-7 error magnitude
-Err6		EQU	Err7+2					; word: time-6 error magnitude
-Err5		EQU	Err6+2					; word: time-5 error magnitude
-Err4		EQU	Err5+2					; word: time-4 error magnitude
-Err3		EQU	Err4+2					; word: time-3 error magnitude
-Err2		EQU	Err3+2					; word: time-2 error magnitude
-Err1		EQU	Err2+2					; word: time-1 error magnitude
-Error		EQU	Err1+2					; word: accumulated error
-GSize		EQU	Error+2
-
-CrsrVBLTask 							;COME HERE ON VERTICAL RETRACE
-
-	If	Not forRom	Then ; <H2>
-		TST.B	CrsrNew					; Mouse changed?
-		BEQ		TrackDone				; No … return
-		TST.B	CrsrBusy				; Cursor locked?
-		BNE		TrackDone				; Yes … return
-
-		TST.B	CrsrCouple				; Cursor coupled to mouse?
-		BEQ		NoComp					; No … skip computation	<DSV>
-
-		MOVE.W	MTemp+H,D0				; Find ∆Mx
-		SUB.W	RawMouse+H,D0
-
-		MOVE.W	MTemp+V,D1				; Find ∆My
-		SUB.W	RawMouse+V,D1
-
-		MOVE.W	D0,D2					; x := |∆Mx|
-		BGE.S	AbslXl
-		NEG.W	D2
-AbslXl
-
-		MOVE.W	D1,D3					; y := |∆My|
-		BGE.S	AbslYl
-		NEG.W	D3
-AbslYl
-
-		move.l	MickeyBytes,a0			; <10/7/86 SMH> get globals			<c856/26May87>
-		CMP.W	D2,D3					; D3 := magnitude(x,y)
-		BLS.S	MagDone
-		EXG	D2,D3
-MagDone	ASR.W	#1,D3
-		ADD.W	D2,D3
-
-		BNE.S		DoComp				; Zero magnitude … don’t compute	<c856/26May87>
-		MOVE.W		#1,adbCount(A0)		; No hits							<c856/26May87>
-		CLR.W		Error(A0)			; No errors							<c856/26May87>
-		BRA			DoPin				; Update the cursor					<c856/26May87>
-DoComp
-;
-		MOVEM.L	D4-D5,-(A7)				; Save off registers
-		MOVE.W	adbCount(A0),D4			; D4 is the number of samples
-		CMP.W	MaxCnt(A0),D4			; Is Count less than MaxCnt
-		BGE.S	CountOK
-		ADD.W	#1,adbCount(A0)			; Yes … we will have one more error
-CountOK
-
-		MOVE.W	D3,D5					; Magnitude at current time
-
-		MOVE.W	D4,D2					; Get Count
-		SUB.W	#1,D2					; Index into JTab
-		ASL.W	#1,D2					; REQUIRES BRA.S’s IN JUMP TABLES
-		JMP	JTab(PC,D2.W)				; Jump to the right code per Count
-
-JTab	BRA.S	E1						; Count = 1
-		BRA.S	E2						; Count = 2
-		BRA.S	E3						; Count = 3
-		BRA.S	E4						; Count = 4
-		BRA.S	E5						; Count = 5
-		BRA.S	E6						; Count = 6
-		BRA.S	E7						; Count = 7
-
-E8		ADD.W	Err7(A0),D5				; Accumulate time-7 magnitude
-
-E7		ADD.W	Err6(A0),D5				; Accumulate time-6 magnitude
-		MOVE.W	Err6(A0),Err7(A0)		; Shift out  time-6 magnitude
-
-E6		ADD.W	Err5(A0),D5				; Accumulate time-5 magnitude
-		MOVE.W	Err5(A0),Err6(A0)		; Shift out  time-5 magnitude
-
-E5		ADD.W	Err4(A0),D5				; Accumulate time-4 magnitude
-		MOVE.W	Err4(A0),Err5(A0)		; Shift out  time-4 magnitude
-
-E4		ADD.W	Err3(A0),D5				; Accumulate time-3 magnitude
-		MOVE.W	Err3(A0),Err4(A0)		; Shift out  time-3 magnitude
-
-E3		ADD.W	Err2(A0),D5				; Accumulate time-2 magnitude
-		MOVE.W	Err2(A0),Err3(A0)		; Shift out  time-2 magnitude
-
-E2		ADD.W	Err1(A0),D5				; Accumulate time-1 magnitude
-		MOVE.W	Err1(A0),Err2(A0)		; Shift out  time-1 magnitude
-
-E1		MOVE.W	D3,Err1(A0)				; Shift out current magnitude
-
-		MOVE.W	D4,D2					; Round up the divide
-		ASR.W	#1,D2					;   by half the denominator
-		ADD.W	D2,D5
-		EXT.L	D5						; Set up for the divide
-		DIVU	D4,D5					; Find the average magnitude
-
-		MOVE.W	D3,D4					; Get the original magnitude
-		SUB.W	D5,D3					; Find distance to average magnitude
-		ADD.W	Error(A0),D3			; Add on the accumulated error
-		CMP.W	#-1,D3					; Define -1 div 2 = 0
-		BNE.S	DivOK
-		CLR.W	D3
-DivOK	ASR.W	#1,D3					; Get half of it
-		MOVE.W	D3,Error(A0)			; Update it
-		ADD.W	D5,D3					; Desired mag is average+Error
-
-		CMP.W	#255,D5					; mag := MAX(mag,255)
-		BLS.S	MaxDone
-		MOVE.B	#255,D5
-MaxDone
-
-		move.l	MickeyBytes,a0			; <10/7/86 SMH> get at globals
-		add	#GSize,a0					; <10/24/86 SMH> point to table
-
-		CLR.W	D2						; i := 0
-
-Search	ADD.B	#1,D2					; repeat
-		CMP.B	(A0)+,D5				;   i := i+1
-		BHI.S	Search					; until mag ≤ Table[i]
-
-		MULS	D2,D3					; D4 := i*(Mag(∆M)+Error)
-
-		MULS	D3,D0					; ∆Cx := (∆Mx*i*(Mag(∆M)+Error))/Mag(∆M)
-		DIVS	D4,D0					;             <<<<<< D3 >>>>>>>
-		BMI.S	@1						; branch if minus
-		ANDI.W	#$007F,D0				; control max displacement (fix mouse jump)
-		BRA.S	@3
-@1
-		ORI.W	#$FF80,D0				; control max displacement (fix mouse jump)
-@3
-		MULS	D3,D1					; ∆Cy := (∆My*i*(Mag(∆M)+Error))/Mag(∆M)
-		DIVS	D4,D1					;             <<<<<< D3 >>>>>>>
-		BMI.S	@5						; branch if minus
-		ANDI.W	#$007F,D1				; control max displacement (fix mouse jump)
-		BRA.S	@7
-@5
-		ORI.W	#$FF80,D1				; control max displacement (fix mouse jump)
-@7
-		MOVEM.L	(A7)+,D4-D5				; Restore registers
-		ADD.W	D0,RawMouse+H			; Update raw mouse location
-		ADD.W	D1,RawMouse+V
-;
-DoPin									;							<c456/26May87>
-		LEA		CrsrPin,A0				; Bounding rect for cursor
-		MOVE.L	RawMouse,D0				; Pin mouse inside rect
-
-	Endif	; Not forRom <H2>
-
-		BSR.S	ScrnPin					; return to SHOWIT if screen changes
-
-		MOVE.L	D0,RawMOUSE 			; update cursor loc with clipped pt
-		MOVE.L	D0,MTEMP				; Update real mouse location with ""
-
-		AND.L	MOUSEMASK,D0			; do jerky masking to drop low order bits
-		MOVE.L	MOUSEOffset,D1			; Get the offset
-		BEQ.S	skipPin 				; and skip 2nd pin if not
-		ADD.L	D1,D0					; do jerky offset
-		BSR.S	ScrnPin 				; return to SHOWIT if screen changes
-
-skipPin	MOVE.L	D0,MOUSE
-
-NotCup	BSR		ERASECURSOR				; HIDE THE CURSOR					<dvb 19sep88>
-SHOWIT	CLR.B	CRSRNEW 				; RESET THE CURSOR CHANGED FLAG
-		CLR.B	CRSROBSCURE				; it's no longer obscured
-		BSR 	DRAWCURSOR				; AND SHOW CURSOR IN NEW POSITION	<dvb 19sep88>
-
-CRSRDONE								;AND RETURN
-		RTS
-
-TrackDone
-		move.l	MickeyBytes,a0			; <10/7/86 SMH> get globals
-		MOVE.W	#1,adbCount(A0)			; No hits
-		CLR.W	Error(A0)				; No errors
-		RTS								; Goodbye
-
-NoComp	move.l	MickeyBytes,a0			; <10/7/86 SMH> get globals
-		MOVE.W	#1,adbCount(A0)			; No hits
-		CLR.W	Error(A0)				; No errors
-		BRA.S	NotCup					; Update the cursor
-
-
-; --------end of ugly jcrsrcoreTask
-
-
-
-ScrnPin			CMP 	LEFT(A0),D0 			;less than left?
-				BGE.S	LEFTOK					;if not, no problem
-				BSR.S	FindScreen				;=>look for new screen
-				MOVE	LEFT(A0),D0 			;pin to the left
-
-LEFTOK			CMP 	RIGHT(A0),D0			;greater than right?
-				BLT.S	RIGHTOK					;if not, no problem  WAS BLE!!			<05Apr85>
-				BSR.S	FindScreen				;=>look for new screen
-				MOVE	RIGHT(A0),D0			;pin to the right
-				SUBQ	#1,D0					;really want one less
-
-RIGHTOK			SWAP	D0						;consider y
-				CMP 	TOP(A0),D0				;less than top?
-				BGE.S	TOPOK					;if not, no problem
-				SWAP	D0
-				BSR.S	FindScreen				;=>look for new screen
-				SWAP	D0
-				MOVE	TOP(A0),D0				;pin to the top
-
-TOPOK			CMP 	BOTTOM(A0),D0			;greater than bottom?
-				BLT.S	BOTOK					;if not, no problem  WAS BLE!!			<05Apr85>
-				SWAP	D0
-				BSR.S	FindScreen				;=>look for new screen
-				SWAP	D0
-				MOVE	BOTTOM(A0),D0			;pin to the bottom
-				SUBQ	#1,D0					;really want one less
-
-BOTOK			SWAP	D0
-				RTS								;and return
-
-;  Check to see if cursor has moved to another screen.
-;  If not, returns with D0 unchanged.
-;  If so, hides the cursor, updates cursor globals and does messy return.
-;
-;  Clobbers D1-D3/A0-A3 which are preserved by interrupt handler
-
-FindScreen		MOVE	D0,D3					;pt.h in D3
-				MOVE.L	D0,D1					;pt.v in D1
-				SWAP	D1						;pt.v in D1
-				MOVE.L	DeviceList,D2			;get the first GDevice
-				BMI.S	NoDev					;=>just in case no GDevice
-DoDev			MOVE.L	D2,A3					;get device handle
-				MOVE.L	(A3),A3					;get device pointer
-				TST		GDFlags(A3)				;is screen active?
-				BPL.S	NxtDev					;=>no, try next device
-				LEA		GDRect(A3),A1			;point to rect
-				CMP		(A1)+,D1				;above top?
-				BLT.S	NxtDev					;=>yes, check next device
-				CMP		(A1)+,D3				;to left of screen?
-				BLT.S	NxtDev					;=>yes, check next device
-				CMP		(A1)+,D1				;to bottom of screen?
-				BGE.S	NxtDev					;=>yes, check next device
-				CMP		(A1)+,D3				;to right of screen?
-				BLT.S	GotDev					;=>no, cursor is on this screen
-NxtDev			MOVE.L	GDNextGD(A3),D2			;get next device in chain
-				BNE.S	DoDev					;=>there is one, check it
-NoDev			RTS								;else return and pin to current screen
-
-; cursor has changed devices, update depth and rowbytes for current device
-
-GotDev			MOVE.L	CRSRPTR,A0				;get handle to cursor data
-				MOVE.L	(A0),A0					;get pointer to cursor data
-				MOVE.L	CrsrDevice,A1			;get handle to current device
-				MOVE.L	(A1),A1					;point to current device
-				MOVE	CCDEPTH(A0),GDCCDEPTH(A1)	;copy depth
-				MOVE	CCBYTES(A0),GDCCBYTES(A1)	;copy expanded rowbytes
-
-; now get the data, depth and rowbytes for the new device
-
-				BSR		ERASECURSOR				;else erase the cursor
-@0				SWAP	D3						;get pt.h in high word
-				MOVE	D1,D3					;get pt.v in low word
-				SWAP	D3						;now get them in the right order
-				MOVE.L	D3,MTEMP				;update real mouse location with ""
-				MOVE.L	D3,RawMOUSE 			;update cursor loc with clipped pt
-				MOVE.L	D3,MOUSE				;update mouse position
-				MOVE.L	D2,CrsrDevice			;set the current cursor device
-				MOVE.L	A3,A1					;get pointer to grafDevice
-				JSR		SetCrsrData				;and set up low-memory stuff for cursor
-
-				MOVE	GDREFNUM(A3),D0			;get the refNum
-				NOT		D0						;refNum -> unitnum
-				ASL		#2,D0					;get offset in unitTable
-				MOVE.L	UTableBase,A0			;get the base of the unit table
-				MOVE.L	(A0,D0),A3				;A3 = handle to the DCE
-				MOVE.L	(A3),A0					;get pointer to the DCE
-				MOVEQ	#0,D0					;clear out D0
-				MOVE.B	dCtlSlot(A0),D0			;get the slot number
-				_ATTACHVBL						;attach vbl to this slot
-
-				ADDQ	#8,SP					;strip 2 RTS's from stack
-				BRA		SHOWIT					;=>and go display cursor on new screen
 
 
 ; This routine is used by the pinrect routine below and is also called directly
@@ -473,53 +203,78 @@ PinRect
 				JMP 	(A0)					;return to caller
 
 
-;_______________________________________________________________________	;<dvb 19Sep88>
-;																			;<dvb 19Sep88>
-;	 PROCEDURE CursorSect -- called by shieldcursor, showcursor				;<dvb 19Sep88>
-;																			;<dvb 19Sep88>
-;	Does a sectrect of CrsrRect and ShieldRect, all global-coörd like.		;<dvb 19Sep88>
-;	CLEAR the z-flag if they DO intersect: BNE YesTheyIntersect.
-;	This code is was moved out of ShieldCursor.								;<dvb 19Sep88>
-;
-;	Since CrsrRect is in local screen coörds, and ShieldRect is in globals,
-;	the CrsrDevice's GDRect is used as an offset.
-;_______________________________________________________________________	;<dvb 19Sep88>
-CursorSect	MOVEM.L	A0/A1/D0,-(SP)					;save the approprate regs  <dvb 19Sep88>
-
-			TST		ShieldDepth						;Any shielding?
-			BEQ.s	@NoSect
-
-			LEA 	CrsrRect,A0 					;point to crsr rect		;<dvb 19Sep88>
-			MOVE.L	CrsrDevice,A1					;GET CURSOR DEVICE		;<dvb 19Sep88>
-			MOVE.L	(A1),A1							;POINT TO CURSOR DEVICE	;<dvb 19Sep88>
-			ADD		#GDRECT,A1						;POINT TO DEVICE'S RECT	;<dvb 19Sep88>
-
-			MOVE	ShieldRect+Bottom,D0 			;GET SHIELD BOTTOM		;<dvb 19Sep88>
-			SUB		TOP(A1),D0						;CONVERT TO SCREEN LOCAL;<dvb 19Sep88>
-			CMP 	(A0)+,D0						;IS SHIELDBOTTOM < SAVETOP ?	;<dvb 19Sep88>
-			BLT.S	@NOSECT							;YES, NO INTERSECTION	;<dvb 19Sep88>
-
-			MOVE	ShieldRect+Right,D0				;GET SHIELD RIGHT			<dvb 19Sep88>
-			SUB		LEFT(A1),D0						;CONVERT TO SCREEN LOCAL	<dvb 19Sep88>
-			CMP 	(A0)+,D0						;IS SHIELDRIGHT <= SAVELEFT ? <dvb 19Sep88>
-			BLE.S	@NOSECT							;YES, NO INTERSECTION		<dvb 19Sep88>
-
-			MOVE	ShieldRect+Top,D0				;GET SHIELD TOP				<dvb 19Sep88>
-			SUB		TOP(A1),D0						;CONVERT TO SCREEN LOCAL	<dvb 19Sep88>
-			CMP 	(A0)+,D0						;IS SHIELDTOP >= SAVEBOTTOM ? <dvb 19Sep88>
-			BGE.S	@NOSECT							;YES, NO INTERSECTION		<dvb 19Sep88>
-
-			MOVE	ShieldRect+Left,D0				;GET SHIELD LEFT			<dvb 19Sep88>
-			SUB		LEFT(A1),D0						;CONVERT TO SCREEN LOCAL	<dvb 19Sep88>
-			CMP 	(A0),D0 						;IS SHIELDLEFT >= SAVERIGHT ? <dvb 19Sep88>
-			BGE.S	@NOSECT							;YES, NO INTERSECTION		<dvb 19Sep88>
-
-@SECT		MOVEQ	#1,D0							;Clear the Z-flag			<dvb 19Sep88>
-			BRA.S	@out														;<dvb 19Sep88>
-
-@NOSECT		CLR		D0								;Set the Z-flag				<dvb 19Sep88>
-@out		MOVEM.L	(SP)+,A0/A1/D0					;Restore regs				<dvb 19Sep88>
-			RTS										;bye.
+;_______________________________________________________________________
+;
+;  HIDECURSOR - is called from CrsrVBLTask, and via jump table.
+;
+;  Subtracts 1 from crsrstate and hides the cursor if visible.
+;
+;
+_HideCursor	PROC	EXPORT
+		MOVEM.L	D0-D2/A0-A1,-(SP)
+		IMPORT	QDNEW_HIDECURSOR
+		JSR		QDNEW_HIDECURSOR
+		MOVEM.L	(SP)+,D0-D2/A0-A1
+		RTS
+
+;_______________________________________________________________________
+;
+;  SHOWCURSOR  - Called from CrsrVBLTask and via Jump Table.
+;
+;  Adds 1 to CRSRSTATE and paints cursor if zero and cursor is
+;  not already visible.
+;
+
+_ShowCursor	PROC	EXPORT
+		MOVEM.L	D0-D2/A0-A1,-(SP)
+		IMPORT	QDNEW_SHOWCURSOR
+		JSR		QDNEW_SHOWCURSOR
+		MOVEM.L	(SP)+,D0-D2/A0-A1
+		RTS
+
+;_______________________________________________________________________
+;
+;  CURSHIELD  - Called via Jump Table
+;
+;  PROCEDURE ShieldCursor(left,top,right,bottom: INTEGER);
+;
+;  Subtracts 1 from CRSRSTATE, hides cursor only if it intersects SHIELDRECT.
+;  left,top,right bottom is the shieldRect in global coordinates
+;
+;  ALL REGISTERS RESTORED.
+;
+
+_ShieldCursor	PROC	EXPORT
+		IMPORT	QDNEW_SHIELDCURSOR
+		JMP		QDNEW_SHIELDCURSOR
+
+;_______________________________________________________________________
+;
+;  PROCEDURE InitCursor;
+;
+;  Definitely redisplay the cursor, independent of previous calls to
+;  HideCursor, ShieldCursor and ObscureCursor.	It falls into showCursor.
+;
+
+_InitCursor	PROC	EXPORT
+		IMPORT	QDNEW_INITCURSOR
+		JMP		QDNEW_INITCURSOR
+
+;_______________________________________________________________________
+;
+; PROCEDURE SetCursor(hotSpot: Point; height: INTEGER; data: Ptr; mask:Ptr);
+;
+; This procedure sets THECRSR pointer in the system global area.
+; A reasonable hotSpot is ENFORCED!  Also fix bug to note changed when only hotspot does.  <05Apr85>
+;
+;  WARNING: to save code, this routine really doesn't use the above interface.
+;  It ignores the height and mask parameters.  It assumes that the mask immediately
+;  follows the data (as it does when called from LisaGraf)
+;
+
+_SetCursor	PROC	EXPORT
+		IMPORT	QDNEW_SETCURSOR
+		JMP		QDNEW_SETCURSOR
 
 ;_______________________________________________________________________
 ;
@@ -528,1446 +283,33 @@ CursorSect	MOVEM.L	A0/A1/D0,-(SP)					;save the approprate regs  <dvb 19Sep88>
 ;	 Removes the cursor from the screen without hiding it, so the next
 ;	 time the mouse moves, it will show up again.
 ;
-;_______________________________________________________________________
 
-ObscureCursor
-		MOVE.B	#1,CrsrBusy						;"Occupado"			<dvb 19sep88>
-		MOVE.B	#1,CrsrObscure					;Mark it as obscure	<dvb 19sep88>
-		BRA.S	EraseCursor						;and erase it
+_ObscureCursor	PROC	EXPORT
+		IMPORT	QDNEW_OBSCURECURSOR
+		JMP		QDNEW_OBSCURECURSOR
 
-;_______________________________________________________________________
+;--------------------------------------------------
 ;
-;  HIDECURSOR - is called from CrsrVBLTask, and via jump table.
+;  PROCEDURE AllocCrsr;
 ;
-;  Subtracts 1 from crsrstate and hides the cursor if visible.
+;  Allocates all global cursor data structures.  A maximum depth of 8 is assumed.
 ;
-;
-HideCursor
-		MOVE.B	#1,CrsrBusy 					;MARK CHANGE IN PROGRESS
-		SUB 	#1,CRSRSTATE					;CURSOR HIDDEN ONE DEEPER
-
-		;Fall into EraseCursor
-
-;________________________________________________________________________
-;	<SM5> CSS Horror vectorized this vector.  We are supporting this to be
-;   compatible with Horror.
-;	EraseCursor calls a vectorized version of the routine via lomem.
-;	EraseCursor is vectorized to gain access to low level cursor blit routines.
-;	(NOTE: Vector is initialized in StartInit.a to routine named VEraseCursor.)
-
-; EraseCursor is much like HideCursor, but doesn't decrement the CrsrState	<dvb 19sep88>
-
-EraseCursor
-		move.l	EraseCrsrVector,-(sp)			;<SM5> CSS
-		rts										;jump to the vectored routine <SM5> CSS
-DoneHid	CLR.B	CRSRBUSY						;CHANGE COMPLETE
-		RTS
-
-
-;_______________________________________________________________________
-;
-;  PROCEDURE InitCursor;
-;
-;  Definitely redisplay the cursor, independent of previous calls to
-;  HideCursor, ShieldCursor and ObscureCursor.	It falls into showCursor.
-;
-InitCursor
-		MOVE.B	#1,CrsrBusy 			;mark it busy
-		CLR.B	CrsrObscure				;we wont be obscure no more
-		CLR 	CrsrState				;reset state to 0
-		CLR		ShieldDepth
-;
-; fall into ShowCursor
-;
-
-;_______________________________________________________________________
-;
-;  SHOWCURSOR  - Called from CrsrVBLTask and via Jump Table.
-;
-;  Adds 1 to CRSRSTATE and paints cursor if zero and cursor is
-;  not already visible.
-;
-; this reflects the fix from QDciPatchROM.a where obscure/show/hide left		<sm 6/9/92>stb
-; the cursor hidden only, and obscure/hide/show left the cursor obscured only.	<sm 6/9/92>stb
-
-ShowCursor
-		MOVE.B	#1,CRSRBUSY 					;MARK CHANGE IN PROGRESS
-
-		TST		ShieldDepth						;Any shielding?
-		BEQ.s	@2
-
-@1		SUBQ	#1,ShieldDepth					;If so, this ShowCursor unshields,
-		BRA.s	DrawCursor						;but doesn't up the cursor level.
-
-@2		ADDQ	#1,CRSRSTATE					;CURSOR HIDDEN ONE LESS DEEP
-		bmi.s	DoneSho
-		beq.s	DrawCursor						;<KON 25JUN90>
-		clr.b	CrsrObscure						;unobscure cursor if level went past zero	<KON 25JUN90>
-
-		;fall into DrawCursor
-
-;________________________________________________________________________
-;	<SM5> CSS Horror vectorized this vector.  We are supporting this to be
-;   compatible with Horror.
-;   DrawCursor calls a vectorized version of the routine via lomem.
-;	DrawCursor is vectorized to gain access to low level cursor blit routines.
-;	(NOTE: Vector is initialized in StartInit.a to routine named VDrawCursor.)
-
-; DrawCursor is much like ShowCursor, but doesn't increment the CrsrState	<dvb 19sep88>
-
-DrawCursor
-		move.l	DrawCrsrVector,-(sp)			; <SM5> CSS
-		rts										;jump to the vectored routine <SM5> CSS
-
-DoneSho	CLR.B	CRSRBUSY						;CHANGE COMPLETE
-		RTS
-
-;_______________________________________________________________________
-;
-;  CURSHIELD  - Called via Jump Table
-;
-;  PROCEDURE ShieldCursor(left,top,right,bottom: INTEGER);
-;
-;  Subtracts 1 from CRSRSTATE, hides cursor only if it intersects SHIELDRECT.
-;  left,top,right bottom is the shieldRect in global coordinates
-;
-;  ALL REGISTERS RESTORED.
-;
-
-ShieldVars	RECORD	{return},DECREMENT					;<dvb 19Sep99>
-ShieldLeft	DS.W	1									;<dvb 19Sep99>
-ShieldTop	DS.W	1									;<dvb 19Sep99>
-ShieldRight	DS.W	1									;<dvb 19Sep99>
-ShieldBot	DS.W	1									;<dvb 19Sep99>
-return		DS.L	1									;<dvb 19Sep99>
-			ENDR
-
-			WITH	ShieldVars
-ShieldCursor
-			TST		ShieldDepth							;Any shielding already?	;<dvb 19Sep88>
-			BEQ.s	@2									;No=>don't unionrect
-
-			MOVEM.L	D0/A0,-(SP)							;Save some regs (and +8 our vars below*)
-			LEA		ShieldRect+right,A0					;A0->ShieldRect.right
-
-			MOVE.L	ShieldBot+8(SP),D0					;D0 = New shield bot,right (*)
-			CMP		(A0),D0								;Compare to ShieldRect.right
-			BLE.s	@u1									;Is the new right bigger?
-			MOVE	D0,(A0)
-
-@u1			SWAP	D0									;D0 = New shield bottom
-			CMP		-(A0),D0							;Compare to ShieldRect.bottom
-			BLE.s	@u2									;Is the new bottom bigger?
-			MOVE	D0,(A0)								;If so, replace with it.
-
-@u2			MOVE.L	ShieldTop+8(SP),D0					;D0 = New shield top,left (*)
-			CMP		-(A0),D0							;Compare to ShieldRect.left
-			BGE.s	@u3									;Is the new left smaller?
-			MOVE	D0,(A0)
-
-@u3			SWAP	D0									;D0 = New shield top
-			CMP		-(A0),D0							;Compare to ShieldRect.top
-			BGE.s	@u4									;Is the new top smaller?
-			MOVE	D0,(A0)
-
-@u4			MOVEM.L	(SP)+,D0/A0
-			BRA.s	@3
-
-@2			MOVE.L	ShieldBot(SP),ShieldRect+botRight	;save shieldrect		;<dvb 19Sep88>
-			MOVE.L	ShieldTop(SP),ShieldRect+topLeft							;<dvb 19Sep88>
-@3			ADDQ	#1,ShieldDepth						;Shielding officially on
-			MOVE.B	#1,CrsrBusy
-			BSR		CursorSect													;<dvb 19Sep88>
-			BEQ.s	@1															;<dvb 19Sep88>
-
-			BSR 	EraseCursor							;IT DOES INTERSECT, REMOVE IT
-
-@1			CLR.B	CrsrBusy
-			MOVE.L	(SP)+,(SP)							;STRIP 8 bytes of PARAMETERS, MOVING
-			MOVE.L	(SP)+,(SP)							;RETURN ADDR UP ON STACK
-			RTS
 
-			ENDWITH
+AllocCrsr	PROC	EXPORT
+		IMPORT	QDNEW_ALLOCCRSR
+		JMP		QDNEW_ALLOCCRSR
 
-			IMPORT	CopyHandle,PatConvert
 ;_______________________________________________________________________
 ;
 ; PROCEDURE SetCCursor(cCrsr: CCrsrHandle);
 ;
 ; This procedure copies the data in the specified color cursor into the
 ; system's cursor save area.  If the depth > 2, it expands it.
-
-; this routine was taken from QDciPatchROM.a because A2 was getting trashed <sm 6/9/92>stb
-; when setting CCursor on multiple device systems							<sm 6/9/92>stb
-
-SetCCursor	MOVEM.L	D3-D4/A2-A4,-(SP)			;save work registers
-			move.l	24(sp),a2					;get ccrsrHandle			<BAL 21Jun88>
-			move.l	a2,a0						;make a copy
-			_HGetState
-			move	d0,-(sp)					;save state for later
-			move.l	a2,a0						;make a copy
-			_HLock
-			MOVE.L	(a2),A2						;GET POINTER TO NEW CURSOR
-
-			MOVE.L	([CRSRPTR]),A3				;point to current cursor (LOCKED)
-			MOVE.L	crsrID(A2),D0				;and get ID of new cursor
-			CMP		#CCrsrPat,ccType(A3)		;is current cursor a color cursor?
-			BNE.S	NotCC						;=>no, it has definitely changed
-			CMP.L	ccID(A3),D0					;same as current one?
-			BEQ		SCCDONE						;=>yes, just return
-
-NotCC		MOVE.B	#1,CRSRBUSY					;flag the cursor as busy
-			MOVE.L	D0,ccID(A3)					;set new ID
-			LEA		crsr1Data(A2),A0			;point to old-cursor data
-			LEA		THECRSR,A1					;put it here
-			MOVEQ	#16,D0						;data+mask+hotspot = 17 longs
-@0			MOVE.L	(A0)+,(A1)+					;copy data
-			DBRA	D0,@0						;until done
-
-			LEA		crsr1Data(A2),A0			;point to old-cursor data
-			LEA		CCLASTCRSR(A3),A1			;save here to indicate cursor changed
-			MOVEQ	#7,D0						;move 8 longs
-@1			MOVE.L	(A0)+,(A1)+					;copy data
-			DBRA	D0,@1						;=>loop until done
-
-			MOVE	crsrType(A2),ccType(A3)		;copy the type
-
-; NOTE:  ALL THE DST HANDLES ARE LOCKED, BUT THEY HAVE BEEN SET TO THE PROPER SIZE
-
-			MOVE.L	crsrMap(A2),-(SP)			;push src pixMap handle
-			MOVE.L	ccMap(A3),-(SP)				;push dst pixMap handle
-			_CopyPixMap							;copy the pixMap
-
-			MOVE.L	crsrData(A2),-(SP)			;push src data handle
-			MOVE.L	ccData(A3),-(SP)			;push dst data handle
-			_CopyHandle							;copy the cursor data
-
-; FOR EACH ACTIVE SCREEN DEVICE, EXPAND CURSOR, IF NECESSARY
-
-			MOVE.L	DEVICELIST,D4				;D4 = CURRENT DEVICE
-			MOVE.L	D4,A4						;GET HANDLE TO CURRENT DEVICE
-NXTSCR		MOVE.L	(A4),A4						;A4 = POINTER TO CURRENT DEVICE
-			TST.W	GDFLAGS(A4)					;IS THE DEVICE ACTIVE?
-			BPL		CHKNXT						;=>NO, CHECK NEXT DEVICE
-												;ACTIVE DEVICES ARE LOCKED DOWN
-			MOVE.L	GDPMAP(A4),A0				;GET HANDLE TO DEVICE'S PIXMAP
-			MOVE.L	(A0),A0						;POINT TO DEVICE'S PIXMAP
-			MOVE	PIXELSIZE(A0),D3			;GET DEVICE'S PIXELSIZE
-
-; IF THE PATTERN IS PRE-EXPANDED TO THE RIGHT DEPTH, JUST COPY THAT DATA
-
-			CLR		GDCCDEPTH(A4)				;flag to expand one-bit data
-			MOVE	CRSRXVALID(A2),D0			;is there pre-expanded data?
-			BEQ.S	GOEXP						;=>no, do expansion
-			CMP		D3,D0						;is the expanded data the right depth?
-			BNE.S	GOEXP						;=>no, expand from the source
-			MOVE	D0,GDCCDEPTH(A4)			;else copy the expanded depth
-			MOVE.L	crsrXData(A2),-(SP)			;push the src xdata handle
-			MOVE.L	CCXDATA(A3),-(SP)			;push the dst xdata handle
-			_CopyHandle							;and copy it
-			BRA.S	CHKNXT						;=>data already expanded, just exit
-
-GOEXP		CMP		#CCRSRPAT,CCTYPE(A3)		;IS IT A COLOR CURSOR?
-			BNE.S	DONEONE						;=>NO, EXIT WITH DEPTH = 0
-			CMP		#2,D3						;IS DEPTH GREATER THAN 2?
-			BLE.S	DONEONE						;=>NO, EXIT WITH DEPTH = 0
-
-			MOVE	D3,GDCCDEPTH(A4)			;RECORD THE EXPANDED DEPTH
-			MOVE.L	GDCCXDATA(A4),CCXDATA(A3)	;GET DEVICE'S EXPANDED DATA FOR PATCONVERT
-			MOVE.L	THEGDEVICE,-(SP)			;SAVE GRAFDEVICE (USED BY PATCONVERT)
-			MOVE.L	D4,THEGDEVICE				;SET IT TO CURRENT DEVICE
-			MOVE.L	CRSRPTR,-(SP)				;PUSH HANDLE TO CURSOR (LOCKED)
-			_PATCONVERT							;AND EXPAND TO CURRENT DEPTH
-			MOVE.L	(SP)+,THEGDEVICE			;RESTORE GRAFDEVICE
-
-;  EXPAND THE MASK TO THE CURRENT DEPTH
-
-			MOVE	D3,D0						;GET DEPTH
-			MOVEQ	#0,D1						;DEFAULT SHIFT = 0
-NXTSHFT1	LSR		#1,D0						;CHECK NEXT DEPTH BIT
-			BCS.S	GOTSHFT1					;=>GOT SHIFT
-			ADDQ	#1,D1						;ELSE ADD ONE TO SHIFT
-			BRA.S	NXTSHFT1					;LOOP UNTIL WE HIT A ONE
-
-GOTSHFT1	LEA		THECRSR+MASK,A0				;SRC = CURSOR MASK
-			MOVE.L	([GDCCXMASK,A4]),A1			;POINT TO EXPANDED MASK (LOCKED)
-
-			move.l	a2,d4						;save pointer to new cursor			<25APR91 KON>
-			MOVE.L	A1,A2						;GET START OF DST BUFFER			<27May87 EHB>
-			MOVE	#32,D0						;GET #BYTES OF SOURCE				<27May87 EHB>
-			LSL		D1,D0						;MULTIPLY BY DEPTH					<27May87 EHB>
-			ADD		D0,A2						;POINT TO END OF BUFFER				<27May87 EHB>
-
-			move.l	ExTblPtr,A3					;POINT TO ROUTINE TABLE
-			add.l	0(A3,D1*4),A3				;USE DEPTH TO SELECT ROUTINE
-			MOVEQ	#0,D0						;CLEAR HIGH PART OF D0
-			JSR		(A3)						;EXPAND 32*DEPTH BYTES
-			MOVE.L	([CRSRPTR]),A3				;GET BACK POINTER TO CURSOR (LOCKED)
-			move.l	d4,a2						;restore pointer to new cursor		<25APR91 KON>
-
-DONEONE		MOVE	GDCCDEPTH(A4),D0			;GET EXPANDED DEPTH
-			ADD		D0,D0						;DOUBLE IT
-			MOVE	D0,GDCCBYTES(A4)			;AND SAVE AS CURSOR'S ROWBYTES
-
-CHKNXT		MOVE.L	GDNEXTGD(A4),D4				;IS THERE A NEXT DEVICE?
-			MOVE.L	D4,A4						;GET HANDLE TO NEXT DEVICE
-			BNE		NXTSCR						;=>THERE IS ONE, PREPARE ITS CURSOR
-
-			BSR.S	GETMAINCRSR					;RESTORE EXPAND DATA FOR MAIN CURSOR
-			BSR		ERASECURSOR					;HIDE THE OLD CURSOR
-			BSR		DRAWCURSOR					;DISPLAY THE NEW CURSOR
-SCCDONE		CLR.B	CRSRBUSY					;CURSOR NOT BUSY ANYMORE
-			move	(sp)+,d0					;get ccrsrhandle state
-			move.l	24(sp),a0					;get ccrsrHandle
-			_HSetState
-			MOVEM.L	(SP)+,D3-D4/A2-A4			;restore work registers
-			MOVE.L	(SP)+,(SP)					;strip parameter
-			RTS									;and return
-
-;_______________________________________________________________________
-
-GETMAINCRSR	MOVE.L	CRSRDEVICE,A0				;GET HANDLE TO CURSOR DEVICE
-			MOVE.L	(A0),A0						;GET POINTER TO CURSOR DEVICE
-			MOVE.L	CRSRPTR,A1					;GET HANDLE TO CURSOR SAVE AREA
-			MOVE.L	(A1),A1						;GET POINTER TO CURSOR SAVE
-			MOVE.L	GDCCXDATA(A0),CCXDATA(A1) 	;GET CURRENT EXPANDED DATA
-			MOVE.L	GDCCXMASK(A0),CCXMASK(A1)	;GET CURRENT EXPANDED MASK
-			MOVE	GDCCDEPTH(A0),CCDEPTH(A1)	;GET EXPANDED DEPTH
-			MOVE	GDCCBYTES(A0),CCBYTES(A1)	;GET EXPANDED ROWBYTES
-			RTS									;AND RETURN
-
-;_______________________________________________________________________
-;
-; PROCEDURE SetCursor(hotSpot: Point; height: INTEGER; data: Ptr; mask:Ptr);
-;
-; This procedure sets THECRSR pointer in the system global area.
-; A reasonable hotSpot is ENFORCED!  Also fix bug to note changed when only hotspot does.  <05Apr85>
-;
-;  WARNING: to save code, this routine really doesn't use the above interface.
-;  It ignores the height and mask parameters.  It assumes that the mask immediately
-;  follows the data (as it does when called from LisaGraf)
-;
-SetCursor	MOVE.L	([CRSRPTR]),A0			;point to crsr data structure (LOCKED)
-			move.b	#1,crsrBusy				;don't allow vbl drawing until we're done <09Aug88>
-			MOVE	#oldCrsrPat,ccType(A0)	;say that it's an old cursor
-
-			MOVE.L	8(SP),A0				;get address of data mask
-			LEA 	THECRSR,A1				;point to system cursor buffer
-			MOVEQ	#15,D2					;have 16 longs to move
-			MOVEQ	#0,D1					;flag that its not different
-
-SetCurLoop	MOVE.L	(A0)+,D0				;get next longWord of new cursor
-			CMP.L	(A1),D0 				;is it the same as what's there
-			BEQ.S	@1						;if so, skip
-			ADDQ	#1,D1					;flag that its different
-@1			MOVE.L	D0,(A1)+				;move it into the cursor buffer
-			DBRA	D2,SetCurLoop			;move all 64 bytes
-
-			MOVE.L	14(SP),D0				;get the alleged hotspot				<23Apr85>
-
-; Clean up the two coordinates to lie between 0 and 16. 							<23Apr85>
-
-			MOVEQ	#16,D2					; VERY handy temp, from loop above		<23Apr85>
-			CMP.W	D2,D0					;										<23Apr85>
-			BLS.S	@31 					; D0 LowerorSame as 16 is ok			<23Apr85>
-			MOVE.W	D2,D0					;pin it at 16							<23Apr85>
-
-@31			SWAP	D0						;align the high-order coord 			<23Apr85>
-			CMP.W	D2,D0					;										<23Apr85>
-			BLS.S	@33 					; D0 LowerorSame as 16 is ok			<23Apr85>
-			MOVE.W	D2,D0					;										<23Apr85>
-
-@33			SWAP	D0						;realign coords 						<23Apr85>
-			CMP.L	TheCrsr+HotSpot,D0		;is it new? 							<05Apr85>
-			BEQ.S	@3						;										<05Apr85>
-			ADDQ	#1,D1					;flag it's different                    <05Apr85>
-			MOVE.L	D0,TheCrsr+HotSpot		;move in the hotSpot					<05Apr85>
-@3
-
-; DID THE CURSOR CHANGE?
-
-			clr.b	crsrBusy				;re-allow vbl drawing					<09Aug88>
-			TST 	D1						;did it change?
-			BEQ.S	@6						;skip if it didn't
-
-; IF SO, FORCE THE CURSOR TO BE REDISPLAYED BY HIDING AND THEN SHOWING IT
-
-			BSR 	EraseCursor				;hide it
-			BSR 	DrawCursor				;then show it again to redraw it
-
-@6			MOVE.L	(SP)+,A0				;get return address
-			ADD 	#14,SP					;strip parameters
-			JMP 	(A0)					;return to caller
-
-
-
-SetCrsrData		PROC	EXPORT
-;------------------------------------------------
-;  UTILITY SetCrsrData
-;
-;  This routine is called to initialize low-memory locations
-;  to the necessary values for the grafDevice pointer in A1.
-;
-				IMPORT	SetCrsrDelay			;<SM5> CSS
-				bsr.l	SetCrsrDelay			;<SM5> CSS
-				MOVE.L	CRSRPTR,A0				;get handle to cursor data
-				MOVE.L	(A0),A0					;get pointer to cursor data
-
-;  initialize the grafDevice's cursor variables
-
-				MOVE.L	GDCCXDATA(A1),CCXDATA(A0)	;copy handle to expanded data
-				MOVE.L	GDCCXMASK(A1),CCXMASK(A0)	;copy handle to expanded mask
-				MOVE	GDCCDEPTH(A1),CCDEPTH(A0)	;copy depth
-				MOVE	GDCCBYTES(A1),CCBYTES(A0)	;copy expanded rowbytes
-
-;  set the pinning rectangle to the current screen
-
-				LEA		GDRect(A1),A0			;get rect for current device
-				MOVE.L	(A0)+,crsrPin			;and set pinning rectangle
-				MOVE.L	(A0),crsrPin+4			;from device's rectangle
-
-;  set the depth, rowbytes, height, and width of the current screen
-
-				MOVE.L	GDPMap(A1),A0			;get pixMap of current device
-				MOVE.L	(A0),A0					;point at pixmap
-				MOVE	PixelSize(A0),chunkyDepth ;set depth of cursor's screen
-				MOVE.L	(A0)+,crsrBase			;update base address for cursor
-				MOVE	(A0)+,D0				;get rowbytes
-				AND		#nuRBMask,D0				;clear flag bits
-				MOVE	D0,crsrRow				;set cursor rowbytes
-				MOVE	bottom(A0),D0			;get bottom of cursor's screen
-				SUB		top(A0),D0				;calc height of cursor's screen
-				MOVE	D0,ColLines				;save height of cursor's screen
-				MOVE	right(A0),D0			;get right of cursor's screen
-				SUB		left(A0),D0				;calc width of cursor's screen
-				MOVE	D0,RowBits				;save width of cursor's screen
-				RTS
-
-
-ALLOCCRSR		PROC	EXPORT
-				IMPORT	PatConvert,GETMAINCRSR,SetCrsrData
-				IMPORT	RNEWHANDLE,ERASECURSOR,DRAWCURSOR
-;--------------------------------------------------
-;
-;  PROCEDURE AllocCrsr;
-;
-;  Allocates all global cursor data structures.  A maximum depth of 8 is assumed.
-;
-; CRSRPTR IS USED AS A HANDLE TO AN EXTENDED PATTERN WHICH CONTAINS THESE FIELDS:
-;
-; CCTYPE		EQU		0				;[WORD] CURSOR TYPE
-; CCMAP			EQU		CCTYPE+2		;[LONG] HANDLE TO CURSOR'S PIXMAP
-; CCDATA		EQU		CCMAP+4			;[LONG] HANDLE TO CURSOR'S COLOR DATA
-; CCXDATA		EQU		CCDATA+4		;[LONG] HANDLE TO EXPANDED DATA
-; CCXMASK		EQU		CCXDATA+4		;[LONG] HANDLE TO EXPANDED MASK
-; CCSAVE		EQU		CCXMASK+4		;[LONG] HANDLE TO SAVE BITS UNDER CURSOR
-; CCLASTCRSR	EQU		CCSAVE+4		;[32 BYTES] DATA FOR LAST B/W CURSOR DRAWN
-; CCID			EQU		CCLASTCRSR		;[LONG] ID FOR LAST COLOR CURSOR DRAWN
-; CCTABLE		EQU		CCID+4			;[LONG] TABLE ID FOR LAST COLOR CURSOR
-; CCDEPTH		EQU		CCLASTCRSR+32	;[WORD] DEPTH FOR LAST CURSOR DRAWN
-; CCSTATEREGS	EQU		CCDEPTH+2		;[20 BYTES] STATE INFO OF SAVED DATA
-; CCBYTES		EQU		CCSTATEREGS+16	;[WORD] ROWBYTES OF EXPANDED DATA
-; CCMAXDEPTH	EQU		CCBYTES+2		;[WORD] MAXIMUM CURSOR DEPTH
-
-
-			MOVEM.L	D0-D6/A0-A4/A6,-(SP)		;PRESERVE ALL REGS
-			MOVE.L	THEZONE,-(SP)				;SAVE THE CURRENT HEAP ZONE
-			MOVE.L	SYSZONE,THEZONE				;SET CURRENT ZONE TO SYS ZONE
-
-; ALLOCATE MAIN CURSOR STRUCTURE AND DATA AREAS IF NECESSARY
-
-			BSR		ERASECURSOR					;HIDE THE CURSOR
-			MOVE.B	#1,CRSRBUSY 				;MARK CHANGE IN PROGRESS
-
-			MOVE.L	CRSRPTR,D0					;GET CRSRPTR (REALLY HANDLE)
-			CMP.L	MINUSONE,D0					;IS IT ALLOCATED?
-			BNE.S	MAINOK						;=>ALREADY ALLOCATED, CONTINUE
-
-; RESERVE MEMORY FOR AND ALLOCATE CURSOR STRUCTURE.
-; THE CURSOR SAVE RECORD CONTAINS A PIXMAP, A DATA HANDLE, AND A SAVE HANDLE.
-
-			clr.b	CrsrObscure					;we wont be obscure no more
-			clr 	CrsrState					;reset state to 0
-			clr		ShieldDepth					;no more shielding
-
-			MOVEQ	#CCSAVEREC,D1				;GET SIZE OF CURSOR SAVE RECORD
-			BSR		GETLOWHANDLE				;ALLOCATE RECORD DOWN LOW AND LOCK
-			MOVE.L	A0,CRSRPTR					;SAVE HANDLE TO CURSOR
-			MOVE.L	(A0),A4						;KEEP POINTER IN A4
-
-			MOVEQ	#PMREC,D0					;WE'RE GOING TO LOCK THIS
-			_RESRVMEM							;SO RESERVE SPACE DOWN LOW
-			CLR.L	-(SP)						;MAKE ROOM FOR FUNCTION RESULT
-			_NEWPIXMAP							;ALLOCATE A PIXMAP
-			MOVE.L	(SP)+,A0					;GET HANDLE TO PIXMAP
-			MOVE.L	A0,CCMAP(A4)				;SAVE PIXMAP IN CURSOR RECORD
-			_HLOCK								;LOCK IT DOWN
-
-			MOVEQ	#2,D0						;DEFAULT SIZE OF DATA HANDLE
-			JSR		RNEWHANDLE					;ALLOCATE IT
-			MOVE.L	A0,CCDATA(A4)				;AND SAVE FOR CURSOR DATA
-
-; RESERVE AND ALLOCATE MEMORY IN WHICH TO SAVE THE BITS BEHIND THE CURSOR.
-; MAGIC AMOUNT OF MEMORY RESERVED IS FOR 32 BIT DEEP, LONG ALIGNED CURSOR.
-
-	if cursorShadow then
-			MOVE.L	#$400*4,D1					;GET REQUIRED SIZE 32*32*4
-	else
-			MOVE.L	#$400,D1					;GET REQUIRED SIZE 16*16*4
-	endif
-			BSR		GETLOWHANDLE				;GET LOW,LOCKED HANDLE
-			MOVE.L	A0,CCSAVE(A4)				;SAVE INTO RECORD
-
-; INITIALIZE THE CURSOR TO THE ARROW CURSOR.
-
-			MOVE	#OLDCRSRPAT,CCTYPE(A4)		;SAY THAT IT'S AN OLD CURSOR
-			CLR		CCDEPTH(A4)					;CLEAR DEPTH TO SAY NOT EXPANDED
-
-			MOVE.L	GRAFGLOBALS(A5),A0			;POINT TO GRAFGLOBALS
-			LEA		ARROW(A0),A0				;POINT TO ARROW CURSOR
-			LEA		THECRSR,A1					;PUT IT HERE
-			MOVEQ	#16,D0						;DATA+MASK+HOTSPOT = 17 LONGS
-@2			MOVE.L	(A0)+,(A1)+					;COPY DATA
-			DBRA	D0,@2						;UNTIL DONE
-
-
-; FOR EACH ACTIVE SCREEN DEVICE, ALLOCATE EXPANDED CURSOR MEMORY IF NECESSARY
-; ALL DEVICES ARE GUARANTEED TO BE LOCKED.
-
-MAINOK		MOVE.L	CRSRPTR,A4					;GET HANDLE TO CURSOR STUFF
-			MOVE.L	(A4),A4						;GET POINTER (LOCKED)
-			MOVE.L	DEVICELIST,D4				;D4 = CURRENT DEVICE
-			MOVE.L	D4,A6						;GET HANDLE TO CURRENT DEVICE
-NXTDEVICE	MOVE.L	(A6),A6						;A6 = POINTER TO CURRENT DEVICE
-			TST.W	GDFLAGS(A6)					;IS THE DEVICE ACTIVE?
-			BPL		CHKNEXT						;=>NO, CHECK NEXT DEVICE
-
-			TST		GDCCDEPTH(A6)				;HAS MEMORY BEEN ALLOCATED?
-			BNE.S	DOEXPAND					;=>YES, EXPAND CURSOR IF NECESSARY
-
-			MOVE.L	GDCCXDATA(A6),A0			;GET HANDLE TO EXPANDED DATA
-			_DISPOSHANDLE						;DISPOSE THE CURRENT HANDLE
-			MOVE.L	#$400,D1					;GET SIZE OF EXPANDED HANDLE @@@@ used to be $100
-			BSR		GETLOWHANDLE				;GET A LOW, LOCKED HANDLE
-			MOVE.L	A0,GDCCXDATA(A6)			;AND SAVE IT
-
-			MOVE.L	GDCCXMASK(A6),A0			;GET HANDLE TO EXPANDED DATA
-			_DISPOSHANDLE						;DISPOSE THE CURRENT HANDLE
-			BSR		GETLOWHANDLE				;GET A LOW, LOCKED HANDLE
-			MOVE.L	A0,GDCCXMASK(A6)			;AND SAVE IT
-
-DOEXPAND
-; MAKE SURE ALL THE HANDLES ARE THE RIGHT SIZE FOR THE CURRENT DEPTH.
-; IF COLOR CURSOR AND DEPTH IS > 2 BITS PER PIXEL, THEN EXPAND TO CURRENT DEPTH.
-; BLACK AND WHITE (AND 2 BIT) CURSORS ARE EXPANDED BY SHOWCURSOR.
-
-			MOVE.L	GDPMAP(A6),A0				;GET HANDLE TO DEVICE'S PIXMAP
-			MOVE.L	(A0),A0						;POINT TO DEVICE'S PIXMAP
-			MOVE	PIXELSIZE(A0),D3			;GET DEVICE'S PIXELSIZE
-			CMP		GDCCDEPTH(A6),D3			;HAS DEPTH CHANGED?
-			BEQ.S	CHKNEXT						;=>NO, THIS DEVICE IS OK
-
-;  CONVERT DEPTH TO SHIFT AMOUNT IN D6
-
-			MOVE	D3,D0						;GET DEPTH
-			MOVEQ	#0,D6						;DEFAULT SHIFT = 0
-NXTSHFT		LSR		#1,D0						;CHECK NEXT DEPTH BIT
-			BCS.S	GOTSHFT						;=>GOT SHIFT
-			ADDQ	#1,D6						;ELSE ADD ONE TO SHIFT
-			BRA.S	NXTSHFT						;LOOP UNTIL WE HIT A ONE
-
-GOTSHFT		CMP		#CCRSRPAT,CCTYPE(A4)		;IS IT A COLOR CURSOR?
-			BNE.S	CHKNEXT						;=>NO
-			CMP		#2,D3						;IS DEPTH GREATER THAN 2?
-			BLE.S	CHKNEXT						;=>NO
-
-			MOVE.L	GDCCXDATA(A6),CCXDATA(A4)	;GET EXPAND HANDLE FOR PATCONVERT
-			MOVE.L	THEGDEVICE,-(SP)			;SAVE GRAFDEVICE
-			MOVE.L	D4,THEGDEVICE				;SET IT TO CURRENT DEVICE
-			MOVE.L	CRSRPTR,-(SP)				;PUSH HANDLE TO CURSOR
-			_PATCONVERT							;AND EXPAND TO CURRENT DEPTH
-			MOVE.L	(SP)+,THEGDEVICE			;RESTORE GRAFDEVICE
-
-;  EXPAND THE MASK TO THE CURRENT DEPTH
-
-			LEA		THECRSR+MASK,A0				;SRC = CURSOR MASK
-			MOVE.L	([GDCCXMASK,A6]),A1			;POINT TO EXPANDED MASK (LOCKED)
-			MOVE.L	A1,A2						;GET START OF DST BUFFER
-			MOVE	#32,D0						;GET #BYTES OF SOURCE
-			LSL		D6,D0						;MULTIPLY BY DEPTH
-			ADD		D0,A2						;POINT TO END OF BUFFER
-
-			move.l	ExTblPtr,A3					;POINT TO ROUTINE TABLE
-			add.l	0(A3,D6*4),A3				;USE DEPTH TO SELECT ROUTINE
-			MOVEQ	#0,D0						;CLEAR HIGH PART OF D0
-			JSR		(A3)						;EXPAND 32*DEPTH BYTES
-
-			MOVE	D3,GDCCDEPTH(A6)			;SAVE DEPTH OF EXPANDED CURSOR
-			ADD		D3,D3						;GET 2*DEPTH
-			MOVE	D3,GDCCBYTES(A6)			;SAVE ROWBYTES FOR EXPANDED CURSOR
-
-CHKNEXT		MOVE.L	GDNEXTGD(A6),D4				;IS THERE A NEXT DEVICE?
-			MOVE.L	D4,A6						;GET HANDLE TO NEXT DEVICE
-			BNE		NXTDEVICE					;=>THERE IS ONE, PREPARE ITS CURSOR
-
-			BSR		GETMAINCRSR					;SET UP FIELDS FOR MAIN CURSOR
-			MOVE.L	CRSRDEVICE,A1				;GET HANDLE TO CURSOR DEVICE
-			MOVE.L	(A1),A1						;GET POINTER TO CURSOR DEVICE
-			JSR		SetCrsrData					;AND SET UP LOW-MEM FOR THIS DEVICE
-
-			MOVE.L	(SP)+,THEZONE				;RESTORE THE ZONE
-			CLR.B	CRSRBUSY					;CHANGE COMPLETE
-			BSR		DRAWCURSOR
-			MOVEM.L	(SP)+,D0-D6/A0-A4/A6		;RESTORE ALL REGS
-			RTS
-
-
-GETLOWHANDLE
-;--------------------------------------------------
-; UTILITY GETLOWHANDLE
-;
-; THIS ROUTINE RESERVES MEMORY FOR A HANDLE, ALLOCATES THE HANDLE
-; AND THEN LOCKS IT DOWN.  THE DESIRED SIZE IS IN D1.  THE RETURNED HANDLE IS IN A0
-; ONLY D0 IS TRASHED
-
-			MOVE.L	D1,D0						;GET THE DESIRED SIZE
-			_RESRVMEM							;RESERVE SPACE FOR THE HANDLE DOWN LOW
-			BNE.S	MEMFULL						;=>ON ERROR, JUST BOMB
-			MOVE.L	D1,D0						;GET THE DESIRED SIZE
-			_NEWHANDLE	,CLEAR					;ALLOCATE THE HANDLE
-			_HLOCK								;LOCK IT
-			RTS									;AND RETURN
-
-MEMFULL		MOVEQ	#25,D0						;MEM FULL ERROR
-			_SYSERROR							;FLAG IT
-			DC.W	$A9FF						;JUST IN CASE WE RETURN
-
-;_______________________________________________________________________
-;
-;	BLITCURSOR																<dvb 19sep88>
-;
-; The only thing that will stop this routine from blitting the cursor
-; to the screen is ShieldRect. Since the new CrsrRect isn't known
-; until pretty far through the process, it's checked here, not
-; DrawCursor. CrsrState and CrsrObscure are _not_ checked here.
-; It seems likely that patching this routine will have use on accelerator
-; cards etc.
-
-BLITCURSOR		PROC	EXPORT
-		IMPORT	CursorSect, SHFTTBL
-
-		TST.L	CRSRPTR							;CURSOR ALLOCATED?
-		BMI		NoBlit							;=>NO, JUST RETURN
-		MOVEM.L D0-D7/A0-A6,-(SP)				;SAVE REGISTERS
-		LEA		THECRSR+DATA,A2					;POINT TO THE CURSOR
-
-
-;-----------------------------------------------
-;
-;  CONVERT CHUNKY DEPTH TO SHIFT AMOUNT IN D7
-;
-		LEA		SHFTTBL,A0					;TO CONVERT DEPTH TO SHIFT
-		MOVE	CHUNKYDEPTH,D1				;GET DEPTH
-		MOVEQ	#0,D7						;DEFAULT SHIFT = 0
-		MOVE.B	0(A0,D1),D7					;GET SHIFT AMOUNT IN D7
-
-
-;-----------------------------------------------
-;
-;  CHECK THE CURSOR TO SEE IF IT HAS CHANGED
-;	 OLD CURSORS: CHECK CURSOR DATA AND DEPTH
-;    NEW CURSORS: CHECK DEPTH
-;
-GOTSHFT	MOVE.L	([CRSRPTR]),A4				;GET POINTER TO CURSOR DATA (LOCKED)
-		CMP		#CCRSRPAT,CCTYPE(A4)		;IS IT A COLOR CURSOR?
-		BNE.S	OLDCUR						;=>NO, JUST AN OLD ONE
-		CMP		CCDEPTH(A4),D1				;HAS DEPTH CHANGED?
-		BEQ		NOEXPAND					;=>NO, DON'T EXPAND
-		CMP		#2,D1						;IS DEPTH 2 or 1?
-		BGT		EXPMASK						;=>NO, JUST EXPAND MASK
-		BRA.S	CPYDATA						;=>ELSE JUST COPY DATA
-
-OLDCUR	LEA		CCLASTCRSR(A4),A0			;POINT TO SAVED DATA
-		MOVE.L	A2,A1						;GET POINTER TO CURSOR
-		MOVEQ	#7,D0						;CHECK 8 LONGS
-@0		CMP.L	(A0)+,(A1)+					;ARE THEY THE SAME?
-		BNE.S	GOEXPAND					;=>NO, EXPAND IT
-		DBRA	D0,@0						;=>LOOP UNTIL DONE
-
-		CMP		CCDEPTH(A4),D1				;HAS DEPTH CHANGED?
-		BEQ		NOEXPAND					;=>NO, DON'T EXPAND
-
-GOEXPAND
-;-----------------------------------------------
-;
-;  INVALIDATE EXPANDED DATA FOR EACH DEVICE BY CLEARING DEPTH
-;  THIS MUST BE DONE SO THAT ALL EXPANDED CURSOR IMAGES ARE RENDERED INVALID AFTER
-;  AN OLD CURSOR HAS BEEN SET.  IF THE CURSOR IS NEW, SETCCURSOR ALREADY DID THIS.
-
-		MOVE.L	DEVICELIST,A0				;GET FIRST HANDLE IN DEVICE LIST
-NXTGD	MOVE.L	(A0),A0						;POINT TO FIRST DEVICE
-		TST		GDFLAGS(A0)					;IS IT ACTIVE?
-		BPL.S	NOTACT						;=>NO, SKIP TO NEXT
-		CLR		GDCCDEPTH(A0)				;ELSE INVALIDATE EXPANDED DATA
-NOTACT	MOVE.L	GDNEXTGD(A0),D0				;GET NEXT GRAFDEVICE
-		MOVE.L	D0,A0						;GET INTO A0
-		BNE.S	NXTGD						;=>REPEAT FOR ALL DEVICES
-
-;  COPY THE CURSOR DATA TO IDENTIFY THIS CURSOR
-
-CPYDATA	LEA		CCLASTCRSR(A4),A0			;POINT TO SAVED DATA
-		MOVE.L	A2,A1						;GET CURSOR
-		MOVEQ	#7,D0						;MOVE 8 LONGS
-@0		MOVE.L	(A1)+,(A0)+					;MOVE A LONG
-		DBRA	D0,@0						;=>LOOP UNTIL DONE
-
-;  UPDATE THE ROWBYTES AND DEPTH FOR THE EXPANDED DATA
-
-	;	MOVE	D1,(A0)+	;COPY THE DEPTH TOO	<this is the top half of ccID! <BAL 01Apr89>
-		MOVE	D1,CCDEPTH(A4)				;SET DEPTH TO SAY IT'S EXPANDED
-		ADD		D1,D1						;DOUBLE FOR CURSOR'S ROWBYTES
-		MOVE	D1,CCBYTES(A4)				;AND UPDATE ROWBYTES
-
-
-;-----------------------------------------------
-;
-;  EXPAND THE CURSOR TO THE CURRENT DEPTH
-;
-		MOVE.L	A2,A0						;SRC = CURSOR
-		MOVE.L	([CCXDATA,A4]),A1			;POINT TO EXPANDED DATA (LOCKED)
-		MOVE.L	A1,A2						;GET START OF DST BUFFER
-		MOVE	#32,D5						;GET #BYTES OF SOURCE
-		LSL		D7,D5						;MULTIPLY BY DEPTH
-		ADD		D5,A2						;POINT TO END OF BUFFER
-
-		move	d7,d0
-		cmp		#4,d0						;16/32 bits per pixel?				<BAL 28Jun88>
-		blt.s	@1							;no, don't hack depth conversion
-		addq	#2,d0						;get address of spiffy 1 to 15/24 bit expand
-
-@1		move.l	ExTblPtr,A3					;POINT TO ROUTINE TABLE
-		add.l	0(A3,D0*4),A3				;USE DEPTH TO SELECT ROUTINE
-		MOVEQ	#0,D0						;CLEAR HIGH PART OF D0
-		JSR		(A3)						;EXPAND 32*DEPTH BYTES
-
-
-;-----------------------------------------------
-;
-;  EXPAND THE MASK TO THE CURRENT DEPTH
-;
-EXPMASK	LEA		THECRSR+MASK,A0				;SRC = CURSOR MASK
-		MOVE.L	([CCXMASK,A4]),A1			;POINT TO EXPANDED MASK (LOCKED)
-		MOVE.L	A1,A2						;GET START OF DST BUFFER
-		MOVE	#32,D5						;GET #BYTES OF SOURCE			<BAL 14Jun88>
-		LSL		D7,D5						;MULTIPLY BY DEPTH				<BAL 14Jun88>
-		ADD		D5,A2						;POINT TO END OF BUFFER
-
-		move.l	ExTblPtr,A3					;POINT TO ROUTINE TABLE
-		add.l	0(A3,D7*4),A3				;USE DEPTH TO SELECT ROUTINE
-		MOVEQ	#0,D0						;CLEAR HIGH PART OF D0
-		JSR		(A3)						;EXPAND 32*DEPTH BYTES
-
-;-----------------------------------------------
-;
-;  PREPARE TO BLT THE CURSOR ON THE SCREEN IN ANY DEPTH
-;	(SUBTITLE:  WALTZ OF THE REGISTERS)
 ;
-NOEXPAND
-		MOVE.L	([CCXDATA,A4]),d0			;A2 = EXPANDED DATA FOR BLT (LOCKED)
-		_rTranslate24To32					;strip off high byte
-		move.l	d0,a2
-		MOVE.L	([CCXMASK,A4]),d0			;A3 = EXPANDED MASK FOR BLT (LOCKED)
-		_rTranslate24To32					;strip off high byte
-		move.l	d0,a3
-		MOVEQ	#16,D5						;D5 = 16
-
-;-----------------------------------------------
-;
-;  CLIP THE CURSOR VERTICALLY AND GET THE TOP AND BOTTOM INTO D2 AND D3.
-;  IF THE TOP IS CLIPPED, UPDATE THE DATA BASE ADDRESSES IN A2 AND A3.
-;
-		MOVE	MOUSE+V,D2					;MOUSE POSITION Y
-		SUB		CRSRPIN+TOP,D2				;CONVERT TO SCREEN LOCAL COORDS
-		SUB		THECRSR+HOTSPOT+V,D2		; - HOTSPOT = TOP EDGE
-		MOVE	D2,D3						;GET CURSOR BOTTOM
-		ADD		D5,D3						; = TOP + 16
-		CMP		D5,D3						;AT TOP?
-		BGE.S	CHKBOT						;=>NOT AT TOP
-		NEG		D2							;GET NUMBER OF CLIPPED ROWS
-		CMP		D5,D2						;ARE ALL 16 CLIPPED?
-		BEQ		SkipBlit					;=>IF SO, NOTHING TO SHOW
-		MULU	CCBYTES(A4),D2				; * ROWBYTES FOR OFFSET
-		ADD.L	D2,A2						;ADD VERTICAL OFFSET INTO CURSOR
-		ADD.L	D2,A3						;ADD VERTICAL OFFSET INTO MASK
-		MOVEQ	#0,D2						;AND PIN CURSOR TO TOP
-
-CHKBOT	MOVE	COLLINES,D4					;GET BOTTOM OF SCREEN
-		CMP		D4,D3						;PAST BOTTOM?
-		BLE.S	CHKLFT						;=>NO, VERTICAL OK
-		MOVE	D4,D3						;ELSE PIN TO BOTTOM EDGE
-
-
-;-----------------------------------------------
-;
-;  CLIP THE CURSOR HORIZONTALLY AND GET THE LEFT AND RIGHT INTO D0 AND D1
-;  IF THE LEFT OF THE CURSOR IS CLIPPED, ADJUST THE OFFET IN D6.
-
-CHKLFT	MOVEQ	#0,D6						;INIT SRC/DST OFFSET TO 0
-		MOVE	MOUSE+H,D0					;MOUSE POSITION X
-		SUB		CRSRPIN+LEFT,D0				;CONVERT TO SCREEN LOCAL COORDS
-		SUB		THECRSR+HOTSPOT+H,D0		; - HOTSPOT = CURSOR LEFT
-		MOVE	D0,D1						;GET CURSOR RIGHT
-		ADD		D5,D1						; = LEFT + 16
-		CMP		D5,D1						;AT LEFT EDGE?
-		BGE.S	CHKRT						;=>NOT AT LEFT EDGE
-		SUB		D0,D6						;OFFSET = AMOUNT CLIPPED
-		MOVEQ	#0,D0						;AND PIN TO LEFT EDGE
-
-CHKRT	MOVE	ROWBITS,D4					;GET RIGHT EDGE OF SCREEN
-		CMP		D4,D1						;PAST RIGHT EDGE?
-		BLE.S	RTOK						;=>NO, HORIZONTAL OK
-		MOVE	D4,D1						;ELSE PIN TO RIGHT EDGE
-RTOK
-
-;-----------------------------------------------
-;
-;  USE TOP AND LEFT TO CALCULATE THE LONG ALIGNED SCREEN BASE ADDRESS
-
-		MOVE.L	CRSRBASE,A5 				;A5 = POINTER TO BASE OF SCREEN
-		MOVE	CRSRROW,A0					;A0 = SCREEN ROWBYTES
-		MOVE	A0,D4						;COPY FOR MULU
-		MULU	D2,D4						;TOP * ROWBYTES
-		ADD.L	D4,A5						;ADD VERT OFFSET INTO SCREEN
-		ext.l	d0							;make it a long					<BAL 17Jan89>
-		LSL.l	D7,D0						;CONVERT LEFT PIXELS TO BITS
-		MOVE.l	D0,D4						;GET LEFT EDGE
-		AND.l	#~$1F,D4					;LONGWORD ALIGNED
-		MOVE.l	D4,D5						;MAKE A COPY
-		ASR.l	#3,D5						;CONVERT BITS TO BYTES
-		ADD.l	D5,A5						;GET BASE OFFSET IN SCREEN
-
-;-----------------------------------------------
-;
-;  SAVE THE CRSRRECT FOR CURSHIELD
-
-		LEA 	CrsrRect,A1 				;SET UP CRSRRECT
-		MOVE	D2,(A1)+					;TOP
-		MOVE.l	D4,D5						;GET LONG ALIGNED LEFT IN BITS
-		LSR.l	D7,D5						;CONVERT TO PIXELS
-		MOVE	D5,(A1)+					;LONG ALIGNED LEFT
-		MOVE	D3,(A1)+					;BOTTOM
-		MOVE	D5,(A1) 					;RIGHT = LEFT + longcount/pixs in long
-
-	if cursorShadow then
-		add.w	#16,-2(a1)					;grow height for shadow
-		add.w	#16,(a1)					;grow width for shadow
-	endif
-
-SAMELONG
-;-----------------------------------------------
-;
-;  ADJUST DST/SRC OFFSET IN D6
-;  GET NUMBER OF ROWS TO DO IN D3
-;  GET LONGCNT IN D5 AND USE TO ADJUST DSTBUMP IN A0
-
-		AND		#$1F,D0						;GET LEFT EDGE MOD 32
-		LSL		D7,D6						;CONVERT OFFSET TO BITS
-		SUB		D0,D6						; = NEG OFFSET FROM SOURCE
-
-		ext.l	d1							;make it a long					<BAL 17Jan89>
-		LSL.l	D7,D1						;CONVERT RIGHT EDGE TO BITS
-		MOVE.l	D1,D5						;MAKE COPY
-		SUB.l	D4,D5						;GET WIDTH OF CURSOR
-		ble		SkipBlit					;crsr fits in 0 or fewer longs so don't draw
-		subq	#1,d5						;force multiples of 32 to round down
-
-		LSR.l	#5,D5						;GET LONGS-1
-
-		SUB		D2,D3						;D3 = # ROWS TO DO
-		SUBQ	#1,D3						;MAKE IT 0 BASED
-
-		MOVE.l	D5,D2						;GET LONGS
-		ADDQ.l	#1,D2						;MAKE ONE BASED
-		LSL.l	#2,D2						;CONVERT TO BYTES
-		SUB.l	D2,A0						;ADJUST DST BUMP
-
-		lsl.l	#3,d2						;get long aligned bit width
-		lsr.l	d7,d2						;get effective cursr pixel width
-		add		d2,(a1)						;adjust crsrRect.right = left+width
-
-		BSR		CursorSect					;Now then, do we intersect shield?
-		BNE		SkipBlit					;If so, ththat's all.
-
-;-----------------------------------------------
-;
-;  CONVERT LEFT EDGE AND RIGHT EDGE TO LEFTMASK AND RIGHTMASK IN D4 AND D2
-
-		MOVEQ	#-1,D4						;FILL LONG WITH ONES
-		LSR.L	D0,D4						;AND SHIFT IN 0'S FOR LEFTMASK
-
-		MOVEQ	#-1,D2						;FILL LONG WITH ONES
-		AND		#$1F,D1						;GET RIGHT MOD 32
-		beq.s	@1							;does right have a real mask? no, flush it
-		LSR.L	D1,D2						;AND SHIFT 0'S IN FROM RIGHT
-		NOT.L	D2							;GET RIGHTMASK
-
-;-----------------------------------------------
-;
-;  SAVE DSTLEFT/DSTBUMP/LONGCNT/ROWCNT INTO CRSRPTR SO THAT
-;  HIDECURSOR KNOWS HOW MUCH SCREEN TO REPLACE.
-
-@1		LEA		CCBYTES(A4),A6				;POINT TO END OF SAVE STATE AREA
-		MOVE	(A6),A1						;A1 = ROWBYTES FOR EXPANDED CURSOR
-		MOVE.L	([CCSAVE,A4]),d0			;A4 = POINTER TO SAVE AREA (LOCKED)
-		_rTranslate24To32					;strip off high byte
-		move.l	d0,a4
-		MOVEM.L	A5/A0/D5/D3,-(A6)			;SAVE DSTLEFT/DSTBUMP/LONGCNT/ROWCNT
-
-		moveq	#true32b,d0					;switch to 32 bit addressing
-		movem.l	a0-a2,-(sp)					;save off registers
-		_rSwapMMUMode						;get previous mode in d0.b (can trash a0/a2, d0/d2)
-		movem.l	(sp)+,a0-a2					;restore registers
-		move.b	d0,-(sp)					;save previous state for later
-
-		MOVE.L	D5,A6						;SAVE LONGCNT
-		EXT.L	D6							;BFEXTU LIKES LONG OFFSETS
-		MOVE.L	D6,-(SP)					;SAVE OFFSET ON STACK
-		MOVE.L	D4,-(SP)					;SAVE LEFTMASK ON STACK
-
-		;use alternate loop if on Direct Device			<BAL 12 Mar89>
-
-		cmp		#4,d7						;are we 16 or 32 bits/pixel (direct device) ?
-		bge		Direct						;no, don't hack
-
-	if	cursorShadow then
-		cmp		#3,d7
-		beq		Shadow8
-	endif
-
-		TST		D5							;CHECK FOR JUST ONE LONG
-		BRA.S	START						;AND JUMP INTO MIDDLE
-
-;-----------------------------------------------
-;
-;  DISPLAY THE CURSOR AND SAVE THE BITS BEHIND IT (DO THE CURSOR LIMBO!!)
-;
-;  THE FUNNY TRANSFER MODE USED HERE WORKS THE SAME AS BEFORE FOR ONE BIT
-;  MODE, AND SIMILARLY FOR COLOR.  IN COLOR, THE DATA PIXELS WITHIN THE MASK
-;  REPLACE THE DESTINATION;  THE DATA PIXELS OUTSIDE THE MASK ARE XORED WITH
-;  THE DST.  IF THE DATA PIXELS OUTSIDE OF THE MASK ARE BLACK (ALL F'S),
-;  THEN THE DST IS SIMPLY INVERTED.  IF THEY ARE OTHER COLORS, INTERESTING
-;  EFFECTS WILL MANIFEST THEMSELVES.
-;
-;  REGISTER USE:	D0:	SCRATCH			A0:	DSTBUMP
-;					D1:	SCRATCH			A1:	SRCBUMP
-;					D2:	RIGHTMASK		A2:	SRCPTR
-;					D3:	ROWCNT			A3:	MASKPTR
-;					D4:	LEFTMASK		A4:	SAVEPTR
-;					D5:	LONGCNT			A5: DSTPTR
-;					D6:	OFFSET			A6:	COPY LONGCNT
-;					D7:	SCRATCH		   (A7): LEFTMASK
-;									   4(A7): COPY OFFSET
-
-END		AND.L	D2,D4						;AND RIGHTMASK INTO LEFTMASK
-MAIN	BFEXTU	(A2){D6:0},D0				;EXTRACT A LONG OF SRC
-		BFEXTU	(A3){D6:0},D1				;EXTRACT A LONG OF MASK
-		ADD.L	#32,D6						;BUMP TO NEXT LONG
-		AND.L	D4,D0						;AND SRC WITH LEFTMASK
-		AND.L	D4,D1						;AND MASK WITH LEFTMASK
-		MOVE.L	D0,D7						;COPY SRC
-
-		AND.L	D1,D7						;GET MASK AND SRC (PIXELS TO REPLACE)
-		NOT.L	D1							;GET NOTMASK
-		MOVE.L	(A5),d4						;get a long of screen
-		move.l	d4,(A4)+					;SAVE A LONG OF SCREEN
-
-		AND.L	D1,D0						;GET NOTMASK AND SRC (PIXELS TO INVERT)
-		AND.L	d4,D1						;PUNCH HOLE FOR PIXELS TO REPLACE (used to be A5)
-		OR.L	D7,D1						;REPLACE PIXELS WITHIN MASK
-		EOR.L	D0,D1						;INVERT PIXELS OUTSIDE OF MASK
-		MOVE.L	D1,(A5)+					;AND PUT TO DST
-		MOVEQ	#-1,D4						;FLUSH LEFTMASK
-		SUB		#1,D5						;DECREMENT LONGCNT
-START	BGT.S	MAIN						;=>MORE THAN ONE TO DO
-		BEQ.S	END							;=>DO LAST LONG
-		MOVE.L	4(SP),D6					;RESTORE OFFSET
-		MOVE.L	(SP),D4						;RESTORE LEFTMASK
-		ADD.L	A1,A3						;BUMP CURSOR DATA
-		ADD.L	A1,A2						;BUMP CURSOR MASK
-		ADD.L	A0,A5						;BUMP SCREEN POINTER
-		MOVE.L	A6,D5						;RESTORE LONGCNT (TEST D5)
-		DBRA	D3,START					;=>DO NEXT ROW
-
-		bra		DoneBlit
-
-
-Direct
-		bgt.s	Direct32
-
-;-----------------------------------------------
-;
-;  DISPLAY THE CURSOR AND SAVE THE BITS BEHIND IT (DO THE CURSOR LIMBO!!)
-;
-;  THE FUNNY TRANSFER MODE USED HERE WORKS THE SAME AS BEFORE FOR ONE BIT
-;  MODE, AND SIMILARLY FOR COLOR.  IN COLOR, THE DATA PIXELS WITHIN THE MASK
-;  REPLACE THE DESTINATION;  THE DATA PIXELS OUTSIDE THE MASK ARE XORED WITH
-;  THE DST.  IF THE DATA PIXELS OUTSIDE OF THE MASK ARE BLACK (ALL F'S),
-;  THEN THE DST IS SIMPLY INVERTED.  IF THEY ARE OTHER COLORS, INTERESTING
-;  EFFECTS WILL MANIFEST THEMSELVES.
-;
-;  REGISTER USE:	D0:	SCRATCH			A0:	DSTBUMP
-;					D1:	SCRATCH			A1:	SRCBUMP
-;					D2:	RIGHTMASK		A2:	SRCPTR
-;					D3:	ROWCNT			A3:	MASKPTR
-;					D4:	LEFTMASK		A4:	SAVEPTR
-;					D5:	LONGCNT			A5: DSTPTR
-;					D6:	OFFSET			A6:	COPY LONGCNT
-;					D7:	SCRATCH		   (A7): LEFTMASK
-;									   4(A7): COPY OFFSET
-Direct16
-		swap	d4
-
-		addq	#1,d5						;make one based
-		add		d5,d5						;convert longcnt to word cnt
-		move	d5,d0						;save pixel cnt
-		subq	#2,d5						;make zero based - 1
-		move	d5,a6						;save a copy for later scans
-
-		moveq	#-1,d7
-		lsr.w	#1,d7						;make into low15bits mask
-
-		add		d0,d0						;make into byte cnt
-		sub		d0,a1						;make srcRow into srcBump
-
-		asr		#3,d6						;make offset into bytes
-		add		d6,a2						;adjust src ptr
-		add		d6,a3						;adjust mask ptr
-
-@first	tst		d4							;is left pixel masked?
-		bne.s	@MAIN						;no, go to it
-		move.w	(a5)+,(a4)+					;save first pixel
-		addq	#2,a2						;bump past first src pixel
-		addq	#2,a3						;bump past first mask pixel
-		bra.s	@next
-
-@MAIN	move.w	(A2)+,D0					;EXTRACT A LONG OF SRC
-		MOVE.w	(A5),d1						;get a long of screen
-		move.w	d1,(A4)+					;SAVE A LONG OF SCREEN
-		tst.w	(A3)+						;EXTRACT A LONG OF MASK
-		bne.s	@inside
-		not.w	d0							;flip src so that black is all 1's
-		and.w	d7,d0						;mask off high bit
-		beq.s	@skipit						;no use in xoring with zero
-		eor.w	d1,d0						;xor dst with src
-@inside
-		move.w	d0,(a5)
-@skipit	addq	#2,a5
-@next	dbra	D5,@MAIN					;DECREMENT LONGCNT
-
-		tst		d2							;is right pixel masked?
-		bne.s	@last						;no, go to it
-		move.w	(a5)+,(a4)+					;save first pixel
-		addq	#2,a2						;bump past first src pixel
-		addq	#2,a3						;bump past first mask pixel
-		bra.s	@nxtScn
-
-@last	move.w	(A2)+,D0					;EXTRACT A LONG OF SRC
-		MOVE.w	(A5),d1						;get a long of screen
-		move.w	d1,(A4)+					;SAVE A LONG OF SCREEN
-		tst.w	(A3)+						;EXTRACT A LONG OF MASK
-		bne.s	@in
-		not.w	d0							;flip src so that black is all 1's
-		and.w	d7,d0						;mask off high bit
-		beq.s	@skip						;no use in xoring with zero
-		eor.w	d1,d0						;xor dst with src
-@in
-		move.w	d0,(a5)
-@skip	addq	#2,a5
-@nxtScn	ADD.L	A1,A3						;BUMP CURSOR DATA
-		ADD.L	A1,A2						;BUMP CURSOR MASK
-		ADD.L	A0,A5						;BUMP SCREEN POINTER
-		MOVE.L	A6,D5						;RESTORE LONGCNT
-		DBRA	D3,@First					;=>DO NEXT ROW
-		bra		DoneBlit
-
-
-
-
-;-----------------------------------------------
-;
-;  DISPLAY THE CURSOR AND SAVE THE BITS BEHIND IT (DO THE CURSOR LIMBO!!)
-;
-;  THE FUNNY TRANSFER MODE USED HERE WORKS THE SAME AS BEFORE FOR ONE BIT
-;  MODE, AND SIMILARLY FOR COLOR.  IN COLOR, THE DATA PIXELS WITHIN THE MASK
-;  REPLACE THE DESTINATION;  THE DATA PIXELS OUTSIDE THE MASK ARE XORED WITH
-;  THE DST.  IF THE DATA PIXELS OUTSIDE OF THE MASK ARE BLACK (ALL F'S),
-;  THEN THE DST IS SIMPLY INVERTED.  IF THEY ARE OTHER COLORS, INTERESTING
-;  EFFECTS WILL MANIFEST THEMSELVES.
-;
-;  REGISTER USE:	D0:	SCRATCH			A0:	DSTBUMP
-;					D1:	SCRATCH			A1:	SRCBUMP
-;					D2:	RIGHTMASK		A2:	SRCPTR
-;					D3:	ROWCNT			A3:	MASKPTR
-;					D4:	LEFTMASK		A4:	SAVEPTR
-;					D5:	LONGCNT			A5: DSTPTR
-;					D6:	OFFSET			A6:	COPY LONGCNT
-;					D7:	SCRATCH		   (A7): LEFTMASK
-;									   4(A7): COPY OFFSET
-
-	if cursorShadow then
-
-Direct32
-		move	d5,d0						;get a copy of long cnt
-		addq	#1,d0						;make one based
-		lsl		#2,d0						;make into byte cnt
-		sub		d0,a1						;make srcRow into srcBump
-
-		asr		#3,d6						;make offset into bytes
-		add		d6,a2						;adjust src ptr
-		add		d6,a3						;adjust mask ptr
-
-
-voff	equ	4
-hoff	equ	4
-
-;-----------------------------------------------
-;
-;  SAVE DSTLEFT/DSTBUMP/LONGCNT/ROWCNT INTO CRSRPTR SO THAT
-;  HIDECURSOR KNOWS HOW MUCH SCREEN TO REPLACE.
-
-		movem.l	d3/d5/a6/a5/a0,-(sp)
-		MOVE.L	([CRSRPTR]),D0				;GET POINTER TO CURSOR DATA (LOCKED)
-		_rTranslate24To32
-		MOVE.L	D0,A6
-		LEA		CCBYTES(A6),A6				;POINT TO END OF SAVE STATE AREA
-		move.w	mouse,d0					;get vert pos
-		lsr.w	#6,d0
-	;	add.w	#voff,d3
-		add.w	d0,d3
-		move.w	mouse+2,d0					;get horiz pos
-		lsr.w	#6,d0
-	;	add.w	#hoff,d5
-		add.w	d0,d5
-		lsl.w	#2,d0
-	;	sub.w	#hoff*4,a0
-		sub.w	d0,a0
-		MOVEM.L	A5/A0/D5/D3,-(A6)			;SAVE DSTLEFT/DSTBUMP/LONGCNT/ROWCNT
-		MOVE.L	D5,A6						;SAVE LONGCNT
-
-@MAIN2	MOVE.L	(A5)+,d1					;get a long of screen
-		move.l	d1,(a4)+					;save a long of screen
-		dbra	D5,@MAIN2					;DECREMENT LONGCNT
-
-		ADD.L	A0,A5						;BUMP SCREEN POINTER
-		MOVE.L	A6,D5						;RESTORE LONGCNT
-		DBRA	D3,@MAIN2					;=>DO NEXT ROW
-		movem.l	(sp)+,a5/d3/d5/a6/a0
-
-
-		movem.l	d3/a2-a5,-(sp)
-
-	;	moveq	#voff,d0
-		move.w	mouse,d0					;get vert pos
-		lsr.w	#6,d0
-		bra.s	@1
-
-@0		ADD.w	CRSRROW,A5					;offset SCREEN POINTER vertically
-@1		dbra	d0,@0
-
-		move.w	mouse+2,d0					;get horiz pos
-		lsr.w	#6,d0
-		lsl.w	#2,d0
-	;	add.w	#hoff*4,a5
-		add.w	d0,a5
-
-@MAIN1	MOVE.L	(A5),d1						;get a long of screen
-		move.l	(A2)+,d0					;combine A LONG OF src
-		not.l	d0							;interested in nothing , dammit!!@!
-		and.l	$31a,d0						; shit line
-		or.l	(A3)+,d0					;EXTRACT A LONG OF MASK
-		beq.s	@skipit1
-											;d0 = 0
-		moveq	#0,d0						;assume result is black
-		moveq	#$3f,d4						;amount to remove from screen
-		swap	d4							;d4 = $3f0000
-		sub.l	d4,d1						;darken the red channel
-		bcs.s	@pinred
-		move.l	d1,d0						;take the red channel
-@pinred
-		lsr.l	#8,d4
-		sub.w	d4,d1						;darken the grn channel
-		bcs.s	@pingrn
-		move.w	d1,d0						;take the grn channel
-@pingrn
-		lsr.w	#8,d4
-		sub.b	d4,d1						;darken the blu channel
-		bcs.s	@pinblu
-		move.b	d1,d0						;take the blu channel
-@pinblu
-
-		move.l	d0,(a5)
-@skipit1
-		addq	#4,a5
-		dbra	D5,@MAIN1					;DECREMENT LONGCNT
-
-		ADD.L	A1,A3						;BUMP CURSOR DATA
-		ADD.L	A1,A2						;BUMP CURSOR MASK
-		ADD.L	A0,A5						;BUMP SCREEN POINTER
-		MOVE.L	A6,D5						;RESTORE LONGCNT
-		DBRA	D3,@MAIN1					;=>DO NEXT ROW
-
-		movem.l	(sp)+,d3/a2-a5
-
-
-
-@MAIN	move.l	(A2)+,D0					;EXTRACT A LONG OF SRC
-		MOVE.L	(A5),d1						;get a long of screen
-		tst.l	(A3)+						;EXTRACT A LONG OF MASK
-		bne.s	@inside
-		not.l	d0							;flip src so that black is all 1's
-		beq.s	@skipit						;no use in xoring with zero
-		eor.l	d1,d0						;xor dst with src
-@inside
-		move.l	d0,(a5)
-@skipit	addq	#4,a5
-		dbra	D5,@MAIN					;DECREMENT LONGCNT
-
-		ADD.L	A1,A3						;BUMP CURSOR DATA
-		ADD.L	A1,A2						;BUMP CURSOR MASK
-		ADD.L	A0,A5						;BUMP SCREEN POINTER
-		MOVE.L	A6,D5						;RESTORE LONGCNT
-		DBRA	D3,@MAIN					;=>DO NEXT ROW
-		bra		DoneBlit
-
-
-;  REGISTER USE:	D0:	SCRATCH			A0:	DSTBUMP
-;					D1:	SCRATCH			A1:	SRCBUMP
-;					D2:	RIGHTMASK		A2:	SRCPTR
-;					D3:	ROWCNT			A3:	MASKPTR
-;					D4:	LEFTMASK		A4:	SAVEPTR
-;					D5:	LONGCNT			A5: DSTPTR
-;					D6:	OFFSET			A6:	COPY LONGCNT
-;					D7:	SCRATCH		   (A7): LEFTMASK
-;									   4(A7): COPY OFFSET
-Shadow8
-		move	d5,d0						;get a copy of long cnt
-		addq	#1,d0						;make one based
-		lsl		#2,d0						;make into byte cnt
-		sub		d0,a1						;make srcRow into srcBump
-
-		asr		#3,d6						;make offset into bytes
-		add		d6,a2						;adjust src ptr
-		add		d6,a3						;adjust mask ptr
-
-
-;-----------------------------------------------
-;
-;  SAVE DSTLEFT/DSTBUMP/LONGCNT/ROWCNT INTO CRSRPTR SO THAT
-;  HIDECURSOR KNOWS HOW MUCH SCREEN TO REPLACE.
-
-		movem.l	d3/d5/a6/a5/a0,-(sp)
-		MOVE.L	([CRSRPTR]),D0				;GET POINTER TO CURSOR DATA (LOCKED)
-		_rTranslate24To32
-		MOVE.L	D0,A6
-		LEA		CCBYTES(A6),A6				;POINT TO END OF SAVE STATE AREA
-		move.w	mouse,d0					;get vert pos
-		lsr.w	#6,d0						;d0=voff
-	;	add.w	#voff,d3
-		add.w	d0,d3
-		move.w	mouse+2,d0					;get horiz pos
-		lsr.w	#6,d0						;d0=hoff
-	;	add.w	#hoff,d5
-		addq	#3,d0
-		lsr.w	#2,d0						;d0=shadow width longs
-		add.w	d0,d5
-
-		lsl.w	#2,d0
-	;	sub.w	#hoff*4,a0
-		sub.w	d0,a0
-		MOVEM.L	A5/A0/D5/D3,-(A6)			;SAVE DSTLEFT/DSTBUMP/LONGCNT/ROWCNT
-		MOVE.L	D5,A6						;SAVE LONGCNT
-
-;-------------------------------------------
-;	Save bits under cursor/shadow
-;-------------------------------------------
-@MAIN2	MOVE.L	(A5)+,d1					;get a long of screen
-		move.l	d1,(a4)+					;save a long of screen
-		dbra	D5,@MAIN2					;DECREMENT LONGCNT
-
-		ADD.L	A0,A5						;BUMP SCREEN POINTER
-		MOVE.L	A6,D5						;RESTORE LONGCNT
-		DBRA	D3,@MAIN2					;=>DO NEXT ROW
-		movem.l	(sp)+,a5/d3/d5/a6/a0
-
-
-;-------------------------------------------
-;	Draw Shadow
-;-------------------------------------------
-		movem.l	d3/a2-a5,-(sp)
-
-	;	moveq	#voff-1,d0
-		move.w	mouse,d0					;get vert pos
-		lsr.w	#6,d0
-		bra.s	@1
-
-@0		ADD.w	CRSRROW,A5					;offset SCREEN POINTER vertically
-@1		dbra	d0,@0
-
-		move.w	mouse+2,d0					;get horiz pos
-		lsr.w	#6,d0
-		add.w	d0,a5
-	;	add.w	#hoff,a5
-
-@MAIN1	MOVE.l	(A5),d1						;get a long of screen
-		move.l	(A2)+,d0					;combine A LONG OF src
-		or.l	(A3)+,d0					;EXTRACT A LONG OF MASK
-		beq.s	@skipit1
-											;d0 = 0
-		moveq	#0,d0						;assume result is black
-		moveq	#$3f,d4						;amount to remove from screen
-		swap	d4							;d4 = $3f0000
-		sub.l	d4,d1						;darken the red channel
-		bcs.s	@pinred
-		move.l	d1,d0						;take the red channel
-@pinred
-		lsr.l	#8,d4
-		sub.w	d4,d1						;darken the grn channel
-		bcs.s	@pingrn
-		move.w	d1,d0						;take the grn channel
-@pingrn
-		lsr.w	#8,d4
-		sub.b	d4,d1						;darken the blu channel
-		bcs.s	@pinblu
-		move.b	d1,d0						;take the blu channel
-@pinblu
-
-	;	move.l	d0,(a5)
-@skipit1
-		addq	#4,a5
-		dbra	D5,@MAIN1					;DECREMENT LONGCNT
-
-		ADD.L	A1,A3						;BUMP CURSOR DATA
-		ADD.L	A1,A2						;BUMP CURSOR MASK
-		ADD.L	A0,A5						;BUMP SCREEN POINTER
-		MOVE.L	A6,D5						;RESTORE LONGCNT
-		DBRA	D3,@MAIN1					;=>DO NEXT ROW
-
-		movem.l	(sp)+,d3/a2-a5
-
-;-------------------------------------------
-;	Draw cursor atop shadow
-;-------------------------------------------
-
-@MAIN	move.l	(A2)+,D0					;EXTRACT A LONG OF SRC
-		tst.l	(A3)+						;EXTRACT A LONG OF MASK
-		bne.s	@inside
-		tst.l	d0							;flip src so that black is all 1's
-		beq.s	@skipit						;no use in xoring with zero
-		MOVE.L	(A5),d1						;get a long of screen
-		eor.l	d1,d0						;xor dst with src
-@inside
-		move.l	d0,(a5)
-@skipit	addq	#4,a5
-		dbra	D5,@MAIN					;DECREMENT LONGCNT
-
-		ADD.L	A1,A3						;BUMP CURSOR DATA
-		ADD.L	A1,A2						;BUMP CURSOR MASK
-		ADD.L	A0,A5						;BUMP SCREEN POINTER
-		MOVE.L	A6,D5						;RESTORE LONGCNT
-		DBRA	D3,@MAIN					;=>DO NEXT ROW
-
-	else
-
-Direct32
-		moveq	#-1,d4
-		lsr.l	#8,d4						;get low3bytes in d4
-		move	d5,d0						;get a copy of long cnt
-		addq	#1,d0						;make one based
-		lsl		#2,d0						;make into byte cnt
-		sub		d0,a1						;make srcRow into srcBump
-
-		asr		#3,d6						;make offset into bytes
-		add		d6,a2						;adjust src ptr
-		add		d6,a3						;adjust mask ptr
-
-@MAIN	move.l	(A2)+,D0					;EXTRACT A LONG OF SRC
-		MOVE.L	(A5),d1						;get a long of screen
-		move.l	d1,(A4)+					;SAVE A LONG OF SCREEN
-		tst.l	(A3)+						;EXTRACT A LONG OF MASK
-		bne.s	@inside
-		not.l	d0							;flip src so that black is all 1's
-		and.l	d4,d0						;mask off high byte
-		beq.s	@skipit						;no use in xoring with zero
-		eor.l	d1,d0						;xor dst with src
-@inside
-		move.l	d0,(a5)
-@skipit	addq	#4,a5
-		dbra	D5,@MAIN					;DECREMENT LONGCNT
-
-		ADD.L	A1,A3						;BUMP CURSOR DATA
-		ADD.L	A1,A2						;BUMP CURSOR MASK
-		ADD.L	A0,A5						;BUMP SCREEN POINTER
-		MOVE.L	A6,D5						;RESTORE LONGCNT
-		DBRA	D3,@MAIN					;=>DO NEXT ROW
-
-	endif
-
-
-DoneBlit
-		ADDQ	#8,SP						;STRIP LEFTMASK AND OFFSET
-		MOVE.B	#1,CrsrVis					;CURSOR VISIBLE
-
-		moveq	#0,d0
-		move.b	(sp)+,d0					;get previous MMU state in d0
-		_rSwapMMUMode						;restore MMU mode from d0.b
-SkipBlit
-		MOVEM.L (SP)+,D0-D7/A0-A6			;THE WALTZ IS OVER...(TANGO VERY MUCH)
-NoBlit
-		RTS
-
-
-
-;_______________________________________________________________________
-;
-;	UNBLITCURSOR															<dvb 19sep88>
-;
-; This routine unconditionally removes cursor according to the data in
-; CCSTATEREGS.
-; Such things as crsrstate, crsrvis, and other nonsense have already been
-; checked. Vectoring this routine may prove useful for later cursor
-; enhancements.
-
-UNBLITCURSOR	PROC	EXPORT
-		TST.L	CRSRPTR							;CURSOR ALLOCATED?
-		BMI.S	DONEHIDE						;=>NO, JUST RETURN
-		MOVEM.L D1-D4/A0-A2,-(SP)				;SAVE REGS USED
-
-		MOVE.L	([CRSRPTR]),A0					;GET POINTER TO CURSOR SAVE DATA (LOCKED)
-		MOVE.L	CCSAVE(A0),A1					;GET HANDLE TO SAVED BITS
-		MOVE.L	(A1),d0							;POINT TO SAVED BITS
-		_rTranslate24To32						;mask off high byte
-		move.l	d0,a1
-		LEA		CCSTATEREGS(A0),A0				;POINT TO SAVE STATE AREA
-		MOVEM.L	(A0)+,D2/D3/D4/A2				;GET /ROWCNT/LONGCNT/DSTBUMP/DSTLEFT
-
-		moveq	#true32b,d0						;switch to 32 bit mode
-		movem.l	d2/a1/a2,-(sp)					;save off registers
-		_rSwapMMUMode							;get previous mode in d0.b (can trash a0/a2, d0/d2)
-		movem.l	(sp)+,d2/a1/a2					;restore registers
-
-		MOVE.L	D3,A0							;SAVE LONGCNT
-@1		MOVE.L	(A1)+,(A2)+						;RESTORE A LONG OF SOURCE
-		DBRA	D3,@1							;=>DO ENTIRE ROW
-		MOVE.L	A0,D3							;RESTORE LONGCNT
-		ADD		D4,A2							;BUMP DST
-		DBRA	D2,@1							;=>DO FOR ALL LINES
-
-		_rSwapMMUMode							;restore original mode from d0.b
-
-		CLR.B	CRSRVIS 						;MARK IT AS INVISIBLE
-		MOVEM.L (SP)+,D1-D4/A0-A2				;RESTORE REGS USED
-DONEHIDE RTS
 
+_SetCCursor	PROC	EXPORT
+		IMPORT	QDNEW_SETCCURSOR
+		JMP		QDNEW_SETCCURSOR
 
 ;
 ;_______________________________________________________________________
@@ -1976,7 +318,7 @@ DONEHIDE RTS
 ;
 ;	return a pointer to the start of the bit-map display
 ;
-ScrnAddress		PROC	EXPORT
+_ScrnAddress		PROC	EXPORT
 		MOVE.L	ScrnBase,4(SP)			;get screenBase set up by OS
 		RTS 							;that was easy!
 
@@ -1987,7 +329,7 @@ ScrnAddress		PROC	EXPORT
 ;
 ;  return the size of the screen in pixels
 ;
-ScrnSize	PROC	EXPORT
+_ScrnSize	PROC	EXPORT
 		MOVE.L	(SP)+,D0				;get the return address
 		MOVE.L	MainDevice,A0			;get handle to main screen device
 		MOVE.L	(A0),A0					;point to main screen device
diff --git a/QuickDraw/CQD.a b/QuickDraw/CQD.a
--- a/QuickDraw/CQD.a
+++ b/QuickDraw/CQD.a
@@ -50,6 +50,7 @@ PrNonPortable 	EQU 1
 WholeErrors 	EQU 1
 AddrModeFlag 	EQU 0
 Quicker 		EQU 1
+has32BitQD		EQU 1
 
 ROMPaletteMgr	EQU		1	;set to zero for System Disk, 1 for ROM build			<C864>
 
@@ -155,6 +156,7 @@ BlockHead	PROC		EXPORT
 		endif
 				INCLUDE	'BITBLT.a'
 				INCLUDE 'cCrsrCore.a'
+				INCLUDE	'QDExtensions2.a'
 				INCLUDE	'QDUtil.a'
 				INCLUDE	'Colorasm.a'
 				INCLUDE	'Patterns.a'
diff --git a/QuickDraw/CheckDevicesINIT.a b/QuickDraw/CheckDevicesINIT.a
--- a/QuickDraw/CheckDevicesINIT.a
+++ b/QuickDraw/CheckDevicesINIT.a
@@ -221,8 +221,8 @@ SlotParms   EQU     IOPBlk-spBlock.SPBlockSize  ; parameter block for slot manag
 VidParms	EQU		SlotParms-12			; [12] size of mode params
 StartList	EQU		VidParms-4				; [long] pointer to start of resource
 
-VARSIZE		EQU		StartList				; size of local vars for CheckDevices
-UTILVARS	EQU		VidParms				; size of local vars for utility routines
+VARSIZE		EQU		StartList-4				; size of local vars for CheckDevices
+UTILVARS	EQU		VidParms-$30			; size of local vars for utility routines
 
 ; ••• Start of Code •••
 ;
@@ -317,557 +317,42 @@ SetDevGamma
 ; ----------------------------------------------------------------------------------------------------------
 
 
+
+NewFunc
+
+			Link	A6,#-$B4
+			Move.l	A2,-(SP)
+			Move.l	(A0),A2
+
+			Lea.l	-$94(A6),A1
+			Move.l	#-2,(A1)
+
+			Lea.l	-$B4(A6),A0
+			Move.l	A0,$C(A1)
+			Lea.l	-$40(A6),A0
+
+			Move	(A2),$18(A0)
+			Move	#$14,$1A(A0)
+			Move.l	A1,$1C(A0)
+			dc.w	$A205					; _PBStatusImmed
+			Move.l	(SP)+,A2
+			Unlk	A6
+			Rts
+
+
+
 CheckDevices								; <19>: Moved label from within if-endif to embed utility
 											; 	routines.  It would be nice to be able to the the LINK
 											;	stuff AFTER the GotScrn entrypoint.
 
 			LINK	A6,#VARSIZE				; allocate local stack frame
-			MOVEM.L	A0-A6/D0-D7,-(SP)		; so we don’t screw up the boot process
-;+++		MOVEM.L	D6-D7/A2-A4,-(SP)		; save work registers
+			MOVEM.L	A0-A4/D0-D7,-(SP)		; so we don’t screw up the boot process
 
-;+++; check to see if the device list needs to be initialized
-;+++
-;+++		MOVE.L	DeviceList,A0			; get handle to device list
-;+++		MOVE.L	(A0),A0					; point to head of device list
-;+++		MOVE	GDFlags(A0),D0			; get the flags word
-;+++		BTST	#allInit,D0				; test initialize flag?
-;+++		BNE		GoHome					; => devices already initialized
-
-; ••• 1st INIT •••
-;
-; Try to load in the resource.  If none, then just do a SetEntries on the boot device (see
-;	the comments on the NoScrn code below).
-;
-GetScrn
-			CLR.L	-(SP)					; make room for function result
-			MOVE.L	#'scrn',-(SP)			; push desired resource type
-			CLR		-(SP)					; resource ID = 0
-			_GetResource					; get the resource
-			MOVE.L	(SP)+,D0				; get the resource handle
-			Beq.s	NoScrn					; if nil, do the no 'scrn' code
-			
-; ••• 2nd INIT •••
-;
-; Test the scrnInval low-mem to make sure the screen resource is valid. (Note:  scrnInval
-;	will generally be cleared by the video card’s primaryInit IF the information in
-;	pRAM doesn’t match the current set up).  This is ALSO a case where we need to
-;	make a SetEntries call so the screen colors don’t change on the the first SetEntries
-;	and/or SetGamma call.
-;
-ChkScrn		
-			Tst.b	scrnInval				; If the 'scrn' resource is not invalid,
-			Bne.s	GotScrn					;	then just go on.
-						
-			Move.l	D0,A4					; Save the 'scrn' resource handle.
-			
-			Move.l	#gestaltDisplayMgrAttr,D0 ; We need to know if the Display Manager is around.
-			_Gestalt						; Ask, and ye shall receive.
-			Bne.s	@NoDM					; Oops, got an error.
-			Move.l	A0,D0					; Get the result into D0.
-			Btst	#gestaltDisplayMgrPresent,D0 ; If the Display Manager is around, then
-			Bne.s	NoScrn					; don’t dispose of the 'scrn' resource so
-@NoDM										; so that the Display Manager can deal with it.
-			
-			Clr.w	-(Sp)					; Make room for resFile refNum.
-			Move.l	A4,-(Sp)				; Push 'scrn' resource handle for resFile.
-			_HomeResFile					; Get refNum.
-			
-			Move.l	A4,-(Sp)				; Push 'scrn' resource handle for remove.
-			_RmveResource					; Try to remove it.
-			Tst.w	ResErr					; If everything is okay, then
-			Beq.s	@DisposeIt				;	just go on.
-			
-			Tst.w	(Sp)+					; Clean up the stack.
-			Move.l	A4,D0					; Get 'scrn' resource handle back into D0.
-			Bra.s	GotScrn					; And we’re screwed.
-			
-@DisposeIt	Movea.l	A4,A0					; Get 'scrn' resource handle into A0.
-			_DisposHandle					; Dispose it.
-			
-			_UpdateResFile					; Update the 'scrn's resFile lest we die later.
-
-; If a 'scrn' resource is NOT around we’ll get here.  The only thing we want to do at this
-;	point is to call SetDevEntries on the boot device so that the screen will not change colors
-;	after a SetEntries/SetGamma call is made later.
-;
-NoScrn		
 			Move.l	DeviceList,A0			; A0 contains gDevice.
 			Move.l	#-1,A1					; Use gDevice’s PixMap for colorTable.
 			Bsr.s	SetDevEntries			;
 			Bra		NoGammaFix
 
-; ••• 3rd INIT •••
-;
-; Lock down the 'scrn' handle, and point at the data (in A4).
-;
-GotScrn			
-			MOVE.L	DeviceList,A0			; get handle to device list
-			MOVE.L	(A0),A0					; point to head of device list
-			BSET	#allInit,GDFlags(A0)	; say list has been initialized
-
-			MOVE.L	D0,-(SP)				; save 'scrn' resource for ReleaseResource
-			MOVE.L	D0,A0					; get the resource
-			_HLock							; lock it down
-			MOVE.L	(A0),A4					; A4 = resource pointer
-
-; Validate the 'scrn' resource.  There must be a descriptor for every screen device.
-; I assume that there are no duplicate entries and that screens don't overlap.
-; In addition the devices in the 'scrn' resource must be in slot order.
-;
-			MOVE.L	A4,StartList(A6)		; save pointer to start of list
-			MOVE	(A4)+,D7				; get the number of screens in resource
-
-	WITH	spBlock,vpBlock
-
-			LEA		SlotParms(A6),A0		; get pointer to parameter block
-			MOVE.L	#((CatDisplay << 16) ++ TypVideo),spCategory(A0)
-											; set category ID, type
-			MOVE.W	#drSwApple,spDrvrSw(A0)	; set software, hardware ID
-			MOVE.B	#$01,spTBMask(A0)		; ignore spDrvrHw
-			MOVE.B	#0,spSlot(A0)			; start with desired slot (0 to check built-in devices)
-			MOVE.B	#0,spID(A0)				; start with first (zeroth) ID
-			CLR.B	spExtDev(A0)			;
-NxtDev		_sNextTypesRsrc					; get next video device
-			BEQ.S	GotDev					; => there is one
-
-; There are no more screens; are there any more entries in the 'scrn' resource?
-;
-			TST		D7						; there should have been one per device
-			BEQ		GoodRsrc				; => there was, go initialize them
-			BRA 	BadScrn					; 
-
-; Scan through 'scrn' resource entry for this device.
-;
-GotDev		MOVE	(A4)+,D0				; get type
-			CMP		spDrvrHw(A0),D0			; does it match?
-			BNE 	BadScrn					; => nope, bad screen resource
-			MOVE	(A4)+,D0				; get slot
-			CMP.B	spSlot(A0),D0			; does it match?
-			BNE.S	BadScrn					; => nope, bad screen resource
-
-; Get the DCE entry for the device and check dCtlDevBase.
-; If no match, look for other devices in the same slot.
-;
-SlotOK		MOVE	spRefNum(A0),D0			; get the refNum
-			NOT		D0						; refNum to unitnum
-			ASL		#2,D0					; offset in unitTable
-			MOVE.L	UTableBase,A1			; get the base of the unit table
-			MOVE.L	(A1,D0),A3				; A3 = handle to the DCE
-			MOVE.L	(A3),A1					; get pointer to the DCE
-			MOVE.L	dCtlDevBase(A1),D0		; get dCtlDevBase
-			CMP.L	(A4)+,D0				; do they match?
-			BNE.S	BadScrn					; => nope, bad screen resource
-
-; Test to make sure that the requested mode (screen depth) is valid in this video
-;	sRsrc list.
-;
-			MOVE.B	spID(A0),D1				; save the spID (so that it’s correct for the sNextTypesRsrc)
-			MOVE.W	(A4)+,D0				; get the mode
-			MOVE.B	D0,spID(A0)				; insert into spBlock
-			_sFindStruct					; find the sRsrc list entry for this mode
-			BNE.S	BadScrn					; if not, then the scrn resource is no good
-			MOVE.B	D1,spID(A0)				; restore the spID
-
-; To be completely compulsive about it, make sure there's a gDevice.
-;
-			MOVE.L	DeviceList,A3			; A3 = first gDevice in list
-			MOVE	spRefNum(A0),D1			; get refnum (unaffected by sFindStruct)
-@NxtGD		MOVE.L	(A3),A1					; get pointer to device
-			CMP		gdRefNum(A1),D1			; does refnum match?
-			BEQ.S	RectCheck				; => yes, this device matches!
-			MOVE.L	gdNextGD(A1),D0			; get handle of next device
-			MOVE.L	D0,A3					; get in A3
-			BNE.S	@NxtGD					; => check all gDevices
-			BRA.S	BadScrn					; => no such gDevice, bad 'scrn'
-
-; Compare the size of the remembered screenRect to the size of this gDevice's
-;	gdRect.  At this point, the gdRects are still topleft={0,0} from InitGDevice
-; 	so we can just check 'scrn' rect against botRight.
-;
-RectCheck
-			ADD		#8,A4					; skip to global rect in 'scrn'
-			MOVE.W	bottom(A4),D0			; get bottom
-			SUB.W	top(A4),D0				; = height
-			CMP.W	gdRect+bottom(A1),D0	; is it equal?
-			BNE.S	BadScrn					; nope, we're out
-			MOVE.W	right(A4),D0			; get right
-			SUB.W	left(A4),D0				; = width
-			CMP.W	gdRect+right(A1),D0		; is it equal?
-			BNE.S	BadScrn					; nope, we're out
-
-; This device matches!  Go check the next one.
-;
-SkipData	ADD		#8,A4					; skip to control field
-			MOVE	(A4)+,D0				; get number of control calls
-			BRA.S	SkipCtl					; skip control call
-SkipNxt		MOVE.L	(A4)+,D1				; get control code, size of params
-			ADD		D1,A4					; add size of params to skip block
-SkipCtl		DBRA	D0,SkipNxt				; => skip next control
-
-			SUBQ	#1,D7					; decrement device count
-			BMI.S	BadScrn					; => oops, bad screen resource
-			
-			LEA		SlotParms(A6),A0		; get pointer to parameter block <14>
-			BRA.s	NxtDev					; => check next device <19>: .s
-
-;	If the 'scrn' resource is bad, then let's walk down the device list and offset
-;	the invalid screens' gdRects so that they don't all pile up at (0,0).  Let's keep
-;	it simple--just put them all edge-to-edge, with the top edge at 0 (unchanged) and
-;	to the right of the previous guys'.  Offset the gdPMap's rect also.
-;
-BadScrn
-			MOVE.L	DeviceList,A0			; get the head of the list (the boot screen)
-			MOVE.L	(A0),A0					; hndl->ptr
-			MOVE.W	gdRect+right(A0),D1		; get the boot screen's right edge (if the scrn
-											;   is invalid, then this is the real right edge)
-@Loop		MOVE.L	gdNextGD(A0),D0			; get handle to next screen
-			BEQ 	ScrnDone				; when NIL we're out of here <19>: Done -> ScrnDone
-			MOVE.L	D0,A0					; get this device
-			MOVE.L	(A0),A0					; handle to ptr
-			ADD.W	D1,gdRect+left(A0)		; offset the left edge (normally zero)
-			ADD.W	D1,gdRect+right(A0)		; offset the right edge
-			MOVE.L	gdPMap(A0),A1			; get the gdPMap handle
-			MOVE.L	(A1),A1					; get the gdPMap pointer
-			ADD.W	D1,pmBounds+left(A1)	; offset the left edge (normally zero)
-			ADD.W	D1,pmBounds+right(A1)	; offset the right edge
-
-			MOVE.W	gdRect+right(A0),D1		; get the new right edge for the next device
-			BRA.S	@Loop					; for each screen
-
-GoodRsrc	_HideCursor						; cursor must be hidden here
-			MOVE.B	#true,CrsrBusy 			; MARK CHANGE IN PROGRESS
-
-; Configure each entry in the scrn resource
-;
-			MOVE.L	StartList(A6),A4		; save pointer to start of list
-			MOVE	(A4)+,D7				; get the number of screens in resource
-			SUBQ	#1,D7					; make it 0 based
-
-; It would be nice if this routine could use sRsrcInfo or sNextsRsrc here, but we
-;	don't keep the video sRsrc spID in the scrn resource, just the hw ID!!!  To
-;	make up for this, we must do a search by type.
-;
-DoNxt		LEA		SlotParms(A6),A0		; get pointer to parameter block
-			MOVE.L	#((CatDisplay << 16) ++ TypVideo),spCategory(A0)
-											; set category ID, type
-			MOVE.W	#drSwApple,spDrvrSw(A0)	;
-											; set software, (invalid) hardware ID
-			MOVE	(A4)+,spDrvrHw(A0)		; set driver hardware ID
-			MOVE.B	#$00,spTBMask(A0)		; all fields valid
-			MOVE	(A4)+,D0				; get slot
-			MOVE.B	D0,spSlot(A0)			; does it match?
-			MOVE.B	#0,spID(A0)				; start with first ID
-			CLR.B	spExtDev(A0)			;
-			_sNextTypesRsrc					; get next video device
-;+++		BNE 	BadScrn					; => this should never be taken (so let’s comment it out) <12>
-
-; We found a device that matches the given description!  Find its gDevice and configure it.
-;
-			MOVE	spRefNum(A0),D1			; D1 = refnum
-
-			MOVE.L	DeviceList,A3			; A3 = first gDevice in list
-@NxtGD		MOVE.L	(A3),A0					; get pointer to device
-			CMP		gdRefNum(A0),D1			; does refnum match?
-			BEQ.S	@GotGD					; => yes, got the gDevice
-			MOVE.L	gdNextGD(A0),D0			; get handle of next device
-			MOVE.L	D0,A3					; get in A3
-			BNE.S	@NxtGD					; => check all gDevices
-;+++		BRA 	BadScrn					; => this should never be taken (so let’s comment it out) <12>
-
-@GotGD		MOVE.L	(A4)+,D0				; discard dCtlDevBase
-
-; Set up the GDFlags word before calling InitGDevice.
-;
-			MOVE.L	(A3),A1					; point at the grafDevice
-			MOVE	gdFlags(A1),D0			; get the flags word
-			AND		2(A4),D0				; turn off the bits that are used
-			OR		4(A4),D0				; turn on new bits
-			BSET	#ramInit,D0				; say we've initialized it
-			BSET	#screenDevice,D0		; and flag it as a screen device
-			MOVE	D0,GDFlags(A1)			; set the flags word
-
-; If main device, set up low-memory handles.  (Wait:  If the ramInit and screenDevice
-;	flags are NOT setup, then why would the mainScreen flag be setup? -- jmp)
-;
-			MOVE	gdFlags(A1),D0			; get the flags word
-			BTST	#mainScreen,D0			; is it the main scrn?
-			BEQ.S	@InitGD					; => no, go init device
-
-			MOVE.L	A3,MainDevice			; set up as main screen device
-			MOVE.L	A3,TheGDevice			; set up as default destination device
-			MOVE.L	A3,SrcDevice			; set up as default source device
-											; AllocCursor called by InitCursor to init cursor
-			MOVE.L	(A3),A0					; point to gDevice
-			MOVE.L	gdPMap(A0),A0			; get pixMap handle
-			MOVE.L	(A0),A0					; point to pixMap
-			MOVE.L	baseAddr(A0),D0			; get base address
-			MOVE.L	D0,scrnBase				; and set up screen base
-
-			LEA		SlotParms(A6),A0		; point at slot manager block again (it's still positioned from above)
-			MOVE	(A4),D0					; get the requested mode
-			MOVE.B	#oneBitMode,spId(A0)	; pass the default mode (assumed to be 1-bit mode)
-			_sFindStruct					; point to this mode information
-
-			MOVE.B	#mVidParams,spID(A0)	; now get the device pixmap
-			_sGetBlock						; on the current heap (system normally here)
-			MOVE.L	spResult(A0),A1			; get the result pointer
-			MOVE.w	vpRowBytes(A1),screenRow ; get the screen row bytes (WORD)
-
-; Set up the low-mem for screen resolution too.  They’re only WORD/WORD rather then FIXED/FIXED.
-;
-			MOVE.W	vpHRes(A1),ScrHRes		; Take the high word of vpHRes
-			MOVE.W	vpVRes(A1),ScrVRes		; Take the high word of vpVRes
-
-			MOVE.L	spResult(A0),A0			; Do what it says in IM V (p 446) instead of
-			_DisposPtr						;	of using _sDispose. <12>
-
-@InitGD		MOVE	D1,-(SP)				; push refnum
-			MOVE	(A4)+,-(SP)				; push mode
-			CLR		-(SP)					; which should be long
-			MOVE.L	A3,-(SP)				; push gDevice
-			_InitGDevice					; configure the gDevice
-			ADDQ	#4,A4					; mask and flags already used
-
-; If there is a gamma table resource id, get the gamma correction table and call the driver.
-;	We need to do this before setting the color table (via SetEntries) to make sure it takes
-;	effect right away.
-;
-			MOVE	2(A4),D0				; get the gamma table resource id
-			CMP		#-1,D0					; is it -1?
-			BEQ.S	ChkTbl					; => yes, no table
-
-; If the gamma table resource id = -2, then request linear gamma from the driver.
-;
-			CMP		#-2,D0					; is it -2?
-			BNE.S	@GetFromSys				; nope, so load the system resource
-
-;+++		LEA		VidParms(A6),A1			; point to parameter block
-;+++		CLR.L	csGTable(A1)			; pass NIL to tell new drivers to set linear
-;+++		BSR.S	GammaControl			; call a common routine to set gamma
-
-; <19>: Use SetDevGamma instead of GammaControl
-;
-			Move.l	A3,A0					; Put gDevice in A0 for SetDevGamma call.
-			Move.l	#0,A1					; (nil) gammaTable Ptr in A1 (to set linear).
-			Bsr.s	SetDevGamma
-;
-			BRA.S	ChkTbl
-
-; Load the gamma resource from the system and set it.
-;
-@GetFromSys	CLR.L	-(SP)					; make room for function result
-			MOVE.L	#'gama',-(SP)			; push gamma table rsrc type
-			MOVE	D0,-(SP)				; else push resource id
-			_GetResource					; try to read in gamma table
-			MOVE.L	(SP)+,D0				; get the result
-			BEQ.S	ChkTbl					; => couldn't find it, use default
-			MOVE.L	D0,-(SP)				; save a copy for later
-			MOVE.L	D0,A0					; setup for HLock
-			_HLock							;
-			
-;+++		LEA		VidParms(A6),A1			; point to params for SetGamma
-;+++		MOVE.L	(A0),csGTable(A1)		; gamma table pointer is only param
-;+++		BSR.S	GammaControl			; call a common routine
-
-; <19>: Use SetDevGamma instead of GammaControl.  For <23>, the setup for the
-;		SetDevGamma call was backwards.
-;
-			Move.l	(A0),A1					; Put pointer to gammaTable in A1, and
-			Move.l	A3,A0					; 	put pointer to GDevice in A0.
-			Bsr.s	SetDevGamma
-;			
-			MOVE.L	(SP),A0					; get the resource handle back
-			_HUnlock						; free it
-			_ReleaseResource				; and release it (fixing the stack)
-
-; <19>: Commented out GammaControl as it is replaced by the SetDevGamma utility
-;		above.  Also, the branch around the GammaControl routine is commented
-;		out.
-;
-;+++		BRA.S	ChkTbl					; continue on
-;
-; Here's an imbedded utility.  I know I burn 2 bytes always BSRing around it, but I
-;	would burn two with a word branch if the utility were outside.  This routine sets
-;	up the iopb and csParam block for a SetGamma control call.  It expects the csGTable
-;	field to be set up, the csParam block pointer in A1, and the gdevice pointer in A3.
-;
-;GammaControl
-; 			
-; 			LEA		IOPBlk(A6),A0			; point to parameter block
-; 			MOVE.L	A1,csParam(A0)			; move addr of parms into block
-; 			MOVE.W	#cscSetGamma,csCode(A0)	; cscSetGamma <12>
-;+++		CLR.L	ioCompletion(A0)		; no completion routine <16>: not necessary
-;+++		CLR.W	ioVRefNum(A0)			; no volRefNum <16>: not necessary
-; 			MOVE.L	(A3),A1					; point to gdevice
-; 			MOVE	GDRefNum(A1),ioRefNum(A0)	; set device's refnum
-; 			_Control ,IMMED					; SetGamma(GammaTable)
-; 											;   if error here (likely if -2 were passed to
-; 											;	and old driver) then just use default table
-; 			RTS								; and back
-; 
-;
-; Previously, if there was a color table resource id, this part loaded that table.  Now,
-;	it checks the state of the gdDevType bit.  If it is monochrome (=0), then this routine
-;	substitutes pixelSize+32 for the resID.  If it is color (=1) and in 2- or 4-bit mode, then
-;	pixelSize+64 is substituted to yield a modified color table that includes the highlight
-;	color.
-;
-; If we EVER have a gamma ID <> -1 (not default), then be sure to set the color table
-;	to flush this gamma into the CLUT hardware.
-;
-; The pointer to the gDevice is still in A1.
-;
-;
-ChkTbl
-			MOVE.L	(A3),A1					; point to the gDevice again
-			MOVE.L	gdPMap(A1),A0			; get pixmap
-			MOVE.L	(A0),A0					; get pixmap ptr
-			MOVE.W	pmPixelSize(A0),D0		; get depth
-
-			CMP		#clutType,gdType(A1)	; is it a direct/fixed (SKH) device? <SM9>
-			BNE  	SetGRect				; if so, then do nothing <19>:s <SM4> CSS
-
-			BTST	#gdDevType,gdFlags+1(A1)	; is it color or monochrome mode?
-			BNE.S	@ClrMode				; if set, then this is color
-			CMP.W	#2,D0					; 1 or 2 bit/pixel?
-			BLE.S	@RegClr					; don't do anything funky
-@MonoMode
-			ADD		#32,D0					; add 32 to pixelsize in all modes for linear gray
-			BRA.S	@GetClut				;
-@ClrMode
-			MOVE.W	D0,D1					; copy the depth
-			AND		#9,D1					; is it 1- or 8-bit mode?
-			BNE.S	@RegClr					; if so, then do regular behavior
-@Is2or4
-			ADD		#64,D0					; for 2- or 4-bit, add 64 to pixel depth (gives color+highlight)
-;!!!		BRA.S	@GetClut				;
-
-@RegClr
-;!!!		MOVE	(A4),D1					; get the color table resource id
-;!!!		CMP		#-1,D1					; is it -1?
-;!!!		BNE.S	@GetClut				; if not, then set the CLUT
-;!!!		CMP		#-1,2(A4)				; if CLUTid=-1, and gammaID<>-1, then set CLUT to flush
-;!!!		BEQ.S	SetGRect				; if both are default, then continue
-
-@GetClut	CLR.L	-(SP)					; make room for function result
-			MOVE	D0,-(SP)				; push resource id
-			_GetCTable						; get a color table
-			MOVE.L	(SP)+,D0				; get the result
-			BEQ.S	SetGRect				; => couldn't find it, use default
-
-			MOVE.L	D0,A0					; save source handle in A0
-			MOVE.L	(A3),A1					; point at the gDevice
-			MOVE.L	gdPMap(A1),A1			; get handle to its pixMap
-			MOVE.L	(A1),A1					; point at the pixMap
-			MOVE.L	pmTable(A1),A1			; get handle to existing color table
-			MOVE.L	A1,-(SP)				; push the color table for later
-			MOVE.L	A0,-(SP)				; push new table handle for dispose
-
-			_GetHandleSize					; get the source size
-			MOVE.L	D0,D1					; save size in D1
-			EXG		A0,A1					; get dest handle in A0
-			_SetHandleSize					; set the dest handle size
-			EXG		A0,A1					; swap dest back to A1, src to A0
-
-			MOVE.L	(A0),A0					; get source ptr
-			MOVE.L	(A1),A1					; get dst ptr
-			MOVE.L	D1,D0					; get size to move
-			_BlockMove						; copy it
-
-			_DisposCTable					; and dispose new handle
-
-; Now call the driver to set this color table (handle on stack)
-; <19>: Use SetDevEntries call instead of in-line code.
-;
-			Move.l	A3,A0					; A0 contains gDevice.
-			Move.l	(Sp),A1					; A1 contain colorTable Handle
-			Bsr.s	SetDevEntries			;			
-
-;			MOVE.L	(SP),A0					; get handle to color table
-;			_HLock							; lock down the color table
-;			LEA		VidParms(A6),A1			; point to params for SetEntries
-;			MOVE.L	(A0),A0					; get ctabPtr
-;			CLR.W	csStart(A1)				; start at zero, use sequence mode
-;			MOVE.W	ctSize(A0),csCount(A1)	; for the length of the table
-;			LEA		ctTable(A0),A0			; get pointer to colorspecs
-;			MOVE.L	A0,csTable(A1)			; color table pointer is first param
-;			LEA		IOPBlk(A6),A0			; point to parameter block
-;			MOVE.L	A1,csParam(A0)			; move addr of parms into block
-;			MOVE.W	#cscSetEntries,csCode(A0)	; cscSetEntries <12>
-;+++		CLR.L	ioCompletion(A0)		; no completion routine <14>: not necessary
-;+++		CLR.W	ioVRefNum(A0)			; no volRefNum <14>: not necessary
-;			MOVE.L	(A3),A1					; point to gdevice
-;			MOVE	gdRefNum(A1),ioRefNum(A0)	; set device's refnum
-;			_Control ,IMMED					; do a SetEntries on color table
-;			
-;			MOVE.L	(SP),A0					; get handle to color table
-;			_HUnLock						; unlock the color table
-
-; Finally, generate an inverse table for the table (handle on stack)
-;
-			MOVE.L	(A3),A1					; point at the gDevice
-			MOVE.L	gdITable(A1),-(SP)		; push inverse table handle
-			MOVEQ	#4,D0					; make 4-4-4 inverse tables
-			MOVE	D0,gdResPref(A1)		; save in GDevice
-			MOVE	D0,-(SP)				; and push res
-			_MakeITable						; and generate inverse table (color/inverse table handles still on stack)
-
-; Use the specified rectangle to determine the device's global coordinates
-;
-SetGRect
-			ADDA	#4,A4					; skip the CLUT and gamma resID's
-			MOVE.L	(A3),A0					; point to the grafDevice
-			MOVE.L	gdPmap(A0),A1			; get handle to pixMap
-			MOVE.L	(A1),A1					; get pointer to pixMap
-			ADDQ	#bounds,A1				; point to pixMap.bounds
-			LEA		gdRect(A0),A0			; point to its rectangle
-			MOVE.L	(A4)+,D0				; get topLeft for mouse offset
-			MOVE.L	D0,(A1)+				; copy topLeft to pixMap.bounds
-			MOVE.L	D0,(A0)+				; copy topLeft to GDRect
-			MOVE.L	(A4),(A1)				; copy botRight to pixMap.bounds
-			MOVE.L	(A4)+,(A0)+				; copy botRight to GDRect
-
-; Parse and execute the additional control commands
-;
-			MOVE	(A4)+,D6				; get number of control calls
-			BRA.S	ChkNxtCtl				; => jump into end of dbra loop
-DoCtl		LEA		IOPBlk(A6),A0			; point to parameter block
-			LEA		4(A4),A1				; point to call parameters
-			MOVE.L	A1,csParam(A0)			; move addr of parms into block
-			MOVE.W	(A4)+,csCode(A0)		; set control code
-;+++		CLR.L	ioCompletion(A0)		; no completion routine <14>: not necessary
-;+++		CLR.W	ioVRefNum(A0)			; no volRefNum <14>: not necessary
-			MOVE.L	(A3),A1					; point to gdevice
-			MOVE	gdRefNum(A1),ioRefNum(A0)	; set device's refnum
-			_Control ,IMMED					; and issue the control call
-
-			MOVE	(A4)+,D0				; get size of param block
-			ADD		D0,A4					; skip param block
-ChkNxtCtl	DBRA	D6,DoCtl				; loop for all control calls
-
-ChkNxt		DBRA	D7,DoNxt				; loop for all screens in resource
-
-			MOVE.L	MainDevice,a0
-			move.l	a0,CrsrDevice			; cursor is now on main device, no longer on boot device
-
-			import	GetDCtlEntry
-
-			subq	#4,sp					; room for resulting DCE handle
-			move.l	(a0),a0
-			move.w	gdRefnum(a0),-(sp)		; get the refNum
-			jsr		GetDCtlEntry
-			move.l	(sp)+,a0				; get handle to DCE
-			move.l	(a0),a0					; get pointer to DCE
-			move.l	#0,d0					; clear out D0
-			move.b	dCtlSlot(a0),d0			; get the slot number
-			_AttachVBL						; attach VBL to this slot
-
-			CLR.B	CrsrBusy				; end of change
-			_AllocCursor					; make sure all cursor structs are updated
-			_ShowCursor						; now redisplay cursor
-
-ScrnDone	_ReleaseResource				; all done with the resource <19>: Done -> ScrnDone
-
 ; ••• 4th INIT •••
 ;
 ; As explained above in the SixPack update notes, the NoGammaFix is for $067C-class
@@ -879,14 +364,7 @@ ScrnDone	_ReleaseResource				; all done with the resource <19>: Done -> ScrnDone
 ;
 NoGammaFix
 
-			Move.l	ROMBase,A0				; Point to ROMBase with A0.
-  		If Not ForROM Then
-			Cmp.w	#$067C,8(A0)			; If we’re not running on a $67C
- 			Bne		GoHome					; 	ROM, then just go on.
-		Else
-			Cmp.w	#$077D,8(A0)			; If we’re not running on a $77D
-			Bne		GoHome					; 	ROM, then just go on.
-		Endif
+	WITH	spBlock,vpBlock
 
 ; Get the default gamma table from ROM (so we don’t have to get it every time
 ;	we find a card that needs it -- if we don’t find any cards that need
@@ -925,6 +403,15 @@ NoGammaFix
 			Move.l	(A0),A0					; DCE Ptr.
 			
 			Move.b	dCtlSlot(A0),D0			; Save slot number.
+
+			Cmp.b	#15,D0
+			Bcs.b	@dont
+			Move.l	A3,A0
+			Bsr.w	NewFunc
+			Bne.s	@reallyDont
+			Bra.s	@skipGD
+@dont
+
 			Lea		SlotParms(A6),A0		; Fill out SpBlock:
 			Move.b	D0,spSlot(A0)				; 	spSlot		= slot number
 			Clr.w	spID(A0)					;	spID		= 0
@@ -947,6 +434,8 @@ NoGammaFix
 ; We found a non-TFB card that contains no gamma table directory.  So, we need to
 ;	employ our fix, which is to make a SetGamma and then a SetEntries call.
 
+@reallyDont
+
 			Move.l	A2,A0					; Lock down the gammaTable Handle.
 			_Hlock
 			
@@ -969,11 +458,6 @@ NoGammaFix
 			Move.l	A2,A0					; Dispose of the storage used for the
 			_DisposHandle					;	gammaTable Handle.
 			
-GoHome		
-;+++		MOVEM.L	(SP)+,D6-D7/A2-A4		; restore work registers
-			MOVEM.L	(SP)+,A0-A6/D0-D7		; so we don’t screw up the boot process
-			UNLK	A6
-			
 ; ••• 5th INIT •••
 ;
 ;----------------------------------------------------------------
@@ -1139,7 +623,7 @@ DoDrvrPatches
 ;
 ; Save all registers to prevent problems with the ROM INIT running code.
 ;
-				MOVEM.L		A0-A6/D0-D7,-(SP)			; so we don’t screw up the boot process
+				MOVEM.L		A5-A6,-(SP)					; so we don’t screw up the boot process
 
 ;
 ; Point to UnitTable in A2.
@@ -1195,7 +679,12 @@ NxtSlotLoop
 				MOVE.L		(A2,D0*4),A1				; get DCE handle
 				MOVE.L		(A1),A1						; get DCE pointer
 
-				MOVE.L		A1,A4						; save this for driver patching code below
+				MOVE.L		(A1),A4
+				MOVE		dCtlFlags(A1),D0
+				BTST.L		#6,D0
+				BEQ.S		@dont
+				MOVE.L		(A4),A4
+@dont
 
 ;
 ; Point to spBlock.
@@ -1235,13 +724,7 @@ NxtSlotLoop
 ; Take the DCE pointer in A4 (from above), and test to see if we want to patch this driver.
 ;
 @IntPtch
-			If Not ForROM Then
-				BTST		#dRAMBased,dCtlFlags+1(A4)	; test if this is a driver in ROM (Erickson overpatch)	<7.0>
-				BEQ			NxtSlot						; if so, then continue to next slot						<7.0>
-			Endif
-
-				MOVE.L		dCtlDriver(A4),A1			; get handle to driver
-				MOVE.L		(A1),A1						; get pointer to driver
+				MOVE.L		A4,A1						; get pointer to driver
 
 				MOVE.L		drvrName+2(A1),D0			; get a unique long from the name
 				CMP.L		#'DrWV',D0					; is it the 2-Page card?
@@ -1342,201 +825,10 @@ Out				LEA			spBlockSize(SP),SP			; clean up the stack						<SM6>
 ;
 ; Lets restore more registers than have ever been restored before. (Hey, you can never be too careful.)
 ;
-				MOVEM.L	(SP)+,A0-A6/D0-D7				; so we don’t screw up the boot process
+				MOVEM.L	(SP)+,A5-A6
+				MOVEM.L	(SP)+,A0-A4/D0-D7				; so we don’t screw up the boot process
 
-; ••• 6th INIT •••
-;
-			if asINIT then
-;
-; Early in the boot process an _InitGraf was performed (for the Welcome to Mac box).
-;	It's not correct if the main screen moved away from the boot screen, so let's call
-;	InitGraf on these early globals to correct the problem.  This will fix a problem
-;	with the LMgr "init" which didn't do an InitGraf while setting up the environment
-;	for an alert dialog.
-;
-; Note that for the new boot process this is no longer necessary.
-;
-
-				PEA			-4(A5)
-				_InitGraf
-			
-			endif
-
-; ••• 7th INIT •••
-;
-			If Not ForROM Then
-
-;---------------------------------------------------------------------
-;	Local variables, definitions, etc....
-;---------------------------------------------------------------------
-
-drHwDAFB		Equ		$001C						; Built-in Video Hardware ID for Macintosh Quadras 700/900/950.
-DrvrVer950		Equ		$0001						; Version number of the Macintosh Quadra 950’s video driver.
-
-badEntry		Equ		$38							; Location of bad table entry in the Macintosh Quadra 950 driver.
-
-; Straight from the Macintosh Quadra 950 ROM’s source code…
-;
-DAFBVidPrivates	RECORD	0
-saveBaseAddr 	DS.L	1							; the screen base address (NOT ST corrected!)
-saveScreenBase	DS.L	1							; ST corrected version of saveBaseAddr.
-saveSQElPtr 	DS.L	1							; the SQ element pointer (for _SIntRemove)
-saveGammaPtr 	DS.L	1							; the pointer to the Gamma correction table
-saveGamDispPtr	DS.L	1							; the pointer to the Gamma block
-saveVDACBase	DS.L	1							; the base addr of the VDAC
-saveDAFBBase	DS.L	1							; the base addr of the DAFB
-saveVidPtr		DS.L	1							; pointer to a big block of DAFB video parameters
-GFlags			DS.W	1							; flags word
-has16bppACDC	Ds.b	1							; true if AC842A is around
-pageModeSet		Ds.b	1							; true if the pRam PageMode enable bit is set
-saveMode		DS.W	1							; the current mode setting (in lo-byte)
-saveMonID		DS.W	1							; monitor type ID (in lo-byte)
-saveSlotId		DS.W	1							; spID of video sRsrc (hi-order byte only!)
-DAFBVidPrivSize	EQU		*
-				ENDR
-
-; Flags within GFlags word…
-;
-GrayFlag		EQU		15							; luminance mapped if GFlags(GrayFlag) = 1
-IntDisFlag		EQU		14							; interrupts disabled if GFlags(IntFlag) =1
-IsMono			EQU		13							; true if monochrome only display (Portrait/Kong)
-UseSeq			EQU		12							; true if sequence mode SetEntries
-UseTrans		Equ		12							; True if we’re supposed to translate 5-bit into 8 (DAFB 16bpp).
-Is16			EQU		11							; true if 16Mhz (Slow) CPU
-IsSlow			Equ		11							; True if Slow CPU (for DAFB, 25Mhz is slow).
-IsDirect		EQU		10							; true if direct video mode, else chunkyIndexed
-PsuedoIndex		EQU		 9							; true if SetEntries request was mapped to indexed from sequential
-													;	(due to screen depth hardware requirements)
-Has16bppSRsrc	Equ		 9							; True if FifthVidMode is 16bpp instead of 32bpp (DAFB).
-SyncOnGreen		Equ		 8							; True if we’re supposed to put sync on green (DAFB).
-
-
-				bra.s	PatchQuadra950Driver		; skip over the title
-				
-				String	Pascal
-
-DAFBVideoTitle	Dc.b	'.Display_Video_Apple_DAFB'
-				Align	2
-
-;---------------------------------------------------------------------
-;	Main
-;---------------------------------------------------------------------
-
-PatchQuadra950Driver
-				String	AsIs
-				With	SpBlock,DAFBVidPrivates
-				
-Quadra950SaveRegs	Reg		D4-D6					; Define work registers.
-
-			If AsInit Then
-				Cmp.w	#$3FFF,ROM85				; If Color QuickDraw is not around,
-				Bne		@ExitNow					;	then just leave.
-			EndIf
-			
-				Tst.l	DeviceList					; If the device list is empty,
-				Beq		@ExitNow					; 	then just leave.
-				
-				Move.l	DeviceList,A0				; Get the DeviceList Handle.
-				Move.l	(A0),A0						; Make it a pointer.
-				Move.w	gdRefNum(A0),D0				; If there’s no driver, then
-				Beq		@ExitNow					;	we can’t do anything here.
-				
-				Movem.l	Quadra950SaveRegs,-(Sp)		; Save work registers.
-				Suba.w	#spBlockSize,Sp				; Allocate SpBlock 
-
-; The shipping version of the Macintosh Quadra 950’s ROM (1.7F2) has a bug in the built-in video
-; driver which prevents the DirectSetEntries call from working correctly when the attached display
-; is put into 32 bit-per-pixel mode.  To fix this problem, we just patch the bad table in place
-; since it resides in the System heap.
-;
-				Move.l	Sp,A0						; Get spBlock ptr into A0.
-				Clr.b	spId(A0)					; Begin at id 0.
-				Clr.b	spSlot(A0)					; We only care about Slot $0.
-				Clr.b	spExtDev(A0)				; No external device.
-				Clr.b	spTBMask(A0)				; No mask in search.
-				Move.w	#catDisplay,spCategory(A0)	; Look for:	Display,
-				Move.w	#typVideo,spCType(A0)		;  			Video,
-				Move.w	#drSwApple,spDrvrSW(A0)		;  			Apple,
-				Move.w	#drHwDAFB,spDrvrHW(A0)		;  			DAFB.
-				Clr.l	spParamData(A0)				; Look only for enabled sRsrcs.
-				Bset	#foneslot,spParamData+3(A0)	; Limit search to this slot only.
-				_GetTypeSRsrc						; If built-in video is not enabled, then
-				Bne.s	@AllDone					;	just quit.
-				
-; We found the DAFB-based (Macintosh Quadra 700/900/950) built-in video in Slot $0.
-;
-				Moveq	#0,D5						; Prepare D5.
-				Move.w	spRefNum(A0),D5				; Get the refNum.
-				Beq.s	@AllDone					; If nil, then just leave (no driver).
-				Not.w	D5							; Convert the refNum into…
-				Lsl.w	#2,D5						;	…a UTable index.
-				
-				Add.l	UTableBase,D5				; Get a ptr to the AuxDCEHandle.
-				Move.l	D5,A0						; Get it into A0.
-				
-				Move.l	(A0),A0						; Get the AuxDCEHandle.
-				Move.l	(A0),A0						; Get the AuxDCEPtr.
-				Move.l	A0,D5						; Save it for later.
-
-				move.w	dCtlFlags(a0),d0			; <27> Get driver flags
-				Move.l	dCtlDriver(A0),A0			; Get driver.
-				btst	#dRAMBased,d0				; <27> Check to see if dCtlDriver is a handle or a pointer
-				bz.s	@gotDriverPointer			; <27> A ROM based driver means it’s a pointer
-				Move.l	(A0),A0						; Get ptr to driver.
-@gotDriverPointer
-				Move.l	A0,D6						; Save it for later.
-				
-				Moveq	#0,D0						; Prepare D0.
-				Lea		drvrName(A0),A0				; Point to the driver name.
-				Move.l	A0,D4						; Save it for later.
-				Move.b	(A0)+,D0					; Get its length.
-				Swap	D0							; Save it.
-				Lea		DAFBVideoTitle,A1			; Point to the driver name we want.
-				Move.b	(A1)+,D0					; Get its length.
-				_CmpString							; Compare the names.
-				Tst.w	D0							; If they are not equal, then we don’t know about
-				Bne.s	@AllDone					;	this DAFB driver, so just leave.
-				
-				Moveq	#0,D0						; Re-prepare D0.
-				Move.l	D4,A0						; Re-point to the driver name.
-				Move.b	(A0),D0						; Get its length.
-				Addq	#2,D0						; Adjust offset to version field.
-				Bclr	#0,D0						; Adjust offset for word alignment.
-				Move.w	(A0,D0),D4					; Get the driver’s version number.
-				Cmp.w	#DrvrVer950,D4				; If this isn’t the Quadra 950’s driver version,
-				Bne.s	@AllDone					;	then just leave.
-				
-				Adda.w	D0,A0						; Point to version part of driver name.
-				Move.l	A0,D4						; Save it for later.
-
-; We found the Macintosh Quadra 950’s version of the DAFB driver.
-;
-				Move.l	D5,A0						; Re-point to the AuxDCEPtr.
-				Move.l	dCtlStorage(A0),A0			; Get the Handle to DAFB private storage.
-				Move.l	(A0),A0						; Make it a pointer.
-				
-				Btst	#Has16bppSRsrc,GFlags(A0)	; If a 16bpp-capable sRsrc is not in use,
-				Beq.s	@AllDone					;	then just leave.
-
-				Move.l	D6,A0						; Re-point to the DAFB driver.
-				Move.b	#$FF,badEntry(A0)			; Fix the bad table entry.
-				
-				Move.l	D4,A0						; Re-point to the DAFB driver version number.
-				Move.w	#DrvrVer950+1,(A0)			; Update it.
-
-@AllDone
-				Add.w	#spBlockSize,Sp 			; Deallocate SpBlock.
-				Movem.l	(Sp)+,Quadra950SaveRegs		; Restore work registers.
-
-@ExitNow											; Outta here, dudes.
-				Rts
-				
-				Endwith
-				
-			Else
-				
-				Rts
-			
-			Endif
+				UNLK		A6
+				RTS
 
 			END
diff --git a/QuickDraw/ColorMgr.a b/QuickDraw/ColorMgr.a
--- a/QuickDraw/ColorMgr.a
+++ b/QuickDraw/ColorMgr.a
@@ -637,7 +637,7 @@ Seed
 
 		MOVE.L		D5,D4				; copy total # of color (and cleared hi word)
 		SUBQ		#2,D4				; this is the number of colors remaining
-		BLE.S		QVille				; if zero or negative, all done
+		BLT.S		QVille				; if zero or negative, all done
 		MOVEQ		#1,D5				; start at color #1 (zero based)
 @TheRestOfUs							; a temporary label for the rest of us
 		BSR.S		QUtil				; queue it
diff --git a/QuickDraw/ColorQD.make b/QuickDraw/ColorQD.make
--- a/QuickDraw/ColorQD.make
+++ b/QuickDraw/ColorQD.make
@@ -21,6 +21,7 @@ QDPatchesDir	=	{ColorQDDir}Patches:
 
 CQDObjs							=	"{ObjDir}CheckDevicesINIT.a.o"			∂
 									"{ObjDir}CQD.a.o"						∂
+									"{LibDir}MoreCQD.lib"					∂
 									"{ObjDir}DeviceLoop.a.o"
 
 
diff --git a/QuickDraw/DeviceLoop.a b/QuickDraw/DeviceLoop.a
--- a/QuickDraw/DeviceLoop.a
+++ b/QuickDraw/DeviceLoop.a
@@ -105,8 +105,38 @@ LocalSize		EQU		*
 		link	A6, #LocalSize
 		movem.l	D3-D7/A2-A4, callerRegs(A6)	; save the callers registers
 
-		btst	#6, ROM85					; Color QuickDraw available?
-		bnz		@classicQD					; if not, handle old case
+		machine	MC68030
+		move.l	([$2b6],$1fc),a0
+		machine	MC68020
+
+		tst.b	$b5(a0)
+		beq.s	@noShield
+
+		move.l	drawingRgn(a6),d0
+		beq.s	@noConversion
+
+		move.l	d0,a0
+		move.l	(a0),a0
+		move.l	$2(a0),localRect+0(a6)
+		move.l	$6(a0),localRect+4(a6)
+
+		pea		localRect+0(a6)
+		_LocalToGlobal
+
+		pea		localRect+4(a6)
+		_LocalToGlobal
+
+		bra.s	@proceedWithShield
+@noConversion
+
+		move.l	#$80008000,localRect+0(a6)
+		move.l	#$7fff7fff,localRect+4(a6)
+
+@proceedWithShield
+		pea		localRect+0(a6)
+		clr.l	-(sp)
+		_ShieldCursor
+@noShield
 
 		move.l	TheGDevice, D0				; Get the handle to the current GDevice
 		move.l	MainDevice, D1				; Get the handle to the main device
@@ -149,11 +179,11 @@ LocalSize		EQU		*
 		beq		@noMore						; if so, no more devices
 		move.l	(A4), A3					; point at the GDevice record
 		bsr		TestAndIntersect			; is device good for drawing?
-		bz.s	@nextDevice					; if not, keep searching
+		bz		@nextDevice					; if not, keep searching
 
 		move.l	flags(A6), D0				; get the caller’s options
 		btst	#allDevicesBit, D0			; are we ignoring regions?
-		bnz.s	@visRgnSetup				; if so, don’t change the visRgn
+		bnz		@visRgnSetup				; if so, don’t change the visRgn
 
 		move.l	D4, -(SP)					; rectangle region handle
 		pea		localRect(A6)				; this device (local coords)
@@ -175,10 +205,12 @@ LocalSize		EQU		*
 		move.l	ctSeed(A0), D7				; stash device’s ctab seed
 		move.l	flags(A6), D0				; get caller’s flags
 		btst	#singleDevicesBit, D0		; should we group devices?
-		bnz.s	@groupingDone				; if not, don’t call AddSimilar
+		bnz		@groupingDone				; if not, don’t call AddSimilar
 		bsr		AddSimilarDevices			; find all the like devices
 @groupingDone
  		movem.l	D3-D7/A2-A4/A6, -(SP)		; save OUR registers
+		bsr		NewFunc1
+		move	D2,-(SP)
 		swap	D6
 		move.l	D6, -(SP)					; pass depth and flags
 		move.l	A4, -(SP)					; and the GDHandle
@@ -187,6 +219,8 @@ LocalSize		EQU		*
 		movem.l	callerRegs(A6), D3-D7/A2-A4	; restore caller’s registers
 		move.l	A6Link(A6), A6				; and restore caller’s A6
 		jsr		(A0)						; call the drawing procedure
+		move	(SP)+,D2
+		bsr		NewFunc2
 		movem.l	(SP)+, D3-D7/A2-A4/A6		; get OUR register set back
 		move.l	(A4), A3					; fix GDevicePtr
 @nextDevice
@@ -194,13 +228,6 @@ LocalSize		EQU		*
 		addq	#1, D3						; increment device number
 		bra.s	@deviceIntersect			; try this one
 
-@classicQD
-		move.l	A6, -(SP)					; save our stack frame ptr
-		move.w	#1, -(SP)					; pass depth (always 1)
-		move.w	#fakeDeviceFlags, -(SP)		; and gdflags (something reasonable)
-		clr.l	-(SP)						; NIL for GDHandle
-		bra.s	@simpleDeviceCommon
-
 @oneDevice
 		move.l	A6, -(SP)					; save our stack frame ptr
 		move.l	gdPMap(A0), A1				; PixMapHandle
@@ -230,6 +257,17 @@ LocalSize		EQU		*
 		_DisposRgn
 		move.l	savedVis(A6), visRgn(A2)	; put original visRgn back
 @exit
+
+		machine	MC68030
+		move.l	([$2b6],$1fc),a0
+		machine	MC68020
+
+		tst.b	$b5(a0)
+		beq.s	@noShow
+
+		_ShowCursor
+@noShow
+
 		movem.l	callerRegs(A6), D3-D7/A2-A4	; restore regs
 		unlk	A6
 		move.l	(SP)+, A0					; clean stack and return
@@ -252,27 +290,30 @@ AddSimilarDevices
 
 		movem.l	A3-A4/D3/D6, -(SP)			; save original state
 		andi.w	#importantFlagsMask, D6		; keep only pertinent flags
+		move.l	A3, A1
 		move.l	gdNextGD(A3), A4			; start with next device
 		addq	#1, D3						; which is next in number, too
 @addLoop
 		move.l	A4, D0						; is there a GDHandle?
-		bz.s	@noMore						; if NIL, then we’re done
+		bz		@noMore						; if NIL, then we’re done
 
 		move.l	(A4), A3					; handle->ptr
-		bsr.s	TestAndIntersect			; see if device is okay by itself
-		bz.s	@nextDevice					; if not, try next one
+		move.l	A1, -(SP)
+		bsr		TestAndIntersect			; see if device is okay by itself
+		move.l	(SP)+, A1
+		bz		@nextDevice					; if not, try next one
 
 		move.w	gdFlags(A3), D0				; get device attributes
 		andi.w	#importantFlagsMask, D0		; strip unimportant ones
 		cmp.w	D0, D6						; is this device similar to test device?
-		bne.s	@nextDevice					; if not, don’t use it
+		bne		@nextDevice					; if not, don’t use it
 
 		move.l	gdPMap(A3), A0				; get device’s PixMapHandle
 		move.l	(A0), A0					; get device’s PixMapPtr
 		move.l	D6, D0						; get depth and flags
 		swap	D0							; get depth into low word
 		cmp.w	pmPixelSize(A0), D0			; save depth as test device?
-		bne.s	@nextDevice					; if not, don’t use it
+		bne		@nextDevice					; if not, don’t use it
 
 		move.l	flags(A6), D0				; get the option flags
 		btst	#dontMatchSeedsBit, D0		; should we check ctSeeds?
@@ -280,12 +321,49 @@ AddSimilarDevices
 		move.l	pmTable(A0), A0				; handle to color table
 		move.l	(A0), A0
 		cmp.l	ctSeed(A0), D7				; are the seeds the same?
-		bne.s	@nextDevice					; if not, don’t use this one
+		bne		@nextDevice					; if not, don’t use this one
 @seedsChecked
 
+		move.l	A3, A0
+		move.l	$22(A1), D0
+		cmp		$24(A0), D0
+		bgt.s	@L4
+		blt.s	@L1
+		swap	D0
+		cmp		$22(A0), D0
+		bgt.s	@L5
+		blt.s	@L2
+		move.l	$26(A1), D0
+		cmp		$28(A0), D0
+		blt.s	@L6
+		bgt.s	@L3
+		bra.s	@nextDevice
+@L1		swap	D0
+		cmp		$22(A0), D0
+		bgt.s	@doneWhateverThatWas
+@L2		move.l	$26(A1), D0
+		cmp		$28(A0), D0
+		blt.s	@doneWhateverThatWas
+@L3		swap	D0
+		cmp		$26(A0), D0
+		blt.s	@doneWhateverThatWas
+		bra.s	@nextDevice
+@L4		swap	D0
+		cmp		$22(A0), D0
+		blt.s	@doneWhateverThatWas
+@L5		move.l	$26(A1), D0
+		cmp		$28(A0), D0
+		bgt.s	@doneWhateverThatWas
+@L6		swap	D0
+		cmp		$26(A0), D0
+		bgt.s	@doneWhateverThatWas
+		bra.s	@nextDevice
+@doneWhateverThatWas
+
 		move.l	flags(A6), D0				; what are the current options?
 		btst	#allDevicesBit, D0			; are we ignoring drawingRgn?
 		bnz.s	@visRgnSetup				; if so, no regions to setup
+		move.l	A1, -(SP)
 
 		move.l	D4, -(SP)					; rectangle region handle
 		pea		localRect(A6)				; this device (local coords)
@@ -299,6 +377,7 @@ AddSimilarDevices
 		move.l	(SP), -(SP)					; get ORed together
 		_XorRgn								; XOr is a fast way to Union when guaranteed no overlap
 		move.l	(A4), A3					; fix GDevicePtr
+		move.l	(SP)+, A1
 
 @visRgnSetup
 		bset.l	D3, D5						; mark this device done
@@ -347,4 +426,73 @@ TestAndIntersect
 @exit
 		rts
 
+
+NewFunc1
+		moveq	#0, D2
+		move.l	(DeviceList), D0
+		beq.s	@return
+		moveq	#0, D1
+@L0		movea.l	D0, A0
+		movea.l	(A0), A0
+		cmp		D3, D1
+		beq.s	@L8
+		tst		$14(A0)
+		bpl.s	@L8
+		movea.l	(A4), A1
+		move.l	$22(A1), D0
+		cmp		$24(A0), D0
+		bgt.s	@L4
+		blt.s	@L1
+		swap	D0
+		cmp		$22(A0), D0
+		bgt.s	@L5
+		blt.s	@L2
+		move.l	$26(A1), D0
+		cmp		$28(A0), D0
+		blt.s	@L6
+		bgt.s	@L3
+		bra.s	@L7
+@L1		swap	D0
+		cmp		$22(A0), D0
+		bgt.s	@L8
+@L2		move.l	$26(A1), D0
+		cmp		$28(A0), D0
+		blt.s	@L8
+@L3		swap	D0
+		cmp		$26(A0), D0
+		blt.s	@L8
+		bra.s	@L7
+@L4		swap	D0
+		cmp		$22(A0), D0
+		blt.s	@L8
+@L5		move.l	$26(A1), D0
+		cmp		$28(A0), D0
+		bgt.s	@L8
+@L6		swap	D0
+		cmp		$26(A0), D0
+		bgt.s	@L8
+@L7		bclr.s	#7, $14(A0)
+		bset.l	D1, D2
+@L8		addq	#1, D1
+		move.l	$1E(A0), D0
+		bne.s	@L0
+@return	Rts
+
+
+NewFunc2
+		tst		D2
+		beq.s	@return
+		move.l	(DeviceList), D0
+		beq.s	@return
+@L10	move.l	D0, A0
+		move.l	(A0), A0
+		lsr		#1, D2
+		bcc.s	@L11
+		bset.s	#7, $14(A0)
+		tst		D2
+		beq.s	@return
+@L11	move.l	$1E(A0), D0
+		bne.s	@L10
+@return	Rts
+
 		END
diff --git a/QuickDraw/DrawText.a b/QuickDraw/DrawText.a
--- a/QuickDraw/DrawText.a
+++ b/QuickDraw/DrawText.a
@@ -2868,7 +2868,6 @@ renderIt
 		TST.B	needs32bit(A6)				;running 32 bit clean
 		BEQ.S	@skip32						;NOPE, so skip it
 		move.b	MMUsave(a6),d0				;get previous MMU state in d0
-		_rSwapMMUMode						;get previous mode in d0.b (can trash a0/a1/a2, d0/d1/d2)
 		_sbRetrieveGlyph					;Call the routine via SplineDispatch
 		moveq	#true32b,d0					;switch to 32 bit addressing
 		_rSwapMMUMode						;get previous mode in d0.b (can trash a0/a1/a2, d0/d1/d2)
diff --git a/QuickDraw/FastTraps.a b/QuickDraw/FastTraps.a
--- a/QuickDraw/FastTraps.a
+++ b/QuickDraw/FastTraps.a
@@ -1005,7 +1005,7 @@ selectGetGray			equ		25
 
 				MACRO
 				_ZapLinks
-				DoPaletteDispatch selectZapLinks,0
+				DoPaletteDispatch selectZapLinks,4
 				ENDM
 
 				MACRO
@@ -2921,6 +2921,7 @@ _EmptyHandle	OPWORD	$A000+43
 _InitApplZone	OPWORD	$A000+44
 _SetApplLimit	OPWORD	$A000+45
 _BlockMove		OPWORD	$A000+46
+_BlockMoveData	OPWORD	$A000+46+$200
 
 ; Here are the event manager routines
 
diff --git a/QuickDraw/GDevice.a b/QuickDraw/GDevice.a
--- a/QuickDraw/GDevice.a
+++ b/QuickDraw/GDevice.a
@@ -201,8 +201,6 @@ MODE		EQU 	REFNUM-4				; LONG, Mode for video card
 		CMP.L	#-1,D0						; if mode = -1, then don't init			<C769>
 		beq.s	Done						; => go home							<C769>
 
-		CMP.W	#OneBitMode,D0				; is it one bit per pixel?
-		BEQ.S	@Mono						; => yes, default to black and white
 		Bsr		TestForGray					; is it monochrome only?
 		Bne.s	@Mono						; => yes, leave GDevice mono
 		BSET	#GDDevType,GDFlags+1(A3)	; else default to color
@@ -210,7 +208,7 @@ MODE		EQU 	REFNUM-4				; LONG, Mode for video card
 @Mono	MOVE.W	REFNUM(A6),-(SP)			; pass device to initialize
 		MOVE.L	MODE(A6),-(SP)				; pass mode to initialize
 		MOVE.L	A2,-(SP)					; and pass gDevice handle
-		_InitGDevice						; initialize the device port
+		JSR		([$16B8])					; initialize the device port
 
 DONE	MOVE.L	(SP)+,theZone				; restore the zone
 		MOVE.L	A2,RESULT(A6)				; return graf device handle
@@ -364,6 +362,8 @@ oldBaseAddr	DS.B	4						; old base address, for later comparison
 oldPort		DS.B	4						; thePort, before we got here
 oldColor	DS.B	8						; a colorSpec used to reinstantiate fg/bk
 
+			DS.B	356
+
 VARSIZE		DS.B	0						; size of locals
 			ENDR
 
@@ -372,6 +372,13 @@ VARSIZE		DS.B	0						; size of locals
 		LINK	A6,#VARSIZE					; allocate stack frame
 		MOVEM.L	D3/A2-A4,-(SP)				; save off work registers
 
+		MOVE.L	ExpandMem,A0
+		MOVE.L	$1FC(A0),A1
+		TST.B	$B5(A1)
+		BNE.S	@true
+		CLR		$276(A0)
+@true
+
 		MOVE.L	GDH(A6),A0					; get the gDevice handle
 		_HGetState							; get the current lock state
 		MOVE	D0,GDHState(A6)				; save the state
@@ -390,16 +397,13 @@ VARSIZE		DS.B	0						; size of locals
 		BNE.S	@noShield					; no, don't shield cursor
 		BTST	#screenDevice,gdFlags(A2)		; is it screen (check hi byte with #>8)
 		BEQ.S	@noShield
-;+++		PEA		gdRect(A2)
-;+++		CLR.L	-(SP)						; in global coörds
-;+++		_ShieldCursor
-		_HideCursor							; changed to Hide from Shield to fix
-											;   problems when cursor is on the move
-											;   during InitGDevice
+		JSR		([$F48])
+
 @noShield
 
 ; initialize the GDevice's mode and refnum
 
+		SF.B	-$6E(A6)
 		MOVE	REFNUM(A6),GDRefNum(A2) 	; set up RefNum
 		MOVE.L	MODE(A6),D0					; get the mode
 		CMP.L	MinusOne,D0					; is the mode -1?
@@ -415,7 +419,8 @@ VARSIZE		DS.B	0						; size of locals
 		MOVE.L	A1,csParam(A0)				; point to param list
 
 		CMP.L	GDMode(A2),D0				; has the mode changed?
-		BEQ		GrayOrColor					; => no, so don't set depth
+		BEQ.S	GrayOrColor					; => no, so don't set depth
+		ST.B	-$6E(A6)
 		MOVE.L	D0,GDMode(A2)				; set up mode
 
 ; setup the gDevice fields for the new screen depth
@@ -491,97 +496,246 @@ NoTbl
 		MOVEQ	#4,D0						; make 4-4-4 inverse tables
 		MOVE	D0,GDResPref(A2)			; save in GDevice
 		MOVE	D0,-(SP)					; and push res
-		_MakeITable							; and generate table
+		JSR		([$16E4])					; and generate table
 
-;  If this device has not been initialized from the system file, then copy the
-;  bounds from the pixMap to the GDRect.  Otherwise copy the GDRect to the Bounds.
 
 ModeOK
-		LEA		BOUNDS(A3),A0				; point to pixmap.bounds				<C837>
-		LEA		GDRECT(A2),A1				; point to device's global rect
-		MOVE	GDFlags(A2),D0				; get the flags word
-		BTST	#RAMInit,D0					; initialized from RAM?
-		BEQ.S	BndsOK						; => no, copy pixMap.bounds to GDRect
-		EXG		A0,A1						; else copy GDRect to pixMap.bounds
-BndsOK	MOVE.L	(A0)+,(A1)+					; copy topLeft
-		MOVE.L	(A0)+,(A1)+					; copy botRight
-
-; <dvb 3Jan89>
-; if we're about the main device, then fix all those
-; potentially errant ports.
-;
-		TST.B	QDExist						; (Unless QuickDraw don't exist)
-		BNE		@noQD
-		MOVE.L	portList,D1					; or if portlist = 0 or -1
-		BEQ		@noQD
-		ADDQ.L	#1,D1
-		BEQ		@noQD
-
-		BTST	#mainScreen,D0				; is it the main scrn? (flags already in D0)
-		BEQ		@notMain
-
-		PEA		oldPort(A6)					; Save the current port
+		MOVE.L	([$2B6],$1FC),A0
+		TST.B	$B5(A0)
+		BEQ		@L13
+		MOVE	$14(A2),D0
+		BTST.L	#$D,D0
+		BEQ		@L13
+		BTST.L	#$A,D0
+		BEQ		@L13
+		TST		(A2)
+		BEQ		@L13
+		TST.B	-$6E(A6)
+		BEQ		@L13
+		MOVE.L	$22(A2),-$6C(A6)
+		MOVE.L	$26(A2),-$68(A6)
+		TST.B	(QDExist)
+		BNE		@L9
+		MOVE.L	A5,-$7A(A6)
+		LEA.L	-$7E(A6),A5
+		MOVE.L	$6(A3),$22(A2)
+		MOVE.L	$A(A3),$26(A2)
+		MOVE.L	(ScrnBase),-$1BC(A6)
+		MOVE.L	-$58(A6),D1
+		CMP.L	(ScrnBase),D1
+		BNE.S	@L0
+		MOVE	$14(A2),D0
+		BTST.L	#$B,D0
+		BEQ		@L0
+		MOVE.L	(A3),(ScrnBase)
+@L0		PEA.L	-$82(A6)
+		_InitGraf
+		PEA.L	-$1B8(A6)
+		_OpenPort
+		MOVE.L	D2,-(SP)
+		MOVEQ.L	#$0,D1
+		MOVEQ.L	#$1,D2
+		MOVE.L	(DeviceList),D0
+@L1		BEQ.S	@L5
+		MOVE.L	D0,A0
+		CMPA.L	$8(A6),A0
+		MOVE.L	(A0),A0
+		BNE.S	@L2
+		BSET.B	#$7,$14(A0)
+		BNE.S	@L4
+		BRA.S	@L3
+@L2		BTST.B	#$7,$14(A0)
+		BEQ.S	@L4
+		BCLR.B	#$7,$14(A0)
+@L3		OR		D2,D1
+@L4		LSL		#$1,D2
+		MOVE.L	$1E(A0),D0
+		BRA.S	@L1
+@L5		MOVE.L	(SP)+,D2
+		MOVE	D1,-(SP)
+		SUBQ.L	#$4,SP
+		_NewRgn
+		MOVE.L	(SP),-(SP)
+		MOVE.L	(SP),-(SP)
+		PEA.L	$6(A3)
+		_RectRgn
+		LEA.L	-$1B8(A6),A0
+		MOVE.L	$18(A0),-(SP)
+		MOVE.L	(SP),-(SP)
+		_UnionRgn
+		_DisposRgn
+		MOVE	$C(A3),D0
+		SUB		$8(A3),D0
+		MOVE	-$66(A6),D1
+		SUB		-$6A(A6),D1
+		SUB		D1,D0
+		ASR		#$1,D0
+		MOVE	D0,-$1C6(A6)
+		MOVE	$A(A3),D0
+		SUB		$6(A3),D0
+		MOVE	-$68(A6),D1
+		SUB		-$6C(A6),D1
+		SUB		D1,D0
+		ASR		#$1,D0
+		MOVE	D0,-$1C8(A6)
+		MOVE	$8(A3),D0
+		ADD		-$1C6(A6),D0
+		MOVE.L	$6(A3),-$76(A6)
+		MOVE	$A(A3),-$72(A6)
+		MOVE	D0,-$70(A6)
+		PEA.L	-$76(A6)
+		MOVE.L	(A5),A1
+		PEA.L	-$10(A1)
+		_FillRect
+		MOVE	$6(A3),D0
+		ADD		-$1C8(A6),D0
+		MOVE	$C(A3),-$70(A6)
+		MOVE	D0,-$72(A6)
+		PEA.L	-$76(A6)
+		MOVE.L	(A5),A1
+		PEA.L	-$10(A1)
+		_FillRect
+		MOVE	$A(A3),D0
+		SUB		-$1C8(A6),D0
+		MOVE.L	$A(A3),-$72(A6)
+		MOVE	$8(A3),-$74(A6)
+		MOVE	D0,-$76(A6)
+		PEA.L	-$76(A6)
+		MOVE.L	(A5),A1
+		PEA.L	-$10(A1)
+		_FillRect
+		MOVE	$C(A3),D0
+		SUB		-$1C6(A6),D0
+		MOVE	$6(A3),-$76(A6)
+		MOVE	D0,-$74(A6)
+		PEA.L	-$76(A6)
+		MOVE.L	(A5),A1
+		PEA.L	-$10(A1)
+		_FillRect
+		MOVE	(SP)+,D1
+		BEQ.S	@L8
+		MOVE.L	(DeviceList),D0
+@L6		BEQ.S	@L8
+		MOVE.L	D0,A0
+		MOVE.L	(A0),A0
+		LSR		#$1,D1
+		BCC.S	@L7
+		BSET.B	#$7,$14(A0)
+		TST		D1
+		BEQ.S	@L8
+@L7		MOVE.L	$1E(A0),D0
+		BRA.S	@L6
+@L8		PEA.L	-$1B8(A6)
+		_ClosePort
+		MOVE.L	-$1BC(A6),(ScrnBase)
+		MOVE.L	-$6C(A6),$22(A2)
+		MOVE.L	-$68(A6),$26(A2)
+		MOVE.L	-$7A(A6),A5
+@L9		MOVE	D2,-(SP)
+		MOVE.L	$16(A2),A0
+		MOVE.L	(A0),A0
+		MOVE	$4(A0),D0
+		ANDI	#$7FFF,D0
+		MOVE	$A(A0),D1
+		SUB		$6(A0),D1
+		ADD		-$6C(A6),D1
+		SUB		-$68(A6),D1
+		ASR		#$1,D1
+		MULU	D1,D0
+		MOVE	$C(A0),D1
+		SUB		$8(A0),D1
+		ADD		-$6A(A6),D1
+		SUB		-$66(A6),D1
+		ASR		#$1,D1
+		MOVE	$20(A0),D2
+		CMPI	#$8,D2
+		BGT.S	@L11
+		BEQ.S	@L12
+@L10	ASR		#$1,D1
+		ASL		#$1,D2
+		CMPI	#$8,D2
+		BLT.S	@L10
+		BRA.S	@L12
+@L11	ASR		#$3,D2
+		MULU	D2,D1
+@L12	EXT.L	D1
+		ADD.L	D1,D0
+		ADD.L	D0,(A0)
+		MOVE	(SP)+,D2
+@L13	LEA.L	$6(A3),A0
+		LEA.L	$22(A2),A1
+		MOVE	$14(A2),D0
+		BTST.L	#$A,D0
+		BEQ.S	@L14
+		EXG.L	A0,A1
+@L14	MOVE.L	(A0)+,(A1)+
+		MOVE.L	(A0)+,(A1)+
+		TST.B	(QDExist)
+		BNE		@L20
+		MOVE.L	(PortList),D1
+		BEQ		@L20
+		ADDQ.L	#$1,D1
+		BEQ		@L20
+		BTST.L	#$B,D0
+		BEQ		@L19
+		PEA.L	-$5C(A6)
 		_GetPort
-		MOVE.L	mainDevice,theGDevice		; and set to the screen
-
-		MOVE.L	PortList,A4					; A4 = handle to list of ALL ports
-		MOVE.L	(A4),A4						; A4->list of all ports
-		MOVE	(A4),D3					; D3 = number of ports that exist
-		BRA.S	@portWalkEnd
-
-@portWalkLoop
-		MOVE.L	PortList,A4
+		MOVE.L	(MainDevice),(TheGDevice)
+		MOVE.L	(PortList),A4
 		MOVE.L	(A4),A4
-		MOVE.L	2(A4,D3.W*4),A4					; A4 = this port
-		MOVE.L	A4,-(SP)						; Set to each port in the port list
+		MOVE	(A4),D3
+		BRA.S	@L17
+@L15	MOVE.L	(PortList),A4
+		MOVE.L	(A4),A4
+		MOVE.L	$2(A4,D3.W*4),A4
+		MOVE.L	A4,-(SP)
 		_SetPort
-
-		MOVE.L	oldBaseAddr(A6),D1				; D1 = the scrnbase of ports to change
-		BTST	#7,portVersion(A4)				; high bit set?
-		BEQ.S	@oldPort
-		MOVE.L	portPixMap(A4),A4				; A4 = handle to the port's pixmap
-		MOVE.L	(A4),A4							; A4->port's pixmap
-		CMP.L	baseAddr(A4),D1					; same as the screen's?
-		BNE.S	@portWalkEnd				 	; no, skip this port
-
-		MOVE.L	baseAddr(A3),baseAddr(A4)		; replace a bunch of fields
-		MOVE	rowBytes(A3),rowBytes(A4)
-		MOVE.L	pixelType(A3),pixelType(A4)		; (gets pixelSize, too)
-		MOVE.L	cmpCount(A3),cmpCount(A4)		; (gets cmpSize, too)
-		MOVE.L	planeBytes(A3),planeBytes(A4)
-
-		PEA		oldColor(A6)					; placeholder for reinstantiating colors
+		MOVE.L	-$58(A6),D1
+		BTST.B	#$7,$6(A4)
+		BEQ.S	@L16
+		MOVE.L	$2(A4),A4
+		MOVE.L	(A4),A4
+		CMP.L	(A4),D1
+		BNE.S	@L17
+		MOVE.L	(A3),(A4)
+		MOVE	$4(A3),$4(A4)
+		MOVE.L	$1E(A3),$1E(A4)
+		MOVE.L	$22(A3),$22(A4)
+		MOVE.L	$26(A3),$26(A4)
+		PEA.L	-$64(A6)
 		MOVE.L	(SP),-(SP)
 		MOVE.L	(SP),-(SP)
 		MOVE.L	(SP),-(SP)
-		_SaveFore								; Save and restore the foreground color
-		_RestoreFore							; (Allowing for pmFore)
-		_SaveBack								; And the same for the background
+		_SaveFore
+		_RestoreFore
+		_SaveBack
 		_RestoreBack
- 		BRA.S	@portWalkEnd
-
-@oldPort
-		CMP.L	portBits+baseAddr(A4),D1		; same base on old port?
-		BNE.S	@portWalkEnd
-		MOVE.L	baseAddr(A3),portBits+baseAddr(A4)
-		MOVE	rowBytes(A3),D1
-		AND		#nurbMask,D1					; handle NURBs here
-		MOVE	D1,portBits+rowBytes(A4)
-
-@portWalkEnd
-		DBRA	D3,@portWalkLoop
-		MOVE.L	oldPort(A6),-(SP)				; restore the pre-existing port
+		BRA.S	@L17
+@L16	CMP.L	$2(A4),D1
+		BNE.S	@L17
+		MOVE.L	(A3),$2(A4)
+		MOVE	$4(A3),D1
+		ANDI	#$7FFF,D1
+		MOVE	D1,$6(A4)
+@L17	DBF		D3,@L15
+		MOVE.L	-$5C(A6),-(SP)
 		_SetPort
-
-		MOVE.L	oldBaseAddr(A6),D1
-		CMP.L	scrnBase,D1						; fix scrnBase too, if neede
-		BNE.S	@notMain
-		MOVE.L	baseAddr(A3),scrnBase
-
-@notMain
+		MOVE.L	-$58(A6),D1
+		CMP.L	(ScrnBase),D1
+		BNE.S	@L18
+		MOVE.L	(A3),(ScrnBase)
+@L18	MOVE.L	-$58(A6),D1
+		MOVE.L	(A5),A0
+		CMP.L	-$7A(A0),D1
+		BNE.S	@L19
+		MOVE.L	(A3),-$7A(A0)
+@L19	BTST.B	#$D,$14(A2)
+		BEQ.S	@L20
 		_AllocCursor
 		_ShowCursor
-@noQD
+@L20	BSR.S	NewFunc
+		MOVE.L	(ExpandMem),A0
+		MOVE	D0,$276(A0)
 
 ;
 ; notify the Palette Manager that the mode has changed
@@ -605,6 +759,62 @@ BndsOK	MOVE.L	(A0)+,(A1)+					; copy topLeft
 		UNLINK	result-return-4,'INITGDEV'
 
 
+NewFunc
+			MOVE.L	(TheGDevice),D0
+			BEQ		@L32
+			MOVE.L	(MainDevice),D1
+			CMP.L	D0,D0
+			BNE.S	@L22
+			MOVE.L	(DeviceList),D0
+			BEQ.S	@L32
+@L22		MOVE.L	D0,A0
+			MOVE.L	(A0),A0
+			MOVE.L	$1E(A0),D1
+			BEQ.S	@L32
+@L23		MOVE.L	D1,A1
+			MOVE.L	(A1),A1
+			MOVE.L	$22(A1),D0
+			CMP		$24(A0),D0
+			BGT.S	@L27
+			BLT.S	@L24
+			SWAP	D0
+			CMP		$22(A0),D0
+			BGT.S	@L28
+			BLT.S	@L25
+			MOVE.L	$26(A1),D0
+			CMP		$28(A0),D0
+			BLT.S	@L29
+			BGT.S	@L26
+			BRA.S	@L30
+@L24		SWAP	D0
+			CMP		$22(A0),D0
+			BGT.S	@L31
+@L25		MOVE.L	$26(A1),D0
+			CMP		$28(A0),D0
+			BLT.S	@L31
+@L26		SWAP	D0
+			CMP		$26(A0),D0
+			BLT.S	@L31
+			BRA.S	@L30
+@L27		SWAP	D0
+			CMP		$22(A0),D0
+			BLT.S	@L31
+@L28		MOVE.L	$26(A1),D0
+			CMP		$28(A0),D0
+			BGT.S	@L31
+@L29		SWAP	D0
+			CMP		$26(A0),D0
+			BGT.S	@L31
+@L30		MOVEQ.L	#$1,D0
+			RTS
+@L31		MOVE.L	$1E(A1),D1
+			BNE.S	@L23
+			MOVE.L	$1E(A0),D0
+			BNE.S	@L22
+@L32		MOVEQ.L	#$0,D0
+			RTS
+
+
 GetDevPixMap	PROC	EXPORT
 				IMPORT	CopyHandle, GetCTSeed, RSetHSize
 ;----------------------------------------------------------------
@@ -627,7 +837,7 @@ DEVTYPE		EQU		PMH-4					; LONG, VAR DevType
 
 MYBLOCK		EQU		-spBlock.SPBLOCKSIZE	; allocate room for parameter block	<Cxxx>
 PMHState	EQU		MyBlock-2				; save pixMap lockState
-VARSIZE		EQU		PMHState				; size of locals
+VARSIZE		EQU		PMHState-$9A			; size of locals
 
 	WITH	spBlock,vpBlock					;<C742>
 
@@ -636,6 +846,7 @@ VARSIZE		EQU		PMHState				; size of locals
 
 ; lock down the pixMap and get pointer in A2
 
+			CLR.B	-$D3(A6)
 			MOVE.L	PMH(A6),A0					; get handle to pixMap
 			_HGetState							; get the current state
 			MOVE	D0,PMHState(A6)				; save current state
@@ -651,6 +862,46 @@ VARSIZE		EQU		PMHState				; size of locals
 			MOVE.L	(A1,D0),A3					; A3 = handle to the DCE
 			MOVE.L	(A3),A1						; get pointer to the DCE
 
+			LEA.L	-$D2(A6),A4
+			LEA.L	-$82(A6),A0
+			MOVE.L	A4,$1C(A0)
+			MOVE	$18(A1),$18(A0)
+			MOVE	#$A,$1A(A0)
+			CLR.L	$C(A0)
+			CLR.L	$12(A0)
+			CLR		$16(A0)
+			DC.W	$A205						; _PBStatusImmed
+			BNE.S	@nope
+			MOVE.L	$2(A4),-$3E(A6)
+			MOVE.L	$8(A4),-$42(A6)
+			MOVE.L	$2A(A1),D3
+			LEA.L	-$AC(A6),A0
+			LEA.L	-$C2(A6),A4
+			MOVE.L	A0,$6(A4)
+			MOVE.L	$10(A6),D0
+			MOVE	D0,$4(A4)
+			MOVE.L	-$3E(A6),(A4)
+			LEA.L	-$82(A6),A0
+			MOVE.L	A4,$1C(A0)
+			MOVE	$14(A6),$18(A0)
+			MOVE	#$12,$1A(A0)
+			CLR.L	$C(A0)
+			CLR.L	$12(A0)
+			CLR		$16(A0)
+			DC.W	$A205						; _PBStatusImmed
+			BNE.S	@nope
+			LEA.L	-$C2(A6),A4
+			MOVE.B	#$1,-$D3(A6)
+			MOVE.L	-$42(A6),D3
+			MOVE.L	D3,$2A(A1)
+			MOVE.L	$8(A6),A1
+			MOVE.L	$E(A4),D4
+			MOVE	D4,(A1)
+			LEA.L	-$38(A6),A0
+			LEA.L	-$AC(A6),A1
+			BRA.S	@saveVals
+@nope
+
 ; get the resource list for the specified device
 
 			LEA		MYBLOCK(A6),A0				; point to parameter block
@@ -687,6 +938,7 @@ VARSIZE		EQU		PMHState				; size of locals
 			BNE		BadSlot						; => something wrong
 			MOVE.L	spResult(A0),A1				; save the pointer to the block			<C742>
 
+@saveVals
 			ADD.L	vpBaseOffset(A1),D3			; calculate baseAddr
 			MOVE.L	D3,(A2)+					; save baseAddr
 
@@ -731,11 +983,13 @@ VARSIZE		EQU		PMHState				; size of locals
 
 			MOVE.L	vpPlaneBytes(A1),(A2)+		; offset from one plane to another		<C742>
 
-
 ; dispose of the sBlock																	<C742>
+			TST.B	-$D3(A6)
+			BNE.S	@dont
 			MOVE.L	A1,spsPointer(A0)			;										<C742>
-			_sDisposePtr						;										<C742>
+			_SDisposePtr						;										<C742>
 			MOVE.L	A4,spsPointer(A0)			; restore pointer to list				<C742>
+@dont
 
 ; use DevType to initialize the color table
 
@@ -748,14 +1002,14 @@ VARSIZE		EQU		PMHState				; size of locals
 
 GetClut		CLR.L	-(SP)						; make room for function result
 			MOVE	D5,-(SP)					; push resource ID
-			_GetCTable							; load in the color table resource
+			JSR		([$1660])					; load in the color table resource
 			MOVE.L	(SP)+,D0					; did we get one?						<C769>
 			BEQ		TableOK						; => no, just punt						<BAL 04Sep88>
 			MOVE.L	D0,-(SP)					; push new handle for dispose			<C1/9>
 			MOVE.L	D0,-(SP)					; push source handle					<C1/9>
 			MOVE.L	(A2),-(SP)					; push destination handle				<C1/9>
-			_CopyHandle							; copy table into our handle			<C1/9>
-			_DisposCTable						; and dispose of new color table		<C1/9>
+			JSR		([$1A14])					; copy table into our handle
+			JSR		([$1690])					; and dispose of new color table
 			BRA.S	TableOK						; => and continue
 
 ;
@@ -788,10 +1042,11 @@ GetFromSlot	MOVE.B	#mTable,spID(A0)			; the fixed table							<2.3>
 			CMPI.L	#minSeed,D0					; is it a resource ID?						<H2>
 			BLE.S	@UseOriginalSeed			; -> yes, assume we know what we're doing	<H2>
 @GetNewSeed	SUBQ	#4,SP						; make room for function result				<2.3>
-			_rGetCTSeed							; get a new, unique ctable seed				<2.3>
+			JSR		([$16A0])					; get a new, unique ctable seed
 			MOVE.L	(SP)+,ctSeed(A1)			; put in the new seed						<2.3>
 @UseOriginalSeed
 												;   transindex/ctflags set below			<2.3>
+
 ;••• <SM3> CSS end rollin GetDevPixMapPatch from Horror
 
 			MOVE.L	A4,spsPointer(A0)			; Restore the pointer to mode list.			<C742>
@@ -868,472 +1123,7 @@ CheckDevices	PROC	EXPORT
 ;  CheckDevices is called by InitGraf.
 
 
-PARAMSIZE	EQU		0
-
-IOPBlk		EQU		-IOVQElSize				; [64] parameter blk for I/O calls
-SlotParms   EQU     IOPBlk-spBlock.SPBlockSize  ; parameter block for slot manager calls <Cxxx>
-VidParms	EQU		SlotParms-12			; [12] size of mode params
-StartList	EQU		VidParms-4				; [long] pointer to start of resource
-VARSIZE		EQU		StartList				; size of locals
-
-
-			LINK	A6,#VARSIZE				; allocate local stack frame
-			MOVEM.L	D6-D7/A2-A4,-(SP)		; save work registers
-
-; check to see if the device list needs to be initialized
-
-			MOVE.L	DeviceList,A0			; get handle to device list
-			MOVE.L	(A0),A0					; point to head of device list
-			MOVE	GDFlags(A0),D0			; get the flags word
-			BTST	#AllInit,D0				; test initialize flag?
-			BNE		GoHome					; => devices already initialized
-
-; test the scrnInval lo-mem to make sure the screen resource is valid.
-
-			TST.B	scrnInval				; if this byte is cleared, then invalid
-			BEQ		GoHome					;
-
-; try to load in the resource.  If none, then exit
-
-			CLR.L	-(SP)					; make room for function result
-			MOVE.L	#'scrn',-(SP)			; push desired resource type
-			CLR		-(SP)					; resource ID = 0
-			_GetResource					; get the resource
-			MOVE.L	(SP)+,D0				; get the resource handle
-			BEQ		GoHome					; => none, don't configure
-
-; lock down the handle, and point at the data
-
-			MOVE.L	DeviceList,A0			; get handle to device list
-			MOVE.L	(A0),A0					; point to head of device list
-			BSET	#AllInit,GDFlags(A0)	; say list has been initialized
-
-			MOVE.L	D0,-(SP)				; save resource for ReleaseResource
-			MOVE.L	D0,A0					; get the resource
-			_HLock							; lock it down
-			MOVE.L	(A0),A4					; A4 = resource pointer
-
-; validate the 'scrn' resource.  There must be a descriptor for every screen device.
-; I assume that there are no duplicate entries and that screens don't overlap.
-; In addition the devices in the 'scrn' resource must be in slot order.
-
-			MOVE.L	A4,StartList(A6)		; save pointer to start of list
-			MOVE	(A4)+,D7				; get the number of screens in resource
-
-	WITH	spBlock,vpBlock
-
-			LEA		SlotParms(A6),A0				; get pointer to parameter block
-			MOVE.L	#((CatDisplay << 16) ++ TypVideo),spCategory(A0)	;<C741>
-											; set category ID, type		<C741>
-			MOVE.W	#DrSwApple,spDrvrSw(A0)	; set software, hardware ID	<C741>
-			MOVE.B	#$01,spTBMask(A0)		; ignore spDrvrH
-			MOVE.B	#0,spSlot(A0)			; start with desired slot
-			MOVE.B	#0,spID(A0)				; start with first ID
-			CLR.B	spExtDev(A0)			;<C720>
-NxtDev		LEA		SlotParms(A6),A0		; get pointer to parameter block
-			_sNextTypesRsrc					; get next video device
-			BEQ.S	GotDev					; => there is one
-
-; there are no more screens, are there more resources?
-
-			TST		D7						; there should have been one per device
-			BEQ 	GoodRsrc				; => there was, go initialize them
-			BRA.S	BadScrn					;
-
-; scan through scrn resource for this device
-
-GotDev		MOVE	(A4)+,D0				; get type
-			CMP		spDrvrHw(A0),D0			; does it match?
-			BNE.S	badScrn					; => nope, bad screen resource
-			MOVE	(A4)+,D0				; get slot
-			CMP.B	spSlot(A0),D0			; does it match?
-			BNE.S	badScrn					; => nope, bad screen resource
-
-; get the DCE entry for the device and check dCtlDevBase
-; if no match look for more devices in same slot
-
-SlotOK		MOVE	spRefNum(A0),D0			; get the refNum
-			NOT		D0						; refNum -> unitnum
-			ASL		#2,D0					; get offset in unitTable
-			MOVE.L	UTableBase,A1			; get the base of the unit table
-			MOVE.L	(A1,D0),A3				; A3 = handle to the DCE
-			MOVE.L	(A3),A1					; get pointer to the DCE
-			MOVE.L	dCtlDevBase(A1),D0		; get dCtlDevBase
-			CMP.L	(A4)+,D0				; do they match?
-			BNE.S	badScrn					; => nope, bad screen resource
-
-; to be completely compulsive about it, make sure there's a grafDevice for it
-
-			MOVE.L	DeviceList,A3			; A3 = first grafdevice in list
-			MOVE	spRefNum(A0),D1			; get refnum
-@NxtGD		MOVE.L	(A3),A1					; get pointer to device
-			CMP		GDRefNum(A1),D1			; does refnum match?
-			BEQ.S	RectCheck				; => yes, this device matches!
-			MOVE.L	GDNextGD(A1),D0			; get handle of next device
-			MOVE.L	D0,A3					; get in A3
-			BNE.S	@NxtGD					; => check all grafDevices
-			BRA.S	badScrn					; => no such grafDevice, bad 'scrn'
-
-;
-; compare the size of the remembered screen rect to the size of this gDevice's
-;	gdRect.  At this point, the GDRects are still topleft=(0,0) from InitGDevice
-; 	so we can just check 'scrn' rect against botRight.
-
-RectCheck
-			ADD		#10,A4					; skip to global rect in scrn
-			MOVE.W	bottom(A4),D0			; get bottom
-			SUB.W	top(A4),D0				; = height
-			CMP.W	GDRect+bottom(A1),D0	; is it equal?
-			BNE.S	badScrn					; nope, we're out
-			MOVE.W	right(A4),D0			; get right
-			SUB.W	left(A4),D0				; = width
-			CMP.W	GDRect+right(A1),D0		; is it equal?
-			BNE.S	badScrn					; nope, we're out
-
-; this device matches!  go check next one
-
-SkipData	ADD		#8,A4					; skip to control field
-			MOVE	(A4)+,D0				; get number of control calls
-			BRA.S	SkipCtl					; skip control call
-SkipNxt		MOVE.L	(A4)+,D1				; get control code, size of params
-			ADD		D1,A4					; add size of params to skip block
-SkipCtl		DBRA	D0,SkipNxt				; => skip next control
-
-			SUBQ	#1,D7					; decrement device count
-			BMI.S	badScrn					; => oops, bad screen resource
-			BRA		NxtDev					; => check next device
-
-BadScrn
-;	If the screen resource is bad, then let's walk down the device list and offset
-;	the invalid screens' GDRects so that they don't all pile up at (0,0).  Let's keep
-;	is simple- I just put them all edge to edge, top edge at 0 (unchanged) and to the
-;	right of the previous guys.  Offset the GDPMap's rect also.
-
-			MOVE.L	DeviceList,A0			; get the head of the list (the boot screen)
-			MOVE.L	(A0),A0					; hndl->ptr
-			MOVE.W	GDRect+right(A0),D1		; get the boot screen's right edge (if the scrn
-											;   is invalid, then this is the real right edge)
-@Loop		MOVE.L	GDNextGD(A0),D0			; get handle to next screen
-			BEQ 	Done					; if NIL, then we're out of here
-			MOVE.L	D0,A0					; get this device
-			MOVE.L	(A0),A0					; hndl->ptr
-			ADD.W	D1,GDRect+left(A0)		; offset the left edge (normally zero)
-			ADD.W	D1,GDRect+right(A0)		; offset the right edge
-			MOVE.L	gdPMap(A0),A1			; get the GDPMap handle
-			MOVE.L	(A1),A1					; get the gdPMap pointer
-			ADD.W	D1,pmBounds+left(A1)	; offset the left edge (normally zero)
-			ADD.W	D1,pmBounds+right(A1)	; offset the right edge
-
-			MOVE.W	GDRect+right(A0),D1		; get the new right edge for the next device
-			BRA.S	@Loop					; for each screen
-
-GoodRsrc	_HideCursor						; cursor must be hidden here
-			MOVE.B	#1,CRSRBUSY 			; MARK CHANGE IN PROGRESS
-			MOVE.L	CRSRDEVICE,A0			; GET HANDLE TO CURSOR DEVICE
-			MOVE.L	(A0),A0					; POINT TO CURSOR DEVICE
-			MOVE.L	GDRECT+TOPLEFT(A0),D0	; GET SCREEN TOPLEFT
-			SUB		D0,MOUSE+H				; CONVERT MOUSE TO SCREEN LOCAL
-			SWAP	D0						; GET SCREEN TOP
-			SUB		D0,MOUSE+V				; CONVERT MOUSE TO SCREEN LOCAL
-			MOVE.L	MOUSE,MTEMP				; copy to mouse temp
-			MOVE.L	MOUSE,RAWMOUSE			; and to raw coordinates
-
-; configure each entry in the scrn resource
-
-			MOVE.L	StartList(A6),A4		; save pointer to start of list
-			MOVE	(A4)+,D7				; get the number of screens in resource
-			SUBQ	#1,D7					; make it 0 based
-
-DoNxt		LEA		SlotParms(A6),A0		; get pointer to parameter block
-			MOVE.L	#((CatDisplay << 16) ++ TypVideo),spCategory(A0)	;<C741>
-											; set category ID, type		<C741>
-			MOVE.W	#DrSwApple,spDrvrSw(A0)	;							<C741>
-											; set software, (invalid) hardware ID	<C741>
-			MOVE	(A4)+,spDrvrHw(A0)		; set driver hardware ID
-			MOVE.B	#$00,spTBMask(A0)		; all fields valid
-			MOVE	(A4)+,D0				; get slot
-			MOVE.B	D0,spSlot(A0)			; does it match?
-			MOVE.B	#0,spID(A0)				; start with first ID
-			CLR.B	spExtDev(A0)			;<C720>
-			_sNextTypesRsrc					; get next video device
-			BNE 	BadScrn					; => this should never be taken
-
-; we found a device that matches the given description!  Find its GDevice and configure it
-
-			MOVE	spRefNum(A0),D1			; D1 = refnum
-
-			MOVE.L	DeviceList,A3			; A3 = first grafdevice in list
-@NxtGD		MOVE.L	(A3),A0					; get pointer to device
-			CMP		GDRefNum(A0),D1			; does refnum match?
-			BEQ.S	@GotGD					; => yes, got the grafDevice
-			MOVE.L	GDNextGD(A0),D0			; get handle of next device
-			MOVE.L	D0,A3					; get in A0
-			BNE.S	@NxtGD					; => check all grafDevices
-			BRA 	BadScrn					; => this should never be taken
-
-@GotGD		MOVE.L	(A4)+,D0				; discard dCtlDevBase
-
-; set up the GDFlags word before calling InitGDevice
-
-@0			MOVE.L	(A3),A1					; point at the grafDevice
-			MOVE	GDFlags(A1),D0			; get the flags word
-			AND		2(A4),D0				; turn off the bits that are used
-			OR		4(A4),D0				; turn on new bits
-			BSET	#RAMInit,D0				; say we've initialized it
-			BSET	#ScreenDevice,D0		; and flag it as a screen device
-			MOVE	D0,GDFlags(A1)			; set the flags word
-
-; if main device, set up low-memory handles
-
-ChkMain		MOVE	GDFlags(A1),D0			; get the flags word
-			BTST	#mainScreen,D0			; is it the main scrn?			<2.2>
-			BEQ.S	@InitGD					; => no, go init device
-
-			MOVE.L	A3,MainDevice			; set up as main screen device
-			MOVE.L	A3,TheGDevice			; set up as default destination device
-			MOVE.L	A3,SrcDevice			; set up as default source device
-											; allocCursor called by initgraf to init cursor
-			MOVE.L	(A3),A0					; point to gDevice
-			MOVE.L	gdPMap(A0),A0			; get pixMap handle
-			MOVE.L	(A0),A0					; point to pixMap
-			MOVE.L	baseAddr(A0),D0			; get base address
-			MOVE.L	D0,scrnBase				; and set up screen base
-
-			LEA		SlotParms(A6),A0		; point at slot manager block again (it's still positioned from above)
-			MOVE	(A4),D0					; get the requested mode
-;+++			MOVE.B	D0,spID(A0)				; put in block						<BAL 06Apr89>
-			MOVE.B	#128,spId(A0)			; pass the default mode (assumed to be 1-bit mode)
-			_sFindStruct					; point to this mode information
-
-			MOVE.B	#mVidParams,spID(A0)	; now get the device pixmap
-			_sGetBlock						; on the system heap (I guess this is OK)
-			MOVE.L	spResult(A0),A1			; get the result pointer
-			MOVE.w	vpRowBytes(A1),screenRow ; get the screen row bytes (WORD)	<BAL 31Mar89>
-
-; set up the lo-mem for screen resolution too.  It's only WORD/WORD rather then FIXED/FIXED
-			MOVE.W	vpHRes(A1),ScrHRes		; Take the high word of vpHRes
-			MOVE.W	vpVRes(A1),ScrVRes		; Take the high word of vpVRes
-
-			MOVE.L	A1,spsPointer(A0)		; now, release the sBlock
-			_sDisposePtr					;
-
-@InitGD
-			MOVE	D1,-(SP)				; push refnum
-			MOVE	(A4)+,-(SP)				; push mode
-			CLR		-(SP)					; which should be long
-			MOVE.L	A3,-(SP)				; push grafDevice
-			_InitGDevice					; configure the grafDevice
-			ADDQ	#4,A4					; mask and flags already used
-
-;
-; if there is a gamma table resource id, get the gamma correction table and call the driver
-;	We need to do this before the color table to make sure it takes effect right away.
-;
-
-			MOVE	2(A4),D0				; get the gamma table resource id
-			CMP		#-1,D0					; is it -1?
-			BEQ.S	ChkTbl					; => yes, no table
-
-;
-; if the gamma table resource id = -2, then request linear gamma from the driver
-;
-
-			CMP		#-2,D0					; is it -2?
-			BNE.S	@GetFromSys				; nope, so load the system resource
-
-			LEA		VidParms(A6),A1			; point to parameter block
-			CLR.L	csGTable(A1)			; pass NIL to tell new drivers to set linear
-			BSR.S	GammaControl			; call a common routine to set gamma
-			BRA.S	ChkTbl				;
-
-;
-; load the gamma resource from the system and set it
-;
-
-@GetFromSys
-			CLR.L	-(SP)					; make room for function result
-			MOVE.L	#'gama',-(SP)			; push gamma table rsrc type
-			MOVE	D0,-(SP)				; else push resource id
-			_GetResource					; try to read in gamma table
-			MOVE.L	(SP)+,D0				; get the result
-			BEQ.S	ChkTbl					; => couldn't find it, use default
-			MOVE.L	D0,-(SP)				; save a copy for later
-			MOVE.L	D0,A0					; setup for HLock
-			_HLock							;
-			LEA		VidParms(A6),A1			; point to params for SetGamma
-			MOVE.L	(A0),csGTable(A1)		; gamma table pointer is only param
-			BSR.S	GammaControl			; call a common routine
-			MOVE.L	(SP),A0					; get the resource handle back
-			_HUnlock						; free it
-			_ReleaseResource				; and release it (fixing the stack)
-			BRA.S	ChkTbl					; continue on
-
-;
-; here's an imbedded utility.  I know I burn 2 bytes always BSRing around it, but I
-;	would burn two with a word branch if the utility were outside.  This routine sets
-;	up the iopb and csParam block for a SetGamma control call.  It expects the csGTable
-;	field to be set up, the csParam block pointer in A1, and the gdevice pointer in A3.
-;
-
-GammaControl
-			LEA		IOPBlk(A6),A0			; point to parameter block
-			MOVE.L	A1,csParam(A0)			; move addr of parms into block
-			MOVE.W	#4,csCode(A0)			; csc_SetGamma
-			CLR.L	ioCompletion(A0)		; no completion routine
-			CLR.W	ioVRefNum(A0)			; no volRefNum
-			MOVE.L	(A3),A1					; point to gdevice
-			MOVE	GDRefNum(A1),ioRefNum(A0)	; set device's refnum
-			_Control ,IMMED					; SetGamma(GammaTable)
-											;   if error here (likely if -2 were passed to
-											;	and old driver) then just use default table
-			RTS								; and back
-
-;
-; Previously, if there was a color table resource id, this part loaded that table.  Now,
-;	it checks the state of the gdDevType bit.  If it is monochrome (=0), then this routine
-;	substitutes pixelSize+32 for the resID.  If it is color (=1) and 2- or 4-bit mode, then
-;	pixelSize+64 is substituted to yield a modified color table that includes the highlight
-;	color.
-;
-; If we EVER have a gamma ID <> -1 (not default), then be sure to set the color table	<2.3>
-;	to flush this gamma into the CLUT hardware.
-;
-; The pointer to the gDevice is still in A1.
-;
-
-ChkTbl
-			MOVE.L	(A3),A1					; point to the gDevice again
-			MOVE.L	gdPMap(A1),A0			; get pixmap
-			MOVE.L	(A0),A0					; get pixmap ptr
-			MOVE.W	pmPixelSize(A0),D0		; get depth
-
-			CMP		#DirectType,gdType(A1)	; is it a direct device?
-			BEQ 	SetGRect				; if so, then do nothing
-
-			BTST	#gdDevType,gdFlags+1(A1)	; is it color or monochrome mode?
-			BNE.S	@ClrMode				; if set, then this is color
-			cmp.w	#2,d0					; 1 or 2 bit/pixel?						<2.1>
-			ble.s	@regClr					; don't do anything funky				<2.1>
-@MonoMode
-			ADD		#32,D0					; add 32 to pixelsize in all modes for linear gray
-			BRA.S	@GetClut				;
-@ClrMode
-			MOVE.W	D0,D1					; copy the depth
-			AND		#9,D1					; is it 1- or 8-bit mode?
-			BNE.S	@regClr					; if so, then do regular behavior
-@is2or4
-			ADD		#64,D0					; for 2- or 4-bit, add 64 to pixel depth (gives color+highlight)
-			BRA.S	@GetClut				;
-
-@regClr
-			MOVE	(A4),D1					; get the color table resource id
-			CMP		#-1,D1					; is it -1?
-			BNE 	@GetClut				; if not, then set the CLUT				<2.3>
-			CMP		#-1,2(A4)				; if CLUTid=-1, and gammaID<>-1, then set CLUT to flush <2.3>
-			BEQ.S	SetGRect				; if both are default, then continue	<2.3>
-
-@GetClut	CLR.L	-(SP)					; make room for function result
-			MOVE	D0,-(SP)				; else push resource id
-			_GetCTable						; get a color table
-			MOVE.L	(SP)+,D0				; get the result
-			BEQ.S	SetGRect				; => couldn't find it, use default
-
-			MOVE.L	(A3),A0					; point at the grafDevice
-			MOVE.L	GDPMap(A0),A0			; get handle to its pixmap
-			MOVE.L	(A0),A0					; point at the pixmap
-			MOVE.L	pmTable(A0),-(SP)		; push our color table for set entries  <C1/9>
-			MOVE.L	D0,-(SP)				; push new table handle for dispose		<C1/9>
-			MOVE.L	D0,-(SP)				; push source color table				<C1/9>
-			MOVE.L	pmTable(A0),-(SP)		; push destination color table			<C1/9>
-			_CopyHandle						; copy new table into our handle		<C1/9>
-			_DisposCTable					; and dispose new handle				<C1/9>
-
-; now call the driver to set this color table (handle on stack)
-
-			MOVE.L	(SP),A0					; get handle to color table
-			_HLock							; lock down the color table
-			LEA		VidParms(A6),A1			; point to params for SetEntries
-			MOVE.L	(A0),A0					; get ctabPtr							<DAF>
-			CLR.W	csStart(A1)				; start at zero, use sequence mode		<DAF>
-			MOVE.W	ctSize(A0),csCount(A1)	; for the length of the table			<DAF>
-			LEA		ctTable(A0),A0			; get pointer to colorspecs				<DAF>
-			MOVE.L	A0,csTable(A1)			; color table pointer is first param	<DAF>
-			LEA		IOPBlk(A6),A0			; point to parameter block
-			MOVE.L	A1,csParam(A0)			; move addr of parms into block
-			MOVE.W	#3,csCode(A0)			; csc_SetEntries
-			CLR.L	ioCompletion(A0)		; no completion routine
-			CLR.W	ioVRefNum(A0)			; no volRefNum
-			MOVE.L	(A3),A1					; point to gdevice
-			MOVE	GDRefNum(A1),ioRefNum(A0)	; set device's refnum
-			_Control ,IMMED					; SetEntries(ColorTable);
-			MOVE.L	(SP),A0					; get handle to color table
-			_HUnLock						; unlock the color table
-
-; finally, generate an inverse table for the table (handle on stack)
-
-											; color table handle on stack
-			MOVE.L	(A3),A1					; point at the grafDevice
-			MOVE.L	GDITable(A1),-(SP)		; push inverse table handle
-			MOVEQ	#4,D0					; make 4-4-4 inverse tables
-			MOVE	D0,GDResPref(A1)		; save in GDevice
-			MOVE	D0,-(SP)				; and push res
-			_MakeITable						; and generate inverse table
-
-; use the specified rectangle to determine the device's global coordinates
-
-SetGRect
-			ADDA	#4,A4					; skip the CLUT and gamma resID's
-			MOVE.L	(A3),A0					; point to the grafDevice
-			MOVE.L	GDPMap(A0),A1			; get handle to pixMap
-			MOVE.L	(A1),A1					; get pointer to pixMap
-			ADDQ	#Bounds,A1				; point to pixMap.bounds
-			LEA		GDRect(A0),A0			; point to its rectangle
-			MOVE.L	(A4)+,D0				; get topLeft for mouse offset
-			MOVE.L	D0,(A1)+				; copy topLeft to pixMap.bounds
-			MOVE.L	D0,(A0)+				; copy topLeft to GDRect
-			MOVE.L	(A4),(A1)				; copy botRight to pixMap.bounds
-			MOVE.L	(A4)+,(A0)+				; copy botRight to GDRect
-
-; parse and execute the additional control commands
-
-			MOVE	(A4)+,D6				; get number of control calls
-			BRA.S	ChkNxtCtl				; => jump into end of dbra loop
-DoCtl		LEA		IOPBlk(A6),A0			; point to parameter block
-			LEA		4(A4),A1				; point to call parameters
-			MOVE.L	A1,csParam(A0)			; move addr of parms into block
-			MOVE.W	(A4)+,csCode(A0)		; set control code
-			CLR.L	ioCompletion(A0)		; no completion routine
-			CLR.W	ioVRefNum(A0)			; no volRefNum
-			MOVE.L	(A3),A1					; point to gdevice
-			MOVE	GDRefNum(A1),ioRefNum(A0)	; set device's refnum
-			_Control ,IMMED					; and issue the control call
-
-			MOVE	(A4)+,D0				; get size of param block
-			ADD		D0,A4					; skip param block
-ChkNxtCtl	DBRA	D6,DoCtl				; loop for all control calls
-
-ChkNxt		DBRA	D7,DoNxt				; loop for all screens in resource
-
-; NOW UPDATE THE MOUSE TO THE COORDINATE SYSTEM OF ITS SCREEN AND DISPLAY IT
-
-			MOVE.L	CRSRDEVICE,A0			; GET HANDLE TO CURSOR DEVICE
-			MOVE.L	(A0),A0					; POINT TO CURSOR DEVICE
-			MOVE.L	GDRECT+TOPLEFT(A0),D0	; GET SCREEN TOPLEFT
-			ADD		D0,MOUSE+H				; CONVERT MOUSE TO GLOBAL
-			SWAP	D0						; GET SCREEN TOP
-			ADD		D0,MOUSE+V				; CONVERT MOUSE TO GLOBAL
-			MOVE.L	MOUSE,MTEMP				; copy to mouse temp
-			MOVE.L	MOUSE,RAWMOUSE			; and to raw coordinates
-			CLR.B	CRSRBUSY				; end of change
-			_AllocCursor					; make sure cache structures are OK			<5+>
-			_ShowCursor						; now redisplay cursor
-
-DONE		_ReleaseResource				; all done with the resource
-
-GoHome		MOVEM.L	(SP)+,D6-D7/A2-A4		; restore work registers
-			UNLINK	PARAMSIZE,'CHECKDEV'
-
-	ENDWITH
+		RTS
 
 ;-------------------------------------------------------------
 ;
diff --git a/QuickDraw/GWorld.a b/QuickDraw/GWorld.a
--- a/QuickDraw/GWorld.a
+++ b/QuickDraw/GWorld.a
@@ -695,6 +695,9 @@ varSize			equ		localRect			; size of local variables
 
 		move	#noErr,result(a6)			; flag a successful operation,
 
+		move.l	offscreenGWorld(a6),a0
+		clr.l	(a0)
+
 ;-------------------------------------------------------------------------
 ; Initialize all offscreen local variables to zero.
 ; If an error happens during this function, we deallocate the memory for
@@ -765,6 +768,14 @@ varSize			equ		localRect			; size of local variables
 		cmp		#32,d7						; illegal if > 32
 		bhi		badPixelDepth				; exit with error
 
+;-------------------------------------------------------------------------
+; Treat 24-bit color as 32-bit.
+
+		cmp		#24,d7
+		bne.s	@dontSetTo32
+		moveq	#32,d7
+@dontSetTo32
+
 ;-------------------------------------------------------------------------
 ; If pixelDepth is not 0, don't try to align offscreen pixmap to screen
 
@@ -1003,6 +1014,17 @@ createPixMap
 		moveq	#5,d0						; no, cmpSize = 5
 @0		move	d0,pmCmpSize(a1)			; store cmpSize in pixmap
 
+		btst.l	#$1,d3
+		beq.s	@skipthisnonsense
+		move.l	([museDevice,a6]),a0
+		move.l	([gdPMap,a0]),a0
+		move.l	gdMode(a0),a0
+		move.l	a0,offscreenCTable(a6)
+		move.l	([offscreenPixMap,a6]),a1
+		move.l	a0,gdMode(a1)
+		bra		createDevice
+@skipthisnonsense
+
 ; Create an empty color table.
 
 		move	#ctRec,d0					; size of an empty color table
@@ -1025,7 +1047,7 @@ createPixMap
 
 ; Create a dummy inverse table (doesn't have to be a seed)
 
-		moveq	#2,d0						; small handle for dummy inverse table
+		moveq	#4,d0						; small handle for dummy inverse table
 		_NewHandle	,CLEAR					; allocate it
 		bne		reportError					; if Memory Manager error, report it and quit
 
@@ -1149,7 +1171,7 @@ dontCloneCTab
 
 ; Allocate inverse table to its initial size
 
-		moveq	#2,d0						; initial size is 2
+		moveq	#4,d0						; initial size is 2
 		_NewHandle	,CLEAR					; allocate it
 		bne		reportError					; if Memory Manager error, report it and quit
 
@@ -1393,9 +1415,9 @@ disposOffscreenHandles
 		move	portVersion(a0),d0			; get portVersion
 		and		#cPortFlag,d0				; check if cPortFlag set
 		cmp		#cPortFlag,d0				; is it set?
-		bne		@0							; if not set, don't close port
+		bne.s	@0							; if not set, don't close port
 		move.l	(a0),-(sp)					; push pointer to port
-		_ClosePort							; close it down
+		_CloseCPort							; close it down
 @0
 		move.l	d7,a0						; get handle to offscreen port
 		_DisposHandle						; dispose it
@@ -1732,7 +1754,7 @@ dontDisposeBaseAddr
 
 dontDisposeGDevice
 		move.l	offscreenGWorld(sp),-(sp)	; push pointer to offscreen port
-		_ClosePort							; get rid of all substructures
+		_CloseCPort							; get rid of all substructures
 
 		move.l	offscreenGWorld(sp),a0		; get pointer to grafport
 		_RecoverHandle						; find handle to grafport
diff --git a/QuickDraw/GrafAsm.a b/QuickDraw/GrafAsm.a
--- a/QuickDraw/GrafAsm.a
+++ b/QuickDraw/GrafAsm.a
@@ -72,7 +72,7 @@ SIZEOK		_NewHandle ,CLEAR					; ask OS to do request
 ;  handle the memory full error by deep-shitting
 
 MemFull 	MOVEQ	#25,D0						;Deep Shit memory full error code
-			_SysError
+			DC.W	$A9C9						;_SysError
 JacksonPollock
 			DC.W	$A9FF						;invoke debugger just in case it comes back
 
@@ -315,7 +315,6 @@ CRSRLP		MOVE.L	(A0)+,(A4)+ 				;COPY A LONG INTO GLOBALS
 
 ; IF SCREENS NOT INITIALIZED FROM 'scrn' RESOURCE, INIT THEM
 
-			bsr.l	CheckDevices				; configure screens, if needed
 			MOVE.L	MainDevice,A0				; get main device
 			MOVE.L	A0,theGDevice				; set gDevice
 			MOVE.L	A0,srcDevice				; and srcDevice just in case
diff --git a/QuickDraw/LCursor.a b/QuickDraw/LCursor.a
--- a/QuickDraw/LCursor.a
+++ b/QuickDraw/LCursor.a
@@ -40,11 +40,7 @@ AllocCursor PROC  	EXPORT
 ;  PROCEDURE AllocCursor;
 ;
 
-		LEA		AllocCrsr,A0				;get default cursor routine
-		MOVE.L	JAllocCrsr,D0				;has vector been initialized?
-		BEQ.S	@0							;=>no, use default routine
-		MOVE.L	D0,A0						;else use routine in vector
-@0		JMP		(A0)						;and call it
+		JMP		AllocCrsr
 
 
 InitCursor PROC  EXPORT 	
@@ -55,8 +51,8 @@ InitCursor PROC  EXPORT
 		MOVE.L	GRAFGLOBALS(A5),A0			;POINT TO QUICKDRAW GLOBALS
 		PEA 	ARROW(A0)					;PUSH ADDR OF ARROW
 		_SetCursor							;INSTALL ARROW CURSOR
-		MOVE.L	JInitCrsr,A0				;get lo mem pointer
-		JMP 	(A0)						;and call it
+		IMPORT	_InitCursor
+		JMP 	_InitCursor
 
 
 
@@ -70,8 +66,8 @@ SetCursor PROC	EXPORT
 		MOVE	#16,-(SP)					;HEIGHT:=16
 		PEA 	DATA(A0)					;PUSH ADDR OF DATA
 		PEA 	MASK(A0)					;PUSH ADDR OF MASK
-		MOVE.L	JSetCrsr,A0 				;get lo mem vector
-		JSR 	(A0)						;call vector
+		IMPORT 	_SetCursor
+		JSR 	_SetCursor
 		MOVE.L	(SP)+,(SP)					;strip param
 		RTS 								;and return
 		
@@ -92,8 +88,8 @@ SetCCursor PROC	EXPORT
 ;		_SetCursor							; and set it the old way
 
 		MOVE.L	4(SP),-(SP)					; Push handle to color cursor
-		MOVE.L	JSetCCrsr,A0 				; get lo mem vector
-		JSR 	(A0)						; call vector (but don't call him hector)
+		IMPORT	_SetCCursor
+		JSR 	_SetCCursor
 ;		_ShowCursor							; balance is a virtue
 		MOVE.L	(SP)+,(SP)					; strip param
 		RTS 								; and return
@@ -107,8 +103,8 @@ HideCursor PROC  EXPORT
 ;
 ;  ALL REGS PRESERVED.
 ;
-		MOVE.L	JHideCursor,-(SP)			;get lo mem vector
-		RTS 								;and call it
+		IMPORT	_HideCursor
+		JMP		_HideCursor
 
 
 
@@ -119,36 +115,8 @@ ShowCursor PROC  EXPORT
 ;
 ;  ALL REGS PRESERVED.
 ;
-		MOVE.L	JShowCursor,-(SP)			;get lo mem vector
-		RTS 								;and call it
-
-
-
-ShieldCursor PROC  EXPORT		
-;---------------------------------------------------------
-;
-;  PROCEDURE ShieldCursor(shieldRect: Rect; offset: Point);
-;
-;  ALL REGS PRESERVED.
-;
-		MOVEM.L D0-D3/A0-A1,-(SP)			;SAVE REGS
-		MOVE.L	32(SP),A0					;POINT TO SHIELDRECT
-		MOVEM.W (A0)+,D0/D1/D2/D3			;GET TOP ... RIGHT
-		LEA 	28(SP),A1
-		SUB 	(A1),D0 					;TOP - OFFSET.V
-		SUB 	(A1)+,D2					;BOTTOM - OFFSET.V
-		SUB 	(A1),D1 					;LEFT - OFFSET.H
-		SUB 	(A1),D3 					;RIGHT - OFFSET.H
-		MOVE	D1,-(SP)					;PUSH GLOBAL LEFT
-		MOVE	D0,-(SP)					;PUSH GLOBAL TOP
-		MOVE	D3,-(SP)					;PUSH GLOBAL RIGHT
-		MOVE	D2,-(SP)					;PUSH GLOBAL BOTTOM
-		MOVE.L	JShieldCursor,A0			;get lo mem vector
-		JSR 	(A0)						;and call it
-		MOVEM.L (SP)+,D0-D3/A0-A1			;RESTORE REGS
-		MOVE.L	(SP)+,(SP)
-		MOVE.L	(SP)+,(SP)					;STRIP 8 BYTES
-		RTS 								;AND RETURN
+		IMPORT	_ShowCursor
+		JMP		_ShowCursor
 
 
 
@@ -159,10 +127,8 @@ ObscureCursor PROC	EXPORT
 ;
 ;  Hide the cursor image until the next time the mouse moves.
 ;
-		MOVE.L	JCrsrObscure,A0 			;get lo mem vector
-		JMP 	(A0)						;and call it
-
-
+		IMPORT	_ObscureCursor
+		JMP		_ObscureCursor
 
 
 		ENDPROC 
diff --git a/QuickDraw/PaletteMgr.a b/QuickDraw/PaletteMgr.a
--- a/QuickDraw/PaletteMgr.a
+++ b/QuickDraw/PaletteMgr.a
@@ -172,7 +172,7 @@ plttUpdates	Equ		$0002			; value passed to SetPalette [short]			AWC.PB457
 ;ctReserveBit	EQU	6
 ;ctReserveVal	EQU	$4000
 
-PMgrVersNum		EQU	$0202			; Version number (VVss: version subversion)				
+PMgrVersNum		EQU	$0203			; Version number (VVss: version subversion)				
 ;-----------------------------------------------------------
 ; Let's talk about PMgrVersNum --
 ;
@@ -228,6 +228,46 @@ PMgrVersNum		EQU	$0202			; Version number (VVss: version subversion)
 ;	GetNewCWindow which is patched in PatchIIROM.a
 
 
+FlushPalettes	PROC	EXPORT				; THIEVED FROM THE MEMORY MGR
+;-----------------------------------------------------------------------
+; Call DisposePalette for all palettes in the app heap.
+;
+; Registers: D0-D2/A0-A1
+; Called by vIAZInit.
+;----------------------------------------------------------------------
+			IMPORT	AppZoneAddr
+
+			MOVEM.L	A2-A3/D3,-(SP)			; save work registers
+			MOVE.L	PMgrHandle,A2			; get paletteMgr handle
+			CMP.L	MinusOne,A2				; is it there?
+			BEQ.S	@DONE					; => no, just return
+			MOVE.L	(A2),A1					; point to data structure
+			MOVE.L	PListHandle(A1),A0		; get handle to palette list
+			_HLock							; and lock it down
+			MOVE.L	(A0),A3					; point to palette list
+
+			Move	APalettes(A1),D3		; get number of active handles
+			Beq.s	@NoPals					; no friends => go home
+			Add		FreeSpaces(A1),D3		; calculate total number of entries
+			BRA.S	@FindEnd				; => check for no entries
+
+@FindLoop	Move.L	PaletteRef(A3),D1		; get first entry
+			BEQ.S	@FindNext				; => no palette in entry
+			MOVE.L	D1,D0					; and get for routine
+			JSR		AppZoneAddr				; in application area (or zero)?	<SM30 BT>
+			BNE.S	@FindNext				; => not in app heap
+			MOVE.L	D1,-(SP)				; push palette handle
+			DC.W	$AA93					; _DisposePalette ; and dispose it in place
+@FindNext	AddQ	#PLstEntrySz,A3			; bump to the next entry
+@FindEnd	DBra	D3,@FindLoop			; repeat for all spaces
+
+@NoPals		MOVE.L	(A2),A1					; point to palette stuff
+			MOVE.L	PListHandle(A1),A0		; get handle to palette list
+			_HUnlock						; and unlock it
+
+@DONE		MOVEM.L	(SP)+,A2-A3/D3			; restore work registers
+			RTS
+
 ;---------------------------------------------------
 ;
 ; PROCEDURE	ActivatePalette(dstWindow: WindowPtr); INLINE $AA94;
@@ -584,14 +624,8 @@ gLoopEnd	DBRA	D3,gLoop				; loop for all devices						<dvb5>
 ; return Z-flag Clear if the process mgr is here (BNE ProcMgrTrue)
 
 CheckForProcessMgr	PROC EXPORT
-			MOVE.L	#'os  ',D0				; type of question
-			_Gestalt
-			TST		D0						; OSErr from Gestalt?
-			BEQ.S	@a						; No=>test result
-			SUBA	A0,A0					; Yes=>assume there's no procMgr
-@a
-			MOVE.L	A0,D0
-			BTST	#gestaltLaunchControl,D0	; clear the Z-flag if procmgr here
+			MOVE.L	ExpandMem,A0
+			TST		$128(A0)
 			RTS
 
 ;---------------------------------------------------
@@ -624,7 +658,7 @@ linkSize	DS.B		0						; linky number
 
 			movem.l	a0-a2/d0-d2,-(sp)		; Those pesky c routines					<mc8>
 			sub.l	a0,a0					; Pass the current process (0)
-			move.w	#12,d0					; _TrashProcess
+			moveq	#12,d0					; _TrashProcess
 			;_FigmentDispatch				; let everyone know this stuff is gone
 			dc.w	$A0A4
 			movem.l	(sp)+,a0-a2/d0-d2		; Restore em
@@ -660,7 +694,7 @@ linkSize	DS.B		0						; linky number
 			PEA		inFront(A6)
 			_SameProcess					; are we the front process?
 			ADDQ	#2,SP					; OSErr leaves inFront true from above
-			TST		inFront(A6)
+			TST.B	inFront(A6)
 			BEQ.S	@doNothing
 @front
 
@@ -1805,8 +1839,9 @@ linkSize	DS.B		0						;linky number
 			MOVE.L	(A2),A3					; A3->gDevice
 			TST		gdType(A3)				; a clut device?							<dvb5>
 			BNE.S	GoHome					; No=> go home w/false
-			TST		gdFlags(A3)				; Device active?
-			BPL.S	GoHome					; No=> ditto
+			MOVE	$14(A3),D0
+			AND		#$8010,D0
+			BEQ.S	GoHome					; No=> ditto
 			SUBQ	#4,SP					; space for result							<dvb5>
 			MOVE.L	A2,-(SP)				; push gDevice handle						<dvb5>
 			JSR		GetClut					; get the appropriate default clut			<dvb5>
@@ -2505,8 +2540,9 @@ FoundAPltt	Move.L	A2,srcPalette(A6)		; save it so we can unlock it				AWC.PB520
 			BEQ.s	@a						; is it a clut device?						<dvb12>
 			SUBQ	#1,D1					; fixed type?								<dvb12>
 			BNE.S	UnlockPltt				; no => we're almost done					<dvb3>
-@a			TST		gdFlags(A0)				; is it active?
-			BPL.S	UnlockPltt				; no => ditto
+@a			MOVE	$14(A3),D0
+			AND		#$8010,D0
+			BEQ.S	UnlockPltt
 			Move	ciUsage(A3),D1			; get flags
 			MoveQ	#0,D0					; clear high word
 			Move	srcEntry(A6),D0			; set D0 in case it is an explicit index
@@ -3152,8 +3188,9 @@ SetDev
 			Move.L	(A0),A0					; dereference it
 			TST		gdType(A0)				; is it CLUT type (zero)?				dvb1
 			BNE		GoHome					; No => do nothing
-			TST		gdFlags(A0)				; is it active
-			BPL		GoHome					; No=>go home
+			MOVE	$14(A0),D0
+			AND		#$8010,D0
+			BEQ		GoHome					; No=>go home
 			Move.L	gdPMap(A0),A0			; get handle to pixmap
 			Move.L	(A0),A0					; dereference pixmap
 			Move.L	pmTable(A0),A0			; get handle to CTab
@@ -4542,66 +4579,7 @@ ReleaseList	PROC	EXPORT
 ;
 FindModeID	FUNC		Export
 
-			WITH		SpBlock,VPBlock
-
-FMVars		RECORD		{A6Link},Decrement
-result		DS.B		2					; integer result
-gd			DS.B		4					; input: GDevice
-depth		DS.B		2					; input: depth
-return		DS.B		4					; return address
-A6Link		DS.B		4					; link
-spBlk		DS.B		spBlockSize			; slot parameter block
-vpPtr		DS.B		4					; pointer to vidParams block
-linkSize	DS.B		0					; size of record
-			ENDR
-	
-			WITH		FMVars
-
-			LINK		A6,#linkSize
-			MOVEM.L		A2/D3,-(SP)				; save 'em
-
-			CLR			result(A6)				; default to failure!
-
-			MOVE.L		gd(A6),A0				; A0 = gDevice handle
-			MOVE.L		(A0),A1					; A1->gDevice
-
-			MOVE.L		UTableBase,A0			; A0->unit table
-			MOVE		gdRefNum(A1),D0			; D0 = refnum
-			NEG			D0
-			SUBQ		#1,D0
-			MOVE.L		(A0,D0.W*4),A1			; A1 = AuxDCEHandle for gDevice
-			MOVE.L		(A1),A1					; A1 = AuxDCEPtr for gDevice
-			LEA			spBlk(A6),A0			; A0 -> spBlock
-			MOVE.B		dCtlSlot(A1),spSlot(A0)		; stash gDevice slot
-			CLR.B		spID(A0)					; clear the ID
-			MOVE		#catDisplay,spCategory(A0)	; category: display
-			MOVE		#typVideo,spCType(A0)
-			MOVE		#drSwApple,spDrvrSW(A0)		; Apple™ style driver
-			MOVE.B		#1,spTBMask(A0)
-			_sNextTypeSRsrc
-			BNE.S		@goHome					; failure
-
-			MOVE.L		spsPointer(A0),A2		; keep saving it here
-			MOVE		#127,D3					; the 0th mode we'll look for
-
-@depthScan
-			ADDQ		#1,D3					; bump to next mode
-			MOVE.B		D3,spID(A0)				; look for the next mode
-			MOVE.L		A2,spsPointer(A0)		; sFindStruct wipes out each time
-			_sFindStruct						; look for it
-			BNE.S		@goHome					; failure
-			MOVE.B		#mVidParams,spID(A0)	; now we look for video params
-			_sGetBlock
-			BNE.S		@goHome					; failure
-			MOVE.L		spResult(A0),A1			; A1->vidParam block, finally
-			MOVE		vpPixelSize(A1),D0		; D0 = depth for this description
-			CMP			depth(A6),D0			; the one we want?
-			BNE.S		@depthScan				; scan 'til found, or slot error
-
-			MOVE		D3,result(A6)
-@goHome		MOVEM.L		(SP)+,A2/D3
-			UNLK		A6
-			RTD			#result-return-4
+			RTS
 
 
 
@@ -4625,6 +4603,7 @@ A6Link		DS.B		4							; link
 r			DS.B		4							; regionhandle
 oldPort		DS.B		4							; previous port
 myRect		DS.B		8							; rectangle for little black corners
+moreStuff	DS.B		10							; not sure what for?
 linkSize	DS.B		0							; size of record
 			ENDR
 
@@ -4634,10 +4613,31 @@ linkSize	DS.B		0							; size of record
 			MOVEM.L		A2-A3/D3-D5,-(SP)			;												<6>
 
 			MOVE		#paramErr,result(A6) ; default to failure!
+			MOVE.B		#1,myRect+6(A6)
+			MOVEQ		#0,D0
+			MOVE		depth(A6),D0
+			MOVE.L		D0,r(A6)
 
-			MOVE.L		gd(A6),A0					; A0 = gDevice handle
-			MOVE.L		(A0),A1						; A1->gDevice
+			CLR			-(SP)
+			MOVE.L		gd(A6),-(SP)
+			CLR.L		-(SP)
+			MOVE.L		r(A6),-(SP)
+			PEA			oldPort(A6)
+			CLR.L		-(SP)
+			PEA			myRect+7(A6)
 
+			MOVE		#$C12,D0					; _DMRemoveDisplay
+			DC.W		$ABEB
+
+			TST			(SP)+
+			BNE.S		@goHome
+
+			MOVE.L		oldPort(A6),D0
+			BTST.L		#1,D0
+			BNE.S		@goHome
+
+			MOVE.L		gd(A6),A1
+			MOVE.L		(A1),A1
 			MOVE		whichFlags(A6),D0			; D0 = mask of flags to change
 			ANDI		#whichMask,D0				; D0 = only the ones we let them change
 			MOVE		D0,D1						; D1 = mask of flags to change
@@ -4646,137 +4646,21 @@ linkSize	DS.B		0							; size of record
 			AND			gdFlags(A1),D0				; D0 = all the unchanged gdFlags
 			OR			D1,D0						; D0 = new gdFlags word
 			MOVE		D0,gdFlags(A1)				; Put back into gDevice
-			MOVE		gdRefNum(A1),D3				; D3 = refnum, for later use
-			
-			MOVE		depth(A6),D4				; get the depth or mode
-			TST.B		D4							; see which it is
-			BMI.S		@gotMode
 
-			SUBQ		#2,SP
+			CLR			-(SP)
 			MOVE.L		gd(A6),-(SP)
-			MOVE		D4,-(SP)
-			Import		FindModeID
-			BSR			FindModeID					; find the mode number, if it exists
-			MOVE		(SP)+,D4					; did we find one?
-			BEQ			@goHome
-
-@gotMode	Movea.l		gd(A6),A2					; Get GDHandle into A2.
-			Movea.l		(A2),A2						; Get a GDPtr into A2.
-			Btst		#mainScreen,gdFlags(A2)		; If we’re not on the menubar screen,
-			Beq.s		@NotMain1					;	then just keep going.
-			Move.w		theMenu,D5					; Get the currently hilited menuID.
-			Clr.w		-(Sp)						; And unhilite it.
-			_HiliteMenu
-@NotMain1
-
-;			Originally, DVB wasn’t getting the current port until corner-rounding code
-;			was about to be executed (below).  That seemed to cause port problems, so
-;			I move the port getting/setting code to here (which is the way Monitors
-;			does it).
-;
-;			-- jmp --
-
-			PEA			oldPort(A6)					; Save the current port
-			_GetPort
-			MOVE.L		WMgrPort,-(SP)				; We want to use the WMgrPort
-			_SetPort
-
-			MOVE		D3,-(SP)					; push refnum
-			EXT.L		D4
-			MOVE.L		D4,-(SP)					; push new gdev mode
-			MOVE.L		gd(A6),-(SP)				; push the handle
-			_InitGDevice
-
-			Btst		#mainScreen,gdFlags(A2)		; If we’re not on the menubar screen,
-			Beq.s		@NotMain2					;	then just keep going.
-			Move.w		D5,-(Sp)					; Get the hilite state.
-			_HiliteMenu								; Restore it.
-			_DrawMenuBar							; Draw the MenuBar.
-@NotMain2
-
-			CLR.L		-(SP)						; Activate the front palette
-			_FrontWindow							; before drawing anything.
-			_ActivatePalette
-
-;			In Monitors (the cdev) this is the point in the code where
-;			the PortList is walked to update all the CGrafPorts to the
-;			new depth.  We don’t need to do that here because InitGDevice
-;			does that for us with Save/ResoreFore and Save/RestoreBack
-;			calls.
-;
-;			-- jmp --
-
-;			If the LayerManger is around, we need to start at the root, otherwise
-;			we just use FrontWindow.  Originally, DVB had PaintOne instead of
-;			PaintBehind here but VL said that was wrong.  Also, Monitors uses the
-;			PaintOne/PaintBehind method instead of PaintOne/PaintOne method.
-;			
-;			-- jmp --
-
-		If HasLayers Then
-			_RedrawAll								; CheckUpdate on all layers		<42>
-		Else
-			SUBQ		#4,SP
-			_NewRgn
-			MOVE.L		(SP),r(A6)					; get a fresh region, LEAVE ON STACK
-
-			MOVE.L		gd(A6),A0					; A0 = gd handle
-			MOVE.L		(A0),A0						; A0->gdevice
-			PEA			gdRect(A0)					; push rectangle to RectRgn
-			_RectRgn								; r is now our region
-
 			CLR.L		-(SP)
-			MOVE.L		r(A6),-(SP)
-			_PaintOne
-
-			SUBQ		#4,SP
-			_FrontWindow
-			MOVE.L		r(A6),-(SP)
-			_PaintBehind
-
-			MOVE.L		r(A6),-(SP)					; Done with region
-			_DisposRgn
-		Endif
-		
-			CLR.L		myRect+topLeft(A6)			; Set the empty rect
-			CLR.L		myRect+botRight(A6)
-			MOVE.L		deviceList,A2				; A2 = 1st GDHandle
-@dloop		MOVE.L		(A2),A2						; A2 -> GDevice
-			BTST		#screenActive,gdFlags(A2)	; bit 15 in upper byte of word
-			BEQ.S		@dloopEnd					; Inactive screen?
-			PEA			gdRect(A2)
-			PEA			myRect(A6)
-			MOVE.L		(SP),-(SP)
-			_UnionRect
-@dloopEnd	MOVE.L		gdNextGD(A2),A2
-			MOVE.L		A2,D0
-			BNE.S		@dloop
-
-			PEA			myRect(A6)					; Set a nice big clip
-			_ClipRect
-			PEA			myRect(A6)
-			MOVE.L		#$FFFDFFFD,-(SP)			; outset by three
-			_InsetRect
-			MOVE.L		#$00030003,-(SP)			; pensize is three
-			_PenSize
-			PEA			myRect(A6)
-			MOVE.L	#$00160016,-(SP)				; and a radius for nice rounding
-			_FrameRoundRect 						; and black out the corners
+			PEA			r(A6)
+			CLR.L		-(SP)
+			CLR.L		-(SP)
 
-			_PenNormal
+			MOVE		#$A11,D0					; _DMEnableDisplay
+			DC.W		$ABEB
 
-			MOVE.L		oldPort(A6),-(SP)			; restore the previous port
-			_SetPort
+			MOVE		(SP)+,result(A6)
 
-			MOVE.L		gd(A6),A0
-			MOVE.L		(A0),A0
-			BTST		#mainScreen,gdFlags(A0)		; (mainScreen=11, in upper byte)
-			BEQ.S		@notMain
-			_DrawMenuBar
-@notMain
-			CLR			result(A6)					; success
 @goHome
-			MOVEM.L		(SP)+,A2/D3-D5
+			MOVEM.L		(SP)+,A2-A3/D3-D5
 			UNLK		A6
 			RTD			#result-return-4
 
@@ -4790,13 +4674,15 @@ HasDepth	FUNC		EXPORT
 whichMask	EQU			$FFFE				; the lowest bit is settable, else fail
 
 SDVars		RECORD		{A6Link},DECREMENT
-result		DS.B		2					; boolean result
-gd			DS.B		4					; input: GDevice to set
-depth		DS.B		2					; input: depth to set to
-whichFlags	DS.B		2					; which GDFlags to affect
-flags		DS.B		2					; input: various flags
-return		DS.B		4					; return address on stack
+result		DS.B		2					; 18 $12 boolean result
+gd			DS.B		4					; 14 $E input: GDevice to set
+depth		DS.B		2					; 12 $C input: depth to set to
+whichFlags	DS.B		2					; 10 $A which GDFlags to affect
+flags		DS.B		2					; 8  $8 input: various flags
+return		DS.B		4					; 4  $4 return address on stack
 A6Link		DS.B		4					; link
+myDepth		DS.B		4
+moreStuff	DS.B		24
 linkSize	DS.B		0					; size of record
 			ENDR
 
@@ -4809,13 +4695,43 @@ linkSize	DS.B		0					; size of record
 			MOVE		whichFlags(A6),D0	; D0 = mask of flags to change
 			AND			flags(A6),D0		; D0 = new flags to set
 			AND			#whichMask,D0		; D0 = all the bits we can't change
-			BNE.S		@goHome				; User tried to set bits we don't yet do!
+			BNE			@goHome				; User tried to set bits we don't yet do!
+
+			MOVEQ		#0,D0
+			MOVE		depth(A6),D0
+			MOVE.L		D0,myDepth(A6)
+
+			CLR			moreStuff+0(A6)
+			CLR.L		moreStuff+2(A6)
+			CLR			moreStuff+6(A6)
+			CLR.L		moreStuff+8(A6)
+			CLR.L		moreStuff+12(A6)
+
+			CLR			-(SP)
+			MOVE.L		gd(A6), -(SP)
+			PEA			moreStuff(A6)
+			MOVE.L		myDepth(A6), -(SP)
+			PEA			-$C(A6)
+			CLR.L		-(SP)
+
+			MOVE		#$AF3,D0					; unknown _DisplayDispatch selector
+			DC.W		$ABEB
+
+			TST			(SP)+
+			BNE.B		@goHome
+
+			MOVEQ.L		#$7F, D0
+			MOVEQ.L		#0, D1
+			MOVE		depth(A6), D1
+			CMP.L		D1, D0
+			BLT.B		@whaaa
+
+			MOVE		$C(A6), D0
+			CMP			-$C(A6), D0
+			BNE.B		@goHome
+
+@whaaa		MOVE		-$1C(A6), $12(A6)
 
-			SUBQ		#2,SP
-			MOVE.L		gd(A6),-(SP)
-			MOVE		depth(A6),-(SP)
-			BSR			FindModeID			; find the mode number, if it exists
-			MOVE		(SP)+,result(A6)	; did we find one?
 @goHome
 			UNLK		A6
 			RTD			#result-return-4
@@ -5087,6 +5003,7 @@ linkSize	DS.B		0					; size of record
 			_HLock
 			MOVE.L		(A0),A2				; A2->color table to check
 			MOVE		ctSize(A2),D3		; D3 = last color in table
+			BEQ.S		@goHome
 			MOVEQ		#0, D5				; initialized number of colors checked
 ;			MOVE		D3,D0
 ;			ADDQ		#1,D0
@@ -5108,6 +5025,9 @@ linkSize	DS.B		0					; size of record
 @next		ADDQ		#8,A2				; Bump to next color
 			DBRA		D3,@loop			; loop through all colors
 
+			TST			D5
+			BEQ.S		@goHome
+
 			DIVU		D5,D7				; compute average tolerance
 ;			DIVU		colorCount(A6),D7	; compute average tolerance
 			CMP			maxAveTol(A6),D7	; in range?
diff --git a/QuickDraw/Patterns.a b/QuickDraw/Patterns.a
--- a/QuickDraw/Patterns.a
+++ b/QuickDraw/Patterns.a
@@ -2308,12 +2308,12 @@ VARSIZE		EQU		DstRgnPtr
 			move.w	dstPix+pixelSize(A6),d0			; preload dst depth in case not screen
 			sub.l	a0,a0							; clear maskrgn in case not screen
 			move.w	d2,d3							; remember screen flag in d3
-			beq.s	NotScreen1
+			beq		NotScreen1
 
 			MOVE.L	DEVICELIST,A2					; GET FIRST ELEMENT IN DEVICE LIST
 			MOVE.L	(A2),A1							; POINT TO DEVICE
 			TST.L	GDNEXTGD(A1)					; CHECK NEXT DEVICE
-			beq.s	NotScreen1						; only 1 device so skip devloop
+			beq		NotScreen1						; only 1 device so skip devloop
 
 		; Copy dst rect and convert to global coordinates
 
@@ -2321,38 +2321,41 @@ VARSIZE		EQU		DstRgnPtr
 			lea		globalRect(a6),a1				; point at our copy
 			move.l	(a0)+,(a1)+						; copy topleft
 			move.l	(a0),(a1)+						; copy botRight
-			move.l	dstPix+bounds+top(a6),d0		; get topleft
-			move.w	d0,d1							; get left
-			swap 	d0								; get top
-			sub.w	d1,-(a1)						; convert right to global
-			sub.w	d0,-(a1)						; convert bottom to global
-			sub.w	d1,-(a1)						; convert left to global
-			sub.w	d0,-(a1)						; convert top to global
-
-			lea		DstRectRgn(a6),A0
-			move.l	a0,DstRgnPtr(a6)				; build master pointer
-			move.w	#10,(a0)						; set region size
-
-NEXTGD		MOVE.L	(A2),A0							; POINT TO DEVICE
-			TST		GDFLAGS(A0)						; IS IT ACTIVE?
-			BPL.S	SKIPGD							; =>NO, SKIP IT
+
+			lea		globalRect(a6),a1
+			move.l	a1,d0
+			move.l	a1,-(sp)
+			jsr		([$FC0])						; _LocalToGlobal?
+
+			add		#4,d0
+			move.l	d0,-(sp)
+			jsr		([$FC0])						; _LocalToGlobal?
+
+			lea.l	DstRectRgn(a6),a0
+			move.l	a0,DstRgnPtr(a6)
+			move	#10,(a0)
+
+NEXTGD		move.l	(a2),a0
+			tst		$14(a0)
+			bpl.s	SKIPGD
 
 			CLR.B	-(SP)							; MAKE ROOM FOR BOOLEAN RESULT
 			PEA		globalRect(A6)					; PUSH SPECIFIED RECTANGLE
 			PEA		gdRect(A0)						; PUSH DEVICE'S RECTANGLE
 			PEA		dstRectRgn+rgnBBox(A6)			; PUSH DESTINATION RECT
-			_SECTRECT								; IS THE RECT IN THE DEVICE
+			JSR		([$10A8])						; SECTRECT -- IS THE RECT IN THE DEVICE
 			TST.B	(SP)+							; TEST RESULT
 			BEQ.S	SKIPGD							; => NO INTERSECTION
 
-			move.l	dstPix+bounds+top(a6),d0		; get topleft
-			move.w	d0,d1							; get left
-			swap 	d0								; get top
-			lea		dstRectRgn+rgnBBox(a6),a0 		; point to rect
-			add.w	d0,(a0)+						; convert top to local coords
-			add.w	d1,(a0)+						; convert left to local coords
-			add.w	d0,(a0)+						; convert bottom to local coords
-			add.w	d1,(a0)							; convert right to local coords
+			lea		dstRectRgn+rgnBBox(A6),a0
+			move.l	a0,d0
+			move.l	a0,-(sp)
+			jsr		([$FC4])						; _GlobalToLocal?
+
+			add		#4,d0
+			move.l	d0,-(sp)
+			jsr		([$FC4])						; _GlobalToLocal?
+
 			MOVE.L	(A2),A0							; POINT TO DEVICE
 			MOVE.L	GDPMAP(A0),A0					; GET PIXMAP
 			MOVE.L	(A0),A0							; POINT TO PIXMAP
diff --git a/QuickDraw/Pictures.a b/QuickDraw/Pictures.a
--- a/QuickDraw/Pictures.a
+++ b/QuickDraw/Pictures.a
@@ -860,77 +860,6 @@ KillPicture PROC  EXPORT
 		_DisposHandle							;discard it
 		JMP 	(A1)							;and return
 
-;-----------------------Calc GCD <KON 07JAN90>---------------------
-CalcGCD		PROC EXPORT
-; Routine returns GCD( d0, d1 ) using Euclidean method
-; On Entry: D0 and D1 contain word size values to reduce
-; On Exit: D0 and D1 both contain GCD
-;
-		cmp.l	d0,d1							;while d0 != d1 (unsigned word compare)
-		beq.s	@FoundGCD
-		bgt.s	@D1isBigger						;  if( d1 < d0 )
-		exg		d0,d1							;    swap( d1, d0 )
-@D1isBigger
-		sub		d0,d1							;  d1 = d1 - d0
-		bra.s	CalcGCD							;end while
-@FoundGCD
-		rts										;d0 and d1 contain GCD
-		ENDPROC
-
-ReduceD3D4		PROC EXPORT
-			IMPORT	CalcGCD
-; Routine returns ReduceD3D4( d3, d4 ) reduces d3.w and d4.w by GCD for
-;	both the low and high words
-;
-; On Entry: D3 and D4 contain two word size values to reduce
-; On Exit: 	D3 and D4 contain reduced values
-;
-;
-; Divide Numer and Denom for width and height by GCD to prevent overflow.  
-;
-		moveq	#0,d0							;make sure high word is zero for next 2 divides
-		move.l	d0,d1							;CalcGCD exchanges regs, so both need to be cleared
-		move.w	d3,d0							;D0 has denom.v, d1 has numer.v
-		beq.s	@Done							;abort if zero.
-		move.w	d4,d1							;D0 has denom.v, d1 has numer.v
-		beq.s	@Done							;abort if zero.
-		jsr		CalcGCD							;returns GCD in d0
-		move.w	d3,d1							;D0 has denom.v, d1 has numer.v
-		divu.w	d0,d1							;dividing by GCD should never leave remainder
-		move.w	d1,d3							;save reduced numer.v
-		move.w	d4,d1							;D0 has denom.v, d1 has numer.v
-		divu.w	d0,d1
-		move.w	d1,d4							;save reduced denom.v
-;
-; Now do width:  Could have different scale factor than height did
-;
-		swap	d3								;operate on high word
-		swap	d4
-		move.w	d3,d0							;D0 has denom.h, d1 has numer.h
-		beq.s	@DoneSwap						;abort if zero.
-		move.w	d4,d1							;D0 has denom.h, d1 has numer.h
-		beq.s	@DoneSwap						;abort if zero.
-		jsr		CalcGCD							;returns GCD in d0
-		move.w	d3,d1							;D0 has denom.h, d1 has numer.h
-		divu.w	d0,d1							;dividing by GCD should never leave remainder
-		move.w	d1,d3							;save reduced numer.h
-		move.w	d4,d1							;D0 has denom.h, d1 has numer.h
-		divu.w	d0,d1
-		move.w	d1,d4							;save reduced denom.h
-@DoneSwap
-		swap	d3								;put things back
-		swap	d4
-@Done
-		rts										;all done
-;
-; End <KON 7/1/91>
-;
-		ENDPROC
-
-;-----------------------END GCD <KON 07JAN90>---------------------
-
-; as seen in QDciPatchROM.a													<sm 6/9/92>stb
-
 DrawPicture PROC  EXPORT
 		IMPORT PicItem1,NewRgn,InitColorStuff,ReduceD3D4
 ;------------------------------------------------------------------
@@ -4316,7 +4245,7 @@ MORE1
 		MOVE.L	A3,A0						;PTR TO FIRST byte of src
 		move.l	d5,d0						;get rowbytes in d0
 
-		_BlockMove							;copy from there to here
+		_BlockMoveData						;copy from there to here
 											;assumes here is a 24 bit address
 
 		moveq	#false32b,d0	;switch back before calling PutPicProc	<BAL 02Feb90>
@@ -4339,47 +4268,6 @@ DONE	MOVE.L	SAVEDSP(A6),SP				;RESTORE STACK POINTER
 ;
 
 
-PutBigPicData PROC  EXPORT						;17Jun88 BAL
-;------------------------------------------------------
-;
-;  PROCEDURE PutBigPicData(dataPtr: QDPtr; byteCount:LONG);
-;  ADD many BYTES TO THEPIC.
-;
-;	This is the same as PutPicData except the byteCount is a long
-;
-partSize	EQU		$4000
-partShift	EQU		$E
-
-		MOVEM.L	D7/A3-A4,-(SP)					;save a couple of registers
-
-		MOVE.L	20(SP),A3						;get the pointer to data
-		MOVE.L	16(SP),A4						;get data length
-		MOVE.L	A4,D7							;copy pointer
-		MOVEQ	#partShift,D0					;get a constant for the upcoming shift
-		LSR.L	D0,D7							;find the number of 16K "pages"
-		BEQ.S	LeftOvers						;no, so do the remaining part of the picture
-
-@1
-		MOVE.L	A3,-(SP)						;PUSH DATA POINTER
-		MOVE	#partSize,-(SP)					;move 16K of data
-		JSR 	PutPicData						;AND CALL GET PROC
-		ADD.W	#partSize,A3					;move data start pointer up
-		SUB.W	#partSize,A4					;subtract for remainder later
-		SUBQ.L	#1,D7							;decrease the number of pages
-		BNE.S	@1								;loop for each page
-
-LeftOvers
-		MOVE.L	A3,-(SP)						;PUSH DATA POINTER
-		MOVE.W	A4,-(SP)						;move remainder
-		JSR 	PutPicData						;AND CALL GET PROC
-
-		MOVEM.L	(SP)+,D7/A2-A4					;restore registers
-		RTD		#8								;and return
-
-;
-;GetPMData now included in GetPMData.a
-;
-
 PutPMData 	PROC	EXPORT
 			IMPORT 	PutPicByte,PutPicWord,PutPicData
 ;------------------------------------------------------
@@ -4956,53 +4844,6 @@ MapRect PROC  EXPORT
 		BRA 	MAPPT							;MAP BOTRIGHT AND RETURN
 
 
-MapRatio PROC  EXPORT
-;-------------------------------------------------------------
-;
-;  PROCEDURE MapRatio(VAR numer, denom: Point;  fromRect: Rect);
-;
-;  Map ratio so that denom.h/.v = height/width of fromRect.
-;  This is so that later scaling of the numerator will have some
-;  range to work within.
-;
-;  NOTE:  Only necessary because fractional numer, denom not used
-;
-;  numer.h :=  numer.h * fromWidth / denom.h
-;  denom.h :=  fromWidth
-;  numer.v :=  numer.v * fromHeight / denom.v
-;  denom.v :=  fromHeight
-
-PARAMSIZE		EQU 	12						; TOTAL BYTES OF PARAMS
-NUMER			EQU 	PARAMSIZE+8-4			; LONG, ADDR OF POINT
-DENOM			EQU 	NUMER-4					; LONG, ADDR OF POINT
-FROMRECT		EQU 	DENOM-4					; LONG, ADDR OF RECT
-
-		LINK	A6,#0							; NO LOCALS
-		MOVEM.L D0-D1/A0-A2,-(SP)				; SAVE REGS
-		MOVE.L	NUMER(A6),A0					; point to numer
-		MOVE.L	DENOM(A6),A1 					; point to denom
-		MOVE.L	FROMRECT(A6),A2					; point to fromRect
-
-		MOVE.W	right(A2),D0					; get fromRect right
-		SUB.W	left(A2),D0						; get fromWidth
-		MOVE.W	h(A0),D1						; get numer.h
-		MULU	D0,D1							; multiply by fromWidth
-		DIVU	h(A1),D1						; divide by denom.h
-		MOVE.W	D1,h(A0)						; update numer.h
-		MOVE.W	D0,h(A1)						; update denom.h
-
-		MOVE.W	bottom(A2),D0					; get fromRect bottom
-		SUB.W	top(A2),D0						; get fromHeight
-		MOVE.W	v(A0),D1						; get numer.v
-		MULU	D0,D1							; multiply by fromHeight
-		DIVU	v(A1),D1						; divide by denom.v
-		MOVE.W	D1,v(A0)						; update numer.v
-		MOVE.W	D0,v(A1)						; update denom.v
-
-DONE	MOVEM.L (SP)+,D0-D1/A0-A2				; RESTORE REGS
-		UNLINK	PARAMSIZE,'MAPRATIO'
-
-
 		ENDPROC 
 
 
diff --git a/QuickDraw/QDExtensions2.a b/QuickDraw/QDExtensions2.a
new file mode 100644
--- /dev/null
+++ b/QuickDraw/QDExtensions2.a
@@ -0,0 +1,44 @@
+QDEXTENSIONS2	PROC	EXPORT
+
+
+				cmp		#10,D0
+				bhi		@bad_selector
+				jmp		@jmptbl(D0.W * 4)
+
+
+@jmptbl
+				import	QDEXTENSIONS2_SELECTOR_0
+				jmp		QDEXTENSIONS2_SELECTOR_0
+				import	QDEXTENSIONS2_SELECTOR_1
+				jmp		QDEXTENSIONS2_SELECTOR_1
+				import	QDEXTENSIONS2_SELECTOR_2
+				jmp		QDEXTENSIONS2_SELECTOR_2
+				import	QDEXTENSIONS2_SELECTOR_3
+				jmp		QDEXTENSIONS2_SELECTOR_3
+				import	QDEXTENSIONS2_SELECTOR_4
+				jmp		QDEXTENSIONS2_SELECTOR_4
+				import	QDEXTENSIONS2_SELECTOR_5
+				jmp		QDEXTENSIONS2_SELECTOR_5
+				import	QDEXTENSIONS2_SELECTOR_6
+				jmp		QDEXTENSIONS2_SELECTOR_6
+				import	QDEXTENSIONS2_SELECTOR_7
+				jmp		QDEXTENSIONS2_SELECTOR_7
+				import	QDEXTENSIONS2_SELECTOR_8
+				jmp		QDEXTENSIONS2_SELECTOR_8
+				import	QDEXTENSIONS2_SELECTOR_9
+				jmp		QDEXTENSIONS2_SELECTOR_9
+				import	QDEXTENSIONS2_SELECTOR_10
+				jmp		QDEXTENSIONS2_SELECTOR_10
+
+
+@bad_selector
+				; The upper half of D0 contains the number of bytes of parameters
+				; on the stack
+
+				move.l	(SP)+,A0
+				swap	D0
+				ext.l	D0
+				add.l	D0,SP
+				move	#paramErr,D0
+				move	D0,QDErr
+				jmp		(A0)
diff --git a/QuickDraw/QDExtensions2.a.idump b/QuickDraw/QDExtensions2.a.idump
new file mode 100644
--- /dev/null
+++ b/QuickDraw/QDExtensions2.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/QuickDraw/QDUtil.a b/QuickDraw/QDUtil.a
--- a/QuickDraw/QDUtil.a
+++ b/QuickDraw/QDUtil.a
@@ -1389,7 +1389,7 @@ GETPIXEL
 		MOVEQ	#0,D2						;ROUTINE = GETPIXEL
 
 SHARE	LINK	A6,#VARSIZE					;ALLOCATE STACKFRAME
-		MOVEM.L	D4-D5/A2-A3,-(SP)			;SAVE WORK REGISTERS
+		MOVEM.L	D4-D6/A2-A3,-(SP)			;SAVE WORK REGISTERS
 		MOVE.L	THEGDEVICE,-(SP)			;SAVE CURRENT GRAFDEVICE
 		MOVE.L	GRAFGLOBALS(A5),A0			;POINT TO QUICKDRAW GLOBALS
 		MOVE.L	THEPORT(A0),A0				;GET THEPORT
@@ -1420,8 +1420,15 @@ OLDRB	MOVE	VLOC(A6),D4					;GET VERTICAL
 		MOVE	D4,-(SP)					;PUSH GLOBAL TOP
 		MOVE	D5,-(SP)					;PUSH GLOBAL RIGHT
 		MOVE	D4,-(SP)					;PUSH GLOBAL BOTTOM
-		MOVE.L	JShieldCursor,A1			;get lo mem vector
-		JSR 	(A1)						;and call it
+
+		MOVE.L	SP,A0
+		CLR.L	-(SP)
+		MOVE.L	A0,-(SP)
+		CLR.L	-(SP)
+		MOVE.L	#$80000,D0
+		DC.W	$ABE0						;_QDExtensions2
+		MOVE.L	(SP)+,D6
+		ADDQ	#8,SP
 
 		MOVE.L	DEVICELIST,A3				;GET FIRST IN DEVICE LIST
 
@@ -1518,9 +1525,11 @@ NOCOLOR	cmp.w	#16,pixelType(a3)			;direct device?
 
 DONE	tst.b	(sp)+						;pop and check crsrFlag
 		beq.s	@noShow						;need to show cursor?
-		_SHOWCURSOR							;show it
+		move.l	D6,-(SP)
+		move.l	#$40001,D0
+		dc.w	$ABE0						;_QDExtensions2
 @noShow	MOVE.L	(SP)+,THEGDEVICE			;RESTORE CURRENT GRAFDEVICE
-		MOVEM.L	(SP)+,D4-D5/A2-A3			;RESTORE WORK REGISTERS
+		MOVEM.L	(SP)+,D4-D6/A2-A3			;RESTORE WORK REGISTERS
 		UNLINK	PARAMSIZE,'GETCPIXEL'
 
 
@@ -4722,7 +4731,7 @@ DSTH		EQU		SRCH-4
 			MOVE.L	(A0),A0						; get SRC pointer
 			MOVE.L	(A1),A1						; get DST pointer
 			MOVE.L	D1,D0						; D0 = size
-			_BlockMove							; copy the data
+			_BlockMoveData						; copy the data
 
 DONE		MOVE.L	(SP)+,A0					; get return address
 			ADDQ	#8,SP						; strip parameters
diff --git a/QuickDraw/ScaleBlt.a b/QuickDraw/ScaleBlt.a
--- a/QuickDraw/ScaleBlt.a
+++ b/QuickDraw/ScaleBlt.a
@@ -127,7 +127,7 @@ multColor		EQU		RGNC-2				;byte, set if source contains nonblack/white colors
 ;
 		_StackAvail 						;GET STACK AVAIL IN D0.L
 		LSR.L	#2,D0						;CONVERT BYTES TO LONGS
-		SUB.L	#qdStackXtra,D0				;SUBTRACT SLOP FACTOR		<1.2> BAL
+		SUB.L	#$200,D0					;SUBTRACT SLOP FACTOR		<1.2> BAL
 		MOVE.L	D0,STACKFREE(A6)			;AND SAVE FREE LONGS ON STACK
 		bpl.s	@stkOK
 		_stNoStack							;=>NOT ENOUGH STACK, QUIT
diff --git a/QuickDraw/Stretch.a b/QuickDraw/Stretch.a
--- a/QuickDraw/Stretch.a
+++ b/QuickDraw/Stretch.a
@@ -9589,32 +9589,107 @@ Scale32to16	PROC	EXPORT
 ;	CLOBBERS A0-A1/D0-D5
 ;
 
+		tst.b	-$a5(a6)
+		bne.s	@different_implementation
+
+		lea		@sexy_code,a4
+		move.l	a4,-$228(a6)
+
+@sexy_code
 		move.l	a2,d2						;get ptr to end
 		sub.l	a1,d2						;sub ptr to beginning
 		lsr.l	#2,d2						;get long cnt in d1
 		subq	#1,d2						;make zero based
 
+		move.l	#$7fff7fff,d3
+
 @NXTSLNG 
 		MOVE.L	(A0)+,D0					;GET NEXT LONG OF SRC
-		ror.l	#8,d0
-		lsr.w	#3,d0
-		ror.l	#5,d0
-		lsr.w	#3,d0
-		ror.l	#6,d0						;16 bit pixel in high word
+		lsr.l	#3,d0
+		lsl.b	#3,d0
+		lsl		#3,d0
+		lsr.l	#6,d0
+		swap	d0
 
 		MOVE.L	(A0)+,D1					;GET NEXT LONG OF SRC
-		ror.l	#8,d1
-		lsr.w	#3,d1
-		ror.l	#5,d1
-		lsr.w	#3,d1
-		ror.l	#6,d1						;16 bit pixel in high word
+		lsr.l	#3,d1
+		lsl.b	#3,d1
+		lsl		#3,d1
+		lsr.l	#6,d1
 
-		swap	d1							;merge pixels
 		move.w	d1,d0
+		and.l	d3,d0
 		move.l	d0,(a1)+					;write out 2 pixels
 		dbra	d2,@NXTSLNG					;loop for all longs in dst scanline
 		RTS
 
+@different_implementation
+		clr.b	-$2a9(a6)
+		lea		@sexy_code_2,a4
+		move.l	a4,-$228(a6)
+
+@sexy_code_2
+		move.l	a2,d2
+		sub.l	a1,d2
+		lsr.l	#2,d2
+		subq	#1,d2
+		moveq.l	#3,d0
+		and.b	-$2a9(a6),d0
+		move.l	@data_tbl(d0.w*4),d3
+		addq.b	#1,-$2a9(a6)
+
+@loop
+		moveq.l	#0,d1
+		move.l	(a0)+,d0
+		swap	d0
+		add.b	d3,d0
+		scs.b	d1
+		or.b	d0,d1
+		lsl.l	#5,d1
+		swap	d0
+		move.b	d0,d4
+		lsr		#8,d0
+		add.b	d3,d0
+		scs.b	d1
+		or.b	d0,d1
+		lsl.l	#5,d1
+		add.b	d3,d4
+		scs.b	d1
+		or.b	d4,d1
+		lsr.l	#3,d1
+		move	d1,d5
+		rol.l	#8,d3
+		swap	d5
+		moveq.l	#0,d1
+		move.l	(a0)+,d0
+		swap	d0
+		add.b	d3,d0
+		scs.b	d1
+		or.b	d0,d1
+		lsl.l	#5,d1
+		swap	d0
+		move.b	d0,d4
+		lsr		#8,d0
+		add.b	d3,d0
+		scs.b	d1
+		or.b	d0,d1
+		lsl.l	#5,d1
+		add.b	d3,d4
+		scs.b	d1
+		or.b	d4,d1
+		lsr.l	#3,d1
+		move	d1,d5
+		move.l	d5,(a1)+
+		rol.l	#8,d3
+		dbf		d2,@loop
+		rts
+
+@data_tbl
+		dc.l	$05010400
+		dc.l	$03070206
+		dc.l	$04000501
+		dc.l	$02060307
+
 
 ; from QDciPatchROM.a verbatim												<sm 6/9/92>stb
 
diff --git a/Resources/MiscROMRsrcs.r b/Resources/MiscROMRsrcs.r
--- a/Resources/MiscROMRsrcs.r
+++ b/Resources/MiscROMRsrcs.r
@@ -223,110 +223,119 @@ resource 'accl' (7) {
 	}
 };
 
-resource 'accl' (8) {
-	'tpad',
-	{	/* array AcclTable: 6 elements */
-		/* [1] */
-		0x2000,
-		{	/* array AcclPoint: 5 elements */
-			/* [1] */
-			0x4692C, 0x10000,
-			/* [2] */
-			0xB9555, 0x38000,
-			/* [3] */
-			0x149555, 0x78000,
-			/* [4] */
-			0x1FAAAB, 0x110000,
-			/* [5] */
-			0x27D555, 0x1C8000
-		},
-		/* [2] */
-		0x5000,
-		{	/* array AcclPoint: 5 elements */
-			/* [1] */
-			0x4692C, 0x10000,
-			/* [2] */
-			0xB9555, 0x38000,
-			/* [3] */
-			0x14AAAB, 0xB0000,
-			/* [4] */
-			0x1FAAAB, 0x1A0000,
-			/* [5] */
-			0x27AAAB, 0x2E0000
-		},
-		/* [3] */
-		0x8000,
-		{	/* array AcclPoint: 5 elements */
-			/* [1] */
-			0x4692C, 0x10000,
-			/* [2] */
-			0xB1AAB, 0x39000,
-			/* [3] */
-			0x152AAB, 0xE8000,
-			/* [4] */
-			0x1FAAAB, 0x210000,
-			/* [5] */
-			0x276AAB, 0x368000
-		},
-		/* [4] */
-		0xB000,
-		{	/* array AcclPoint: 7 elements */
-			/* [1] */
-			0x4692C, 0x10000,
-			/* [2] */
-			0x6D332, 0x28000,
-			/* [3] */
-			0xA9555, 0x48000,
-			/* [4] */
-			0x10C000, 0xC0000,
-			/* [5] */
-			0x178000, 0x198000,
-			/* [6] */
-			0x1E5555, 0x288000,
-			/* [7] */
-			0x278000, 0x460000
-		},
-		/* [5] */
-		0xE000,
-		{	/* array AcclPoint: 7 elements */
-			/* [1] */
-			0x4692C, 0x10000,
-			/* [2] */
-			0x6D332, 0x28000,
-			/* [3] */
-			0xA1555, 0x58000,
-			/* [4] */
-			0xF8000, 0xE0000,
-			/* [5] */
-			0x161555, 0x1D0000,
-			/* [6] */
-			0x1D1555, 0x310000,
-			/* [7] */
-			0x27C000, 0x590000
-		},
-		/* [6] */
-		0x10000,
-		{	/* array AcclPoint: 9 elements */
-			/* [1] */
-			0x46AAB, 0x10000,
-			/* [2] */
-			0x69555, 0x28000,
-			/* [3] */
-			0x92AAB, 0x58000,
-			/* [4] */
-			0xE8000, 0xF0000,
-			/* [5] */
-			0x121555, 0x188000,
-			/* [6] */
-			0x158000, 0x248000,
-			/* [7] */
-			0x1C8000, 0x410000,
-			/* [8] */
-			0x224000, 0x580000,
-			/* [9] */
-			0x282AAB, 0x6D0000
-		}
-	}
+data 'accl' (8) {
+	$"0000 0003 0007 0000 0000 0001 0001 0000"
+	$"0001 0000 0000 2000 0005 0001 23C6 0001"
+	$"0000 0002 FE3C 0003 8000 0005 5719 000B"
+	$"0000 0008 2EBF 001A 0000 000A 3FF1 002E"
+	$"0000 0000 5000 0005 0001 23C6 0001 0000"
+	$"0002 DE8A 0004 1000 0005 682C 000F E000"
+	$"0008 1EBF 0022 6000 000A 1F68 0037 E000"
+	$"0000 8000 0007 0001 23C6 0001 0000 0001"
+	$"C378 0002 8000 0002 AC15 0004 A000 0004"
+	$"5402 000D C000 0006 1285 001B B000 0007"
+	$"E68B 002D 1000 000A 44EB 004A 9000 0000"
+	$"B000 0009 0001 2429 0001 0000 0001 B37C"
+	$"0002 8000 0002 5E5F 0005 8000 0003 BF2C"
+	$"000F 0000 0004 BC35 0017 A000 0006 1E38"
+	$"0027 B000 0007 5D45 0038 5000 0008 99A2"
+	$"004B B000 000A 9105 0066 B000 0000 E000"
+	$"000A 0001 1855 0001 3000 0001 B228 0002"
+	$"F000 0002 5369 0006 A000 0003 6F4A 0010"
+	$"D000 0004 6AAB 001F 1000 0005 4AAB 002D"
+	$"5000 0006 2555 003F 4000 0007 1AAB 0051"
+	$"C000 0008 9AAB 0066 3000 000A 8AAB 007D"
+	$"7000 0001 0000 000B 0001 1855 0001 3000"
+	$"0001 B228 0003 1000 0002 5369 0007 1000"
+	$"0003 2F4A 0011 8000 0003 ACFB 001C 8800"
+	$"0004 3AAB 0028 E000 0004 CAAB 0038 4000"
+	$"0005 5555 0048 F000 0006 3AAB 005C 9000"
+	$"0007 AAAB 0073 1000 000A 3AAB 008B 7000"
+};
+
+data 'accl' (9) {
+	$"5553 422A 0007 0000 0000 0001 0001 0000"
+	$"0001 0000 0000 2000 0010 0000 713B 0000"
+	$"4CE3 0004 4EC5 000D 3704 0005 4400 0014"
+	$"8000 0007 2C00 0023 E000 0009 0000 0034"
+	$"B000 000A D800 0045 F000 000D 0800 0057"
+	$"9000 000F 6000 0069 0000 0012 1000 007A"
+	$"8000 0015 0000 0089 0000 0017 C000 0091"
+	$"0000 001A C000 0096 B000 001D 9000 0099"
+	$"B000 0020 A000 009B 3000 0023 F000 009C"
+	$"3000 0027 B000 009C 3000 0000 8000 0012"
+	$"0000 713B 0000 567F 0004 4A00 000E A000"
+	$"0006 3A00 001F 4000 0007 2800 0029 0000"
+	$"0008 D800 003C 6000 0009 B800 0047 4000"
+	$"000A B000 0053 3000 000B C000 0060 3000"
+	$"000C C000 006C 2000 000E E000 0084 2000"
+	$"0011 6000 009D 2000 0014 0000 00B4 0000"
+	$"0016 C000 00C7 0000 0019 A000 00D4 0000"
+	$"001C E000 00DB 0000 0020 8000 00E0 0000"
+	$"0024 4000 00E3 0000 0027 A000 00E3 0000"
+	$"0000 B000 0014 0000 713B 0000 614E 0004"
+	$"4A00 000F 6000 0005 3200 0017 6000 0006"
+	$"3200 0020 A000 0007 2C00 002C 2000 0008"
+	$"0800 0037 A000 0008 E400 0043 4000 0009"
+	$"C000 0050 8000 000A A000 005F 2200 000B"
+	$"9000 006D 7000 000C 7000 007B 0000 000E"
+	$"8000 0098 A000 0010 C000 00B6 0000 0013"
+	$"4000 00D2 0000 0016 6000 00E9 0000 001A"
+	$"2000 00FA 0000 001D A000 0103 0000 0021"
+	$"2000 0107 0000 0024 8000 010A 0000 0027"
+	$"A000 010C 0000 0000 E000 0011 0000 713B"
+	$"0000 6D77 0004 1A00 0011 F000 0005 1A00"
+	$"001B F000 0005 F000 0026 6000 0006 FC00"
+	$"0034 0000 0008 4C00 004F E000 0009 6C00"
+	$"006D E000 000A 7800 008D C000 000B B000"
+	$"00B6 4000 000D 5000 00D9 8000 0011 0000"
+	$"00F7 8000 0015 C000 0111 0000 0019 6000"
+	$"0120 0000 001D 4000 0128 0000 0021 0000"
+	$"012E 0000 0024 8000 0132 0000 0027 8000"
+	$"0135 0000 0000 5000 0012 0000 713B 0000"
+	$"4BB0 0004 4C00 000E 0000 0005 4000 0015"
+	$"5000 0007 2400 0026 2000 0008 B400 0035"
+	$"C000 000A 9000 0049 8000 000B E800 0056"
+	$"8000 000D 2000 0062 0000 000E 1800 006A"
+	$"D000 000F 1800 0074 0000 0011 9000 0087"
+	$"8000 0014 5000 009A 0000 0017 6000 00A9"
+	$"8000 001A 6000 00B4 0000 001D 5000 00B9"
+	$"0000 0020 D000 00BC 8000 0024 2000 00BD"
+	$"8000 0027 B000 00BE 8000 0001 0000 0010"
+	$"0000 713B 0000 567F 0003 B800 0012 A000"
+	$"0005 2000 0025 4000 0006 0800 0037 8000"
+	$"0006 F000 005F 0000 0007 F000 008A 0000"
+	$"0009 2800 00CB 2000 000A F000 00F7 8000"
+	$"000D 2000 011C 8000 0010 0000 0138 0000"
+	$"0014 4000 014A 0000 0019 0000 0153 0000"
+	$"001C D000 0157 0000 0020 E000 015B 8000"
+	$"0024 2000 015D 8000 0027 A000 015E 0000"
+	$"0052 7000 0009 94D1 0059 3000 000A 1269"
+	$"005F F000 000A 9000 0066 B000 0000 E000"
+	$"001C 0001 1855 0001 3000 0001 B228 0002"
+	$"F000 0002 5369 0006 A000 0003 6F4A 0010"
+	$"D000 0003 AD78 0014 5800 0003 EBA5 0017"
+	$"E000 0004 29D3 001B 6800 0004 6800 001E"
+	$"F000 0004 A201 0022 9800 0004 D956 0026"
+	$"2000 0005 14AB 0029 6800 0005 5000 002C"
+	$"B000 0005 8001 0031 C800 0005 B556 0036"
+	$"4000 0005 EAAB 003A B800 0006 2000 003F"
+	$"3000 0006 6200 0043 DC00 0006 9EAB 0048"
+	$"7800 0006 DB56 004D 1400 0007 1800 0051"
+	$"B000 0007 7A01 0056 DC00 0007 D956 005B"
+	$"F800 0008 38AB 0061 1400 0008 9800 0066"
+	$"3000 0009 1601 006C 0000 0009 9156 0071"
+	$"D000 000A 0CAB 0077 A000 000A 8800 007D"
+	$"7000 0001 0000 0013 0001 1855 0001 3000"
+	$"0001 B228 0003 1000 0002 5369 0007 1000"
+	$"0003 2F4A 0011 8000 0003 ACFB 001C 8800"
+	$"0004 3AAB 0028 E000 0004 8156 0030 8800"
+	$"0004 C800 0038 3000 0005 0D56 0040 9800"
+	$"0005 5000 0048 F000 0005 C6AB 0052 B000"
+	$"0006 3800 005C 7000 0006 F156 0067 C000"
+	$"0007 4CAB 006D 5800 0007 A800 0072 F000"
+	$"0008 4C00 0079 0400 0008 F000 007F 1800"
+	$"0009 9400 0085 2C00 000A 3800 008B 4000"
 };
 
 resource 'pslt' (gestaltQuadra950, sysheap, locked) {
@@ -1165,6 +1174,264 @@ data 'PICT' (106, "DiskMode 6") {
 	};
 
 
+// XDiskIcon
+
+data 'cicn' (-20023) {
+	$"0000 0000 8010 0000 0000 0020 0020 0000"
+	$"0000 0000 0000 0048 0000 0048 0000 0000"
+	$"0004 0001 0004 0000 0000 0000 0000 0000"
+	$"0000 0000 0000 0004 0000 0000 0020 0020"
+	$"0000 0000 0004 0000 0000 0020 0020 0000"
+	$"0000 7FFF FFF0 FFFF FFF8 FFFF FFFC FFFF"
+	$"FFFE FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF 7FFF"
+	$"FFFE 7FFF FFF0 8100 0108 8100 7104 8100"
+	$"8902 8100 8901 8100 8901 8100 8901 8100"
+	$"8901 8100 7101 8100 0101 80FF FE01 8000"
+	$"0001 8000 0001 8000 0001 87FF FFE1 8800"
+	$"0011 8800 0011 8810 0811 8838 1C11 881C"
+	$"3811 880E 7011 8807 E011 8803 C011 8803"
+	$"C011 8807 E011 880E 7011 881C 3811 8838"
+	$"1C11 8810 0811 8800 0011 8800 0011 FFFF"
+	$"FFFE 0000 0000 0000 0007 0000 FFFF FFFF"
+	$"FFFF 0001 EEEE EEEE EEEE 0002 CCCC CCCC"
+	$"CCCC 0003 AAAA AAAA AAAA 0004 8888 8888"
+	$"8888 0005 7777 7777 7777 0006 2222 2222"
+	$"2222 000F 0000 0000 0000 0FFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF 0000 F222 3224 4444"
+	$"4444 4444 4444 1225 F000 F222 3224 4444"
+	$"4444 4666 4444 1222 5F00 F222 3224 4444"
+	$"4444 6222 1444 1222 25F0 F222 3224 4444"
+	$"4444 6222 1444 1222 225F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 4111 2444 1222 222F F222 3222 4444"
+	$"4444 4444 4442 1222 222F F222 2111 1111"
+	$"1111 1111 1111 1222 222F F222 2222 2222"
+	$"2222 2222 2222 2222 222F F222 2222 2222"
+	$"2222 2222 2222 2222 222F F222 2333 3333"
+	$"3333 3333 3333 3332 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2226"
+	$"2222 2222 6222 2221 222F F222 3222 2266"
+	$"6222 2226 6622 2221 222F F222 3222 2226"
+	$"6622 2266 6222 2221 222F F222 3222 2222"
+	$"6662 2666 2222 2221 222F F222 3222 2222"
+	$"2666 6662 2222 2221 222F F222 3222 2222"
+	$"2266 6622 2222 2221 222F F222 3222 2222"
+	$"2266 6622 2222 2221 222F F222 3222 2222"
+	$"2666 6662 2222 2221 222F F222 3222 2222"
+	$"6662 2666 2222 2221 222F F222 3222 2226"
+	$"6622 2266 6222 2221 222F F244 3222 2266"
+	$"6222 2226 6622 2221 222F F244 3222 2226"
+	$"2222 2222 6222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F 0FFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFF0"
+};
+
+
+// QDiskIcon
+
+data 'cicn' (-20022) {
+	$"0000 0000 8010 0000 0000 0020 0020 0000"
+	$"0000 0000 0000 0048 0000 0048 0000 0000"
+	$"0004 0001 0004 0000 0000 0000 0000 0000"
+	$"0000 0000 0000 0004 0000 0000 0020 0020"
+	$"0000 0000 0004 0000 0000 0020 0020 0000"
+	$"0000 7FFF FFF0 FFFF FFF8 FFFF FFFC FFFF"
+	$"FFFE FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF 7FFF"
+	$"FFFE 7FFF FFF0 8100 0108 8100 7104 8100"
+	$"8902 8100 8901 8100 8901 8100 8901 8100"
+	$"8901 8100 7101 8100 0101 80FF FE01 8000"
+	$"0001 8000 0001 8000 0001 87FF FFE1 8800"
+	$"0011 8800 0011 8807 E011 880F F011 880C"
+	$"3011 880C 3011 8800 7011 8800 E011 8801"
+	$"C011 8801 8011 8801 8011 8800 0011 8801"
+	$"8011 8801 8011 8800 0011 8800 0011 FFFF"
+	$"FFFE 0000 0000 0000 0007 0000 FFFF FFFF"
+	$"FFFF 0001 EEEE EEEE EEEE 0002 CCCC CCCC"
+	$"CCCC 0003 AAAA AAAA AAAA 0004 8888 8888"
+	$"8888 0005 7777 7777 7777 0006 2222 2222"
+	$"2222 000F 0000 0000 0000 0FFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF 0000 F222 3224 4444"
+	$"4444 4444 4444 1225 F000 F222 3224 4444"
+	$"4444 4666 4444 1222 5F00 F222 3224 4444"
+	$"4444 6222 1444 1222 25F0 F222 3224 4444"
+	$"4444 6222 1444 1222 225F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 4111 2444 1222 222F F222 3222 4444"
+	$"4444 4444 4442 1222 222F F222 2111 1111"
+	$"1111 1111 1111 1222 222F F222 2222 2222"
+	$"2222 2222 2222 2222 222F F222 2222 2222"
+	$"2222 2222 2222 2222 222F F222 2333 3333"
+	$"3333 3333 3333 3332 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2666 6662 2222 2221 222F F222 3222 2222"
+	$"6666 6666 2222 2221 222F F222 3222 2222"
+	$"6622 2266 2222 2221 222F F222 3222 2222"
+	$"6622 2266 2222 2221 222F F222 3222 2222"
+	$"2222 2666 2222 2221 222F F222 3222 2222"
+	$"2222 6662 2222 2221 222F F222 3222 2222"
+	$"2226 6622 2222 2221 222F F222 3222 2222"
+	$"2226 6222 2222 2221 222F F222 3222 2222"
+	$"2226 6222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F244 3222 2222"
+	$"2226 6222 2222 2221 222F F244 3222 2222"
+	$"2226 6222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F 0FFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFF0"
+};
+
+
+// DiskIcon
+
+data 'cicn' (-20021) {
+	$"0000 0000 8010 0000 0000 0020 0020 0000"
+	$"0000 0000 0000 0048 0000 0048 0000 0000"
+	$"0004 0001 0004 0000 0000 0000 0000 0000"
+	$"0000 0000 0000 0004 0000 0000 0020 0020"
+	$"0000 0000 0004 0000 0000 0020 0020 0000"
+	$"0000 7FFF FFF0 FFFF FFF8 FFFF FFFC FFFF"
+	$"FFFE FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFFF FFFF FFFF 7FFF"
+	$"FFFE 7FFF FFF0 8100 0108 8100 7104 8100"
+	$"8902 8100 8901 8100 8901 8100 8901 8100"
+	$"8901 8100 7101 8100 0101 80FF FE01 8000"
+	$"0001 8000 0001 8000 0001 87FF FFE1 8800"
+	$"0011 8800 0011 8800 0011 8800 0011 8800"
+	$"0011 8800 0011 8800 0011 8800 0011 8800"
+	$"0011 8800 0011 8800 0011 8800 0011 8800"
+	$"0011 8800 0011 8800 0011 8800 0011 FFFF"
+	$"FFFE 0000 0000 0000 0007 0000 FFFF FFFF"
+	$"FFFF 0001 EEEE EEEE EEEE 0002 CCCC CCCC"
+	$"CCCC 0003 AAAA AAAA AAAA 0004 8888 8888"
+	$"8888 0005 7777 7777 7777 0006 2222 2222"
+	$"2222 000F 0000 0000 0000 0FFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF 0000 F222 3224 4444"
+	$"4444 4444 4444 1225 F000 F222 3224 4444"
+	$"4444 4666 4444 1222 5F00 F222 3224 4444"
+	$"4444 6222 1444 1222 25F0 F222 3224 4444"
+	$"4444 6222 1444 1222 225F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 6222 1444 1222 222F F222 3224 4444"
+	$"4444 4111 2444 1222 222F F222 3222 4444"
+	$"4444 4444 4442 1222 222F F222 2111 1111"
+	$"1111 1111 1111 1222 222F F222 2222 2222"
+	$"2222 2222 2222 2222 222F F222 2222 2222"
+	$"2222 2222 2222 2222 222F F222 2333 3333"
+	$"3333 3333 3333 3332 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F244 3222 2222"
+	$"2222 2222 2222 2221 222F F244 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F F222 3222 2222"
+	$"2222 2222 2222 2221 222F 0FFF FFFF FFFF"
+	$"FFFF FFFF FFFF FFFF FFF0"
+};
+
+
+// HappyIcon
+
+data 'cicn' (-20020) {
+	$"0000 0000 8010 0000 0000 0020 0020 0000"
+	$"0000 0000 0000 0048 0000 0048 0000 0000"
+	$"0004 0001 0004 0000 0000 0000 0000 0000"
+	$"0000 0000 0000 0004 0000 0000 0020 0020"
+	$"0000 0000 0004 0000 0000 0020 0020 0000"
+	$"0000 0FFF FFE0 1FFF FFF0 1FFF FFF0 1FFF"
+	$"FFF0 1FFF FFF0 1FFF FFF0 1FFF FFF0 1FFF"
+	$"FFF0 1FFF FFF0 1FFF FFF0 1FFF FFF0 1FFF"
+	$"FFF0 1FFF FFF0 1FFF FFF0 1FFF FFF0 1FFF"
+	$"FFF0 1FFF FFF0 1FFF FFF0 1FFF FFF0 1FFF"
+	$"FFF0 1FFF FFF0 1FFF FFF0 1FFF FFF0 1FFF"
+	$"FFF0 1FFF FFF0 1FFF FFF0 1FFF FFF0 0FFF"
+	$"FFE0 0FFF FFE0 0FFF FFE0 0FFF FFE0 0FFF"
+	$"FFE0 0FFF FFE0 1000 0010 1000 0010 11FF"
+	$"FF10 1200 0090 1200 0090 1200 0090 1211"
+	$"1090 1211 1090 1201 0090 1201 0090 1203"
+	$"0090 1200 0090 1208 4090 1207 8090 1200"
+	$"0090 1200 0090 11FF FF10 1000 0010 1000"
+	$"0010 1000 0010 1000 0010 1300 FF10 1000"
+	$"0010 1000 0010 1000 0010 1000 0010 0FFF"
+	$"FFE0 0800 0020 0800 0020 0800 0020 0FFF"
+	$"FFE0 0000 0000 0000 000A 0000 FFFF FFFF"
+	$"FFFF 0001 0000 BBBB 0000 0002 CCCC CCCC"
+	$"FFFF 0003 CCCC CCCC CCCC 0004 8888 8888"
+	$"8888 0005 7777 7777 7777 0006 5555 5555"
+	$"5555 0007 4444 4444 4444 0008 2222 2222"
+	$"2222 0009 DDDD 0000 0000 000F 0000 0000"
+	$"0000 0000 FFFF FFFF FFFF FFFF FFFF FFF0"
+	$"0000 000F 3333 3333 3333 3333 3333 333F"
+	$"0000 000F 3333 3333 3333 3333 3333 333F"
+	$"0000 000F 3337 7777 7777 7777 7777 333F"
+	$"0000 000F 3372 2222 2222 2222 2222 033F"
+	$"0000 000F 3372 2222 2222 2222 2222 033F"
+	$"0000 000F 3372 2222 2222 2222 2222 033F"
+	$"0000 000F 3372 222F 222F 222F 2222 033F"
+	$"0000 000F 3372 222F 222F 222F 2222 033F"
+	$"0000 000F 3372 2222 222F 2222 2222 033F"
+	$"0000 000F 3372 2222 222F 2222 2222 033F"
+	$"0000 000F 3372 2222 22FF 2222 2222 033F"
+	$"0000 000F 3372 2222 2222 2222 2222 033F"
+	$"0000 000F 3372 2222 F222 2F22 2222 033F"
+	$"0000 000F 3372 2222 2FFF F222 2222 033F"
+	$"0000 000F 3372 2222 2222 2222 2222 033F"
+	$"0000 000F 3372 2222 2222 2222 2222 033F"
+	$"0000 000F 3330 0000 0000 0000 0000 333F"
+	$"0000 000F 3333 3333 3333 3333 3333 333F"
+	$"0000 000F 3333 3333 3333 3333 3333 333F"
+	$"0000 000F 3333 3333 3333 3333 3333 333F"
+	$"0000 000F 3333 3333 3333 3333 3333 333F"
+	$"0000 000F 3311 3333 3333 FFFF FFFF 333F"
+	$"0000 000F 3399 3333 3333 0000 0000 333F"
+	$"0000 000F 3333 3333 3333 3333 3333 333F"
+	$"0000 000F 3333 3333 3333 3333 3333 333F"
+	$"0000 000F 3333 3333 3333 3333 3333 333F"
+	$"0000 0000 FFFF FFFF FFFF FFFF FFFF FFF0"
+	$"0000 0000 F666 6667 7777 8888 8888 8FF0"
+	$"0000 0000 F555 5555 5667 7778 8888 8FF0"
+	$"0000 0000 F444 4444 4555 6677 7788 8FF0"
+	$"0000 0000 FFFF FFFF FFFF FFFF FFFF FFF0"
+	$"0000"
+};
+
+
 	type 'clut' (5) {
 		unsigned hex longint = 5;								/* ctSeed				*/
 		hex integer = $8000;									/* ctFlags				*/
@@ -1528,7 +1795,7 @@ resource 'ppat' (18, sysheap, locked) {
 	0,
 	$"0000 0000 0000 0300 0200 0000 0000 0000"
 	$"0000 0000 0030 0000 0000 0020 0000 0000",
-	0x1A0B,
+	0,
 	0,
 	{	/* array ColorSpec: 8 elements */
 		/* [1] */
diff --git a/Resources/ROMFonts.r b/Resources/ROMFonts.r
--- a/Resources/ROMFonts.r
+++ b/Resources/ROMFonts.r
@@ -837,44 +837,6 @@ data 'FONT' (12, sysheap) {
 	$"00 00 00 00 00 00 00 00 01 0B 03 0A 6D B6"          /* ............m∂ */
 };
 
-#if !hasAMIC 						/* on PDM, use sample simple beep <SM3> */
-
-resource 'snd ' (1, "Simple Beep", purgeable) {
-	FormatOne {{squareWaveSynth, 0}},
-	{
-		noData, timbreCmd {90},
-		noData, ampCmd {224},
-		noData, freqCmd {69},
-		noData, waitCmd {40},
-		noData, ampCmd {200},
-		noData, waitCmd {40},
-		noData, ampCmd {192},
-		noData, waitCmd {40},
-		noData, ampCmd {184},
-		noData, waitCmd {40},
-		noData, ampCmd {176},
-		noData, waitCmd {40},
-		noData, ampCmd {168},
-		noData, waitCmd {40},
-		noData, ampCmd {160},
-		noData, waitCmd {40},
-		noData, ampCmd {144},
-		noData, waitCmd {40},
-		noData, ampCmd {128},
-		noData, waitCmd {40},
-		noData, ampCmd {96},
-		noData, waitCmd {40},
-		noData, ampCmd {64},
-		noData, waitCmd {40},
-		noData, ampCmd {32},
-		noData, waitCmd {40},
-		noData, ampCmd {0}
-	},
-	{ }
-};
-
-#else								/* we're a PDM with a manly simple beep  <SM3> */
-
 data 'snd ' (1, "Simple Beep", purgeable) {
 	$"0001 0001 0005 0000 00A0 0001 8051 0000"            /* .........†..ÄQ.. */
 	$"0000 0014 0000 0000 0000 15D4 5622 0000"            /* ...........‘V".. */
@@ -1229,5 +1191,3 @@ data 'snd ' (1, "Simple Beep", purgeable) {
 	$"7676 7777 7878 797A 7B7C 7C7D 7F7F 8082"            /* vvwwxxyz{||}..ÄÇ */
 	$"8285 8789 8A8C 8D8D 8D8D 8C8B 8987 8583"            /* ÇÖáâäåççççåãâáÖÉ */
 };
-
-#endif
diff --git a/Resources/RomResources.r b/Resources/RomResources.r
--- a/Resources/RomResources.r
+++ b/Resources/RomResources.r
@@ -195,9 +195,6 @@ resource 'rrsc' (10, "Gibbly Guts") {
 	"Gibbly.rsrc",
 
 	{
-		'boot',
-		{ 3 };
-
 		'rovm',
 		{ 0 };
 	}
@@ -247,11 +244,21 @@ resource 'rrsc' (30, "kbd") {
 		'KCHR',
 		{ 0 };
 
+		'vadb',
+		{
+			0 /*ISO Cosmo*/,
+			1 /*JIS Cosmo*/,
+			2 /*ANSI Cosmo*/,
+			3 /*ISO Andy*/,
+			4 /*JIS Andy*/,
+			5 /*ANSI Andy*/
+		};
+
 		'KMAP',
-		{ 0, 2 };
+		{ 0, 2, 27, 198, 199, 200, 204, 205, 206 };
 
 		'KCAP',
-		{ 1,2,4,5 };
+		{ 1,2,4,5,14,16,17,198,199,200,204,205,206 };
 	}
 };
 
@@ -302,16 +309,7 @@ resource 'rrsc' (60, "MiscROMRsrcs") {
 
 	{
 		'accl',
-		{ 0, 1, 2, 3, 4, 5, 6, 7, 8 };
-
-		'pslt',
-		{ gestaltQuadra950,
-		  gestaltPowerBookDuo210, gestaltPowerBookDuo230,
-		  gestaltCyclone33,    gestaltTempest33,
-		  gestaltCentris660AV, gestaltQuadra840AV, 
-		  gestaltPDM50WLCD,    gestaltPDM66WLCD, gestaltPDM80WLCD,
-		  gestaltPDM50L,       gestaltPDM66L,    gestaltPDM80L,
-		  gestaltPDM66F,       gestaltPDM80F,    gestaltPDM100F};
+		{ 0, 1, 2, 4, 5, 6, 7, 8, 9 };
 
 		'ics#',
 		{ -16386 };
@@ -322,6 +320,9 @@ resource 'rrsc' (60, "MiscROMRsrcs") {
 		'ics8',
 		{ -16386 };
 
+		'cicn',
+		{ -20023, -20022, -20021, -20020 };
+
 		'clut',
 		{ 5, 9 };
 
@@ -549,18 +550,6 @@ resource 'rrsc' (200, "DataAccessMgr") {
 };
 
 
-resource 'rrsc' (500, "DictionaryMgr") {
-	kUniversal,
-	AllCombos,
-	{RsrcDir},
-	"DictionaryMgr.rsrc",
-
-	{
-		'dimg',
-		{ -16385 };
-	}
-};
-
 resource 'rrsc' (210, "HelpMgr") {
 	hasSysSevenResources,
 	AllCombos,
@@ -588,18 +577,6 @@ resource 'rrsc' (220, "PictUtilities") {
 	}
 };
 
-resource 'rrsc' (230, "Sony") {
-	kUniversal,
-	AllCombos,
-	{RsrcDir},
-	"Sony.rsrc",
-
-	{
-		'DRVR',
-		{ 4 };
-	}
-};
-
 resource 'rrsc' (240, "SCCIOP") {
 	hasIopScc,
 	AllCombos,
@@ -612,38 +589,14 @@ resource 'rrsc' (240, "SCCIOP") {
 	}
 };
 
-resource 'rrsc' (250, "Serial") {
-	kUniversal,
-	AllCombos,
-	{RsrcDir},
-	"Serial.rsrc",
-
-	{
-		'SERD',									/* common IOP/Bypass serial driver */
-		{ 0 };
-	}
-};
-
-resource 'rrsc' (260, "SerialIOP") {
-	hasIopScc,
-	AllCombos,
-	{RsrcDir},
-	"Serial.rsrc",
-
-	{
-		'SERD',									/* port A, B IOP serial drivers */
-		{ 60, 61 };
-	}
-};
-
 resource 'rrsc' (270, "SerialDMA") {
-	hasPSC || hasAMIC,
+	kUniversal,
 	AllCombos,
-	{RsrcDir},
+	{MiscDir},
 	"SerialDMA.rsrc",
 
 	{
-		'SERD',									/* universal driver */
+		'nsrd',
 		{ 1 };
 	}
 };
@@ -952,28 +905,6 @@ resource 'rrsc' (455, "I2CC") {
 	}
 };
 
-resource 'rrsc' (460, "Ethernet") {
-	kUniversal,
-	AllCombos,
-	{MiscDir},																					/* <LW18> */
-	"Ethernet.RSRC",
-
-	{
-/*		'DRVR',								DRVR from Ethernet.RSRC is out-of-date */
-/*		{ 127 };							We want the one from AppleTalk.ROM.RSRC */
-
-		'enet',								/* ENET Driver for LC Ethernet Card */
-		{ 46 };								/* ONLY in ROM to allow ELAN PSD enet card */
-											/* to work when netbooting, ie. before a system */
-											/* file is opened which has a good enet drvr in it,
-											/* on 030 cpus, LCII, etc. */
-
-		'ecfg',								    /* Enet Config resources for new Enet Driver */ /* <LW18> */
-		{ 19, 20, 22, 26, 27, 30, 35, 36,
-		  116,117,118,119,120,121,122,123};		/* Rsrc ID's are gestaltMachineType codes */	/* <LW18> */
-	}
-};
-
 resource 'rrsc' (461, "Ethernet2") {
 	hasMace,
 	AllCombos,
@@ -1011,95 +942,29 @@ resource 'rrsc' (480, "Backlight") {
 	}
 };
 
-// Sound Manager resources
-
-// sifter 'thng' resource IDs
-#define kRate8ResID				-16557
-#define kRate16ResID			-16558
-#define kConverterResID			-16559
-#define kSndSourceResID			-16560
-#define kMixerResID				-16561
-#define kASCResID				-16563
-#define kClassicResID			-16564
-#define kDSPResID				-16565
-#define kMace3ResID				-16566
-#define kMace6ResID				-16567
-#define kCDXAResID				-16576
-#define kAwacsResID				-16569
-#define kAwacsPhoneResID		-16570
-
-// component descriptor string IDs
-#define kRate8StringResID		-16577
-#define kRate16StringResID		-16578
-#define kConverterStringResID	-16579
-#define kSndSourceStringResID	-16580
-#define kMixerStringResID		-16581
-#define kASCStringResID			-16583
-#define kClassicStringResID		-16584
-#define kDSPStringResID			-16585
-#define kMace3StringResID		-16586
-#define kMace6StringResID		-16587
-#define kCDXAStringResID		-16588
-#define kAwacsStringResID		-16569
-#define kAwacsPhoneStringResID	-16571
-
-// sound 'proc' resource IDs
-#define kSoundInputResID		-16497
-#define kPlayFromDiskResID		-16498
-
-// Sound Manager resource IDs
-#define kMeterControlDefID		62
-#define kSoundDriverID			3
-#define kBatmanInputDriverID	-16499
-#define kAwacsInputDriverID		-16500
-#define kPreferenceNameID		-16568
-#define	iWrongOutputSampleRate	-16526
-
-resource 'rrsc' (490, "Sound") {
+resource 'rrsc' (335, "LANDisk") {
 	kUniversal,
 	AllCombos,
-	{RsrcDir},
-	"SoundMgr.rsrc",
+	{MiscDir},
+	"LANDisk.rsrc",
 
 	{
-		'CDEF',
-		{ kMeterControlDefID };
-		
-		'DRVR',
-		{ kSoundDriverID,kBatmanInputDriverID,kAwacsInputDriverID };
-
-		'proc',
-		{ kPlayFromDiskResID, kSoundInputResID };
-
-		'sift',
-		{ kRate8ResID, kRate16ResID, kConverterResID, kSndSourceResID,
-		  kMixerResID, kASCResID, kMace3ResID, kAwacsResID };
-
-		'adio',
-		{ kAwacsPhoneResID };
-
-		'thng',
-		{ kRate8ResID, kRate16ResID, kConverterResID, kSndSourceResID,
-		  kMixerResID, kASCResID, kMace3ResID, kMace6ResID, kAwacsResID, kAwacsPhoneResID };
-
-		'ICON',
-		{ kRate8ResID, kSndSourceResID, kMixerResID, kASCResID, kAwacsPhoneResID };
-
-
-/* re: we'll leave these resources in here so sound will work without a gibbly. They'll be on */
-/* disk too.																				  */
-
-		'STR ',
-		{ kRate8ResID, kRate16ResID, kConverterResID, kSndSourceResID, kMixerResID,
-		  kASCResID, kMace3ResID, kMace6ResID, kPreferenceNameID, kRate8StringResID,
-		  kRate16StringResID, kConverterStringResID, kMixerStringResID, kASCStringResID,
-		  kMace3StringResID, kMace6StringResID, kAwacsStringResID, kAwacsPhoneResID,
-		  kAwacsPhoneStringResID };
+		'dfrg',
+		{ -20722 };
 	}
 };
 
+resource 'rrsc' (435, "BCScreen") {
+	kUniversal,
+	AllCombos,
+	{MiscDir},
+	"BCScreen.rsrc",
 
-// End of SoundMgr items
+	{
+		'ndrv',
+		{ -16515 };
+	}
+};
 
 resource 'rrsc' (501, "EmulatorAccelerations") {
 	hasMixedMode,
@@ -1113,6 +978,20 @@ resource 'rrsc' (501, "EmulatorAccelerations") {
 	}
 };
 
+resource 'rrsc' (599, "Multiprocessing") {
+	hasMixedMode,
+	AllCombos,
+	{MiscDir},
+	"MultiprocessingServices.rsrc",
+
+	{
+		'ncod',
+		{ 2 /*MPLibrary*/ };
+		'nlib',
+		{ 3 /*MPSharedGlobals*/ };
+	}
+};
+
 resource 'rrsc' (502, "GoNative") {
 	hasMixedMode,
 	AllCombos,
@@ -1120,56 +999,174 @@ resource 'rrsc' (502, "GoNative") {
 	"GoNativeResources",
 
 	{
+		'cfrf',
+		{ 0 };
+
 		'ncod',
 		{ 0,1,8 };
 
 		'nlib',
-		{ 5,6,9,10,11,15,16,17,18,19,20 };
+		{
+			5 /*InterfaceLib*/,
+			6 /*PrivateInterfaceLib*/,
+			7 /*BootStdCLib*/,
+			8 /*MathLibGlobals*/,
+			9 /*MathLib*/,
+			10 /*StdCLib*/,
+			-16420 /*Math64Lib*/,
+			-20264 /*CursorDevicesLib*/
+		};
 	}
 };
 
-resource 'rrsc' (504, "Password") {
-	kUnused,
+resource 'rrsc' (503, "DriverServices") {
+	hasMixedMode,
 	AllCombos,
-	{RsrcDir},
-	"MiscROMRsrcs.rsrc",
+	{MiscDir},
+	"DriverServices.rsrc",
 
 	{
-		'ICON',
-		{29296}
+		'ntrb',
+		{ -16400 /*NameRegistryTraps*/ };
+
+		'nlib',
+		{ -16400 /*NameRegistryLib*/, -16407 /*DSLGlobalsLib*/, -16401 /*DriverServicesLib*/, -16402 /*DriverLoaderLib*/, -16404 /*PCILib*/, -16403 /*VideoServicesLib*/, -16405 /*VideoServicesGlobals*/ };
+	}
+};
+
+resource 'rrsc' (504, "PowerMgr") {
+	kUniversal,
+	AllCombos,
+	{MiscDir},
+	"PowerMgr.rsrc",
+
+	{
+		'nlib',
+		{ -16411 /*PowerMgrLib*/ };
+
+		'scod',
+		{ -20961, -20984 };
+	}
+};
+
+resource 'rrsc' (605, "ATAMgr") {
+	kUniversal,
+	AllCombos,
+	{MiscDir},
+	"ATAMgr.rsrc",
+
+	{
+		'DRVR',
+		{ 53 /*.ATADisk*/, -20175 /*.ATALoad*/ };
+	}
+};
+
+resource 'rrsc' (607, "NativeNub -- for Power Mac Debugger?") {
+	hasMixedMode,
+	AllCombos,
+	{MiscDir},
+	"NativeNub.rsrc",
+
+	{
+		'ncod',
+		{ 50 /*NativeNub*/ };
+	}
+};
+
+resource 'rrsc' (610, "Native SCSI Mgr 4.3") {
+	hasMixedMode,
+	AllCombos,
+	{MiscDir},
+	"NativeItt.rsrc",
+
+	{
+		'nitt',
+		{ 43 /*Native 4.3*/ };
+		'gcko',
+		{ 43 /*Main*/ };
 	}
 };
 
-resource 'rraa' (105, "TNT Boot beep") {
+resource 'rrsc' (620, "PCCard") {
+	kUniversal,
+	AllCombos,
+	{MiscDir},
+	"PCCard.rsrc",
+
+	{
+		'ndrv',
+		{ -20166 /*DefaultPCCardEnabler*/, -20181 /*pccard-ata*/ };
+	}
+};
+
+resource 'rrsc' (630, "MediaBay") {
+	kUniversal,
+	AllCombos,
+	{MiscDir},
+	"MediaBay.rsrc",
 
-	hasGrandCentral,
+	{
+		'ndrv',
+		{ -20164 /*media-bay*/ };
+		'code',
+		{ -20164 /*Main*/ };
+	}
+};
 
+resource 'rrsc' (640, "Native ATAMgr") {
+	hasMixedMode,
 	AllCombos,
+	{MiscDir},
+	"ATAMgr.rsrc",
 
-	{MiscDir},			/* Path Name */
-	
-	"BootBeep.rsrc",	/* File Name */
-	
-	'beep',				/* Resource Type */  
-	
-	0x0000,				/* Resource ID */
-	
-	0x00200000			 /* ROM Address */
+	{
+		'nlib',
+		{ -20186 /*ATAManager*/ };
+	}
 };
 
-resource 'rraa' (110, "TNT error beep") {
+resource 'rrsc' (650, "USB") {
+	kUniversal,
+	AllCombos,
+	{MiscDir},
+	"USB.rsrc",
 
-	hasGrandCentral,
+	{
+		'nlib',
+		{ -20776 /*USBServicesLib*/, -20777 /*USBFamilyExpertLib*/, -20778 /*USBManagerLib*/ };
+		'ndrv',
+		{ -20776 /*pciclass,0c0310*/ };
+		'usbd',
+		{ -20776 /*USBHubDriver0*/, -20777 /*USBHubDriver1*/, -20778 /*USBHIDKeyboardModule*/, -20779 /*USBHIDMouseModule*/, -20780 /*USBCompositeDriver*/ };
+		'usbf',
+		{ -20776 };
+		'usbs',
+		{ -20781 /*USBShimKeyboard*/, -20782 /*USBShimMouse*/ };
+		'ndrv',
+		{ -20777 /*USBUnitTableStorageDriver*/ };
+		'usbs',
+		{ -20776 /*USBMassStorageLoader*/ };
+		'usbd',
+		{ -20781 /*USBMassStorageClassDriver*/, -20782 /*USBMassStorageVSDriver*/ };
+	}
+};
 
+resource 'rrsc' (660, "FireWire") {
+	kUniversal,
 	AllCombos,
+	{MiscDir},
+	"FireWire.rsrc",
 
-	{MiscDir},			/* Path Name */
-	
-	"ErrorBeep.rsrc",	/* File Name */
-	
-	'beep',				/* Resource Type */  
-	
-	0x0000,				/* Resource ID */
-	
-	0x00220000			 /* ROM Address */
+	{
+		'ndrv',
+		{ -21143 /*fw609e,10483*/ };
+		'fexp',
+		{ -21140 /*ComponentDriverExpert*/, -21141 /*GenericDriverFamilyExpert*/ };
+		'frag',
+		{ -21140 /*FWPCIScanner*/, -21141 /*FWExpertRegistration*/, -21142 /*sbp609e,104d8*/ };
+		'gpch',
+		{ 1207 /*Main*/ };
+		'ndrv',
+		{ -20994 /*sbp609e,104d8*/ };
+	}
 };
diff --git a/Toolbox/ComponentMgr/ThingManager.c b/Toolbox/ComponentMgr/ThingManager.c
--- a/Toolbox/ComponentMgr/ThingManager.c
+++ b/Toolbox/ComponentMgr/ThingManager.c
@@ -290,6 +290,22 @@ pascal long goComponentRegister(long theComponent ) = ComponentCallNow( kCompone
 pascal long goComponentUnregister(long theComponent ) = ComponentCallNow( kComponentUnregisterSelect,0);
 
 
+// (CDG5) moved up here for no obvious reason
+long RegisteredComponentPointerToComponentID(register RegisteredComponent *rt)		/* should be a macro */
+	{																				/* don't let valid components be negative */
+	return rt ? ( rt - ComponentManagerGlobals->rtTable + ((long)rt->rtEntryUseCount<<16) ) : 0;
+	}
+
+
+// (CDG5) moved up here for no obvious reason
+long ComponentInstancePointerToComponentInstanceID(register RegisteredComponentInstance *rti)		/* should be a macro */
+	{
+	return rti ? ( rti - ComponentManagerGlobals->rtInstanceTable + ((long)rti->rtiEntryUseCount<<16) ) : 0;
+	}
+
+
+
+
 // Gestalt proc for returning the version of the installed Component Mgr
 pascal OSErr GestaltComponentMgrVersion(OSType selector, long* responsePtr)
 {
@@ -502,12 +518,6 @@ pascal long __GetComponentListModSeed( )
 	}
 
 
-long RegisteredComponentPointerToComponentID(register RegisteredComponent *rt)		/* should be a macro */
-	{																				/* don't let valid components be negative */
-	return rt ? ( rt - ComponentManagerGlobals->rtTable + ((long)rt->rtEntryUseCount<<16) ) : 0;
-	}
-
-
 #if 1
 	#define ComponentIDtoRegisteredComponentPointer(t) ((RegisteredComponent *)( ComponentManagerGlobals->rtTable + (short)(t & 0xffff)))
 #else
@@ -713,7 +723,7 @@ pascal Component __RegisterComponent(ComponentDescription *td, ComponentRoutine
 	saveZone = (THz)GetZone();
 
 	if (global & registerComponentGlobal)
-		SetZone(*(THz *)SysZone);
+		SetZone(SystemZone());
 	new->rtNameHand = cmHandToHand( ComponentName );
 	new->rtInfoHand = cmHandToHand( ComponentInfo );
 	new->rtIconHand = cmHandToHand( ComponentIcon );
@@ -772,8 +782,10 @@ pascal Component __RegisterComponentResource(ComponentResource **htr, short glob
 	long	version = 0;
 	short	platformType;
 
+	if (global & 0x80) TempInsertROMMap(true);
+
 	GetResInfo((Handle)htr, &resID, &resType, wastedName);			// don't need the name under system 7
-	if (result = ResError()) return 0;
+	if (ResError()) return 0;
 
 	saveState = HGetState((Handle)htr);
 	HLock((Handle)htr);
@@ -820,15 +832,20 @@ pascal Component __RegisterComponentResource(ComponentResource **htr, short glob
 				new->rtFlags |= rtfHasIconSuite;
 			}
 
+		if (global & 0x80) {
+			new->rtFileNumber = -1;
+		} else {
 		new->rtFileNumber = AddComponentResFile( (Handle)htr );
 		if ( new->rtFileNumber < 0)
 			{
 #ifdef	WARHOL_DEBUG
 			Debugger();						/* should never fail (can fail if no memory and couldn't get a file id)*/
 #endif
+			new->rtFileNumber = -2;
 			UnregisterComponent(result);
 			return 0;
 			}
+		}
 		componentRoutine = NewHandleSys(0);
 		EmptyHandle(componentRoutine);
 
@@ -853,6 +870,10 @@ pascal Component __RegisterComponentResource(ComponentResource **htr, short glob
 				UnregisterComponent(result);
 				return 0;
 				}
+			else
+				{
+				new = ComponentIDtoRegisteredComponentPointer(result);
+				}
 
 		// scan the Component table for possible duplicates and kill the older one(s) (if auto versioning on)
 		// (can't do this before the register message since we might call GetComponentVersion on the component,
@@ -890,16 +911,62 @@ pascal long __RegisterComponentResourceFile(short resRefNum, short global)
 	{
 		register short count, i;
 
-		if ((count = Count1Resources(kComponentResourceType)) > 0)
+		// ALL of the new variable definitions
+		short listResCount; short j, k; Handle subhdl; short elCnt;
+
+		short resID; // -$0112(A6)
+		OSType resType; // -$0116(A6)
+		Str255 wastedName; // -$0110(A6)
+
+		// (CDG5) First load component resources in the order specified
+		// by any 'thn#' resources, which are arrays of (type, id).
+		listResCount = Count1Resources('thn#');
+		for (j=1; j<=listResCount; j++)
+		{
+			hdl = Get1Resource('thn#', j);
+			if (hdl)
+			{
+				elCnt = GetHandleSize(hdl) / 6;
+				for (k=0; k<elCnt; k++)
+				{
+					subhdl = Get1Resource(*(OSType *)(*hdl + 6*k), *(short *)(*hdl + 6*k + 4));
+					if (subhdl)
+					{
+						if (RegisterComponentResource((ComponentResource **)subhdl, global))
+						{
+							err++;
+						}
+					}
+				}
+			}
+		}
+
+		// (CDG5) the original loop with a twist...
+		count = Count1Resources(kComponentResourceType);
 		{
 			for (i=1; i<=count; i++)
 			{
 				hdl = Get1IndResource(kComponentResourceType, i);
 				if (hdl)
 					{
+										if (listResCount) {
+											GetResInfo(hdl, &resID, &resType, wastedName);
+											for (j=1; j<=listResCount; j++) {
+												subhdl = Get1IndResource('thn#', j);
+												if (subhdl) {
+													elCnt = GetHandleSize(subhdl) / 6;
+													for (k=0; k<elCnt; k++) {
+														if (*(OSType *)(*hdl + 6*k) == resType && *(short *)(*hdl + 6*k + 4) == resID) {
+															goto alreadyDoneResource;
+														}
+													}
+												}
+											}
+										}
 					if (RegisterComponentResource((ComponentResource **)hdl, global))
 						err++;						/* we registered something */
 					}
+										alreadyDoneResource:;
 			}
 		}
 	}
@@ -1191,14 +1258,6 @@ RegisteredComponentInstance *ComponentInstanceIDToComponentInstancePointer( regi
 
 
 
-long ComponentInstancePointerToComponentInstanceID(register RegisteredComponentInstance *rti)		/* should be a macro */
-	{
-	return rti ? ( rti - ComponentManagerGlobals->rtInstanceTable + ((long)rti->rtiEntryUseCount<<16) ) : 0;
-	}
-
-
-
-
 RegisteredComponentInstance *FindNextComponentInstance( register RegisteredComponentInstance *rti,  register RegisteredComponent *rt )
 	{
 	register short i;
@@ -1349,7 +1408,7 @@ pascal long __LoadComponent( long componentID )
 
 				saveZone = (THz)GetZone();
 				if (!rt->rtLocalA5)
-					SetZone(*(THz *)SysZone);
+					SetZone(SystemZone());
 				if (entryPoint = Get1Resource(resSpec.resType, resSpec.resID))
 					{
 					LoadResource(entryPoint);
@@ -1752,7 +1811,7 @@ pascal OSErr __GetComponentInfoPrivate( Component aComponent, Handle  nameHand,
 			short saveRes = CurResFile();
 			short resRef;
 
-			SetZone(*(THz *)SysZone);
+			SetZone(SystemZone());
 
 			resRef = OpenComponentResFile(aComponent);
 			if (resRef != -1) {
diff --git a/Toolbox/ControlMgr/ControlMgr.a b/Toolbox/ControlMgr/ControlMgr.a
--- a/Toolbox/ControlMgr/ControlMgr.a
+++ b/Toolbox/ControlMgr/ControlMgr.a
@@ -255,6 +255,7 @@ CMGR			PROC	  EXPORT
 ; External Routines used by Control Manager
 ;
 				IMPORT	GetNewRgn
+				IMPORT	FlushCRange
 
 ;
 ;  FUNCTION NewControl( window: 	windowPtr;
@@ -302,8 +303,6 @@ NewControl
 				MOVE.L	A0,(A4) 				;also, its the function result
 				MOVE.L	(A3),A2 				;handle -> pointer
 
-				TST.B	MMU32Bit				; are we in 32-bit mode?				<C777/09Feb87> DAF
-				BEQ.S	@1						; nope, so continue						<C612/12Jan87> DAF
 				SF.B	contrlVis(A2)			; set this temporarily, so SetCtlColor won't try to draw <C612/12Jan87> DAF
 				MOVE.L	A3,-(SP)				; push controlHandle					<C612/12Jan87> DAF
 				MOVE.L	#-1,-(SP)				; push -1 to make a new rec with default CTab <C612/12Jan87> DAF
@@ -371,8 +370,6 @@ GetCDefProc
 
 				MOVE.W	(A4),D0 				;get resource ID
 				AND 	#$000F,D0				;use only low 4 bits
-				TST.B	MMU32Bit				; is it in 32-bit mode?			<C777/09Feb87> DAF
-				BEQ.S	@1						; nope, so hide in hi-byte 		<C612/12Jan87> DAF
 				MOVE.L	A0,-(SP)				; save A0						<C612/12Jan87> DAF
 				MOVE.L	D0,-(SP)				; save D0 too					<C612/12Jan87> DAF
 				SUBQ	#6,SP					; get placeholder for auxCtlHndl, and boolean result <C612/12Jan87> DAF
@@ -385,10 +382,7 @@ GetCDefProc
 				MOVE.L	(SP)+,D0				; restore D0 (with variant)		<C612/12Jan87> DAF
 				MOVE.B	D0,acReserved(A0)		; put variant in auxRec			<C612/12Jan87> DAF<1.6>
 				MOVE.L	(SP)+,A0				; restore A0					<C612/12Jan87> DAF
-				BRA.S	@2						; all done						<C612/12Jan87> DAF
-@1
-				MOVE.B	D0,(A0) 				;keep in high byte of handle
-@2
+
 				ADDQ	#4,A0					;bump to next field
 
 				CLR.L	(A0)+					;init dataHandle
@@ -470,9 +464,7 @@ CallControl
 				MOVE.W	(SP)+,10(SP)			; move from top of stack to placeholder <C491/08Dec86> DAF
 
 				MOVE.L	(A3),A0 				;get pointer to control structure
-				MOVE.L	ContrlDefHandle(A0),D0	;get handle of controlProc			<C491/08Dec86> DAF
-				_StripAddress					;clean variant code out of hi byte 	<C491/08Dec86> DAF
-				MOVE.L	D0,A0					;copy to an A-reg					<C491/08Dec86> DAF
+				MOVE.L	ContrlDefHandle(A0),A0	;get handle of controlProc			<C491/08Dec86> DAF
 				TST.L	(A0)					;needs reloading?
 				BNE.S	SkipCLoad				;if not,skip
 
@@ -497,7 +489,12 @@ SkipCLoad
 				_GetHandleSize					; How big is our CDEF Handle					<LW3> fau
 				cmp.l		#32,D0				; Is it "small"									<LW6> chp
 				bhi.s		@RealCDEF			; no, don't flush the cache						<LW3> fau
-				jsr			([jCacheFlush])		; else, flush the caches.						<LW3> fau
+				move.l		A0,-(SP)
+				move.l		(A0),A0
+				move.l		D0,A1
+				bsr.l		FlushCRange			; else, flush the caches.						<LW3> fau
+				move.l		(SP)+,A0
+
 @RealCDEF										;												<LW3> fau
 				_HLock							; lock it down				<C424/18Nov86>
 				MOVE.L	(A0),A0 				;get cDefProc ptr
@@ -527,8 +524,6 @@ NoDControl
 
 GetCVariant										;					<C491/08Dec86> DAF
 				MOVE.L	4(SP),A0 				; get ctl handle
-				TST.B	MMU32Bit				; are we in 32-Bit mode?		<C777/09Feb87> DAF
-				BEQ.S	@1						; no, so do it the old way		<C612/12Jan87> DAF
 				SUBQ	#6,SP					; leave room for result and boolean	<C612/12Jan87> DAF
 				MOVE.L	A0,-(SP)				; push the controlHandle		<C612/12Jan87> DAF
 				PEA		6(SP)					; point to result placeholder	<C612/12Jan87> DAF
@@ -538,12 +533,7 @@ GetCVariant										;					<C491/08Dec86> DAF
 				MOVE.L	(A0),A0					; get the auxRecPtr				<C612/12Jan87> DAF
 				CLR.W	D0						; clear top byte				<C612/12Jan87> DAF
 				MOVE.B	acReserved(A0),D0		; get variant code				<C612/12Jan87> DAF<1.6>
-				BRA.S	@2						;								<C612/12Jan87> DAF
-@1
-				MOVE.L	(A0),A0					; get ctl ptr
-				MOVE.B	ContrlDefHandle(A0),D0	; get selector parameter
-				AND.W	#$000F,D0				; lo nybble only
-@2
+
 				MOVE.W	D0,8(SP)				; return result
 				MOVE.L	(SP)+,A0				; get return addr
 				ADDQ	#4,SP					; flush parameters
@@ -569,18 +559,10 @@ EraseControl
 				_NewRgn 						;allocate a new region
 				MOVE.L	(SP),A4 				;keep the region in A4, keep on stack
 
-				TST.B	MMU32Bit				;are we in 32-bit mode?						<1.3>
-				BEQ.S	@24bit					;no, don’t call new message					<1.3>
 				MOVEQ	#CalcWholeCtlMsg,D0		;message is calculate whole regions			<1.2>
 				MOVE.L	A4,D1					;the region is the parameter				<1.2>
-				BSR.S	CallControl 			;send it the message						<1.2>
-				BRA.S	@doneCalc 				;											<1.2>
-@24bit											;											<1.3>
-				MOVEQ	#CalcCtlMsg,D0			;message is calculate regions
-				MOVE.L	A4,D1					;the region is the parameter
-				BCLR	#31,D1					;hi-bit clear means whole thing
-				BSR.S	CallControl 			;send it the message
-@doneCalc
+				BSR		CallControl 			;send it the message						<1.2>
+
 ;
 ; paint white to erase control and add it to the window’s update region
 ;
@@ -657,9 +639,6 @@ DontEraseControl								;										<3>
 				MOVE.L	(A0),A0					; get auxCtlRec ptr
 				MOVE.L	acCTable(A0),-(SP)		; push default colors hndl				<1.6>
 
-				TST.B	MMU32Bit					; are we in 32-bit mode?								<1.4/DAF>
-				BEQ.S	@CtlRec24					; nope, so get rid of it the easy, old-fashioned way	<1.4/DAF>
-
 				LEA		AuxCtlHead,A1				; get the head of the auxCtlList (offset is zero so this works!)
 @10
 				MOVE.L	(A1),A2						; get the handle to the auxCtlRec
@@ -684,11 +663,6 @@ DontEraseControl								;										<3>
 				MOVE.L	A2,A0						; release the auxCtlRec
 				_DisposHandle						;
 				ADDQ	#4,SP						; get rid of the extra window pointer pushed above
-				BRA.S	@CtlRecDone					;
-
-@CtlRec24
-				_SetCtlColor					; set this control’s colors to default (and delete)
-@CtlRecDone
 
 ;
 ; delete it from the window’s controlList
@@ -991,7 +965,7 @@ GetCTitle
 				MOVEQ	#0,D0					;clear high part
 				MOVE.B	(A0),D0 				;get length of string
 				ADDQ.L	#1,D0					;include the length byte, too
-				_BLOCKMOVE						;move it in place
+				_BLOCKMOVEDATA					;move it in place
 				RTS 							;all done!
 ;
 ; PROCEDURE SetCTitle(theControl: controlHandle; theTitle: Str255);
@@ -1034,7 +1008,7 @@ CopyCTitle										;									<3>
 				MOVE.L	(A3),A1 				;get control pointer
 				LEA 	ContrlTitle(A1),A1		;point to title string
 				ADDQ	#1,D0					;dont forget the length byte
-				_BlockMove						;move it in
+				_BlockMoveData					;move it in
 ;
 ; make it visible if it used to be
 ;
@@ -1221,8 +1195,6 @@ DragCon1
 ;
 				JSR 	GetNewRgn				;allocate a new region
 
-				TST.B	MMU32Bit				;are we in 32-bit mode?						<1.3>
-				BEQ.S	@24bit					;no, don’t call new message					<1.3>
 				MOVEQ	#CalcWholeCtlMsg,D0		;message is calculate whole regions			<1.2>
 				TST.W	DragFlag				;if we’re called as real MoveControl,		<1.2>
 				BEQ.S	@0						;then we picked the right message			<1.2>
@@ -1230,16 +1202,7 @@ DragCon1
 @0												;											<1.2>
 				MOVE.L	(SP),D1					;the region is the parameter				<1.2>
 				BSR.S	CallControl 			;send it the message						<1.2>
-				BRA.S	@doneCalc 				;											<1.2>
-@24bit											;											<1.3>
-				TST.W	DragFlag				;if we’re called as real MoveControl,
-				SNE 	(SP)					;high bit off means we want whole thing
-				MOVE.L	(SP),D1 				;parameter goes in D1
-				MOVEQ	#CalcCtlMsg,D0			;tell controlProc to calculate it regions
-				BSR 	CallControl 			;tell the control about it
-;
-				CLR.B	(SP)					;clear high byte of region
-@doneCalc
+
 				MOVE.L	(SP)+,A4				;keep it in A4
 ;
 ;  set up the parameters for dragging the region around (careful -- extra reg
diff --git a/Toolbox/DeskMgr/DeskMgr.a b/Toolbox/DeskMgr/DeskMgr.a
--- a/Toolbox/DeskMgr/DeskMgr.a
+++ b/Toolbox/DeskMgr/DeskMgr.a
@@ -237,6 +237,8 @@ SearchWindow
 				MOVE	windowKind(A0),D0		; get the unit number from window
 				BPL.S	noGoodSearch			; if not sys. kind, ignore it
 				NOT 	D0						; flip it (bitwise)
+				CMP		UnitNtryCnt,D0
+				BPL.S	noGoodSearch
 				ASL 	#2,D0					; * 4
 				MOVE.L	UTableBase,A0			; point to the driver table
 				MOVE.L	0(A0,D0),A0 			; get the handle
@@ -255,12 +257,12 @@ SendDrvrMsg
 				MOVEQ	#64,D0					;message 64 is "feedEvent"
 ;
 SendDCommon
-				LINK	A6,#-32 				;get some space for the control p-block
-				LEA 	IORefNum-32(A6),A0		;point A0 at the block
+				LINK	A6,#-50 				;get some space for the control p-block
+				LEA 	IORefNum-50(A6),A0		;point A0 at the block
 				MOVE.W	DCtlRefNum(A1),(A0)+	;set up the refNum
 				MOVE.W	D0,(A0)+				;set up the control "opCode"
 				MOVE.L	A3,(A0) 				;set up event ptr as parameter
-				LEA 	-32(A6),A0				;point to pBlock
+				LEA 	-50(A6),A0				;point to pBlock
 				_Control  ,IMMED				;make the control call
 ;
 				UNLK	A6						;de-allocate parameter block
@@ -304,11 +306,11 @@ DiskHandler		tst.w	EvtMessage(A3)			;if an Eject event,			<C150/09sep86>
 				jsr		(A0)					;eject the disk				<C150/09sep86>
 				bra.s	DoneSysEvt				;mark as taken, no error	<C150/09sep86>
 
-@1				SUB.W	#24,SP					;allocate 24 bytes on stack
+@1				SUB.W	#64,SP
 				MOVE.L	SP,A0					;point to it
 				MOVE.W	EvtMessage+2(A3),IODrvNum(A0) ;get the "disk ID" parameter
 				_MountVol						;tell OS to do its thing
-				ADD.W	#24,SP					;deallocate space on stack
+				ADD.W	#64,SP					;deallocate space on stack
 				MOVE.W	D0,EvtMessage(A3)		;return result to application
 				BRA 	DoneSEvt				;always return "FALSE"
 
@@ -652,10 +654,14 @@ SystemTask
 
 ; begin roll-in HMSystemTaskPatch patch												<11>
 
-				IMPORT	ptchHMGetBalloons		;									<11>
+				MOVE.L	ExpandMem,A0			; (This rolled-in HelpMgr patch code has
+				MOVE.L	ExpandMemRec.emHelpGlobals(A0),D0	; been protected by a check
+				BEQ.S	@BalloonsOff			; of HelpMgr presence in CDG5)
 
-				JSR		ptchHMGetBalloons		; what is the state of What Is? mode?		<11>
-				BEQ.S	@BalloonsOff			; no, let's not scan for a content window	<11>
+				CLR		-(SP)					; (ptchHMGetBalloons becomes trap in CDG5)
+				_HMGetBalloons
+				TST.B	(SP)+					; what is the state of What Is? mode?
+				BEQ.S	@BalloonsOff			; no, let's not scan for a content window
 
 				SUBQ	#2,SP					; make room for a dummy OSErr		<11>
 				_HMBalloonBulk					;									<11>
@@ -668,7 +674,7 @@ SystemTask
 				IMPORT	NMTask					;									<V1.1>
 				JSR		NMTask					;Give time to Notification Manager	<V1.1>
 
-				MOVEM.L D3/A3,-(SP) 			;save some work registers
+				MOVEM.L D2-D4/A3-A4,-(SP) 		;save some work registers
 ;
 ; if this is a re-entrant call, just punt
 ;
@@ -701,7 +707,9 @@ SystemTask
 
 NotSWindow
 				MOVE.L	UTableBase,A3			;point to the driver table
+				MOVE.L	A3,A4
 				MOVE.W	UnitNtryCnt,D3			;get number of entries
+				MOVE.L	D3,D4
 ;
 ; here is the main loop for SystemTask.  For each driver that's installed, see if
 ; it needs time.  If so, send it the RUN message.
@@ -729,9 +737,10 @@ SysTLoop
 				MOVEQ	#0,D0					;zero high part of D0
 				MOVE.W	DCtlDelay(A1),D0		;get delay tick count
 				BEQ.S	DoItNow 				;if zero, always do it
-				ADD.L	DCtlCurTicks(A1),D0 	;figure out next time to call it
-				CMP.L	Ticks,D0				;has that time passed yet?
-				BGT.S	NextTSys				;if not, don't call it
+				MOVE.L	Ticks,D2
+				SUB.L	DCtlCurTicks(A1),D2
+				CMP.L	D0,D2
+				BCS.S	NextTSys
 ;
 ; its time to give it a call
 ;
@@ -741,12 +750,18 @@ DoItNow
 ;
 ; here is the bottom of the main loop.	See if there are any more entries to process
 ;
+				CMP.L	UTableBase,A4
+				BNE.S	NotSWindow
+
+				CMP		UnitNtryCnt,D4
+				BNE.S	NotSWindow
+
 NextTSys
 				SUBQ.W	#1,D3
 				BGT.S	SysTLoop				;loop if there's more to do
 				_SetPort						;restore it
 				CLR.B	TaskLock				;flag that we're done
-TaskDone		MOVEM.L (SP)+,D3/A3 			;restore work registers
+TaskDone		MOVEM.L (SP)+,D2-D4/A3-A4 		;restore work registers
 				RTS 							;return to caller
 ;
 ; PROCEDURE SystemMenu(menuResult: LongInt);
@@ -774,8 +789,8 @@ SystemMenu
 				SWAP	D1								;put the high word back
 				MOVE.L	D1,-(SP)						;move it onto the stack
 				PEA		(SP)							;push the address
-				IMPORT	CHANGEMENURESULTFORINPUTMETHOD
-				JSR		CHANGEMENURESULTFORINPUTMETHOD	;and send it to the input method
+				MOVE	#35,D0
+				_TSMDispatch							;and send it to the input method
 				ADDQ	#4,SP							;get rid of space for menuresult
 				MOVE.L	(SP)+,(SP)						;strip parameter
 				RTS										;return to caller
@@ -893,8 +908,8 @@ DoneSEdit
 OpenDeskAcc
 				CLR.W	8(SP)			   ;return 0 as the default
 
-				SUB 	#32,SP			   ;get 32 bytes for a parameter block
-				MOVE.L	36(SP),IOFileName(SP)  ;set up name
+				SUB 	#50,SP			   ;get 32 bytes for a parameter block
+				MOVE.L	54(SP),IOFileName(SP) ;set up name
 				CLR.W	IODrvNum(SP)	   ;use default volume
 				MOVE.W	#$0040, IOFileType(SP) ;clear type byte, special permissions to ID OpenDeskAcc
 				CLR.L	IOOwnBuf(SP)	   ;use system buffer
@@ -904,7 +919,7 @@ OpenDeskAcc
 				BNE.S	DoneOpenDAcc	   ;if an error, don't return refNum
 
 				MOVE.W	IORefNum(SP),D0    ;get the refNum
-				MOVE	D0,40(SP)		   ;return the refNum
+				MOVE	D0,58(SP)		   ;return the refNum
 
 ; figure out the DCE ptr
 
@@ -926,7 +941,7 @@ OpenDeskAcc
 				_ShowWindow 					;show it!
 
 DoneOpenDAcc
-				ADD.W	#32,SP					;strip the pBlock
+				ADD.W	#50,SP					;strip the pBlock
 				MOVE.L	(SP)+,(SP)				;strip parameter
 				RTS
 
@@ -935,11 +950,11 @@ DoneOpenDAcc
 
 CloseDeskAcc
 				MOVE.W	4(SP),D0				;get the refNum
-				SUB 	#30,SP					;get space for param block
+				SUB 	#50,SP					;get space for param block
 				MOVE.W	D0,IORefNum(SP) 		;set up refNum
 				MOVE.L	SP,A0
 				_Close							;close it!
-				ADD 	#30,SP					;pop off param block
+				ADD 	#50,SP					;pop off param block
 TwoByteExit
 				MOVE.L	(SP)+,A0
 				ADDQ	#2,SP
diff --git a/Toolbox/DialogMgr/DialogDispatch.a b/Toolbox/DialogMgr/DialogDispatch.a
--- a/Toolbox/DialogMgr/DialogDispatch.a
+++ b/Toolbox/DialogMgr/DialogDispatch.a
@@ -98,7 +98,9 @@ DialogMgrDispatch	BeginDispatcher	_DialogDispatch
 
 DMgrPushMenuState	PROC		EXPORT
 				IMPORT PushMenuState
-				JMP PushMenuState
+				JSR PushMenuState
+				MOVE.L (SP)+,4(SP)
+				RTS
 				ENDPROC
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
@@ -606,8 +608,6 @@ kBOCorner		 EQU 	16			; Radius for outline frame
 				tst.b		defaultBtn.kind+1(a6)	; is default button enabled?
 				bpl.s		@patSet					; if so,l just draw
 
-				cmp.w		#$3FFF,ROM85			; if (not on a color system)
-				bhi.s		@bwGrafPort				; 	    or
 				move.w		portVersion(a4),d0 		;
 				and.w		#$C000,d0			 	; 	 (not a color grafport)
 				bne.s		@colorGrafport			;
diff --git a/Toolbox/DialogMgr/DialogMgr.a b/Toolbox/DialogMgr/DialogMgr.a
--- a/Toolbox/DialogMgr/DialogMgr.a
+++ b/Toolbox/DialogMgr/DialogMgr.a
@@ -359,8 +359,8 @@ eventMeta	EQU 		theEvent+14 			; Meta keys
 ; ——————————————————————————————————————————————————————————————————————————————————
 colorDctb	EQU			theEvent-4				; handle to color table for dialog item list
 colorWctb	EQU			colorDctb-4				; handle to color table for alert/dialog
-unused		EQU			colorWctb-1				;
-oldVis		EQU			unused-1				; byte set if window is to be visible
+useShowWind	EQU			colorWctb-1				; setUpCDialog to use _ShowWindow vs _ShowHide
+oldVis		EQU			useShowWind-1			; byte set if window is to be visible
 returnAddr	EQU			oldVis-4				; saved address so common code can access stack frame
 saveFColor	EQU			returnAddr-6			; space for port fore rgb
 saveBColor	EQU			saveFColor-6			; space for port back rgb
@@ -590,6 +590,7 @@ DoAlert
 			TST.L		colorWctb(A6)			; colors?
 			BEQ.S		@useoldDialog
 			ST			oldVis(A6)				; make it visible later
+			ST			useShowWind(A6)			; all alerts get a _ShowWindow (all are frontmost)
 			BSR			setUpCDialog
 			BRA.S		@commonDlg
 
@@ -773,6 +774,13 @@ GetNewDialog
 			MOVE.L		A0, -(SP)				; Push copy back on.
 			TST.L		colorWctb(A6)			; try for color resource
 			BEQ.S		@noDialogColors
+
+			SF			useShowWind(A6)			; dialogs are only frontmost if
+			MOVEQ		#-1,D0					; -1 is passed instead of a
+			CMP.L		8(A6),D0				; window ptr
+			BNE.S		@notFrontmost
+			ST			useShowWind(A6)
+@notFrontmost
 			BSR.S		setUpCDialog
 			BRA.S		@getnewDlogCommon
 
@@ -804,9 +812,8 @@ setUpCDialog
 			TST.B		oldVis(A6)				; should it be visible?
 			BEQ.S		@notVisible
 			MOVE.L		(SP),-(SP)				; pass the window
-			MOVEQ		#-1,D0
-			CMP.L		8(A6),D0				; is it the front window?
-			BEQ.S		@useShowWindow
+			TST.B		useShowWind(A6)			; use _ShowWindow instead of _ShowHide
+			BNZ.S		@useShowWindow
 			ST			-(SP)					; make it visisble
 			_ShowHide
 			BRA.S		@notVisible
@@ -853,7 +860,7 @@ GotStorage
 			MOVEQ		#30, D0 				; Copy 30 bytes of parameters
 			SUB.L		D0, SP					; Subtract for stack frame
 			MOVE.L		SP, A1					; Copy to the stack
-			_BlockMove							; Copy all parameters except Items
+			_BlockMoveData						; Copy all parameters except Items
 			TST.L		D5
 			BEQ.S		@useOldWindow
 			_NewCWindow
@@ -966,12 +973,13 @@ IsDialogEvent
 
 			IMPORT		NotOwnActivator			; from DialogMgrExtensions.a									<9>
 			IMPORT		FakeUpEvent				; from DialogMgrExtensions.a									<9>
-			IMPORT		ptchHMGetBalloons		; <SM12> rb
 			
 			BSR 		StdEntry				; Link A6, save regs.
 
-			JSR			ptchHMGetBalloons		; what is the state of What Is? mode?				<SM12> rb, start
-			BEQ.S		@BalloonsOff			; no, let's not scan for a content window
+			CLR		-(SP)						; (ptchHMGetBalloons becomes trap in CDG5)
+			_HMGetBalloons
+			TST.B	(SP)+						; what is the state of What Is? mode?
+			BEQ.S	@BalloonsOff				; no, let's not scan for a content window
 
 			SUBQ		#2,SP					; make space for OsErr
 			_HMTrackModalHelpItems
@@ -1131,7 +1139,7 @@ ValidDS											; not an osEvt													<9>
 			MOVE.L		DSEvent(A6), A0 		; Copy the passed event in DSEvent
 			LEA 		theEvent(A6), A1		; to theEvent for easy decomposition
 			MOVEQ		#EvtBlkSize,D0
-			_BlockMove							; theEvent is the first event.
+			_BlockMoveData						; theEvent is the first event.
 
 			BSR 		EventAD 				; Handle event--result in D3
 			TST.W		D3						; Check to see if my event or not
@@ -1181,10 +1189,11 @@ ModalDialog
 ; begin roll-in ModalDialogSetFlagsAndAddFilter patch													<9>
 
 			IMPORT	StdFilter				; from DialogDispatch.a										<9>
-			IMPORT	ptchHMGetBalloons		;														<SM12> rb
 			
-			JSR		ptchHMGetBalloons		; what is the state of What Is? mode?					<SM12> rb
-			BEQ.S	@BalloonsOff			; no, let's not scan for a content window				<SM12> rb
+			CLR		-(SP)						; (ptchHMGetBalloons becomes trap in CDG5)
+			_HMGetBalloons
+			TST.B	(SP)+						; what is the state of What Is? mode?
+			BEQ.S	@BalloonsOff				; no, let's not scan for a content window
 
 			SUBQ	#2,SP					; make space for OsErr									<SM12> rb
 			_HMTrackModalHelpItems			;														<SM12> rb
@@ -1861,7 +1870,7 @@ GetIText
 okStrLength
 			MOVE.B		D0,(A1)+				; set dest string length
 			MOVE.L		(A0), A0				; Dereference
-			_BlockMove							; Copy those bytes!
+			_BlockMoveData						; Copy those bytes!
 
 			BRA.S		TwoLongExit 			; ...and exit
 
diff --git a/Toolbox/DialogMgr/ModalDialogMenuExtensions.a b/Toolbox/DialogMgr/ModalDialogMenuExtensions.a
--- a/Toolbox/DialogMgr/ModalDialogMenuExtensions.a
+++ b/Toolbox/DialogMgr/ModalDialogMenuExtensions.a
@@ -116,8 +116,7 @@ MDJGNEFilter	Proc 	Export
 				movem.l	(sp)+,d0-d2/a0-a2
 
 		IF forROM THEN
-				import	NMGNEFilter				; from NotificationMgr.c
-				pea		NMGNEFilter				; call NMGNEFilter
+				; No longer pass on to the Notification Mgr (it does not do modal any more)
 		ELSE
 				peaOld							; call the old filter
 												; note: we can use peaOld here because
diff --git a/Toolbox/DialogMgr/ModalDialogMenuExtensions.c b/Toolbox/DialogMgr/ModalDialogMenuExtensions.c
--- a/Toolbox/DialogMgr/ModalDialogMenuExtensions.c
+++ b/Toolbox/DialogMgr/ModalDialogMenuExtensions.c
@@ -126,6 +126,7 @@
 #include <Processes.h>
 #include <TextUtils.h>
 #include <Windows.h>
+#include <Types.h>
 
 #include <DialogsPriv.h>
 #include <MenuMgrPriv.h>
@@ -139,16 +140,16 @@
 
 typedef struct
 	{
-	short		lastMenu;
-	short		lastRight;
-	short		reserved;
+	UInt16		lastMenu;
+	UInt16		lastRight;
+	UInt16		reserved;
 	}
 MenuListHeader;
 
 typedef struct
 	{
 	MenuHandle	handle;
-	short		left;
+	UInt16		left;
 	}
 MenuListEntry;
 
@@ -186,7 +187,7 @@ enum
 	kApplicationHandlesMenus,
 	kHandleSystemMenusDisabled,
 	kHandleMenusEditMenuDisabled,
-	kHandleMenusEditMenuEnabled,
+	kHandleMenusEditMenuEnabled
 	};
 typedef short TAnalyzedWindowState;
 
diff --git a/Toolbox/FontMgr/BassExtensions.a b/Toolbox/FontMgr/BassExtensions.a
--- a/Toolbox/FontMgr/BassExtensions.a
+++ b/Toolbox/FontMgr/BassExtensions.a
@@ -357,6 +357,7 @@ INSTALLBASSCOMMON	Proc	Export
 		import		fs_GetGlyphInfo, fs_GetGlyphData
 		import		fs_GetBitMapInfo, fs_GetBitMapData
 	endif
+		import		DOINITPARTIALFONTS
 		case		obj
 
 ;——————————————————————————————————————————————————————————————————————————————————————————
@@ -490,11 +491,13 @@ INSTALLBASSCOMMON	Proc	Export
 		MOVE.L		expandMem, A0				; get low mem expand
 		MOVE.L		ExpandMemRec.emSplineKey(A0),A0		; Handle to splineKey
 		_HUnlock						; Unlock splineKey globals
+		BSR			DOINITPARTIALFONTS	; Init partial fonts
 		rts							; Exit anyway
 	
 @bailOut
 		MOVE.L	expandMem, A2				; get low mem expand
 		CLR.L	ExpandMemRec.emSplineKey(A2)		; Handle to splineKey
+		BSR		DOINITPARTIALFONTS
 		RTS							; <=== in any case
 
 ;——————————————————————————————————————————————————————————————————————————————————————————
@@ -546,6 +549,16 @@ INITZONEGLUE	PROC  EXPORT
 		_InitZone
 		Add 	#14,SP			;strip parameters
 		JMP 	(A1)			;return via A1
+
+;——————————————————————————————————————————————————————————————————————————————————————————
+; Init partial font (TrueType) support -- puts big locked block in sys heap, so do early
+;——————————————————————————————————————————————————————————————————————————————————————————
+DOINITPARTIALFONTS	Proc	Export
+		SUBQ	#2,SP
+		MOVE.L	#48*1024,-(SP)		; size of partial-font heap zone in system heap
+		_InitializePartialFonts
+		ADDQ	#2,SP
+		RTS
 ;•••••••••••••••••••••••••••••••••••••••
 ;——————————————————————————————————————————————————————————————————————————————————————————
 ;								END Spline_PatcheeTail.a!!!
diff --git a/Toolbox/FontMgr/Bass_Cache.c b/Toolbox/FontMgr/Bass_Cache.c
--- a/Toolbox/FontMgr/Bass_Cache.c
+++ b/Toolbox/FontMgr/Bass_Cache.c
@@ -857,7 +857,7 @@ Handle sb_SizeTheBlock(sb_SplineKeyHdl splineKey, Handle inputH, THz* inputZone,
 				
 				if (newH = sb_NewZoneHandle(splineKey, size, &newZ)) {
 				
-					BlockMove( *h, *newH, origSize );
+					BlockMoveData( *h, *newH, origSize );
 					sb_DisposeZoneHandle( h, *zone );			/* <28-CEL> assigned zone before disposing caused problems */
 
 					if (cachePlace != -1) {		/* <28-CEL> Need to update cache info in cacheList */
@@ -2037,7 +2037,7 @@ long AppendSplineDirectoryToWidthTable( Handle splineHandle, widthTableHdl width
 			SetHandleSize( (Handle) widthTableHandle, sizeof( widthTable ) + splineDirectorySize );
 			if ( (error = MemError( )) == noErr ) {
 			
-				BlockMove( (Ptr) splineDirectoryPointer, (Ptr) (*widthTableHandle)->fSplineDirectory, splineDirectorySize );
+				BlockMoveData( (Ptr) splineDirectoryPointer, (Ptr) (*widthTableHandle)->fSplineDirectory, splineDirectorySize );
 				
 			}
 		
diff --git a/Toolbox/FontMgr/DiskCache/Source/DiskCacheMap.c b/Toolbox/FontMgr/DiskCache/Source/DiskCacheMap.c
--- a/Toolbox/FontMgr/DiskCache/Source/DiskCacheMap.c
+++ b/Toolbox/FontMgr/DiskCache/Source/DiskCacheMap.c
@@ -239,7 +239,7 @@ void FontNameIndexToFontName( StringPtr fontNamePointer, Integer fontNameIndex,
 	
 	}
 	
-	BlockMove( (Ptr) stringEntryPointer->fString, (Ptr) fontNamePointer, stringEntryPointer->fString[0] + 1 );
+	BlockMoveData( (Ptr) stringEntryPointer->fString, (Ptr) fontNamePointer, stringEntryPointer->fString[0] + 1 );
 	
 }
 
@@ -307,7 +307,7 @@ OSErr FontNameToFontNameIndex( Integer *fontNameIndexPointer, StringPtr fontName
 		} else {
 		
 			stringEntryPointer->fReferenceCount = 1;
-			BlockMove( (Ptr) fontNamePointer, (Ptr) stringEntryPointer->fString, fontNamePointer[0] + 1 );
+			BlockMoveData( (Ptr) fontNamePointer, (Ptr) stringEntryPointer->fString, fontNamePointer[0] + 1 );
 			*fontNameIndexPointer = stringListPointer->fStringCount++;
 			
 		}
diff --git a/Toolbox/FontMgr/FontMgr.a b/Toolbox/FontMgr/FontMgr.a
--- a/Toolbox/FontMgr/FontMgr.a
+++ b/Toolbox/FontMgr/FontMgr.a
@@ -1343,7 +1343,7 @@ MoreDifFont
 			MOVE.L	8(A6),A0				; pick up request pointer
 			LEA		copyInput(A6),A1
 			MOVEQ	#$10,D0
-			_BlockMove						; make copy of request
+			_BlockMoveData					; make copy of request
 			MOVE.L	A1,A3
 
 			MOVE.B	fmInFace(A3),FOutCurStyle ; set up desired style
@@ -1943,13 +1943,9 @@ LookForColor
 
 			MOVE.L	FOutFontHandle,A0		; could be a 1 bit ROM font
 			BSR		DerefResource			; get a pointer to it
-			MOVE.L	A0,D0
-			_StripAddress					; but only look at the valid part of the address
-			MOVE.L	D0,A0
 			MOVE.L	ROMBase,D0				; do the same to the ROM base pointer
-			_StripAddress
 			CMP.L	D0,A0					; is it below the ROM?
-			BLT.S	@noEntry				; if so, skip looking for a expanded font in the ROM
+			BCS.S	@noEntry				; if so, skip looking for a expanded font in the ROM
 			MOVE	D5,D0
 			BSR		LoadNewStrike			; then look in ROM
 			BEQ.S	@noEntry
@@ -2160,7 +2156,7 @@ LookForColor
 			ADD.L	D0,A1					; don’t forget header size
 			SUB.L	D0,D2					; take out header from size of post-strike tables
 			MOVE.L	D2,D0
-			_BlockMove						; move tables after the strike
+			_BlockMoveData					; move tables after the strike
 			
 		; put pixel size in stack record for MakeScaleTbl
 			MOVEQ	#1,D4
@@ -2255,7 +2251,7 @@ AddToSynList
 			MOVE.L	widthNFNT(A0),(A1)+		; save the font ID, NFNT flag
 			LEA		foreBack(A6),A0
 			MOVEQ	#rgbColor*2,D0			; size of foreground, background colors
-			_BlockMove						; move foreground, background
+			_BlockMoveData					; move foreground, background
 			
 ; new font should only be made purgable at next DifFont time
 ; this means FontMgr needs to know that it was a “synthetic” font via font flag
@@ -3293,7 +3289,7 @@ SetScreenDevice
 			LEA 	FMDotsPerInch,A1		; get place to stash info
 			LEA 	ScreenStyleTab,A0		; point to the info
 			MOVEQ	#28,D0					; 28 bytes of info to move
-			_BlockMove						; move it in
+			_BlockMoveData					; move it in
 			RTS
 
 ; -------------------------------------------------------------------------------------
@@ -3365,35 +3361,11 @@ LoadSplineFontResource
 			_SizeRsrc							; get the size of the resource
 			move.l	(sp)+,d0					; pop the resource size
 			cmp.l	#128*1024,d0				; is the spline size greater than 128k?
-			bgt.s	@LoadEmptySplineIntoSystemHeap	; yes, load an empty spline into the system heap
+			bgt.s	@Exit						; yes, so just leave an empty spline handle
+												; (old code would force this hdl to system heap)
 
 			move.l	resourceHandle(a6),-(sp)	; push empty resource handle
 			_LoadResource						; load the resource into memory
-			bra.s	@Exit						; return
-
-; The spline font is bigger than 128K, so don’t load it into memory, but create an empty
-; handle for it in it’s resource reference entry.  We can probably get rid of the call to
-; ReleaseResource and the zone mucking, since it’s pretty unlikely for a font to be loaded
-; in the application heap these days.  For example, fonts from the system and the Fonts
-; folder automatically load in the system heap.  Fonts will go in the application heap
-; if the application is carrying the font around.  But at this point in the code, the
-; 'sfnt' is larger than 128K, and it’s unlikely that applications will be carrying around
-; fonts of this size.  But I’m too chicken to get rid of these lines at this point in
-; 7.1’s schedule.
-
-@LoadEmptySplineIntoSystemHeap
-			move.l	resourceHandle(a6),-(sp)	; push resource handle
-			_ReleaseResource					; get rid of empty spline from some application heap
-			
-			move.w	#MapFALSE,ROMMapInsert		; don't load sfnt into memory
-			move.l	TheZone,-(sp)				; save the current zone
-			move.l	SysZone,TheZone				; make the system heap current
-			subq	#4,sp						; reserve space for function result
-			move.l	#'sfnt',-(sp)				; push resource type
-			move.w	resourceID(a6),-(sp)		; push the resource id
-			_GetResource						; grab the resource handle			
-			move.l	(sp)+,resourceHandle(a6)	; pop the spline handle
-			move.l	(sp)+,TheZone				; restore the saved heap zone
 						
 @Exit
 			_SetResLoad							; <15> Old ResLoad is still on the stack.  Restore it before we leave.
@@ -4765,7 +4737,7 @@ BWRealFont
 			move.l	(sp)+,d0
 			move.l	(sp)+,a1				; Restore A1
 			move.l	d0,-(sp)				; <60> Save the candidate list
-			beq.s	@oldKindOfFont
+			beq		@oldKindOfFont
 			
 ; GetCandidateFONDs returns a list of available sizes for this font family.  Scan this
 ; list for the requested size.
@@ -4785,7 +4757,7 @@ BWRealFont
 @nextCandidate
 			add.w	#kFONDListSize,A0		; skip to next entry
 			DBRA	D0,@nrfLoop				; check em all out
-			BRA.S	@notReal 				; it must not be real...
+			BRA		@notReal 				; it must not be real...
 
 ; <50> We’ve got an entry for a TrueType font.  Instead of automatically
 ; returning true, call fs_LowestPPEM to see if the TrueType font will be
diff --git a/Toolbox/FontMgr/MacExtra.c b/Toolbox/FontMgr/MacExtra.c
--- a/Toolbox/FontMgr/MacExtra.c
+++ b/Toolbox/FontMgr/MacExtra.c
@@ -137,6 +137,7 @@ extern pascal EncodingTablePointer		GetEncodingTable( short fondID, uint16 *scri
 #define FIXONEHALF		0x00008000
 #define HIGHWORDMASK	0xFFFF0000
 
+#undef FIXROUND
 #define FIXROUND(n)		FixRound(n)
 #define ROUND(n)		(((n) + FIXONEHALF) & HIGHWORDMASK)
 
diff --git a/Toolbox/FontMgr/fnt.c b/Toolbox/FontMgr/fnt.c
--- a/Toolbox/FontMgr/fnt.c
+++ b/Toolbox/FontMgr/fnt.c
@@ -494,6 +494,9 @@ void CHECK_CONTOUR(fnt_LocalGraphicStateType* gs, fnt_ElementType* elem, int ctr
 #define ADJUSTBASE 0x8F							/* <15> base opcode for adjust instruction */
 #define PIXEL 64
 #define LG2PIXEL 6
+#undef HALF
+#undef HALFM
+#undef HALFP
 #define HALF (PIXEL >> 1)
 #define HALFM (HALF-1)
 #define HALFP (HALF+1)
diff --git a/Toolbox/GetMgr/GetMgr.a b/Toolbox/GetMgr/GetMgr.a
--- a/Toolbox/GetMgr/GetMgr.a
+++ b/Toolbox/GetMgr/GetMgr.a
@@ -181,13 +181,14 @@ VisState		EQU		-1					; flag for resource's vis state			<C314/31Oct86> DAF
 Align			EQU		-2					; another byte to re-align stack frame	<C666/22Jan87> DAF
 IsACPort		EQU		-4					; flag for color port
 	
-GetNewCWindow	LINK	A6,#IsACPort		; build stack frame					<C106 EHB>
-				MOVE	#-1,IsACPort(A6)	; flag the color port				<C106 EHB>
+GetNewCWindow	MOVEQ.L	#-1,D0				; color port
 				BRA.S	GNWShare			; =>dive into common code			<C106 EHB>
 					
-GetNewWindow	LINK	A6,#IsACPort		; build stack frame
-				CLR		IsACPort(A6)		; flag black and white port			<C106 EHB>
-GNWShare		MOVE.L	A3,-(SP)			; preserve a work register
+GetNewWindow	MOVEQ.L	#0,D0				; black and white port
+
+GNWShare		LINK	A6,#IsACPort		; build stack frame
+				MOVE	D0,IsACPort(A6)		; flag port
+				MOVE.L	A3,-(SP)			; preserve a work register
 				CLR.L	result(A6)			; set result to NIL
 	
 				SUBQ	#4,SP				; make space for result
@@ -496,18 +497,18 @@ LoadMDEF
 			   MOVE.W	 #MapTRUE,ROMMapInsert	 ; get the MDEF from the ROM map	<EHB 10 Jul 85>
 			   _GetResource 				 ; get it!
 
-			   MOVE.L	 (A3),A0			 ; get pointer to menu
-			   MOVE.L	 (SP)+,MenuDefHandle(A0) ; install the defProc handle (which may be NIL)
-
-			   MOVE.L	 A3,-(SP)			 ; push the menu handle
-			   _CalcMenuSize				 ; calculate the size of the menu
-
 ;
 ; Now try to load a menu color table with the same ID as the menu's					<FJL C408/C417>
 ;
 				move.b	#1, -(sp)			; force Resource Load to true
 				_SetResLoad			
 				
+			   MOVE.L	 (A3),A0			 ; get pointer to menu
+			   MOVE.L	 (SP)+,MenuDefHandle(A0) ; install the defProc handle (which may be NIL)
+
+			   MOVE.L	 A3,-(SP)			 ; push the menu handle
+			   _CalcMenuSize				 ; calculate the size of the menu
+
 				subq	#4, sp				; make room for the result
 				move.l	#'mctb', -(sp)		; push resource type
 				move.w	8(a6), -(sp)		; push menuID
@@ -584,6 +585,7 @@ GetNewMBar
 
 ; loop, getting and inserting one menu at a time
 
+			   BRA.S	skipAllThis
 GetMBLoop
 			   SUBQ 	 #4,SP				 ;make room for result
 			   MOVE.L	 (A3),A0			 ;get pointer to mBarDef
@@ -595,8 +597,9 @@ GetMBLoop
 			   CLR.W	 -(SP)				 ;insert at end of menuBar
 			   _InsertMenu
 
-			   MOVE.L	 (A3),A0			 ;get ptr to mBarDef
 			   ADDQ 	 #1,D3				 ;bump to next menu
+skipAllThis
+			   MOVE.L	 (A3),A0			 ;get ptr to mBarDef
 			   CMP		 (A0),D3			 ;done yet
 			   BLT.S	 GetMBLoop			 ;loop until done
 
diff --git a/Toolbox/Munger/Munger.a b/Toolbox/Munger/Munger.a
--- a/Toolbox/Munger/Munger.a
+++ b/Toolbox/Munger/Munger.a
@@ -267,7 +267,7 @@ bm												; local, faster block move		<4May85>
 			SUBQ.L		#1,D0					; only move <=1 byte?			<4May85>
 			BLE.S		@0						; small move?					<4May85>
 			ADDQ.L		#1,D0					; fix up subtract above 		<4May85>
-			_BlockMove							; move 'em on out               <4May85
+			_BlockMoveData						; move 'em on out               <4May85
 			RTS 								; adios 						<4May85>
 @0												;								<4May85>
 			BLT.S		zeroErr 				; nothing to move				<4May85>
@@ -483,7 +483,7 @@ clone2Common
 			ADD.L		D2,A0					; add in offset (=0 most times)
 			EXG 		A0,A1					; switch source/dest
 			MOVE.L		D1,D0					; restore length
-			_BlockMove							; counts on D0 being returned 0
+			_BlockMoveData						; counts on D0 being returned 0
 
 			MOVE.L		(SP)+,A0				; get handle for return
 noRoom
diff --git a/Toolbox/NotificationMgr/NotificationMgr.a b/Toolbox/NotificationMgr/NotificationMgr.a
--- a/Toolbox/NotificationMgr/NotificationMgr.a
+++ b/Toolbox/NotificationMgr/NotificationMgr.a
@@ -28,6 +28,7 @@
 			LOAD		'StandardEqu.d'		;										<v1.2>
 			INCLUDE		'HardwarePrivateEqu.a'
 			INCLUDE		'UniversalEqu.a'
+			INCLUDE		'PowerPrivEqu.a'
 			CASE	OBJ
 			STRING	ASIS
 
@@ -36,16 +37,6 @@ __NMINSTALL	PROC	EXPORT
 			MOVE.L	A0, -(SP)			; Put A0 on stack
 			IMPORT	_NMInstall
 
-	if forROM then						; <5>
-
-			TestFor	SupportsIdle
-			BEQ.S	@notsupported
-
-			_IdleUpdate					; this is activity, stay at full speed
-@notsupported
-
-	endif								; forROM
-
 			BSR		_NMInstall			; Call the C routine
 			ADDQ.L	#4, SP				; Clean up stack
 			RTS
@@ -60,7 +51,9 @@ __NMREMOVE	PROC	EXPORT
 			TestFor	SupportsIdle
 			BEQ.S	@notsupported
 
-			_IdleUpdate					; this is activity, stay at full speed
+			MOVE.L	D0,-(SP)
+			_IdleUpdateDispatch			; this is activity, stay at full speed
+			MOVE.L	(SP)+,D0
 @notsupported
 
 	endif								; forROM
diff --git a/Toolbox/NotificationMgr/NotificationMgr.c b/Toolbox/NotificationMgr/NotificationMgr.c
--- a/Toolbox/NotificationMgr/NotificationMgr.c
+++ b/Toolbox/NotificationMgr/NotificationMgr.c
@@ -137,14 +137,13 @@ typedef struct {
 
 #define	BufPtr			(*(Ptr *) 0x10C)
 #define	UnitTable		(*(DCtlHandle **) 0x11C)
-#define	Ticks			(*(long *) 0x16A)
+#define	Ticks			(TickCount())
 #define	AlarmState		(*(char *) 0x21F)
 #define	ROM85			(*(unsigned short *) 0x28E)
-#define	SysZone			(*(THz *) 0x2A6)
-#define	ApplZone		(*(THz *) 0x2AA)
+#define	SysZone			(SystemZone())
+#define	ApplZone		(ApplicZone())
 #define WMgrPort		(*(GrafPtr *) 0x9DE)
 #define MenuList		(*(MenuLHdl *) 0xA1C)
-#define	ROMMapInsert	(*(short *) 0xB9E)
 #define	MBarHeight		(*(short *) 0xBAA)
 #define WMgrCPort		(*(GrafPtr *) 0xD2C)
 
@@ -202,10 +201,12 @@ typedef struct NMHdr {
 	Handle		copyIcon;
 	long		lastMoveTime;
 	Boolean		useNewIcon;
+	Boolean		shouldClearMarks;
 	/* the following fields were added after the Portable and IIci ROMs */
 	IconRecPtr	curPMIconRec;
 	QHdr		pmIcons;
 	Boolean		appleMenu;
+	Boolean		shouldRedrawMbar;
 } NMHdr, *NMHdrPtr;
 
 #define	NMQHdr	(*(NMHdrPtr *) 0xB60)
@@ -225,25 +226,26 @@ typedef struct NMHdr {
 
 /* The MPW GetDCtlEntry has a bug.  This is my substitute.  It returns a handle
  * to the DCE of the driver having the given refnum.
+ * CDG5 addendum: this now actually incorrect (treats UnitTable as byte array),
+ *                but (?)8.6+ put desk acc's in the app menu so no worries
  */
-#define	MyGetDCtlEntry(refNum)	UnitTable[~refNum]
+#define	MyGetDCtlEntry(refNum)	((char *)UnitTable)[~refNum]
 
 /* Returns true iff theAddr is in the range specified by low & high.  Uses StripAddress. */
 Boolean
 AddrInRange(Ptr theAddr, Ptr low, Ptr high)
 {
-	theAddr = StripAddress(theAddr);
-	return (StripAddress(low) <= theAddr) && (theAddr <= StripAddress(high));
+	return (low <= theAddr) && (theAddr <= high);
 }
 #define	InSysZone(theAddr)	AddrInRange(theAddr, (Ptr) SysZone, SysZone->bkLim)
-#define	InApplZone(theAddr)	AddrInRange(theAddr, (Ptr) ApplZone, BufPtr)
+#define	InApplZone(theAddr)	AddrInRange(theAddr, (Ptr) ApplZone, (Ptr) ApplZone < BufPtr ? ApplZone->bkLim : BufPtr)
 
 
 /* Gets a process ID, or returns -1 if none is available (MultiFinder not active) */
 short
 GetPID(void)
 {
-	if (NGetTrapAddress(0x8F, ToolTrap) != NGetTrapAddress(0x9F, ToolTrap)) {
+	if (GetToolTrapAddress(0xA88F) != GetToolTrapAddress(0xA89F)) {
 		/* MultiFinder active */
 		return TWGetPID();
 	}
@@ -303,7 +305,7 @@ short InApplicationMenu(short thePID, short theMarkID)
 			ResType			dType;
 			Str255			dName;
 
-			ROMMapInsert = MapTRUE;
+			TempInsertROMMap(true);
 			GetResInfo(GetResource('DRVR', ~theMarkID), &dID, &dType, dName);
 			theItem = FindItem(theApplicationMenu, dName);
 		}
@@ -448,7 +450,7 @@ OSErr
 _NMInstall(NMRecPtr theNMRec)
 {
 	if (theNMRec->qType != nmType) return nmTypErr;
-	if (NGetTrapAddress(0xA085,OSTrap) != NGetTrapAddress(0xA89F,ToolTrap)) 
+	if (GetOSTrapAddress(0xA085) != GetToolTrapAddress(0xA89F)) 
 		IdleUpdate();
 	theNMRec->nmFlags = 0;
 	theNMRec->nmPrivate = 0;
@@ -473,18 +475,17 @@ _NMRemove(NMRecPtr theNMRec)
 		/* See if we have a dialog up */
 		if ((theNMRec->nmFlags & (fDlogDisp | fDlogCompl)) == fDlogDisp) NMQHdr->requests.qFlags |= fDlogInval;
 		UnLinkAuxRecs(theNMRec);
+		if (theNMRec->nmFlags & fIconinRot) {
+			NMQHdr->shouldClearMarks = true;
+			if (theNMRec->nmIcon != 0) {
+				NMQHdr->shouldRedrawMbar = true;
+			}
+		}
 	}
 
 	return rValue;
 }
 
-/* Copies Pascal style strings. */
-pascal void
-CopyString(StringPtr srcString, StringPtr dstString)
-{
-	BlockMove(srcString, dstString, *srcString + 1);
-}
-
 /* Called by InitApplZone via the IAZNotify vector.  Removes all requests that
  * are in the application zone.
  */
@@ -510,36 +511,21 @@ FLUSHAPPLNM(void)
 }
 
 /* This dialog filter proc is almost identical to the default, except that it will
- * also return if aborted by NMRemove.
+ * also return if aborted by NMRemove. Now calls default rather than including it.
  */
 pascal Boolean
 NMFilter(DialogPtr theDialog, EventRecord *theEvent, short *itemHit)
 {
-	if (theEvent->what == keyDown) {
-		register unsigned char	theChar = theEvent->message & 0xFF;
-
-		if ((theChar == 3)  || (theChar == 0xD)) {
-			/* It's a return or enter. */
-			short	itemType;
-			ControlHandle	item;
-			Rect	junk;
-
-			GetDItem(theDialog, buttonItem, &itemType, (Handle*)&item, &junk);
-			if (itemType == (ctrlItem+btnCtrl)) {
-				/* It's an enabled button - highlight it */
-				HiliteControl(item, inButton);
-				Delay(8, (long*)&junk);
-				HiliteControl(item, 0);
-			}
-			*itemHit = buttonItem;
-			return true;
-		}
+	register Boolean	rValue = false;
+	ModalFilterProcPtr filter;
+	if (!GetStdFilterProc(&filter)) {
+		rValue = filter(theDialog, theEvent, itemHit);
 	}
 	if (NMQHdr->requests.qFlags & fDlogInval) {
 		/* The request was removed - punt the dialog */
-		return true;
+		rValue = true;
 	}
-	return false;
+	return rValue;
 }
 
 /* This is the user item procedure which displays the default button roundRect. */
@@ -576,7 +562,7 @@ NMCallMBarProc(short message, short param1, long param2)
 	}
 	else return 0;
 
-	ROMMapInsert = MapTRUE;
+	TempInsertROMMap(true);
 	if (MBDFHndl = (MBarProcHandle) GetResource('MBDF', mbResID)) {
 		register short	flags = HGetState((Handle)MBDFHndl);
 		register long	result;
@@ -714,7 +700,7 @@ DoDialog(NMRecPtr theNMRec, int procLevel)
 		theNMRec->nmFlags |= fDlogDisp | fReqLocked;
 
 		/* Copy the string */
-		CopyString(theNMRec->nmStr, alertStr);
+		BlockMoveData(theNMRec->nmStr, alertStr, *(theNMRec->nmStr) + 1);
 
 		spl(procLevel);
 
@@ -727,8 +713,7 @@ DoDialog(NMRecPtr theNMRec, int procLevel)
 		theDialog = GetNewDialog(NMDialog, nil, (WindowPtr) -1);
 		UseResFile(saveResFile);
 
-		GetDItem(theDialog, defButItem, &itemType, &item, &box);
-		SetDItem(theDialog, defButItem, itemType, (Handle) DefButProc, &box);	/* 1.5 type coersion */
+		SetDialogDefaultItem(theDialog, 1);
 
 		GetDItem(theDialog, textItem, &itemType, &item, &box);
 		SetIText(item, alertStr);
@@ -794,7 +779,7 @@ NMGNEFilter(void)
 			/* It's not, turn it on */
 			register Handle	theSIcon;
 
-			ROMMapInsert = MapTRUE;
+			TempInsertROMMap(true);
 			if (theSIcon = GetResource('SICN', AlarmSICN)) {
 				/* Build theAlarmRec and copy the alarm icon into the sys heap */
 				register Size	iconSize = GetHandleSize(theSIcon);
@@ -826,25 +811,15 @@ NMGNEFilter(void)
 pascal void
 NMTask(void)
 {
-	register int	procLevel;
-	short	selector[4];
-	
-	/* NOTE: If this code seems buggy, take this 'if' statement and move it below after the call to AddIconRec() */
-	if (NMQHdr->requests.qHead == nil)
-		return;
+	register NMHdrPtr	theNMHdr = NMQHdr;
+	register NMRecPtr	theNMRec = theNMHdr->requests.qHead;
 
-	selector[0] = MoveSICNToPM;
-	selector[1] = MoveICSToPM;
-	selector[2] = MoveSICNToAM;
-	selector[3] = MoveICSToAM;
-	
-	procLevel = disable();
+	if (theNMRec != nil) {
+		register int procLevel = disable();
  
-	{
 		/* Find the first queue element that needs attention.
 		 * Note that the response proc is the last thing done.
 		 */
-		register NMRecPtr	theNMRec = NMQHdr->requests.qHead;
 		while ((theNMRec != nil) && (theNMRec->nmFlags & fReqLocked)) theNMRec = (NMRecPtr) theNMRec->qLink;	/* 1.5 type coersion */
 
 		/* Determine the next thing to be done and call the procedure to do it */
@@ -858,74 +833,96 @@ NMTask(void)
 			else if (!(nmFlags & fRespCompl)) DoRespProc(theNMRec, procLevel);
 			else theNMRec->nmFlags |= fReqLocked | fReqDone;
 		}
+
+		spl(procLevel);
 	}
 
-	spl(procLevel);
-
-	AddMarkRec();
-	AddIconRec();
+	AddAuxRec(sizeof(MarkRec), &theNMHdr->marks);			/* AddMarkRec */
+	AddAuxRec(sizeof(IconRec), &theNMHdr->amIcons);			/* AddIconRec -- apple menu */
+	AddAuxRec(sizeof(IconRec), &theNMHdr->pmIcons);			/* AddIconRec -- process menu*/
 
 	/* Now go through the marks queue, deleting entries and updating menu marks
 	 * as needed.
 	 */
 	{
-		register MenuHandle	theApplicationMenu = GetApplicationMenu();
-		register MarkRecPtr	theMarkRec = NMQHdr->marks.qHead;
+		register MenuHandle	theApplicationMenu = nil;
+		register MarkRecPtr	theMarkRec;
 
-		if (theApplicationMenu && (NMQHdr->lastMenuUsed != theApplicationMenu)) ClearMarks(theApplicationMenu);
+		if (theNMHdr->shouldClearMarks) {
+			theApplicationMenu = GetApplicationMenu();
 
-		while (theMarkRec != nil) {
-			register MarkRecPtr	nextMarkRec = theMarkRec->hdr.qLink;
+			if (theApplicationMenu && (theNMHdr->lastMenuUsed != theApplicationMenu)) ClearMarks(theApplicationMenu);
 
-			if (theMarkRec->hdr.qType) {
-				if (!theMarkRec->hdr.aRefCount) {
-					/* Remove the mark and delete this record */
-					UnMarkApp(theMarkRec);
-					Dequeue((QElemPtr)theMarkRec, &NMQHdr->marks);
-					DisposPtr((Ptr)theMarkRec);
+			if (theNMHdr->shouldRedrawMbar) {
+				NMCallMBarProc(0, 0, 0);					/* Draw selector, last arg means "all": see StandardMBDF.a */
+				theNMHdr->shouldRedrawMbar = 0;
+			}
+
+			theNMHdr->shouldClearMarks = 0;
+		}
+
+		theMarkRec = (MarkRecPtr)theNMHdr->marks.qHead;
+		if (theMarkRec != nil) {
+			while (theMarkRec != nil) {
+				register MarkRecPtr	nextMarkRec = theMarkRec->hdr.qLink;
+
+				if (theMarkRec->hdr.qType) {
+					if (!theMarkRec->hdr.aRefCount) {
+						/* Remove the mark and delete this record */
+						UnMarkApp(theMarkRec);
+						Dequeue((QElemPtr)theMarkRec, &theNMHdr->marks);
+						DisposPtr((Ptr)theMarkRec);
+					}
+					else if ((theApplicationMenu = GetApplicationMenu()) && theNMHdr->lastMenuUsed != theApplicationMenu) MarkApp(theMarkRec);
 				}
-				else if (theApplicationMenu && NMQHdr->lastMenuUsed != theApplicationMenu) MarkApp(theMarkRec);
+				theMarkRec = nextMarkRec;
 			}
-			theMarkRec = nextMarkRec;
 		}
-		NMQHdr->lastMenuUsed = theApplicationMenu;
+		theNMHdr->lastMenuUsed = theApplicationMenu;
 	}
 
-	{
+	if (theNMHdr->requests.qHead != nil) {
 		/* Get the icon to be displayed for the menu bar defproc */
-		register long	curTime = Ticks, timeSince = curTime - NMQHdr->lastMoveTime;
+		register long	curTime = Ticks, timeSince = curTime - theNMHdr->lastMoveTime;
 		register IconRecPtr	*curIconRec;
 
-		curIconRec = (NMQHdr->appleMenu ? &NMQHdr->curAMIconRec : &NMQHdr->curPMIconRec);
+		curIconRec = (theNMHdr->appleMenu ? &theNMHdr->curAMIconRec : &theNMHdr->curPMIconRec);
 
 		if (timeSince >= MoveSThresh) {
 			register IconRecPtr	theIconRec = *curIconRec;
+	 		register long selector;
 
-			if (NMQHdr->useNewIcon) {
+			if (theNMHdr->useNewIcon) {
 				/* Get the next icon from the queue.  If not enough time has elapsed,
 				 * or the new icon is the same as the old, get out.
 				 */
-				if (timeSince >= WaitSThresh(NMQHdr->amIcons, NMQHdr->pmIcons)) {
-					register IconRecPtr	newIconRec = ValidIconRec(theIconRec,  (NMQHdr->appleMenu ? &NMQHdr->amIcons : &NMQHdr->pmIcons));
+				if (timeSince >= WaitSThresh(theNMHdr->amIcons, theNMHdr->pmIcons)) {
+					register IconRecPtr	newIconRec = ValidIconRec(theIconRec,  (theNMHdr->appleMenu ? &theNMHdr->amIcons : &theNMHdr->pmIcons));
 
 					if (newIconRec == theIconRec) {
-						NMQHdr->appleMenu = !(NMQHdr->appleMenu);
+						theNMHdr->appleMenu = !(theNMHdr->appleMenu);
 						return;
 					}
 					else {
 						*curIconRec = theIconRec = newIconRec;
 						if (theIconRec)
-							BlockMove(*(theIconRec->iSIcon), *(NMQHdr->copyIcon), (theIconRec->iconSuite ? sizeof(IconSuite) : SICNsize));
+							BlockMoveData(*(theIconRec->iSIcon), *(theNMHdr->copyIcon), (theIconRec->iconSuite ? sizeof(IconSuite) : SICNsize));
 					}
 				}
 				else return;
 			}
 
-			NMQHdr->lastMoveTime = curTime;
-			NMQHdr->useNewIcon = NMCallMBarProc(selector[(NMQHdr->appleMenu << 1) + (theIconRec ? theIconRec->iconSuite : 0)],
+			selector = (theNMHdr->appleMenu << 1) + (theIconRec ? theIconRec->iconSuite : 0);
+			if (selector == 0) selector = MoveSICNToPM;
+			else if (selector == 1) selector = MoveICSToPM;
+			else if (selector == 2) selector = MoveSICNToAM;
+			else selector = MoveICSToAM;
+
+			theNMHdr->lastMoveTime = curTime;
+			theNMHdr->useNewIcon = NMCallMBarProc(selector,
 													MoveSDist,
-													(long) (theIconRec ? NMQHdr->copyIcon: nil));
-			NMQHdr->appleMenu = !(NMQHdr->appleMenu);
+													(long) (theIconRec ? theNMHdr->copyIcon: nil));
+			theNMHdr->appleMenu = !(theNMHdr->appleMenu);
 		}
 	}
 }
diff --git a/Toolbox/Printing/PrintGlue.a b/Toolbox/Printing/PrintGlue.a
--- a/Toolbox/Printing/PrintGlue.a
+++ b/Toolbox/Printing/PrintGlue.a
@@ -362,7 +362,12 @@ GotPDEF
 		_GetHandleSize					; How big is our PDEF Handle					<LW2> fau
 		cmp.l		#32,D0				; Is it "small"									<LW2> fau
 		bhi.s		@RealPDEF			; no, don't flush the cache						<LW2> fau
-		jsr			([jCacheFlush])		; else, flush the caches.						<LW2> fau
+		move.l		A0,-(SP)
+		move.l		(A0),A0
+		move.l		D0,A1
+		import		FLUSHCRANGE
+		bsr.l		FLUSHCRANGE			; else, flush the caches.
+		move.l		(SP)+,A0
 @RealPDEF										;										<LW2> fau
 		_HLock
 ;<22Feb87> JNP Restore curMap before jumping into the print code.
@@ -375,7 +380,7 @@ GotPDEF
 		Add.b	ParmByt(a6),d0
 		Sub.w	d0,sp					; We know the thing isn't actually more than a word wide
 		Move.l	sp,a1					; Beginning of destination
-		_BlockMove						; Note: Leaves d0 = 0
+		_BlockMoveData					; Note: Leaves d0 = 0
 ; Call the routine.  The offset into the PDEF to jump to is given by the glue parameter
 		Move.b	CodeOfs(a6),d0			; Get offset (note high part of d0 is still 0)
 		Andi.b	#$7F,d0					; Mask off the unlock bit that is stored there
@@ -544,6 +549,14 @@ LLOut
 		Add.w	#IOQElSize,sp			; Strip parameter block
 		Move.w	d0,PrintVars+iPrErr		; Set return code
 GlueOut
+		Move.l	sp,-(sp)				; Let the Blue Box know right after
+		Moveq.l	#0,d0					; every print call is made (CDG5)
+		Move.b	FuncByt(a6),d0
+		Lsr.b	#3,d0
+		Move.l	d0,-(sp)
+		Import	BlueBoxPrintHook
+		Bsr		BlueBoxPrintHook
+		Addq	#8,sp
 ;
 ; Get the number of bytes of parameter to this entry in d1
 		Moveq	#0,d1
@@ -670,7 +683,7 @@ kAliasID		EQU		-8192							; System Printer alias's resID
 				MOVE.B	(A0), D0			; which is this long
 				ADDQ.B	#1, D0				; plus that length byte!
 				LEA		sysFileSpec + FSSpec.name(A6), A1	; to the FSSpec
-				_BlockMove
+				_BlockMoveData
 				
 		; ResolveDriver: Resolve the alias using the system file's FSSpec.
 
diff --git a/Toolbox/ResourceMgr/ResourceMgr.a b/Toolbox/ResourceMgr/ResourceMgr.a
--- a/Toolbox/ResourceMgr/ResourceMgr.a
+++ b/Toolbox/ResourceMgr/ResourceMgr.a
@@ -1011,9 +1011,6 @@ RMGRVersion 	DC.W	1				; Resource Manager version number
 InitRSRCMgr	ST		SysMap				; flag that resources are not inited
 			CLR.L	TopMapHndl			; tell the res mgr that it's start time
 
-			Move.B	MMFlags,-(SP)		; save the memory Manager flag
-			BSET.B	#MMStartMode,MMFlags; set for 32 bit system heap
-
 			move.l	ExpandMem,a0							; init override flags 		<SM48> kc
 			clr.b	ExpandMemRec.emScanOverrideMaps(a0)		; turn off ScanOverrideMaps	<SM48> kc
 			clr.w	ExpandMemRec.emLastMapOverridden(a0)	; flush override cache.		<SM48> kc
@@ -1023,7 +1020,6 @@ InitRSRCMgr	ST		SysMap				; flag that resources are not inited
 			_InitResources				; Init ROM resource file
 			ADDQ	#2, SP				; Assume success
 
-			MOVE.B	(SP)+,MMFlags		; restore memory manager flag
 			RTS
 
 
@@ -1126,13 +1122,41 @@ ROVR			EQU 	$524F7672		; ROVR = 'ROvr' (type of override rsrc)
 
 RomOverRide 							; new routine									<27aug85> BBM
 		SUBQ	#4,SP					; Save room on stack for handle
-		MOVE.L	#ROVR,-(SP) 			; rsrc type for override
+		PEA		ROVR					; rsrc type for override
 		MOVE.W	#0,-(SP)				; rsrc ID of 0
+		MOVE	#-1,RomMapInsert
 		_GetResource					; get the override rsrc
+		SUBQ	#4,SP					; Save room on stack for handle
+		PEA		ROVR 					; rsrc type for override
+		MOVE.W	#0,-(SP)				; rsrc ID of 0
+		_GetResource					; get the override rsrc
+		MOVEQ.L	#0,D1
 		MOVE.L	(SP)+,D0				; Check to see if it exists
-		BEQ.S	ROvrOut					; if handle is zero then just return
+		BEQ.S	@Lx
 		MOVE.L	D0,A0					; get ready to execute this resource
 		MOVE.L	(A0),A0 				; dereference handle
+
+		Move	$8(A0), D1
+@Lx		MoveA.L	(SP)+, A1
+		Move.L	A1, D2
+		BEQ.S	@L0
+		MoveA.L	(A1), A0
+		Move	$8(A0), D2
+@L0		Cmp		D2, D1
+		BHI.S	@L2
+		Tst.L	D0
+		BEQ.S	@L1
+		Cmp.L	A1, D0
+		BEQ.S	@L1
+		Move.L	A1, -(SP)
+		Move.L	D0, -(SP)
+		_ReleaseResource
+		MoveA.L	(SP)+, A1
+@L1		Move.L	A1, D0
+		BEQ.S	ROvrOut
+@L2		MoveA.L	D0, A0
+		MoveA.L	(A0), A0
+
 FPCallROvr								; FlashPort hint attachment point <bt>
 		JSR 	(A0)					; and execute handle
 ROvrOut	RTS 							; and return
@@ -1280,7 +1304,7 @@ ReDoMap 								; new routine
 		moveq	#$20,d0					; size of null map
 		lea		NullRF,a0				; get null map from rom
 		move.l	(A4),A1 				; Dereference handle to destination
-		_BlockMove						; move map down
+		_BlockMoveData					; move map down
 		move.w	#1,MRefNum(a1)			; and stuff the rom map refnum (so getcurmap works)
 
 		clr.w	-(sp)					; get a buffer on the stack to read in index
@@ -1783,7 +1807,7 @@ vNewMap 								; Def to build dispatch entry					<27oct85> BBM
 		ADDA.L	#HdrSize,A0 			; ... finish calc for source
 		LEA 	HSCache,A1				; Destination for blockmove
 		MOVE.L	#PreSize,D0 			; size for blockmove							<11jul85> BBM
-		_BlockMove						; move the key data to the stack
+		_BlockMoveData					; move the key data to the stack
 		MOVEA.L A0,A1					; restore A1
 		SUBA.L	#HdrSize,A1 			; ... finish restoring A1
 		BSR 	PreFormat				; check the preload format of this file			<SM25> CSS 	
@@ -1824,7 +1848,7 @@ vNewMap 								; Def to build dispatch entry					<27oct85> BBM
 		; a new map is first created and only set after the appropriate Resource overrides
 		; calls have been made.
 	
-		andi.b	#kAllButOverrideAttributesMask,mInMemoryAttr(a1)	
+		andi.b	#kDecompressionPasswordMask,mInMemoryAttr(a1)	
 
 		; Successful load.	Return with D6=refnum of file and D0=1 for "newmap" flag
 
@@ -4572,7 +4596,7 @@ vCheckLoad										; Def to build dispatch entry
 				tst.b	(sp)+
 				bne.s	@system_rsrc					; if so, branch
 				move.l	(a4),a0							; a0 <- ptr to map
-				btst.b	#mapForceSysHeap,MAttr(a0)		; should all entries in map go in system heap?
+				btst.b	#overrideNextMapBit,MAttr(a0)	; should all entries in map go in system heap?
 				beq.s	@GoOnCheckLoad					; if not, branch
 @system_rsrc
 				bset	#ResSysHeap,RAttr(a2)			; get into the system heap (and stay there!)
@@ -5806,7 +5830,7 @@ LoadResource
 		MOVE.L	D0,A0					; handle in A0
 		MOVE.L	ROMBASE,A1
 		CMP.L	(A0),A1					; resource in ROM
-		BPL.S	@2						; Nope
+		BHI.S	@2						; Nope
 		CLR.W	ResErr					; since we found a ROM resource, and we assume it is ok. <SM43> CSS
 		BRA.S 	 @9						; yes, done
 @2
@@ -6324,7 +6348,7 @@ CopyStr
 		MOVEQ	#0, D0					; Zero high order bits.
 		MOVE.B	(A0), D0				; Get length of string
 		ADDQ.W	#1, D0					; include length byte.							<14jun85> BBM
-		_BlockMove						; Copy the string to A1
+		_BlockMoveData					; Copy the string to A1
 		RTS 							; and return.
 
 ;_______________________________________________________________________________
diff --git a/Toolbox/ResourceMgr/ResourceMgrExtensions.a b/Toolbox/ResourceMgr/ResourceMgrExtensions.a
--- a/Toolbox/ResourceMgr/ResourceMgrExtensions.a
+++ b/Toolbox/ResourceMgr/ResourceMgrExtensions.a
@@ -922,7 +922,7 @@ ValidateFontResourceIDs	Proc	Export
 				beq.s	@checkForNFNTs					; <mc3> 
 				cmpi.l	#'NFNT',d3						; <mc3> If it is a NFNT, also check for FONT conflicts
 				beq.s	@checkForFONTs					; <mc3> 
-				bra.s	@nextTableEntry					; <mc3> If it is a sfnt or other, go on to the next one.
+				bra		@nextTableEntry					; <mc3> If it is a sfnt or other, go on to the next one.
 
 @checkForFONTs
 				subq	#4,sp							; <mc3>
@@ -930,7 +930,7 @@ ValidateFontResourceIDs	Proc	Export
 				move.w	4(a3),-(sp)						; <mc3> Look for this ID.
 				_GetResource							; <mc3> Does it exist?
 				move.l	(sp)+,d0						; <mc3>
-				bz.s	@nextTableEntry					; <mc3> This number is fine
+				bz		@nextTableEntry					; <mc3> This number is fine
 				bra.s	@conflictOccured
 
 @checkForNFNTs
@@ -939,7 +939,7 @@ ValidateFontResourceIDs	Proc	Export
 				move.w	4(a3),-(sp)						; <mc3> Look for this ID.
 				_GetResource							; <mc3> Does it exist?
 				move.l	(sp)+,d0						; <mc3>
-				bz.s	@nextTableEntry					; <mc3> This number is fine
+				bz		@nextTableEntry					; <mc3> This number is fine
 
 @conflictOccured
 				move.l	d0,a0							; <46>
@@ -965,6 +965,27 @@ ValidateFontResourceIDs	Proc	Export
 ; Make sure this ID is not used in the resource map.
 ;
 
+				cmpi.l	#'FONT',D3
+				beq.s	@isFONT
+				cmpi.l	#'NFNT',D3
+				beq.s	@isNFNT
+				bra.s	@isNeither
+
+@isNFNT			subq	#4,SP
+				move.l	#'FONT',-(SP)
+				move	D2,-(SP)
+				_GetResource
+				move.l	(SP)+,D0
+				beq.s	@isNeither
+				bra.s	@getUniqueID
+@isFONT			subq	#4,SP
+				move.l	#'NFNT',-(SP)
+				move	D2,-(SP)
+				_GetResource
+				move.l	(SP)+,D0
+				bne.s	@getUniqueID
+@isNeither
+
 				move.l	mapToRenumber(a6),TopMapHndl	; <29> Make sure we’re reading out of the right map
 				move.w	refNum(a6),CurMap
 				subq	#4,sp
@@ -974,6 +995,28 @@ ValidateFontResourceIDs	Proc	Export
 				move.l	(sp)+,d0						; Check it out
 				bnz.s	@getUniqueID					; Try again
 
+				cmpi.l	#'FONT',D3
+				beq.s	@isFONT2
+				cmpi.l	#'NFNT',D3
+				beq.s	@isNFNT2
+				bra.s	@@isNeither
+
+@isNFNT2		subq	#4,SP
+				move.l	#'FONT',-(SP)
+				move	D2,-(SP)
+				_GetResource
+				move.l	(SP)+,D0
+				beq.s	@@isNeither
+				bra		@getUniqueID
+@isFONT2		subq	#4,SP
+				move.l	#'NFNT',-(SP)
+				move	D2,-(SP)
+				_GetResource
+				move.l	(SP)+,D0
+				beq.s	@@isNeither
+				bra		@getUniqueID
+@@isNeither
+
 ; We have a unique ID.  Put it and the original in the from-to list.
 
 				move.w	d2,-(sp)						; <57> Pass new ID
@@ -1131,26 +1174,6 @@ ReleaseTheFont	Proc	Export
 				jmp		(a0)							; Return to the caller
 				EndProc
 				
-;____________________________________________________________________________________________________
-; <53> SetDeanBitIfResourceWillBeLoaded
-;
-; This routine checks to see if the resource reference entry already contains a handle
-; or not.  If it does, DeanBit is cleared.  If there is no handle (ie, the resource will
-; be loaded this time) set DeanBit.  This allows people to determine whether they loaded
-; a resource, or if someone else did.
-;
-
-SetDeanBitIfResourceWillBeLoaded	PatchProc	jCheckLoad
-				tst.l	RHndl(a2)						; See if a master pointer has already been allocated
-				bz.s	@setDeanBit
-				bclr	#kDeanBit,kBrianBits			; A master pointer has already been allocated
-				bra.s	@goLoadTheResource
-@setDeanBit
-				bset	#kDeanBit,kBrianBits			; We’ll be loading the resource right now
-@goLoadTheResource
-				jmpOld									; Load the resource
-				EndProc
-
 ;____________________________________________________________________________________________________
 ; <48> CloseResFileUnderSystemMap(refNum: Integer);
 ;
@@ -1512,7 +1535,7 @@ IsThisASystemResourceMap	Proc	Export
 				move.l	d1,a0
 				move.l	(a0),a0
 				move.w	mRefNum(a0),d0					; Get the file reference number of this map
-				bsr		GetPSNFromParallelFCB			; <60> Get the parallel FCB info
+				bsr.l	GetPSNFromParallelFCB			; <60> Get the parallel FCB info
 				
 ; I really should use EqualProcess, but the Process Manager might not be around yet…
 
@@ -1540,6 +1563,29 @@ IsThisASystemResourceMap	Proc	Export
 ;	people are picky about how long they can play Tetris on the airplane…
 
 GetPSNFromParallelFCB	Proc	Export
+				movea.l	FSVarsPtr,A0
+				btst.b	#3,FSVars.fsFlags(A0)
+				beq.s	@dontHitFS
+
+				sub		#$32,SP
+				movea.l	SP,A0
+				cmp		#$3,D0
+				bne.s	@L0
+				moveq.l	#$2,D0
+@L0				move	D0,$18(A0)
+				moveq.l	#$50,D0
+				_HFSDispatch
+				cmp		#$0,D0
+				bne.s	@L1
+				movea.l	$1C(A0),A0
+				bra.s	@L2
+@L1				lea.l	0,A0
+
+@L2				dc.w	$defc, $0032
+				;add	#$32,SP ; can't seem to make this look right!
+				rts
+
+@dontHitFS
 				andi.l	#$FFFF, d0						; only the low word is passed.
 				divu.w	FSFCBLen,d0						; convert refnum to an index
 				movea.l	FSVarsPtr,a0					; get address of HFS variable area
@@ -1566,7 +1612,7 @@ MarkFileAsOwnedByTheSystem	Proc	Export
 				Import	GetPSNFromParallelFCB
 				
 				move.l	a0,-(sp)						; Preserve A0
-				bsr		GetPSNFromParallelFCB
+				bsr.l	GetPSNFromParallelFCB
 				clr.l	(a0)+							; Clear high word of PSN
 				move.l	#kSystemProcess,(a0)			; Set the low word
 				move.l	(sp)+,a0						; Restore A0
@@ -1950,7 +1996,7 @@ MakeOverrideMap	Proc	Export
 				
 				exg		a2,a1							; Swap reference entry and 'rovm' pointer
 				move.l	#RESize,d0
-				_BlockMove								; Copy reference data
+				_BlockMoveData							; Copy reference data
 				clr.b	RAttr(a0)						; clear the attributes for the resource (protected, etc.)
 
 ;
diff --git a/Toolbox/SANE/Str2Dec.a b/Toolbox/SANE/Str2Dec.a
--- a/Toolbox/SANE/Str2Dec.a
+++ b/Toolbox/SANE/Str2Dec.a
@@ -249,9 +249,7 @@ Start
 				MOVEM.L 		D2-D7/A2-A3,-(SP) ; save working registers
 				MOVEM.L 		D(A6),D4-D6 	; D4<--&D, D5<--&INDEX, D6<--&S
 
-				MOVE.L			D6,D0			; D0 <--&S								<v1.2>
-				_StripAddress					; sanitized address						<v1.2>
-				MOVEA.L			D0,A0			; &S for calc of first char				<v1.2>
+				MOVE.L			D6,A0			; D0 <--&S								<v1.2>
 				MOVEA.L 		D5,A1			; copy &index for indirect ref
 				MOVEQ			#0,D6			; prepare to reuse D6
 				MOVE.B			(A0),D6 		; length byte of S
diff --git a/Toolbox/ScrapMgr/ScrapMgr.a b/Toolbox/ScrapMgr/ScrapMgr.a
--- a/Toolbox/ScrapMgr/ScrapMgr.a
+++ b/Toolbox/ScrapMgr/ScrapMgr.a
@@ -383,6 +383,7 @@ ZeroScrap
 			BSR 		StdEntry				; D0 set to 0 by above
 			BNE 		err0Exit
 
+			MOVEQ.L		#0,D0					; was missing, which was a bug (CDG5)
 			MOVE.L		D0,scrapInfo			; zero out info
 			ADDQ		#8,4(A4)				; increment validation word
 			BPL.S		@0
@@ -441,7 +442,7 @@ DoGet
 			MOVE.L		D5,A2					; get scrapHandle
 			MOVE.L		(A2),A0 				; set up source for move
 			ADD.L		D3,A0					; add in offset
-			_BlockMove
+			_BlockMoveData
 			BRA 		goHome0 				; return zero
 
 ; Get the data from the file
diff --git a/Toolbox/SegmentLoader/SegmentLoader.a b/Toolbox/SegmentLoader/SegmentLoader.a
--- a/Toolbox/SegmentLoader/SegmentLoader.a
+++ b/Toolbox/SegmentLoader/SegmentLoader.a
@@ -242,9 +242,7 @@ LoadSeg
 @37											;Aren't we slick and tight?                  <02Nov85>  JTC
 			_HLock							;					<23May85><C169>
 NoMoveHHi
-			MOVE.L	(A0),D0					; handle -> dirty pointer	<C169>
-			_StripAddress					; D0 <- clean ptr			<C169>
-			MOVE.L	D0,A0					;							<C169>				
+			MOVE.L	(A0),A0					; handle -> dirty pointer	<C169>
 			
 			MOVE.L	A5,A1					 ;copy world base address
 			ADD.W 	CurJTOffset,A1			 ;offset by the current offset
@@ -530,7 +528,7 @@ LaunchCom
 			move.w	(a3)+,CurPageOption 	;											<28Oct85>
 			LEA		CurApName,A1			;get address to stuff the name
 			MOVEQ 	#32,D0					;move 32 bytes worth
-			_BlockMove						;move it in
+			_BlockMoveData					;move it in
 			
 			MOVEQ	#0,D3					;<A284> assume all flags are zero
 			CMP.W	#'LC',(A3)+				;<A284> extension code around?
@@ -570,7 +568,7 @@ SkipClose
 		  MOVE.L	SP,A1					 ;set up destination for move
 		  MOVE.L	(A0),A0 				 ;set up source for move
 		  MOVE.L	D0,-(SP)				 ;remember the size
-		  _BlockMove						 ;move it!
+		  _BlockMoveData					 ;move it!
 
 ; re-init the application heap zone, destroying the world...
 ; ...but just before, flush any vbl tasks executing out of that doomed land!		 <27Mar85>
@@ -608,7 +606,7 @@ GoInitAZone
 		  MOVE.L	D1,D0					 ;get size for blockMove
 		  MOVE.L	(A0),A1 				 ;get destination pointer
 		  MOVE.L	SP,A0					 ;get source pointer
-		  _BlockMove						 ;move it in!
+		  _BlockMoveData					 ;move it in!
 
 		  ADD.L 	D1,SP					 ;deallocate scrap save buffer
 
@@ -728,7 +726,9 @@ ExitToShell 								 ;									<30Jan85>
 ;			 _CloseResFile
 ;			 CLR.W	 CurApRefNum
 
-			_PMgrExit					; Empty out the palette manager				< 7Jul89>
+			MOVE	#$C, D0				; Empty out the palette manager				< 7Jul89>
+			_PaletteDispatch
+
 			SUB.L	A0,A0				; clear out A0								<30Jan85>
 			_SetGrowZone				; disable application's growZone handler    <30Jan85>
 
@@ -836,7 +836,7 @@ GetAppParms
 
 			   LEA		 CurApName,A0	;point to name in low memory
 			   MOVEQ	 #32,D0 		;move 32 bytes
-			   _BlockMove				;move it!
+			   _BlockMoveData			;move it!
 
 			   RTS						;return to caller (params already stripped)
 
diff --git a/Toolbox/ShutDownMgr/ShutDownMgr.a b/Toolbox/ShutDownMgr/ShutDownMgr.a
--- a/Toolbox/ShutDownMgr/ShutDownMgr.a
+++ b/Toolbox/ShutDownMgr/ShutDownMgr.a
@@ -333,6 +333,7 @@ sdBitPowerOff	EQU		0				; Call routine just before PowerOff.
 sdBitReStart	EQU		1				; Call routine just before a Reboot.
 sdBitUnMount	EQU		2				; Call routine before UnMounting Vols.
 sdBitDrivers	EQU		3				;  before Driver Goodbye Kiss.
+sdBitNew		EQU		4
 
 ; local equates
 
@@ -354,15 +355,27 @@ ShutInit		PROC	Export
 				move.l	A0,SDHeader
 
 				pea		DoDrivers				; the default routine to unload				
-				move.w	#SDOnUnMount,-(SP)		; all drivers with a goodbye
+				move.w	#$8000|SDOnUnMount,-(SP)	; all drivers with a goodbye
 				jsr		ShutInstall				; install it in the queue
 
 				pea		DoUnmount				; the default routine to unmount volumes		
-				move.w	#sdRestartOrPower,-(SP)	; do before power-off or restart
+				move.w	#$8000|$10,-(SP)		; do before power-off or restart
+				jsr		ShutInstall
+
+				pea		DoSomethingAtRestartOrPower
+				move.w	#$8000|sdRestartOrPower,-(SP)
+				jsr		ShutInstall
+
+				pea		DoUnmountAtPowerDown
+				move.w	#$8000|sdOnPowerOff,-(SP)
+				jsr		ShutInstall
+
+				pea		DoUnmountAtRestart
+				move.w	#$8000|sdOnRestart,-(SP)
 				jsr		ShutInstall
 
 				pea		ClearWarmStart
-				move.w	#sdOnPowerOff,-(SP)		; only on 'shut down'						<26>
+				move.w	#$8000|sdOnPowerOff,-(SP)		; only on 'shut down'						<26>
 				jsr		ShutInstall				; install it in the queue					<26>
 
 				Rts
@@ -392,17 +405,20 @@ ShutInit		PROC	Export
 ShutDown		move.l	(SP)+,D2			; save return
 				move.w	(SP)+,D0			; get opcode word
 				move.l	D2,-(SP)			; restore the return
-				subq	#SDPowerOff,D0
-				bcs.w	ShutInit			; if d0=0, _SDInit a selector in ROM versions
-				beq		ShutPower			; if d0=1, Shutdown
 
-				subq	#SDInstall-SDPowerOff,D0	
-				bcs		ShutRestart			; if d0=2, carry set, bra to restart
-				beq.s	ShutInstall			; if d0=3, Install
+				cmp.w	#5,D0
+				bhi.s	@unknownSelector
+
+				move.w	@tbl(d0*2),d0
+				jmp		@tbl(d0)
+
+@tbl			dc.w	ShutInit-@tbl		; 0
+				dc.w	ShutPower-@tbl		; 1
+				dc.w	ShutRestart-@tbl	; 2
+				dc.w	ShutInstall-@tbl	; 3
+				dc.w	ShutRemove-@tbl		; 4
+				dc.w	UserChoice-@tbl		; 5
 
-				subq.w	#sdUserChoice-sdInstall,d0	
-				bmi.s	ShutRemove			;if  d0=4, Remove
-				beq		UserChoice			; if d0=5, User Choice
 @unknownSelector
 				rts							; unknown selector (do nothing, assume no parameters)
 
@@ -514,57 +530,118 @@ ShutRemove
 
 						
 				export	ShutRestart	
+				import	SHUTDOWNMGRC_2CC90
 ShutRestart		
 				with	ROMHeader				
 
+				bsr		VersionCheckingFunc
+				beq.s	@old
+
+				bsr		DoRAMDiskAlert
+				bne		@return
+
+				bsr		FindEDisk
+				beq.s	@old
+
+				bsr		KillEDisk
+				bra.s	@old
+
+@return			rts
+@old
+
 				moveq	#sdOnPowerOff,d5		; Remove poweroff routines from the queue		<13>
 				bsr		RemoveOtherRoutines
 
 				moveq	#SDBitRestart,D0		; remember that we will reboot.
+				moveq	#1,D1
 				bsr		CallRoutines			; do the shutDown cleanup.
 
-				moveq	#1,D5					; Go ahead and hide cursor/close LCDs.
-				bsr		BlankDesktop			; Go blank the desktop.
-
 				move.l	ROMBase,A2					; point to the ROM
 				lea		ROMHeader.Restart(A2),A2	; point to the restart routine
 
 				move.l	#emuWarmStartConst,D0	; Does the upper long match?
 				move.l	#WmStConst,D1			; Does the upper long match?
 				bsr		UpdateEmuWarmstart		; Write the warmstart (We may have come from a shutdown...) <MC8>
-							
-				tst.l	VMGlobals				; Is VM running?
-				bmi.s	@noVM					; -> No.  Assume we're in Supervisor Mode				
-				_EnterSupervisorMode			; Enter supervisor mode (don’t worry about munging the stack...)
-@noVM
-				bsr		DockInitSCC				; reset the SCC	(if we have Power controls)				<SM16><3>
 
-				TestFor	JawsExists				; are we running on a Tim machine with JAWS				<SM16><5> HJR
-				beq.s	@noJAWS					; -> No JAWS, jump to RESTART now.						<SM16><43>
-
-				with	PmgrRec, pmCommandRec
-@JawsRestartSeq									; -- Special Case for JAWS --							<5> HJR
-				move.l	PMgrBase,a0				; get pointer to the power manager globals
-				move.l	HDVector(a0),a0			; get pointer to hard disk power down
-				jsr		(a0)					; kill the hard disk
-				lea		-pmBlkSize(sp),sp		; Create stack frame									<v5.7>
-				lea		pmData(sp),a0			; Get pointer to a xmit buffer
-				move.l	a0,pmRBuffer(sp)		; Load pointer to receive buffer
-				move.l	a0,pmSBuffer(sp)		; Load pointer to xmit buffer
-				clr.l	(a0)					; No data
-				clr.w	pmLength(sp)			; No data
-				move.w	#$21,pmCommand(sp)		; ADB autopoll disable
-				move.l	sp,a0					; a0 get pointer to paramter block
-				_PmgrOp							; go kill the machine
-				clr.l	pmData(a0)				; clear data
-				clr.w	pmLength(a0)			; clear length
-				move.w	#$d0,pmCommand(sp)		; reset CPU command
-				move.w	Timedbra,d1				; set-up our counter
-				lsl.w	#2,d1					; give ourselves 4 milliseconds
-				_PmgrOp							; go kill the machine
-
-@waitloop		dbra	d1,@waitloop			; stick around for 4 milliseconds
-												; Fall into the JMP to Restart							<43>
+E_0				Bsr		SHUTDOWNMGRC_2CC90
+				MoveQ.L	#$0, D0
+				_DebugUtil
+				CmpI.L	#$8, D0
+				BLT.B	@L0
+				MoveQ.L	#$8, D0
+				_DebugUtil
+@L0				Move.L	#'pwrv', D0
+				_Gestalt
+				BNE.B	@L1
+				Move.L	A0, D0
+				CmpI.L	#$200, D0
+				BLT.B	@L1
+				MoveQ.L	#$20, D0
+				_PowerDispatch
+@L1				BTst.B	#$0, (HWCfgFlags)
+				BEQ.B	@L3
+				BTst.B	#$3, ($240A)
+				BNE.B	@L3
+				Clr.L	-(A7)
+				Clr.L	-(A7)
+				Move.L	A7, -(A7)
+				Move.L	(A7), -(A7)
+				Clr		-(A7)
+				Move	#$D0, -(A7)
+				MoveA.L	A7, A0
+				_PMgrOp
+				Lea.L	$C(A7), A7
+@L2				Bra.B	@L2
+@L3				BTst.B	#$1, ($2400)
+				BNE.B	@L4
+				Bra.B	@L6
+@L4				Move.L	#$7000000, D0
+				And.L	(UnivROMFlags), D0
+				SubI.L	#$3000000, D0
+				BNE.B	@L6
+				Lea.L	-$14(A7), A7
+				MoveA.L	A7, A0
+				Move.B	#$1, (A0)
+				Move.B	#$11, $1(A0)
+				Clr.L	$10(A0)
+				_EgretDispatch
+				Lea.L	$14(A7), A7
+@L5				Bra.B	@L5
+@L6				BTst.B	#$3, ($2409)
+				BEQ		@L8
+				Lea.L	-$28(A7), A7
+				Move.L	A7, D0
+				AddQ	#$7, D0
+				AndI.L	#$FFFFFFF8, D0
+				Move.L	#$FFFFF000, D1
+				Move.L	D1, D2
+				And.L	D0, D2
+				MoveA.L	D0, A1
+				Lea.L	$F(A1), A1
+				Move.L	A1, D4
+				And.L	D4, D1
+				Cmp.L	D1, D2
+				BEQ.B	@L7
+				Move.L	D1, D0
+@L7				MoveA.L	D0, A0
+				Move.L	([$68FFEFD0.L],$50), (A0)		; NKHWInfo.RTAS_Restart
+				Clr.L	$4(A0)
+				Move.L	#$1, $8(A0)
+				MoveA.L	A0, A1
+				MoveQ.L	#$10, D0
+				DC.W	$FE0C
+				MoveA.L	A1, A0
+				DC.W	$FE20
+				Lea.L	$28(A7), A7
+@L8				MoveQ.L	#$E, D0
+				And.L	(UnivROMFlags), D0
+				CmpI.L	#$8, D0
+				BNE.B	@noJAWS
+				MoveA.L	([$68FFEFD0.L],$30), A0			; NKHWInfo.ADB_Base
+				BSet.B	#$4, $A0(A0)
+				Nop
+				BSet.B	#$4, $110(A0)
+				Nop
 
 	; Finally!  Restart the machine by Jumping through the Restart vector in the ROM header
 	
@@ -598,15 +675,15 @@ ShutPower
 				bsr.w	RemoveOtherRoutines		; Go remove these procedures from the queue		<13>
 
 				moveq	#SDBitPowerOff,D0		; pass parameter: power off.
+				moveq	#1,D1
 				bsr.w	CallRoutines			; do cleanup and check if new mac.
 
-				moveq	#1,D5					; Go ahead and hide cursor/close LCDs.
-				bsr		BlankDesktop			; Clear the whole desktop.
-								
 				bsr		FindEDisk				; Do we have an EDisk in the drive Q?
 				beq.s	@noEDisk				; -> Nope, continue w/power off
 				bsr		KillEDisk				; Clear the EDisk's checksum data (invalidate the disk)
 @noEDisk
+				IMPORT	SHUTDOWNMGRC_2CC90
+				BSR		SHUTDOWNMGRC_2CC90
 
 	; Send Sonic a soft reset																	<16> thru next <16>
 
@@ -660,17 +737,18 @@ DoSysErrDialog
 ;_______________________________________________________________________
 
 UserChoice
+				bsr		CheckForSoftPowerOff	; does this machine have software power-off?
+				bz.s	@noSoftPowerOff			; no!
+
 				moveq	#0,D5					; Don’t hide cursor/close LCDs.
 				bsr		BlankDesktop			; Clear the entire desktop for consistency.
 
-				bsr		CheckForSoftPowerOff	; does this machine have software power-off?
-				bz.s	@noSoftPowerOff			; no!
-
 				move.w	#dsShutDownOrRestart,d0	; yes, let the user choose Shut Down or Restart
 				bra.s	DoSysErrDialog
 
 @noSoftPowerOff
 				moveq	#sdBitPowerOff,d0		; notify just as we would for PowerOff
+				moveq	#0,d1
 				bsr.s	CallRoutines			; go do the notification
 
 				move.w	#dsSwitchOffOrRestart,d0	; no, let the user switch off or Restart
@@ -688,16 +766,27 @@ CallRoutines
 				movem.l	A1-A3/D0-D5,-(SP)
 				move.w	D0,D4
 
+				swap	D4
+				move	D1,D4
+
 ; Call Cleanup for Drivers, and Custom cleanup Procs.
 
 				moveq	#SDBitDrivers,D5		; do Pre-Driver cleanUp
 				bsr.s	CallCleanUp
 
+				moveq	#sdBitUnMount,D5
+				bsr.s	CallCleanUp
+
 ; Call Cleanup to unmount volumes, and then custom PowerOff/Restart.
 
-				moveq	#SDBitUnMount,D5		; do Vol UnMounts
+				moveq	#SDBitNew,D5
 				bsr.s	CallCleanUp
 				move.w	D4,D5					; do PowerOff or ReStart cleanup
+
+				bsr		BlankDesktop
+				swap	D4
+				move	D4,D5
+
 				bsr.s	CallCleanUp
 
 ; set up the flags for the caller.
@@ -786,6 +875,9 @@ CallCleanUp
 
 				clr.w	QType(a2)				; QType holds the shutdown flags
 @DontCallUs
+				cmp		#0,A3
+				beq.s	@NotFound
+
 				cmp.l	A2,D3					; at the end?
 				move.l	A3,A2
 				Bne.S	@ScanLoop
@@ -816,54 +908,6 @@ DoDrivers
 			MOVE.L	D0,A0							; get the DCE handle
 			MOVE.L	(A0),A0 						; get the DCE pointer
 
-;------------------------------------------------------------------------	<4> jmp
-			
-			Btst	#dRamBased,DCtlFlags+1(A0)		; If we’ve got a pointer, then just skip
-			Beq.s	@skipVidChk						;	this code (our drivers are RamBased).
-			
-			Move.l	A0,D7							; Save pointer to DCE.
-			Move.l	A1,D6							; Save UTable pointer.
-			
-			Move.l	dCtlDriver(A0),A0				; Get handle to driver.
-			Move.l	(A0),A0							; Get pointer to driver.
-			Lea		drvrName(A0),A0					; Point to driver name.
-			Move.l	A0,D5							; Save it for later.
-			
-			moveq	#0,D0							; Prepare D0.
-			Move.b	(A0),D0							; Get the length of the driver name.
-			Move.w	D0,D4							; Make a copy.
-			Addq	#2,D4							; Adjust offset to version field (len + 1)
-			Bclr	#0,D4							; Adjust offset for word alignment.
-			Move.w	(A0,D4.w),D4					; Get the version number.
-			Bne.s	@endVidChk						; If non-zero, then just leave.
-			
-			Swap	D0								; Get 1st string length into hi-word.
-			Addq	#1,A0							; Point to text of driver name.
-			Lea		TimVidTitle,A1					; Point to TIM/TIM-LC’s video driver name.
-			Move.b	(A1)+,D0						; Get 2nd string length into lo-word.
-			_CmpString								; Compare drvrName with TimVidTitle.
-			Tst.b	D0								; If this is the TIM/TIM-LC driver,
-			Beq.s	@fixFlags						;	then don’t kiss it goodbye.
-			
-			Move.l	D5,A0							; Restore pointer to driver name.
-			moveq	#0,D0							; Re-prepare D0.
-			Move.b	(A0)+,D0						; Get length of 1st string…
-			Swap	D0								; 	…into the hi-word.
-			Lea		DAFBVidTitle,A1					; Point to Spike/Eclipse video driver name.
-			Move.b	(A1)+,D0						; Get 2nd string length into lo-word.
-			_CmpString								; Compare drvrName with DAFVidTitle.
-			Tst.b	D0								; If this is the DAFB (Spike/Eclipse) driver,
-			Beq.s	@fixFlags						;	then don’t kiss it goodbye.
-			Bra.s	@endVidChk						; Otherise, just leave.
-			
-@fixFlags	Move.l	D7,A0							; Restore pointer to DCE.
-			Bclr	#DNeedGoodbye,DCtlFlags(A0) 	; Reset the good-bye kiss flag.
-
-@endVidChk	Move.l	D7,A0							; Restore pointer to DCE.
-			Move.l	D6,A1							; Restore pointer to UTable.
-			
-@skipVidChk
-
 ;------------------------------------------------------------------------	<4> jmp		
 			
 			BTST	#DNeedGoodbye,DCtlFlags(A0) 	; need a goodbye kiss?
@@ -884,28 +928,43 @@ DoDrivers
 			MOVEM.L	(SP)+,D0-D1/D4-D7/A0-A1			; restore registers		<4> jmp
 			RTS
 
-;------------------------------------------------------------------------	<4> jmp		
-
-			String	Pascal
-
-TIMVidTitle
-			DC.W	'.Display_Video_Apple_TIM'		; Name of TIM/TIM-LC Video Driver.
-
-DAFBVidTitle
-			DC.W	'.Display_Video_Apple_DAFB'		; Name of Spike/Eclipse Video Driver.
-
 ;------------------------------------------------------------------------	<4> jmp		
 
 ;_______________________________________________________________________
 ;
-; DoUnmount - Unmount all of the volumes on line, so the disks will be updated before our power off.
+; DoUnmountCommon - Unmount all of the volumes on line, so the disks will be updated before our power off.
 ;
 ;		Entry:	No parameters.
 ;
 ;_______________________________________________________________________
 
-			export	DoUnmount
+DoUnmountAtPowerDown
+			MOVE.L	D3,-(SP)
+			MOVE.L	#$2,D3
+			BSR		DoUnmountCommon
+			MOVE.L	(SP)+,D3
+			RTS
+
+
+DoUnmountAtRestart
+			MOVE.L	D3,-(SP)
+			MOVE.L	#$1,D3
+			BSR		DoUnmountCommon
+			MOVE.L	(SP)+,D3
+			RTS
+
+
+			EXPORT	DoUnmount
 DoUnmount
+			MOVE.L	D3,-(SP)
+			MOVE.L	#$3,D3
+			BSR		DoUnmountCommon
+			MOVE.L	(SP)+,D3
+			RTS
+
+
+DoUnmountCommon
+			move.l	D5,-(SP)
 			sub		#IOQElSize,SP				; allocate pBlock
 
 ; Go through the VCB Queue to Flush and eject all volumes.
@@ -916,6 +975,20 @@ DoUnmount
 			move.l	VCBQHdr+QHead,A1			; get the queue header
 			move.l	VCBQHdr+QTail,D2			; get the tail too
 			beq.s	@AllFlushed
+
+			cmp.l	D2,A1
+			beq.s	@AllFlushed
+
+			move.l	(A1),A1
+			move.l	#0,D5
+			tst.l	$B78
+			bmi.s	@alreadySetB78
+
+			move.l	$B78,A0
+			move.w	$4E(A0),D5
+			move.l	SP,A0
+@alreadySetB78
+
 			bsr		ZapVCBQueue					; wipe out the whole queue
 
 @AllFlushed
@@ -938,6 +1011,7 @@ taskActive	equ		7							; High bit of qType word is active flag.
 			_PrimeTime							; Start the TMTask.
 
 			move.l	DrvQHdr+QHead,D0			; Now, get a pointer to the first drvQElem.
+			beq.s	@TimedOut
 @Repeat		move.l	D0,A1						; Copy the drvQElem pointer into A1.
 			cmpi.w	#-5,dqRefNum(A1)			; If this isn’t a floppy (.Sony) driver drive,
 			bne.s	@Until						;	then just go on.
@@ -954,8 +1028,49 @@ taskActive	equ		7							; High bit of qType word is active flag.
 @TimedOut	_RmvTime							; Remove TMTask.
 
 			adda.w	#tmXQSize,Sp				; Reclaim the stack space.
+			move.l	(SP)+,D5
 		  	rts
 
+
+;_______________________________________________________________________
+;
+; DoSomethingAtRestartOrPower
+;_______________________________________________________________________
+
+DoSomethingAtRestartOrPower
+
+			movem.l	D3/D5,-(SP)
+
+			tst		D4
+			beq.s	@cond1
+
+			moveq	#1,D3
+			bra.s	@cond2
+
+@cond1		moveq	#2,D3
+@cond2		sub		#IOQElSize,SP				; allocate pBlock
+
+; Go through the VCB Queue..?
+
+		  	move.l	SP,A0						; point to the parameter block
+			clr.L	ioVNPtr(A0)
+			clr.W	ioRefNum(A0)
+			move.l	VCBQHdr+QHead,A1			; get the queue header
+			move.l	VCBQHdr+QTail,D2			; get the tail too
+
+			beq		@noZap
+
+			move.l	#0,D5
+			bsr		ZapVCBQueue
+@noZap
+
+			add.w	#IOQElSize,SP
+
+			movem.l	(SP)+,D3/D5
+
+			rts
+
+
 ;_______________________________________________________________________					<5>
 ;
 ; ClearWarmStart - Shutdown task to clear warm start variable if user
@@ -996,9 +1111,6 @@ ClearWarmStart
 UpdateEmuWarmstart	
 			With	nkDiagInfo	
 
-			testFor	has68kEmulator					; Does this machine have a V0 style emulator?
-			beq		@Done							; -> Nope, we're done.  Exit.
-			
 			move	SR,-(SP)						; Save SR
 			ori.w	#hiIntMask,SR					; Disable interrupts
 			movem.l	D2-D7,-(SP)						; Save some D regs
@@ -1023,6 +1135,7 @@ UpdateEmuWarmstart
 			
 			lea		1,A0							; Get the buffer page number in A0
 			lea		1,A1							; Say page is inited (#1)
+			move.l	D1,A1
 			_nkMMUMarkBacking						; Mark this page as outta here
 	
 			lea		1,A0							; Logical Page number of the buffer
@@ -1039,6 +1152,7 @@ UpdateEmuWarmstart
 	
 			lea		1,A0							; Get the lo Page number in A0
 			lea		1,A1							; Say page is inited (#1)
+			move.l	D1,A1
 			_nkMMUMarkBacking						; Mark this page as outta here
 	
 			lea		1,A0							; Get the lo Page number in A0
@@ -1054,6 +1168,12 @@ UpdateEmuWarmstart
 			
 			EndWith
 
+
+
+			rts
+
+
+
 ;_______________________________________________________________________					<5>
 ; ZapVCBQueue - This routine goes through the VCB Queue, and calls HUnmountVol for each entry.
 ;
@@ -1064,20 +1184,55 @@ UpdateEmuWarmstart
 ;				D1 - Preserved.
 ;_______________________________________________________________________					<5>
 
+			import	SHUTDOWNMGRC_2CB90
+
 ZapVCBQueue
-			move.w	D1,-(SP)			; save for re-entrancy.
+			movem.l	D1/D4-D6,-(SP)		; save for re-entrancy.
 			
+			moveq	#0,D4
 			move.w	vcbVRefNum(A1),D1	; get a VRefNum
+			move.w	vcbDrvNum(A1),D6
+			move.w	vcbDRefNum(A1),D4
 			move.l	QLink(A1),-(SP)		; go on to the next VCB
 			cmp.l	D2,A1
 			move.l	(SP)+,A1
 			beq.s	@FlushTime			; have we reached the end?
 			bsr.s	ZapVCBQueue			; not yet, save the VRefNum, call self.
 @FlushTime
+
+			tst		D5
+			beq.s	@defsDo
+			cmp		D5,D6
+			beq.s	@return
+@defsDo
+
 			move.w	D1,ioVRefNum(A0)	; set up the refNum in the PBlock.
-			_Eject
 			_HUnMountVol				; shut the volume down.
-			move.w	(SP)+,D1			; restore crucial VRefNum
+
+			tst		D6
+			bgt.s	@skipCheck
+
+			tst		D4
+			bge.s	@return
+
+			neg		D4
+			move	D4,D6
+@skipCheck
+
+			move.l	A0,-(SP)
+			move.l	D4,-(SP)
+			move.l	D3,-(SP)
+			bsr		SHUTDOWNMGRC_2CB90
+			addq.l	#8,SP
+			move.l	(SP)+,A0
+
+			tst		D0
+			bne.s	@return
+
+			move	D6,ioVRefNum(A0)
+			_Eject
+
+@return		movem.l	(SP)+,D1/D4-D6
 			Rts							; for reentrancy.
 
 ;_______________________________________________________________________
@@ -1099,6 +1254,7 @@ ZapVCBQueue
 ;_______________________________________________________________________
 
 			IMPORT	AllocFakeRgns			;
+			IMPORT	SHUTDOWNMGRC_2D4F0, SHUTDOWNMGRC_2D330
 
 BlankDesktop
 
@@ -1138,6 +1294,14 @@ BlankDesktop
 			
 			TST.B	D5						; If we’re not supposed to close LCDs,
 			BEQ.S	@SkipClose				;	then just go on.
+
+			CLR.B	-(SP)
+			BSR		SHUTDOWNMGRC_2D4F0
+
+			CLR.B	-(SP)
+			BSR		SHUTDOWNMGRC_2D330
+
+			BSR		YetAnother
 			BSR		CloseLCDVideo			; Otherwise, close ’em.
 @SkipClose
 
@@ -1182,51 +1346,57 @@ CheckForSoftPowerOff
 ;			if the video is of type LCD.  If so, then close the video driver.  
 ;————————————————————————————————————————————————————————————————————————————————————————
 
-CloseLCDFrame		RECORD	0, DECR
-CloseLCDCntBlk		DS.B	IOVQElSize				; control call parm block
-CloseLCDSpBlk		DS.B	spBlock.spBlockSize		; Slot Manager param block.
-CloseLCDFrameSize	EQU		*						; size of frame
-					ENDR
+CloseLCDVideo
 
-CloseLCDVideo		
-CloseLCDVideoRegs	REG		D1/A0-A1	
-		WITH CloseLCDFrame,spBlock
-			LINK	A6,#CloseLCDFrameSize			; allocate variable space
-			MOVEM.L	CloseLCDVideoRegs,-(SP)			; Save them regs
-			LEA		CloseLCDSpBlk(A6),A1			; Get pointer to spBlock
-			MOVEA.L	A1,A0							; Set pointer to A0
-			CLR.B	spSlot(A0)						; Set slot number
-			MOVEQ	#0,D1							; set spId to 0
-			CLR.B	spExtDev(A0)					; No external devices
-			MOVE.W	#CatDisplay,spCategory(A0)		; Look for this slot's card
-			MOVE.W	#TypVideo,spCType(A0)			; Make sure it is video
-			MOVE.W	#DrSwApple,spDrvrSW(A0)			; Make sure it is from Apple
-			MOVE.B	#1,spTBMask(A0)					; mark spDrvrHw field as don’t care
-@sNextLoop
-			MOVEA.L	A1,A0							; Get pointer to spBlock
-			MOVE.B	D1,spId(A0)						; Set spID
-			_sNextTypesRsrc							; get the spsPointer
-			BNE.S	@Done
+			Move.L	(DeviceList), D0
+			BEQ.B	@L5
+			MoveM.L	A0-A2, -(A7)
+			Link	A6, #-$40
+@L1			MoveA.L	D0, A2
+			MoveA.L	(A2), A2
+			IMPORT	PMGRCALLEDBYSHUTDOWNMGRDEC4
+			Bsr.L	PMGRCALLEDBYSHUTDOWNMGRDEC4
+			BNE.B	@L2
+			IMPORT	PMGRCALLEDBYSHUTDOWNMGRDEE4
+			Bsr.L	PMGRCALLEDBYSHUTDOWNMGRDEE4
+			BEQ.B	@L4
+@L2			Move	(A2), D0
+			MoveA.L	(UTableBase), A1
+			AddQ	#$1, D0
+			Neg		D0
+			AsL		#$2, D0
+			MoveA.L	$0(A1,D0.W), A1
+			MoveA.L	(A1), A1
+			BTst.B	#$3, $5(A1)
+			BEQ.B	@L3
+			Move.L	#$1, -(A7)
+			Move	(A2), D0
+			Ext.L	D0
+			Move.L	D0, -(A7)
+			IMPORT	EXPANSIONBUSMGR_VEC01A8
+			Bsr.L	EXPANSIONBUSMGR_VEC01A8
+			AddQ	#$8, A7
+			Bra.B	@L4
+@L3			Lea.L	-$40(A6), A0
+			Move	(A2), $18(A0)
+			_Close
+@L4			Move.L	$1E(A2), D0
+			BNE.B	@L1
+			Unlk	A6
+			MoveM.L	(A7)+, A0-A2
+@L5			Rts
 
-			MOVE.B	spId(A0),D1						; Save spId for later use
-			MOVE.B	#sVidAttributes,spId(A0)		; read flag field in sRsrc
-			_sReadWord								; ...pointed to by spsPointer
-			BNE.S	@sNextLoop						; no flags - find next sRsrc
 
-			MOVEQ.L	#1<<fLCDScreen,D0				; got flag word
-			AND.W	spResult+2(A0),D0				; test if LCD screen
-			BEQ.S	@sNextLoop
-			
-			LEA		CloseLCDCntBlk(A6),A0			; Get pointer to ioPB
-			MOVE.W	spRefNum(A1),ioRefNum(A0)		; Get the driver refNum
-			_Close									; Close the driver
 
-			BRA.S	@sNextLoop
-@Done
-			MOVEM.L	(SP)+,CloseLCDVideoRegs			; Restore them regs
-			UNLK	A6								; Clean up the stackframe
-			RTS										;												<4> HJR
-		ENDWITH
+			IMPORT	SHUTDOWNMGRC_2CC30
+
+YetAnother
+			MOVEM.L	D0-D2/A0-A1,-(SP)
+			BTST.B	#6,$2409
+			BEQ.S	@return
+			BSR.L	SHUTDOWNMGRC_2CC30
+@return		MOVEM.L	(SP)+,D0-D2/A0-A1
+			RTS
 
 
 
@@ -1312,7 +1482,6 @@ KillEDisk
 			BNE.S	@noEMMU					; IF we have an EMMU THEN
 			MOVE.L	A2,A0					;	get ptr to start of data area
 			MOVE.L	#BytesToKill,A1			;	get number of bytes to erase
-			MOVE.L	#(0<<16)|hwEDiskProt,D0	;	_HwPriv EDisk write protect selector and "unprotect" parm
 			BRA.S	@unProtect				; ELSE
 @noEMMU		MOVE.L	CheckSumPtr(A0),A0		;	Get Ptr to the start of the checksum area, if it exists
 			TST.L	A0						;	Check if RAM Disk is using checksums
@@ -1320,8 +1489,8 @@ KillEDisk
 			MOVE.L	A2,A0					;	  base address of RAM disk is same as DataStartPtr
 @cksumOn									;	ENDIF
 			SUB.L	A1,A1					;	Protect flag.  Zero = Unprotect
-			MOVEQ	#hwEDiskProt,D0			;	_HwPriv EDisk write protect selector
 @unProtect									; ENDIF
+			MOVEQ	#hwEDiskProt,D0			;	_HwPriv EDisk write protect selector
 			_HwPriv							; Write Enable the EDisk RAM
 			CMPI.W	#paramErr,D0			; Does not clear D0 on success, Check for failure
 			BEQ.S	@Done					; -> enable failed.  Bail out now or Bus Error!		
@@ -1445,7 +1614,13 @@ ShutDownCancelButton	EQU		2				; dialog item of Cancel button
 			_ParamText							; set dialog parameters
 
 			subq	#4,sp						; room for DialogPtr
+			bsr		VersionCheckingFunc
+			beq.s	@oldDLOG
+			move.w	#-20601,-(sp)
+			bra.s	@doIt
+@oldDLOG
 			move.w	#ShutDownDLOGID,-(sp)		; resource ID
+@doIt
 			clr.l	-(sp)						; use heap storage
 			move.l	#-1,-(sp)					; put it in front
 			_GetNewDialog
@@ -1488,82 +1663,30 @@ exitFalse	move.w	#false,d0					; allow shutdown to continue
 justExit	move.l	(sp)+,a2					; restore a2
 			rts
 			
-;________________________________
-;
-;	Docking Dispatch Trap
-;
 
-DockInitSCC		MOVEM.L	D0-D2/A0-A2,-(SP)			;														<3>
-				MOVE.W	#UnimplementedTrapNumber,D0	; does the _DockingDispatch trap exist?
-				_GetTrapAddress	,NEWTOOL
-				MOVEA.L	A0,A1
-				MOVE.W	#$AA57,D0
-				_GetTrapAddress	,NEWTOOL
-				CMPA.L	A0,A1
-				BEQ.S	@Done						; -> no, skip it
-				MOVEQ	#sccOn-256,D0				; turn SCC power on
-				BSR.S	@SCCPower
-				BSR.S	InitSCC						; reset the SCC so it doesn't cause us trouble
-				MOVEQ	#sccOff,D0					; turn SCC power off
-				BSR.S	@SCCPower
-@Done			MOVEM.L	(SP)+,D0-D2/A0-A2
-				RTS
-@SCCPower
-				TestFor	hwCbPwrMgr					; does this machine have a Power Manager?
-				BEQ.S	@NoPMGR						; -> nope, skip
-				MOVE.B	D0,-(SP)
-				MOVE.L	SP,-(SP)					;  pmRBuffer
-				MOVE.L	(SP),-(SP)					;  pmSBuffer
-				MOVE.W	#1,-(SP)					;  pmLength = 1 byte to send
-				MOVE.W	#powerCntl,-(SP)			;  pmCommand = power control
-				MOVEA.L	SP,A0						; point to the parameter block
-				_PMgrOp								; turn SCC power on or off
-				LEA		pmRBuffer+4+2(SP),SP		; toss the parameter block and buffer
-@NoPMGR			RTS
-InitBData
-				DC.B	9,$C0						; do a hard reset
-				DC.B	9,$40						; reset the channel
-				DC.B	4,$4C						; set async mode (magic?)
-				DC.B	2,$00						; zero interrupt vector for dispatcher
-				DC.B	3,$C0						; DCD not an auto-enable
-				DC.B	15,$00						; no interrupts
-				DC.B	0,$10						; reset ext/sts interrupts twice
-				DC.B	0,$10
-				DC.B	1,$00						; no interrupts
-InitBLth		EQU 	*-InitBData
-	
-InitAData		DC.B	9,$80						; reset the channel
-				DC.B	4,$4C						; set async mode (magic?)
-				DC.B	3,$C0						; DCD not an auto-enable
-				DC.B	15,$00						; no interrupts
-				DC.B	0,$10						; reset ext/sts interrupts twice
-				DC.B	0,$10
-				DC.B	1,$00						; no interrupts
-InitALth		EQU 	*-InitAData
-	
-	
-InitSCC
-				TestFor	SCCIOPExists				; see if we have a SCC IOP
-				bne.s	@hasIOP						; if so, don't try to initialize it
-				MOVEA.L	SCCWr,A0					; point to SCC base write address (chan B)
-				MOVEA.L	SCCRd,A1					; point to SCC base read address (chan B)
-				LEA 	InitBData,A2				; point to channel B init data
-				MOVEQ	#InitBLth,D1				;  and set up the length
-				BSR.S	@WriteSCC					; then init channel B
-	
-				ADDQ.W	#ACtl,A0					; adjust SCC addresses for channel A
-				ADDQ.W	#ACtl,A1
-													; A2 points to channel A's init data
-				MOVEQ	#InitALth,D1				;  init data length
-@WriteSCC		MOVE.B	(A1),D2 					; read to make sure SCC is sync'ed up
-				BRA.S	@2							; delay for timing, too
-@1				MOVE.L	(SP),(SP)					; delay long for reset
-				MOVE.L	(SP),(SP)
-				MOVE.B	(A2)+,(A0)
-@2				DBRA	D1,@1
-	
-@hasIOP			RTS
- 				
+
+VersionCheckingFunc
+			
+			move.l	ROMBase, a0
+
+			cmp.w	#$077D, ROMHeader.MachineNumber(a0)
+			bne.s	@zero
+
+			cmp.b	#$40, ROMHeader.ROMRelease(a0)
+			beq.s	@one
+
+			cmp.b	#$45, ROMHeader.ROMRelease(a0)
+			beq.s	@one
+
+			cmp.b	#$44, ROMHeader.ROMRelease(a0)
+			bne.s	@zero
+
+@one		moveq.l	#1, d0
+			rts
+
+@zero		moveq.l	#0, d0
+			rts
+
 		endwith	
 		ENDP
 		END
diff --git a/Toolbox/TextEdit/TextEdit.a b/Toolbox/TextEdit/TextEdit.a
--- a/Toolbox/TextEdit/TextEdit.a
+++ b/Toolbox/TextEdit/TextEdit.a
@@ -1233,7 +1233,6 @@ TextEdit	Proc		Export
 			Export		vChar2Pixel
 			
 ; sets up vectors to be used for patching TextEdit and clears ExpandMem TE globals <28June89smb>
-			Export		GestaltTEVersion					; <13>
 			Export		TEGlobalInit					; <13>
 ;-------------------------------------------------------------------------------------------------
 
@@ -1254,6 +1253,7 @@ AddrTable	DC.W		iTEStylPaste-AddrTable				; 0
 			DC.W		iTECustomHook-AddrTable				; 12
 			DC.W		iTENumStyles-AddrTable				; 13
 			DC.W		iTEFeatureFlag-AddrTable			; 14
+			DC.W		iTEGetHiliteRgn-AddrTable			; 15
 
 ;-------------------------------------------------------------------------------------------------
 
@@ -1335,44 +1335,8 @@ VectorLoop
 LoopXit
 			movem.l	(sp)+,a2/a3
 			
-; when TextEdit 3.0 is ptch0, need this code			
-			move.l	#gestaltTextEditVersion, d0	; <8Aug89smb>
-			lea		GestaltTEVersion, a0
-			_NewGestalt
 			rts
 
-;----------------------------------------------------------------------
-;			PROCEDURE GestaltTEVersion
-;			<8Aug89smb>
-;			The following Gestalt Function is an interface using the Gestalt
-;			mechanism to determine the current version of TextEdit.
-;
-;			 FUNCTION	GestaltTEVersion (	gestaltSelector: 	OSType;
-;											VAR gestaltResult:	Longint;): OSErr;
-;
-;			The versions for the gestaltTextEditVersion selector are:
-;				gestaltUndefSelectorErr = old styled TextEdit (pre-MacIIci TE)
-;			All the following versions of TE are based on the SMgr-compatible version:
-;				gestaltTE1 (1) = MacIIci ROM/PTCH 67c
-;				gestaltTE2 (2) = 604 Script Systems PTCH 67c (Script bug fixes for MacIIci)
-;				gestaltTE3 (3) = 604 Script Systems ptch0/parallels Big Bang (for MacII, MacSE, Mac+)
-;				gestaltTE4 (4) = Big Bang ptch0/PTCH 67c
-;				gestaltTE5 (5) = TextWidthHook available in System 7
-;
-;			THE OBVIOUS: since this is here for the MacIIci ROM patch, we have 
-;			hardcoded the ONLY value that is appropriate to be returned! sigh.
-;_________________________________________________________________________________
-
-GestaltTEVersion
-
-			move.l	(sp)+,a0			; return address
-			move.l	(sp)+,a1			; address of result
-			move.l		#gestaltTE5, (a1)	; 													<19>
-			adda.w	#4,sp				; pop the selector type
-			move.w	#noErr,(sp)			; it always works
-			jmp		(a0)
-
-;formFeed
 ;----------------------------------------------------------------------
 ;
 ;			PROCEDURE TEInit
@@ -8254,7 +8218,7 @@ CopyGuts
 			Bsr			GetStyle				; get the style ptr
 			AddQ.L		#2,A0					; skip 1st entry				** <C207/13oct86/MBK> **
 			MoveQ		#stRecSize-2,D0			; size of a style rec-2			** <C381/6nov86/MBK> **
-			_BlockMove							; copy style to scrap
+			_BlockMoveData						; copy style to scrap
 
 			MoveQ		#0,D0					; it's a long word				** <C207/13oct86/MBK> **
 			Move.W		startChar(A2),D0		; get start offset of this style
@@ -8461,7 +8425,7 @@ DeleteStyle
 			Move.L		A2,A1					; destination of move
 			Move.L		A2,A0
 			Add.L		D4,A0					; source of move
-			_BlockMove
+			_BlockMoveData
 
 @2			MoveM.L		(SP)+,D0/D2-D6/A2		; restore stuff
 
@@ -10937,7 +10901,7 @@ MakeRoom
 			Add.L		D2,A1					; destination
 			Move.L		D3,D0					; length
 			_StripAddress						; clean up high byte of length <5June89smb>
-			_BlockMove							; make room
+			_BlockMoveData						; make room
 
 
 			MoveM.L		(SP)+,D2-D3/A2
@@ -11140,7 +11104,7 @@ AddStyle
 
 @1			Sub.W		D0,D3					; get the index
 			Move.L		#stRecSize,D0			; size of record
-			_BlockMove							; copy it to styleRec array
+			_BlockMoveData						; copy it to styleRec array
 
 			Move.W		D3,D0					; return the index
 
@@ -13963,7 +13927,7 @@ styleLoop	Move.W		styleIndex(A2),D0		; else, index to style
 
 			Move.L		#stRecSize,D0			; length of a styleRec
 			Move.L		A4,A1					; ptr to temp storage
-			_BlockMove							; copy to temp location for mod
+			_BlockMoveData						; copy to temp location for mod
 
 			Move.L		A2,A0					; current style
 			Move.L		D3,D0					; selStart, selEnd
@@ -14939,7 +14903,7 @@ iGetStylScrap
 			Lea			2(A0),A0				; skip over stCount to stHeight		<C971/RWW102387>
 
 			Move.L		#scrpRecSize-4,D0		; amount to copy					<C971/RWW102387>
-			_BlockMove							; from NullStRec to StScrpRec		<C971/RWW102387>
+			_BlockMoveData						; from NullStRec to StScrpRec		<C971/RWW102387>
 			Bra.S		EndGet					; we're outta here					<C971/RWW102387>
 @05												;									<C971/RWW102387>
 
@@ -15496,6 +15460,55 @@ ContGuts
 
 			EndWith		;contArgs
 
+;formFeed
+;----------------------------------------------------------------------
+;
+;			PROCEDURE TEGetHiliteRgn( region: RgnHandle; hTE: TEHandle ): OSErr;
+;
+;			Obtains the highlight region for the specified edit structure.
+;
+;----------------------------------------------------------------------
+iTEGetHiliteRgn
+			Move		$20(A3), D0
+			Cmp			$22(A3), D0
+			BLT.B		@L1
+			Move.L		(A2)+, -(SP)
+			_SetEmptyRgn
+			Bra.B		@L3
+@L1			Move.L		$56(A3), -(SP)
+			Lea.L		DT0, A0
+			Move.L		A0, $56(A3)
+			_OpenRgn
+			Move		$24(A3), -(SP)
+			OrI			#$FF00, $24(A3)
+			Pea.L		$10(A3)
+			Move.L		A4, -(SP)
+			_TEUpdate
+			Move		(SP)+, $24(A3)
+			Move.L		(A2), -(SP)
+			_CloseRgn
+			SubQ		#4, SP
+			_NewRgn
+			Move.L		(SP)+, D0
+			BEQ.B		@L2
+			Move.L		D0, -(SP)
+			Move.L		D0, -(SP)
+			Move.L		(A2), -(SP)
+			Move.L		(A2), -(SP)
+			Move.L		D0, -(SP)
+			Pea.L		$8(A3)
+			_RectRgn
+			_SectRgn
+			_DisposeRgn
+@L2			AddQ		#4, A2
+			Move.L		(SP)+, $56(A3)
+@L3			Clr			(A2)
+			MoveQ.L		#10, D0
+			Bra			StdExit2
+
+DT0			_FrameRect
+			Rts
+
 
 ; *************************************************************************************************
 ; *************************************************************************************************
diff --git a/Toolbox/Toolbox.make b/Toolbox/Toolbox.make
--- a/Toolbox/Toolbox.make
+++ b/Toolbox/Toolbox.make
@@ -61,12 +61,14 @@ WindowMgrDir 				= "{ToolBoxDir}WindowMgr:"
 ToolboxObjs	= 						"{ObjDir}PackageMgr.a.o"						∂
 									"{ObjDir}SegmentLoader.a.o"						∂
 									"{ObjDir}ShutDownMgr.a.o"						∂
+									"{ObjDir}ShutDownMgr.c.o"						∂
 									"{ObjDir}Munger.a.o"							∂
 									"{ObjDir}DeskMgr.a.o"							∂
 									"{ObjDir}GetMgr.a.o"							∂
 									"{ObjDir}TextEdit.a.o"							∂
 									"{ObjDir}ScrapMgr.a.o"							∂
 									"{ObjDir}PrintGlue.a.o"							∂
+									"{ObjDir}BlueBoxPrintHook.c.o"					∂
 									"{ObjDir}SexyDate.a.o"							∂
 
 
@@ -85,6 +87,9 @@ ToolboxObjs	= 						"{ObjDir}PackageMgr.a.o"						∂
 "{ObjDir}ShutDownMgr.a.o"			ƒ	"{ToolboxDir}ShutDownMgr:ShutDownMgr.a"
 	Asm {StdAOpts} -o "{Targ}" "{ToolboxDir}ShutDownMgr:ShutDownMgr.a"
 
+"{ObjDir}ShutDownMgr.c.o"			ƒ	"{ToolboxDir}ShutDownMgr:ShutDownMgr.c"
+	C {StdCOpts} -o "{Targ}" "{ToolboxDir}ShutDownMgr:ShutDownMgr.c"
+
 "{ObjDir}Munger.a.o"				ƒ	"{ToolboxDir}Munger:Munger.a"
 	Asm {StdAOpts} -o "{Targ}" "{ToolboxDir}Munger:Munger.a"
 
@@ -108,3 +113,6 @@ ToolboxObjs	= 						"{ObjDir}PackageMgr.a.o"						∂
 										"{AIncludes}PrPrivate.a"					∂
 										"{PrintingDir}PrintGlue.a"
 	Asm {StdAOpts} -o "{Targ}" "{PrintingDir}PrintGlue.a"
+
+"{ObjDir}BlueBoxPrintHook.c.o"		ƒ	"{PrintingDir}BlueBoxPrintHook.c"
+	C {StdCOpts} -o "{Targ}" "{PrintingDir}BlueBoxPrintHook.c"
diff --git a/Toolbox/ToolboxEventMgr/ToolboxEventMgr.a b/Toolbox/ToolboxEventMgr/ToolboxEventMgr.a
--- a/Toolbox/ToolboxEventMgr/ToolboxEventMgr.a
+++ b/Toolbox/ToolboxEventMgr/ToolboxEventMgr.a
@@ -503,20 +503,6 @@ HandBySys								;											<09Apr85>
 DoneGNE
 
 
-; The following is a one-time check to see if the internal drive (SCSI ID in low
-; memory) is up to speed by now.  If so, then clear high bit of PRAM startup
-; device timeout value (PRAM address $01, byte length) to indicate that device
-; 0 is there (and the startup code will wait for it at the next boot).
-
-				BTST.B	#7,SCSIPoll		; bit 7 is cleared by InitSCSIMgr			<C613/12Jan87>
-				BNE.S	@1				; don't poll if we've already done it once	<C613/12Jan87>
-				CMP.L	#20*60,Ticks	; have we been running for 20 seconds?		<A349/04Nov86>
-				BLO.S	@1				; no, too early yet							<A300/29Oct86>
-				BSET.B	#7,SCSIPoll		; set it so we don't do it again			<C613/12Jan87>
-				BSR		TryDevice		; see if that device is out there			<C613/12Jan87>
-
-@1
-
 ; see if there was no event, if so do a get mouse to tickle tracking
 ; Historical note: by this time, an FKey is made to look like "no event", in which	<13Jan86  JTC>
 ; case the mouse update is done...
@@ -617,75 +603,6 @@ GotDActive		CLR 	D2				;flag the deactivate
 				BRA.S	GotActCommon	;go use common code
 
 
-;--------------------------------------------------------------------------
-;
-; TryDevice -- we do a one-time check of the SCSI ID for the internal hard
-;	disk some number of seconds after bootup.  Since the internal disk is
-;	powered from the CPU's power supply, it is likely that the startup code
-;	will be ready to boot off a floppy before the disk has spun up to full
-;	speed.  Unless we have some way to know if there is an internal drive,
-;	the start code won't know whether or not to wait for the device.  This
-;	'lightning bolt' happens once per bootup, setting a field in parameter
-;	RAM that the startup code looks at.  If we find a SCSI device ready that
-;	corresponds to the internal disk SCSI ID stored in parameter RAM, then
-;	we set a field in parameter RAM so the startup code will wait for it
-;	at the next bootup.  This introduces some hysteresis in the process if the
-;	user changes the ID of his internal drive, but it was deemed to be more
-;	preferable than the alternative of a Control Panel setting to enable and
-;	disable waiting for the internal hard disk.  The default ID to check is
-;	0, but can be changed in parameter RAM (which gets stored into the SCSIPoll
-;	variable by InitSCSIMgr).
-;
-
-TryDevice								; This subroutine new <A300/29Oct86>
-				CLR.L	-(SP)			; 6-byte Test Unit Ready command block
-				CLR.L	-(SP)			;   (6 zeroes) and 2-byte return value
-				_SCSIGet				; arbitrate for the SCSI bus
-				TST.W	(SP)			; success?
-				BNE.S	TryDevDone		; if arbitrate failed, don't change PRAM
-				MOVE.B	SCSIPoll,D0		; get SCSI ID of the int. drive		<C613>
-				AND.B	#$07,D0			; mask off ID bits					<C613>
-				MOVE.W	D0,-(SP)		; push SCSI ID for the select		<C613>
-
-				_SCSISelect				; try to select (max. wait 250 ms.)
-				TST.W	(SP)			; success?
-				BEQ.S	SelectOK		; branch if select succeeded
-
-				_DisableDynWait			; don't wait for that id on bootup	<A349/04Nov86>
-				BRA.S	TryDevDone		; exit
-
-SelectOK
-				PEA		2(SP)			; address of Test Unit Ready command
-				MOVE.W	#6,-(SP)		; length of Test Unit Ready command
-				_SCSICmd				; do the command
-		;
-		;	If something went wrong with the command, then we need to do
-		;	SCSIComplete anyway, so it isn't necessary to check the
-		;	return value.  Since we don't need the space for the command
-		;	block any more, we just reuse it for the status and message
-		;	values (each a word) returned by SCSIComplete.  Before pushing
-		;	anything else, these EA's are 2(sp) and 4(sp), so we PEA 2(sp)
-		;	for the first (which adds 4 bytes to the stack), and PEA 8(sp)
-		;	for the second [PEA 4+4(sp)].
-		;
-				PEA		2(SP)			; address for status value
-				PEA		8(SP)			; address for message value
-				MOVEQ.L	#60,D0			; maximum number of ticks to wait	<A349/04Nov86>
-				MOVE.L	D0,-(SP)		; push it
-				_SCSIComplete			; wrap things up, ignore return code
-		;
-		;	If we got this far, then there is a device 0, so enable timeout
-		;
-				_EnableDynWait			; startup code will wait for dev. 0	<A349/04Nov86>
-
-TryDevDone
-				ADDQ.L	#8,sp			; clean up local variables
-				RTS
-
-
-				ENDPROC
-
-
 ;____________________________________________________________________________________
 ;
 ; Proc WaitNextEvent
diff --git a/Toolbox/ToolboxEventMgr/ToolboxEventMgrPatches.a b/Toolbox/ToolboxEventMgr/ToolboxEventMgrPatches.a
--- a/Toolbox/ToolboxEventMgr/ToolboxEventMgrPatches.a
+++ b/Toolbox/ToolboxEventMgr/ToolboxEventMgrPatches.a
@@ -143,191 +143,4 @@ ClearSysErrorUpdateRect installproc (Plus,SE,II,Portable,IIci)
 
 		endproc
 		
-	if not forROM then
-;————————————————————————————————————————————————————————————————————————————————————————————————————
-; GetNextEvent/EventAvail — fix 32-bit activation bug
-
-; A bug occurs in the IIci ROM under 32-bit mode. The high bit of CurActivate and CurDeactivate
-; are used as flags to indicate that the events have already been sent. (0 in either also means that
-; the event was sent.) The problem is that the ROM code (written for 24-bit machines) refers to the
-; windowKind field without stripping off this high bit. Under some circumstances, this would cause
-; a bus error. Since the code that checks the window is only used to set the system/application bit
-; in the modifiers of the activate/deactivate event, and that bit was never documented in a released
-; version of Inside Mac. (and no one uses it), we can fix the bug by getting rid of the code that
-; sets the system/application bit. This patch to CheckActivate eliminates the code to set the
-; system/application bit.
-
-FixCheckActivate comefrompatchproc _OSEventAvail,AfterOSEventAvailInCheckActivate,(IIci,using32BitHeaps)
-
-		lea		ComeBackHere,a1				; after doing the OSEventAvail, come back here
-		move.l	a1,ReturnAddressDepth(sp)	; jam in that return address
-		jmpOld								; go do the OSEventAvail
-
-ComeBackHere
-		MOVE.W	#activateEvt,(A0)+			; flag it as (de)activate event
-		MOVE.L	D1,(A0) 					; the windowPtr is the message
-
-		jmpROM	AfterSystemUserWindowInCheckActivate
-
-		endproc
-	endif
-;————————————————————————————————————————————————————————————————————————————————————————————————————
-; GetNextEvent - Make sure current port is valid before calling _GetMouse
-
-; This is mostly for the sake of the journalling driver.  Before _GetNextEvent calls _GetMouse, check
-; to see if the Window Manager exists by checking WWExist.  (QDExist is also checked in the process, but
-; that’s fine.)  If the Window Manager exists, set the port to the Window Manager port before calling
-; _GetMouse.  If there’s no Window Manager, the call to _GetMouse is skipped.
-
-SetWindowMgrPort ComeFromPatchProc _GetMouse,AfterGetMouseInGetNextEvent,(Plus,SE,II,Portable,IIci)
-
-		tst.w	WWExist				; See if the Window Manager & QuickDraw exist
-		bne.s	@backToGetNextEvent	; If WMgr isn’t there, don’t call _GetMouse
-
-; Window Mananger exists.  Set the port to the Window Manager’s port before calling _GetMouse
-
-		sub.w	#4,sp
-		move.l	sp,-(sp)
-		_GetPort				; Save the current port on the stack
-
-		move.l	WMgrPort,-(sp)
-		_SetPort				; Set the port to the Window Manager’s port
-		move.l	8(sp),-(sp)		; Copy the original _GetMouse parameter
-		jsrOld					; Call _GetMouse
-
-		_SetPort				; Old port is already on the stack.
-
-@backToGetNextEvent
-		add.w	#8,sp			; Remove return address and parameter from stack
-		jmpROM	AfterGetMouseInGetNextEvent
-		ENDPROC
-
-;————————————————————————————————————————————————————————————————————————————————————————————————————
-; Come-from patch on _GetResource inside GetNextEvent to ignore FKEYs on the Mac Plus			<9>
-
-; If called from GetNextEvent trying to load an FKEY, abort out so that the
-; event record is passed to the application.  FKEYs are handled by SystemEvent on the Plus.
-
-; Note that this FKEY patch is rarely invoked, and only in bizarre circumstances.
-; Due to a bug in the Mac Plus ROM, a valid FKEY event always fails the range check (it
-; compares ASCII 0 through 9 (i.e. $30 to $39) to decimal 0 through 9), and GetNextEvent
-; never tries to invoke the FKEY.  However, it may try to load an FKEY when an invalid key
-; combination is held down. For example, shift-cmd-enter is really shift-cmd-$03, which because
-; of the range checking problem causes FKEY 3 to be loaded.  Someday we may want to reassess whether
-; this patch is more trouble than it's worth.
-
-LoadFKEYInGetNextEvent		ComeFromPatchProc	_GetResource,AfterGetResourceInTryFKey,(Plus)
-
-		LEA		14(SP), SP				; Clean off the stack
-		jmpROM	DoneGNE					; Go where we are supposed to
-		
-		endproc
-
-;————————————————————————————————————————————————————————————————————————————————————————————————————
-; Come-from patch on _GetResource inside GetNextEvent to disable FKEYs from the keypad			<9>
-
-; Note that even though this is a come-from on the same label as LoadFKEYInGetNextEvent on
-; the Plus, it's doing different things.  On the Plus, FKEY handling was moved into SystemEvent.
-; On the SE and II, it was moved back out so that FKEY's are handled before calling SystemEvent.
-; So, it's valid for GetNextEvent to get an FKEY on the SE and II where it wasn't valid on the
-; Plus.
-
-KeypadFKEYInGetNextEvent	ComeFromPatchProc	_GetResource,AfterGetResourceInTryFKey,(SE,II)
-
-		TST.B	ScrDmpEnb				;	Check the ScrDmpEnb flag							<11>
-		BNE.S	moreChecks				;	if it is not false, do some more checks				<11>
-		MOVE.L	(SP)+, A0				;	otherwise, return NIL.								<11>
-		ADDQ.L	#6, SP					;														<11>
-		CLR.L	(SP)					;														<11>
-		JMP		(A0)					;														<11>
-
-moreChecks							;														<11>
-		MOVE.B	evtMessage+2(A3), D0	; Get the raw keycode
-		CMP.B	#$3F, D0				; Keyboard or Keypad?
-		blsOld							; Keyboard -- execute normally
-
-		LEA		14(SP), SP				; Clean off the stack
-		jmpROM	TrySysEvent				; Go where we are suppossed to
-		
-		endproc
-
-;————————————————————————————————————————————————————————————————————————————————————————————————————
-; Come-from patch on _GetResource inside GetNextEvent to honor ScrDmpEnb						<11>
-
-; The portable and IIci ROMS are fixed to do most of what KeypadFKEYInGetNextEvent does.  They only
-; require a fix to honor the ScrDmpEnable BOOLEAN in low-memory.
-
-CheckInhibitFKEYInGetNextEvent	ComeFromPatchProc	_GetResource,AfterGetResourceInTryFKey,(Portable,IIci)
-
-		TST.B	ScrDmpEnb				;	Check the ScrDmpEnb flag
-		bneOld							;	if it is not false, try to get the FKEY
-		MOVE.L	(SP)+, A0				;	otherwise, return NIL.
-		ADDQ.L	#6, SP
-		CLR.L	(SP)
-		JMP		(A0)
-		
-		endproc
-
-;————————————————————————————————————————————————————————————————————————————————————————————————————
-; GetOSEvent/OSEventAvail -- change ROM GetNextEvent to look for high level (PPC) events.
-; This code should be rolled inline into GetNextEvent.  We use comefrom patches for
-; convenience only.
-
-HLEAvail		ComeFromPatchProc		_OSEventAvail,AfterOSEventAvailInGetNextEvent,(Plus,SE,II,Portable,IIci)
-		import	shareHLEPatch:CODE
-
-; must look for OS events before we waste any more time
-		jsrOld									; call through
-		jmp		shareHLEPatch					; go share code		
-							
-		EndProc									; HLEAvail
-
-GetNextHLE		ComeFromPatchProc		_GetOSEvent,AfterGetOSEventInGetNextEvent,(Plus,SE,II,Portable,IIci)
-		entry	shareHLEPatch:CODE
-
-; must try to get OS events before we waste any more time
-		jsrOld									; call through
-
-shareHLEPatch
-		tst.w	EvtNum(a3)						; find something?
-		bne.s	Return							; if so, get out without further ado
-
-; no OS events.  Should we look for high-level events?
-		move.w	12(a6),d0						; get the caller's event mask
-		btst	#highLevelEvtBit,d0				; high-level events requested?
-		beq.s	ReturnFalse						; if not, just go on
-		move.w	WeKnowProcMgrExists,d0			; do we know whether OSDispatch is OK?
-		bne.s	CallGetHLEvent					; if so, go do it right now
-
-; We need to check for high level events.  Determine whether Process Mgr is around yet.
-		move.l	#gestaltOSAttr,d0				; Gestalt implemented by Process Mgr
-		_Gestalt								; ask about Process Mgr
-		blt.s	ReturnFalse						; exit now if we're still too early
-		lea		WeKnowProcMgrExists,a0			; get address of cheater flag
-		st		(a0)							; remember not to check again
-
-; Ask the Process Mgr for a high level event.
-CallGetHLEvent
-		clr.w	-(sp)							; allocate result storage
-		move.w	12(a6),-(sp)					; pass event mask
-		move.l	a3,-(sp)						; pass address of event record
-		tst.w 	d3								; EventAvail or GetNextEvent?
-		seq		-(sp)							; pass Boolean: GNE - true, EA - false
-		_GetNextHighLevelEvent					; call Processs Mgr
-		move.w	(sp)+,d0						; pop result
-Return
-		rts
-
-; Exit where we have to restore d0 to say “false”
-ReturnFalse
-		moveq	#0,d0							; say false
-		bra.s	Return							; joint exit
-
-; Flag whether we know Process Mgr exists
-WeKnowProcMgrExists	dc.w	0
-
-		EndProc									; GetNextHLE
-
-;————————————————————————————————————————————————————————————————————————————————————————————————————
-
 		end
-- 
2.18.0

