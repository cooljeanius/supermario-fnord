From: Horst Beepmanh <>
Subject: Source

---
--- a/Drivers/Video/TFBDriver.a
+++ b/Drivers/Video/TFBDriver.a
@@ -10,7 +10,6 @@
 ;	Change History (most recent first):
 ;
 ;	   <SM3>	 11/3/92	SWC		Changed SlotEqu.a->Slots.a and VideoEqu.a->Video.a.
-;		<SM2>	10/27/92	CSS		Changed some short branches to word branches.
 ;		 <8>	 8/21/91	JSM		Clean up header.
 ;		 <7>	  4/3/91	jmp		TFB registers are byte wide, but the TFB reset register was
 ;									being written to as a word.  So, I changed a Move.w to a Move.b
@@ -811,11 +810,11 @@ SetGamma										; <C522/15Dec86> DAF
 			MOVE.L	D0,A1							; get pointer to new gamma table
 
 			TST.L	GVersion(A1)					; version, type = 0?
-			BNE 	BadCtl							; => no, return error <SM2> CSS
+			BNE.S	BadCtl							; => no, return error
 			CMP		#8,GDataWidth(A1)				; is data width 8?
-			BNE 	BadCtl							; => no, return error <SM2> CSS
+			BNE.S	BadCtl							; => no, return error
 			CMP		#256,GDataCnt(A1)				; 256 values per channel?
-			BNE 	BadCtl							; => no, return error <SM2> CSS
+			BNE.S	BadCtl							; => no, return error
 
 ; if new table is different size, reallocate memory
 

--- a/Interfaces/AIncludes/AppleTalk.a
+++ b/Interfaces/AIncludes/AppleTalk.a
@@ -8,9 +8,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 1/29/93	RB		Change the SCCLockout value to 600 instead of 2600, because the
-;									other bits in the status register should remain unchanged for
-;									NewKernel.
 ;		<11>	  7/1/92	DCL		Obsoleted ATalkEqu.a which now includes this file.
 ;		<10>	 6/14/91	JL		Equated clientName and xppSubCode to $1C insteead of csCode
 ;									because csCode is in SysEqu.a which would have to be included.
@@ -134,9 +131,9 @@ crcErr			EQU 		-2
 underrunErr   	EQU 		-3
 lengthErr 		EQU 		-4
 ;
-; SCC interrupt priority		Should NEVER MOVE.W this value, just ORI.W						<SM2> rb
+; SCC interrupt priority
 ;
-sccLockout		EQU 		$600     				; This value works on both Mac and Lisa		<SM2> rb
+sccLockout		EQU 		$2600     				; This value works on both Mac and Lisa
 ;
 ;
 ;+ MPP (control calls to NBP, DDP and ABLAP)

--- a/Interfaces/AIncludes/GestaltEqu.a
+++ b/Interfaces/AIncludes/GestaltEqu.a
@@ -10,63 +10,13 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM26>	 12/2/93	JDR		updated gestaltFinderAttr, added gestaltQuickTimeFeatures
-;	  <SM25>	 11/8/93	JRH		Added gestaltPowerBookDuo250 and gestaltPowerBookDuo270C.
-;	  <SM24>	10/28/93	SAM		Roll in <MC4> from mc900ftjesus.
-;	   <MC4>	10/28/93	SAM		Changed gestaltNativeCPUtype equates (making each cpu type take
-;									a range of 256 per architecture).
-;	  <SM23>	10/14/93	pdw		Added 'scsi' selector and bits.
-;	  <SM22>	09-24-93	jmp		Rolled in various equates from the Excelsior sources.
-;	  <SM21>	 8/12/93	BG		Updated the MachineType list to be somewhere closer to current.
-;	  <SM20>	  8/4/93	JDR		synch with Sound Mgr project.
-;		<19>	  8/4/93	IH		#1101633,1098397,1101795,1101636,1102280 <KON>: Fix 1102280. Add
-;									CloseView and Display Manager gestalt selectors.
-;	  <SM18>	 6/23/93	CSS		Update from Reality:
-;		<67>	  6/9/93	DRF		#1087472: Add gestaltFinderSupports4GBVolumes and
-;									gestaltFinderHandlesCFMFailures to gestaltFinderAttr.
-;		<66>	  6/1/93	DTY		Standardize Icon Utilities selector name.
-;		<65>	 5/11/93	JMF		Added equates for gestaltKeyboardType for the Apple
-;									Adjustable Keyboard (ISO & US) & Keypad
-;		<64>	 4/27/93	KIP		Add gestalt16BitSoundIO, gestaltStereoInput and
-;									gestaltLineLevelInput selectors.
-;		<63>	 3/29/93	ash		Added gestalt attribute/selectors for Macintosh PC Exchange as
-;									well as additional selector for Translation Manager.
-;		<62>	 3/29/93	ngk		Add GestaltValue macros
-;		<61>	 3/19/93	mgl		Add gestaltFinderAttr for Finder attributes.
-;		<60>	  3/5/93	JDR		Added gestalt16BitAudioSupport.
-;		<59>	 2/26/93	hjcr	Add the gestaltBgndMouseDownSupport bit
-;		<58>	 1/18/93	ash		Add selectors for Macintosh Easy Open and Translation Manager
-;	  <SM17>	 6/14/93	kc		Roll in Ludwig.
-;	   <LW3>	 4/29/93	fau		Bug #1081636:  Update from Reality:  changed some of the
-;									gestaltSoundattr bit assignments and added some others.
-;	  <SM16>	  3/2/93	CSS		Update from Horror. Comments follow:
-;		<H4>	12/15/92	RLE		add more released machines
-;		<H3>	 6/16/92	SWC		Added gestaltAppleEventsAttr.
-;		<H2>	11/12/91	jmp		Just brought this file slightly more up-to-date than it was;
-;	  <SM15>	 2/11/93	SAM		Added EMMU emulated MMU type. (Hooray for change SM14 !!!)
-;     <SM14>	02/10/93	HY		Remove change <SM13>.
-;	  <SM13>	01/11/93	HY		Added bit gestaltNoAtlkSupport in the gestaltMiscAttr selector.
-;	  <SM12>	12/13/92	SAM		Added gestaltNativeCPUtype and gestaltSysArchitecture.  Cleaned
-;									up this file (what a mess!)
-;	   <SM11>	10/27/92	fau		Added a gestaltHasEnhancedLTtlk bit to gestaltHardwareAttr.
-;	   <SM10>	 7/29/92	CSS		Update from Reality:
-;									<57> 7/28/92 JDR	<DCL> Added Sound Mgr 3.0 flags.
-;	   <SM9>	 7/28/92	WS		add realtime manager attribute for gestalt call
-;	   <SM8)	 7/20/92	CSS		Remove information about soundhardware from this file 
-;									as JDR has put the same information into GestaltEquPriv.a.
-;	   <SM7>	 7/15/92	RB		Added the gestalt result for Classic hardware.
-;	   <SM6>	 7/14/92	RB		Added the selector and types associated with sound hardware.
-;	   <SM5>	 6/10/92	CSS		Roll-in Reality changes:	
-;									<56> 6/5/92	 DC		Add the selector for checking for the presence of icon
-;														utilities.
-;									<55> 6/2/92	 JSM	#1031451 <csd>: Add gestaltPowerBook145.
-;									<54> 5/27/92 KIP	#1030293,<JDR>: Add gestaltPlayAndRecord bit for sound
-;														attributes.
-;									<53> 5/27/92 DCL	Moved gestaltQuadra950 into the public consciousness.
-;	   <SM4>	 5/20/92	KW		Put in Pandora additions P2
-;	   <SM3>	 5/19/92	CS		fix header
-;	   <SM2>	 5/19/92	CS		Integrated changes from Reality:
-;									<52> 4/9/92 JSM #1026795,<DTY>: Add gestaltMacLCII.
+;		<56>	 6/5/92		DC		Add the selector for checking for the presence of icon
+;									utilities.
+;		<55>	 6/2/92		JSM		#1031451 <csd>: Add gestaltPowerBook145.
+;		<54>	 5/27/92	KIP		#1030293,<JDR>: Add gestaltPlayAndRecord bit for sound
+;									attributes.
+;		<53>	 5/27/92	DCL		Moved gestaltQuadra950 into the public consciousness.
+;		<52>	  4/9/92	JSM		#1026795,<DTY>: Add gestaltMacLCII.
 ;		<51>	  1/7/92	KST		Added gestaltTSMgrVersion.
 ;		<50>	 12/3/91	SAM		Moved 'hwdr' bits gestaltHasSCSI961 and gestaltHasSCSI962 here
 ;									from the private Gestalt equates.
@@ -203,11 +153,6 @@ gestaltAppleTalkVersion		EQU		'atlk'    		; AppleTalk version
 gestaltAUXVersion			EQU 	'a/ux'    		; a/ux version, if present
 gestaltAUXNotPresent		EQU		0
 
-gestaltCloseViewAttr		EQU		'BSDa'			; CloseView attributes
-
-gestaltCloseViewEnabled					EQU 0		; Closeview enabled (dynamic bit - returns current state)
-gestaltCloseViewDisplayMgrFriendly		EQU 1		; Closeview compatible with Display Manager (FUTURE)
-
 gestaltComponentMgr 		EQU		'cpnt'			; Component Mgr version
 
 gestaltTSMgrVersion			EQU		'tsmv'			; Text Services Mgr version, if present
@@ -218,19 +163,6 @@ gestaltConnMgrCMSearchFix	EQU		1				; do we have fix to CMAddSearch?
 gestaltConnMgrErrorString	EQU		2
 gestaltConnMgrMultiAsyncIO	EQU		3
 
-gestaltNativeCPUtype		EQU		'cput'			; The native CPU type			<SM12><MC4>
-	; 68000 Architecture
-gestaltCPU68000				EQU 	$000
-gestaltCPU68010				EQU 	$001
-gestaltCPU68020				EQU 	$002
-gestaltCPU68030				EQU 	$003
-gestaltCPU68040				EQU 	$004
-	; PowerPC Architecture
-gestaltCPU601				EQU		$101			; IBM 601
-gestaltCPU603				EQU		$103
-gestaltCPU604				EQU		$104
-
-
 gestaltCRMAttr				EQU		'crm '			; comm resource mgr attributes
 gestaltCRMPresent			EQU		0				
 gestaltCRMPersistentFix		EQU		1				; fix for persistent connections present
@@ -247,11 +179,6 @@ gestaltDictionaryMgrPresent	EQU		0				; Dictionary Manager attributes
 gestaltDITLExtAttr			EQU		'ditl'    		; AppenDITL, etc. calls from CTB
 gestaltDITLExtPresent		EQU		0     			; True if calls are present
 
-gestaltDisplayMgrAttr		EQU		'dply'			; Display Manager attributes
-gestaltDisplayMgrPresent 	EQU		 0				; True if Display Mgr is present
-
-gestaltDisplayMgrVers		EQU		'dplv'			; Display Manager version
-
 gestaltEasyAccessAttr		EQU 	'easy'    		; Easy Access attributes
 gestaltEasyAccessOff		EQU		0     			; if Easy Access present, but off (no icon)
 gestaltEasyAccessOn			EQU		1     			; if Easy Access "On"
@@ -260,21 +187,10 @@ gestaltEasyAccessLocked		EQU		3     			; if Easy Access "Locked"
 
 gestaltEditionMgrAttr		EQU 	'edtn'    		; Edition Mgr attributes
 gestaltEditionMgrPresent	EQU		0     			; True if Edition Mgr present
-gestaltEditionMgrTranslationAware	EQU		1		; True if edition manager is translation manager aware
-gestaltTranslationMgrHintOrder		EQU		1		; True if hint order reversal in effect 
 
 gestaltAppleEventsAttr		EQU		'evnt'    		; Apple Events attributes
 gestaltAppleEventsPresent	EQU		0     			; True if Apple Events present
 
-gestaltFinderAttr			EQU		'fndr'			; Finder attributes
-gestaltFinderDropEvent		EQU		0				; Finder recognizes drop event
-gestaltFinderMagicPlacement	EQU		1				; Finder supports magic icon placement
-gestaltFinderCallsAEProcess	EQU		2				; Finder calls AEProcessAppleEvent
-gestaltOSLCompliantFinder	EQU		3				; Finder is scriptable and recordable
-gestaltFinderSupports4GBVolumes	EQU		4			; Finder correctly handles 4GB volumes
-gestaltFinderHandlesCFMFailures	EQU		5			; Finder handles Code Fragment Manager errors
-gestaltFinderHasClippings	EQU		6				; Finder supports Drag Manager clipping files
-
 gestaltFindFolderAttr		EQU  	'fold'    		; FindFolder attributes
 gestaltFindFolderPresent	EQU		0     			; True if FindFolder present
 
@@ -307,7 +223,6 @@ gestaltHasSoftPowerOff		EQU		19				; Capable of software power off
 gestaltHasSCSI961			EQU		21				; 53C96 SCSI controller on internal bus	<50>
 gestaltHasSCSI962			EQU		22				; 53C96 SCSI controller on external bus	<50>
 gestaltHasUniversalROM		EQU		24				; Do we gots a Universal ROM?			<49>
-gestaltHasEnhancedLtalk		EQU		30				; Do we have Enhanced LocalTalk
 
 gestaltHelpMgrAttr			EQU		'help'    		; Help Mgr Attributes
 gestaltHelpMgrPresent		EQU 	0     			; true if help mgr is present
@@ -327,9 +242,6 @@ gestaltADBKbdII				EQU		10
 gestaltADBISOKbdII			EQU		11
 gestaltPwrBookADBKbd		EQU		12				; <49>
 gestaltPwrBookISOADBKbd		EQU		13				; <49>
-gestaltAppleAdjustKeypad	EQU		14				; <65>
-gestaltAppleAdjustADBKbd	EQU		15				; <65>
-gestaltAppleAdjustISOKbd	EQU		16				; <65>
 
 
 gestaltLowMemorySize		EQU  	'lmem'    		; size of low-memory area
@@ -346,7 +258,6 @@ gestaltAMU					EQU 	1     			; address management unit
 gestalt68851				EQU 	2     			; 68851 PMMU
 gestalt68030MMU				EQU 	3     			; 68030 built-in MMU
 gestalt68040MMU				EQU 	4     			; 68040 built-in MMU
-gestaltEMMU1				EQU		5				; Emulated MMU type 1 (Power PC systems)
 
 gestaltNotificationMgrAttr	EQU		'nmgr'   		; notification manager attributes
 gestaltNotificationPresent	EQU		0    			; notification manager exists
@@ -367,17 +278,12 @@ gestaltTempMemTracked		EQU 	6         		; temporary memory handles are tracked
 gestaltIPCSupport			EQU 	7         		; IPC support is present
 gestaltSysDebuggerSupport	EQU 	8         		; system debugger support is present
 ; gestaltSkiaGlobalsSwitched is #9. I don't know why it is not here
-gestaltBgndMouseDownSupport	EQU		10				; Background mouse down support is present
 
 
 gestaltOSTable				EQU		'ostt'			; OS trap table base
 gestaltToolboxTable			EQU		'tbtt'			; Toolbox trap table base
 gestaltExtToolboxTable		EQU		'xttt'			; Extended Toolbox trap table base
 
-gestaltPCXAttr 				EQU 	'pcxg'			; PC Exchange attributes
-gestaltPCXHas8and16BitFAT	EQU		0				; PC Exchange supports both 8 and 16 bit FATs
-gestaltPCXHasProDOS 		EQU		1				; PC Exchange supports ProDOS
-
 gestaltLogicalPageSize		EQU		'pgsz'    		; logical page size
 
 gestaltPowerMgrAttr			EQU   	'powr'        	; power manager attributes
@@ -426,12 +332,8 @@ gestaltHasColor				EQU		0				; color quickdraw present							<37>
 gestaltHasDeepGWorlds		EQU		1				; GWorlds can be deeper than 1-bit					<37>
 gestaltHasDirectPixMaps		EQU		2				; PixMaps can be direct (16 or 32 bit)				<37>
 gestaltHasGrayishTextOr		EQU		3				; supports text mode grayishTextOr					<37>
-gestaltSupportsMirroring	Equ		4				; Supports video mirroring via the Display Manager.
 
 gestaltPhysicalRAMSize		EQU		'ram '    		; physical RAM size
-gestaltRBVAddr				EQU		'rbv '			; RBV base address									<SM4>
-gestaltSCCReadAddr			EQU		'sccr'			; SCC read base address								<SM4>
-gestaltSCCWriteAddr			EQU		'sccw'			; SCC write base address							<SM4>
 
 gestaltPopupAttr			EQU		'pop!'			; popup cdef attributes
 gestaltPopupPresent			EQU		0
@@ -439,26 +341,11 @@ gestaltPopupPresent			EQU		0
 gestaltResourceMgrAttr		EQU		'rsrc'    		; Resource Mgr attributes
 gestaltPartialRsrcs			EQU   	0     			; True if partial resources exist
 
-gestaltRealtimeMgrAttr		EQU		'rtmr'			; Realtime manager attributes						<SM9> WS
-gestaltRealtimeMgrPresent	EQU		0				; true if Realtime manager is present				<SM9> WS  
-
-gestaltScrapMgrAttr				EQU		'scra'		; Scrap manager attributes
-gestaltScrapMgrTranslationAware	EQU		0			; True if scrap manager is translation manager aware
-
 gestaltScriptMgrVersion		EQU		'scri'    		; Script Manager version number 					<08/05/89 pke>
 gestaltScriptCount			EQU		'scr#'    		; number of active script systems					<08/05/89 pke>
 
-gestaltSlotAttr				EQU		'slot'			; slot manager attributes							<SM4>
-gestaltSlotMgrExists		EQU		0				; true if slot mgr exists							<SM4>
-gestaltNuBusPresent			EQU		1				; NuBus slots are present							<SM4>
-gestaltSESlotPresent		EQU		2				; SE PDS slot present								<SM4>
-gestaltSE30SlotPresent		EQU		3				; SE/30 slot present								<SM4>
-gestaltPortableSlotPresent	EQU		4				; Portable's slot present							<SM4>
-
 gestaltNuBusConnectors		EQU		'sltc'			; bitmap of slots with NuBus connectors				<26>
 
-gestaltFirstSlotNumber		EQU		'slt1'			; returns first physical slot						<SM4>
-
 gestaltSoundAttr			EQU		'snd '        	; sound attributes
 gestaltStereoCapability		EQU		0         		; sound hardware has stereo capability
 gestaltStereoMixing			EQU   	1         		; stereo mixing on external speaker
@@ -466,28 +353,15 @@ gestaltSoundIOMgrPresent	EQU		3				; The Sound I/O Manager is present
 gestaltBuiltInSoundInput	EQU		4				; built-in Sound Input hardware is present
 gestaltHasSoundInputDevice 	EQU		5				; Sound Input device available
 gestaltPlayAndRecord		EQU		6				; built-in hardware can play and record simultaneously
-gestalt16BitSoundIO			EQU		7				; sound hardware can play and record 16-bit samples
-gestaltStereoInput			EQU		8				; sound hardware can record stereo
-gestaltLineLevelInput		EQU		9				; sound input port requires line level
-													; the following bits are not defined prior to Sound Mgr 3.0
-gestaltSndPlayDoubleBuffer	EQU		10				; SndPlayDoubleBuffer available, set by Sound Mgr 3.0 and later
-gestaltMultiChannels		EQU		11				; multiple channel support, set by Sound Mgr 3.0 and later
-gestalt16BitAudioSupport	EQU		12				; 16 bit audio data supported, set by Sound Mgr 3.0 and later
 
 gestaltSpeechAttr 			EQU		'ttsc'			; Speech Manager attributes
 gestaltSpeechMgrPresent		EQU		0				; bit set indicates that Speech Manager exists
 
-gestaltSysArchitecture		EQU		'sysa'			; System architecture								<SM12>
-gestalt68k					EQU		1				; Motorola MC68k architecture
-gestaltPowerPC				EQU		2				; IBM PowerPC architecture
-
 gestaltStdNBPAttr			EQU		'nlup'			; standard nbp attributes
 gestaltStdNBPPresent		EQU		0
 
 gestaltStandardFileAttr				EQU		'stdf'  ; Standard File attributes
 gestaltStandardFile58				EQU   	0     	; True if selectors 5-8 (StandardPutFile-CustomGetFile) are supported
-gestaltStandardFileTranslationAware	EQU		1		; True if standard file is translation manager aware
-gestaltStandardFileHasColorIcons	EQU		2		; True if standard file has 16x16 color icons
 
 gestaltTextEditVersion		EQU		'te  '    		; TextEdit version number
 gestaltTE1					EQU 	1     			; TextEdit in MacIIci ROM
@@ -505,28 +379,16 @@ gestaltStandardTimeMgr		EQU		1         		; standard time mgr is present
 gestaltRevisedTimeMgr		EQU 	2         		; revised time mgr is present
 gestaltExtendedTimeMgr		EQU		3         		; extended time mgr is present
 
-gestaltVIA1Addr				EQU		'via1'			; VIA 1 base address								<SM4>
-gestaltVIA2Addr				EQU		'via2'			; VIA 2 base address								<SM4>
-
 gestaltVMAttr				EQU 	'vm  '    		; virtual memory attributes
 gestaltVMPresent			EQU 	0     			; virtual memory is present
 
-gestaltTranslationAttr		EQU		'xlat'			; Translation manager attributes
-gestaltTranslationMgrExists	EQU		0				; TRUE if translation manager exists
-
-gestaltIconUtilitiesAttr	EQU		'icon'			; Icon Utilities attributes
+gestaltIconUtilities		EQU		'icon'			; Icon Utilities attributes
 gestaltIconUtilitiesPresent	EQU		0				; true if icon utilities are present
 
 gestaltCompressionMgr		EQU		'icmp'			; returns version of the Image Compression Manager
 gestaltQuickTime			EQU		'qtim'			; returns version of QuickTime
-gestaltQuickTimeFeatures	EQU		'qtrs'			; return QuickTime features
 gestaltPPCQuickTimeLibPresent EQU	0
 
-gestaltSCSI 				EQU		'scsi'			; SCSI Manager attributes
-gestaltAsyncSCSI			EQU		0				; Supports Asynchronous SCSI 
-gestaltAsyncSCSIInROM		EQU		1				; Async scsi is in ROM (available for booting) 
-gestaltSCSISlotBoot			EQU		2				; This ROM supports Slot-style SCSI boots 
-
 
 **************************
 * Info-only Selectors
@@ -554,55 +416,14 @@ gestaltClassicII			EQU		23				; <49>
 gestaltPowerBook100			EQU		24				; <49>
 gestaltPowerBook140			EQU		25				; <49>
 gestaltQuadra950			EQU		26				; <53>
-gestaltMacLCIII				EQU		27				; <SM21>
-gestaltPowerBookDuo210		EQU		29				; <H4>
-gestaltCentris650			EQU		30				; <SM21>
-gestaltPowerBookDuo230		EQU		32				; <H4>
-gestaltPowerBook180			EQU		33				; <H4>
-gestaltPowerBook160			EQU		34				; <H4>
-gestaltQuadra800			EQU		35				; <SM21>
 gestaltMacLCII				EQU		37				; <52>
-gestaltPowerBookDuo250		EQU		38				; 
-gestaltMacIIvx				EQU		45				; <SM21>
-gestaltColorClassic			EQU		49				; <SM21>
-gestaltPowerbook180c		EQU		50				; <SM21>
-gestaltCentris610			EQU		52				; <SM21>
 gestaltPowerBook145			EQU		54				; <55>
-gestaltLC520				EQU		56				; <SM21>
-gestaltCentris660AV			EQU		60				; <SM21>
-gestaltQuadra660AV			EQU		gestaltCentris660AV; thank you, Ian Diery
-gestaltPowerBookDuo270C		EQU		77				; 
-gestaltQuadra840AV			EQU		78				; <SM21>
 
 gestaltMachineIcon			EQU		'micn'        	; machine icon
 
 gestaltROMSize				EQU 	'rom '        	; ROM size
 gestaltROMVersion			EQU 	'romv'        	; ROM version
 gestaltSystemVersion		EQU  	'sysv'    		; system version
-
-gestaltInternalDisplay		EQU		'idsp'			; slot number of internal display location
-
-	IF &TYPE('_NewGestaltValue') = 'UNDEFINED' THEN
-
-		MACRO
-		_NewGestaltValue
-			move.w		#$0401,d0
-			dc.w		$ABF1
-		ENDM
-
-		MACRO
-		_ReplaceGestaltValue
-			move.w		#$0402,d0
-			dc.w		$ABF1
-		ENDM
-
-		MACRO
-		_DeleteGestaltValue
-			move.w		#$0203,d0
-			dc.w		$ABF1
-		ENDM
-
-	ENDIF	; _NewGestaltValue
 	
 	
 	

--- a/Interfaces/AIncludes/SonyEqu.a
+++ b/Interfaces/AIncludes/SonyEqu.a
@@ -80,10 +80,22 @@ onMacPP   		EQU 		0
 onNuMac   		EQU 		0
   				ENDIF
 
+          IF      (&TYPE('onHafMac') = 'UNDEFINED') THEN
+onHafMac      EQU     0
+          ENDIF
+
   				IF  		(&TYPE('onHcMac') = 'UNDEFINED') THEN
 onHcMac   		EQU 		0
   				ENDIF
 
+          IF      (&TYPE('onMac16') = 'UNDEFINED') THEN
+onMac16       EQU     0
+          ENDIF
+
+          IF      (&TYPE('onMac32') = 'UNDEFINED') THEN
+onMac32       EQU     0
+          ENDIF
+
 ; forDiskDup should be set to 0 for most uses
 
   				IF  		(&TYPE('forDiskDup') = 'UNDEFINED') THEN
@@ -273,6 +285,8 @@ drive3			EQU 		drive2+drvLclLth  		; * real external for MacPP
 floppyLclEnd  	EQU 		drive3+drvLclLth
   				ELSEIF		onMac | onNuMac | onMac32 THEN
 floppyLclEnd  	EQU 		drive2+drvLclLth
+          ELSE
+floppyLclEnd EQU $99
   				ENDIF
 
 track 			EQU 		0         				; current track location (used for spd)

--- a/Interfaces/AIncludes/SysEqu.a
+++ b/Interfaces/AIncludes/SysEqu.a
@@ -6,13 +6,8 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	  9/9/93	pdw		Added SetOSPassword.
-;	   <SM4>	 4/20/93	CSS		Update from Reality:
-;									<34>	 3/30/93	JDR		Added ioMisc.
-;	   <SM3>	 11/10/92	CSS		Rollins from Reality:
-;									<33>	10/28/92	JDR		Added Time Manager task record.
-;	   <SM2>	 5/17/92	kc		Add selectors for the _MemoryDispatch trap.
-;                                   Add CacheFlags and bCopybackMode Equates.
+;		<34>	 3/30/93	JDR		Added ioMisc.
+;		<33>	10/28/92	JDR		Added Time Manager task record.
 ;		<32>	12/31/91	RB		Added new exception vectors from Terror.
 ;		<31>	10/28/91	SAM/KSM	Rolled in Regatta file.
 ;		
@@ -293,7 +288,6 @@ TheGDevice		EQU 		$0CC8 					; (long) the current graphics device
 CQDGlobals		EQU 		$0CCC 					; (long) quickDraw global extensions
 
 DeskCPat  		EQU 		$0CD8 					; [PixPatHandle] Handle to desk pixPat
-SetOSPassword	EQU			$0CDC					; (long) used as password by SetOSDefault (StartMgr)
 
 TimeVIADB 		EQU 		$0CEA 					; (word) number of iter's of VIA access & DBRA.	<1.3>
 VIA2	   		EQU 		$0CEC 					; VIA2 base address [pointer]					<2.7>
@@ -1045,11 +1039,6 @@ RAMBase   		EQU 		$2B2  					; RAM base address [pointer]
 SysVersion		EQU 		$15A  					; version # of RAM-based system [word]
 RndSeed   		EQU 		$156  					; random seed/number [long]
 
-; Cache-related stuff
-
-CacheFlags		EQU			$B72					; cache flags [byte]							<T9>
-bCopybackMode	EQU			7						; bit indicating cache mode on 68040			<T9>
-
 ; fields for _GetDefaultStartup: [DefStartRec]
 ; SlotDev:
 sdExtDevID		EQU 		$0    					; [byte]
@@ -1603,16 +1592,6 @@ size				EQU			*			; minimum size of table
 defaultSize			EQU			size + (MemoryBlock.size * defaultPhysicalEntryCount)
 					ENDR
 
-; selectors for the _MemoryDispatch trap
-holdMemory			EQU			0			; selector for _HoldMemory
-unholdMemory		EQU			1			; selector for _UnholdMemory
-lockMemory			EQU			2			; selector for _LockMemory
-lockMemoryContiguous EQU		4			; selector for _LockMemoryContiguous
-unlockMemory		EQU			3			; selector for _UnlockMemory
-getPhysical			EQU			5			; selector for _GetPhysical
-getReal				EQU			6			; selector for _GetReal call
-getPageDesc			EQU			7			; selector for _GetPageDesc call
-
 ;___________________________________________________________________________
 ;
 

--- a/Interfaces/AIncludes/Traps.a
+++ b/Interfaces/AIncludes/Traps.a
@@ -9,9 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM18>	 9/13/93	SAM		Removed the 24bit conds around the removate of SwapMMUMode,
-;									StripAddress, and Translate24to32.  I also removed all the
-;									redefinitions of Translate24to32 throughout the sources.
 ;	  <SMG2>	  9/1/93	chp		Took out _DMAIntInstall again. No one needs it now.
 ;	  <SM16>	 7/21/93	RC		back out <sm 15>
 ;	  <SM14>	 6/14/93	kc		Roll in Ludwig. (leave behind _DMAIntInstall for SAM)
@@ -2110,18 +2107,10 @@ _HGetState		OPWORD  	$A069
 _HSetState		OPWORD  	$A06A
 _InitFS   		OPWORD  	$A06C
 _InitEvents   	OPWORD  	$A06D
-
-	Macro							; SuperMario is a 32-bit only ROM
-	_SwapMMUMode
-	EndM
-	Macro							; SuperMario is a 32-bit only ROM
-	_StripAddress
-	EndM
-	Macro							; SuperMario is a 32-bit only ROM
-	_Translate24To32
-	EndM
-
+_StripAddress 	OPWORD  	$A055
+_Translate24To32 OPWORD  	$A091
 _SetAppBase   	OPWORD  	$A057
+_SwapMMUMode  	OPWORD  	$A05D
 _SlotVInstall 	OPWORD  	$A06F
 _SlotVRemove  	OPWORD  	$A070
 _AttachVBL		OPWORD  	$A071

--- a/Interfaces/CIncludes/Desk.h
+++ b/Interfaces/CIncludes/Desk.h
@@ -45,7 +45,7 @@ Created: Saturday, July 27, 1991 at 2:53 PM
 enum {
 
  accEvent = 64,
- accRun = 65,
+// accRun = 65,
  accCursor = 66,
  accMenu = 67,
  accUndo = 68,

--- /dev/null
+++ b/Interfaces/PInterfaces/Sound.p
@@ -0,0 +1,455 @@
+
+{
+Created: Monday, December 2, 1991 at 5:09 PM
+ Sound.p
+ Pascal Interface to the Macintosh Libraries
+
+  Copyright Apple Computer, Inc. 1986-1991
+  All rights reserved
+}
+
+
+{$IFC UNDEFINED UsingIncludes}
+{$SETC UsingIncludes := 0}
+{$ENDC}
+
+{$IFC NOT UsingIncludes}
+ UNIT Sound;
+ INTERFACE
+{$ENDC}
+
+{$IFC UNDEFINED UsingSound}
+{$SETC UsingSound := 1}
+
+{$I+}
+{$SETC SoundIncludes := UsingIncludes}
+{$SETC UsingIncludes := 1}
+{$IFC UNDEFINED UsingTypes}
+{$I $$Shell(PInterfaces)Types.p}
+{$ENDC}
+{$IFC UNDEFINED UsingFiles}
+{$I $$Shell(PInterfaces)Files.p}
+{$ENDC}
+{$SETC UsingIncludes := SoundIncludes}
+
+CONST
+swMode = -1;								{ Sound Driver modes }
+ftMode = 1;
+ffMode = 0;
+
+synthCodeRsrc = 'snth';						{ Resource types used by Sound Manager }
+soundListRsrc = 'snd ';
+
+twelfthRootTwo = 1.05946309434;
+rate22khz = $56EE8BA3;						{ 22254.54545 in fixed-point }
+rate11khz = $2B7745D1;						{ 11127.27273 in fixed-point }
+
+{ synthesizer numbers for SndNewChannel }
+squareWaveSynth = 1;						{square wave synthesizer}
+waveTableSynth = 3;							{wave table synthesizer}
+sampledSynth = 5;							{sampled sound synthesizer}
+
+{ old Sound Manager MACE synthesizer numbers }
+MACE3snthID = 11;
+MACE6snthID = 13;
+
+{ command numbers for SndDoCommand and SndDoImmediate }
+nullCmd = 0;
+initCmd = 1;
+freeCmd = 2;
+quietCmd = 3;
+flushCmd = 4;
+reInitCmd = 5;
+
+waitCmd = 10;
+pauseCmd = 11;
+resumeCmd = 12;
+callBackCmd = 13;
+syncCmd = 14;
+emptyCmd = 15;
+
+tickleCmd = 20;
+requestNextCmd = 21;
+howOftenCmd = 22;
+wakeUpCmd = 23;
+availableCmd = 24;
+versionCmd = 25;
+totalLoadCmd = 26;
+loadCmd = 27;
+
+scaleCmd = 30;
+tempoCmd = 31;
+
+freqDurationCmd = 40;
+restCmd = 41;
+freqCmd = 42;
+ampCmd = 43;
+timbreCmd = 44;
+getAmpCmd = 45;
+
+waveTableCmd = 60;
+phaseCmd = 61;
+
+soundCmd = 80;
+bufferCmd = 81;
+rateCmd = 82;
+continueCmd = 83;
+doubleBufferCmd = 84;
+getRateCmd = 85;
+
+sizeCmd = 90;
+convertCmd = 91;
+
+stdQLength = 128;
+dataOffsetFlag = $8000;
+
+waveInitChannelMask = $07;
+waveInitChannel0 = $04;
+waveInitChannel1 = $05;
+waveInitChannel2 = $06;
+waveInitChannel3 = $07;
+
+{ channel initialization parameters }
+initPanMask = $0003;						{ mask for right/left pan values }
+initSRateMask = $0030;						{ mask for sample rate values }
+initStereoMask = $00C0;						{ mask for mono/stereo values }
+initCompMask = $FF00;						{ mask for compression IDs }
+
+initChanLeft = $0002;						{ left stereo channel }
+initChanRight = $0003;						{ right stereo channel }
+initNoInterp = $0004;						{ no linear interpolation }
+initNoDrop = $0008;							{ no drop-sample conversion }
+initMono = $0080;							{ monophonic channel }
+initStereo = $00C0;							{ stereo channel }
+initMACE3 = $0300;							{ MACE 3:1 }
+initMACE6 = $0400;							{ MACE 6:1 }
+
+initChan0 = $0004;							{ channel 0 - wave table only }
+initChan1 = $0005;							{ channel 1 - wave table only }
+initChan2 = $0006;							{ channel 2 - wave table only }
+initChan3 = $0007;							{ channel 3 - wave table only }
+
+stdSH = $00;								{ Standard sound header encode value }
+extSH = $FF;								{ Extended sound header encode value }
+cmpSH = $FE;								{ Compressed sound header encode value }
+
+notCompressed = 0;							{ compression ID's }
+twoToOne = 1;
+eightToThree = 2;
+threeToOne = 3;
+sixToOne = 4;
+
+outsideCmpSH = 0;							{ MACE constants }
+insideCmpSH = 1;
+aceSuccess = 0;
+aceMemFull = 1;
+aceNilBlock = 2;
+aceBadComp = 3;
+aceBadEncode = 4;
+aceBadDest = 5;
+aceBadCmd = 6;
+sixToOnePacketSize = 8;
+threeToOnePacketSize = 16;
+stateBlockSize = 64;
+leftOverBlockSize = 32;
+
+firstSoundFormat = $0001;					{ general sound format }
+secondSoundFormat = $0002;					{ special sampled sound format (HyperCard) }
+
+dbBufferReady = $00000001;					{ double buffer is filled }
+dbLastBuffer = $00000004;					{ last double buffer to play }
+
+sysBeepDisable = $0000;						{ SysBeep() enable flags }
+sysBeepEnable = $0001;
+
+unitTypeNoSelection = $FFFF;				{ unitTypes for AudioSelection.unitType }
+unitTypeSeconds = $0000;
+
+TYPE
+{   Structures for Sound Driver   }
+
+
+FreeWave = PACKED ARRAY [0..30000] OF Byte;
+
+FFSynthPtr = ^FFSynthRec;
+FFSynthRec = RECORD
+ mode: INTEGER;
+ count: Fixed;
+ waveBytes: FreeWave;
+ END;
+
+Tone = RECORD
+ count: INTEGER;
+ amplitude: INTEGER;
+ duration: INTEGER;
+ END;
+
+
+Tones = ARRAY [0..5000] OF Tone;
+
+SWSynthPtr = ^SWSynthRec;
+SWSynthRec = RECORD
+ mode: INTEGER;
+ triplets: Tones;
+ END;
+
+
+Wave = PACKED ARRAY [0..255] OF Byte;
+WavePtr = ^Wave;
+
+FTSndRecPtr = ^FTSoundRec;
+FTSoundRec = RECORD
+ duration: INTEGER;
+ sound1Rate: Fixed;
+ sound1Phase: LONGINT;
+ sound2Rate: Fixed;
+ sound2Phase: LONGINT;
+ sound3Rate: Fixed;
+ sound3Phase: LONGINT;
+ sound4Rate: Fixed;
+ sound4Phase: LONGINT;
+ sound1Wave: WavePtr;
+ sound2Wave: WavePtr;
+ sound3Wave: WavePtr;
+ sound4Wave: WavePtr;
+ END;
+
+FTSynthPtr = ^FTSynthRec;
+FTSynthRec = RECORD
+ mode: INTEGER;
+ sndRec: FTSndRecPtr;
+ END;
+
+{   Structures for Sound Manager   }
+
+SndCommand = PACKED RECORD
+ cmd: INTEGER;
+ param1: INTEGER;
+ param2: LONGINT;
+ END;
+
+
+Time = LONGINT;								{ in half milliseconds }
+
+
+
+SndChannelPtr = ^SndChannel;
+SndChannel = PACKED RECORD
+ nextChan: SndChannelPtr;
+ firstMod: Ptr;								{ reserved for the Sound Manager }
+ callBack: ProcPtr;
+ userInfo: LONGINT;
+ wait: Time;								{ The following is for internal Sound Manager use only.}
+ cmdInProgress: SndCommand;
+ flags: INTEGER;
+ qLength: INTEGER;
+ qHead: INTEGER;							{ next spot to read or -1 if empty }
+ qTail: INTEGER;							{ next spot to write = qHead if full }
+ queue: ARRAY [0..stdQLength - 1] OF SndCommand;
+ END;
+
+{ MACE structures }
+StateBlockPtr = ^StateBlock;
+StateBlock = RECORD
+ stateVar: ARRAY [0..stateBlockSize - 1] OF INTEGER;
+ END;
+
+LeftOverBlockPtr = ^LeftOverBlock;
+LeftOverBlock = RECORD
+ count: LONGINT;
+ sampleArea: PACKED ARRAY [0..leftOverBlockSize - 1] OF Byte;
+ END;
+
+ModRef = RECORD
+ modNumber: INTEGER;
+ modInit: LONGINT;
+ END;
+
+SndListPtr = ^SndListResource;
+SndListResource = RECORD
+ format: INTEGER;
+ numModifiers: INTEGER;
+ modifierPart: ARRAY [0..0] OF ModRef;		{This is a variable length array}
+ numCommands: INTEGER;
+ commandPart: ARRAY [0..0] OF SndCommand;	{This is a variable length array}
+ dataPart: PACKED ARRAY [0..0] OF Byte;		{This is a variable length array}
+ END;
+
+SoundHeaderPtr = ^SoundHeader;
+SoundHeader = PACKED RECORD
+ samplePtr: Ptr;							{ if NIL then samples are in sampleArea }
+ length: LONGINT;							{ length of sound in bytes }
+ sampleRate: Fixed;							{ sample rate for this sound }
+ loopStart: LONGINT;						{ start of looping portion }
+ loopEnd: LONGINT;							{ end of looping portion }
+ encode: Byte;								{ header encoding }
+ baseFrequency: Byte;						{ baseFrequency value }
+ sampleArea: PACKED ARRAY [0..0] OF Byte;
+ END;
+
+CmpSoundHeaderPtr = ^CmpSoundHeader;
+CmpSoundHeader = PACKED RECORD
+ samplePtr: Ptr;							{ if nil then samples are in sample area }
+ numChannels: LONGINT;						{ number of channels i.e. mono = 1 }
+ sampleRate: Fixed;							{ sample rate in Apples Fixed point representation }
+ loopStart: LONGINT;						{ loopStart of sound before compression }
+ loopEnd: LONGINT;							{ loopEnd of sound before compression }
+ encode: Byte;								{ data structure used , stdSH, extSH, or cmpSH }
+ baseFrequency: Byte;						{ same meaning as regular SoundHeader }
+ numFrames: LONGINT;						{ length in frames ( packetFrames or sampleFrames ) }
+ AIFFSampleRate: Extended80;				{ IEEE sample rate }
+ markerChunk: Ptr;							{ sync track }
+ futureUse1: Ptr;							{ reserved by Apple }
+ futureUse2: Ptr;							{ reserved by Apple }
+ stateVars: StateBlockPtr;					{ pointer to State Block }
+ leftOverSamples: LeftOverBlockPtr;			{ used to save truncated samples between compression calls }
+ compressionID: INTEGER;					{ 0 means no compression, non zero means compressionID }
+ packetSize: INTEGER;						{ number of bits in compressed sample packet }
+ snthID: INTEGER;							{ resource ID of Sound Manager snth that contains NRT C/E }
+ sampleSize: INTEGER;						{ number of bits in non-compressed sample }
+ sampleArea: PACKED ARRAY [0..0] OF Byte;	{ space for when samples follow directly }
+ END;
+
+ExtSoundHeaderPtr = ^ExtSoundHeader;
+ExtSoundHeader = PACKED RECORD
+ samplePtr: Ptr;							{ if nil then samples are in sample area }
+ numChannels: LONGINT;						{ number of channels,  ie mono = 1 }
+ sampleRate: Fixed;							{ sample rate in Apples Fixed point representation }
+ loopStart: LONGINT;						{ same meaning as regular SoundHeader }
+ loopEnd: LONGINT;							{ same meaning as regular SoundHeader }
+ encode: Byte;								{ data structure used , stdSH, extSH, or cmpSH }
+ baseFrequency: Byte;						{ same meaning as regular SoundHeader }
+ numFrames: LONGINT;						{ length in total number of frames }
+ AIFFSampleRate: Extended80;				{ IEEE sample rate }
+ markerChunk: Ptr;							{ sync track }
+ instrumentChunks: Ptr;						{ AIFF instrument chunks }
+ AESRecording: Ptr;
+ sampleSize: INTEGER;						{ number of bits in sample }
+ futureUse1: INTEGER;						{ reserved by Apple }
+ futureUse2: LONGINT;						{ reserved by Apple }
+ futureUse3: LONGINT;						{ reserved by Apple }
+ futureUse4: LONGINT;						{ reserved by Apple }
+ sampleArea: PACKED ARRAY [0..0] OF Byte;	{ space for when samples follow directly }
+ END;
+
+ConversionBlockPtr = ^ConversionBlock;
+ConversionBlock = RECORD
+ destination: INTEGER;
+ unused: INTEGER;
+ inputPtr: CmpSoundHeaderPtr;
+ outputPtr: CmpSoundHeaderPtr;
+ END;
+
+SMStatusPtr = ^SMStatus;
+SMStatus = PACKED RECORD
+ smMaxCPULoad: INTEGER;
+ smNumChannels: INTEGER;
+ smCurCPULoad: INTEGER;
+ END;
+
+SCStatusPtr = ^SCStatus;
+SCStatus = RECORD
+ scStartTime: Fixed;
+ scEndTime: Fixed;
+ scCurrentTime: Fixed;
+ scChannelBusy: BOOLEAN;
+ scChannelDisposed: BOOLEAN;
+ scChannelPaused: BOOLEAN;
+ scUnused: BOOLEAN;
+ scChannelAttributes: LONGINT;
+ scCPULoad: LONGINT;
+ END;
+
+AudioSelectionPtr = ^AudioSelection;
+AudioSelection = PACKED RECORD
+ unitType: LONGINT;
+ selStart: Fixed;
+ selEnd: Fixed;
+ END;
+
+SndDoubleBufferPtr = ^SndDoubleBuffer;
+SndDoubleBuffer = PACKED RECORD
+ dbNumFrames: LONGINT;
+ dbFlags: LONGINT;
+ dbUserInfo: ARRAY [0..1] OF LONGINT;
+ dbSoundData: PACKED ARRAY [0..0] OF Byte;
+ END;
+
+SndDoubleBufferHeaderPtr = ^SndDoubleBufferHeader;
+SndDoubleBufferHeader = PACKED RECORD
+ dbhNumChannels: INTEGER;
+ dbhSampleSize: INTEGER;
+ dbhCompressionID: INTEGER;
+ dbhPacketSize: INTEGER;
+ dbhSampleRate: Fixed;
+ dbhBufferPtr: ARRAY [0..1] OF SndDoubleBufferPtr;
+ dbhDoubleBack: ProcPtr;
+ END;
+
+
+FUNCTION SndDoCommand(chan: SndChannelPtr;cmd: SndCommand;noWait: BOOLEAN): OSErr;
+ INLINE $A803;
+FUNCTION SndDoImmediate(chan: SndChannelPtr;cmd: SndCommand): OSErr;
+ INLINE $A804;
+FUNCTION SndNewChannel(VAR chan: SndChannelPtr;synth: INTEGER;init: LONGINT;
+ userRoutine: ProcPtr): OSErr;
+ INLINE $A807;
+FUNCTION SndDisposeChannel(chan: SndChannelPtr;quietNow: BOOLEAN): OSErr;
+ INLINE $A801;
+FUNCTION SndPlay(chan: SndChannelPtr;sndHdl: Handle;async: BOOLEAN): OSErr;
+ INLINE $A805;
+FUNCTION SndAddModifier(chan: SndChannelPtr;modifier: ProcPtr;id: INTEGER;
+ init: LONGINT): OSErr;
+ INLINE $A802;
+FUNCTION SndControl(id: INTEGER;VAR cmd: SndCommand): OSErr;
+ INLINE $A806;
+
+PROCEDURE SetSoundVol(level: INTEGER);
+PROCEDURE GetSoundVol(VAR level: INTEGER);
+PROCEDURE StartSound(synthRec: Ptr;numBytes: LONGINT;completionRtn: ProcPtr);
+PROCEDURE StopSound;
+FUNCTION SoundDone: BOOLEAN;
+
+FUNCTION SndSoundManagerVersion: NumVersion;
+ INLINE $203C,$000C,$0008,$A800;
+FUNCTION SndStartFilePlay(chan: SndChannelPtr;fRefNum: INTEGER;resNum: INTEGER;
+ bufferSize: LONGINT;theBuffer: Ptr;theSelection: AudioSelectionPtr;theCompletion: ProcPtr;
+ async: BOOLEAN): OSErr;
+ INLINE $203C,$0D00,$0008,$A800;
+FUNCTION SndPauseFilePlay(chan: SndChannelPtr): OSErr;
+ INLINE $203C,$0204,$0008,$A800;
+FUNCTION SndStopFilePlay(chan: SndChannelPtr;async: BOOLEAN): OSErr;
+ INLINE $203C,$0308,$0008,$A800;
+FUNCTION SndChannelStatus(chan: SndChannelPtr;theLength: INTEGER;theStatus: SCStatusPtr): OSErr;
+ INLINE $203C,$0010,$0008,$A800;
+FUNCTION SndManagerStatus(theLength: INTEGER;theStatus: SMStatusPtr): OSErr;
+ INLINE $203C,$0014,$0008,$A800;
+PROCEDURE SndGetSysBeepState(VAR sysBeepState: INTEGER);
+ INLINE $203C,$0018,$0008,$A800;
+FUNCTION SndSetSysBeepState(sysBeepState: INTEGER): OSErr;
+ INLINE $203C,$001C,$0008,$A800;
+FUNCTION SndPlayDoubleBuffer(chan: SndChannelPtr;theParams: SndDoubleBufferHeaderPtr): OSErr;
+ INLINE $203C,$0020,$0008,$A800;
+
+FUNCTION MACEVersion: NumVersion;
+ INLINE $203C,$0000,$0010,$A800;
+PROCEDURE Comp3to1(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$0004,$0010,$A800;
+PROCEDURE Exp1to3(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$0008,$0010,$A800;
+PROCEDURE Comp6to1(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$000C,$0010,$A800;
+PROCEDURE Exp1to6(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$0010,$0010,$A800;
+
+
+{$ENDC} { UsingSound }
+
+{$IFC NOT UsingIncludes}
+ END.
+{$ENDC}
+

--- /dev/null
+++ b/Interfaces/PInterfaces/Sound.p.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file

--- a/Internal/Asm/AppleDeskBusPriv.a
+++ b/Internal/Asm/AppleDeskBusPriv.a
@@ -11,16 +11,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM3>	 7/7/92		CSS		Remove includes to ApplDeskBusPriv.a and roll changes
-;									from that file into this one:
-;	  								<SM1> 5/2/92	kc		Roll in Horror. Comments follow:
-;		 							<2>	  8/5/91	SC		Added new bits to the PMGR ADB flags.
-;									Updated from Reality:
-;		 							<6>	 4/24/92	JF		Added comment to let everyone know that one of three unused
-;									l						ongs in ADBVars is now being used.
-;	   <SM2>	 5/25/92	RB		Commented out the definition of talkCmd and listenCmd since they
-;									are also defined in EgretEqu.a, which seems to be included
-;									everywhere.
 ;		 <5>	 8/21/91	JSM		Clean up header.
 ;		 <4>	 1/30/91	gbm		sab, #38: Change the ‘already including this file’ variable to
 ;									all uppercase (for security reasons)
@@ -48,8 +38,8 @@ __INCLUDINGAPPLEDESKBUSPRIV__	SET	1
 
 maskADBCmd		EQU			$0C					; Mask for ADB command
 resetCmd		EQU			$00					; Command for Bus Reset
-; <SM2> rb	talkCmd   		EQU 		$0C   				; Command for Talk R0
-; <SM2> rb	listenCmd 		EQU 		$08   				; Command for Listen R0 
+talkCmd   		EQU 		$0C   				; Command for Talk R0
+listenCmd 		EQU 		$08   				; Command for Listen R0 
 kbdAddr   		EQU 		$02   				; keyboard type device 
 mouseAddr 		EQU 		$03   				; mouse type device 
 numFDBAdr 		EQU 		16   				; number of avaiblae FDB address 
@@ -62,8 +52,6 @@ Flags			ds.b	1				; modifier/status flags (bit definitions below)
 NoReply			equ		1				; flag for 'command timed out'
 SRQReq			equ		2				; int flag for 'device requesting service'
 SetPollEnables	equ		5				; Update auto-enable bit mask from ADBData field	<1.4>
-PollEnable		equ		6				; enable auto polling and auto srq polling
-ExplicitCmd		equ		7				; message contains an explicit cmd
 
 DataCount		ds.b	1				; number of bytes of ADBData (0..8) (cmd not included)
 ADBCmd			ds.b	1				; ADB command to send / command that replied
@@ -128,7 +116,7 @@ hasDev			ds.w	1	    			; every bit corresponds to an device address
 devMap			ds.w	1	  				; device address map (2 bytes)
 
 				ds.l	1					; unused space												<6>
-				ds.l	1					; •• Now Used! ••  Pointer to Extended ADB Data (4 bytes)	<6>
+				ds.l	1					; unused space												<6>
 				ds.l	1					; unused space												<6>
 				
 fDBCmd			ds.b	1		  			; last fDB command (1 byte)

--- a/Internal/Asm/Decompression.a
+++ b/Internal/Asm/Decompression.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		 <1>	 4/14/92	stb		first checked in
-;		<19>	 4/14/91	stb		<sm1>stb Add to SuperMario project for use by ResourceMgr.a.  Corrected some speling.
 ;		<18>	  7/9/91	JSM		No need to define SysVers here.
 ;		<17>	 1/30/91	gbm		sab, #38: Change the name of one of the decompressor header
 ;									files (because Sheila said it was okay)
@@ -195,7 +193,7 @@ maxReplacement		EQU	6		;end of substitution list.
 ;
 ;---------------------------------------------------------------------------------
 ExtendedResource	Record	0
-signature			DS.L	1		;used for robustness.  Tells if data is compressed now.
+signiture			DS.L	1		;used for robustness.  Tells if data is compressed now.
 headerLength		DS.W	1		;length of this header in bytes.
 headerVersion		DS.B	1		;number of items in this header. ( must be < 128 ).
 extendedAttributes	DS.B	1		;extension to the attributes for this resource.

--- a/Internal/Asm/DialogsPriv.a
+++ b/Internal/Asm/DialogsPriv.a
@@ -31,8 +31,6 @@
 	IF &TYPE('__INCLUDINGDIALOGSPRIV__') = 'UNDEFINED' THEN
 __INCLUDINGDIALOGSPRIV__	SET	1
 
-	IF forROM OR TheFuture THEN
-
 	; format of globals in emDialogGlobals
 
 DialogMgrGlobals	record	0
@@ -43,8 +41,6 @@ SavedMenuState		ds.l	1
 DialogMgrGlobalsSize equ	*
 					endr
 
-	ENDIF						; forROM OR TheFuture
-
 ; bits for flag byte
 cannotTwitchOutOfDialogBit		EQU 7
 systemHandlesMenusBit			EQU	6

--- a/Internal/Asm/GestaltPrivateEqu.a
+++ b/Internal/Asm/GestaltPrivateEqu.a
@@ -165,8 +165,8 @@ size			equ		*
 				ENDR
 
 GestaltGlobals	RECORD	0
+longH
 tableH			ds.l	1						; handle to table of longs
-slotsUsed		ds.l	1						; number of entries in table
 maxSlots		ds.l	1						; number of entries in table
 memSize			ds.l	1						; amount of memory in this machine
 realTop			ds.l	1						; adjusted memory size

--- a/Internal/Asm/HardwarePrivateEqu.a
+++ b/Internal/Asm/HardwarePrivateEqu.a
@@ -8,40 +8,10 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM30>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
-;									machines
-;	  <SM29>	11/16/93	SAM		Added an eieio macro for use on systems that have non serialized
-;									i/o space.  Basically, the macro will expand to a 68k NOP if
-;									"forNonSerializedIO" is set to true.
-;	  <SM28>	 11/9/93	KW		added eieioSTP macro.  When forSTP601 is defined as True, a 68k
-;									nop instruction will be added.  Emulator turns 68k nop into
-;									eieio.  Only effects the CygnusX1 ROM
 ;	  <SM27>	  8/4/93	JDR		private sound defines are in SoundPrivate.a
-;	  <SM26>	 7/20/93	SAM		Fixed the ROMHeader record.  Added the fields the SuperMario
-;									guys forgot to add to the end of the structure.
-;	  <SM25>	 7/14/93	RC		Added BART nubus controller register defs for PDM and Cold
-;									Fusion
-;	  <SM24>	  5/6/93	SAM		More generic AMIC stuff.
-;	  <SM23>	 4/22/93	SAM		Added some general AMIC equates (for PDM).
 ;	  <SM22>	 3/31/93	chp		Synchronize SuperMario with changes from <LW2>.
 ;	   <LW2>	 2/24/93	chp		Added equates for the PSC wait/request multiplexer control bits
 ;									in VIA1.
-;	  <SM21>	01-12-93	jmp		Added in the CSC equates.
-;	  <SM20>	 12/4/92	SWC		Added ascPlayRecA to the ASC equates.
-;	  <SM19>	 12/1/92	EH		Added Pratt Memory controller equates and Via1 equates for
-;									Blackbird.
-;	  <SM18>	 11/6/92	rab		Roll in Horror changes. Comments follow:
-;	   <H28> 	10/12/92	BG		Added symbolic constants for refering to the CPU ID bits that
-;									describe CPU_SPEED and CPU_ID values for Wombat/WLCD/Vail040.
-;	   <H27>	  9/6/92	jab		Added SCSI configuration info for BIOS.
-;	   <H26>	 8/25/92	BG		Added definitions for BIOS configuration registers.
-;	  <SM17>	10/27/92	fau		Added a YMCABase to the YMCA equ's.
-;	  <SM16>	 9/30/92	fau		Added a couple of constants for YMCA register sizes to aid in
-;									the SizeMem programming;  renamed a couple of YMCA registers to
-;									something better.
-;	  <SM15>	 9/16/92	WS		Fix bug change / to _
-;	  <SM14>	 9/16/92	WS
-;	  <SM14>	 9/15/92	gjs		Added the YMCA equates for EVT-4.
 ;	  <SM13>	 8/17/92	CCH		Bumped HeapStart to $2800.
 ;	  <SM12>	  8/7/92	JDB		Changed Singer control register to have 0 for the output
 ;									attenuation and  5 for the input gain.
@@ -217,6 +187,43 @@
 __INCLUDINGHARDWAREPRIVATEEQU__	SET	1
 
 
+  				IF  		(&TYPE('onMac') = 'UNDEFINED') THEN 
+onMac 			EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onMacPP') = 'UNDEFINED') THEN
+onMacPP   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onNuMac') = 'UNDEFINED') THEN
+onNuMac   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onHafMac') = 'UNDEFINED') THEN
+onHafMac   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onHcMac') = 'UNDEFINED') THEN
+onHcMac   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onMac16') = 'UNDEFINED') THEN
+onMac16   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onMac32') = 'UNDEFINED') THEN
+onMac32   		EQU 		0
+  				ENDIF
+
+onAnything		EQU 		onMac|onMacPP|onHcMac|onHafMac|onNuMac|onMac16|onMac32
+
+
+; *** If HWNonPortable is defined to be non-zero, Then a machine type must be specified!
+; *** If a machine is specified, HWNonPortable must be non-zero, specified or not.
+  				IF  		(&TYPE('HWNonPortable') = 'UNDEFINED') THEN
+HWNonPortable 	EQU 		onAnything
+  				ENDIF
+
 
 ;__________________________________________________________________________________________
 ;
@@ -584,43 +591,6 @@ setIopRun		equ			(1<<iopRun)|\			; start iop running
 
 
 
-;__________________________________________________________________________________________
-;
-;
-; The STP card has problems when accessing VIA's if the 601 instruction 'eieio' is not
-; not used to force in order execution. Macro expands to nop only when conditional build
-; flag forSTP601 is defined as TRUE.  The 68k nop instruction is turned into an eieio
-; instruction by the emulator.
-;__________________________________________________________________________________________
-
-	MACRO
-	eieioSTP	; do nop if forSTP601 is set, emulator does eieio for 68k nop
-		if forSTPnop then
-			nop								; force write to complete
-		endif
-	ENDM
-
-
-;__________________________________________________________________________________________ <SAM>
-; Enforce In-order Execution of I/O.
-;
-; This macro is for use on systems that have non-serialized memory-mapped I/O.
-; It will order loads and stores ensuring that all previous storage accesses
-; previously initiated by the processor are complete with respect to main storage.
-;
-; The macro will expand only if the build conditional "hasSerializedIO" is true.  It will
-; expand to a 68K "NOP" which the V0 emulator translates to a PowerPC "eieio" instrucion.
-;__________________________________________________________________________________________
-	MACRO
-	eieio									; do nop if nonSerializedIO is set
-		if nonSerializedIO then
-			nop								; force writes to complete
-		endif
-	ENDM
-
-
-
-
 ;__________________________________________________________________________________________
 ;
 ;
@@ -651,7 +621,7 @@ vPCR  			EQU 		$1800 					; PERIPH. CONTROL REG.
 vIFR  			EQU 		$1A00 					; INT. FLAG REG.
 vIER  			EQU 		$1C00 					; INT. ENABLE REG.
 vBufA 			EQU 		$1E00 					; BUFFER A
-vBufD 			EQU 		vBufA 					; disk head select is buffer A			<3.5>
+;(see below) vBufD 			EQU 		vBufA 					; disk head select is buffer A			<3.5>
 
 ;---------------------------------------------------
 ; VIA IFR/IER bits
@@ -671,51 +641,49 @@ ifIRQ 			EQU 		7 						; any interrupt
 ; VIA1 Port A definitions
 ;---------------------------------------------------
 
-vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+;(see below) vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
 
-vTestJ			EQU 		0 						; Burn In Test jumper		(input)
+;(see below) vTestJ			EQU 		0 						; Burn In Test jumper		(input)
 
-vCpuId0			EQU			1						; CPU Identification bit 0	(input)
-vCpuId1			EQU			2						; CPU Identification bit 1	(input)
-vSync 			EQU 		3 						; Synchronous modem
-vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
-vCpuId2			EQU			4						; CPU Identification bit 2
+;(see below) vCpuId0			EQU			1						; CPU Identification bit 0	(input)
+;(see below) vCpuId1			EQU			2						; CPU Identification bit 1	(input)
+;(see below) vSync 			EQU 		3 						; Synchronous modem
+;(see below) vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+;(see below) vCpuId2			EQU			4						; CPU Identification bit 2
 vReqAEnable		EQU			4						; enable ReqA into vSCCWrReq (PSC only)		<LW2>
-vHeadSel  		EQU 		5 						; head select line for Sony
-vCpuId3			EQU			6						; CPU Identification bit 3
-vRev8Bd   		EQU 		6 						; =0 for rev 8 board>
+;(see below) vHeadSel  		EQU 		5 						; head select line for Sony
+;(see below) vCpuId3			EQU			6						; CPU Identification bit 3
+;(see below) vRev8Bd   		EQU 		6 						; =0 for rev 8 board>
 vReqBEnable		EQU			6						; enable ReqB into vSCCWrReq (PSC only)		<LW2>
-vSCCWrReq 		EQU 		7 						; SCC write/request line
+;(see below) vSCCWrReq 		EQU 		7 						; SCC write/request line
 
 ;---------------------------------------------------
 ; VIA1 Port B definitions
 ;---------------------------------------------------
 
 vEclipseLED		EQU			0						; flashable Eclipse LED (how quaint!)		<23>
-vRTCData  		EQU 		0 						; real time clock data
+;(see below) vRTCData  		EQU 		0 						; real time clock data
 vRMP0			EQU			0						; Reserved for RMP (PSC only)
-vENetIDClk		EQU			0						; Ethernet ID ROM clock	for Whitney			<SM19>
-vRTCClk   		EQU 		1 						; real time clock clock pulses
+;(see below) vRTCClk   		EQU 		1 						; real time clock clock pulses
 vRMP1			EQU			1						; Reserved for RMP (PSC only)
-vENetIDData   	EQU 		1 						; Ethernet ID ROM clock	for Whitney			<SM19>
-vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+;(see below) vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
 vRMP2			EQU			2						; Reserved for RMP (PSC only)
-vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+;(see below) vFDBInt   		EQU 		3 						; Front Desk bus interrupt
 vXcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
 vSDMCable		EQU			3						; SCSI DiskMode cable sense for Dartanian	<H15>
 vCudaTREQ		EQU			3						; Cuda transaction request input		<P2><SM4> rb
 vSDMDiskID		EQU			4						; DiskMode HD ID (bits 4-6) for Dartanian	<H15>
-vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+;(see below) vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
 vViafullbit		EQU			4						; Egret via full bit					<6>
 vCudaBYTEACK	EQU			4						; Cuda byte acknowledge output			<P2><SM4> rb
-vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+;(see below) vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
 vSyssesbit		EQU			5						; Egret system session bit				<6><SM4> rb
 vCudaTIP		EQU			5						; Cuda interface transaction in progress output <P2>
 vAUXIntEnb 		EQU 		6 						; switch to A/UX interrupt scheme (output)	<23>
-vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
+;(see below) vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
 vJMPDude6		EQU			6						; Reserved for JMP (PSC only)
-vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
-vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+;(see below) vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
+;(see below) vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
 vSWInt	  		EQU 		7 						; cause a software interrupt	(output)	<23>
 vJMPDude7		EQU			7						; Reserved for JMP (PSC only)
 
@@ -1138,9 +1106,7 @@ DAFB_CRB3			EQU			$3C				; vRAM Color Register, bank 3
 Swatch_BaseOffset	EQU			$100			; Swatch offset from DAFBBase
 Swatch_BaseOffset1	EQU			$124			; parameter offset
 Swatch_ParmSize1	EQU			$12				; size of Swatch parameter list
-; ••• This number is off by 2, we think.  BG/NJV
-; Swatch_NumRegs		Equ			30				; Number of Swatch registers.
-Swatch_NumRegs		Equ			28				; Number of Swatch registers.
+Swatch_NumRegs		Equ			30				; Number of Swatch registers.
 
 Swatch_Mode			EQU			$100			; Swatch general control
 Swatch_IntMsk		EQU			$104			; Swatch interrupt control
@@ -1188,7 +1154,6 @@ ACDC_ParmSize		EQU			$1				; size of ACDC parameter list
 ;----------
 
 Clk_BaseOffset		EQU			$300			; National offset from DAFBBase
-Clk_ChipIntOffset	EQU			$C0				; Clock Chip Interface offset from National offset from DAFBBase <H33>
 Clk_ParmSize		EQU			$10 			; size of National parameter list
 Clk_ParmSize1		Equ			$0A				; (Once programmed, the last six bytes are always the same.)
 
@@ -1217,44 +1182,6 @@ GSCDiag0			Equ		$1D						; Undocumented “diagnostic” registers.
 GSCDiag1			Equ		$1E
 GSCDiag2			Equ		$1F
 
-;----------
-; CSC register definitions (offsets from VDACAddr in ProductInfo) ($50F2 0000)					<H30> jmp
-;----------
-CSCDeviceID			Equ		$00						; Device revision register; read only.
-CSCPanelID			Equ		$02						; “Senseline” register; read only.
-CSCPanelIDControl	Equ		$04						; Extended senseline control.
-CSCPanelType		Equ		$06						; Controls mono/color, size, etc….
-CSCPanelSetup		Equ		$08						; Controls polarity, power, etc….
-CSCDataOutputForm	Equ		$0A						; Controls datapath output type.
-CSCFRCControl		Equ		$0C						; “DAC” control from CLUT for panel.
-CSCPolyMAdj			Equ		$0E						; M adjustment for FRC.
-CSCPolyNAdj			Equ		$10						; N adjustment for FRC.
-CSCDisplayDataForm	Equ		$12						; 1,2,4,8,16 bpp.
-CSCDisplayStatus	Equ		$14						; IFR,IER,blanking.
-CSCRefreshRate		Equ		$16						; Controls refresh cycles per scanline.
-CSCVRAMControl		Equ		$18						; Controls VRAM clocking.
-CSCHSkewHi			Equ		$1A						; Effectively, controls the horizontal
-CSCHSkewLo			Equ		$1C						;	timing.
-CSCACDClkHi			Equ		$1E						; Effectively, controls the dot-clock
-CSCACDClkLo			Equ		$20						; 	timing.
-CSCVSkewHi			Equ		$22						; Effectively, control the vertical
-CSCVSkewLo			Equ		$24						; 	timing.
-CSCMemConfig		Equ		$26						; Controls addressing for type of VRAM.
-CSCLPStart			Equ		$28						; Controls start of timing diagram.
-CSCLPWidth			Equ		$2A						; Controls width of timing diagram.
-CSCFLMControl		Equ		$2C						; What does this do?
-
-CSCFrstReg			Equ		CSCPanelType			; First CSC register we need to save/restore.
-CSCLastReg			Equ		CSCFLMControl+2			; Last  CSC register we need to save/restore.
-CSCNumRegs			Equ		((CSCLastReg-CSCFrstReg)/2) ; Total number of registers to save/restore.
-
-CSCGTweak			Equ		$3C						; For “tweaking” the gray-only panels.
-
-CSCAddrRegW			Equ		$40						; Sets the index of the NEXT Palette Write.
-CSCAddrRegR			Equ		$46						; Sets the index of the NEXT Palette Read.
-CSCDataReg			Equ		$42						; Accessed as an R-G-B tripple into the Palette.
-
-CSCMaskReg			Equ		$44						; Logically masks out video data; set to all $F's.
 
 ;----------
 ; Sonora register definitions (offsets from SonoraAddr in ProductInfo) ($50F0 0000)				<H4><H6>
@@ -1285,17 +1212,6 @@ SonoraSetClr	Equ			7						; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
 ;
 SonoraVBLIRQEn	Equ			6						; Enable/Disable built-in video VBL
 
-;----------
-; Additional register definitions implemented in the Ardbeg variation of the Sonora chip		<HK4><H31> thru next <H31>
-;----------
-
-ArdbegPwr		EQU			$00A					; Ardbeg chip Power Management register
-
-;----------
-; Power Management register bit definitions
-;----------
-ArdbegPwrSaver	EQU 		0						; 1=Monitor power saver mode enabled (monitor power is off) <H31>
-
 ;----------
 ; Ariel register definitions (offsets from VDACAddr in ProductInfo) ($50F2 4000)				<H6>
 ;----------
@@ -1304,33 +1220,7 @@ ArielDataReg	Equ			1						; Offset to r/w data register
 ArielConfigReg	Equ			2						; Offset to r/w control register
 ArielKeyReg		Equ			3						; Offset to r/w key color register
 
-;----------
-; FIFO Memory Definitions for Whitney/Hardrock machines
-;----------
-FIFOMEM_BASE	Equ			$50F24000				; Logical address assignment for base of FIFO's
-FIFO_0_OFFSET	Equ			(16*1024)
-FIFO_1_OFFSET	Equ			(32*1024)
-FIFO_2_OFFSET	Equ			(48*1024)
 
-;----------
-; Whitney register definitions <ged>
-;----------
-
-WhitneyPwrCtl	Equ			$50F96000				; Whitney power control register
-WhitneyRev		Equ			$50F96004				; Whitney revision register
-
-;----------
-; Whitney power register bit definitions 														<K4>
-;----------
-
-WhitneySCCclk	equ			7						; 1 = SCC pClk forced low
-WhitneyInt3En	equ			6						; 1 = MDM_IRQ_L causes level 3 interrupt
-WhitneySWIMclk	equ			5						; 1 = Swim clock forced low
-WhitneySWIMReset equ		4						; 0 = reset SWIM chip
-WhitneyKEYclk	equ			3						; 1 = KEY_C16 forced low
-WhitneySCCpwr	equ			2						; 1 = power off serial driver chip
-WhitneyEnetReset equ		1						; 0 = reset SONIC chip
-WhitneyEnetPwr	equ			0						; 1 = power off Sonic chip
 ;----------
 ; MMC register definitions (offsets from MMCAddr in ProductInfo) ($50F3 0400)				<P2><SM4> rb, start
 ;----------
@@ -1365,135 +1255,6 @@ MMC_ClockSelect	EQU			$48						; Endeavor Input Clock Select (NTSC/PAL) [M18].
 
 MMC_Bypass		EQU			$4C						; RGB or Composite bypass [M19].
 
-;----------
-; YMCA register definitions (offsets from YMCAAddr in ProductInfo) ($50F3 0400)			<SM16> fau, start
-;----------
-YMCABase		EQU			$50F30400				; Used in YMCASizeBank 'cause we ran out of registers.  <SM17>
-YMCAMaxSize		EQU			5						; Maximum value that can be programed into the size registers
-BankBdryRegSize	EQU			7						; Size in bits of the boundary registers
-BankSizeRegSize	EQU			3						; Size in bits of the size register
-
-YMCA_DRAMspeed0	EQU			$00						; DRAM timing register 0 [M0].
-YMCA_DRAMspeed1	EQU			$04						; DRAM timing register 1 [M1].
-
-YMCA_CPUspeed0	EQU			$08						; Clock speed 0 [M2].
-YMCA_CPUspeed1	EQU			$0C						; Clock speed 1 [M3].
-
-YMCA_ROMspeed0	EQU			$10						; ROM cycle time 0 [M4].
-YMCA_ROMspeed1	EQU			$14						; ROM cycle time 1 [M5].
-YMCA_ROMspeed2	EQU			$18						; ROM cycle time 2 [M6].
-
-YMCA_DSPspeed	EQU			$1C						; DSP clock speed [M7].
-
-YMCA_DRAMwidth0	EQU			$20						; DRAM width 0 [M8].
-YMCA_DRAMwidth1	EQU			$24						; DRAM width 1 [M9].
-YMCA_DRAMwidth2	EQU			$28						; DRAM width 2 [M10].
-YMCA_DRAMwidth3	EQU			$2C						; DRAM width 3 [M11].
-
-YMCA_EPROMmode	EQU			$30						; EPROM mode [M12].
-
-YMCA_040Mode	EQU			$34						; 040 Special Mode [M13].
-
-YMCA_CPUID0		EQU			$38						; CPU ID 0 [M14].
-YMCA_CPUID1		EQU			$3C						; CPU ID 1 [M15].
-YMCA_CPUID2		EQU			$40						; CPU ID 2 [M16].
-YMCA_CPUID3		EQU			$44						; CPU ID 3 [M17].
-
-YMCA__ClockSelect	EQU		$48						; Endeavor Input Clock Select [M18].
-YMCA_Bypass 		EQU		$4C						; Composite out or RGB [M19].
-
-YMCA_DRAMBank0_A20 EQU		$50						; DRAM Bank0 Addr A20 [M20].
-YMCA_DRAMBank0_A21 EQU		$54						; DRAM Bank0 Addr A21 [M21].
-YMCA_DRAMBank0_A22 EQU		$58						; DRAM Bank0 Addr A22 [M22].
-YMCA_DRAMBank0_A23 EQU		$5C						; DRAM Bank0 Addr A23 [M23].
-YMCA_DRAMBank0_A24 EQU		$60						; DRAM Bank0 Addr A24 [M24].
-YMCA_DRAMBank0_A25 EQU		$64						; DRAM Bank0 Addr A25 [M25].
-YMCA_DRAMBank0_A26 EQU		$68						; DRAM Bank0 Addr A26 [M26].
-YMCA_DRAMBank0_Sz0 EQU		$6C						; DRAM Bank0 Size 0   [M27].
-YMCA_DRAMBank0_Sz1 EQU		$70						; DRAM Bank0 Size 1   [M28].
-YMCA_DRAMBank0_Sz2 EQU		$74						; DRAM Bank0 Size 2   [M29].
-
-YMCA_DRAMBank1_A20 EQU		$78						; DRAM Bank1 Addr A20 [M30].
-YMCA_DRAMBank1_A21 EQU		$7C						; DRAM Bank1 Addr A21 [M31].
-YMCA_DRAMBank1_A22 EQU		$80						; DRAM Bank1 Addr A22 [M32].
-YMCA_DRAMBank1_A23 EQU		$84						; DRAM Bank1 Addr A23 [M33].
-YMCA_DRAMBank1_A24 EQU		$88						; DRAM Bank1 Addr A24 [M34].
-YMCA_DRAMBank1_A25 EQU		$8C						; DRAM Bank1 Addr A25 [M35].
-YMCA_DRAMBank1_A26 EQU		$90						; DRAM Bank1 Addr A26 [M36].
-YMCA_DRAMBank1_Sz0 EQU		$94						; DRAM Bank1 Size 0   [M37].
-YMCA_DRAMBank1_Sz1 EQU		$98						; DRAM Bank1 Size 1   [M38].
-YMCA_DRAMBank1_Sz2 EQU		$9C						; DRAM Bank1 Size 2   [M39].
-
-YMCA_DRAMBank2_A20 EQU		$A0						; DRAM Bank2 Addr A20 [M40].
-YMCA_DRAMBank2_A21 EQU		$A4						; DRAM Bank2 Addr A21 [M41].
-YMCA_DRAMBank2_A22 EQU		$A8						; DRAM Bank2 Addr A22 [M42].
-YMCA_DRAMBank2_A23 EQU		$AC						; DRAM Bank2 Addr A23 [M43].
-YMCA_DRAMBank2_A24 EQU		$B0						; DRAM Bank2 Addr A24 [M44].
-YMCA_DRAMBank2_A25 EQU		$B4						; DRAM Bank2 Addr A25 [M45].
-YMCA_DRAMBank2_A26 EQU		$B8						; DRAM Bank2 Addr A26 [M46].
-YMCA_DRAMBank2_Sz0 EQU		$BC						; DRAM Bank2 Size 0   [M47].
-YMCA_DRAMBank2_Sz1 EQU		$C0						; DRAM Bank2 Size 1   [M48].
-YMCA_DRAMBank2_Sz2 EQU		$C4						; DRAM Bank2 Size 2   [M49].
-
-YMCA_DRAMBank3_A20 EQU		$C8						; DRAM Bank3 Addr A20 [M50].
-YMCA_DRAMBank3_A21 EQU		$CC						; DRAM Bank3 Addr A21 [M51].
-YMCA_DRAMBank3_A22 EQU		$D0						; DRAM Bank3 Addr A22 [M52].
-YMCA_DRAMBank3_A23 EQU		$D4						; DRAM Bank3 Addr A23 [M53].
-YMCA_DRAMBank3_A24 EQU		$D8						; DRAM Bank3 Addr A24 [M54].
-YMCA_DRAMBank3_A25 EQU		$DC						; DRAM Bank3 Addr A25 [M55].
-YMCA_DRAMBank3_A26 EQU		$E0						; DRAM Bank3 Addr A26 [M56].
-YMCA_DRAMBank3_Sz0 EQU		$E4						; DRAM Bank3 Size 0   [M57].
-YMCA_DRAMBank3_Sz1 EQU		$E8						; DRAM Bank3 Size 1   [M58].
-YMCA_DRAMBank3_Sz2 EQU		$EC						; DRAM Bank3 Size 2   [M59].
-
-YMCA_DRAMBank4_A20 EQU		$F0						; DRAM Bank4 Addr A20 [M60].
-YMCA_DRAMBank4_A21 EQU		$F4						; DRAM Bank4 Addr A21 [M61].
-YMCA_DRAMBank4_A22 EQU		$F8						; DRAM Bank4 Addr A22 [M62].
-YMCA_DRAMBank4_A23 EQU		$FC						; DRAM Bank4 Addr A23 [M63].
-YMCA_DRAMBank4_A24 EQU		$100					; DRAM Bank4 Addr A24 [M64].
-YMCA_DRAMBank4_A25 EQU		$104					; DRAM Bank4 Addr A25 [M65].
-YMCA_DRAMBank4_A26 EQU		$108					; DRAM Bank4 Addr A26 [M66].
-YMCA_DRAMBank4_Sz0 EQU		$10C					; DRAM Bank4 Size 0   [M67].
-YMCA_DRAMBank4_Sz1 EQU		$110					; DRAM Bank4 Size 1   [M68].
-YMCA_DRAMBank4_Sz2 EQU		$114					; DRAM Bank4 Size 2   [M69].
-
-YMCA_DRAMBank5_A20 EQU		$118					; DRAM Bank5 Addr A20 [M70].
-YMCA_DRAMBank5_A21 EQU		$11C					; DRAM Bank5 Addr A21 [M71].
-YMCA_DRAMBank5_A22 EQU		$120					; DRAM Bank5 Addr A22 [M72].
-YMCA_DRAMBank5_A23 EQU		$124					; DRAM Bank5 Addr A23 [M73].
-YMCA_DRAMBank5_A24 EQU		$128					; DRAM Bank5 Addr A24 [M74].
-YMCA_DRAMBank5_A25 EQU		$12C					; DRAM Bank5 Addr A25 [M75].
-YMCA_DRAMBank5_A26 EQU		$130					; DRAM Bank5 Addr A26 [M76].
-YMCA_DRAMBank5_Sz0 EQU		$134					; DRAM Bank5 Size 0   [M77].
-YMCA_DRAMBank5_Sz1 EQU		$138					; DRAM Bank5 Size 1   [M78].
-YMCA_DRAMBank5_Sz2 EQU		$13C					; DRAM Bank5 Size 2   [M79].
-
-YMCA_DRAMBank6_A20 EQU		$140					; DRAM Bank6 Addr A20 [M80].
-YMCA_DRAMBank6_A21 EQU		$144					; DRAM Bank6 Addr A21 [M81].
-YMCA_DRAMBank6_A22 EQU		$148					; DRAM Bank6 Addr A22 [M82].
-YMCA_DRAMBank6_A23 EQU		$14C					; DRAM Bank6 Addr A23 [M83].
-YMCA_DRAMBank6_A24 EQU		$150					; DRAM Bank6 Addr A24 [M84].
-YMCA_DRAMBank6_A25 EQU		$154					; DRAM Bank6 Addr A25 [M85].
-YMCA_DRAMBank6_A26 EQU		$158					; DRAM Bank6 Addr A26 [M86].
-YMCA_DRAMBank6_Sz0 EQU		$15C					; DRAM Bank6 Size 0   [M87].
-YMCA_DRAMBank6_Sz1 EQU		$160					; DRAM Bank6 Size 1   [M88].
-YMCA_DRAMBank6_Sz2 EQU		$164					; DRAM Bank1 Size 2   [M89].
-
-YMCA_DRAMBank7_A20 EQU		$168					; DRAM Bank7 Addr A20 [M90].
-YMCA_DRAMBank7_A21 EQU		$16C					; DRAM Bank7 Addr A21 [M91].
-YMCA_DRAMBank7_A22 EQU		$170					; DRAM Bank7 Addr A22 [M92].
-YMCA_DRAMBank7_A23 EQU		$174					; DRAM Bank7 Addr A23 [M93].
-YMCA_DRAMBank7_A24 EQU		$178					; DRAM Bank7 Addr A24 [M94].
-YMCA_DRAMBank7_A25 EQU		$17C					; DRAM Bank7 Addr A25 [M95].
-YMCA_DRAMBank7_A26 EQU		$180					; DRAM Bank7 Addr A26 [M96].
-YMCA_DRAMBank7_Sz0 EQU		$184					; DRAM Bank7 Size 0   [M97].
-YMCA_DRAMBank7_Sz1 EQU		$188					; DRAM Bank7 Size 1   [M98].
-YMCA_DRAMBank7_Sz2 EQU		$18C					; DRAM Bank7 Size 2   [M99].
-
-YMCA_Test_Mode 		EQU		$190					; Enable Test Mode    [M100].
-YMCA_Refresh_Test   EQU		$194					; Refresh Test Mode   [M101].
-
-;													;											<SM16> fau, end
 ;----------
 ; MUNI (NuBus) register definitions																<P6>
 ;----------
@@ -1633,7 +1394,7 @@ MSCFlashWrEnb	EQU			$23						; flash ROM write enable
 MSCPowerCycle	EQU			$50FA0000-$50F26000		; CPU power off control register			<H2>
 
 ;  ======  VIA2 BufferB Equivalent		Address: $50F26000	 =====
-MSCEnableFPU	EQU			0						; 0 = enable on-board floating point processor	<H29>
+MSCExpansion	EQU			0						; 0 = enable on-board external cache (not currently used)
 ;v2PMack		EQU 		1 						; Power manager handshake acknowledge
 ;v2PMreq		EQU 		2 						; Power manager handshake request
 ;reserved3		EQU			3						; reserved
@@ -1722,84 +1483,6 @@ MSCDefConfig	EQU			(1<<MSC25MHz)|\			; 25MHz system								<H9>
 							(%000<<MSCSize0)		; set 2MB so there's real RAM for BootBeep	<H10>
 
 
-BIOSAddr		EQU			$50F18000				; verified by hasBIOSAddr in ExtValid		<H26><SM18>
-
-BIOS_Config		EQU			0						; contains bit 0:  0 = BCLK ≥ 33MHz			<H26>
-													;                  1 = BCLK ≤ 25MHz			<H26>
-BIOS_SONIC_SCSI	EQU			$200					; contains SONIC and SCSI parameters		<H26>
-BIOSSCSIFilter	EQU			$40						; bit 6 = SONIC stuff, all the rest are SCSI<H31>
-													; (bit 7 in BIOS is undefined)				<H31>
-BIOScfg20MHz	EQU			$1B						; 3-clk PDMA Write and Read 				<H27><SM18>
-BIOScfg25MHz	EQU			$3F						; 3-clk PDMA Write and Read/DRQCHK on		<H27><SM18>
-BIOScfg33MHz	EQU			$12						; 4-clk PDMA Write and Read 				<H27><SM18>
-BIOScfg40MHz	EQU			$00						; 5-clk PDMA Write and Read					<H27><SM18>
-
-BIOS_REVISION	EQU			$300					; bits 5:7 is BIOS revision number			<H26>
-bBIOSW1Cmplt	EQU			$2						; bit positions...			 				<H27>
-bBIOSR1Cmplt	EQU			$1						;					 						<H27>
-bBIOSSCSIBERR	EQU			$0						;						 					<H27>
-
-BIOS_PDMA		EQU			$300					; bits 0:2 are Pseudo-DMA control bits		<H26>
-BIOS_SCSI_RESID	EQU			$400					; bits 0:16 are latched SCSI data			<H26>
-BIOS_BRIGHTNESS	EQU			$500					; 8 bits of 0-$FF brightness				<H31>
-BIOS_CONTRAST	EQU			$501					; 8 bits of 0-$FF contrast					<H31>
-BIOS_Timeout	EQU			$600					; bits 0:11 are watchdog timer timeout cntr	<H26>
-
-BIOS_Config2	EQU			$100					; for Primus/Optimus bios					<H35>
-bBIOSBR30116BIT	EQU			$0						; bit positions...							<H35>
-bBIOSIOCSTime	EQU			$1						;											<H35>
-bBIOSENETIRQLVL	EQU			$2						;											<H35>
-
-;__________________________________________________________________________________________		<SM23> SAM
-;	AMIC (Apple Memory mapped I/O Controller) Creative name huh? Equates
-;	First used on PDM/Cold Fusion
-;__________________________________________________________________________________________
-
-AMICBase		EQU			$50F30000				; AMIC base
-AMICDMABase		EQU			$50F31000				; DMA Buffer Base Address (256k alignment)
-AMICSCSIDMABase	EQU			$0000					; SCSI DMA Buffer Base Address [scsi has its own buffer] (8 byte alignment)
-
-AMICSCSICntrl	EQU			$1008					; SCSI DMA control register
-
-AMICEnetTxCntrl	EQU			$0C20					; Ethernet transmit DMA control register
-AMICEnetRxCntrl	EQU			$1028					; Ethernet receive DMA control register
-
-AMICFloppyCntrl	EQU			$1068					; Floppy DMA control register
-
-AMICSCCTxACntrl	EQU			$1088					; SCC port A transmit DMA control register
-AMICSCCRxACntrl	EQU			$1098					; SCC port A receive DMA control register
-
-AMICSCCTxBCntrl	EQU			$10A8					; SCC port B transmit DMA control register
-AMICSCCRxBCntrl	EQU			$10B8					; SCC port B receive DMA control register
-
-AMICIrqBase		EQU			$50F2A000				; AMIC's interrupt register base
-AMICIrqFlags	EQU			$0000					; Interrupt source register
-AMICDMAFlags0	EQU			$0008					; DMA interrupt source register
-AMICDMAFlags1	EQU			$000A					; DMA interrupt source register
-
-PDMrbvSize 		EQU			768*1024				; 768k for RBV							<SM24>
-PDMDMAbufSize	EQU			160*1024				; 160k for the DMA buffer
-PDMDMAlogAddr	EQU			$61000000				; Logical address of the DMA buffer
-
-;__________________________________________________________________________________________
-;	BART (PDM/Cold Fusion NuBus Controller) Equates
-;	First used on PDM/Cold Fusion
-;__________________________________________________________________________________________
-BARTBase		EQU			$F0000000				; BART Register Base
-
-BARTResetReg	EQU			$F0000000				; bit zero of this register will reset NuBus
-BARTResetBit	EQU			$0
-
-BARTSlowReg		EQU			$F0000001				; Setting bit 8 will add wait states
-BARTSlowBit		EQU			$8
-
-BARTOffSltE		EQU			$F0000011				; Setting bit 8 will cause slot E to be disabled (for Cold Fusion)
-BARTOFFBit		EQU			$8
-
-BARTBurstReg	EQU			$80						; Offset from base to slot zero burst reg (not actually used directly)
-BARTBurstRegOff	EQU			$08						; Offset from Busrt Reg to next slot Reg ($80, $78, $70, $68 ... $10)
-BARTBurstBit	EQU			$8
-
 
 ;__________________________________________________________________________________________
 ;
@@ -1992,56 +1675,6 @@ NiagraFlashEnbl	EQU			$30000					; Enable flash from Niagra
 NiagraFPUAcc	EQU			$34000					; FPU access detected
 NiagraSpeedReg	EQU			$36000					; Returns the CPU clock frequency
 
-;---------------------------------------------------
-; Pratt Memory Controller Equates
-;---------------------------------------------------
-
-PrattChipID		EQU			$5ffffff8				; Pratt ID register address (chip version)		CSR0
-PrattSysStat	EQU			$0007					; CPU speed	register offset						CSR1								
-PrattROMSpeed	EQU			$000B					; ROM speed register offset						CSR2
-PrattRAMDensity	EQU			$000F					; RAM density register offset					CSR3
-PrattRAMConfig	EQU			$0013					; RAM configuration register offset				CSR4
-PrattRefresh	EQU			$0017					; RAM refresh register offset					CSR5
-PrattNapReg		EQU			$001B					; PowerCycling enable register offset			CSR6
-PrattVersion	EQU			$001F					; Unused register offset (always reads zero)	CSR7
-
-													;CSR1 System Status Register
-Pratt16MHzCPU	EQU			%00000000				; CPU speed reg config values (bits 0:1)
-Pratt20MHzCPU	EQU			%00000001				; 
-Pratt25MHzCPU	EQU			%00000010				; 
-Pratt33MHzCPU	EQU			%00000011				;
-PrattFlashLBit	EQU			2						; bit position for Flash detection (0 = Flash is present)
-PrattROMBit		EQU			3						; bit position for ROM boot (1 = ROM in system)
-
-Pratt250nsROM	EQU			%00000000				;CSR2 ROM speed reg config values
-Pratt200nsROM	EQU			%00000001				;
-Pratt150nsROM	EQU			%00000010				;
-Pratt120nsROM	EQU			%00000011				;
-
-													;CSR3/4 RAM sizing bit definitions
-PrattDensBits	EQU			%00001111				; bit mask showing active density config bits
-PrattBankBits	EQU			%00111111				; bit mask showing active bank occupancy bits
-PrattDefDensity	EQU			%00000111				; Default RAM Density value for Pratt (all 8MB banks)
-PrattDefConfig	EQU			%00111111				; Default RAM Bank Configuration for Pratt (all banks occupied)		
-PrattNumbanks	EQU			6						; Total number of RAM banks, onboard plus expansion
-
-Pratt0MBbank	EQU			%11111100				; Onboard RAM bank bit masks 
-Pratt2MBbank	EQU			%11111110
-Pratt4MBbank	EQU			%11111101
-Pratt8MBbank	EQU			%11111111
-
-Pratt0MBExBank	EQU			%11110011				; Expansion RAM bank bit masks
-Pratt2MBExBank	EQU			%11110011
-Pratt4MBExBank	EQU			%11111011
-Pratt8MBExBank	EQU			%11110111
-
-													;CSR5 Test Control Bits
-PrattFreqRfsh	EQU			0						; Pratt frequent refresh control bit
-PrattDBRfshOnly	EQU			1						; Do daughterboard refresh only bit
-PrattShortRamp	EQU			2						; Do short power rampup bit
-
-PrattPwrCyclBit	EQU			0						;CSR6 Power Cycling bit (= 1 to power cycle) 
-
 ;---------------------------------------------------								<SM4> rb, start
 ; Ponti Register Equates  (NiagraGUR register space + offset
 ;---------------------------------------------------
@@ -2073,109 +1706,7 @@ PontiLmpHWCtl		EQU			1				; (1 = Hardware control) 	- if set, hardware control l
 PontiLmpMux0		EQU			2				; (1 = 1/2 pot) 			- 1/2 scale pot reduction
 PontiLmpMux1		EQU			3				; (1 = 1/4 pot) 			- 1/4 scale pot reduction
 PontiLmpSPIDir		EQU			4				; (1 = shift out) 			- direction of shift register
-
-;---------------------------------------------------								<K9> HJR
-; HardRock Register Equates
-;---------------------------------------------------
-HardRockSlotBase	EQU			$FB000000
-
-HardRockCodecICR	EQU			HardRockSlotBase + $1020
-HardRockCodecSRCR	EQU			HardRockSlotBase + $1024
-HardRockCodecEnReg	EQU			HardRockSlotBase + $1028
-HardRockCodecOutAtt	EQU			HardRockSlotBase + $1030
-HardRockCodecInGain	EQU			HardRockSlotBase + $1034
-
-HardRockFifoBase	EQU			HardRockSlotBase + $2000
-HardRockFifoControl	EQU			HardRockSlotBase + $2000 +4
-
-HRChan_run12		EQU			12				; 1 = enable channel 12
-HRChan_run9			EQU			9				; 1 = enable channel 9
-HRChan_run7			EQU			7				; 1 = enable channel 7
-HRChan_run6			EQU			6				; 1 = enable channel 6
-HRChan_run5			EQU			5				; 1 = enable channel 5
-HRChan_run4			EQU			4				; 1 = enable channel 4
-HRChan_run3			EQU			3				; 1 = enable channel 3
-HRChan_run2			EQU			2				; 1 = enable channel 2
-HRChan_run1			EQU			1				; 1 = enable channel 1
-HRSPI_Voice_Sel		EQU			0				; 1 = Voice DMA data goes through SPI Interface
-												; 0 = Voice DMA data goes through CODEC Interface
-
-HardRockFifoCTL0	EQU			HardRockFifoBase + $10
-HardRockFifoCTL1	EQU			HardRockFifoBase + $20
-HardRockFifoCTL2	EQU			HardRockFifoBase + $30
-
-HardRockFifoBase0	EQU			HardRockFifoBase + $1C
-HardRockFifoBase1	EQU			HardRockFifoBase + $2C
-HardRockFifoBase2	EQU			HardRockFifoBase + $3C
-
-HardRockFifoRec		RECORD		0,Increment		; 
-HRFifoConfig		DS.W		1				; 0
-HRFifoInt			DS.W		1				; 2
-HRFifoReserved		DS.W		2				; 4
-HRFifoReadptr		DS.W		1				; 8
-HRFifoWriteptr		DS.W		1				; A
-HRFifoBase			DS.L		1				; C
-HRFiforecSize		EQU			*-HardRockFifoRec
-					ENDR
-
-HRFifoConfig64b		EQU			6				; Fifo config size of 64 bytes	
-HRFifoConfig128b	EQU			7				; Fifo config size of 128 bytes	
-HRFifoConfig256b	EQU			8				; Fifo config size of 256 bytes	
-HRFifoConfig512b	EQU			9				; Fifo config size of 512 bytes	
-HRFifoConfig1k		EQU			10				; Fifo config size of 1 kbytes	
-HRFifoConfig2k		EQU			11				; Fifo config size of 2 kbytes	
-HRFifoConfig4k		EQU			12				; Fifo config size of 4 kbytes	
-HRFifoConfig8k		EQU			13				; Fifo config size of 8 kbytes	
-
-HRFifoConfigVal		EQU			HRFifoConfig1k	; Currently set Fifo size to 1k
-HRFifoSz			EQU			$400			; $400 = #1024 = 1k
-HRFifoWrapVal		EQU			HRFifoSz-1
-
-HardRockFifoIntMsk0	EQU			HardRockFifoBase + $12
-HardRockFifoIntMsk1	EQU			HardRockFifoBase + $22
-HardRockFifoIntMsk2	EQU			HardRockFifoBase + $32
-
-HRIntMask			EQU			0				; 1 = interrupt masked, 0 = interrupt enabled
-
-HardRockReadIntRec	RECORD		0,Increment		; 
-HRIntFlags			DS.B		1
-HRRcvFlags			DS.B		1
-HRDataCount			DS.W		1
-					ENDR
-
-HardRockModemPwrReg	EQU			HardRockSlotBase + $20
-HardRockModemRstClr	EQU			2				; 0 = deassertion of CHIQUITA_RESET_L is high level
-												; 1 = deassertion of CHIQUITA_RESET_L is tristate level
-HardRockModem_RST	EQU			1				; 0 = assert CHIQUITA_RESET_L
-HardRockModem_PWR	EQU			0				; 1 = Enable power to modem
-
-HardRockModem_base	EQU			HardRockSlotBase + $4000
-
-HardRockSPIMdmCtl	EQU			$000
-HardRockSPIAck		EQU			2				; (1 = ack idle)
-HardRockSPIReq		EQU			3				; (1 = req idle)
-
-HardRockSndCtl		EQU			$400
-HardRockSndSPIIrqMsk EQU		0				; (1 = mask int)
-
-HardRockSPISftReg	EQU			$800
-
-HardRockLmpSftCtl	EQU			$C00
-HardRockLmpSPIDir	EQU			4				; (1 = shift out) 			- direction of shift register
-
-ModemExtCmdRec	RECORD			0,Increment		; 
-modemcmdsel		ds.b			1
-modemdata		ds.b			1
-				endr
-
-WriteFifoRect	RECORD			0,Increment		; 
-writeflags		ds.b			1
-writecnthi		ds.b			1
-writecntlo		ds.b			1
-writepad		ds.b			1				;															<K9>
-				endr
-
-
+												;									<SM4> rb, end
 ;-------------------------------------																		<H21> thru next <H21>
 ;	djMEMC memory controller equates
 ;-------------------------------------
@@ -2185,20 +1716,6 @@ writepad		ds.b			1				;															<K9>
 
 MEMCAddr			EQU		$50F0E000				; same for both Wombat + WLCD memory maps
 
-;	djMEMC-specific CPU_ID bit values
-
-djVIA_CPU_TYPE_MASK	EQU		%01000010				; PA6, PA1 = CPU type bits								<SM18>
-djCPU_TYPE_VAIL040	EQU		%00000000				; Vail 040   = 00										<SM18>
-djCPU_TYPE_FRIDGE	EQU		%00000010				; Frigidaire = 01										<SM18>
-djCPU_TYPE_WLCD		EQU		%01000000				; WLCD       = 10										<SM18>
-djCPU_TYPE_LEGO		EQU		%01000010				; Lego       = 11										<SM18>
-
-djVIA_CPU_SPEED_MASK EQU	%00010100				; PA4, PA2 = CPU speed bits								<SM18>
-djCPU_SPEED_20MHZ	EQU		%00000000				; 20MHz      = 00										<SM18>
-djCPU_SPEED_25MHZ	EQU		%00000100				; 25MHz      = 01										<SM18>
-djCPU_SPEED_33MHZ	EQU		%00010000				; 33MHz      = 10										<SM18>
-djCPU_SPEED_40MHZ	EQU		%00010100				; 40MHz      = 11										<SM18>
-
 MEMCRegisterStart	EQU		0
 MEMCIntleaveEnable	EQU		MEMCRegisterStart		; DRAM interleave enable reg.
 dj_OneBufferedBusBit EQU	5
@@ -2235,31 +1752,31 @@ MEMCRefresh			EQU		MEMCconfig+4			; DRAM refresh rate register
 ; Interrupt Masks
 ;---------------------------------------------------
 
-hiIntMask 		EQU 		$0700					; programmer switch only
-pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
-sccIntMask		EQU 		$0400					; SCC interrupt level
-sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
-slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
-viaIntMask		EQU 		$0100					; VIA1 interrupt level
-loIntMask 		EQU 		$0100
+;(see below) hiIntMask 		EQU 		$0700					; programmer switch only
+;(see below) pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
+;(see below) sccIntMask		EQU 		$0400					; SCC interrupt level
+;(see below) sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
+;(see below) slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
+;(see below) viaIntMask		EQU 		$0100					; VIA1 interrupt level
+;(see below) loIntMask 		EQU 		$0100
 
 
 ;---------------------------------------------------
 ; Hardware Base Addresses
 ;---------------------------------------------------
 
-WrOffs			EQU			0						; SCSI write addrs are same as read base
-MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
-MskVIA1			EQU			1						; VIA 1 is level 1
-MskADB			EQU			1						; ADB is level 1
-Msk60Hz			EQU			1						; 60 Hz is level 1
-MskSCSI			EQU			2						; SCSI is level 2
-MskSound		EQU			2						; sound is level 2						<4.5>
-MskSlots		EQU			2						; slots are level 2 interrupts
-MskRTC			EQU			3						; RTC is level 3
-MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
-MskPwrOff		EQU			6						; Poweroff button is level 6
-MskNMI			EQU			7						; NMI switch is level 7
+;(see below) WrOffs			EQU			0						; SCSI write addrs are same as read base
+;(see below) MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
+;(see below) MskVIA1			EQU			1						; VIA 1 is level 1
+;(see below) MskADB			EQU			1						; ADB is level 1
+;(see below) Msk60Hz			EQU			1						; 60 Hz is level 1
+;(see below) MskSCSI			EQU			2						; SCSI is level 2
+;(see below) MskSound		EQU			2						; sound is level 2						<4.5>
+;(see below) MskSlots		EQU			2						; slots are level 2 interrupts
+;(see below) MskRTC			EQU			3						; RTC is level 3
+;(see below) MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
+;(see below) MskPwrOff		EQU			6						; Poweroff button is level 6
+;(see below) MskNMI			EQU			7						; NMI switch is level 7
 
 
 ; ---------------------------------------------------------------------------------------------------	<T8>
@@ -2336,32 +1853,32 @@ CACR_WA_030				EQU		13				; bit # of write allocate enable on 030s				<T8>
 
 
 
-Machine   		EQU 		7						; new Machine number for patches			<18>
+;(see below) Machine   		EQU 		7						; new Machine number for patches			<18>
 
 ;---------------------------------------------------
 ; System Software Information
 ;---------------------------------------------------
 
-numOsTrap 		EQU 		256   					; number of os traps
-ToolTable 		EQU 		$0E00 					; start of toolbox trap table
-numTbTrap 		EQU 		1024   					; number of toolbox traps
-numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
+;(see below) numOsTrap 		EQU 		256   					; number of os traps
+;(see below) ToolTable 		EQU 		$0E00 					; start of toolbox trap table
+;(see below) numTbTrap 		EQU 		1024   					; number of toolbox traps
+;(see below) numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
 JMemMgr24		EQU			$1E00					; jump vector start for 24 bit Memory Manager 		<v1.9>
 JMemMgr32		EQU			$1F00					; jump vector start for 32 bit Memory Manager 		<v1.9>
-HeapStart 		EQU 		$2800 					; Low mem is now 10k bytes							<SM13>
-defSysHeap		EQU 		$18000    				; Default size of the system heap
-nDfltStackSize	EQU 		$6000 					; Default stack size
+;(see below) HeapStart 		EQU 		$2800 					; Low mem is now 10k bytes							<SM13>
+;(see below) defSysHeap		EQU 		$18000    				; Default size of the system heap
+;(see below) nDfltStackSize	EQU 		$6000 					; Default stack size
 
 **** maybe not so temporary to allow things to build ****									<3.5>
-oneSecConst   	EQU 		8 						; gets converted to $80000 for onesec constant<3.5>
+;(see below) oneSecConst   	EQU 		8 						; gets converted to $80000 for onesec constant<3.5>
 	IF BlackBirdDebug THEN
-ROMStart  		EQU 		$40000000 				; ••PN BlackBirdstarting address of final ROM code	<3.5>
+;(see below) ROMStart  		EQU 		$40000000 				; ••PN BlackBirdstarting address of final ROM code	<3.5>
 	ELSE
-ROMStart  		EQU 		$40800000 				; starting address of final ROM code	<3.5>
+;(see below) ROMStart  		EQU 		$40800000 				; starting address of final ROM code	<3.5>
 	ENDIF
-snd2MemTop		EQU 		$300  					; SoundLow to Memtop
-pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
-bufWorldSize  	EQU 		8192		   			; total size of the BufPtr world		<H16>
+;(see below) snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+;(see below) pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+;(see below) bufWorldSize  	EQU 		8192		   			; total size of the BufPtr world		<H16>
 
 ;---------------------------------------------------								<SM4> rb, start
 ;  Sound parameters																			<P4>
@@ -2370,146 +1887,6 @@ sampleSize		equ			4				; number of bytes per sample
 bufferSize		equ			960				; number of samples per buffer
 sampleRate		equ			24 * 1024		; 24KHz sample rate
 
-;---------------------------------------------------------------------
-;  Whitney Sound Register Offsets (from ASC base in UniversalTables.a)
-;---------------------------------------------------------------------
-wSndInABWritePtr	equ			$f54		; [word] A/B input FIFO write pointer (alias at $f04)
-wSndInAReadPtr		equ			$f52		; [word] A input FIFO read pointer
-wSndInBReadPtr		equ			$f56		; [word] B input FIFO read pointer
-
-wSndOutAWritePtr	equ			$f58		; [word] A output FIFO write pointer
-wSndOutBWritePtr	equ			$f5c		; [word] B output FIFO write pointer
-wSndOutABReadPtr	equ			$f5a		; [word] A/B output FIFO read pointer (alias at $f26)
-
-wSndControl			equ			$f40		; [byte] configures Singer power/FIFO size/sample rate, etc.
-wSndFIFOBase		equ			$f44		; [long] physical base address of FIFO
-wSndFIFOBaseHi		equ			$f44		; [word] high order (physical) word of FIFO base address in RAM
-wSndFIFOBaseLo		equ			$f46		; [word] low order word of FIFO base address in RAM
-
-wSndAData			equ			$1000		; [word] 16-bit sound in/out data for left channel
-wSndBData			equ			$1800		; [word] 16-bit sound in/out data for right channel
-
-wSndSingerCtl1		equ			$f48		; [word] Singer mute/input select/gain control
-wSndSingerCtl2		equ			$f4a		; [word] Singer attenuation/digital out control
-wSndSingerStat1		equ			$f4c		; [word] Singer valid/clipping/error/rev status
-wSndSingerStat2		equ			$f4e		; [word] Singer digital input status
-
-;---------------------------------------------------
-;  Whitney Sound Register Bit Definitions
-;---------------------------------------------------
-
-; === sndControl register ===
-wSampleRateMsk	equ			$03				; Mask for sample rate bits
-wFIFOSizeMsk	equ			$0C				; Mask for FIFO size bits
-
-wSampleRate		equ			0				; Sample rate field for Singer Serial Clock (2 bits)
-wSampleRate1	equ			0				;  lsbit
-wSampleRate2	equ			1				;  msbit
-
-wFIFOSize		equ			2				; FIFO size (2 bits)
-wFIFOSize1		equ			2				;  lsbit
-wFIFOSize2		equ			3				;  msbit
-
-wSingerClk		equ			4				; Singer master clock enable
-wSingerPower	equ			5				; Singer power enable
-wSingerSNDFlag	equ			6				; Singer sound flag
-;				equ			7				; unused
-
-; === sndSingerCtl1 register ===
-wRGainMsk		equ			$000F			; Mask for right channel input gain
-wLGainMsk		equ			$00F0			; Mask for left channel input gain
-wRGain			equ			0				; Singer right input A/D gain (4 bits)
-wRGain1			equ			0				;  lsb
-wRGain2			equ			1
-wRGain3			equ			2
-wRGain4			equ			3				;  msb
-
-wLGain			equ			4				; Singer left input A/D gain (4 bits)
-wLGain1			equ			4				;  lsb
-wLGain2			equ			5
-wLGain3			equ			6
-wLGain4			equ			7				;  msb
-
-wInSelRight		equ			8				; Input select for right channel
-wInSelLeft		equ			9				; Input select for left channel
-
-wMute			equ			10				; Mute enable
-
-wWordAOut		equ			11				; Word A Out 17:21 (5 bits) - 0's, see Singer spec
-;				equ			12
-;				equ			13
-;				equ			14
-;				equ			15
-
-; === sndSingerCtl2 register ===
-wDigOut			equ			0				; Singer digital output (4 bits)
-wDigOut4		equ			0				;  output 4
-wDigOut3		equ			1				;  output 3
-wDigOut2		equ			2				;  output 2
-wDigOut1		equ			3				;  output 1
-
-wRAtten			equ			4				; Singer right D/A attenuation (4 bits)
-wRAtten1		equ			4				;  lsb
-wRAtten2		equ			5
-wRAtten3		equ			6
-wRAtten4		equ			7				;  msb
-
-wLAtten			equ			8				; Singer left D/A attenuation (4 bits)
-wLAtten1		equ			8				;  lsb
-wLAtten2		equ			9
-wLAtten3		equ			10
-wLAtten4		equ			11				;  msb
-
-
-wWordBOut		equ			12				; Word B Out 49:52 (5 bits) - 0's in SM1, see Singer spec
-;				equ			13
-;				equ			14
-;				equ			15
-
-; === sndSingerStat1 register ===
-wRev			equ			0				; Singer revision number (4 bits)
-wRev1			equ			0				;  lsb
-wRev2			equ			1
-wRev3			equ			2
-wRev4			equ			3				;  msb
-
-wErr			equ			4				; Singer error code (4 bits)
-wErr1			equ			4				;  lsb
-wErr2			equ			5
-wErr3			equ			6
-wErr4			equ			7				;  msb
-
-wRClip			equ			8				; Right clipping indicator
-wLClip			equ			9				; Left clipping indicator
-
-wADValid		equ			10				; A/D valid data indicator
-
-wWordAIn		equ			11				; Word A In 17:21 (5 bits), see Singer spec
-;				equ			12
-;				equ			13
-;				equ			14
-;				equ			15
-
-; === sndSingerStat2 register ===
-wDigIn			equ			0				; Singer digital input (4 bits)
-wDigIn4			equ			0				;  input 4
-wDigIn3			equ			1				;  input 3
-wDigIn2			equ			2				;  input 2
-wDigIn1			equ			3				;  input 1
-
-wWordBIn		equ			4				; Word B In 49:60 (12 bits), see Singer spec
-;				equ			5
-;				equ			6
-;				equ			7
-;				equ			8
-;				equ			9
-;				equ			10
-;				equ			11
-;				equ			12
-;				equ			13
-;				equ			14
-;				equ			15
-
 ;---------------------------------------------------
 ;  PSC Hardware Defs
 ;---------------------------------------------------
@@ -2718,7 +2095,7 @@ pdspSet			equ			7				; "0" clears, "1" sets for any bit field [0:6] containing a
 ; ???
 ;---------------------------------------------------
 
-seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+;seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
 
 ;---------------------------------------------------
 ; Hardware configuration bits.
@@ -2778,30 +2155,30 @@ dsRectLen 		EQU 		(DSrectBR**$FFFF)-(DSrectTL**$FFFF)
 ; System Error Equates
 ;---------------------------------------------------
 
-seVars			EQU 		seRegs        			; start of system error data space (wrap city)
-seVSize   		EQU 		128       				; # of bytes in space
-seD0  			EQU 		seVars        			; loc of saved reg D0
-seA0  			EQU 		seD0+32       			; loc of saved reg A0
-seA7  			EQU 		seA0+28       			; loc of saved reg A7
-sePC  			EQU 		seA7+4        			; loc of saved PC
-seSR  			EQU 		sePC+4        			; loc of saved SR
-seAccess  		EQU 		seSR+2        			; PC address during bus/address error
-seCmdSize 		EQU 		seAccess+4    			; # of bytes of parameters passed in _debugger call
-se000BE   		EQU 		seCmdSize+2       		; 8 bytes of bus error info for 68000
-seLastVar 		EQU 		se000BE+8     			; last var in System Error data space
+;seVars			EQU 		seRegs        			; start of system error data space (wrap city)
+;seVSize   		EQU 		128       				; # of bytes in space
+;seD0  			EQU 		seVars        			; loc of saved reg D0
+;seA0  			EQU 		seD0+32       			; loc of saved reg A0
+;seA7  			EQU 		seA0+28       			; loc of saved reg A7
+;sePC  			EQU 		seA7+4        			; loc of saved PC
+;seSR  			EQU 		sePC+4        			; loc of saved SR
+;seAccess  		EQU 		seSR+2        			; PC address during bus/address error
+;seCmdSize 		EQU 		seAccess+4    			; # of bytes of parameters passed in _debugger call
+;se000BE   		EQU 		seCmdSize+2       		; 8 bytes of bus error info for 68000
+;seLastVar 		EQU 		se000BE+8     			; last var in System Error data space
 
 
 ;---------------------------------------------------
 ; ROM based debugger nub
 ;---------------------------------------------------
 
-rdPort			EQU 		seLastVar     			; Number of port currently in use (0 => no link, 1 => A, 2 => B)
-rdCode			EQU 		rdPort+2      			; Ptr to code download buffer.
-rdAtrap   		EQU 		rdCode+4      			; Saved Rom Atrap handler
-rdLowTrap 		EQU 		rdAtrap+4     			; low value for trap handling
-rdHiTrap  		EQU 		rdLowTrap+2       		; high value for trap handling
-rdResult  		EQU 		rdHiTrap+2    			; result of executing down-loaded code, etc. (16 bytes)
-rdEnd 			EQU 		rdResult+16       		; end of vars
+;rdPort			EQU 		seLastVar     			; Number of port currently in use (0 => no link, 1 => A, 2 => B)
+;rdCode			EQU 		rdPort+2      			; Ptr to code download buffer.
+;rdAtrap   		EQU 		rdCode+4      			; Saved Rom Atrap handler
+;rdLowTrap 		EQU 		rdAtrap+4     			; low value for trap handling
+;rdHiTrap  		EQU 		rdLowTrap+2       		; high value for trap handling
+;rdResult  		EQU 		rdHiTrap+2    			; result of executing down-loaded code, etc. (16 bytes)
+;rdEnd 			EQU 		rdResult+16       		; end of vars
 
 
 ;---------------------------------------------------
@@ -2811,10 +2188,10 @@ rdEnd 			EQU 		rdResult+16       		; end of vars
 ; NOTE: Keep mbDotAddr immediately before mBlocAddr
 
 mbBufSize 		EQU 		34
-mbBuffer  		EQU 		seLastVar     			; buffer for input
-mbSign			EQU 		mbBuffer+mbBufSize    	; ST => negative sign during conversion
-mbDotAddr 		EQU 		mbSign+2      			; saved address
-mBlocAddr 		EQU 		mbDotAddr+4       		; saved location
+;mbBuffer  		EQU 		seLastVar     			; buffer for input
+;mbSign			EQU 		mbBuffer+mbBufSize    	; ST => negative sign during conversion
+;mbDotAddr 		EQU 		mbSign+2      			; saved address
+;mBlocAddr 		EQU 		mbDotAddr+4       		; saved location
 
 
 ;---------------------------------------------------
@@ -2873,9 +2250,6 @@ CheckSum1			DS.L		1					; $0034 checksum 1
 CheckSum2			DS.L		1					; $0038 checksum 2
 CheckSum3			DS.L		1					; $003C checksum 3
 RomSize				DS.L		1					; $0040 HiRam stuffs size of ROM in bytes here
-EraseIconOff		DS.L		1					; $0044 Offset to code to ease the Happy Mac icon
-InitSys7ToolboxOff	DS.L		1					; $0048 Offset to System 7.0 toolbox init code
-SubVers				DS.L		1					; $004C Yet another subversion (sigh)
 				ENDR
 
 
@@ -2888,60 +2262,9 @@ locValid2		EQU			6						; this must be 0
 inEmulatorBit	EQU			1						; running in emulator
 inRamBit		EQU			0						; running in ram
 
-;----------
-; TestInRam Macro																	<4.4>
-;
-; This macro tests the RomLoc byte in the ROM header to determine the ROM is located
-; in RAM.
-;----------
-			MACRO
-				TestInRam	&reg
-			    lea		@testInRamData,&reg
-				move.w	#$1,(&reg)					; write to "ROM"
-				tst.w	@testInRamData				; did it stick?
-				bra.s	@testDone
-@testInRamData	dc.w	0
-@testDone
-			ENDM
 
-;----------
-; WhitneyRevAtLeast Macro
-;	Sets the Z bit in the CCR if Whitney revision is greater or equal to &rev parameter passed in
-;	 else clears the Z bit
-; NOTE: This macro no longer supports the original rev Whitney b/c the hack used will interfere with
-;		modem operation.
-;----------
-			MACRO
-				WhitneyRevAtLeast	&rev
-				cmpi.b	#&rev,WhitneyRev
-				bmi.s	@older
-				ori		#$04,CCR				;set the Z bit
-				bra.s	@exit
-@older			andi	#$FB,CCR				;clear the Z bit
-@exit
-			ENDM	
-
-;----------
-; PrattFlashSystem Macro
-;	Sets the Z bit in the CCR if Pratt detects Flash on the expansion board,
-;	 else clears the Z bit
-;----------
-PrattSysStatReg	EQU		$50080007
-			MACRO
-				PrattFlashSystem	
-				btst.b	#PrattFlashLBit,PrattSysStatReg		; Is this a flash rom system
-			ENDM	
-
-ForAmusementOnly	equ		0
-				If	ForAmusementOnly then
-;__________________________________________________________________________________________
-;
-;
-; Old 16 bit Equates for onMac, onMacPP, and onHcMac
-;
-;
-;__________________________________________________________________________________________
 
+				If	onMac then
 ;=======================================;
 ;  Macintosh Plus Hardware Information	;
 ;=======================================;
@@ -2958,12 +2281,12 @@ viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
 loIntMask 		EQU 		$0100
 
 ; === VIA1 BUFFER A ===
-;vSound			EQU 		$7    					; sound volume bits (0..2)
+vSound			EQU 		$7    					; sound volume bits (0..2)
 vSndPg2   		EQU 		3 						; select sound page 2 if 0
-;vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+vHeadSel  		EQU 		5 						; head select line for Sony
 vPage2			EQU 		6 						; select video page 2 if 0
-;vSCCWrReq 		EQU 		7 						; SCC write/request line
+vSCCWrReq 		EQU 		7 						; SCC write/request line
 
 vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
 							(1<<vSndPg2)|\			; sound page 2 select is an output
@@ -2981,14 +2304,14 @@ vAInit 			EQU 		(1)|\					; sound volume level initially 1
 
 
 ; === VIA1 BUFFER B ===
-;vRTCData  		EQU 		0 						; real time clock data
-;vRTCClk   		EQU 		1 						; real time clock clock pulses
-;vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
 vSW   			EQU 		3 						; mouse switch (0 when down)
 vX2   			EQU 		4 						; mouse X level
 vY2   			EQU 		5 						; mouse Y level
 vH4   			EQU 		6 						; horizontal sync
-;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
 
 vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
 							(1<<vRTCClk)|\			; real time clock clock is an output
@@ -3064,7 +2387,9 @@ stlDelay  		EQU 		$30   					; default bus settle delay		*** patch only ***
 ROMDoEject		EQU 		$40001E   				; jump to DoEject utility		*** patch only ***
 dACKRd			EQU 		$200  					; offset of psuedo-DMA - READ	*** patch only ***
 
+seRegs      EQU     $3FFC80           ; Sys Error Regs w/o Overlay
 
+  				ELSEIF  	onMacPP THEN
 ;=======================================;
 ;	Macintosh SE Hardware Information	;
 ;=======================================;
@@ -3081,12 +2406,12 @@ viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
 loIntMask 		EQU 		$0100
 
 ; === VIA1 BUFFER A ===
-;vSound			EQU 		$7    					; sound volume bits (0..2)
-;vSync 			EQU 		3 						; Synchronous modem
+vSound			EQU 		$7    					; sound volume bits (0..2)
+vSync 			EQU 		3 						; Synchronous modem
 vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vHeadSel  		EQU 		5 						; head select line for Sony
 vPage2			EQU 		6 						; select video page 2 if 0
-;vSCCWrReq 		EQU 		7 						; SCC write/request line
+vSCCWrReq 		EQU 		7 						; SCC write/request line
 
 vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
 							(1<<vSync)|\			; Synchronous modem is an output
@@ -3105,15 +2430,15 @@ vAInit 			EQU 		(1)|\					; sound volume level initially 1
 
 
 ; === VIA1 BUFFER B ===
-;vRTCData  		EQU 		0 						; real time clock data
-;vRTCClk   		EQU 		1 						; real time clock clock pulses
-;vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
-;vFDBInt   		EQU 		3 						; Front Desk bus interrupt
-;vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
-;vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
 vSCSIMask 		EQU 		6 						; SCSI IRQ mask
 vH4   			EQU 		vSCSIMask				; SCSI IRQ mask (was horiz. sync)
-;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
 
 vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
 							(1<<vRTCClk)|\			; real time clock clock is an output
@@ -3183,7 +2508,9 @@ HeapStart 		EQU 		$1600 					; Aladdin starting point
 defSysHeap		EQU 		$18000    				; Default size of the system heap
 nDfltStackSize	EQU 		$2000 					; Default stack size
 
+seRegs      EQU     $3FFC80           ; Sys Error Regs w/o Overlay
 
+  				ELSEIF  	onHcMac THEN
 ;===========================================;
 ;	Macintosh Portable Hardware Information	;
 ;===========================================;
@@ -3212,12 +2539,12 @@ vAInit			EQU 		$00   					; VBufA initial values
 vPMreq			EQU 		0 						; Power manager handshake request
 vPMack			EQU 		1 						; Power manager handshake acknowledge
 vTestJ			EQU 		2 						; Test jumper
-;vSync 			EQU 		3 						; Synchronous modem
+vSync 			EQU 		3 						; Synchronous modem
 vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vHeadSel  		EQU 		5 						; head select line for Sony
 vStereo   		EQU 		6 						; Stereo sound enable
-;vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
-;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)	(output)
+vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)	(output)
 
 vBOut 			EQU 		(1<<vPMreq)|\			; Power mgr handshake request is an output
 							(0<<vPMack)|\			; Power mgr handshake acknowledge is an input
@@ -3300,7 +2627,9 @@ HeapStart 		EQU 		$1E00 					; Portable starting point	<1.2>
 DefSysHeap		EQU 		$18000    				; Default size of the system heap
 NDfltStackSize	EQU 		$2000 					; Default stack size
 
+seRegs      EQU     $0C30           ; offset to Sys Error Regs w/o Overlay
 
+  				ELSEIF  	onMac16 THEN
 ;===================================================;
 ;	Universal 16 bit Macintosh Hardware Information	;
 ;===================================================;
@@ -3314,43 +2643,43 @@ viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
 loIntMask 		EQU 		$0100
 
 ; === VIA1 BUFFER A ===
-;vSound			EQU 		$7    					; sound volume bits (0..2)
+vSound			EQU 		$7    					; sound volume bits (0..2)
 vSndPg2   		EQU 		3 						; select sound page 2 if 0
-;vSync 			EQU 		3 						; Synchronous modem
-;vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
-;vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vSync 			EQU 		3 						; Synchronous modem
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
+vHeadSel  		EQU 		5 						; head select line for Sony
 vPage2			EQU 		6 						; select video page 2 if 0
-;vSCCWrReq 		EQU 		7 						; SCC write/request line
+vSCCWrReq 		EQU 		7 						; SCC write/request line
 
 ; === VIA1 BUFFER B ===
-;vRTCData  		EQU 		0 						; real time clock data
-;vRTCClk   		EQU 		1 						; real time clock clock pulses
-;vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
 vSW   			EQU 		3 						; mouse switch (0 when down)
-;vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
 vX2   			EQU 		4 						; mouse X level
-;vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
 vY2   			EQU 		5 						; mouse Y level
-;vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
 vH4   			EQU 		6 						; horizontal sync
 vSCSIMask 		EQU 		6 						; SCSI IRQ mask
-;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
 
 vPMreq			EQU 		0 						; Power manager handshake request
 vPMack			EQU 		1 						; Power manager handshake acknowledge
 vTestJ			EQU 		2 						; Test jumper
-;vSync 			EQU 		3 						; Synchronous modem
-;vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vSync 			EQU 		3 						; Synchronous modem
+vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
+vHeadSel  		EQU 		5 						; head select line for Sony
 vStereo   		EQU 		6 						; Stereo sound enable
-;vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
+vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
 
 ; === VIA1 BUFFER A/B ===
-;vSync 			EQU 		3 						; Synchronous modem						<3.1>
+vSync 			EQU 		3 						; Synchronous modem						<3.1>
 vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)	<3.1>
-;vHeadSel  		EQU 		5 						; head select line for Sony				<3.1>
-;vSCCWrReq 		EQU 		7 						; SCC write/request line				<3.1>
+vHeadSel  		EQU 		5 						; head select line for Sony				<3.1>
+vSCCWrReq 		EQU 		7 						; SCC write/request line				<3.1>
 
 ; === Hardware Base Addresses ===
 
@@ -3366,11 +2695,4295 @@ HeapStart 		EQU 		$1E00 					; Laguna starting point	<1.2>
 DefSysHeap		EQU 		$18000    				; Default size of the system heap
 NDfltStackSize	EQU 		$2000 					; Default stack size
 
+seRegs      EQU     $0C30           ; offset to Sys Error Regs w/o Overlay
 
+  				ELSEIF  	onMac32 THEN
+;===================================================;
+;	Universal 32 bit Macintosh Hardware Information	;
+;===================================================;
 
-  				ENDIF								; ForAmusementOnly
+machine   		EQU 		6						; for patch file $067C					<3.5>
+
+; === Interrupt Masks ===
+hiIntMask 		EQU 		$0700					; programmer switch only
+pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
+sccIntMask		EQU 		$0400					; SCC interrupt level
+sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
+slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
+viaIntMask		EQU 		$0100					; VIA1 interrupt level
+loIntMask 		EQU 		$0100
+
+; === VIA1 BUFFER A ===
+vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+vTestJ			EQU 		0 						; Burn In Test jumper		(input)
+vCpuId0			EQU			1						; CPU Identification bit 0	(input)
+vCpuId1			EQU			2						; CPU Identification bit 1	(input)
+vSync 			EQU 		3 						; Synchronous modem
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+vCpuId2			EQU			4						; CPU Identification bit 2
+vHeadSel  		EQU 		5 						; head select line for Sony
+vRev8Bd   		EQU 		6 						; =0 for rev 8 board
+vCpuId3			EQU			6						; CPU Identification bit 3
+vSCCWrReq 		EQU 		7 						; SCC write/request line
+
+; === VIA1 BUFFER B ===
+vRTCData  		EQU 		0 						; real time clock data
+v0reserved		EQU			0						; reserved bit in Erickson				<6>
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+v1reserved		EQU			1						; reserved bit in Erickson				<6>
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+v2reserved		EQU			2						; reserved bit in Erickson				<6>
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+xcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+viafullbit		EQU			4						; Egret via full bit					<6>
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+syssesbit		EQU			5						; Egret system session bit				<6>
+vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
+v6reserved		EQU			6						; reserved bit in Erickson				<6>
+vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
+v7reserved		EQU			7						; reserved bit in Erickson				<6>
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+
+
+; === Hardware Base Addresses ===
+
+WrOffs			EQU			0						; SCSI write addrs are same as read base
+
+MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
+MskVIA1			EQU			1						; VIA 1 is level 1
+MskADB			EQU			1						; ADB is level 1
+Msk60Hz			EQU			1						; 60 Hz is level 1
+MskSCSI			EQU			2						; SCSI is level 2
+MskSound		EQU			2						; sound is level 2						<4.5>
+MskSlots		EQU			2						; slots are level 2 interrupts
+MskRTC			EQU			3						; RTC is level 3
+MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
+MskPwrOff		EQU			6						; Poweroff button is level 6
+MskNMI			EQU			7						; NMI switch is level 7
+
+; === System Software Information ===
+snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world
+seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+
+
+  				ELSEIF  	onHafMac THEN
+;===================================;
+;	Mac IIci Hardware Information	;
+;===================================;
+
+machine   		EQU 		6
+
+; === Interrupt Masks ===
+hiIntMask 		EQU 		$0700 					; programmer switch only
+pwrOffEnbl		EQU 		$2500 					; mask to allow poweroff interrupts
+sccIntMask		EQU 		$0400 					; SCC interrupt level
+sccEnblMask   	EQU 		$FBFF 					; mask to enable SCC interrupts
+via2IntMask   	EQU 		$0200 					; VIA2 interrupt level		<v1.4><1.9>
+slotIntMask   	EQU 		via2IntMask   			; slot's interrupt level	<v1.4><1.9>
+viaIntMask		EQU 		$0100 					; VIA1 interrupt level
+loIntMask 		EQU 		$0100
+
+; === VIA1 BUFFER A ===
+vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+vTestJ			EQU 		0 						; Burn In Test jumper		(input)
+vCpuId0			EQU			1						; CPU Identification bit 0	(input)
+vCpuId1			EQU			2						; CPU Identification bit 1	(input)
+vSync 			EQU 		3 						; Synchronous modem
+vCpuId2			EQU			4						; CPU Identification bit 2
+vHeadSel  		EQU 		5 						; head select line for Sony
+vCpuId3			EQU			6						; CPU Identification bit 3
+vSCCWrReq 		EQU 		7 						; SCC write/request line
+
+vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
+							(1<<vSync)|\			; Synchronous modem is an output
+							(0<<vCpuId2)|\			; CPU Identification bit 2 is an input
+							(1<<vHeadSel)|\			; head select line is an output
+							(0<<vCpuId3)|\			; CPU Identification bit 3 is an input
+							(0<<vSCCWrReq)			; SCC write/request line is an input
+
+vAInit 			EQU 		(1)|\					; sound volume level initially 1
+							(0<<vSync)|\			; Synchronous modem disabled (active high)
+							(0<<vCpuId2)|\			; CPU Identification bit 2 is an input
+							(1<<vHeadSel)|\			; head select line is an output
+							(0<<vCpuId3)|\			; CPU Identification bit 3 is an input
+							(0<<vSCCWrReq)			; SCC write/request line is an input
+
+vBufD 			EQU 		vBufA 					; disk head select is buffer A
+
+
+; === VIA1 BUFFER B ===
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
+vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+
+vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
+							(1<<vRTCClk)|\			; real time clock clock is an output
+							(1<<vRTCEnb)|\			; clock enable is an output
+							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
+							(1<<vFDesk1)|\			; FDB state bit 0 is an output
+							(1<<vFDesk2)|\			; FDB state bit 1 is an output
+							(1<<vPGCEnb)|\			; PGC enable is an output
+							(1<<vSndEnb)			; sound enable is an output
+
+vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
+							(1<<vRTCClk)|\			; real time clock clock is high
+							(1<<vRTCEnb)|\			; clock initially disabled
+							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
+							(1<<vFDesk1)|\			; FDB state bit 0 is initially state 3
+							(1<<vFDesk2)|\			; FDB state bit 1 is initially state 3
+							(1<<vPGCEnb)|\			; Parity Checking is initially disabled
+							(1<<vSndEnb)			; sound is disabled
+
+
+; === RBV BUFFER B ===
+RvBInit			EQU			(1<<RvCDis)|\			; cache disabled	<3.3>
+							(1<<RvBusLk)|\			; Bus unlocked
+							(1<<RvPowerOff)|\		; Power on
+							(1<<RvCFlush)|\			; don't flush cache
+							(0<<RvTM1A)|\			; NuBus timeout bits are inputs
+							(0<<RvTM0A)|\			; NuBus timeout bits are inputs
+							(0<<RvSndExt)|\			; sound/speaker mode is an input
+							(1<<RvPGCTest)			; generate correct parity
+
+
+; === Hardware Base Addresses ===
+
+VBase 			EQU 		$50F00000   			; VIA base address
+AVBufA			EQU 		VBase+vBufA 			; VIA buffer A
+AVBufB			EQU 		VBase+vBufB  			; VIA buffer B
+
+SCCRBase  		EQU 		$50F04000   			; SCC base read address
+SCCWBase  		EQU 		$50F04000   			; SCC base write address
+sccWrite  		EQU 		SCCWBase-SCCRBase		; general offset for write from read
+
+NewSCSIBase   	EQU 		$50F10000 				; rev8 base addr SCSI interface
+NewSCSIDMA		EQU 		$50F12000 				; rev8 base addr SCSI DMA (corrected)
+NewSCSIHsk		EQU 		$50F06000 				; rev8 base addr SCSI handshake
+MacSCSIBase   	EQU 		$50F10000 				; base addr SCSI interface
+MacSCSIDMA		EQU 		$50F12000 				; base addr SCSI DMA
+MacSCSIHsk		EQU 		$50F06000 				; base addr SCSI handshake
+wrOffs			EQU 		0 						; write addrs are same as read base
+
+SndBase			EQU 		$50F14000 				; sound chip's base address
+
+; === Video Parameters ===
+
+RBVBase			EQU			$50F26000				; RBV base address				<v1.4><1.4>
+vDACBase		EQU			$50F24000				; base of clut
+
+; === System Software Information ===
+snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world
+seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+
+  				ELSEIF  	onNuMac THEN
+;=======================================================;
+;	Macintosh II, IIx, IIcx, SE30 Hardware Information	;
+;=======================================================;
+
+hwCfgBits 		EQU 		hwCmSCSI++hwCmClock++hwCmFPU++hwCmMMU++hwCmADB
+machine   		EQU 		1
+rom85Bits 		EQU 		$3F   					; New ROMs, Power Off ability.
+
+; === Interrupt Masks ===
+hiIntMask 		EQU 		$0700 					; programmer switch only
+pwrOffEnbl		EQU 		$2500 					; mask to allow poweroff interrupts
+sccIntMask		EQU 		$0400 					; SCC interrupt level
+sccEnblMask   	EQU 		$FBFF 					; mask to enable SCC interrupts
+via2IntMask   	EQU 		$0200 					; VIA2 interrupt level		<v1.4><1.9>
+slotIntMask   	EQU 		via2IntMask   			; slot's interrupt level	<v1.4><1.9>
+viaIntMask		EQU 		$0100 					; VIA1 interrupt level
+loIntMask 		EQU 		$0100
+
+; === VIA1 BUFFER A ===
+vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+vSync 			EQU 		3 						; Synchronous modem
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+vHeadSel  		EQU 		5 						; head select line for Sony
+vRev8Bd   		EQU 		6 						; =0 for rev 8 board
+vSCCWrReq 		EQU 		7 						; SCC write/request line
+
+vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
+							(1<<vSync)|\			; Synchronous modem is an output
+							(1<<vOverlay)|\			; overlay bit is an output
+							(1<<vHeadSel)|\			; head select line is an output
+							(0<<vRev8Bd)|\			; board ID is an input
+							(0<<vSCCWrReq)			; SCC write/request line is an input
+
+vAInit 			EQU 		(1)|\					; sound volume level initially 1
+							(0<<vSync)|\			; Synchronous modem disabled (active high)
+							(0<<vOverlay)|\			; overlay is turned off
+							(0<<vHeadSel)|\			; head select line is an output
+							(0<<vRev8Bd)|\			; board ID is an input
+							(0<<vSCCWrReq)			; SCC write/request line is an input
+
+vBufD 			EQU 		vBufA 					; disk head select is buffer A
+
+
+; === VIA1 BUFFER B ===
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+;				EQU			6						; unused
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+
+vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
+							(1<<vRTCClk)|\			; real time clock clock is an output
+							(1<<vRTCEnb)|\			; clock enable is an output
+							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
+							(1<<vFDesk1)|\			; FDB state bit 0 is an output
+							(1<<vFDesk2)|\			; FDB state bit 1 is an output
+							(1<<vSndEnb)			; sound enable is an output
+
+vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
+							(1<<vRTCClk)|\			; real time clock clock is high
+							(1<<vRTCEnb)|\			; clock initially disabled
+							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
+							(1<<vFDesk1)|\			; FDB state bit 0 is initially state 3
+							(1<<vFDesk2)|\			; FDB state bit 1 is initially state 3
+							(0<<vSndEnb)			; sound is enabled
+
+
+; === VIA2 BUFFER A ===
+v2AOut			EQU 		(0<<v2IRQ1)|\     		; slot 1 interrupt is an input
+  				(0<<v2IRQ2)|\ 						; slot 2 interrupt is an input
+  				(0<<v2IRQ3)|\ 						; slot 3 interrupt is an input
+  				(0<<v2IRQ4)|\ 						; slot 4 interrupt is an input
+  				(0<<v2IRQ5)|\ 						; slot 5 interrupt is an input
+  				(0<<v2IRQ6)|\ 						; slot 6 interrupt is an input
+  				(1<<v2RAM0)|\ 						; ram size bit 0 is an output
+  				(1<<v2RAM1)   						; ram size bit 1 is an output
+
+v2AInit			EQU			(0<<v2IRQ1)|\			; slot 1 interrupt is an input
+							(0<<v2IRQ2)|\			; slot 2 interrupt is an input
+							(0<<v2IRQ3)|\			; slot 3 interrupt is an input
+							(0<<v2IRQ4)|\			; slot 4 interrupt is an input
+							(0<<v2IRQ5)|\			; slot 5 interrupt is an input
+							(0<<v2IRQ6)|\			; slot 6 interrupt is an input
+							(0<<v2RAM0)|\			; or ram size bit 0 with 0
+							(0<<v2RAM1)				; or ram size bit 1 with 0
+
+
+; === VIA2 BUFFER B ===
+v2BOut			EQU			(0<<v2CDis)|\			; cache disabled	<3.3>
+  				(0<<v2BusLk)|\						; Bus unlocked
+  				(0<<v2PowerOff)|\ 					; Power on
+  				(0<<vFC3)|\   						; don't flush cache
+  				(0<<v2TM1A)|\ 						; NuBus timeout bits are inputs
+  				(0<<v2TM0A)|\ 						; NuBus timeout bits are inputs
+  				(0<<v2SndExt)|\   					; sound/speaker mode is an input
+  				(1<<v2VBL)							; 60Hz pseudo VBL output
+
+v2BInit			EQU			(1<<v2CDis)|\			; cache disabled (input when not in use)	<3.3>
+							(0<<v2BusLk)|\			; Bus unlocked	(input when not in use)
+							(1<<v2PowerOff)|\		; Power on	(input when not in use)
+							(0<<vFC3)|\				; don't flush cache	(input when not in use)
+							(0<<v2TM1A)|\			; NuBus timeout bits are inputs
+							(0<<v2TM0A)|\			; NuBus timeout bits are inputs
+							(0<<v2SndExt)|\			; sound/speaker mode is an input
+							(0<<v2VBL)				; 60Hz pseudo VBL output
+
+
+; === Hardware Base Addresses ===
+
+VBase 			EQU 		$50F00000     			; VIA base address
+AVBufA			EQU 		VBase+vBufA       		; VIA buffer A
+AVBufB			EQU 		VBase+vBufB       		; VIA buffer B
+
+VBase2			EQU 		$50F02000 				; VIA2 base address				<v1.4>
+
+SCCRBase  		EQU 		$50F04000     			; SCC base read address
+SCCWBase  		EQU 		$50F04000     			; SCC base write address
+sccWrite  		EQU 		SCCWBase-SCCRBase     	; general offset for write from read
+
+NewSCSIBase   	EQU 		$50F10000     			; rev8 base addr SCSI interface
+NewSCSIDMA		EQU 		$50F12000     			; rev8 base addr SCSI DMA (corrected)
+NewSCSIHsk		EQU 		$50F06000     			; rev8 base addr SCSI handshake
+MacSCSIBase   	EQU 		$50F10000     			; base addr SCSI interface
+MacSCSIDMA		EQU 		$50F12000     			; base addr SCSI DMA
+MacSCSIHsk		EQU 		$50F06000     			; base addr SCSI handshake
+wrOffs			EQU 		0 						; write addrs are same as read base
+
+SndBase   		EQU 		$50F14000     			; sound chip's base address
+
+; === System Software Information ===
+snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world
+seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+
+
+  				ENDIF
 
 HardwarePrivate EQU 		1
 
   				ENDIF								; __INCLUDINGHARDWAREPRIVATEEQU__
 
+; Everything below is empty calories to keep this file compiling
+;__________________________________________________________________________________________
+;
+; Welcome to the New Hardware Equates File.  By following some simple procedures this file
+; can keep its youthful appearance for years to come.  This file is a recombination of
+; HardwareEqu.a and HardwarePrivateEqu.a.  Everyone should be using this file only.  Please
+; change any of your files that use either of the hardware equate files to use only this one.
+; HardwareEqu.a will be left as an historical artifact for future generations.
+;
+; To help you navigate through this file use the "Mark" menu item, and please help to keep
+; it current.  When you add a new section, add a handy mark to find it again.  Equates are
+; grouped in a semi-logical way in the follwing order:
+;
+;		Chip Offsets - Register offsets for the 'standard' Mac peripheral chips.
+;		Chip Offsets 2 - Register offsets for the 'non-standard' Mac peripheral chips.
+;		VIA1 - Register offsets and pin descriptions.
+;		VIA2 - Register offsets and pin descriptions.
+;		RBV - Register offsets and pin descriptions.
+;		VISA - Register offsets and pin descriptions.
+;		Memory Controllers - Register definitions and miscellaneous equates.
+;		Interrupts - Auto vector names and mask definitions.
+;		Miscellaneous - The "Smorgasboard" of equates.
+;		Old 16 Bit Equates - Machine dependent equates for Mac, MacPP, HcMac, and Mac16.
+;
+;
+;__________________________________________________________________________________________
+
+
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; Chip Offsets - Register offsets for "standard" Mac chips.  This includes the following:
+;				 IWM, SWIM, SCC, SCSI (with and without DMA), ASC.
+;
+;
+;__________________________________________________________________________________________
+
+
+;---------------------------------------------------
+; IWM Offsets
+;---------------------------------------------------
+
+	IF &TYPE('ph0L') = 'UNDEFINED' THEN ; generated for fun
+ph0L  			EQU 		0 						; disk address offsets from base
+	ENDIF ; generated for fun
+	IF &TYPE('ph0H') = 'UNDEFINED' THEN ; generated for fun
+ph0H  			EQU 		$200
+	ENDIF ; generated for fun
+	IF &TYPE('ph1L') = 'UNDEFINED' THEN ; generated for fun
+ph1L  			EQU 		$400
+	ENDIF ; generated for fun
+	IF &TYPE('ph1H') = 'UNDEFINED' THEN ; generated for fun
+ph1H  			EQU 		$600
+	ENDIF ; generated for fun
+	IF &TYPE('ph2L') = 'UNDEFINED' THEN ; generated for fun
+ph2L  			EQU 		$800
+	ENDIF ; generated for fun
+	IF &TYPE('ph2H') = 'UNDEFINED' THEN ; generated for fun
+ph2H  			EQU 		$A00
+	ENDIF ; generated for fun
+	IF &TYPE('ph3L') = 'UNDEFINED' THEN ; generated for fun
+ph3L  			EQU 		$C00
+	ENDIF ; generated for fun
+	IF &TYPE('ph3H') = 'UNDEFINED' THEN ; generated for fun
+ph3H  			EQU 		$E00
+	ENDIF ; generated for fun
+	IF &TYPE('mtrOff') = 'UNDEFINED' THEN ; generated for fun
+mtrOff			EQU 		$1000
+	ENDIF ; generated for fun
+	IF &TYPE('mtrOn') = 'UNDEFINED' THEN ; generated for fun
+mtrOn 			EQU 		$1200
+	ENDIF ; generated for fun
+	IF &TYPE('intDrive') = 'UNDEFINED' THEN ; generated for fun
+intDrive  		EQU 		$1400 					; enable internal drive address
+	ENDIF ; generated for fun
+	IF &TYPE('extDrive') = 'UNDEFINED' THEN ; generated for fun
+extDrive  		EQU 		$1600 					; enable external drive address
+	ENDIF ; generated for fun
+	IF &TYPE('q6L') = 'UNDEFINED' THEN ; generated for fun
+q6L   			EQU 		$1800
+	ENDIF ; generated for fun
+	IF &TYPE('q6H') = 'UNDEFINED' THEN ; generated for fun
+q6H   			EQU 		$1A00
+	ENDIF ; generated for fun
+	IF &TYPE('q7L') = 'UNDEFINED' THEN ; generated for fun
+q7L   			EQU 		$1C00
+	ENDIF ; generated for fun
+	IF &TYPE('q7H') = 'UNDEFINED' THEN ; generated for fun
+q7H   			EQU 		$1E00
+	ENDIF ; generated for fun
+
+	IF &TYPE('IWMInitMode') = 'UNDEFINED' THEN ; generated for fun
+IWMInitMode		equ			$17						; initial IWM mode setting				<3.5>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+;  SWIM offsets
+;---------------------------------------------------
+
+	IF &TYPE('wData') = 'UNDEFINED' THEN ; generated for fun
+wData 			EQU 		$0000 					;Write a data byte
+	ENDIF ; generated for fun
+	IF &TYPE('wMark') = 'UNDEFINED' THEN ; generated for fun
+wMark 			EQU 		$0200 					;Write a mark byte
+	ENDIF ; generated for fun
+	IF &TYPE('wCRC') = 'UNDEFINED' THEN ; generated for fun
+wCRC  			EQU 		$0400 					;Write a 2-byte CRC (1 access does both)
+	ENDIF ; generated for fun
+	IF &TYPE('wIWMConfig') = 'UNDEFINED' THEN ; generated for fun
+wIWMConfig		EQU 		wCRC  					;Set IWM configuration
+	ENDIF ; generated for fun
+	IF &TYPE('wParams') = 'UNDEFINED' THEN ; generated for fun
+wParams   		EQU 		$0600 					;Set the 16 parameter registers
+	ENDIF ; generated for fun
+	IF &TYPE('wPhase') = 'UNDEFINED' THEN ; generated for fun
+wPhase			EQU 		$0800 					;Set phase lines states and directions
+	ENDIF ; generated for fun
+	IF &TYPE('wSetup') = 'UNDEFINED' THEN ; generated for fun
+wSetup			EQU 		$0A00 					;Set the current configuration
+	ENDIF ; generated for fun
+	IF &TYPE('wZeroes') = 'UNDEFINED' THEN ; generated for fun
+wZeroes   		EQU 		$0C00 					;Mode reg: 1's clr bits, 0's=don't care
+	ENDIF ; generated for fun
+	IF &TYPE('wOnes') = 'UNDEFINED' THEN ; generated for fun
+wOnes 			EQU 		$0E00 					;Mode reg: 1's set bits, 0's=don't care
+	ENDIF ; generated for fun
+	IF &TYPE('rData') = 'UNDEFINED' THEN ; generated for fun
+rData 			EQU 		$1000 					;Read a data byte
+	ENDIF ; generated for fun
+	IF &TYPE('rCorrection') = 'UNDEFINED' THEN ; generated for fun
+rCorrection   	EQU 		rData 					;Read the correction factor
+	ENDIF ; generated for fun
+	IF &TYPE('rMark') = 'UNDEFINED' THEN ; generated for fun
+rMark 			EQU 		$1200 					;Read a mark byte
+	ENDIF ; generated for fun
+	IF &TYPE('rError') = 'UNDEFINED' THEN ; generated for fun
+rError			EQU 		$1400 					;Error register
+	ENDIF ; generated for fun
+	IF &TYPE('rParams') = 'UNDEFINED' THEN ; generated for fun
+rParams   		EQU 		$1600 					;Parameters (16 bytes deep at this addr)
+	ENDIF ; generated for fun
+	IF &TYPE('rPhase') = 'UNDEFINED' THEN ; generated for fun
+rPhase			EQU 		$1800 					;Phase lines states and directions
+	ENDIF ; generated for fun
+	IF &TYPE('rSetup') = 'UNDEFINED' THEN ; generated for fun
+rSetup			EQU 		$1A00 					;Read the current configuration
+	ENDIF ; generated for fun
+	IF &TYPE('rStatus') = 'UNDEFINED' THEN ; generated for fun
+rStatus   		EQU 		$1C00 					;Status (returns current mode reg value)
+	ENDIF ; generated for fun
+	IF &TYPE('rHandshake') = 'UNDEFINED' THEN ; generated for fun
+rHandshake		EQU 		$1E00 					;Handshake register
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; 8530 SCC Offsets
+;---------------------------------------------------
+
+	IF &TYPE('aData') = 'UNDEFINED' THEN ; generated for fun
+aData 			EQU 		6 						; offset for A channel data
+	ENDIF ; generated for fun
+	IF &TYPE('aCtl') = 'UNDEFINED' THEN ; generated for fun
+aCtl  			EQU 		2 						; offset for A channel control
+	ENDIF ; generated for fun
+	IF &TYPE('bData') = 'UNDEFINED' THEN ; generated for fun
+bData 			EQU 		4 						; offset for B channel data
+	ENDIF ; generated for fun
+	IF &TYPE('bCtl') = 'UNDEFINED' THEN ; generated for fun
+bCtl  			EQU 		0 						; offset for B channel control
+	ENDIF ; generated for fun
+	IF &TYPE('sccData') = 'UNDEFINED' THEN ; generated for fun
+sccData   		EQU 		4 						; general offset for data from control
+	ENDIF ; generated for fun
+	IF &TYPE('rxBF') = 'UNDEFINED' THEN ; generated for fun
+rxBF  			EQU 		0 						; SCC receive buffer full
+	ENDIF ; generated for fun
+	IF &TYPE('txBE') = 'UNDEFINED' THEN ; generated for fun
+txBE  			EQU 		2 						; SCC transmit buffer empty
+	ENDIF ; generated for fun
+	IF &TYPE('RxCA') = 'UNDEFINED' THEN ; generated for fun
+RxCA			EQU			0						; Receive Character Available
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; 53C80 SCSI Register Defs, Offsets
+;---------------------------------------------------
+
+	IF &TYPE('sCDR') = 'UNDEFINED' THEN ; generated for fun
+sCDR  			EQU 		$00   					; Current SCSI Read Data
+	ENDIF ; generated for fun
+	IF &TYPE('sODR') = 'UNDEFINED' THEN ; generated for fun
+sODR  			EQU 		$00   					; Output data register
+	ENDIF ; generated for fun
+	IF &TYPE('sICR') = 'UNDEFINED' THEN ; generated for fun
+sICR  			EQU 		$10   					; Initiator Command Register - READ/WRITE
+	ENDIF ; generated for fun
+	IF &TYPE('iRST') = 'UNDEFINED' THEN ; generated for fun
+iRST  			EQU 		$80   					; *RST asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iAIP') = 'UNDEFINED' THEN ; generated for fun
+iAIP  			EQU 		$40   					; arbitration in progress (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bAIP') = 'UNDEFINED' THEN ; generated for fun
+bAIP  			EQU 		6 						; bit test for arbitration in progress
+	ENDIF ; generated for fun
+	IF &TYPE('aTMD') = 'UNDEFINED' THEN ; generated for fun
+aTMD  			EQU 		$40   					; assert Test Mode (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iLA') = 'UNDEFINED' THEN ; generated for fun
+iLA   			EQU 		$20   					; Lost arbitration (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bLA') = 'UNDEFINED' THEN ; generated for fun
+bLA   			EQU 		5 						; bit test for Lost Arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('aDIFF') = 'UNDEFINED' THEN ; generated for fun
+aDIFF 			EQU 		$20   					; assert Differential enable (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iACK') = 'UNDEFINED' THEN ; generated for fun
+iACK  			EQU 		$10   					; *ACK is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iBSY') = 'UNDEFINED' THEN ; generated for fun
+iBSY  			EQU 		$08   					; *BSY is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iSEL') = 'UNDEFINED' THEN ; generated for fun
+iSEL  			EQU 		$04   					; *SEL is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iATN') = 'UNDEFINED' THEN ; generated for fun
+iATN  			EQU 		$02   					; *ATN is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iDB') = 'UNDEFINED' THEN ; generated for fun
+iDB   			EQU 		$01   					; Data bus is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('sMR') = 'UNDEFINED' THEN ; generated for fun
+sMR   			EQU 		$20   					; Mode Register - READ/WRITE
+	ENDIF ; generated for fun
+	IF &TYPE('iBDMA') = 'UNDEFINED' THEN ; generated for fun
+iBDMA 			EQU 		$80   					; Block Mode DMA
+	ENDIF ; generated for fun
+	IF &TYPE('iTGT') = 'UNDEFINED' THEN ; generated for fun
+iTGT  			EQU 		$40   					; Target Mode
+	ENDIF ; generated for fun
+	IF &TYPE('iPTY') = 'UNDEFINED' THEN ; generated for fun
+iPTY  			EQU 		$20   					; Enable Parity Checking
+	ENDIF ; generated for fun
+	IF &TYPE('iIPTY') = 'UNDEFINED' THEN ; generated for fun
+iIPTY 			EQU 		$10   					; Enable Parity interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('iIEOP') = 'UNDEFINED' THEN ; generated for fun
+iIEOP 			EQU 		$08   					; Enable EOP interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('iMBSY') = 'UNDEFINED' THEN ; generated for fun
+iMBSY 			EQU 		$04   					; Monitor BSY
+	ENDIF ; generated for fun
+	IF &TYPE('iDMA') = 'UNDEFINED' THEN ; generated for fun
+iDMA  			EQU 		$02   					; DMA Mode
+	ENDIF ; generated for fun
+	IF &TYPE('iARB') = 'UNDEFINED' THEN ; generated for fun
+iARB  			EQU 		$01   					; Arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('sTCR') = 'UNDEFINED' THEN ; generated for fun
+sTCR  			EQU 		$30   					; Target Command Register - READ/WRITE
+	ENDIF ; generated for fun
+	IF &TYPE('iREQ') = 'UNDEFINED' THEN ; generated for fun
+iREQ  			EQU 		$08   					; Assert *REQ
+	ENDIF ; generated for fun
+	IF &TYPE('iMSG') = 'UNDEFINED' THEN ; generated for fun
+iMSG  			EQU 		$04   					; Assert *MSG
+	ENDIF ; generated for fun
+	IF &TYPE('iCD') = 'UNDEFINED' THEN ; generated for fun
+iCD   			EQU 		$02   					; Assert C/*D
+	ENDIF ; generated for fun
+	IF &TYPE('iIO') = 'UNDEFINED' THEN ; generated for fun
+iIO   			EQU 		$01   					; Assert I/*O
+	ENDIF ; generated for fun
+	IF &TYPE('sCSR') = 'UNDEFINED' THEN ; generated for fun
+sCSR  			EQU 		$40   					; Current SCSI Bus Status (READ)
+	ENDIF ; generated for fun
+	IF &TYPE('aRST') = 'UNDEFINED' THEN ; generated for fun
+aRST  			EQU 		$80   					; *RST
+	ENDIF ; generated for fun
+	IF &TYPE('aBSY') = 'UNDEFINED' THEN ; generated for fun
+aBSY  			EQU 		$40   					; *BSY
+	ENDIF ; generated for fun
+	IF &TYPE('bBSY') = 'UNDEFINED' THEN ; generated for fun
+bBSY  			EQU 		6 						; bit test for *BSY
+	ENDIF ; generated for fun
+	IF &TYPE('aREQ') = 'UNDEFINED' THEN ; generated for fun
+aREQ  			EQU 		$20   					; *REQ
+	ENDIF ; generated for fun
+	IF &TYPE('bREQ') = 'UNDEFINED' THEN ; generated for fun
+bREQ  			EQU 		5 						; bit test for *REQ
+	ENDIF ; generated for fun
+	IF &TYPE('aMSG') = 'UNDEFINED' THEN ; generated for fun
+aMSG  			EQU 		$10   					; *MSG
+	ENDIF ; generated for fun
+	IF &TYPE('bMSG') = 'UNDEFINED' THEN ; generated for fun
+bMSG  			EQU 		4 						; bit test for *MSG
+	ENDIF ; generated for fun
+	IF &TYPE('aCD') = 'UNDEFINED' THEN ; generated for fun
+aCD   			EQU 		$08   					; C/*D
+	ENDIF ; generated for fun
+	IF &TYPE('bCD') = 'UNDEFINED' THEN ; generated for fun
+bCD   			EQU 		3 						; bit test for C/*D
+	ENDIF ; generated for fun
+	IF &TYPE('aIO') = 'UNDEFINED' THEN ; generated for fun
+aIO   			EQU 		$04   					; I/*O
+	ENDIF ; generated for fun
+	IF &TYPE('bIO') = 'UNDEFINED' THEN ; generated for fun
+bIO   			EQU 		2 						; bit test for I/*O
+	ENDIF ; generated for fun
+	IF &TYPE('aSEL') = 'UNDEFINED' THEN ; generated for fun
+aSEL  			EQU 		$02   					; *SEL
+	ENDIF ; generated for fun
+	IF &TYPE('bSEL') = 'UNDEFINED' THEN ; generated for fun
+bSEL  			EQU 		1 						; bit test for *SEL
+	ENDIF ; generated for fun
+	IF &TYPE('aDBP') = 'UNDEFINED' THEN ; generated for fun
+aDBP  			EQU 		$01   					; *DBP
+	ENDIF ; generated for fun
+	IF &TYPE('sSER') = 'UNDEFINED' THEN ; generated for fun
+sSER  			EQU 		$40   					; Select Enable Register (WRITE)
+	ENDIF ; generated for fun
+	IF &TYPE('sBSR') = 'UNDEFINED' THEN ; generated for fun
+sBSR  			EQU 		$50   					; Bus & Status Register (READ)
+	ENDIF ; generated for fun
+	IF &TYPE('iEDMA') = 'UNDEFINED' THEN ; generated for fun
+iEDMA 			EQU 		$80   					; End of DMA
+	ENDIF ; generated for fun
+	IF &TYPE('bEDMA') = 'UNDEFINED' THEN ; generated for fun
+bEDMA 			EQU 		7 						; bit test for end of DMA
+	ENDIF ; generated for fun
+	IF &TYPE('iDMAR') = 'UNDEFINED' THEN ; generated for fun
+iDMAR 			EQU 		$40   					; DMA Request
+	ENDIF ; generated for fun
+	IF &TYPE('bDMAR') = 'UNDEFINED' THEN ; generated for fun
+bDMAR 			EQU 		6 						; bit test for DMA Req
+	ENDIF ; generated for fun
+	IF &TYPE('iPERR') = 'UNDEFINED' THEN ; generated for fun
+iPERR 			EQU 		$20   					; Parity Error
+	ENDIF ; generated for fun
+	IF &TYPE('iIREQ') = 'UNDEFINED' THEN ; generated for fun
+iIREQ 			EQU 		$10   					; Interrupt Request
+	ENDIF ; generated for fun
+	IF &TYPE('bIREQ') = 'UNDEFINED' THEN ; generated for fun
+bIREQ 			EQU 		4 						; bit test for interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('iPM') = 'UNDEFINED' THEN ; generated for fun
+iPM   			EQU 		$08   					; Phase Match
+	ENDIF ; generated for fun
+	IF &TYPE('bPM') = 'UNDEFINED' THEN ; generated for fun
+bPM   			EQU 		3 						; bit test for Phase Match
+	ENDIF ; generated for fun
+	IF &TYPE('iBERR') = 'UNDEFINED' THEN ; generated for fun
+iBERR 			EQU 		$04   					; Bus Error
+	ENDIF ; generated for fun
+	IF &TYPE('ATN') = 'UNDEFINED' THEN ; generated for fun
+ATN   			EQU 		$02   					; *ATN
+	ENDIF ; generated for fun
+	IF &TYPE('ACK') = 'UNDEFINED' THEN ; generated for fun
+ACK   			EQU 		$01   					; *ACK
+	ENDIF ; generated for fun
+	IF &TYPE('bACK') = 'UNDEFINED' THEN ; generated for fun
+bACK  			EQU 		0 						; bit test for ACK
+	ENDIF ; generated for fun
+	IF &TYPE('sDMAtx') = 'UNDEFINED' THEN ; generated for fun
+sDMAtx			EQU 		$50   					; DMA Transmit Start (WRITE)
+	ENDIF ; generated for fun
+	IF &TYPE('sIDR') = 'UNDEFINED' THEN ; generated for fun
+sIDR  			EQU 		$60   					; Data input register (READ)
+	ENDIF ; generated for fun
+	IF &TYPE('sTDMArx') = 'UNDEFINED' THEN ; generated for fun
+sTDMArx   		EQU 		$60   					; Start Target DMA receive (WRITE)
+	ENDIF ; generated for fun
+	IF &TYPE('sRESET') = 'UNDEFINED' THEN ; generated for fun
+sRESET			EQU 		$70   					; Reset Parity/Interrupt (READ)
+	ENDIF ; generated for fun
+	IF &TYPE('sIDMArx') = 'UNDEFINED' THEN ; generated for fun
+sIDMArx   		EQU 		$70   					; Start Initiator DMA receive (WRITE)
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+;  SCSI DMA chip register offsets
+;---------------------------------------------------
+
+;  Note that the 53C80 registers are provided on the SCSI DMA chip.  The registers
+;  described here are in addition to the 53C80 registers.
+
+	IF &TYPE('sDCTRL') = 'UNDEFINED' THEN ; generated for fun
+sDCTRL			EQU			$80
+	ENDIF ; generated for fun
+	IF &TYPE('bDMAEN') = 'UNDEFINED' THEN ; generated for fun
+bDMAEN			EQU			0						; bit to enable SCSI DMA
+	ENDIF ; generated for fun
+	IF &TYPE('iDMAEN') = 'UNDEFINED' THEN ; generated for fun
+iDMAEN			EQU			$0001					; mask to enable SCSI DMA
+	ENDIF ; generated for fun
+	IF &TYPE('bINTREN') = 'UNDEFINED' THEN ; generated for fun
+bINTREN			EQU			1						; bit to enable SCSI DMA interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('iINTREN') = 'UNDEFINED' THEN ; generated for fun
+iINTREN			EQU			$0002					; mask to enable SCSI DMA interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('bTIMEEN') = 'UNDEFINED' THEN ; generated for fun
+bTIMEEN			EQU			2						; bit to enable watchdog timer intr's
+	ENDIF ; generated for fun
+	IF &TYPE('iTIMEEN') = 'UNDEFINED' THEN ; generated for fun
+iTIMEEN			EQU			$0004					; mask to enable watchdog timer intr's
+	ENDIF ; generated for fun
+	IF &TYPE('bHSKEN') = 'UNDEFINED' THEN ; generated for fun
+bHSKEN			EQU			3						; bit to enable hardware-handshaking (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iHSKEN') = 'UNDEFINED' THEN ; generated for fun
+iHSKEN			EQU			$0008					; mask to enable hardware-handshaking (write)
+	ENDIF ; generated for fun
+	IF &TYPE('bRESET') = 'UNDEFINED' THEN ; generated for fun
+bRESET			EQU			4						; bit to reset SCSI DMA chip (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iRESET') = 'UNDEFINED' THEN ; generated for fun
+iRESET			EQU			$0010					; mask to reset SCSI DMA chip (write)
+	ENDIF ; generated for fun
+	IF &TYPE('bFIFO') = 'UNDEFINED' THEN ; generated for fun
+bFIFO			EQU			4						; bit indicating bytes left in FIFO (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iFIFO') = 'UNDEFINED' THEN ; generated for fun
+iFIFO			EQU			$0010					; mask indicating bytes left in FIFO (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bTEST') = 'UNDEFINED' THEN ; generated for fun
+bTEST			EQU			5						; bit to enable SCSI Test Mode (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iTEST') = 'UNDEFINED' THEN ; generated for fun
+iTEST			EQU			$0020					; mask to enable SCSI Test Mode (write)
+	ENDIF ; generated for fun
+	IF &TYPE('bSCSIP') = 'UNDEFINED' THEN ; generated for fun
+bSCSIP			EQU			6						; bit indicating SCSI intr pending (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iSCSIP') = 'UNDEFINED' THEN ; generated for fun
+iSCSIP			EQU			$0040					; mask indicating SCSI intr pending (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bTIMEP') = 'UNDEFINED' THEN ; generated for fun
+bTIMEP			EQU			7						; bit indicating timer intr pending (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iTIMEP') = 'UNDEFINED' THEN ; generated for fun
+iTIMEP			EQU			$0080					; mask indicating timer intr pending (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bDMABERR') = 'UNDEFINED' THEN ; generated for fun
+bDMABERR		EQU			8						; bit indicating DMA bus error (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iDMABERR') = 'UNDEFINED' THEN ; generated for fun
+iDMABERR		EQU			$0100					; mask indicating DMA bus error (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iARBID') = 'UNDEFINED' THEN ; generated for fun
+iARBID			EQU			$0E00					; mask to get target ID for arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('bARBIDEN') = 'UNDEFINED' THEN ; generated for fun
+bARBIDEN		EQU			12						; bit to enable hardware arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('iARBIDEN') = 'UNDEFINED' THEN ; generated for fun
+iARBIDEN		EQU			$1000					; mask to enable hardware arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('bWONARB') = 'UNDEFINED' THEN ; generated for fun
+bWONARB			EQU			13						; bit indicating successful arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('iWONARB') = 'UNDEFINED' THEN ; generated for fun
+iWONARB			EQU			$2000					; mask indicating successful arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('iINFIFO') = 'UNDEFINED' THEN ; generated for fun
+iINFIFO			EQU			$C000					; mask to get bytes left in FIFO (read)
+	ENDIF ; generated for fun
+
+	IF &TYPE('sDCNT') = 'UNDEFINED' THEN ; generated for fun
+sDCNT			EQU			$C0
+	ENDIF ; generated for fun
+
+	IF &TYPE('sDADDR') = 'UNDEFINED' THEN ; generated for fun
+sDADDR			EQU			$100
+	ENDIF ; generated for fun
+
+	IF &TYPE('sDTIME') = 'UNDEFINED' THEN ; generated for fun
+sDTIME			EQU			$140
+	ENDIF ; generated for fun
+
+	IF &TYPE('sTEST') = 'UNDEFINED' THEN ; generated for fun
+sTEST			equ			$180
+	ENDIF ; generated for fun
+
+;__________________________________________________________________________________________
+;
+;
+; Chip Offsets - Register offsets for "non standard" Mac chips.  This includes the following:
+;				 OSS and IOP.
+;
+;
+;__________________________________________________________________________________________
+
+
+;---------------------------------------------------
+;  OSS (Operating System Support) Chip Address & Offsets
+;---------------------------------------------------
+
+	IF &TYPE('OSSMskFirst') = 'UNDEFINED' THEN ; generated for fun
+OSSMskFirst		equ			$000					;offset to first interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlot9') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlot9		equ			OSSMskFirst				;offset to slot 9 interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotA') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotA		equ			$001					;offset to slot A interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotB') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotB		equ			$002					;offset to slot B interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotC') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotC		equ			$003					;offset to slot C interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotD') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotD		equ			$004					;offset to slot D interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotE') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotE		equ			$005					;offset to slot E interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskPSwm') = 'UNDEFINED' THEN ; generated for fun
+OSSMskPSwm		equ			$006					;offset to SWIM PIC interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskPScc') = 'UNDEFINED' THEN ; generated for fun
+OSSMskPScc		equ			$007					;offset to SCC PIC interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSnd') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSnd		equ			$008					;offset to Sound interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskScsi') = 'UNDEFINED' THEN ; generated for fun
+OSSMskScsi		equ			$009					;offset to SCSI interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMsk60Hz') = 'UNDEFINED' THEN ; generated for fun
+OSSMsk60Hz		equ			$00A					;offset to 60 Hz interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskVia1') = 'UNDEFINED' THEN ; generated for fun
+OSSMskVia1		equ			$00B					;offset to VIA1 interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskRTC') = 'UNDEFINED' THEN ; generated for fun
+OSSMskRTC		equ			$00C					;offset to RTC interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskADB') = 'UNDEFINED' THEN ; generated for fun
+OSSMskADB		equ			$00D					;offset to ADB interrupt mask register (not used)		<5.1>
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskRPU') = 'UNDEFINED' THEN ; generated for fun
+OSSMskRPU		equ			$00E					;offset to RPU interrupt mask register					<4.8>
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskLast') = 'UNDEFINED' THEN ; generated for fun
+OSSMskLast		equ			OSSMskRPU				;offset to last interrupt mask register
+	ENDIF ; generated for fun
+
+	IF &TYPE('rpuReset') = 'UNDEFINED' THEN ; generated for fun
+rpuReset		EQU			$010					; RPU write offset to reset serial ptr					<4.9>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OSSIntStat') = 'UNDEFINED' THEN ; generated for fun
+OSSIntStat		equ			$202					;offset to interrupt status register. Bits are:			<3.7>
+	ENDIF ; generated for fun
+													;  15:  interrupt 15 (spare) pending
+													;  14:  interrupt 14 (RPU) pending						<4.8>
+													;  13:  interrupt 13 (spare) pending					<5.1>
+													;  12:  interrupt 12 (RTC) pending
+													;  11:  interrupt 11 (VIA1) pending
+													;  10:  interrupt 10 (60 Hz) pending
+													;   9:  interrupt 9 (SCSI) pending
+													;   8:  interrupt 8 (sound) pending
+													;   7:  interrupt 7 (SCC PIC) pending
+													;   6:  interrupt 6 (SWIM PIC) pending
+													;   5:  interrupt 5 (slot E) pending
+													;   4:  interrupt 4 (slot D) pending
+													;   3:  interrupt 3 (slot C) pending
+													;   2:  interrupt 2 (slot B) pending
+													;   1:  interrupt 1 (slot A) pending
+													;   0:  interrupt 0 (slot 9) pending
+
+;••••• NOTE: In the new OSS, the interrupt status register is a long word starting at $200.			<3.7>
+;•••••		 Since only the low-order word is currently used, making a single change here			<3.7>
+;•••••		 has less impact on the ROM sources.  When we permanently switch over to the			<3.7>
+;•••••		 new OSS hardware, then it may make sense to fix this equate and change all its			<3.7>
+;•••••		 uses from MOVE.Ws to MOVE.Ls.															<3.7>
+
+	IF &TYPE('OSSRomCntl') = 'UNDEFINED' THEN ; generated for fun
+OSSRomCntl		equ			$204					;offset to ROM control register.  Bits are:
+	ENDIF ; generated for fun
+													;  <to be specified - see Steve Ray's spec>				<2.0>
+
+	IF &TYPE('OSSPwrOff') = 'UNDEFINED' THEN ; generated for fun
+OSSPwrOff		equ			OSSRomCntl				;power off is now a bit in the ROM control register		<5.1>
+	ENDIF ; generated for fun
+	IF &TYPE('OSSPwrOffBit') = 'UNDEFINED' THEN ; generated for fun
+OSSPwrOffBit	equ			7						;    7:  write a 1 here to power off the machine		<2.1><3.7>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OSSCntrCntl') = 'UNDEFINED' THEN ; generated for fun
+OSSCntrCntl		equ			$205					;offset to counter control register.  Bits are
+	ENDIF ; generated for fun
+													;  7-2:  unused
+													;    1:  test control.  A 1 causes each 4 bit
+													;        counter segment to count in parallel
+													;    0:  counter hold.  A 1 holds current value
+													;        so all 64 bits can be read.  Hold doesn't
+													;        affect counting, though!
+
+	IF &TYPE('OSSInpStat') = 'UNDEFINED' THEN ; generated for fun
+OSSInpStat		equ			$206					;offset to input status register.  Bits are
+	ENDIF ; generated for fun
+													;  7-2:  not used, read as zero
+													;    1:  SCC write request. Not used if PIC present
+													;    0:  mini-phono device plugged in flag.  A 1
+													;        means a device IS plugged in.
+
+	IF &TYPE('OSS60HzAck') = 'UNDEFINED' THEN ; generated for fun
+OSS60HzAck		equ			$207					;offset to 'Clear 60 Hz interrupt flag' register.  Both	<3.7>
+	ENDIF ; generated for fun
+													; writes and reads clear it, so might as well write it.
+
+	IF &TYPE('OSSCounter') = 'UNDEFINED' THEN ; generated for fun
+OSSCounter		equ			$208					;offset to 64 bit counter register.  Low order 8
+	ENDIF ; generated for fun
+													;.bits are always read as zero (maybe not in future...)
+
+;  Bit numbers in OSS interrupt status register
+
+	IF &TYPE('OSSIntIOPSWIM') = 'UNDEFINED' THEN ; generated for fun
+OSSIntIOPSWIM	equ			6						;bit # of SWIM IOP in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntIOPSCC') = 'UNDEFINED' THEN ; generated for fun
+OSSIntIOPSCC	equ			7						;bit # of SCC IOP in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntSound') = 'UNDEFINED' THEN ; generated for fun
+OSSIntSound		equ			8						;bit # of ASC in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntSCSI') = 'UNDEFINED' THEN ; generated for fun
+OSSIntSCSI		equ			9						;bit # of SCSI in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntVBL60Hz') = 'UNDEFINED' THEN ; generated for fun
+OSSIntVBL60Hz	equ			10						;bit # of 60Hz VBL in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntVia1') = 'UNDEFINED' THEN ; generated for fun
+OSSIntVia1		equ			11						;bit # of VIA 1 in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntRTC') = 'UNDEFINED' THEN ; generated for fun
+OSSIntRTC		equ			12						;bit # of RTC in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntADB') = 'UNDEFINED' THEN ; generated for fun
+OSSIntADB		equ			13						;bit # of ADB in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntRPU') = 'UNDEFINED' THEN ; generated for fun
+OSSIntRPU		equ			14						;bit # of RPU in interrupt status register		<4.8>
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntLast') = 'UNDEFINED' THEN ; generated for fun
+OSSIntLast		equ			14						;bit # of last interrupt source
+	ENDIF ; generated for fun
+
+	IF &TYPE('OSSRomInit') = 'UNDEFINED' THEN ; generated for fun
+OSSRomInit		EQU			$D						; initial value for ROM control register<3.5>
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+;  IOP (Input Output Processor) Chip Offsets and bit definitions
+;---------------------------------------------------
+
+	IF &TYPE('iopRamAddrH') = 'UNDEFINED' THEN ; generated for fun
+iopRamAddrH		equ			$0000-$20				; high byte of shared RAM address register
+	ENDIF ; generated for fun
+	IF &TYPE('iopRamAddrL') = 'UNDEFINED' THEN ; generated for fun
+iopRamAddrL		equ			$0002-$20				; low byte of shared RAM address register
+	ENDIF ; generated for fun
+	IF &TYPE('iopRamAddr') = 'UNDEFINED' THEN ; generated for fun
+iopRamAddr		equ			iopRamAddrL-1			; WORD access to shared RAM address register
+	ENDIF ; generated for fun
+
+	IF &TYPE('iopRamData') = 'UNDEFINED' THEN ; generated for fun
+iopRamData		equ			$0008-$20				; shared RAM data register (byte, word, or long)
+	ENDIF ; generated for fun
+	IF &TYPE('iopStatCtl') = 'UNDEFINED' THEN ; generated for fun
+iopStatCtl		equ			$0004-$20				; IOP Status and Control register
+	ENDIF ; generated for fun
+
+;	bit numbers within the iopStatCtl register
+	IF &TYPE('iopInBypassMode') = 'UNDEFINED' THEN ; generated for fun
+iopInBypassMode	equ			0						; IOP is in BYPASS mode
+	ENDIF ; generated for fun
+	IF &TYPE('iopIncEnable') = 'UNDEFINED' THEN ; generated for fun
+iopIncEnable	equ			1						; enable addr pointer increment
+	ENDIF ; generated for fun
+	IF &TYPE('iopRun') = 'UNDEFINED' THEN ; generated for fun
+iopRun			equ			2						; 0 -> reset IOP, 1 -> run IOP
+	ENDIF ; generated for fun
+	IF &TYPE('iopGenInterrupt') = 'UNDEFINED' THEN ; generated for fun
+iopGenInterrupt	equ			3						; interrupt the IOP
+	ENDIF ; generated for fun
+	IF &TYPE('iopInt0Active') = 'UNDEFINED' THEN ; generated for fun
+iopInt0Active	equ			4						; interrupt 0 active
+	ENDIF ; generated for fun
+	IF &TYPE('iopInt1Active') = 'UNDEFINED' THEN ; generated for fun
+iopInt1Active	equ			5						; interrupt 1 active
+	ENDIF ; generated for fun
+	IF &TYPE('iopBypassIntReq') = 'UNDEFINED' THEN ; generated for fun
+iopBypassIntReq	equ			6						; peripheral chip interrupt request in bypass mode
+	ENDIF ; generated for fun
+	IF &TYPE('iopSCCWrReq') = 'UNDEFINED' THEN ; generated for fun
+iopSCCWrReq		equ			7						; 0 -> SCC REQ active, 1 -> inactive
+	ENDIF ; generated for fun
+
+;	commands bytes to write to the iopStatCtl register
+	IF &TYPE('setIopIncEnable') = 'UNDEFINED' THEN ; generated for fun
+setIopIncEnable	equ			(1<<iopIncEnable)|\		; set increment enable
+							(1<<iopRun)				; leave iop running
+	ENDIF ; generated for fun
+
+	IF &TYPE('clrIopIncEnable') = 'UNDEFINED' THEN ; generated for fun
+clrIopIncEnable	equ			(0<<iopIncEnable)|\		; reset increment enable
+							(1<<iopRun)				; leave iop running
+	ENDIF ; generated for fun
+
+	IF &TYPE('clrIopInt0') = 'UNDEFINED' THEN ; generated for fun
+clrIopInt0		equ			(1<<iopInt0Active)|\	; clear interrupt 0 active
+							(1<<iopRun)|\			; leave iop running
+							(1<<iopIncEnable)		; leave increment enabled
+	ENDIF ; generated for fun
+
+	IF &TYPE('clrIopInt1') = 'UNDEFINED' THEN ; generated for fun
+clrIopInt1		equ			(1<<iopInt1Active)|\	; clear interrupt 1 active
+							(1<<iopRun)|\			; leave iop running
+							(1<<iopIncEnable)		; leave increment enabled
+	ENDIF ; generated for fun
+
+	IF &TYPE('setIopGenInt') = 'UNDEFINED' THEN ; generated for fun
+setIopGenInt	equ			(1<<iopGenInterrupt)|\	; interrupt the IOP
+							(1<<iopRun)|\			; leave iop running
+							(1<<iopIncEnable)		; leave increment enabled
+	ENDIF ; generated for fun
+
+	IF &TYPE('resetIopRun') = 'UNDEFINED' THEN ; generated for fun
+resetIopRun		equ			(0<<iopRun)|\			; stop iop from running
+							(1<<iopInt0Active)|\	; clear interrupt 0 active
+							(1<<iopInt1Active)|\	; clear interrupt 1 active
+							(1<<iopIncEnable)		; set increment enable
+	ENDIF ; generated for fun
+
+	IF &TYPE('setIopRun') = 'UNDEFINED' THEN ; generated for fun
+setIopRun		equ			(1<<iopRun)|\			; start iop running
+							(1<<iopInt0Active)|\	; clear interrupt 0 active
+							(1<<iopInt1Active)|\	; clear interrupt 1 active
+							(1<<iopIncEnable)		; set increment enable
+	ENDIF ; generated for fun
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; VIA1 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
+; are grouped together.  New definitions for VIA1 pins are added such that the grouping is
+; maintained.
+;
+;
+;__________________________________________________________________________________________
+
+;---------------------------------------------------
+; 6522 VIA1 (and VIA2) register offsets
+;---------------------------------------------------
+
+	IF &TYPE('vBufB') = 'UNDEFINED' THEN ; generated for fun
+vBufB 			EQU 		0 						; BUFFER B
+	ENDIF ; generated for fun
+	IF &TYPE('vBufAH') = 'UNDEFINED' THEN ; generated for fun
+vBufAH			EQU 		$200  					; buffer a (with handshake) [ Dont use! ]
+	ENDIF ; generated for fun
+	IF &TYPE('vDIRB') = 'UNDEFINED' THEN ; generated for fun
+vDIRB 			EQU 		$400  					; DIRECTION B
+	ENDIF ; generated for fun
+	IF &TYPE('vDIRA') = 'UNDEFINED' THEN ; generated for fun
+vDIRA 			EQU 		$600  					; DIRECTION A
+	ENDIF ; generated for fun
+	IF &TYPE('vT1C') = 'UNDEFINED' THEN ; generated for fun
+vT1C  			EQU 		$800  					; TIMER 1 COUNTER (L.O.)
+	ENDIF ; generated for fun
+	IF &TYPE('vT1CH') = 'UNDEFINED' THEN ; generated for fun
+vT1CH 			EQU 		$A00  					; timer 1 counter (high order)
+	ENDIF ; generated for fun
+	IF &TYPE('vT1L') = 'UNDEFINED' THEN ; generated for fun
+vT1L  			EQU 		$C00  					; TIMER 1 LATCH (L.O.)
+	ENDIF ; generated for fun
+	IF &TYPE('vT1LH') = 'UNDEFINED' THEN ; generated for fun
+vT1LH 			EQU 		$E00  					; timer 1 latch (high order)
+	ENDIF ; generated for fun
+	IF &TYPE('vT2C') = 'UNDEFINED' THEN ; generated for fun
+vT2C  			EQU 		$1000 					; TIMER 2 LATCH (L.O.)
+	ENDIF ; generated for fun
+	IF &TYPE('vT2CH') = 'UNDEFINED' THEN ; generated for fun
+vT2CH 			EQU 		$1200 					; timer 2 counter (high order)
+	ENDIF ; generated for fun
+	IF &TYPE('vSR') = 'UNDEFINED' THEN ; generated for fun
+vSR   			EQU 		$1400 					; SHIFT REGISTER
+	ENDIF ; generated for fun
+	IF &TYPE('vACR') = 'UNDEFINED' THEN ; generated for fun
+vACR  			EQU 		$1600 					; AUX. CONTROL REG.
+	ENDIF ; generated for fun
+	IF &TYPE('vPCR') = 'UNDEFINED' THEN ; generated for fun
+vPCR  			EQU 		$1800 					; PERIPH. CONTROL REG.
+	ENDIF ; generated for fun
+	IF &TYPE('vIFR') = 'UNDEFINED' THEN ; generated for fun
+vIFR  			EQU 		$1A00 					; INT. FLAG REG.
+	ENDIF ; generated for fun
+	IF &TYPE('vIER') = 'UNDEFINED' THEN ; generated for fun
+vIER  			EQU 		$1C00 					; INT. ENABLE REG.
+	ENDIF ; generated for fun
+	IF &TYPE('vBufA') = 'UNDEFINED' THEN ; generated for fun
+vBufA 			EQU 		$1E00 					; BUFFER A
+	ENDIF ; generated for fun
+	IF &TYPE('vBufD') = 'UNDEFINED' THEN ; generated for fun
+vBufD 			EQU 		vBufA 					; disk head select is buffer A			<3.5>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; VIA IFR/IER bits
+;---------------------------------------------------
+
+	IF &TYPE('ifCA2') = 'UNDEFINED' THEN ; generated for fun
+ifCA2 			EQU 		0 						; CA2 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifCA1') = 'UNDEFINED' THEN ; generated for fun
+ifCA1 			EQU 		1 						; CA1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifSR') = 'UNDEFINED' THEN ; generated for fun
+ifSR  			EQU 		2 						; SR shift register done
+	ENDIF ; generated for fun
+	IF &TYPE('ifCB2') = 'UNDEFINED' THEN ; generated for fun
+ifCB2 			EQU 		3 						; CB2 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifCB1') = 'UNDEFINED' THEN ; generated for fun
+ifCB1 			EQU 		4 						; CB1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifT2') = 'UNDEFINED' THEN ; generated for fun
+ifT2  			EQU 		5 						; T2 timer2 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifT1') = 'UNDEFINED' THEN ; generated for fun
+ifT1  			EQU 		6 						; T1 timer1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifIRQ') = 'UNDEFINED' THEN ; generated for fun
+ifIRQ 			EQU 		7 						; any interrupt
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; VIA1 Port A definitions
+;---------------------------------------------------
+
+	IF &TYPE('vSound') = 'UNDEFINED' THEN ; generated for fun
+vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+	ENDIF ; generated for fun
+
+	IF &TYPE('vTestJ') = 'UNDEFINED' THEN ; generated for fun
+vTestJ			EQU 		0 						; Burn In Test jumper		(input)
+	ENDIF ; generated for fun
+
+	IF &TYPE('vCpuId0') = 'UNDEFINED' THEN ; generated for fun
+vCpuId0			EQU			1						; CPU Identification bit 0	(input)
+	ENDIF ; generated for fun
+	IF &TYPE('vCpuId1') = 'UNDEFINED' THEN ; generated for fun
+vCpuId1			EQU			2						; CPU Identification bit 1	(input)
+	ENDIF ; generated for fun
+	IF &TYPE('vSync') = 'UNDEFINED' THEN ; generated for fun
+vSync 			EQU 		3 						; Synchronous modem
+	ENDIF ; generated for fun
+	IF &TYPE('vOverlay') = 'UNDEFINED' THEN ; generated for fun
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+	ENDIF ; generated for fun
+	IF &TYPE('vCpuId2') = 'UNDEFINED' THEN ; generated for fun
+vCpuId2			EQU			4						; CPU Identification bit 2
+	ENDIF ; generated for fun
+	IF &TYPE('vReqAEnable') = 'UNDEFINED' THEN ; generated for fun
+vReqAEnable		EQU			4						; enable ReqA into vSCCWrReq (PSC only)		<LW2>
+	ENDIF ; generated for fun
+	IF &TYPE('vHeadSel') = 'UNDEFINED' THEN ; generated for fun
+vHeadSel  		EQU 		5 						; head select line for Sony
+	ENDIF ; generated for fun
+	IF &TYPE('vCpuId3') = 'UNDEFINED' THEN ; generated for fun
+vCpuId3			EQU			6						; CPU Identification bit 3
+	ENDIF ; generated for fun
+	IF &TYPE('vRev8Bd') = 'UNDEFINED' THEN ; generated for fun
+vRev8Bd   		EQU 		6 						; =0 for rev 8 board>
+	ENDIF ; generated for fun
+	IF &TYPE('vReqBEnable') = 'UNDEFINED' THEN ; generated for fun
+vReqBEnable		EQU			6						; enable ReqB into vSCCWrReq (PSC only)		<LW2>
+	ENDIF ; generated for fun
+	IF &TYPE('vSCCWrReq') = 'UNDEFINED' THEN ; generated for fun
+vSCCWrReq 		EQU 		7 						; SCC write/request line
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; VIA1 Port B definitions
+;---------------------------------------------------
+
+	IF &TYPE('vEclipseLED') = 'UNDEFINED' THEN ; generated for fun
+vEclipseLED		EQU			0						; flashable Eclipse LED (how quaint!)		<23>
+	ENDIF ; generated for fun
+	IF &TYPE('vRTCData') = 'UNDEFINED' THEN ; generated for fun
+vRTCData  		EQU 		0 						; real time clock data
+	ENDIF ; generated for fun
+	IF &TYPE('vRMP0') = 'UNDEFINED' THEN ; generated for fun
+vRMP0			EQU			0						; Reserved for RMP (PSC only)
+	ENDIF ; generated for fun
+	IF &TYPE('vRTCClk') = 'UNDEFINED' THEN ; generated for fun
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+	ENDIF ; generated for fun
+	IF &TYPE('vRMP1') = 'UNDEFINED' THEN ; generated for fun
+vRMP1			EQU			1						; Reserved for RMP (PSC only)
+	ENDIF ; generated for fun
+	IF &TYPE('vRTCEnb') = 'UNDEFINED' THEN ; generated for fun
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+	ENDIF ; generated for fun
+	IF &TYPE('vRMP2') = 'UNDEFINED' THEN ; generated for fun
+vRMP2			EQU			2						; Reserved for RMP (PSC only)
+	ENDIF ; generated for fun
+	IF &TYPE('vFDBInt') = 'UNDEFINED' THEN ; generated for fun
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('vXcvrsesbit') = 'UNDEFINED' THEN ; generated for fun
+vXcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
+	ENDIF ; generated for fun
+	IF &TYPE('vSDMCable') = 'UNDEFINED' THEN ; generated for fun
+vSDMCable		EQU			3						; SCSI DiskMode cable sense for Dartanian	<H15>
+	ENDIF ; generated for fun
+	IF &TYPE('vCudaTREQ') = 'UNDEFINED' THEN ; generated for fun
+vCudaTREQ		EQU			3						; Cuda transaction request input		<P2><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('vSDMDiskID') = 'UNDEFINED' THEN ; generated for fun
+vSDMDiskID		EQU			4						; DiskMode HD ID (bits 4-6) for Dartanian	<H15>
+	ENDIF ; generated for fun
+	IF &TYPE('vFDesk1') = 'UNDEFINED' THEN ; generated for fun
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+	ENDIF ; generated for fun
+	IF &TYPE('vViafullbit') = 'UNDEFINED' THEN ; generated for fun
+vViafullbit		EQU			4						; Egret via full bit					<6>
+	ENDIF ; generated for fun
+	IF &TYPE('vCudaBYTEACK') = 'UNDEFINED' THEN ; generated for fun
+vCudaBYTEACK	EQU			4						; Cuda byte acknowledge output			<P2><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('vFDesk2') = 'UNDEFINED' THEN ; generated for fun
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('vSyssesbit') = 'UNDEFINED' THEN ; generated for fun
+vSyssesbit		EQU			5						; Egret system session bit				<6><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('vCudaTIP') = 'UNDEFINED' THEN ; generated for fun
+vCudaTIP		EQU			5						; Cuda interface transaction in progress output <P2>
+	ENDIF ; generated for fun
+	IF &TYPE('vAUXIntEnb') = 'UNDEFINED' THEN ; generated for fun
+vAUXIntEnb 		EQU 		6 						; switch to A/UX interrupt scheme (output)	<23>
+	ENDIF ; generated for fun
+	IF &TYPE('vPGCEnb') = 'UNDEFINED' THEN ; generated for fun
+vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
+	ENDIF ; generated for fun
+	IF &TYPE('vJMPDude6') = 'UNDEFINED' THEN ; generated for fun
+vJMPDude6		EQU			6						; Reserved for JMP (PSC only)
+	ENDIF ; generated for fun
+	IF &TYPE('vPGCErr') = 'UNDEFINED' THEN ; generated for fun
+vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
+	ENDIF ; generated for fun
+	IF &TYPE('vSndEnb') = 'UNDEFINED' THEN ; generated for fun
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+	ENDIF ; generated for fun
+	IF &TYPE('vSWInt') = 'UNDEFINED' THEN ; generated for fun
+vSWInt	  		EQU 		7 						; cause a software interrupt	(output)	<23>
+	ENDIF ; generated for fun
+	IF &TYPE('vJMPDude7') = 'UNDEFINED' THEN ; generated for fun
+vJMPDude7		EQU			7						; Reserved for JMP (PSC only)
+	ENDIF ; generated for fun
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; VIA2 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
+; are grouped together.  New definitions for VIA2 pins are added such that the grouping is
+; maintained.
+;
+;
+;__________________________________________________________________________________________
+
+;---------------------------------------------------
+; VIA2 Port A definitions
+;---------------------------------------------------
+
+	IF &TYPE('v2IRQ1') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ1			EQU 		0 						; slot 1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2EnetIRQ') = 'UNDEFINED' THEN ; generated for fun
+v2EnetIRQ		EQU			0						; on-board ethernet								<8><23>
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ2') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ2			EQU 		1 						; slot 2 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ3') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ3			EQU 		2 						; slot 3 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ4') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ4			EQU 		3 						; slot 4 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ5') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ5			EQU 		4 						; slot 5 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ6') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ6			EQU 		5 						; slot 6 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2RAM0') = 'UNDEFINED' THEN ; generated for fun
+v2RAM0			EQU 		6 						; RAM size bit 0
+	ENDIF ; generated for fun
+	IF &TYPE('v2LCDIRQ') = 'UNDEFINED' THEN ; generated for fun
+v2LCDIRQ		EQU			6						; on-board LCD video
+	ENDIF ; generated for fun
+	IF &TYPE('v2VideoIRQ') = 'UNDEFINED' THEN ; generated for fun
+v2VideoIRQ		EQU			6						; on-board video								<8><23>
+	ENDIF ; generated for fun
+	IF &TYPE('v2RAM1') = 'UNDEFINED' THEN ; generated for fun
+v2RAM1			EQU 		7 						; RAM size bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('v2CardIn') = 'UNDEFINED' THEN ; generated for fun
+v2CardIn		EQU			7						; on-board video
+	ENDIF ; generated for fun
+	IF &TYPE('v2SyncOnGreen') = 'UNDEFINED' THEN ; generated for fun
+v2SyncOnGreen	EQU			7						; for enabling/disabling Sync-on-Green (DAFB)	<T20>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; VIA2 Port B definitions
+;---------------------------------------------------
+
+	IF &TYPE('v2ConfigLE') = 'UNDEFINED' THEN ; generated for fun
+v2ConfigLE		EQU			0						; DFAC config latch enable						<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('v2CDis') = 'UNDEFINED' THEN ; generated for fun
+v2CDis			EQU 		0 						; cache disable (when 1)	<3.3>
+	ENDIF ; generated for fun
+	IF &TYPE('v2Keyswitch') = 'UNDEFINED' THEN ; generated for fun
+v2Keyswitch		EQU			0						; 900/950 ONLY - keyswitch shadow bit (1=SECURE)<T14><T17><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('v2BusLk') = 'UNDEFINED' THEN ; generated for fun
+v2BusLk   		EQU 		1 						; Bus lockout
+	ENDIF ; generated for fun
+	IF &TYPE('v2PMack') = 'UNDEFINED' THEN ; generated for fun
+v2PMack			EQU 		1 						; Power manager handshake acknowledge
+	ENDIF ; generated for fun
+	IF &TYPE('v2PowerOff') = 'UNDEFINED' THEN ; generated for fun
+v2PowerOff		EQU 		2 						; soft power off signal (when 0)
+	ENDIF ; generated for fun
+													; (also 900/950 keyswitch OFF bit)				<T17><SM4> rb
+	IF &TYPE('v2PMreq') = 'UNDEFINED' THEN ; generated for fun
+v2PMreq			EQU 		2 						; Power manager handshake request
+	ENDIF ; generated for fun
+	IF &TYPE('v2ConfigData') = 'UNDEFINED' THEN ; generated for fun
+v2ConfigData 	EQU 		3 						; DFAC config data								<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('v2FC3') = 'UNDEFINED' THEN ; generated for fun
+v2FC3  			EQU 		3 						; PMMU FC3 indicator
+	ENDIF ; generated for fun
+	IF &TYPE('vFC3') = 'UNDEFINED' THEN ; generated for fun
+vFC3  			EQU 		3 						; PMMU FC3 indicator
+	ENDIF ; generated for fun
+	IF &TYPE('v2SndInSel0') = 'UNDEFINED' THEN ; generated for fun
+v2SndInSel0		EQU			3						; Eclipse only - sound input select bit 0		<t19><H17>
+	ENDIF ; generated for fun
+	IF &TYPE('v2ConfigClk') = 'UNDEFINED' THEN ; generated for fun
+v2ConfigClk		EQU 		4 						; DFAC config clock								<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('v2TM1A') = 'UNDEFINED' THEN ; generated for fun
+v2TM1A			EQU 		4 						; bit for NUBus
+	ENDIF ; generated for fun
+	IF &TYPE('v2TM0A') = 'UNDEFINED' THEN ; generated for fun
+v2TM0A			EQU 		5 						; and another
+	ENDIF ; generated for fun
+	IF &TYPE('v2Speed') = 'UNDEFINED' THEN ; generated for fun
+v2Speed			EQU 		5 						; 25/33 Mhz 68040 input (0=25MHz, 1=33 MHz)
+	ENDIF ; generated for fun
+	IF &TYPE('v2MicCtl') = 'UNDEFINED' THEN ; generated for fun
+v2MicCtl		EQU			5						; microphone control on Wombats					<H17><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('v2HMMU') = 'UNDEFINED' THEN ; generated for fun
+v2HMMU			EQU			5 						; HMMU 24/32									<15> HJR
+	ENDIF ; generated for fun
+	IF &TYPE('v2CDis2') = 'UNDEFINED' THEN ; generated for fun
+v2CDis2			EQU			6						; On Tim the CDIS is on pb6						<15> HJR
+	ENDIF ; generated for fun
+	IF &TYPE('v2SndExt') = 'UNDEFINED' THEN ; generated for fun
+v2SndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio
+	ENDIF ; generated for fun
+	IF &TYPE('v2SndInSel1') = 'UNDEFINED' THEN ; generated for fun
+v2SndInSel1		EQU			6						; Q900/950 only - sound input select bit 1		<t19><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('v2VBL') = 'UNDEFINED' THEN ; generated for fun
+v2VBL 			EQU 		7 						; pseudo VBL signal
+	ENDIF ; generated for fun
+	IF &TYPE('v2ModemRST') = 'UNDEFINED' THEN ; generated for fun
+v2ModemRST		EQU			7						; Modem.Reset									<15> HJR
+	ENDIF ; generated for fun
+
+
+
+													; temporary Cyclone equates <SM4> rb, start, <SM5> rb
+
+
+; <SM7> rb, • TEMP EQUATES
+
+	IF &TYPE('CycloneEVT1Reg') = 'UNDEFINED' THEN ; generated for fun
+CycloneEVT1Reg	EQU			$A55A2800				; id which identifies an EVT1 cyclone in CPURegID <SM9> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2SIntEVT1') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2SIntEVT1	EQU			$000					; Slot interrupt reg. offset					<SM9> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2IFREVT1') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2IFREVT1	EQU			$004					; VIA2 interrupt flag reg. offset				<SM9> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2IEREVT1') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2IEREVT1	EQU			$008					; VIA2 interrupt enable reg. offset				<SM9> rb
+	ENDIF ; generated for fun
+
+	IF &TYPE('PSCVIA2SInt') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2SInt		EQU			$1E00					; Slot interrupt reg. offset					<SM7> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2IFR') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2IFR		EQU			$1A00					; VIA2 interrupt flag reg. offset				<SM7> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2IER') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2IER		EQU			$1C00					; VIA2 interrupt enable reg. offset				<SM7> rb
+	ENDIF ; generated for fun
+
+
+; PSC VIA2 Slot Interrupt Register equates
+	IF &TYPE('PSCSlotC') = 'UNDEFINED' THEN ; generated for fun
+PSCSlotC		EQU			3						; slot C int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSlotD') = 'UNDEFINED' THEN ; generated for fun
+PSCSlotD		EQU			4						; slot D int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSlotE') = 'UNDEFINED' THEN ; generated for fun
+PSCSlotE		EQU			5						; slot E int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCOVBVBL') = 'UNDEFINED' THEN ; generated for fun
+PSCOVBVBL		EQU			6						; on-board video vbl int.
+	ENDIF ; generated for fun
+
+; PSC VIA2 Interrupt Flag and Interrupt Enable Registers equates
+	IF &TYPE('PSCSCSI0') = 'UNDEFINED' THEN ; generated for fun
+PSCSCSI0		EQU			0						; SCSI int., same as bit 3
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSlot') = 'UNDEFINED' THEN ; generated for fun
+PSCSlot			EQU			1						; any slot int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCMUNI') = 'UNDEFINED' THEN ; generated for fun
+PSCMUNI			EQU			2						; MUNI int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSCSI3') = 'UNDEFINED' THEN ; generated for fun
+PSCSCSI3		EQU			3						; SCSI int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCFDC') = 'UNDEFINED' THEN ; generated for fun
+PSCFDC			EQU			5						; floppy int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSNDFRM') = 'UNDEFINED' THEN ; generated for fun
+PSCSNDFRM		EQU			6						; sound frame int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCANY') = 'UNDEFINED' THEN ; generated for fun
+PSCANY			EQU			7						; any of the above
+	ENDIF ; generated for fun
+
+													; <SM4> rb, end, <SM5> rb
+
+
+;----------
+;RBV (Ram Based Video) register definitions
+;----------
+
+	IF &TYPE('RvDataB') = 'UNDEFINED' THEN ; generated for fun
+RvDataB			EQU			$000					; VIA2 data reg. B equivalent	<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvExp') = 'UNDEFINED' THEN ; generated for fun
+RvExp			EQU			$001					; RBV Expansion Register		<3>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSInt') = 'UNDEFINED' THEN ; generated for fun
+RvSInt			EQU			$002					; Slot interrupts reg.			<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIFR') = 'UNDEFINED' THEN ; generated for fun
+RvIFR			EQU			$003					; interrupt flag reg.			<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvMonP') = 'UNDEFINED' THEN ; generated for fun
+RvMonP			EQU			$010					; monitor parameters reg.		<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvChpT') = 'UNDEFINED' THEN ; generated for fun
+RvChpT			EQU			$011					; chip test reg.				<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSEnb') = 'UNDEFINED' THEN ; generated for fun
+RvSEnb			EQU			$012					; Slot interrupt enable reg.	<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIER') = 'UNDEFINED' THEN ; generated for fun
+RvIER			EQU			$013					; interrupt flag enable reg.	<v1.4><2.5>
+	ENDIF ; generated for fun
+
+;----------
+;Common Via 2 and RBV (Ram Based Video) register offsets
+;----------
+
+
+	IF &TYPE('Rv2DataB') = 'UNDEFINED' THEN ; generated for fun
+Rv2DataB		EQU			vBufB++RvDataB			; RBV/VIA2 data reg. B equivalent	<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2Exp') = 'UNDEFINED' THEN ; generated for fun
+Rv2Exp			EQU			RvExp					; RBV Expansion Register			<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2SInt') = 'UNDEFINED' THEN ; generated for fun
+Rv2SInt			EQU			RvSInt					; Slot interrupts reg.				<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2IFR') = 'UNDEFINED' THEN ; generated for fun
+Rv2IFR			EQU			vIFR++RvIFR				; RBV/VIA2 interrupt flag reg.		<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2MonP') = 'UNDEFINED' THEN ; generated for fun
+Rv2MonP			EQU			RvMonP					; monitor parameters reg.			<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2ChpT') = 'UNDEFINED' THEN ; generated for fun
+Rv2ChpT			EQU			RvChpT					; chip test reg.					<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2SEnb') = 'UNDEFINED' THEN ; generated for fun
+Rv2SEnb			EQU			RvSEnb					; Slot interrupt enable reg.		<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2IER') = 'UNDEFINED' THEN ; generated for fun
+Rv2IER			EQU			vIER++RvIER				; iRBV/VIA2 interrupt enable reg.	<H8>
+	ENDIF ; generated for fun
+
+
+;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====									<v1.4>
+	IF &TYPE('RvCDis') = 'UNDEFINED' THEN ; generated for fun
+RvCDis			EQU 		0 						; cache disable (when 1)					<v1.4><3.3>
+	ENDIF ; generated for fun
+	IF &TYPE('RvBusLk') = 'UNDEFINED' THEN ; generated for fun
+RvBusLk   		EQU 		1 						; Bus lockout								<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvPowerOff') = 'UNDEFINED' THEN ; generated for fun
+RvPowerOff		EQU 		2 						; soft power off signal (when 0)			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvCFlush') = 'UNDEFINED' THEN ; generated for fun
+RvCFlush		EQU 		3 						; Flush external cache (when 0)				<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvTM1A') = 'UNDEFINED' THEN ; generated for fun
+RvTM1A			EQU 		4 						; bit for NUBus								<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvTM0A') = 'UNDEFINED' THEN ; generated for fun
+RvTM0A			EQU 		5 						; and another								<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSndExt') = 'UNDEFINED' THEN ; generated for fun
+RvSndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio		<v1.4>
+	ENDIF ; generated for fun
+													; jack in use								<v1.4>
+	IF &TYPE('RvPGCTest') = 'UNDEFINED' THEN ; generated for fun
+RvPGCTest		EQU			7						; 1 = generate good parity, 0 = generate errors
+	ENDIF ; generated for fun
+
+;  ======  Future Expansion   Address: $50026001	 =====										<v1.4>
+
+;  ======  Slot Interrupts   Address: $50026002	 =====											<v1.4>
+	IF &TYPE('RvIRQ1') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ1			EQU 		0 						; slot 1 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ2') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ2			EQU 		1 						; slot 2 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ3') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ3			EQU 		2 						; slot 3 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ4') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ4			EQU 		3 						; slot 4 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ5') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ5			EQU 		4 						; slot 5 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ6') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ6			EQU 		5 						; slot 6 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ0') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ0			EQU 		6 						; slot 0 interrupt or internal video 		<v1.4>
+	ENDIF ; generated for fun
+													; blanking interrupt						<v1.4>
+;RvResr			EQU 		7 						; reserved 									<v1.4>
+
+;  ======  Interrupt Flags   Address: $50026003	 =====											<v1.4>
+	IF &TYPE('RvSCSIDRQ') = 'UNDEFINED' THEN ; generated for fun
+RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvAnySlot') = 'UNDEFINED' THEN ; generated for fun
+RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvExpIRQ') = 'UNDEFINED' THEN ; generated for fun
+RvExpIRQ		EQU			2						; 1 = expansion int. (reserved)				<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSCSIRQ') = 'UNDEFINED' THEN ; generated for fun
+RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSndIRQ') = 'UNDEFINED' THEN ; generated for fun
+RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup				<v1.4>
+	ENDIF ; generated for fun
+;RvResr			EQU 		5 						; reserved 									<v1.4>
+;RvResr			EQU 		6 						; reserved									<v1.4>
+;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt			<v1.4>
+													; on WRITE, 1 = 1-bits in bits 0-6 write 1's<v1.4>
+													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>
+
+;  ======  Monitor Parameters   Address: $50026010	 =====										<v1.4>
+	IF &TYPE('RvColor1') = 'UNDEFINED' THEN ; generated for fun
+RvColor1		EQU			0						; (lsb) R/W 000 = 1bit, 001 = 2 bit			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvColor2') = 'UNDEFINED' THEN ; generated for fun
+RvColor2		EQU			1						; 		R/W 010 = 4bit, 011 = 8 bit			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvColor3') = 'UNDEFINED' THEN ; generated for fun
+RvColor3		EQU			2						; (msb) Read 1xx = Reserved					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvMonID1') = 'UNDEFINED' THEN ; generated for fun
+RvMonID1		EQU			3						; READ 000,011,100=reserved; x01=15" monitor<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvMonID2') = 'UNDEFINED' THEN ; generated for fun
+RvMonID2		EQU			4						; 010=Mod'IIGSmonitor;110=MacII monitors	<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvMonID3') = 'UNDEFINED' THEN ; generated for fun
+RvMonID3		EQU 		5 						; 111= 9" build in monitor					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvVIDOff') = 'UNDEFINED' THEN ; generated for fun
+RvVIDOff		EQU 		6 						; 1 = Video off								<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvVID3St') = 'UNDEFINED' THEN ; generated for fun
+RvVID3St		EQU			7						; 1 = all video outputs tri-stated			<v1.4>
+	ENDIF ; generated for fun
+
+;  ======  Chip Test   Address: $50026011	 =====												<v1.4>
+	IF &TYPE('RvC60') = 'UNDEFINED' THEN ; generated for fun
+RvC60			EQU			0						; 1 = C60 clock run 128 x normal			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSpd1') = 'UNDEFINED' THEN ; generated for fun
+RvSpd1			EQU			1						; (lsb) 00 = normal, 01=medium				<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSpd2') = 'UNDEFINED' THEN ; generated for fun
+RvSpd2			EQU			2						; (msb) 10 = fast, 11 = very fast			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvHndShk3') = 'UNDEFINED' THEN ; generated for fun
+RvHndShk3		EQU			3						; 1=VID.REQ & VID.RES tri-stated			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIOClk3') = 'UNDEFINED' THEN ; generated for fun
+RvIOClk3		EQU			4						; 1=C16M, C8M, C3.7M tri-stated				<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvC30M') = 'UNDEFINED' THEN ; generated for fun
+RvC30M			EQU 		5 						; 1=30.24 mHz clock for all monitors		<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSDTClk') = 'UNDEFINED' THEN ; generated for fun
+RvSDTClk		EQU 		6 						; 1 = Dot clock halted						<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvTstRes') = 'UNDEFINED' THEN ; generated for fun
+RvTstRes		EQU			7						; 1 = reset video counters					<v1.4>
+	ENDIF ; generated for fun
+
+;  ======  Slot Interrupts Enable   Address: $50026012	 =====									<v1.4>
+	IF &TYPE('RvIRQ1En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ1En		EQU 		0 						; slot 1 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ2En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ2En		EQU 		1 						; slot 2 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ3En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ3En		EQU 		2 						; slot 3 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ4En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ4En		EQU 		3 						; slot 4 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ5En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ5En		EQU 		4 						; slot 5 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ6En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ6En		EQU 		5 						; slot 6 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ0En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ0En		EQU 		6 						; slot 0 interrupt or internal video enabled<v1.4>
+	ENDIF ; generated for fun
+;RvSetClr		EQU			7						; on READs, always reads 0					<v1.4>
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
+													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>
+
+;  ======  Interrupt Flags Enable   Address: $50026013	 =====
+	IF &TYPE('RvSCSIDRQEn') = 'UNDEFINED' THEN ; generated for fun
+RvSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvAnySlotEn') = 'UNDEFINED' THEN ; generated for fun
+RvAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled		<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvExpIRQEn') = 'UNDEFINED' THEN ; generated for fun
+RvExpIRQEn		EQU			2						; 1 = expansion int. (reserved) enabled		<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSCSIRQEn') = 'UNDEFINED' THEN ; generated for fun
+RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSndIRQEn') = 'UNDEFINED' THEN ; generated for fun
+RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled	<v1.4>
+	ENDIF ; generated for fun
+;RvResr			EQU 		5 						; reserved 									<v1.4>
+;RvResr			EQU 		6 						; reserved									<v1.4>
+;RvSetClr		EQU			7						; on READs, always reads 1					<v1.4>
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
+													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>
+
+;----------
+; VDAC register definitions
+;----------
+
+	IF &TYPE('vDACwAddReg') = 'UNDEFINED' THEN ; generated for fun
+vDACwAddReg		EQU			$0000					;   offset from vDACBase for write address reg
+	ENDIF ; generated for fun
+	IF &TYPE('vDACrAddReg') = 'UNDEFINED' THEN ; generated for fun
+vDACrAddReg		EQU			$000C					;   offset from vDACBase for read address register <v4.2>
+	ENDIF ; generated for fun
+	IF &TYPE('vDACwDataReg') = 'UNDEFINED' THEN ; generated for fun
+vDACwDataReg	EQU			$0004					;   offset from vDACBase for write data reg
+	ENDIF ; generated for fun
+
+	IF &TYPE('vDACPixRdMask') = 'UNDEFINED' THEN ; generated for fun
+vDACPixRdMask	EQU			$0008					;   offset from vDACBase for pixel mask
+	ENDIF ; generated for fun
+
+
+;__________________________________________________________________________________________
+;
+;
+; VISA Pin Definitions and Register Offsets - Multiple names for the same pin are grouped
+; together.  New definitions for VISA pins are added such that the grouping is maintained.
+;
+;
+;__________________________________________________________________________________________
+
+
+;----------
+; VISA register definitions - generally, these equates are a precise subset
+;		of the RBV equates.
+;----------
+
+; these registers are accessed off of VIA1 lomem
+	IF &TYPE('VsData1A') = 'UNDEFINED' THEN ; generated for fun
+VsData1A		EQU		  	$1E00					; VIA1 data reg A
+	ENDIF ; generated for fun
+	IF &TYPE('VsData1B') = 'UNDEFINED' THEN ; generated for fun
+VsData1B		EQU			$0000					; VIA1 data reg B
+	ENDIF ; generated for fun
+
+; these registers are accessed off of VISA lomem
+	IF &TYPE('VsData2B') = 'UNDEFINED' THEN ; generated for fun
+VsData2B		EQU			$000					; VIA2 data reg B equivalent
+	ENDIF ; generated for fun
+	IF &TYPE('VsExp') = 'UNDEFINED' THEN ; generated for fun
+VsExp			EQU			$001					; VISA Expansion Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsSInt') = 'UNDEFINED' THEN ; generated for fun
+VsSInt			EQU			$002					; Slot Interrupt Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsIFR') = 'UNDEFINED' THEN ; generated for fun
+VsIFR			EQU			$003					; Interrupt Flag Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsMonP') = 'UNDEFINED' THEN ; generated for fun
+VsMonP			EQU			$010					; Monitor Parameters Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsSEnb') = 'UNDEFINED' THEN ; generated for fun
+VsSEnb			EQU			$012					; Slot Interrupt Enable Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsIER') = 'UNDEFINED' THEN ; generated for fun
+VsIER			EQU			$013					; Interrupt Flag Enable Register
+	ENDIF ; generated for fun
+
+;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====
+;*VsResr		EQU			0						; reserved
+;*VsResr		EQU			1						; reserved
+;*VsResr		EQU			2						; reserved
+	IF &TYPE('VsFC3') = 'UNDEFINED' THEN ; generated for fun
+VsFC3			EQU			3						; select 32-bit map.  0=24 bit, 1=32 bit
+	ENDIF ; generated for fun
+;*VsResr		EQU			4						; reserved
+;*VsResr		EQU			5						; reserved
+	IF &TYPE('VsSndExt') = 'UNDEFINED' THEN ; generated for fun
+VsSndExt		EQU			6						; Always reads as 1 - play sounds in Mono
+	ENDIF ; generated for fun
+;*VsResr		EQU			7						; reserved
+
+;  ======  Future Expansion   Address: $50026001	 =====
+	IF &TYPE('VsA2Mode') = 'UNDEFINED' THEN ; generated for fun
+VsA2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
+	ENDIF ; generated for fun
+	IF &TYPE('VsVResEn') = 'UNDEFINED' THEN ; generated for fun
+VsVResEn		EQU			1						; 1=enable vertical counter reset for video genlock
+	ENDIF ; generated for fun
+	IF &TYPE('VsFlWrEn') = 'UNDEFINED' THEN ; generated for fun
+VsFlWrEn	 	EQU			2						; 1=enable writes to flash EEPROM
+	ENDIF ; generated for fun
+	IF &TYPE('Vs1BV') = 'UNDEFINED' THEN ; generated for fun
+Vs1BV			EQU			3						; 1=low base for 1-bit mode, 0=high base
+	ENDIF ; generated for fun
+	IF &TYPE('VsPg2') = 'UNDEFINED' THEN ; generated for fun
+VsPg2			EQU			4						; 1=main video page, 0=sec video page
+	ENDIF ; generated for fun
+;*VsResr		EQU			5						; reserved
+	IF &TYPE('VsSiz0') = 'UNDEFINED' THEN ; generated for fun
+VsSiz0			EQU			6						; RAM size control bit 00=1MB, 01=1.5MB
+	ENDIF ; generated for fun
+	IF &TYPE('VsSiz1') = 'UNDEFINED' THEN ; generated for fun
+VsSiz1			EQU			7						; 	10=3MB,11=9MB
+	ENDIF ; generated for fun
+
+;  ======  Slot Interrupts   Address: $50026002	 =====
+;*VsResr		EQU			0						; reserved
+;*VsResr		EQU			1						; reserved
+;*VsResr		EQU			2						; reserved
+;*VsResr		EQU			3						; reserved
+;*VsResr		EQU			4						; reserved
+	IF &TYPE('VsSIRQ') = 'UNDEFINED' THEN ; generated for fun
+VsSIRQ			EQU			5						; expansion slot interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('VsVBLInt') = 'UNDEFINED' THEN ; generated for fun
+VsVBLInt		EQU			6						; slot zero (built-in) VBL interrupt
+	ENDIF ; generated for fun
+;*VsResr		EQU			7						; reserved
+
+
+;  ======  Interrupt Flags   Address: $50026003	 =====
+	IF &TYPE('VsSCSIDRQ') = 'UNDEFINED' THEN ; generated for fun
+VsSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrup
+	ENDIF ; generated for fun
+	IF &TYPE('VsAnySlot') = 'UNDEFINED' THEN ; generated for fun
+VsAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
+	ENDIF ; generated for fun
+;*VsResr		EQU			2						; reserved
+	IF &TYPE('VsSCSIRQ') = 'UNDEFINED' THEN ; generated for fun
+VsSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('VsSndIRQ') = 'UNDEFINED' THEN ; generated for fun
+VsSndIRQ		EQU			4						; 1 = Apple Sound Chip interrupt
+	ENDIF ; generated for fun
+;RvResr			EQU 		5 						; reserved
+;RvResr			EQU 		6 						; reserved
+	IF &TYPE('RvSetClr') = 'UNDEFINED' THEN ; generated for fun
+RvSetClr		EQU			7						; on READ, 1 = any enabled interrupt
+	ENDIF ; generated for fun
+													; on WRITE, 1 = 1-bits in bits 0-6 write 1's
+													;  			0 = 1-bits in bits 0-6 write 0's
+
+;  ======  Monitor Parameters   Address: $50026010	 =====
+;*VsResr		EQU			0						; (lsb)
+	IF &TYPE('VsColor') = 'UNDEFINED' THEN ; generated for fun
+VsColor			EQU			1						; (compat w/RBV) R/W 000 = 1bit, R/W 010 = 4bit
+	ENDIF ; generated for fun
+;*VsResr		EQU			2						; (msb)
+	IF &TYPE('VsMonConn') = 'UNDEFINED' THEN ; generated for fun
+VsMonConn		EQU			3						; (lsb)1=no monitor connected
+	ENDIF ; generated for fun
+;*VsResr		EQU			4						; (compat w/RBV)
+	IF &TYPE('VsMonSel') = 'UNDEFINED' THEN ; generated for fun
+VsMonSel		EQU 		5 						; (msb) Monitor select 1=Jersey, 0=Rubik
+	ENDIF ; generated for fun
+;*VsResr		EQU 		6 						; reserved
+;*VsResr		EQU			7						; reserved
+
+
+;  ======  Slot Interrupts Enable   Address: $50026012	 =====
+;*VsResr		EQU			0						; reserved
+;*VsResr		EQU			1						; reserved
+;*VsResr		EQU			2						; reserved
+;*VsResr		EQU			3						; reserved
+;*VsResr		EQU			4						; reserved
+	IF &TYPE('VsExtIRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('VsIntIRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsIntIRQEn		EQU 		6 						; internal video interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('VsSetClr') = 'UNDEFINED' THEN ; generated for fun
+VsSetClr		EQU			7						; on READs, always reads 0
+	ENDIF ; generated for fun
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
+													;  			0 = 1-bits in bits 0-6 write 0's
+
+;  ======  Interrupt Flags Enable   Address: $50026013	 =====
+	IF &TYPE('VsSCSIDRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('VsAnySlotEn') = 'UNDEFINED' THEN ; generated for fun
+VsAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled
+	ENDIF ; generated for fun
+;*VsResr		EQU			2						; reserved
+	IF &TYPE('VsSCSIRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('VsSndIRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
+	ENDIF ; generated for fun
+;VsResr			EQU 		5 						; reserved
+;VsResr			EQU 		6 						; reserved
+;RvSetClr		EQU			7						; on READs, always reads 1
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
+													;  			0 = 1-bits in bits 0-6 write 0's
+
+
+;----------
+; V8 register definitions - generally compatible with the VISA equates above, but a few equates
+;	have changed names.
+;----------
+
+; these registers are accessed off of the V8 lomem
+	IF &TYPE('V8Exp') = 'UNDEFINED' THEN ; generated for fun
+V8Exp			EQU			$001					; V8 Expansion Register
+	ENDIF ; generated for fun
+	IF &TYPE('V8SInt') = 'UNDEFINED' THEN ; generated for fun
+V8SInt			EQU			$002					; V8 Slot Interrupt Register
+	ENDIF ; generated for fun
+	IF &TYPE('V8MonP') = 'UNDEFINED' THEN ; generated for fun
+V8MonP			EQU			$010					; Monitor Parameters Register
+	ENDIF ; generated for fun
+	IF &TYPE('V8SEnb') = 'UNDEFINED' THEN ; generated for fun
+V8SEnb			EQU			$012					; Slot Interrupt Enable Register
+	ENDIF ; generated for fun
+
+;  ======  Future Expansion   Address: $50F26001	 =====
+	IF &TYPE('V8A2Mode') = 'UNDEFINED' THEN ; generated for fun
+V8A2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
+	ENDIF ; generated for fun
+	IF &TYPE('V8512Row') = 'UNDEFINED' THEN ; generated for fun
+V8512Row		EQU			1						; 1=V8 rowbytes is 256, 0=rowbytes is 512
+	ENDIF ; generated for fun
+	IF &TYPE('V8vRAMIn') = 'UNDEFINED' THEN ; generated for fun
+V8vRAMIn	 	EQU			2						; 1=refresh video from vRAM, 0=refresh from dRAM
+	ENDIF ; generated for fun
+;*V8Resr		EQU			3						; no 1BV on V8
+;*V8Resr		EQU			4						; no VP2 on V8
+	IF &TYPE('V8Siz0') = 'UNDEFINED' THEN ; generated for fun
+V8Siz0			EQU			5						; RAM size control bit 0
+	ENDIF ; generated for fun
+	IF &TYPE('V8Siz1') = 'UNDEFINED' THEN ; generated for fun
+V8Siz1			EQU			6						; RAM size control bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('V8Siz2') = 'UNDEFINED' THEN ; generated for fun
+V8Siz2			EQU			7						; RAM size control bit 2
+	ENDIF ; generated for fun
+
+;  ======  Monitor Parameters   Address: $50F26010	 =====
+	IF &TYPE('V8Col0') = 'UNDEFINED' THEN ; generated for fun
+V8Col0			EQU			0						; Video depth control bit 0
+	ENDIF ; generated for fun
+	IF &TYPE('V8Col1') = 'UNDEFINED' THEN ; generated for fun
+V8Col1			EQU			1						; Video depth control bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('V8Col2') = 'UNDEFINED' THEN ; generated for fun
+V8Col2			EQU			2						; Video depth control bit 2
+	ENDIF ; generated for fun
+	IF &TYPE('V8MonID1') = 'UNDEFINED' THEN ; generated for fun
+V8MonID1		EQU			3						; Monitor sense ID bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('V8MonID2') = 'UNDEFINED' THEN ; generated for fun
+V8MonID2		EQU			4						; Monitor sense ID bit 2
+	ENDIF ; generated for fun
+	IF &TYPE('V8MonID3') = 'UNDEFINED' THEN ; generated for fun
+V8MonID3		EQU			5						; Monitor sense ID bit 3
+	ENDIF ; generated for fun
+;*VsResr		EQU 		6 						; reserved
+;*VsResr		EQU			7						; reserved
+
+;  ======  Slot Interrupts Enable   Address: $50F26012	 =====
+;*V8Resr		EQU			0						; reserved
+;*V8Resr		EQU			1						; reserved
+;*V8Resr		EQU			2						; reserved
+;*V8Resr		EQU			3						; reserved
+;*V8Resr		EQU			4						; reserved
+	IF &TYPE('V8ExtIRQEn') = 'UNDEFINED' THEN ; generated for fun
+V8ExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('V8IntIRQEn') = 'UNDEFINED' THEN ; generated for fun
+V8IntIRQEn		EQU 		6 						; internal video interrupt enabled
+	ENDIF ; generated for fun
+;*V8Resr		EQU			7						; reserved
+
+
+;----------
+; Elsie VDAC register definitions
+;----------
+
+; VISA/Bt450 registers
+
+	IF &TYPE('VsDACwAddReg') = 'UNDEFINED' THEN ; generated for fun
+VsDACwAddReg	EQU			$0000					;   offset from vDACBase for write address reg
+	ENDIF ; generated for fun
+	IF &TYPE('VsDACwDataReg') = 'UNDEFINED' THEN ; generated for fun
+VsDACwDataReg	EQU			$0001					;   offset from vDACBase for write data reg
+	ENDIF ; generated for fun
+
+; V8/Ariel registers
+
+	IF &TYPE('V8DACrAddReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACrAddReg	EQU			$0000					; offset for read address reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACwAddReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACwAddReg	EQU			$0000					; offset for write address reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACrDataReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACrDataReg	EQU			$0001					; offset for read data reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACwDataReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACwDataReg	EQU			$0001					; offset for write data reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACrCntlReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACrCntlReg	EQU			$0002					; offset for read control reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACwCntlReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACwCntlReg	EQU			$0002					; offset for write control reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACrKeyReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACrKeyReg	EQU			$0003					; offset for read key color reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACwKeyReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACwKeyReg	EQU			$0003					; offset for write key color reg
+	ENDIF ; generated for fun
+
+	IF &TYPE('V8vRAMBase') = 'UNDEFINED' THEN ; generated for fun
+V8vRAMBase		EQU			$50F40000				; base address of V8 VRAM, if present
+	ENDIF ; generated for fun
+
+; End of VISA changes								<4> <cv>
+
+
+;----------
+; DAFB register definitions (offsets from DAFBBase in ProductInfo) ($F980 0000)
+;----------
+
+	IF &TYPE('DAFB_BaseOffset') = 'UNDEFINED' THEN ; generated for fun
+DAFB_BaseOffset		EQU			$0				; DAFB offset from DAFBBase
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_ParmSize') = 'UNDEFINED' THEN ; generated for fun
+DAFB_ParmSize		EQU			$5				; size of DAFB programmed subset
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_NumRegs') = 'UNDEFINED' THEN ; generated for fun
+DAFB_NumRegs		Equ			(16-4)			; Number of DAFB registers (Color Regs are really vRAM).
+	ENDIF ; generated for fun
+
+	IF &TYPE('DAFB_VidBaseHi') = 'UNDEFINED' THEN ; generated for fun
+DAFB_VidBaseHi		EQU			$0				; DAFB video base address, bits 20:9
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_VidBaseLo') = 'UNDEFINED' THEN ; generated for fun
+DAFB_VidBaseLo		EQU			$4				; DAFB video base address, bits 8:5 (4:0 always zero)
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_RowWords') = 'UNDEFINED' THEN ; generated for fun
+DAFB_RowWords		EQU			$8				; DAFB rowlongs size
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_ClkCfg') = 'UNDEFINED' THEN ; generated for fun
+DAFB_ClkCfg			EQU			$C				; DAFB clock configuration
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_Config') = 'UNDEFINED' THEN ; generated for fun
+DAFB_Config			EQU			$10				; DAFB general configuration
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_BlkWrtEn') = 'UNDEFINED' THEN ; generated for fun
+DAFB_BlkWrtEn		EQU			$14				; DAFB block write enable
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_PgMdEn') = 'UNDEFINED' THEN ; generated for fun
+DAFB_PgMdEn			EQU			$18				; DAFB page mode enable
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_Sense') = 'UNDEFINED' THEN ; generated for fun
+DAFB_Sense			EQU			$1C				; DAFB sense line
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_Reset') = 'UNDEFINED' THEN ; generated for fun
+DAFB_Reset			EQU			$20				; DAFB reset control
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_SCSIch0') = 'UNDEFINED' THEN ; generated for fun
+DAFB_SCSIch0		EQU			$24				; Turbo SCSI channel 0 control (not used)
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_SCSIch1') = 'UNDEFINED' THEN ; generated for fun
+DAFB_SCSIch1		EQU			$28				; Turbo SCSI channel 1 control (not used)
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_Test') = 'UNDEFINED' THEN ; generated for fun
+DAFB_Test			EQU			$2C				; DAFB test control
+	ENDIF ; generated for fun
+
+	IF &TYPE('DAFB_CRB0') = 'UNDEFINED' THEN ; generated for fun
+DAFB_CRB0			EQU			$30				; vRAM Color Register, bank 0
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_CRB1') = 'UNDEFINED' THEN ; generated for fun
+DAFB_CRB1			EQU			$34				; vRAM Color Register, bank 1
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_CRB2') = 'UNDEFINED' THEN ; generated for fun
+DAFB_CRB2			EQU			$38				; vRAM Color Register, bank 2
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_CRB3') = 'UNDEFINED' THEN ; generated for fun
+DAFB_CRB3			EQU			$3C				; vRAM Color Register, bank 3
+	ENDIF ; generated for fun
+
+;----------
+; Swatch (in DAFB) register definitions (offsets from DAFBBase in ProductInfo)
+;----------
+
+	IF &TYPE('Swatch_BaseOffset') = 'UNDEFINED' THEN ; generated for fun
+Swatch_BaseOffset	EQU			$100			; Swatch offset from DAFBBase
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_BaseOffset1') = 'UNDEFINED' THEN ; generated for fun
+Swatch_BaseOffset1	EQU			$124			; parameter offset
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ParmSize1') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ParmSize1	EQU			$12				; size of Swatch parameter list
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_NumRegs') = 'UNDEFINED' THEN ; generated for fun
+Swatch_NumRegs		Equ			30				; Number of Swatch registers.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Swatch_Mode') = 'UNDEFINED' THEN ; generated for fun
+Swatch_Mode			EQU			$100			; Swatch general control
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_IntMsk') = 'UNDEFINED' THEN ; generated for fun
+Swatch_IntMsk		EQU			$104			; Swatch interrupt control
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_IntStat') = 'UNDEFINED' THEN ; generated for fun
+Swatch_IntStat		EQU			$108			; Swatch interrupt status
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ClrCrsrInt') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ClrCrsrInt	EQU			$10C			; Swatch clear cursor interrupt (not used in this form)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ClrAnimInt') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ClrAnimInt	EQU			$110			; Swatch clear animation interrupt (not used in this form)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ClrVBLInt') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ClrVBLInt	EQU			$114			; Swatch clear VBL interrupt (not used in this form)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_CrsrLine') = 'UNDEFINED' THEN ; generated for fun
+Swatch_CrsrLine		EQU			$118			; Swatch cursor interrupt trigger line
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_AnimLine') = 'UNDEFINED' THEN ; generated for fun
+Swatch_AnimLine		EQU			$11C			; Swatch animation interrupt trigger line
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_Test') = 'UNDEFINED' THEN ; generated for fun
+Swatch_Test			EQU			$120			; Swatch counter test
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HSyncRegs') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HSyncRegs	EQU			$124			; Swatch horizontal sync registers (set as a group)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HSerr') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HSerr		Equ			$124			;   HSerr
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_Hlfln') = 'UNDEFINED' THEN ; generated for fun
+Swatch_Hlfln		Equ			$128			;   Hlfln
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HEq') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HEq			Equ			$12C			;   HEq
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HSP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HSP			Equ			$130			;   HSP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HBWay') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HBWay		Equ			$134			;   HBWay
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HBrst') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HBrst		Equ			$138			;   HBrst
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HBP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HBP			Equ			$13C			;   HBP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HAL') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HAL			Equ			$140			;   HAL
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HFP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HFP			Equ			$144			;   HFP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HPix') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HPix			Equ			$148			;   HPix
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VSyncRegs') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VSyncRegs	EQU			$14C			; Swatch vertical sync registers (set as a group)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VHLine') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VHLine		Equ			$14C			;	VHLine
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VSync') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VSync		Equ			$150			;	VSync
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VBPEq') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VBPEq		Equ			$154			;	VBPEq
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VBP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VBP			Equ			$158			;	VBP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VAL') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VAL			Equ			$15C			;	VAL
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VFP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VFP			Equ			$160			;	VFP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VFPEq') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VFPEq		Equ			$164			;	VFPEq
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_TimeAdj') = 'UNDEFINED' THEN ; generated for fun
+Swatch_TimeAdj		EQU			$168			; Swatch miscellaneous timing adjust
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ActLine') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ActLine		EQU			$16C			; Swatch active video line (read-only)
+	ENDIF ; generated for fun
+
+;----------
+; ACDC register definitions (offsets from DAFBBase in ProductInfo, also in vDACBase)
+;----------
+
+	IF &TYPE('ACDC_AddrReg') = 'UNDEFINED' THEN ; generated for fun
+ACDC_AddrReg		EQU			$200			; set position in ACDC internal RAM
+	ENDIF ; generated for fun
+	IF &TYPE('ACDC_DataReg') = 'UNDEFINED' THEN ; generated for fun
+ACDC_DataReg		EQU			$210			; read/write data in ACDC internal RAM
+	ENDIF ; generated for fun
+	IF &TYPE('ACDC_ConfigReg') = 'UNDEFINED' THEN ; generated for fun
+ACDC_ConfigReg		EQU			$220			; ACDC offset from DAFBBase
+	ENDIF ; generated for fun
+	IF &TYPE('ACDC_ParmSize') = 'UNDEFINED' THEN ; generated for fun
+ACDC_ParmSize		EQU			$1				; size of ACDC parameter list
+	ENDIF ; generated for fun
+
+
+;----------
+; National Clock Chip register definitions (offsets from DAFBBase in ProductInfo)
+;----------
+
+	IF &TYPE('Clk_BaseOffset') = 'UNDEFINED' THEN ; generated for fun
+Clk_BaseOffset		EQU			$300			; National offset from DAFBBase
+	ENDIF ; generated for fun
+	IF &TYPE('Clk_ParmSize') = 'UNDEFINED' THEN ; generated for fun
+Clk_ParmSize		EQU			$10 			; size of National parameter list
+	ENDIF ; generated for fun
+	IF &TYPE('Clk_ParmSize1') = 'UNDEFINED' THEN ; generated for fun
+Clk_ParmSize1		Equ			$0A				; (Once programmed, the last six bytes are always the same.)
+	ENDIF ; generated for fun
+
+;----------
+; Misc. DAFB Parms
+;----------
+	IF &TYPE('Misc_ParmSize') = 'UNDEFINED' THEN ; generated for fun
+Misc_ParmSize		Equ			$4				; Just for consistency with other DAFB parms.
+	ENDIF ; generated for fun
+
+
+;----------
+; GSC register definitions (offsets from VDACAddr in ProductInfo) ($50F2 0000)					<H5> jmp
+;----------
+	IF &TYPE('GSCDeviceID') = 'UNDEFINED' THEN ; generated for fun
+GSCDeviceID			Equ		$00						; Device revision register; read only.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelID') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelID			Equ		$01						; “Senseline” read/write register.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelControl') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelControl		Equ		$02						; Switches r/w sense of PanelID reg.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelSetup') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelSetup		Equ		$03						; Panel intialization register.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCGrayScale') = 'UNDEFINED' THEN ; generated for fun
+GSCGrayScale		Equ		$04						; The depth-switching register.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPolyAdj') = 'UNDEFINED' THEN ; generated for fun
+GSCPolyAdj			Equ		$05						; Allows for grayscale adjustment.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelAdj') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelAdj			Equ		$06						; Allows for panel adjustment.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCACDClk') = 'UNDEFINED' THEN ; generated for fun
+GSCACDClk			Equ		$07						; Who knows?
+	ENDIF ; generated for fun
+	IF &TYPE('GSCRefreshRate') = 'UNDEFINED' THEN ; generated for fun
+GSCRefreshRate		Equ		$08						; Refresh cycles per scanline.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCBlankShade') = 'UNDEFINED' THEN ; generated for fun
+GSCBlankShade		Equ		$09						; Shade of gray for depth switches.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelSkew') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelSkew		Equ		$0A						; Who knows?
+	ENDIF ; generated for fun
+
+	IF &TYPE('GSCDiag0') = 'UNDEFINED' THEN ; generated for fun
+GSCDiag0			Equ		$1D						; Undocumented “diagnostic” registers.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCDiag1') = 'UNDEFINED' THEN ; generated for fun
+GSCDiag1			Equ		$1E
+	ENDIF ; generated for fun
+	IF &TYPE('GSCDiag2') = 'UNDEFINED' THEN ; generated for fun
+GSCDiag2			Equ		$1F
+	ENDIF ; generated for fun
+
+
+;----------
+; Sonora register definitions (offsets from SonoraAddr in ProductInfo) ($50F0 0000)				<H4><H6>
+;----------
+
+	IF &TYPE('SonoraVIA2Base') = 'UNDEFINED' THEN ; generated for fun
+SonoraVIA2Base	Equ			$26000					; Base address of VIA2
+	ENDIF ; generated for fun
+
+	IF &TYPE('SonoraVIA2Data') = 'UNDEFINED' THEN ; generated for fun
+SonoraVIA2Data	Equ			$00						; VIA2 Data Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraRAMSize') = 'UNDEFINED' THEN ; generated for fun
+SonoraRAMSize	EQU			$01						; DRAM config
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraSlotIFR') = 'UNDEFINED' THEN ; generated for fun
+SonoraSlotIFR	Equ			$02						; Slot Interrupt Flags Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVIA2IFR') = 'UNDEFINED' THEN ; generated for fun
+SonoraVIA2IFR	Equ			$03						; VIA2 Interrupt Flags Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVRAMSize') = 'UNDEFINED' THEN ; generated for fun
+SonoraVRAMSize	Equ			$04						; VRAM config
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraSpeedReg') = 'UNDEFINED' THEN ; generated for fun
+SonoraSpeedReg	Equ			$05						; System CPU Speed (waitstate) Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraSlotIER') = 'UNDEFINED' THEN ; generated for fun
+SonoraSlotIER	Equ			$12						; Slot Interrupt Enable Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVIA2IER') = 'UNDEFINED' THEN ; generated for fun
+SonoraVIA2IER	Equ			$13						; Interrupt Flag Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVdCtlBase') = 'UNDEFINED' THEN ; generated for fun
+SonoraVdCtlBase	Equ			$28000					; Base address of video control registers
+	ENDIF ; generated for fun
+
+	IF &TYPE('SonoraVdModeReg') = 'UNDEFINED' THEN ; generated for fun
+SonoraVdModeReg	Equ			$00						; Monitor code and video blanking register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVdColrReg') = 'UNDEFINED' THEN ; generated for fun
+SonoraVdColrReg Equ			$01						; Framebuffer pixel depth control register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVdSenseRg') = 'UNDEFINED' THEN ; generated for fun
+SonoraVdSenseRg	Equ			$02						; Senseline register
+	ENDIF ; generated for fun
+
+; Bits for Misc Sonora Regs
+;
+	IF &TYPE('SonoraSetClr') = 'UNDEFINED' THEN ; generated for fun
+SonoraSetClr	Equ			7						; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
+	ENDIF ; generated for fun
+													;  			 0 = 1-bits in bits 0-6 write 0's
+
+; Bits for SonoraSlotIER
+;
+	IF &TYPE('SonoraVBLIRQEn') = 'UNDEFINED' THEN ; generated for fun
+SonoraVBLIRQEn	Equ			6						; Enable/Disable built-in video VBL
+	ENDIF ; generated for fun
+
+;----------
+; Ariel register definitions (offsets from VDACAddr in ProductInfo) ($50F2 4000)				<H6>
+;----------
+	IF &TYPE('ArielAddrReg') = 'UNDEFINED' THEN ; generated for fun
+ArielAddrReg	Equ			0						; Offset to r/w address register
+	ENDIF ; generated for fun
+	IF &TYPE('ArielDataReg') = 'UNDEFINED' THEN ; generated for fun
+ArielDataReg	Equ			1						; Offset to r/w data register
+	ENDIF ; generated for fun
+	IF &TYPE('ArielConfigReg') = 'UNDEFINED' THEN ; generated for fun
+ArielConfigReg	Equ			2						; Offset to r/w control register
+	ENDIF ; generated for fun
+	IF &TYPE('ArielKeyReg') = 'UNDEFINED' THEN ; generated for fun
+ArielKeyReg		Equ			3						; Offset to r/w key color register
+	ENDIF ; generated for fun
+
+
+;----------
+; MMC register definitions (offsets from MMCAddr in ProductInfo) ($50F3 0400)				<P2><SM4> rb, start
+;----------
+
+	IF &TYPE('MMC_DRAMspeed0') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMspeed0	EQU			$00						; DRAM timing register 0 [M0].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMspeed1') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMspeed1	EQU			$04						; DRAM timing register 1 [M1].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_CPUspeed0') = 'UNDEFINED' THEN ; generated for fun
+MMC_CPUspeed0	EQU			$08						; Clock speed 0 [M2].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_CPUspeed1') = 'UNDEFINED' THEN ; generated for fun
+MMC_CPUspeed1	EQU			$0C						; Clock speed 1 [M3].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_ROMspeed0') = 'UNDEFINED' THEN ; generated for fun
+MMC_ROMspeed0	EQU			$10						; ROM cycle time 0 [M4].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_ROMspeed1') = 'UNDEFINED' THEN ; generated for fun
+MMC_ROMspeed1	EQU			$14						; ROM cycle time 1 [M5].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_ROMspeed2') = 'UNDEFINED' THEN ; generated for fun
+MMC_ROMspeed2	EQU			$18						; ROM cycle time 2 [M6].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_DSPspeed') = 'UNDEFINED' THEN ; generated for fun
+MMC_DSPspeed	EQU			$1C						; DSP clock speed [M7].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_DRAMwidth0') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMwidth0	EQU			$20						; DRAM width 0 [M8].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMwidth1') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMwidth1	EQU			$24						; DRAM width 1 [M9].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMwidth2') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMwidth2	EQU			$28						; DRAM width 2 [M10].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMwidth3') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMwidth3	EQU			$2C						; DRAM width 3 [M11].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_EPROMmode') = 'UNDEFINED' THEN ; generated for fun
+MMC_EPROMmode	EQU			$30						; EPROM mode [M12].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_DRAMrange2') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMrange2	EQU			$34						; DRAM bank range 0 [M13].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMrange1') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMrange1	EQU			$38						; DRAM bank range 1 [M14].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMrange0') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMrange0	EQU			$3C						; DRAM bank range 2 [M15].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_CPUID0') = 'UNDEFINED' THEN ; generated for fun
+MMC_CPUID0		EQU			$40						; CPU ID 0 [M16].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_CPUID1') = 'UNDEFINED' THEN ; generated for fun
+MMC_CPUID1		EQU			$44						; CPU ID 1 [M17].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_ClockSelect') = 'UNDEFINED' THEN ; generated for fun
+MMC_ClockSelect	EQU			$48						; Endeavor Input Clock Select (NTSC/PAL) [M18].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_Bypass') = 'UNDEFINED' THEN ; generated for fun
+MMC_Bypass		EQU			$4C						; RGB or Composite bypass [M19].
+	ENDIF ; generated for fun
+
+;----------
+; MUNI (NuBus) register definitions																<P6>
+;----------
+
+; <SM7> rb, • TEMP for EVT1							;											<SM7> rb
+
+	IF &TYPE('MUNIBaseEVT1') = 'UNDEFINED' THEN ; generated for fun
+MUNIBaseEVT1	EQU			$50F30800				; Base address of Muni for EVT1				<SM9> rb
+	ENDIF ; generated for fun
+
+
+	IF &TYPE('MUNIBase') = 'UNDEFINED' THEN ; generated for fun
+MUNIBase		EQU			$50F30000				; Base address of Muni.						<SM7> rb
+	ENDIF ; generated for fun
+
+
+
+	IF &TYPE('MUNI_IntCntrl') = 'UNDEFINED' THEN ; generated for fun
+MUNI_IntCntrl	EQU			$00						; Interrupt control register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_IntStatus') = 'UNDEFINED' THEN ; generated for fun
+MUNI_IntStatus	EQU			$04						; Interrupt status register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_Control') = 'UNDEFINED' THEN ; generated for fun
+MUNI_Control	EQU			$08						; System control register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_BlkAttmpt') = 'UNDEFINED' THEN ; generated for fun
+MUNI_BlkAttmpt	EQU			$0C						; Block attempt register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_Status') = 'UNDEFINED' THEN ; generated for fun
+MUNI_Status		EQU			$10						; Status register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_Test') = 'UNDEFINED' THEN ; generated for fun
+MUNI_Test		EQU			$14						; Test control register.
+	ENDIF ; generated for fun
+
+;----------
+; Civic register definitions (offsets from CivicAddr in ProductInfo) ($50F3 6000)
+;----------
+
+	IF &TYPE('Civic_VBLInt') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBLInt	Equ			$000					; Read-only VBL flag register
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VBLEnb') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBLEnb	Equ			$110					; Enables VBL interrupt.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VBLClr') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBLClr	Equ			$120					; Clear VBL interrupt.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_Enable') = 'UNDEFINED' THEN ; generated for fun
+Civic_Enable	Equ			$004					; Enables Civic’s timing generator (Casio).
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Reset') = 'UNDEFINED' THEN ; generated for fun
+Civic_Reset		Equ			$10C					; Resets Casio.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VDCInt') = 'UNDEFINED' THEN ; generated for fun
+Civic_VDCInt	Equ			$008					; Read-only VDC flag register.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VDCClr') = 'UNDEFINED' THEN ; generated for fun
+Civic_VDCClr	Equ			$00C					; Clears VDC interrupt.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VDCEnb') = 'UNDEFINED' THEN ; generated for fun
+Civic_VDCEnb	Equ			$010					; Enables VDC interrupt.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VDCClk') = 'UNDEFINED' THEN ; generated for fun
+Civic_VDCClk	Equ			$018					; Enables VDC clock.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VidInSize') = 'UNDEFINED' THEN ; generated for fun
+Civic_VidInSize	Equ			$014					; Controls video-in Rows (1024 vs. 1536 bytes).
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VidInDble') = 'UNDEFINED' THEN ; generated for fun
+Civic_VidInDble	Equ			$208					; Controls whether Civic Doubles each Video-in Field
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_ScanCtl') = 'UNDEFINED' THEN ; generated for fun
+Civic_ScanCtl	Equ			$01C					; Controls progressive vs. interlaced scans.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_GSCDivide') = 'UNDEFINED' THEN ; generated for fun
+Civic_GSCDivide	Equ			$020					; Controls graphics clock divide count.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VSCDivide') = 'UNDEFINED' THEN ; generated for fun
+Civic_VSCDivide	Equ			$02C					; Controls video-in clock divide count.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VRAMSize') = 'UNDEFINED' THEN ; generated for fun
+Civic_VRAMSize	Equ			$040					; Controls VRAM sizing (1 vs. 2 Mbytes).
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_RfrshCtl') = 'UNDEFINED' THEN ; generated for fun
+Civic_RfrshCtl	Equ			$044					; Controls the refresh mode.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_BusSize') = 'UNDEFINED' THEN ; generated for fun
+Civic_BusSize	Equ			$04C					; Controls the bus size (32 vs. 64 bits).
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_SpeedCtl') = 'UNDEFINED' THEN ; generated for fun
+Civic_SpeedCtl	Equ			$050					; Controls the timing (25 vs. 33 MHz).
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_ConvEnb') = 'UNDEFINED' THEN ; generated for fun
+Civic_ConvEnb	Equ			$054					; Enables convolution.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_ReadSense') = 'UNDEFINED' THEN ; generated for fun
+Civic_ReadSense	Equ			$088					; Sense-line registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_SenseCtl') = 'UNDEFINED' THEN ; generated for fun
+Civic_SenseCtl	Equ			$058					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Sense0') = 'UNDEFINED' THEN ; generated for fun
+Civic_Sense0	Equ			$05C					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Sense1') = 'UNDEFINED' THEN ; generated for fun
+Civic_Sense1	Equ			$060					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Sense2') = 'UNDEFINED' THEN ; generated for fun
+Civic_Sense2	Equ			$064					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_SenseTst') = 'UNDEFINED' THEN ; generated for fun
+Civic_SenseTst	Equ			$068					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_SyncClr') = 'UNDEFINED' THEN ; generated for fun
+Civic_SyncClr	Equ			$06C					; Disables RGB (Sync) output.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_BaseAddr') = 'UNDEFINED' THEN ; generated for fun
+Civic_BaseAddr	Equ			$0C0					; Base address of active video.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_RowWords') = 'UNDEFINED' THEN ; generated for fun
+Civic_RowWords	Equ			$094					; Row long words of active video.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_AdjF1') = 'UNDEFINED' THEN ; generated for fun
+Civic_AdjF1		Equ			$128					; Timing adjust registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_AdjF2') = 'UNDEFINED' THEN ; generated for fun
+Civic_AdjF2		Equ			$124					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Piped') = 'UNDEFINED' THEN ; generated for fun
+Civic_Piped		Equ			$440					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_HSerr') = 'UNDEFINED' THEN ; generated for fun
+Civic_HSerr		Equ			$180					; Horizontal timing registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HlfLn') = 'UNDEFINED' THEN ; generated for fun
+Civic_HlfLn		Equ			$280					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HEq') = 'UNDEFINED' THEN ; generated for fun
+Civic_HEq		Equ			$2C0					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HSP') = 'UNDEFINED' THEN ; generated for fun
+Civic_HSP		Equ			$300					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HBWay') = 'UNDEFINED' THEN ; generated for fun
+Civic_HBWay		Equ			$340					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HAL') = 'UNDEFINED' THEN ; generated for fun
+Civic_HAL		Equ			$380					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HFP') = 'UNDEFINED' THEN ; generated for fun
+Civic_HFP		Equ			$3C0					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HPix') = 'UNDEFINED' THEN ; generated for fun
+Civic_HPix		Equ			$400					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VHLine') = 'UNDEFINED' THEN ; generated for fun
+Civic_VHLine	Equ			$480					; Vertical timing registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VSync') = 'UNDEFINED' THEN ; generated for fun
+Civic_VSync		Equ			$4C0					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VBPEqu') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBPEqu	Equ			$500					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VBP') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBP		Equ			$540					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VAL') = 'UNDEFINED' THEN ; generated for fun
+Civic_VAL		Equ			$580					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VFP') = 'UNDEFINED' THEN ; generated for fun
+Civic_VFP		Equ			$640					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VFPEqu') = 'UNDEFINED' THEN ; generated for fun
+Civic_VFPEqu	Equ			$680					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_CurLine') = 'UNDEFINED' THEN ; generated for fun
+Civic_CurLine	Equ			$6C0					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VInHAL') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInHAL	Equ			$1C0					; Video-in timing registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VInHFPD') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInHFPD	Equ			$200					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VInHFP') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInHFP	Equ			$240					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VInVAL') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInVAL	Equ			$5C0					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VInVFP') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInVFP	Equ			$600					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_HLDB') = 'UNDEFINED' THEN ; generated for fun
+Civic_HLDB		Equ			$114					; Horizontal test/control registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HHLTB') = 'UNDEFINED' THEN ; generated for fun
+Civic_HHLTB		Equ			$118					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HActHi') = 'UNDEFINED' THEN ; generated for fun
+Civic_HActHi	Equ			$11C
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VLDB') = 'UNDEFINED' THEN ; generated for fun
+Civic_VLDB		Equ			$100					; VSync test/control registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VHLTB') = 'UNDEFINED' THEN ; generated for fun
+Civic_VHLTB		Equ			$104					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VActHi') = 'UNDEFINED' THEN ; generated for fun
+Civic_VActHi	Equ			$108					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_TestEnb') = 'UNDEFINED' THEN ; generated for fun
+Civic_TestEnb	Equ			$12C					; Enables Casio test mode.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_CntTest') = 'UNDEFINED' THEN ; generated for fun
+Civic_CntTest	Equ			$140					; Count test register.
+	ENDIF ; generated for fun
+
+;----------
+; Sebastian register definitions (offsets from SebastianAddr in ProductInfo) ($50F3 0000)
+;----------
+
+	IF &TYPE('SebastAddrReg') = 'UNDEFINED' THEN ; generated for fun
+SebastAddrReg	Equ			$000					; CLUT/DAC Address register.
+	ENDIF ; generated for fun
+	IF &TYPE('SebastDataReg') = 'UNDEFINED' THEN ; generated for fun
+SebastDataReg	Equ			$010					; CLUT/DAC Data register.
+	ENDIF ; generated for fun
+	IF &TYPE('SebastPCBR') = 'UNDEFINED' THEN ; generated for fun
+SebastPCBR		Equ			$020					; CLUT/DAC Pixel Bus Control register.
+	ENDIF ; generated for fun
+
+;----------
+; Endeavor register definitions
+;----------
+
+	IF &TYPE('Endeavor') = 'UNDEFINED' THEN ; generated for fun
+Endeavor		Equ			$50F2E000				; Base address of Endeavor in Cyclone.
+	ENDIF ; generated for fun
+
+	IF &TYPE('EndeavorM') = 'UNDEFINED' THEN ; generated for fun
+EndeavorM		Equ			$000					; 8-bit numerator.
+	ENDIF ; generated for fun
+	IF &TYPE('EndeavorN') = 'UNDEFINED' THEN ; generated for fun
+EndeavorN		Equ			$010					; 8-bit denominator.
+	ENDIF ; generated for fun
+	IF &TYPE('EndeavorClk') = 'UNDEFINED' THEN ; generated for fun
+EndeavorClk		Equ			$020					; Clock select (A or B).
+	ENDIF ; generated for fun
+
+;----------
+; MSC register definitions (offsets from MSCAddr in ProductInfo) ($50F2 6000)
+;----------
+
+	IF &TYPE('MSCSlotIFR') = 'UNDEFINED' THEN ; generated for fun
+MSCSlotIFR		EQU			$02						; slots interrupt flags
+	ENDIF ; generated for fun
+	IF &TYPE('MSCVIA2IFR') = 'UNDEFINED' THEN ; generated for fun
+MSCVIA2IFR		EQU			$03						; VIA 2 interrupt flags
+	ENDIF ; generated for fun
+	IF &TYPE('MSCConfig') = 'UNDEFINED' THEN ; generated for fun
+MSCConfig		EQU			$10						; RAM, clock configuration
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSlotIER') = 'UNDEFINED' THEN ; generated for fun
+MSCSlotIER		EQU			$12						; slots interrupt enables
+	ENDIF ; generated for fun
+	IF &TYPE('MSCVIA2IER') = 'UNDEFINED' THEN ; generated for fun
+MSCVIA2IER		EQU			$13						; VIA 2 interrupt enables
+	ENDIF ; generated for fun
+	IF &TYPE('MSCClkCntl') = 'UNDEFINED' THEN ; generated for fun
+MSCClkCntl		EQU			$21						; peripherals clock control
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSndCntl') = 'UNDEFINED' THEN ; generated for fun
+MSCSndCntl		EQU			$22						; sound control
+	ENDIF ; generated for fun
+	IF &TYPE('MSCFlashWrEnb') = 'UNDEFINED' THEN ; generated for fun
+MSCFlashWrEnb	EQU			$23						; flash ROM write enable
+	ENDIF ; generated for fun
+	IF &TYPE('MSCPowerCycle') = 'UNDEFINED' THEN ; generated for fun
+MSCPowerCycle	EQU			$50FA0000-$50F26000		; CPU power off control register			<H2>
+	ENDIF ; generated for fun
+
+;  ======  VIA2 BufferB Equivalent		Address: $50F26000	 =====
+	IF &TYPE('MSCExpansion') = 'UNDEFINED' THEN ; generated for fun
+MSCExpansion	EQU			0						; 0 = enable on-board external cache (not currently used)
+	ENDIF ; generated for fun
+;v2PMack		EQU 		1 						; Power manager handshake acknowledge
+;v2PMreq		EQU 		2 						; Power manager handshake request
+;reserved3		EQU			3						; reserved
+;reserved4		EQU			4						; reserved
+;reserved5		EQU			5						; reserved
+;reserved6		EQU			6						; reserved
+;reserved7		EQU			7						; reserved
+
+;  ======  Slot Interrupt Flags			Address: $50F26002	 =====
+;reserved0		EQU			0						; reserved
+;reserved1		EQU			1						; reserved
+;reserved2		EQU			2						; reserved
+;reserved3		EQU			3						; reserved
+;reserved4		EQU			4						; reserved
+;RvIRQE			EQU 		5 						; slot E interrupt
+;RvIRQLCD		EQU			6						; LCD display VBL interrupt
+;reserved7		EQU			7						; reserved
+
+;  ======  VIA 2 Interrupt Flags		Address: $50F26003	 =====
+;RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt
+;RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
+;reserved2		EQU			2						; reserved
+;RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
+;RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup
+;reserved5		EQU			5						; reserved
+;reserved6		EQU			6						; reserved
+;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt
+
+;  ======  MSC Configuration			Address: $50F26010	 =====
+	IF &TYPE('MSC25MHz') = 'UNDEFINED' THEN ; generated for fun
+MSC25MHz		EQU			0						; 1 = 25MHz system, 0 = 33MHz system
+	ENDIF ; generated for fun
+	IF &TYPE('MSCEconoBit') = 'UNDEFINED' THEN ; generated for fun
+MSCEconoBit		EQU			1						; 1 = econo-mode enabled (switches to 16MHz)
+	ENDIF ; generated for fun
+	IF &TYPE('MSCFastROM') = 'UNDEFINED' THEN ; generated for fun
+MSCFastROM		EQU			2						; 1 = 100ns ROMs installed, 0 = 120ns ROMs installed
+	ENDIF ; generated for fun
+;reserved3		EQU			3						; reserved
+	IF &TYPE('MSCBank8M') = 'UNDEFINED' THEN ; generated for fun
+MSCBank8M		EQU			4						; 1 = banks 4-7 are 8MB, 0=banks 4-7 are 2MB
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSize0') = 'UNDEFINED' THEN ; generated for fun
+MSCSize0		EQU			5						; RAM size bit
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSize1') = 'UNDEFINED' THEN ; generated for fun
+MSCSize1		EQU			6						; RAM size bit
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSize2') = 'UNDEFINED' THEN ; generated for fun
+MSCSize2		EQU			7						; RAM size bit
+	ENDIF ; generated for fun
+
+;  ======  Slot Interrupt Enables		Address: $50F26012	 =====
+;reserved0		EQU			0						; reserved
+;reserved1		EQU			1						; reserved
+;reserved2		EQU			2						; reserved
+;reserved3		EQU			3						; reserved
+;reserved4		EQU			4						; reserved
+;RvIRQEEn		EQU 		5 						; slot E interrupt enabled
+;RvIRQLCDEn		EQU			6						; LCD display VBL interrupt enabled
+;RvSetClr		EQU			7						; on READs, always reads 0
+
+;  ======  VIA 2 Interrupt Enables		Address: $50F26013	 =====
+;RvSCSIDRQEn	EQU			0						; 1 = SCSI DRQ interrupt enabled
+;RvAnySlotEn	EQU			1						; 1 = any slot(0-6).IRQ int. enabled
+;reserved2		EQU			2						; reserved
+;RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
+;RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
+;reserved5		EQU			5						; reserved
+;reserved6		EQU			6						; reserved
+;RvSetClr		EQU			7						; on READs, always reads 0
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
+													;  			0 = 1-bits in bits 0-6 write 0's
+
+;  ======  Peripherals Clock Control	Address: $50F26021	 =====
+	IF &TYPE('MSCIOClk') = 'UNDEFINED' THEN ; generated for fun
+MSCIOClk		EQU			0						; 1=15.6672MHz I/O clock running, 0=stopped
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSCCClk') = 'UNDEFINED' THEN ; generated for fun
+MSCSCCClk		EQU			1						; 1=3.672MHz SCC clock running, 0=stopped
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSCSIReset') = 'UNDEFINED' THEN ; generated for fun
+MSCSCSIReset	EQU			2						; 1=SCSI reset not asserted, 0=reset asserted (clocks stop)
+	ENDIF ; generated for fun
+	IF &TYPE('MSCLCDReset') = 'UNDEFINED' THEN ; generated for fun
+MSCLCDReset		EQU			3						; 1=LCD reset not asserted, 0=reset asserted (clocks stop)
+	ENDIF ; generated for fun
+;reserved4		EQU			4						; reserved
+;reserved5		EQU			5						; reserved
+;reserved6		EQU			6						; reserved
+;reserved7		EQU			7						; reserved
+
+;  ======  Sound Control				Address: $50F26022	 =====
+	IF &TYPE('MSCSndPower') = 'UNDEFINED' THEN ; generated for fun
+MSCSndPower		EQU			0						; 1=DFAC power on, 0=DFAC power off
+	ENDIF ; generated for fun
+;reserved1		EQU			1						; reserved
+;reserved2		EQU			2						; reserved
+;reserved3		EQU			3						; reserved
+;reserved4		EQU			4						; reserved
+;reserved5		EQU			5						; reserved
+	IF &TYPE('MSCSndBusy') = 'UNDEFINED' THEN ; generated for fun
+MSCSndBusy		EQU			6						; 1=access to FIFO since last access to this register
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSndLatch') = 'UNDEFINED' THEN ; generated for fun
+MSCSndLatch		EQU			7						; 1=DFAC is powered up and initialized
+	ENDIF ; generated for fun
+
+
+	IF &TYPE('MSCDefConfig') = 'UNDEFINED' THEN ; generated for fun
+MSCDefConfig	EQU			(1<<MSC25MHz)|\			; 25MHz system								<H9>
+							(0<<MSCEconoBit)|\		; econo-mode disabled						<H9>
+							(0<<MSCFastROM)|\		; 120ns ROMs installed						<H9>
+							(0<<MSCBank8M)|\		; assume 2MB each in banks 4-7				<H19>
+							(%000<<MSCSize0)		; set 2MB so there's real RAM for BootBeep	<H10>
+	ENDIF ; generated for fun
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; Memory Controllers - Register Definitions and Misc Equates for Memory Controllers.  Included
+; are: FMC, ORWELL, JAWS, Niagra, Ponti, djMEMC, Pratt
+;
+;
+;__________________________________________________________________________________________
+
+
+;---------------------------------------------------
+;  FMC (Fitch Memory Controller) Equates
+;---------------------------------------------------
+
+	IF &TYPE('FMCConfig') = 'UNDEFINED' THEN ; generated for fun
+FMCConfig		equ			$0						; offset to configuration register.  It is a 16
+	ENDIF ; generated for fun
+													; bit wide register with a 1 bit wide data port
+													; on d24, so do byte writes (and rotates) and
+													; let dynamic bus sizing replicate it on d24-31.
+
+	IF &TYPE('FMCLatch') = 'UNDEFINED' THEN ; generated for fun
+FMCLatch		equ			$10						; offset to 'latch config data' register (latches
+	ENDIF ; generated for fun
+													; on a write to here)
+	IF &TYPE('FMCInit') = 'UNDEFINED' THEN ; generated for fun
+FMCInit			EQU			$F3EF					; config reg initial value				<4.5><4.6><4.9><1>
+	ENDIF ; generated for fun
+	IF &TYPE('FMCRPUInit') = 'UNDEFINED' THEN ; generated for fun
+FMCRPUInit		EQU			$F3FF					; config reg initial value (parity)		<1>
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+;  Orwell Memory Controller Equates	<5>
+;---------------------------------------------------
+
+;	Orwell only has one input/output data bit.  So to store or retrieve any configuration register
+;	information, you must read/write a succession of long-word addresses, starting at the addresses
+;	below, with the ONLY valid data bit being {reg}:0.  Valued being read must be assembled one bit
+;	at a time; values being written must be loaded into the config registers 1 bit at a time.  The
+;	new config. register values do not become active until a "latch" register address associated
+;	with the config. register is written.
+;
+;	The below addresses correspond to longword addresses where bit 0 of whatever data register used to
+;	read/write the location will be stored.  The Orwell configuration register is a 34-bit register,
+;	with each bit written to/read by addressing the appropriate longword offset.
+;
+;	The configuration register can be thought of like this:
+;
+;		+---------------------------------------------------------------------------------------------+
+;		| PAR_ODD | PAR_ENB | REFRESH | ROM_SPEED | DRAM_SPEED | CLK_SPEED | BANK_D | BANK_C | BANK_B |
+;		+---------------------------------------------------------------------------------------------+
+;			28        27     26     24 23       21  20       19     18      17   12  11    6  5      0
+;
+;																												<T6>
+;		+---------------------------------------------------------------------+									<T6>
+;		|    RAS    | Optional WRITE | Optional Read  | Optional Read  | Page |									<T6>
+;		| Precharge |   wait state   | 2nd wait state | 1st wait state | Mode |									<T6>
+;		+---------------------------------------------------------------------+									<T6>
+;			 33            32                31               30          29									<T6>
+
+;			***		Register Offsets	***
+
+	IF &TYPE('OrCfgRegAddr') = 'UNDEFINED' THEN ; generated for fun
+OrCfgRegAddr		EQU			0						; starting offset of config reg. bits
+	ENDIF ; generated for fun
+	IF &TYPE('OrCfgRegSize') = 'UNDEFINED' THEN ; generated for fun
+OrCfgRegSize		EQU			34						; number of bits in the configuration register				<T6>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrBankFieldSize') = 'UNDEFINED' THEN ; generated for fun
+OrBankFieldSize		EQU			6						; each bank config. reg. field is 6 bits wide
+	ENDIF ; generated for fun
+	IF &TYPE('OrBankBCfgAddr') = 'UNDEFINED' THEN ; generated for fun
+OrBankBCfgAddr		EQU			OrCfgRegAddr			; starting offset of BankB(5:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrBankCCfgAddr') = 'UNDEFINED' THEN ; generated for fun
+OrBankCCfgAddr		EQU			OrBankBCfgAddr+(4*OrBankFieldSize); starting offset of BankC(5:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrBankDCfgAddr') = 'UNDEFINED' THEN ; generated for fun
+OrBankDCfgAddr		EQU			OrBankCCfgAddr+(4*OrBankFieldSize); starting offset of BankD(5:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrClkSpeedAddr') = 'UNDEFINED' THEN ; generated for fun
+OrClkSpeedAddr		EQU			OrBankDCfgAddr+(4*OrBankFieldSize); starting address of Clock_Speed
+	ENDIF ; generated for fun
+														; ... Clock_Speed is 1 bit (0=25MHz)
+	IF &TYPE('OrDRAMSpeedAddr') = 'UNDEFINED' THEN ; generated for fun
+OrDRAMSpeedAddr		EQU			OrClkSpeedAddr+4		; starting address of DRAM Speed(1:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrDRAMFieldSize') = 'UNDEFINED' THEN ; generated for fun
+OrDRAMFieldSize		EQU			2						; DRAM speed config reg. field is 2 bits wide
+	ENDIF ; generated for fun
+	IF &TYPE('OrROMSpeedAddr') = 'UNDEFINED' THEN ; generated for fun
+OrROMSpeedAddr		EQU			OrDRAMSpeedAddr+(4*OrDRAMFieldSize); starting address of ROM Speed(2:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrROMFieldSize') = 'UNDEFINED' THEN ; generated for fun
+OrROMFieldSize		EQU			3						; ROM speed config reg. field is 3 bits wide
+	ENDIF ; generated for fun
+	IF &TYPE('OrRefreshAddr') = 'UNDEFINED' THEN ; generated for fun
+OrRefreshAddr		EQU			OrROMSpeedAddr+(4*OrROMFieldSize); starting address of Refresh Rate(2:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrRefreshSize') = 'UNDEFINED' THEN ; generated for fun
+OrRefreshSize		EQU			3						; Refresh speed config reg. field is 3 bits wide
+	ENDIF ; generated for fun
+	IF &TYPE('OrParityEnbAddr') = 'UNDEFINED' THEN ; generated for fun
+OrParityEnbAddr		EQU			OrRefreshAddr+(4*OrRefreshSize); starting address of parity enable/disable
+	ENDIF ; generated for fun
+														; ... Parity_Enable is 1 bit (0=parity OFF)
+	IF &TYPE('OrParityTypAddr') = 'UNDEFINED' THEN ; generated for fun
+OrParityTypAddr		EQU			OrParityEnbAddr+4		; starting address of parity type (even/odd)
+	ENDIF ; generated for fun
+														; ... Parity_Type is 1 bit (0=parity EVEN)
+	IF &TYPE('OrPageMode') = 'UNDEFINED' THEN ; generated for fun
+OrPageMode			EQU			OrParityTypAddr+4		;															<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrWaitRead1') = 'UNDEFINED' THEN ; generated for fun
+OrWaitRead1			EQU			OrPageMode+4			;															<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrWaitRead2') = 'UNDEFINED' THEN ; generated for fun
+OrWaitRead2			EQU			OrWaitRead1+4			;															<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrWaitWrite1') = 'UNDEFINED' THEN ; generated for fun
+OrWaitWrite1		EQU			OrWaitRead2+4			;															<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrRASPrecharge') = 'UNDEFINED' THEN ; generated for fun
+OrRASPrecharge		EQU			OrWaitWrite1+4			;															<T6>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrLatchOffset') = 'UNDEFINED' THEN ; generated for fun
+OrLatchOffset		EQU			$A0						; offset from start of config reg. where latches live		<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrwellLatches') = 'UNDEFINED' THEN ; generated for fun
+OrwellLatches		EQU			OrCfgRegAddr+OrLatchOffset; starting address of Latch Addresses						<T6>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrLoadBanks') = 'UNDEFINED' THEN ; generated for fun
+OrLoadBanks			EQU			OrwellLatches			; Load Bank Config Reg. Latch address						<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadSpeeds') = 'UNDEFINED' THEN ; generated for fun
+OrLoadSpeeds		EQU			OrLoadBanks+4			; Load Clock, DRAM and ROM Speeds Latch address
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadRefresh') = 'UNDEFINED' THEN ; generated for fun
+OrLoadRefresh		EQU			OrLoadSpeeds+4			; Load Refresh interval Latch address
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadParity') = 'UNDEFINED' THEN ; generated for fun
+OrLoadParity		EQU			OrLoadRefresh+4			; Load Parity enable/disable and type Latch address
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrLoadMode') = 'UNDEFINED' THEN ; generated for fun
+OrLoadMode			EQU			OrLoadParity+4			; Load Page Mode On/Off address								<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadWaitStates') = 'UNDEFINED' THEN ; generated for fun
+OrLoadWaitStates	EQU			OrLoadMode+4			; Load Read/Write extra waitstates address					<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadPrecharge') = 'UNDEFINED' THEN ; generated for fun
+OrLoadPrecharge		EQU			OrLoadWaitStates+4		; Load RAS precharge address								<T6>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrParityStatus') = 'UNDEFINED' THEN ; generated for fun
+OrParityStatus		EQU			$100					; A0-BC = LS 8 bits, C0-DC   = LM 8 bits					<T6>
+	ENDIF ; generated for fun
+														; E0-FC = HM 8 bits, 100-11C = MS 8 bits
+	IF &TYPE('OrParErrInByte0') = 'UNDEFINED' THEN ; generated for fun
+OrParErrInByte0		EQU			$180					; =1 if parity error occurred in byte 0
+	ENDIF ; generated for fun
+	IF &TYPE('OrParErrInByte1') = 'UNDEFINED' THEN ; generated for fun
+OrParErrInByte1		EQU			$184					; =1 if parity error occurred in byte 1
+	ENDIF ; generated for fun
+	IF &TYPE('OrParityError') = 'UNDEFINED' THEN ; generated for fun
+OrParityError		EQU			$188					; =1 if parity error occurred (period)
+	ENDIF ; generated for fun
+
+;			***		Initializing Values at Bootup Time		***
+
+	IF &TYPE('ORINITBankB') = 'UNDEFINED' THEN ; generated for fun
+ORINITBankB			EQU			$10						; 10=Bank B at 64MB
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITBankC') = 'UNDEFINED' THEN ; generated for fun
+ORINITBankC			EQU			$20						; 20=Bank C at 128MB
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITBankD') = 'UNDEFINED' THEN ; generated for fun
+ORINITBankD			EQU			$30						; 30=Bank D at 192MB
+	ENDIF ; generated for fun
+
+	IF &TYPE('ORINITClock25') = 'UNDEFINED' THEN ; generated for fun
+ORINITClock25		EQU			1						; 1=25MHz, 0=33MHz											<T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITClock33') = 'UNDEFINED' THEN ; generated for fun
+ORINITClock33		EQU			0						;															<T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITDRAMSpeed') = 'UNDEFINED' THEN ; generated for fun
+ORINITDRAMSpeed		EQU			1						; 0=100ns, 1=80ns, 2=60ns							<10>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITROMSpeed25') = 'UNDEFINED' THEN ; generated for fun
+ORINITROMSpeed25	EQU			2						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITROMSpeed33') = 'UNDEFINED' THEN ; generated for fun
+ORINITROMSpeed33	EQU			4						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITREFRESH25') = 'UNDEFINED' THEN ; generated for fun
+ORINITREFRESH25		EQU			2						; 0=25MHz 7.8µsec,  1=33MHz, 7.8µsec				<21>	<T12>
+	ENDIF ; generated for fun
+														; 2=25MHz 15.6µsec, 3=33MHz 15.6µsec				<21>	<T12>
+	IF &TYPE('ORINITREFRESH33') = 'UNDEFINED' THEN ; generated for fun
+ORINITREFRESH33		EQU			3						;													<21>	<T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITParity') = 'UNDEFINED' THEN ; generated for fun
+ORINITParity		EQU			0						; 0=parity OFF, 1=parity ON
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITParType') = 'UNDEFINED' THEN ; generated for fun
+ORINITParType		EQU			1						; 0=even, 1=odd
+	ENDIF ; generated for fun
+
+;	Additional (programmable) wait states for reads and writes
+
+	IF &TYPE('ORINITPageMode') = 'UNDEFINED' THEN ; generated for fun
+ORINITPageMode		EQU			0						; 0=off, 1=on												<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITWaitRd1') = 'UNDEFINED' THEN ; generated for fun
+ORINITWaitRd1		EQU			0						; 0=off, 1=on (unless Rd2 = 1, in which case it is interpreted as off)<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITWaitRd2') = 'UNDEFINED' THEN ; generated for fun
+ORINITWaitRd2		EQU			0						; 0=off, 1=on (unless Rd1 = 1, in which case it is interpreted as off)<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITWaitWr1') = 'UNDEFINED' THEN ; generated for fun
+ORINITWaitWr1		EQU			0						; 0=off, 1=on												<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITRAS25') = 'UNDEFINED' THEN ; generated for fun
+ORINITRAS25			EQU			0						; 0=2 cycles, 1=3 cycles 									<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITRAS33') = 'UNDEFINED' THEN ; generated for fun
+ORINITRAS33			EQU			1						;															<T12>
+	ENDIF ; generated for fun
+
+;	These are 32-bit constants that hold all but 2 bits of the initial defaults we									  .
+;	would want to jam into the Orwell configuration register.  These are arranged									  .
+;	in order the register is memory-mapped to facilitate the code that sticks them									  .
+;	in the register.  There are two bits that don't fit in a 32-bit constant, the									  .
+;	optional -OrWaitWrite1- and the not-so-optional -OrRASPrecharge-.  Those values									  .
+;	are used and initialized separately.																			  .
+
+	IF &TYPE('ORWELL_INIT25') = 'UNDEFINED' THEN ; generated for fun
+ORWELL_INIT25		EQU			\						;															<T6><T12>
+								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
+								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
+								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
+								(ORINITParType<<28)|\	; initial parity even/odd value
+								(ORINITParity<<27)|\	; initial parity on/off value
+								(ORINITREFRESH25<<24)|\	; initial refresh rate value								<T12>
+								(ORINITROMSpeed25<<21)|\; initial ROM speed value									<T12>
+								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
+								(ORINITClock25<<18)|\	; initial clock speed value									<T12>
+								(ORINITBankD<<12)|\		; initial Bank D starting address value
+								(ORINITBankC<<6)|\		; initial Bank C starting address value
+								(ORINITBankB)			; initial Bank B starting address value
+	ENDIF ; generated for fun
+	IF &TYPE('ORWELL_INIT33') = 'UNDEFINED' THEN ; generated for fun
+ORWELL_INIT33		EQU			\						;															<T6><T12> thru next <T12>
+								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
+								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
+								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
+								(ORINITParType<<28)|\	; initial parity even/odd value
+								(ORINITParity<<27)|\	; initial parity on/off value
+								(ORINITREFRESH33<<24)|\	; initial refresh rate value
+								(ORINITROMSpeed33<<21)|\; initial ROM speed value
+								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
+								(ORINITClock33<<18)|\	; initial clock speed value
+								(ORINITBankD<<12)|\		; initial Bank D starting address value
+								(ORINITBankC<<6)|\		; initial Bank C starting address value
+								(ORINITBankB)			; initial Bank B starting address value						<T12>
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; JAWS Memory Controller Equates
+;---------------------------------------------------
+
+	IF &TYPE('JAWSRAMWaitS') = 'UNDEFINED' THEN ; generated for fun
+JAWSRAMWaitS	EQU			$00000					; RAM wait state control register offset
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSEconoMode') = 'UNDEFINED' THEN ; generated for fun
+JAWSEconoMode	EQU			$04000					; Econo-Mode register offset									<21> HJR
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSROMWaitS') = 'UNDEFINED' THEN ; generated for fun
+JAWSROMWaitS	EQU			$06000					; ROM wait state control register offset
+	ENDIF ; generated for fun
+
+	IF &TYPE('JAWSMemConfigA') = 'UNDEFINED' THEN ; generated for fun
+JAWSMemConfigA	EQU			$10000					; Contiguous memory (knitting) registers
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSMemConfigB') = 'UNDEFINED' THEN ; generated for fun
+JAWSMemConfigB	EQU			$12000					; Contiguous memory (knitting) registers
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSMemConfigC') = 'UNDEFINED' THEN ; generated for fun
+JAWSMemConfigC	EQU			$14000					; Contiguous memory (knitting) registers
+	ENDIF ; generated for fun
+
+	IF &TYPE('JAWSPowerCycle') = 'UNDEFINED' THEN ; generated for fun
+JAWSPowerCycle	EQU			$20000					; CPU power off control register
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSSetCPUClock') = 'UNDEFINED' THEN ; generated for fun
+JAWSSetCPUClock	EQU			$22000					; Controls the CPU clock frequency
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSPCBLevel') = 'UNDEFINED' THEN ; generated for fun
+JAWSPCBLevel	EQU			$30000					; Selects between SCC and SCC/SCSI combo
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSLockRAM') = 'UNDEFINED' THEN ; generated for fun
+JAWSLockRAM		EQU			$32000					; Puts RAM in self refresh state
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSGetCPUClock') = 'UNDEFINED' THEN ; generated for fun
+JAWSGetCPUClock	EQU			$34000					; Returns the CPU clock frequency
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; Niagra Memory Controller Equates
+;---------------------------------------------------
+
+	IF &TYPE('NiagraVidCntCtr') = 'UNDEFINED' THEN ; generated for fun
+NiagraVidCntCtr	EQU			$02000					; Video count options 									<21> HJR
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraGUR') = 'UNDEFINED' THEN ; generated for fun
+NiagraGUR		EQU			$16000					; General Utility Registers (ponti register access)<SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraVidAcc1') = 'UNDEFINED' THEN ; generated for fun
+NiagraVidAcc1	EQU			$22000					; Video Accesses thru 64
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraVidAcc2') = 'UNDEFINED' THEN ; generated for fun
+NiagraVidAcc2	EQU			$24000					; Video Accesses thru 512
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraVidAcc3') = 'UNDEFINED' THEN ; generated for fun
+NiagraVidAcc3	EQU			$26000					; Video Accesses thru 2K
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraFlashEnbl') = 'UNDEFINED' THEN ; generated for fun
+NiagraFlashEnbl	EQU			$30000					; Enable flash from Niagra
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraFPUAcc') = 'UNDEFINED' THEN ; generated for fun
+NiagraFPUAcc	EQU			$34000					; FPU access detected
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraSpeedReg') = 'UNDEFINED' THEN ; generated for fun
+NiagraSpeedReg	EQU			$36000					; Returns the CPU clock frequency
+	ENDIF ; generated for fun
+
+;---------------------------------------------------								<SM4> rb, start
+; Ponti Register Equates  (NiagraGUR register space + offset
+;---------------------------------------------------
+
+	IF &TYPE('PontiSPIMdmCtl') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIMdmCtl		EQU			$000
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndCtl') = 'UNDEFINED' THEN ; generated for fun
+PontiSndCtl			EQU			$400
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSPISftReg') = 'UNDEFINED' THEN ; generated for fun
+PontiSPISftReg		EQU			$800
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpSftCtl') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpSftCtl		EQU			$C00
+	ENDIF ; generated for fun
+
+; Ponti PontiSPIMdmCtl bit definitions
+	IF &TYPE('PontiSPIMdmId') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIMdmId		EQU			0				; (1 = SPI modem connected)
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSPIAck') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIAck			EQU			2				; (1 = ack idle)
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSPIReq') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIReq			EQU			3				; (1 = req idle)
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSPIIrq') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIIrq			EQU			4				; (1 = interrupting)
+	ENDIF ; generated for fun
+
+; Ponti PontiSoundCtl bit definitions
+	IF &TYPE('PontiSndSPIIrqMsk') = 'UNDEFINED' THEN ; generated for fun
+PontiSndSPIIrqMsk	EQU			0				; (1 = mask int)			- irq mask for PontiSPIIrq
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndIntMic') = 'UNDEFINED' THEN ; generated for fun
+PontiSndIntMic		EQU			1				; (1 = using internal mic)	- flag to check which mike is used	<H22>
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndLatchClr') = 'UNDEFINED' THEN ; generated for fun
+PontiSndLatchClr	EQU			2				; (pulse high to clear)		- line directly to latch
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndLatchData') = 'UNDEFINED' THEN ; generated for fun
+PontiSndLatchData	EQU			3				; (1 = snd ckt used)		- output value of the sound latch
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndPWMOff') = 'UNDEFINED' THEN ; generated for fun
+PontiSndPWMOff		EQU			4				; (1 = PWM off)				- ultimate off to remove "pop"
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndPwrOn') = 'UNDEFINED' THEN ; generated for fun
+PontiSndPwrOn		EQU			5				; (1 = power snd ckt)		- sw equal of latch output
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndMux0') = 'UNDEFINED' THEN ; generated for fun
+PontiSndMux0		EQU			6				; (1 = ???)
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndMux1') = 'UNDEFINED' THEN ; generated for fun
+PontiSndMux1		EQU			7				; (1 = modem sound {regardless of Mux0})
+	ENDIF ; generated for fun
+
+; Ponti PontiLmpSftCtl bit definitions
+	IF &TYPE('PontiLmpOff') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpOff			EQU			0				; (1 = backlight on) 		- turn on the backlight tube
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpHWCtl') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpHWCtl		EQU			1				; (1 = Hardware control) 	- if set, hardware control loop
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpMux0') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpMux0		EQU			2				; (1 = 1/2 pot) 			- 1/2 scale pot reduction
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpMux1') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpMux1		EQU			3				; (1 = 1/4 pot) 			- 1/4 scale pot reduction
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpSPIDir') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpSPIDir		EQU			4				; (1 = shift out) 			- direction of shift register
+	ENDIF ; generated for fun
+												;									<SM4> rb, end
+;-------------------------------------																		<H21> thru next <H21>
+;	djMEMC memory controller equates
+;-------------------------------------
+
+;	This hard-coded I/O address is in here because there is no more room in the
+;	Universal tables to hold this information.
+
+	IF &TYPE('MEMCAddr') = 'UNDEFINED' THEN ; generated for fun
+MEMCAddr			EQU		$50F0E000				; same for both Wombat + WLCD memory maps
+	ENDIF ; generated for fun
+
+	IF &TYPE('MEMCRegisterStart') = 'UNDEFINED' THEN ; generated for fun
+MEMCRegisterStart	EQU		0
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCIntleaveEnable') = 'UNDEFINED' THEN ; generated for fun
+MEMCIntleaveEnable	EQU		MEMCRegisterStart		; DRAM interleave enable reg.
+	ENDIF ; generated for fun
+	IF &TYPE('dj_OneBufferedBusBit') = 'UNDEFINED' THEN ; generated for fun
+dj_OneBufferedBusBit EQU	5
+	ENDIF ; generated for fun
+;	djMEMC supports up to a maximum of 10 (TEN) DRAM banks
+	IF &TYPE('dj_MaxBanks') = 'UNDEFINED' THEN ; generated for fun
+dj_MaxBanks			EQU		10						;														<H22>
+	ENDIF ; generated for fun
+
+	IF &TYPE('MEMCDRAMCfg0') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg0		EQU		MEMCIntleaveEnable+4	; Bank 0 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg1') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg1		EQU		MEMCDRAMCfg0+4			; Bank 1 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg2') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg2		EQU		MEMCDRAMCfg1+4			; Bank 2 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg3') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg3		EQU		MEMCDRAMCfg2+4			; Bank 3 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg4') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg4		EQU		MEMCDRAMCfg3+4			; Bank 4 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg5') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg5		EQU		MEMCDRAMCfg4+4			; Bank 5 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg6') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg6		EQU		MEMCDRAMCfg5+4			; Bank 6 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg7') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg7		EQU		MEMCDRAMCfg6+4			; Bank 7 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg8') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg8		EQU		MEMCDRAMCfg7+4			; Bank 8 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg9') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg9		EQU		MEMCDRAMCfg8+4			; Bank 9 cfg reg
+	ENDIF ; generated for fun
+
+	IF &TYPE('MEMCmemTop') = 'UNDEFINED' THEN ; generated for fun
+MEMCmemTop			EQU		MEMCDRAMCfg9+4			; Top of stitched RAM
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCconfig') = 'UNDEFINED' THEN ; generated for fun
+MEMCconfig			EQU		MEMCmemTop+4			; "Multiple bit DRAM/ROM configuration register"
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCRefresh') = 'UNDEFINED' THEN ; generated for fun
+MEMCRefresh			EQU		MEMCconfig+4			; DRAM refresh rate register
+	ENDIF ; generated for fun
+
+
+;__________________________________________________________________________________________
+;
+;
+; Interrupt Vector Definitions and Masks
+;
+;
+;__________________________________________________________________________________________
+
+
+
+;---------------------------------------------------
+; Interrupt Masks
+;---------------------------------------------------
+
+	IF &TYPE('hiIntMask') = 'UNDEFINED' THEN ; generated for fun
+hiIntMask 		EQU 		$0700					; programmer switch only
+	ENDIF ; generated for fun
+	IF &TYPE('pwrOffEnbl') = 'UNDEFINED' THEN ; generated for fun
+pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('sccIntMask') = 'UNDEFINED' THEN ; generated for fun
+sccIntMask		EQU 		$0400					; SCC interrupt level
+	ENDIF ; generated for fun
+	IF &TYPE('sccEnblMask') = 'UNDEFINED' THEN ; generated for fun
+sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('slotIntMask') = 'UNDEFINED' THEN ; generated for fun
+slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
+	ENDIF ; generated for fun
+	IF &TYPE('viaIntMask') = 'UNDEFINED' THEN ; generated for fun
+viaIntMask		EQU 		$0100					; VIA1 interrupt level
+	ENDIF ; generated for fun
+	IF &TYPE('loIntMask') = 'UNDEFINED' THEN ; generated for fun
+loIntMask 		EQU 		$0100
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Hardware Base Addresses
+;---------------------------------------------------
+
+	IF &TYPE('WrOffs') = 'UNDEFINED' THEN ; generated for fun
+WrOffs			EQU			0						; SCSI write addrs are same as read base
+	ENDIF ; generated for fun
+	IF &TYPE('MskIOP1') = 'UNDEFINED' THEN ; generated for fun
+MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('MskVIA1') = 'UNDEFINED' THEN ; generated for fun
+MskVIA1			EQU			1						; VIA 1 is level 1
+	ENDIF ; generated for fun
+	IF &TYPE('MskADB') = 'UNDEFINED' THEN ; generated for fun
+MskADB			EQU			1						; ADB is level 1
+	ENDIF ; generated for fun
+	IF &TYPE('Msk60Hz') = 'UNDEFINED' THEN ; generated for fun
+Msk60Hz			EQU			1						; 60 Hz is level 1
+	ENDIF ; generated for fun
+	IF &TYPE('MskSCSI') = 'UNDEFINED' THEN ; generated for fun
+MskSCSI			EQU			2						; SCSI is level 2
+	ENDIF ; generated for fun
+	IF &TYPE('MskSound') = 'UNDEFINED' THEN ; generated for fun
+MskSound		EQU			2						; sound is level 2						<4.5>
+	ENDIF ; generated for fun
+	IF &TYPE('MskSlots') = 'UNDEFINED' THEN ; generated for fun
+MskSlots		EQU			2						; slots are level 2 interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('MskRTC') = 'UNDEFINED' THEN ; generated for fun
+MskRTC			EQU			3						; RTC is level 3
+	ENDIF ; generated for fun
+	IF &TYPE('MskIOP0') = 'UNDEFINED' THEN ; generated for fun
+MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
+	ENDIF ; generated for fun
+	IF &TYPE('MskPwrOff') = 'UNDEFINED' THEN ; generated for fun
+MskPwrOff		EQU			6						; Poweroff button is level 6
+	ENDIF ; generated for fun
+	IF &TYPE('MskNMI') = 'UNDEFINED' THEN ; generated for fun
+MskNMI			EQU			7						; NMI switch is level 7
+	ENDIF ; generated for fun
+
+
+; ---------------------------------------------------------------------------------------------------	<T8>
+;		Bit definitions for the Cache Control Register (CACR) on various CPUs							<T8>
+; ---------------------------------------------------------------------------------------------------	<T8>
+;
+;	020 CACR:		(from MC68020 User's Manual, 3rd Ed.  pg. 6-3)										<T8>
+;			+------------------------------------------------+											<T8>
+;			|  0  ..............  0 |  C  |  CE  |  F  |  E  |											<T8>
+;			+------------------------------------------------+											<T8>
+;			  31                  4    3      2     1     0												<T8>
+;
+;				C   =  Clear Cache																		<T8>
+;				CE  =  Clear Entry																		<T8>
+;				F   =  Freeze Cache																		<T8>
+;				E   =  Enable (Inst.) Cache																<T8>
+;
+;
+;	030 CACR:		(from MC68030 User's Manual, 2nd Ed.  pg 6-15)										<T8>
+;			+------------------------------------------------------------------------------------+		<T8>
+;			|  0  ...  0  | WA | DBE | CD | CED | FD | ED | 0 | 0 | 0 | IBE | CI | CEI | FI | EI |		<T8>
+;			+------------------------------------------------------------------------------------+		<T8>
+;			 31       14    13    12   11    10    9    8   7   6   5    4    3     2    1     0		<T8>
+;
+;				WA  =	Write Allocate																	<T8>
+;				DBE =	Data Burst Allocate																<T8>
+;				CD	=	Clear Data Cache																<T8>
+;				CED	=	Clear Entry in Data Cache														<T8>
+;				FD	=	Freeze Data Cache																<T8>
+;				ED	=	Enable Data Cache																<T8>
+;				IBE	=	Instruction Burst Enable														<T8>
+;				CI	=	Clear Instruction Cache															<T8>
+;				CEI	=	Clear Entry in Instruction Cache												<T8>
+;				FI	=	Freeze Instruction Cache														<T8>
+;				EI	=	Enable Instruction Cache														<T8>
+;
+;
+;	040 CACR:		(from MC68040 User's Manual, 1st Ed.,  pg. 7-19)									<T8>
+;			+-------------------------------------+														<T8>
+;			|  DE  |  0 ... 0  |  IE  |  0 ... 0  |														<T8>
+;			+-------------------------------------+														<T8>
+;			   31    30     16    15    14     0														<T8>
+;
+;				DE	=	Enable Data Cache																<T8>
+;				IE	=	Enable Instruction Cache														<T8>
+;
+
+;	MC68040 CACR bits of note:
+
+	IF &TYPE('CACR_IE_040') = 'UNDEFINED' THEN ; generated for fun
+CACR_IE_040				EQU		15				; bit # of instruction cache enable/disable on 040s		<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_DE_040') = 'UNDEFINED' THEN ; generated for fun
+CACR_DE_040				EQU		31				; bit # of data cache enable/disable on 040s			<T8>
+	ENDIF ; generated for fun
+
+;	MC68020 and MC68030 CACR bits of note:
+
+	IF &TYPE('CACR_EI_020_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_EI_020_030			EQU		0				; bit # of inst. cache enable/disable on 020/030s		<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_FI_020_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_FI_020_030			EQU		1				; bit # of inst. cache freeze on 020/030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_CEI_020_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_CEI_020_030		EQU		2				; bit # of inst. cache flush entry on 020/030s			<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_CI_020_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_CI_020_030			EQU		3				; bit # of inst. cache flush on 020/030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_IBE_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_IBE_030			EQU		4				; bit # of data cache burst enable on 030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_ED_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_ED_030				EQU		8				; bit # of data cache enable/disable on 030s			<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_FD_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_FD_030				EQU		9				; bit # of data cache freeze on 030s					<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_CED_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_CED_030			EQU		10				; bit # of data cache flush entry on 030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_CD_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_CD_030				EQU		11				; bit # of data cache flush on 030s						<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_DBE_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_DBE_030			EQU		12				; bit # of data cache burst enable on 030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_WA_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_WA_030				EQU		13				; bit # of write allocate enable on 030s				<T8>
+	ENDIF ; generated for fun
+
+;__________________________________________________________________________________________
+;
+;
+; Miscellaneous Equates - Look Here If You Can't Find It Anywhere Else.
+;
+;
+;__________________________________________________________________________________________
+
+
+
+	IF &TYPE('Machine') = 'UNDEFINED' THEN ; generated for fun
+Machine   		EQU 		7						; new Machine number for patches			<18>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; System Software Information
+;---------------------------------------------------
+
+	IF &TYPE('numOsTrap') = 'UNDEFINED' THEN ; generated for fun
+numOsTrap 		EQU 		256   					; number of os traps
+	ENDIF ; generated for fun
+	IF &TYPE('ToolTable') = 'UNDEFINED' THEN ; generated for fun
+ToolTable 		EQU 		$0E00 					; start of toolbox trap table
+	ENDIF ; generated for fun
+	IF &TYPE('numTbTrap') = 'UNDEFINED' THEN ; generated for fun
+numTbTrap 		EQU 		1024   					; number of toolbox traps
+	ENDIF ; generated for fun
+	IF &TYPE('numTrapMask') = 'UNDEFINED' THEN ; generated for fun
+numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
+	ENDIF ; generated for fun
+	IF &TYPE('JMemMgr24') = 'UNDEFINED' THEN ; generated for fun
+JMemMgr24		EQU			$1E00					; jump vector start for 24 bit Memory Manager 		<v1.9>
+	ENDIF ; generated for fun
+	IF &TYPE('JMemMgr32') = 'UNDEFINED' THEN ; generated for fun
+JMemMgr32		EQU			$1F00					; jump vector start for 32 bit Memory Manager 		<v1.9>
+	ENDIF ; generated for fun
+	IF &TYPE('HeapStart') = 'UNDEFINED' THEN ; generated for fun
+HeapStart 		EQU 		$2800 					; Low mem is now 10k bytes							<SM13>
+	ENDIF ; generated for fun
+	IF &TYPE('defSysHeap') = 'UNDEFINED' THEN ; generated for fun
+defSysHeap		EQU 		$18000    				; Default size of the system heap
+	ENDIF ; generated for fun
+	IF &TYPE('nDfltStackSize') = 'UNDEFINED' THEN ; generated for fun
+nDfltStackSize	EQU 		$6000 					; Default stack size
+	ENDIF ; generated for fun
+
+**** maybe not so temporary to allow things to build ****									<3.5>
+	IF &TYPE('oneSecConst') = 'UNDEFINED' THEN ; generated for fun
+oneSecConst   	EQU 		8 						; gets converted to $80000 for onesec constant<3.5>
+	ENDIF ; generated for fun
+	IF BlackBirdDebug THEN
+	IF &TYPE('ROMStart') = 'UNDEFINED' THEN ; generated for fun
+ROMStart  		EQU 		$40000000 				; ••PN BlackBirdstarting address of final ROM code	<3.5>
+	ENDIF ; generated for fun
+	ELSE
+	IF &TYPE('ROMStart') = 'UNDEFINED' THEN ; generated for fun
+ROMStart  		EQU 		$40800000 				; starting address of final ROM code	<3.5>
+	ENDIF ; generated for fun
+	ENDIF
+	IF &TYPE('snd2MemTop') = 'UNDEFINED' THEN ; generated for fun
+snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+	ENDIF ; generated for fun
+	IF &TYPE('pwm2MemTop') = 'UNDEFINED' THEN ; generated for fun
+pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+	ENDIF ; generated for fun
+	IF &TYPE('bufWorldSize') = 'UNDEFINED' THEN ; generated for fun
+bufWorldSize  	EQU 		8192		   			; total size of the BufPtr world		<H16>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------								<SM4> rb, start
+;  Sound parameters																			<P4>
+;---------------------------------------------------
+	IF &TYPE('sampleSize') = 'UNDEFINED' THEN ; generated for fun
+sampleSize		equ			4				; number of bytes per sample
+	ENDIF ; generated for fun
+	IF &TYPE('bufferSize') = 'UNDEFINED' THEN ; generated for fun
+bufferSize		equ			960				; number of samples per buffer
+	ENDIF ; generated for fun
+	IF &TYPE('sampleRate') = 'UNDEFINED' THEN ; generated for fun
+sampleRate		equ			24 * 1024		; 24KHz sample rate
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+;  PSC Hardware Defs
+;---------------------------------------------------
+
+; === Hardware Base Addresses ===
+	IF &TYPE('PSCBase') = 'UNDEFINED' THEN ; generated for fun
+PSCBase			equ			$50f31000		; Base address of the PSC
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+;  PSC Sound Register Offsets
+;---------------------------------------------------
+	IF &TYPE('sndComCtl') = 'UNDEFINED' THEN ; generated for fun
+sndComCtl		equ			$200			; [word] sound and communications control
+	ENDIF ; generated for fun
+	IF &TYPE('singerCtl') = 'UNDEFINED' THEN ; generated for fun
+singerCtl		equ			$204			; [long] singer sound CODEC control
+	ENDIF ; generated for fun
+	IF &TYPE('singerStat') = 'UNDEFINED' THEN ; generated for fun
+singerStat		equ			$208			; [long] singer sound CODEC status  (read only)
+	ENDIF ; generated for fun
+	IF &TYPE('sndPhase') = 'UNDEFINED' THEN ; generated for fun
+sndPhase		equ			$20c			; [long] sound subsystem phase  (read only)
+	ENDIF ; generated for fun
+	IF &TYPE('sndInBase') = 'UNDEFINED' THEN ; generated for fun
+sndInBase		equ			$210			; [long] sound input double-buffer base address
+	ENDIF ; generated for fun
+	IF &TYPE('sndOutBase') = 'UNDEFINED' THEN ; generated for fun
+sndOutBase		equ			$214			; [long] sound output double buffer base address
+	ENDIF ; generated for fun
+	IF &TYPE('sndSize') = 'UNDEFINED' THEN ; generated for fun
+sndSize			equ			$218			; [word] sound input and output buffer size
+	ENDIF ; generated for fun
+	IF &TYPE('dspOverRun') = 'UNDEFINED' THEN ; generated for fun
+dspOverRun		equ			$21C			; [byte] DSP overrun status register.
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+;  PSC Sound Register Bit Definitions
+;---------------------------------------------------
+; === sndComCtl register ===
+	IF &TYPE('pSubFrmInSel') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmInSel	equ			0				; singer sound CODEC input subframe select
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmInSel1') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmInSel1	equ			0				; singer sound CODEC input subframe select, lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmInSel2') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmInSel2	equ			1				; singer sound CODEC input subframe select, msbit
+	ENDIF ; generated for fun
+
+	IF &TYPE('pSubFrmOutSel') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel	equ			2				; singer sound CODEC output subframe select
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmOutSel1') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel1	equ			2				; singer sound CODEC output subframe select, lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmOutSel2') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel2	equ			3				; singer sound CODEC output subframe select
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmOutSel3') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel3	equ			4				; singer sound CODEC output subframe select
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmOutSel4') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel4	equ			5				; singer sound CODEC output subframe select, msbit
+	ENDIF ; generated for fun
+
+	IF &TYPE('pFrmIntEn') = 'UNDEFINED' THEN ; generated for fun
+pFrmIntEn		equ			6				; frame interrupt enable
+	ENDIF ; generated for fun
+	IF &TYPE('pSndInEn') = 'UNDEFINED' THEN ; generated for fun
+pSndInEn		equ			7				; sound input DMA enable
+	ENDIF ; generated for fun
+	IF &TYPE('pSndOutEn') = 'UNDEFINED' THEN ; generated for fun
+pSndOutEn		equ			8				; sound output DMA enable
+	ENDIF ; generated for fun
+
+	IF &TYPE('pSndRate') = 'UNDEFINED' THEN ; generated for fun
+pSndRate		equ			9				; singer sound CODEC sampling rate control
+	ENDIF ; generated for fun
+	IF &TYPE('pSndRate1') = 'UNDEFINED' THEN ; generated for fun
+pSndRate1		equ			9				; singer sound CODEC sampling rate control, lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pSndRate2') = 'UNDEFINED' THEN ; generated for fun
+pSndRate2		equ			10				; singer sound CODEC sampling rate control, msbit
+	ENDIF ; generated for fun
+
+	IF &TYPE('pComRate') = 'UNDEFINED' THEN ; generated for fun
+pComRate		equ			11				; communications CODEC sampling rate contrl
+	ENDIF ; generated for fun
+	IF &TYPE('pComRate1') = 'UNDEFINED' THEN ; generated for fun
+pComRate1		equ			11				; communications CODEC sampling rate contrl, lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pComRate2') = 'UNDEFINED' THEN ; generated for fun
+pComRate2		equ			12				; communications CODEC sampling rate contrl, msbit
+	ENDIF ; generated for fun
+;				equ			13				; unused
+;				equ			14				; unused
+;				equ			15				; unused
+
+
+	IF &TYPE('sndComCtlInit') = 'UNDEFINED' THEN ; generated for fun
+sndComCtlInit 	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
+							(0<<pSubFrmOutSel)|\	; Ouput subframe zero selected
+							(0<<pFrmIntEn)|\		; frame interrupts disabled
+							(0<<pSndInEn)|\			; sound input disabled
+							(0<<pSndOutEn)|\		; sound output disabled
+							(0<<pSndRate)|\			; 24KHz sampling rate selected
+							(0<<pComRate)			; communications CODEC, we just don't care
+	ENDIF ; generated for fun
+
+	IF &TYPE('soundOutEnable') = 'UNDEFINED' THEN ; generated for fun
+soundOutEnable	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
+							(1<<pSubFrmOutSel)|\	; Ouput subframe zero selected
+							(0<<pFrmIntEn)|\		; frame interrupts enabled
+							(0<<pSndInEn)|\			; sound input disabled
+							(1<<pSndOutEn)|\		; sound output disabled
+							(0<<pSndRate)|\			; 24KHz sampling rate selected
+							(0<<pComRate)			; communications CODEC, we just don't care
+	ENDIF ; generated for fun
+
+
+
+; === singerCtl register ===
+	IF &TYPE('pOutputPort') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort	equ			0					; set digital output port
+	ENDIF ; generated for fun
+	IF &TYPE('pOutputPort1') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort1	equ			0				; set digital output port, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pOutputPort2') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort2	equ			1				; set digital output port
+	ENDIF ; generated for fun
+	IF &TYPE('pOutputPort3') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort3	equ			2				; set digital output port
+	ENDIF ; generated for fun
+	IF &TYPE('pOutputPort4') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort4	equ			3				; set digital output port, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pRightAtten') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten		equ			4				; right ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pRightAtten1') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten1	equ			4				; right ouput attenutaion, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pRightAtten2') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten2	equ			5				; right ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pRightAtten3') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten3	equ			6				; right ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pRightAtten4') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten4	equ			7				; right ouput attenutaion, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pLeftAtten') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten		equ			8				; Left ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftAtten1') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten1		equ			8				; Left ouput attenutaion, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftAtten2') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten2		equ			9				; Left ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftAtten3') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten3		equ			10				; Left ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftAtten4') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten4		equ			11				; Left ouput attenutaion, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pRightGain') = 'UNDEFINED' THEN ; generated for fun
+pRightGain		equ			12				; right input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pRightGain1') = 'UNDEFINED' THEN ; generated for fun
+pRightGain1		equ			12				; right input gain, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pRightGain2') = 'UNDEFINED' THEN ; generated for fun
+pRightGain2		equ			13				; right input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pRightGain3') = 'UNDEFINED' THEN ; generated for fun
+pRightGain3		equ			14				; right input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pRightGain4') = 'UNDEFINED' THEN ; generated for fun
+pRightGain4		equ			15				; right input gain, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pLeftGain') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain		equ			16				; left input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftGain1') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain1		equ			16				; left input gain, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftGain2') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain2		equ			17				; left input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftGain3') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain3		equ			18				; left input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftGain4') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain4		equ			19				; left input gain, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pRightInMux') = 'UNDEFINED' THEN ; generated for fun
+pRightInMux		equ			20				; right input mux
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftInMux') = 'UNDEFINED' THEN ; generated for fun
+pLeftInMux		equ			21				; left input mux
+	ENDIF ; generated for fun
+	IF &TYPE('pMute') = 'UNDEFINED' THEN ; generated for fun
+pMute			equ			22				; mute bit
+	ENDIF ; generated for fun
+	IF &TYPE('pExpCtl') = 'UNDEFINED' THEN ; generated for fun
+pExpCtl			equ			23				; expand bit for control
+	ENDIF ; generated for fun
+;				equ			24				; unused
+;				equ			25				; unused
+;				equ			26				; unused
+;				equ			27				; unused
+;				equ			28				; unused
+;				equ			29				; unused
+;				equ			30				; unused
+;				equ			31				; unused
+
+	IF &TYPE('singerCtlInit') = 'UNDEFINED' THEN ; generated for fun
+singerCtlInit	equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
+							(0<<pRightAtten)|\		; right output attenuation set to zero
+							(0<<pLeftAtten)|\		; left output attenuation set to zero
+							(%0101<<pRightGain)|\	; right input gain set to middle
+							(%0101<<pLeftGain)|\	; left input gain set to middle
+							(0<<pRightInMux)|\		; input muxes irrelevant
+							(0<<pLeftInMux)|\		;
+							(1<<pMute)|\			; mute ON
+							(0<<pExpCtl)			; no expand
+	ENDIF ; generated for fun
+
+	IF &TYPE('unMute') = 'UNDEFINED' THEN ; generated for fun
+unMute			equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
+							(0<<pRightAtten)|\		; right output attenuation set to zero
+							(0<<pLeftAtten)|\		; left output attenuation set to zero
+							(%0101<<pRightGain)|\	; right input gain set to middle
+							(%0101<<pLeftGain)|\	; left input gain set to middle
+							(0<<pRightInMux)|\		; input muxes irrelevant
+							(0<<pLeftInMux)|\		;
+							(0<<pMute)|\			; mute OFF
+							(0<<pExpCtl)			; no expand
+	ENDIF ; generated for fun
+
+
+
+; === singerStat register ===
+	IF &TYPE('pInputPort1') = 'UNDEFINED' THEN ; generated for fun
+pInputPort1		equ			0				; set digital Input port, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pInputPort2') = 'UNDEFINED' THEN ; generated for fun
+pInputPort2		equ			1				; set digital Input port
+	ENDIF ; generated for fun
+	IF &TYPE('pInputPort3') = 'UNDEFINED' THEN ; generated for fun
+pInputPort3		equ			2				; set digital Input port
+	ENDIF ; generated for fun
+	IF &TYPE('pInputPort4') = 'UNDEFINED' THEN ; generated for fun
+pInputPort4		equ			3				; set digital Input port, msb
+	ENDIF ; generated for fun
+;				equ			4				; unused
+;				equ			5				; unused
+;				equ			6				; unused
+;				equ			7				; unused
+;				equ			8				; unused
+;				equ			9				; unused
+;				equ			10				; unused
+;				equ			11				; unused
+	IF &TYPE('pRevNum1') = 'UNDEFINED' THEN ; generated for fun
+pRevNum1		equ			12				; revision number, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pRevNum2') = 'UNDEFINED' THEN ; generated for fun
+pRevNum2		equ			13				; revision number
+	ENDIF ; generated for fun
+	IF &TYPE('pRevNum3') = 'UNDEFINED' THEN ; generated for fun
+pRevNum3		equ			14				; revision number
+	ENDIF ; generated for fun
+	IF &TYPE('pRevNum4') = 'UNDEFINED' THEN ; generated for fun
+pRevNum4		equ			15				; revision number, msb
+	ENDIF ; generated for fun
+	IF &TYPE('pSingerStatus1') = 'UNDEFINED' THEN ; generated for fun
+pSingerStatus1	equ			16				; status bits, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pSingerStatus2') = 'UNDEFINED' THEN ; generated for fun
+pSingerStatus2	equ			17				; status bits
+	ENDIF ; generated for fun
+	IF &TYPE('pSingerStatus3') = 'UNDEFINED' THEN ; generated for fun
+pSingerStatus3	equ			18				; status bits
+	ENDIF ; generated for fun
+	IF &TYPE('pSingerStatus4') = 'UNDEFINED' THEN ; generated for fun
+pSingerStatus4	equ			19				; status bits, msb
+	ENDIF ; generated for fun
+	IF &TYPE('pOFRight') = 'UNDEFINED' THEN ; generated for fun
+pOFRight		equ			20				; right channel overflow
+	ENDIF ; generated for fun
+	IF &TYPE('pOFLeft') = 'UNDEFINED' THEN ; generated for fun
+pOFLeft			equ			21				; left channel overflow
+	ENDIF ; generated for fun
+	IF &TYPE('pValidData') = 'UNDEFINED' THEN ; generated for fun
+pValidData		equ			22				; valid sound data
+	ENDIF ; generated for fun
+	IF &TYPE('pExpStat') = 'UNDEFINED' THEN ; generated for fun
+pExpStat		equ			23				; expand bit for status
+	ENDIF ; generated for fun
+;				equ			24				; unused
+;				equ			25				; unused
+;				equ			26				; unused
+;				equ			27				; unused
+;				equ			28				; unused
+;				equ			29				; unused
+;				equ			30				; unused
+;				equ			31				; unused
+
+
+; === sound phase register ===
+	IF &TYPE('pPreScaleLSB') = 'UNDEFINED' THEN ; generated for fun
+pPreScaleLSB	equ			0				; pre-scaler lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pReScaleMSB') = 'UNDEFINED' THEN ; generated for fun
+pReScaleMSB		equ			5				; pre-Scaler msbit
+	ENDIF ; generated for fun
+	IF &TYPE('pOffsetLSB') = 'UNDEFINED' THEN ; generated for fun
+pOffsetLSB		equ			6				; sample offset lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pOffsetMSB') = 'UNDEFINED' THEN ; generated for fun
+pOffsetMSB		equ			17				; sample offset msbit
+	ENDIF ; generated for fun
+;				equ			18				; unused
+;				equ			19				; unused
+;				equ			20				; unused
+;				equ			21				; unused
+;				equ			22				; unused
+;				equ			23				; unused
+;				equ			24				; unused
+;				equ			25				; unused
+;				equ			26				; unused
+;				equ			27				; unused
+;				equ			28				; unused
+;				equ			29				; unused
+;				equ			30				; unused
+;				equ			31				; unused
+
+	IF &TYPE('phaseOffsetMsk') = 'UNDEFINED' THEN ; generated for fun
+phaseOffsetMsk	equ			$003FFFC0		;										<SM4> rb, end
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; PSC DSP Register Bit Definitions						<SM10> ejb
+;---------------------------------------------------
+
+; === dspOverrun register ===
+	IF &TYPE('pdspReset') = 'UNDEFINED' THEN ; generated for fun
+pdspReset		equ			0				; when set places the dsp in reset state
+	ENDIF ; generated for fun
+	IF &TYPE('pdspResetEn') = 'UNDEFINED' THEN ; generated for fun
+pdspResetEn		equ			1				; when cleared disables the dspReset bit
+	ENDIF ; generated for fun
+	IF &TYPE('pdspFrameOvr') = 'UNDEFINED' THEN ; generated for fun
+pdspFrameOvr	equ			2				; when set indicates cat2 frame overrun on the dsp
+	ENDIF ; generated for fun
+;				equ			3				; unused
+;				equ			4				; unused
+;				equ			5				; unused
+;				equ			6				; unused
+	IF &TYPE('pdspSet') = 'UNDEFINED' THEN ; generated for fun
+pdspSet			equ			7				; "0" clears, "1" sets for any bit field [0:6] containing a "1"
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; ???
+;---------------------------------------------------
+
+	IF &TYPE('seRegs') = 'UNDEFINED' THEN ; generated for fun
+seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; Hardware configuration bits.
+;---------------------------------------------------
+
+	IF &TYPE('hwCbSCSI') = 'UNDEFINED' THEN ; generated for fun
+hwCbSCSI  		EQU 		15        				; SCSI port present
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbClock') = 'UNDEFINED' THEN ; generated for fun
+hwCbClock 		EQU 		14        				; New clock chip present
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbExPRAM') = 'UNDEFINED' THEN ; generated for fun
+hwCbExPRAM		EQU 		13        				; Extra Parameter Ram valid.
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbFPU') = 'UNDEFINED' THEN ; generated for fun
+hwCbFPU   		EQU 		12        				; FPU chip present.
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbMMU') = 'UNDEFINED' THEN ; generated for fun
+hwCbMMU   		EQU 		11        				; Some kind of MMU present (see MMUType for what kind).
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbADB') = 'UNDEFINED' THEN ; generated for fun
+hwCbADB   		EQU 		10        				; Apple Desktop Bus present.
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbAUX') = 'UNDEFINED' THEN ; generated for fun
+hwCbAUX			EQU			9						; Running A/UX					<2.8>
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbPwrMgr') = 'UNDEFINED' THEN ; generated for fun
+hwCbPwrMgr		EQU			8						; Power Manager present			<2.8>
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmSCSI') = 'UNDEFINED' THEN ; generated for fun
+hwCmSCSI  		EQU 		(1 << hwCbSCSI)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmClock') = 'UNDEFINED' THEN ; generated for fun
+hwCmClock 		EQU 		(1 << hwCbClock)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmExPRAM') = 'UNDEFINED' THEN ; generated for fun
+hwCmExPRAM		EQU 		(1 << hwCbExPRAM)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmFPU') = 'UNDEFINED' THEN ; generated for fun
+hwCmFPU   		EQU 		(1 << hwCbFPU)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmMMU') = 'UNDEFINED' THEN ; generated for fun
+hwCmMMU   		EQU 		(1 << hwCbMMU)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmADB') = 'UNDEFINED' THEN ; generated for fun
+hwCmADB   		EQU 		(1 << hwCbADB)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmAUX') = 'UNDEFINED' THEN ; generated for fun
+hwCmAUX			EQU			(1 << hwCbAUX)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmPwrMgr') = 'UNDEFINED' THEN ; generated for fun
+hwCmPwrMgr		EQU			(1 << hwCbPwrMgr)
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; HcMac Clock Change Addresses
+;---------------------------------------------------
+
+	IF &TYPE('Clock16M') = 'UNDEFINED' THEN ; generated for fun
+Clock16M  		EQU 		$FE0000   				; Go to sixteen megahertz clock throughput
+	ENDIF ; generated for fun
+	IF &TYPE('Clock1M') = 'UNDEFINED' THEN ; generated for fun
+Clock1M   		EQU 		$FE0002   				; Go to one megahertz clock throughput (adds 64 wait states)
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; SCC Clock Rates, Baud Rate Constants
+;---------------------------------------------------
+
+	IF &TYPE('nuMacClock') = 'UNDEFINED' THEN ; generated for fun
+nuMacClock		EQU 		36864
+	ENDIF ; generated for fun
+	IF &TYPE('nuMacConst') = 'UNDEFINED' THEN ; generated for fun
+nuMacConst		EQU 		115200
+	ENDIF ; generated for fun
+
+	IF &TYPE('macClock') = 'UNDEFINED' THEN ; generated for fun
+macClock  		EQU 		36707 					; in Hz * 100
+	ENDIF ; generated for fun
+	IF &TYPE('macConst') = 'UNDEFINED' THEN ; generated for fun
+macConst  		EQU 		114709    				; in Hz/32
+	ENDIF ; generated for fun
+
+	IF &TYPE('hcMacClock') = 'UNDEFINED' THEN ; generated for fun
+hcMacClock		EQU 		36720 					; SCC clock rates
+	ENDIF ; generated for fun
+	IF &TYPE('hcMacConst') = 'UNDEFINED' THEN ; generated for fun
+hcMacConst		EQU 		114750
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Deep Shit Rectangle info
+;---------------------------------------------------
+
+	IF &TYPE('dsRectTL') = 'UNDEFINED' THEN ; generated for fun
+dsRectTL  		EQU 		(64<<16)+32       		; top left = 64,32
+	ENDIF ; generated for fun
+	IF &TYPE('dsRectBR') = 'UNDEFINED' THEN ; generated for fun
+dsRectBR  		EQU 		(190<<16)+480     		; bottom right = 190,480
+	ENDIF ; generated for fun
+	IF &TYPE('dsRectHei') = 'UNDEFINED' THEN ; generated for fun
+dsRectHei 		EQU 		(DSrectBR**$FFFF0000)-(DSrectTL**$FFFF0000)>>16
+	ENDIF ; generated for fun
+	IF &TYPE('dsRectLen') = 'UNDEFINED' THEN ; generated for fun
+dsRectLen 		EQU 		(DSrectBR**$FFFF)-(DSrectTL**$FFFF)
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; System Error Equates
+;---------------------------------------------------
+
+	IF &TYPE('seVars') = 'UNDEFINED' THEN ; generated for fun
+seVars			EQU 		seRegs        			; start of system error data space (wrap city)
+	ENDIF ; generated for fun
+	IF &TYPE('seVSize') = 'UNDEFINED' THEN ; generated for fun
+seVSize   		EQU 		128       				; # of bytes in space
+	ENDIF ; generated for fun
+	IF &TYPE('seD0') = 'UNDEFINED' THEN ; generated for fun
+seD0  			EQU 		seVars        			; loc of saved reg D0
+	ENDIF ; generated for fun
+	IF &TYPE('seA0') = 'UNDEFINED' THEN ; generated for fun
+seA0  			EQU 		seD0+32       			; loc of saved reg A0
+	ENDIF ; generated for fun
+	IF &TYPE('seA7') = 'UNDEFINED' THEN ; generated for fun
+seA7  			EQU 		seA0+28       			; loc of saved reg A7
+	ENDIF ; generated for fun
+	IF &TYPE('sePC') = 'UNDEFINED' THEN ; generated for fun
+sePC  			EQU 		seA7+4        			; loc of saved PC
+	ENDIF ; generated for fun
+	IF &TYPE('seSR') = 'UNDEFINED' THEN ; generated for fun
+seSR  			EQU 		sePC+4        			; loc of saved SR
+	ENDIF ; generated for fun
+	IF &TYPE('seAccess') = 'UNDEFINED' THEN ; generated for fun
+seAccess  		EQU 		seSR+2        			; PC address during bus/address error
+	ENDIF ; generated for fun
+	IF &TYPE('seCmdSize') = 'UNDEFINED' THEN ; generated for fun
+seCmdSize 		EQU 		seAccess+4    			; # of bytes of parameters passed in _debugger call
+	ENDIF ; generated for fun
+	IF &TYPE('se000BE') = 'UNDEFINED' THEN ; generated for fun
+se000BE   		EQU 		seCmdSize+2       		; 8 bytes of bus error info for 68000
+	ENDIF ; generated for fun
+	IF &TYPE('seLastVar') = 'UNDEFINED' THEN ; generated for fun
+seLastVar 		EQU 		se000BE+8     			; last var in System Error data space
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; ROM based debugger nub
+;---------------------------------------------------
+
+	IF &TYPE('rdPort') = 'UNDEFINED' THEN ; generated for fun
+rdPort			EQU 		seLastVar     			; Number of port currently in use (0 => no link, 1 => A, 2 => B)
+	ENDIF ; generated for fun
+	IF &TYPE('rdCode') = 'UNDEFINED' THEN ; generated for fun
+rdCode			EQU 		rdPort+2      			; Ptr to code download buffer.
+	ENDIF ; generated for fun
+	IF &TYPE('rdAtrap') = 'UNDEFINED' THEN ; generated for fun
+rdAtrap   		EQU 		rdCode+4      			; Saved Rom Atrap handler
+	ENDIF ; generated for fun
+	IF &TYPE('rdLowTrap') = 'UNDEFINED' THEN ; generated for fun
+rdLowTrap 		EQU 		rdAtrap+4     			; low value for trap handling
+	ENDIF ; generated for fun
+	IF &TYPE('rdHiTrap') = 'UNDEFINED' THEN ; generated for fun
+rdHiTrap  		EQU 		rdLowTrap+2       		; high value for trap handling
+	ENDIF ; generated for fun
+	IF &TYPE('rdResult') = 'UNDEFINED' THEN ; generated for fun
+rdResult  		EQU 		rdHiTrap+2    			; result of executing down-loaded code, etc. (16 bytes)
+	ENDIF ; generated for fun
+	IF &TYPE('rdEnd') = 'UNDEFINED' THEN ; generated for fun
+rdEnd 			EQU 		rdResult+16       		; end of vars
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Microbug
+;---------------------------------------------------
+
+; NOTE: Keep mbDotAddr immediately before mBlocAddr
+
+	IF &TYPE('mbBufSize') = 'UNDEFINED' THEN ; generated for fun
+mbBufSize 		EQU 		34
+	ENDIF ; generated for fun
+	IF &TYPE('mbBuffer') = 'UNDEFINED' THEN ; generated for fun
+mbBuffer  		EQU 		seLastVar     			; buffer for input
+	ENDIF ; generated for fun
+	IF &TYPE('mbSign') = 'UNDEFINED' THEN ; generated for fun
+mbSign			EQU 		mbBuffer+mbBufSize    	; ST => negative sign during conversion
+	ENDIF ; generated for fun
+	IF &TYPE('mbDotAddr') = 'UNDEFINED' THEN ; generated for fun
+mbDotAddr 		EQU 		mbSign+2      			; saved address
+	ENDIF ; generated for fun
+	IF &TYPE('mBlocAddr') = 'UNDEFINED' THEN ; generated for fun
+mBlocAddr 		EQU 		mbDotAddr+4       		; saved location
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Alternate ROM vectors
+;---------------------------------------------------
+
+	IF &TYPE('DiagROM') = 'UNDEFINED' THEN ; generated for fun
+DiagROM   		EQU 		$F80000   				; Alternate ROM - initial vector
+	ENDIF ; generated for fun
+	IF &TYPE('DiagROM1') = 'UNDEFINED' THEN ; generated for fun
+DiagROM1  		EQU 		$F80080   				; Alternate ROM - memory sizing vector
+	ENDIF ; generated for fun
+	IF &TYPE('DiagROM2') = 'UNDEFINED' THEN ; generated for fun
+DiagROM2  		EQU 		$F80088   				; Alternate ROM - init I/O vector
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Timing constants
+;---------------------------------------------------
+
+	IF &TYPE('VIAClockHz') = 'UNDEFINED' THEN ; generated for fun
+VIAClockHz		EQU			783360					; VIA clock rate is 783360 Hz.		<2.8>
+	ENDIF ; generated for fun
+	IF &TYPE('nTicks') = 'UNDEFINED' THEN ; generated for fun
+nTicks			EQU 		VIAClockHz/1000   		; VIA timer ticks per msec
+	ENDIF ; generated for fun
+	IF &TYPE('oneSecTicks') = 'UNDEFINED' THEN ; generated for fun
+oneSecTicks   	EQU 		60    					; ticks, of course
+	ENDIF ; generated for fun
+				IF &TYPE('__SysEqu__') = 'UNDEFINED' THEN
+	IF &TYPE('TimeSCSIDB') = 'UNDEFINED' THEN ; generated for fun
+TimeSCSIDB		EQU			$0B24					; DBRAs & SCSI access per millisecond <1.9>
+	ENDIF ; generated for fun
+				ENDIF
+
+	IF &TYPE('ramChk') = 'UNDEFINED' THEN ; generated for fun
+ramChk			EQU 		1024      				; Amount of memory tested for stack.
+	ENDIF ; generated for fun
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; ROM Header RECORD Definition
+;
+;
+;__________________________________________________________________________________________
+
+
+;---------------------------------------------------
+; Romulator ROM location bits and TestFor Macro
+;---------------------------------------------------
+
+	IF &TYPE('locValid1') = 'UNDEFINED' THEN ; generated for fun
+locValid1		EQU			7						; this must be 1
+	ENDIF ; generated for fun
+	IF &TYPE('locValid2') = 'UNDEFINED' THEN ; generated for fun
+locValid2		EQU			6						; this must be 0
+	ENDIF ; generated for fun
+	IF &TYPE('inEmulatorBit') = 'UNDEFINED' THEN ; generated for fun
+inEmulatorBit	EQU			1						; running in emulator
+	ENDIF ; generated for fun
+	IF &TYPE('inRamBit') = 'UNDEFINED' THEN ; generated for fun
+inRamBit		EQU			0						; running in ram
+	ENDIF ; generated for fun
+
+

--- a/Internal/Asm/SysPrivateEqu.a
+++ b/Internal/Asm/SysPrivateEqu.a
@@ -8,63 +8,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM30>	 1/14/94	ged		Added the jSWModemSoundVector field to the ExpandMemRec to
-;									support software modem sound using various modems.
-;	  <SM29>	11/11/93	fau		<aek>		Added pointer to Expansion Bus Manager Globals. Bumped
-;									version to	132.
-;	  <SM29>	10/31/93	aek		Added pointer to Expansion Bus Manager Globals. Bumped version to
-;									132.
-;	  <SM28>	10/29/93	pdw		Moved intRegs and intRegsSize from InterruptHandlers.a into this
-;									file to show that they are used elsewhere as well
-;									(SCSIMgr4pt3:HALc96Routines.a).
-;	  <SM27>	 9/12/93	SAM		Changed emFigmentGlobals to emHeapUtilsGlobals which is more
-;									accurate.
-;	  <SM26>	 9/11/93	SAM		Added emFigmentGlobals (new memory manager).  Bumped emVersion
-;									to 131 to reflect the first post cyclone expandmem change.
-;	  <SM25>	  6/7/93	CSS		Add expandmem to stash the control handle during thumb dragging.
-;									Plus rollin from Reality:
-;		<85>	 5/20/93	KWR		Added emSpeechRecognitionGlobals and bumped the version number
-;		<84>	 5/20/93	PKE		Delete names for obsolete fields emNumer, emDenom (they are now
-;									unused).
-;	  <SM24>	05/19/93	HY		Added emIDEGlobals and updated emCurVersion.
-;	  <SM23>	 4/22/93	CSS		Remove ";" from emButtonIntGlobals.
-;	  <SM22>	 4/22/93	CSS		Change emFFSwapMMU to emButtomIntGlobals per expandmempriv.h.
-;									Also, update from Reality. Reality Comments follow:
-;		<81>	 3/29/93	DTY		Added emAuxiliaryWindowHashTable and
-;									emAuxiliaryControlHashTable.
-;		<80>	 3/26/93	YK		Add emHasMultiScript.  This flag will be true if non-Roman
-;									script system is installed, but still be zero until the Procee
-;									Mgr is initialized.  Most of the code for multi lingual support
-;									can be skipped by checking this value.
-;		<79>	 3/25/93	DTY		Add field to store PixMapHandle used for drawing defproc
-;									gadgets.
-;		<78>	 3/18/93	SES		Steven Swenson - added a longword to ExpandMemRec for the
-;									globals for the Internal Modem Manager.
-;		<77>	 3/11/93	ngk		Rename emUsed2 to emWindowMgrFlags
-;		<76>	 3/10/93	GMA		General synch with SuperMario and Ludwig. Adding in Reno info.
-;	  <SM21>	 3/10/93	GS		Getting in touch with Reality...
-;		<75>	  3/7/93	DTY		Add Tinge Manager information.
-;		<74>	 2/25/93	IH		Change type of emDisplayManagerGlobals from Handle to Ptr.
-;		<73>	 2/23/93	ngk		Add emTranslationMgrGlobals
-;		<72>	 2/23/93	IH		Add emDisplayMgrGlobals and Get/Set macros
-;		<71>	12/22/92	YK		Added emLanguagePackGlobals in the first long of two in the
-;									emUnused3 spot.
-;	  <SM20>	 2/20/93	SAM		Added emDMADispGlobs for DMA Manager/Dispatcher globals.
-;	  <SM19>	 1/27/93	PN		Add emStartTicks extended memory global for "startticks" in
-;									ListMgrPack
-;		<SM1>	12/09/92	HI		Added emIsDragging field to be used as a flag to determine
-;									whether OSEventAvail was called from DragTheRgn or not. The
-;									flag is set by DragTheRgn only. OSEventAvail uses this flag
-;									to bypass the HelpMgr patch code if called from DragTheRgn.
-;									(Hoon Im)
-;		<70>	10/27/92	JMF		Added emButtonManagerGlobals in the emUnused1 spot and added
-;									emSerialManagerGlobals in the first long of three in the 
-;									emUnused3 spot.
-;		<69>	10/15/92	aen		Change 'fndr' names to 'emFndr'
-;		<68>	10/14/92	gs		Steal a long word from emUnused1 for FSCommon Library.
-;		<67>	10/14/92	aen		Added fndrDeskRgn, fndrDeskRgnTracking, fndrDeskRgnChange, and bumped
-;									the version number to 0x129 for Bungee Finder support of UltraDesk
-;									(Andy Nicholas).
 ;		<66>	 10/8/92	KST		emUnused4 is now used by WS II printing stuff.
 ;		<65>	 7/21/92	bbm		Add emNetBootGlobals for Network Booting and Appletalk stuff.
 ;									(see Steve Roth)
@@ -204,11 +147,6 @@ envEclipse		EQU			18
 ; *********************************************************
 
 
-IntRegs		reg		a0-a3/d0-d3			; registers saved by all interrupt handlers
-IntRegsSize	equ		8*4					; size of IntRegs in bytes - must change if IntRegs changes!
-										; if this changes, then you must update HALc96Routines.a to handle
-										; both old and new cases.
-
 ;___________________________________________________________________________
 ;
 ; Extended Low Memory area available on all machines
@@ -388,7 +326,7 @@ emPrintingGlobals			ds.l	1				; Tsunami Printing Manager non-swapped printing gl
 
 emCursorGlobals				ds.l	1				; Ptr to CursorDev globals								<46>
 
-emButtonIntGlobals			ds.l	1				; Ptr to Button Interrupt globals. previously Ptr to "real" SwapMMUMode routine	<SM22> CSS				
+emFFSwapMMUMode				ds.l	1				; Ptr to "real" SwapMMUMode routine
 
 emAppleTalkInactiveOnBoot	ds.w	1				; True if AppleTalk was inactive on boot				<48>
 
@@ -398,49 +336,11 @@ emLowMemoryPrintingGlobals	ds.l	1				; Handle to globals used by LowMemoryPrinti
 
 emNetBootGlobals			ds.l	1				; Handle to globals used by emNetBootGlobals for Network Booting and Appletalk stuff.	<65>
 
-emFndrDeskRgn				ds.l	1				; Handle to region maintained by Bungee Finder if fndrDeskRgnTracking is true <67> <69>
-
-emFndrDeskRgnTracking		ds.w	1				; If true, the Bungee Finder will keep an up-to-date region handle in fndrDeskRgn of the icons on the desktop <67> <69>
-
-emFndrDeskRgnChange			ds.w	1				; Always incremented by the Bungee Finder for every change made to the desktop <67> <69>
-
-emDisplayManagerGlobals		ds.l	1				; Pointer to globals used by Display Manager
-
-emTranslationMgrGlobals		ds.l	1				; Pointer to globals used by Translation Manager (Macintosh Easy Open)	<73>
-
-emTingeInfo					ds.l	1				; Handle to color information kept by the Tinge Manager
-
-emIsDragging				ds.b	1				; Set within DragTheRgn and cleared before exiting; if true, HelpMgr
-emIsDraggingSlop			ds.b	3				; patch in OSEventAvail is bypassed.		<SM1>
-
-emRenoGlobals				ds.l	1				; Ptr to Reno Globals						<LW2>
-
-emDMADispatchGlobals		ds.l	1				; DMA dispatch globals ptr					<SM20>
-
-emInternalModemMgrGlobals	ds.l	1				; Internal modem manager globals 			<78>
-
-emGadgetPixMap				ds.l	1				; PixMapHandle used by defprocs to draw gadgets
-
-emAuxiliaryWindowHashTable	ds.l	1				; Pointer to auxiliary window record hash table
-emAuxiliaryControlHashTable	ds.l	1				; Pointer to auxiliary control record hash table
-
-emIDEGlobals				ds.l	1				; IDE driver globals						<SM24>
-
-emSpeechRecognitionGlobals	ds.l	1				; Speech Recognition Globals				<85><KWR>
-
-emControlHandle				ds.l	1				; control handle used in _DragTheRgn when the thumb is being dragged so we can send a draw thumb outline message. <SM25> CSS
-
-emHeapUtilsGlobals			ds.l	1				; Heap Utilities globals
-
-emExpansionBusGlobals		ds.l	1				; Pointer to Expansion Bus Manager Globals
-
-jSWModemSoundVector			ds.l	1				; Vector to control routine for software modem sound
-
 ; NOTE: When adding new fields here, be sure to update the high-level language header files as well
 ; (currently {CInternal}ExpandMemPriv.h is the one)
 ; Be sure to update the Reality sources when you change this file (and the version number)
 
-emCurVersion		EQU			$0133				; version 
+emCurVersion		EQU			$0128				; version 
 
 emRecSize			equ			*					; size for this version
 size				equ			*

--- a/Internal/Asm/egretequ.a
+++ b/Internal/Asm/egretequ.a
@@ -270,10 +270,7 @@ WrHangTout		equ		$1E				; set hang threshold
 RdHangTout		equ		$1F				; get hang threshold
 SetDefDFAC		equ		$20				; Set Default DFAC String 									<T2>
 EnDisPDM		equ		$21				; Enable/Disable PowerDown Message							<T2>
-RdWrIIC			equ		$22				; Read or Write IIC (I sqared C)							<SM3>[rbm]<3>
-WakeUpMode		equ		$23				; Enable/Disable WakeUpMode									<P1>
-TimerTickle		equ		$24				; ShutDown Timer Tickle										<P1>
-MaxPseudoCmd	equ		TimerTickle		; largest possible pseudo command number					<P1>
+MaxPseudoCmd	equ		EnDisPDM		; largest possible pseudo command number					<P1>
 
 ;
 ;__________________________________________________________________________________________________

--- a/LinkedPatches/LinkedPatchLoader.a
+++ b/LinkedPatches/LinkedPatchLoader.a
@@ -305,9 +305,6 @@
 		include 'LinkedPatchMacros.a'
 		print pop
 
-_GetTrapWordAddress						opword	$A546				; *** move into Traps.a
-_SetTrapWordAddress						opword	$A447				; *** move into Traps.a
-
 dsLinkedPatchReferenceTooFar			equ		97					; *** move into SysErr.a
 
 k32BitCQDTrap							equ		$AB03				; trap number for 32-bit QuickDraw

--- a/OS/ADBMgr/ADBMgrPatch.a
+++ b/OS/ADBMgr/ADBMgrPatch.a
@@ -9,7 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 11/9/93	KW		added some eieioSTP macros.  Only active for CygnusX1 ROM
 ;		<13>	 2/12/92	JSM		Moved this file to ADBMgr folder, keeping all the old revisions.
 ;		<12>	 10/4/91	JSM		Change PsychoticFarmerOrLater conditionals to TheFuture.
 ;		<11>	 9/22/91	DTY		Change PsychoticFarmerAndLater to PsychoticFarmerOrLater.
@@ -164,9 +163,7 @@ InitADB		InstallProc	(SE,II,notAUX)
 			
 			movea.l	VIA,a1				; point to the VIA1 registers
 @wait		
-		eieioSTP
 			move.b	vBufB(a1),d0
-		eieioSTP
 			andi.b	#(1<<vFDesk2)|\
 					(1<<vFDesk1),d0		; look at state bits
 			cmpi.b	#(1<<vFDesk2)|\
@@ -174,9 +171,7 @@ InitADB		InstallProc	(SE,II,notAUX)
 			bne.s	@wait				; no, keep waiting...
 
 			ori.w	#NoIntMask,sr		; mask out interrupts							<1.2>
-		eieioSTP
 			move.b	vSR(a1),d0			; empty shift reg
-		eieioSTP
 
 			MOVE.L	ADBBase,A3			; point to ADB private data structures
 			
@@ -637,18 +632,9 @@ StartReqVIA
 
 			pea		RunADBRequest		; somthing in queue, run after a short delay
 			move.w	TimeViaDB,d0		; get 1ms VIA loop time constant
-
-	IF forSTP601 THENB
-		;•••• STP ••• eric -- let's double it??
-			lsr.w	#2,d0				; 1ms/8 = 125µs
-	ELSE
-
 			lsr.w	#4,d0				; 1ms/16 = 62.5µs
-	ENDIF
 @delay		
-		eieioSTP
 			btst.b	#0,vBufB(a1)		; timing base on BTST loop, we don't care
-		eieioSTP
 			dbra	d0,@delay			; wait at least 50µs for state change to occur
 @idle		bclr.b	#fDBBusy,FDBAuFlag(a3)	; allow explicit cmds to interrupt auto polling
 			rts							; if not, just let auto polling continue
@@ -712,45 +698,32 @@ StartReqVIA
 
 	if TheFuture then					;												<9>
 
-		eieioSTP
 			move.b	vBufB(a1),d1		; get current state								<8>
-		eieioSTP
 			andi.b	#(1<<vFDesk2)+\
 					(1<<vFDesk1),d1		;												<8>
 			cmpi.b	#(1<<vFDesk2)+\
 					(1<<vFDesk1),d1		; are we in state 3?							<8>
 			bne.s	@sendCont			; no, procede as usual							<8>
-		eieioSTP
 			btst.b	#vFDBInt,vBufB(a1)	; yes, test the FDBInt~ status					<8>
-		eieioSTP
 			beq.s	@sendExit			; asserted, xcvr already clocking autopoll data,<8>
 										; exit (wait for autopoll to complete)			<8>
 	endif								;												<9>
 	
 @sendCont	
-		eieioSTP
 			ori.b	#$1C,vACR(a1)		; set SR to shift-out with ext clk
-		eieioSTP
 			move.b	d3,vSR(a1) 			; load shift reg with cmd, start shifting
-		eieioSTP
 			move.b	d3,fDBCmd(a3)		; save the command
-		eieioSTP
 			andi.b	#-1-(1<<vFDesk2)-\
 					(1<<vFDesk1),vBufB(a1)	; force state bits to zero
-		eieioSTP
 @sendExit	move.l	(sp)+,ShiftIntResume(a3); save resume address
 			move.w	d0,sr				; restore interrupt mask
 			rts							; return to callers caller, wait for interrupt
 
 
 @waitForInput
-		eieioSTP
 			bclr.b	#4,vACR(a1)			; change to shift-in mode
-		eieioSTP
 			tst.b	vSR(a1) 			; empty shift reg to start shifting
-		eieioSTP
 			eor.b	d1,vBufB(a1)		; change the state
-		eieioSTP
 			move.l	(sp)+,ShiftIntResume(a3)	; save resume address
 			rts							; return to callers caller, wait for interrupt
 
@@ -760,12 +733,9 @@ StartReqVIA
 			moveq.l	#1,d0				; zero extend the index
 			add.b	(a0),d0				; get, and increment the index
 			move.b	d0,(a0)				; update the index
-		eieioSTP
 			move.b	vSR(a1),(a0,d0.w)	; save the new byte in the buffer
-		eieioSTP
 			eori.b	#(1<<vFDesk1)|\
 					(1<<vFDesk2),vBufB(a1)	; alternate between state 1 and state 2
-		eieioSTP
 			move.l	(sp)+,ShiftIntResume(a3)	; save resume address
 			rts							; return to callers caller, wait for interrupt
 
@@ -812,14 +782,10 @@ StartReqVIA
 			moveq.l	#(1<<vFDesk1)|\
 					(1<<vFDesk2),d1		; alternate between state 1 and state 2
 @sendByte	movea.l	ListenBuffPtr(a3),a0; get the buffer pointer
-		eieioSTP
 			move.b	(a0)+,vSR(a1)		; send the byte
-		eieioSTP
 			move.l	a0,ListenBuffPtr(a3); update the buffer pointer
 			subq.b	#1,fDBCnt(a3)		; decrement the send count
-		eieioSTP
 			eor.b	d1,vBufB(a1)		; change the state
-		eieioSTP
 			move.l	(sp)+,ShiftIntResume(a3)	; save resume address
 			rts							; return to callers caller, wait for interrupt
 			
@@ -836,9 +802,7 @@ StartReqVIA
 FDBShiftInt
 			movea.l	ADBBase,a3			; point to ADB globals in low memory
 			movea.l	ShiftIntResume(a3),a0	; get address to resume at
-		eieioSTP
 			btst.b	#vFDBInt,vBufB(a1)	; test the FDBInt~ status
-		eieioSTP
 			jmp		(a0)				; resume async processing
 			
 			Title	'KbdADB - ADB Manager  -  ReqDoneVIA'
@@ -1041,9 +1005,7 @@ GE1			jsrROM	GEmptyAddr			; get empty address space, D0 gets address (GEmptyAddr
 ;   more device in original address, we want to move the device back to 
 ;   original address.
 
-		eieioSTP
 			tst.b	(a0)				; did the device return data
-		eieioSTP
 			beq.S	@1					; no, branch 
 ; no timeout indication, 
 			bsr.s	CopyEntry			; copy entry into device table
@@ -1151,9 +1113,7 @@ GNextAddr
 
 MouseDrvr
 			lea		1(a0),a1			; skip over length byte, free up A0
-		eieioSTP
 			move.b	(a1)+,d2			; get first data byte (button, ∆ Vert)
-		eieioSTP
 
 ;	Update the mouse button state
 
@@ -1197,9 +1157,7 @@ MouseDrvr
 
 ;	Update the mouse horizontal position
 
-		eieioSTP
 			move.b	(a1),d2				; get the ∆ Horiz (low 7 bits)
-		eieioSTP
 		 	add.b	d2,d2				; shift high bit of ∆ into sign
 			beq.s	@horizDone			; if no change, nothing to update
 			asr.b	#1,d2				; shift ∆ back, sign extended

--- a/OS/Gestalt/GestaltExtensions.a
+++ b/OS/Gestalt/GestaltExtensions.a
@@ -10,8 +10,6 @@
 ;	Change History (most recent first):
 ;
 ;	  <SM10>	  6/7/93	wc		(Really BT)Fix a stupid bug of mine.
-;	   <SM9>	  6/6/93	BT		Add gestaltRISCV0ResMgrPatches to 'bugy' bits if rom is built
-;									with this option.
 ;	   <SM8>	  6/3/93	SAM		Updating the list of machine icons from the Gibbly project.
 ;	   <SM7>	 5/10/93	CSS		For 'bugy' return that the gestaltmtCheckFix has been fixed in
 ;									SuperMario. Also, update the support of bugy to include bits
@@ -188,7 +186,6 @@ getBugFixes		Proc	Entry
 ************************************************************************
 
 getBugFixesTwo		Proc	Entry
-		IF hasRISCV0ResMgrPatches THEN
 			 	move.l	#											\
 						(1<<gestaltEgretSCCFix)					|	\
 						(1<<gestaltEgretRdTimeFix)				|	\
@@ -197,22 +194,8 @@ getBugFixesTwo		Proc	Entry
 						(1<<gestaltSCSIFastAckFix)				|	\
 						(1<<gestaltPowerOffDelayFix)			|	\
 						(1<<gestaltGetIndResourceSysMapHandleFix) |	\
-						(1<<gestaltMoveHHiExtraStackSpace)		|	\
-						(1<<gestaltRISCV0ResMgrPatches)				\						<SM9> BT
+						(1<<gestaltMoveHHiExtraStackSpace)			\
 						, d0
-		ELSE
-			 	move.l	#											\
-						(1<<gestaltEgretSCCFix)					|	\
-						(1<<gestaltEgretRdTimeFix)				|	\
-						(1<<gestaltEgretIRQPatch)				|	\
-						(1<<gestaltEgretTickHandlerFix)			|	\
-						(1<<gestaltSCSIFastAckFix)				|	\
-						(1<<gestaltPowerOffDelayFix)			|	\
-						(1<<gestaltGetIndResourceSysMapHandleFix) |	\
-						(1<<gestaltMoveHHiExtraStackSpace)		|	\
-						(0<<gestaltRISCV0ResMgrPatches)				\						<SM9> BT
-						, d0
-		ENDIF
 				
 				import	stdResult
 				lea		stdResult,a0

--- a/OS/HFS/Cache/DiskCache.a
+++ b/OS/HFS/Cache/DiskCache.a
@@ -10,19 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	11/23/93	rab		In the previous checkin a !forROM conditional was added to
-;									FlushCache to strip out a check for the Mac+ ROM. Unforutnately
-;									the conditional was added a few lines too soon and eliminated
-;									all of the logic which decided if the cache should be flushed
-;									based on CacheFlag and noFlushBit. The result was that the cache
-;									always flushed which causes a performance hit. Moved the
-;									conditional and added a bra fcExit so things will work like they
-;									used to.
-;	   <SM3>	11/18/92	RB		Made some changes forROM so that we have the disk cache code in
-;									ROM and not installed as a patch from the system file. This code
-;									is now installed as the cache from ROM, but we do not prevent
-;									the file system cache from being installed (yet), so we will let
-;									this cache do cleanup.
 ;		<24>	 12/3/91	KST		Clean up the equates. Remove cbHqAge and use cbHqDevNum
 ;									consistently.
 ;		<23>	  7/9/91	JSM		Remove obsolete SysVers conditionals, turn off a label unless
@@ -367,7 +354,7 @@ ktDebugCache	equ		0
 ktDebugHash	equ		0
 		endif
 
-RAMCache	PROC	EXPORT			;												<SM3> rb
+			MAIN
 
 ; The following absolute addresses are needed to patch problems in the version 75 ROM:
 
@@ -376,11 +363,6 @@ FlMDBCall	EQU		$402DD8			; ROM75 FlushMDB return address (used for patch)
 
 ;_______________________________________;
 ;
-; If we are compiling forROM, this code is simply part of the ROM code and not a	<SM3> rb
-; resource installed by a patch.													<SM3> rb
-;
-; Otherwise:																		<SM3> rb
-;
 ; The following code is made into
 ;	a separate resource of type CACH.
 ;	It is loaded by the CacheLoad (PTCH 0 in 7.0 world)
@@ -390,13 +372,10 @@ FlMDBCall	EQU		$402DD8			; ROM75 FlushMDB return address (used for patch)
 
 CacheStart
 	
-	IF NOT forROM THEN					;											<SM3> rb
-	
 			BRA		 CacheInstall		;										<06Dec85>
 			DC.L	('CACH')			; CACH resource 						<06Dec85>
 			DC.W	1					; res is 1								<06Dec85>
 			DC.W	3					; <17Apr90> version 3					<17Apr90>
-	ENDIF								;											<SM3> rb
 	
 ;_________________________________________________________________________________
 ;
@@ -453,17 +432,12 @@ fcFile		MOVEA.L FCBSPtr,A1			; A1 = FCB ptr
 			BNE.S	@1					; br if so (go flush)
 			BTST	#noFlushBit,FHFlags(A4) ; avoid intermediate flushes?		<08Dec85>
 			BEQ.S	@1					; br if not (go flush)					<08Dec85>
-			bra.s	fcExit				; exit if so (skip flush)				<SM4>
 
-	IF NOT forROM THEN					; We don't need MacPlus ROM check		<SM3> rb <SM4>
 			MOVE.L	ROMBase,A3			;<11Dec86> make sure we have the correct ROM
 			CMP.W	#$0075,8(A3)		;<11Dec86>
 			BNE.S	fcExit				;<11Dec86> exit if not
 			CMP.L	#FReadCall,$28(A6)	; FileRead flush before verify? 		<08Dec85>
 			BNE.S	fcExit				; exit if not (skip flush)				<08Dec85>
-	ELSE								;										<SM3> rb
-			; if FlushFlag is 0, then if this file is control file skip flushing
-	ENDIF								;										<SM3> rb
 	
 @1			BSR 	FlushFCache 		; flush the A4 cache
 			BRA.S	fcExitTrash 		; trash and exit						<28Sep89>
@@ -925,8 +899,6 @@ RelBlock
 			MOVE.L	(SP)+,-(A6) 		; save return address on A6 stack
 			MOVE.L	A4,-(A6)			; save registers
 
-	IF NOT forROM THEN					; Not for the new ROMs					<SM3> rb
-	
 ; The next nine lines patch a bug in ROM 75 (FlushMDB never cleared dirty bits
 ;  on control file FCBs . . .)
 
@@ -940,7 +912,6 @@ RelBlock
 			BCLR	#FCBModBit,FCBMdRByt(A3,D0) ; clear the dirty flag
 			MOVE.W	VCBCTRef(A2),D0 	; Get catalog file refNum
 			BCLR	#FCBModBit,FCBMdRByt(A3,D0) ; clear the dirty flag
-	ENDIF								;										<SM3> rb
 
 @4			
 										; now we have pointer to data buffer	<23Apr90>
@@ -2553,8 +2524,6 @@ StrFreeQCnt DC.B	'Cache: Free Q Cnt Bad'
 StrTotalCnt DC.B	'Cache: Total Cnt Bad'
 			ENDIF
 
-	IF NOT forROM THEN					;										<SM3> rb
-	
 CutBack
 			_SetHandleSize				; adjust our size
 
@@ -2566,8 +2535,6 @@ CutBack
 			RTS
 EndResident
 
-	ENDIF								;										<SM3> rb
-	
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Code after this point will be discarded !!
 
@@ -2648,7 +2615,6 @@ verifyCacheSize
 ;						physical memory that Ramcache can allocate. The max size
 ;						is calculated based on memory CDEV and may be changed later.
 ;_________________________________________________________________________________
-			EXPORT	CacheInstall		;											<SM3> rb
 CacheInstall
 
 										; assume A0/A1 to be free
@@ -2736,18 +2702,12 @@ CacheInstall
 
 			BSR		SyncFSCall			; <02Dec86> synchronize with fs and call below
 	
-	IF NOT forROM THEN					;										<SM3> rb
-	
 			LEA		CacheStart,A0		; get beginning of resident code
 			LEA		EndResident,A1		; get end of resident code
 			SUB.L	A0,A1				; calculate size
 			_RecoverHandle				; recover handle to code (pointed to by A0)
 			MOVE.L	A1,D0				; put size in D0 for SetHandleSize
 			BRA		CutBack				; and slice away.
-			
-	ELSE								;	we are the ROM, this is no patch	<SM3> rb
-			RTS							;										<SM3> rb
-	ENDIF								;										<SM3> rb
 
 ; The following code is executed while the file system is in a suspended state.
 ; Input:	A0.L = ptr(cachevar)

--- a/OS/HFS/Extensions/CMSvcsExtras.a
+++ b/OS/HFS/Extensions/CMSvcsExtras.a
@@ -41,6 +41,14 @@
 			LOAD		'StandardEqu.d'
 			include		'LinkedPatchMacros.a'
 
+ROMBTDELETE		ROMBind	(Plus,$600000),(II,$610000),(SE,$620000),(Portable,$630000),(IIci,$640000)
+ROMBTINSERT		ROMBind	(Plus,$600000),(II,$610000),(SE,$620000),(Portable,$630000),(IIci,$640000)
+ROMBTUPDATE		ROMBind	(Plus,$600000),(II,$610000),(SE,$620000),(Portable,$630000),(IIci,$640000)
+ROMBUILDKEY		ROMBind	(Plus,$600000),(II,$610000),(SE,$620000),(Portable,$630000),(IIci,$640000)
+ROMCMFLUSH		ROMBind	(Plus,$600000),(II,$610000),(SE,$620000),(Portable,$630000),(IIci,$640000)
+ROMLOCCREC		ROMBind	(Plus,$600000),(II,$610000),(SE,$620000),(Portable,$630000),(IIci,$640000)
+ROMUPDCNAME		ROMBind	(Plus,$600000),(II,$610000),(SE,$620000),(Portable,$630000),(IIci,$640000)
+
 ;_________________________________________________________________________________
 ;
 ; Routine:		CMDeleteCN (Delete CNode)

--- a/OS/HFS/Extensions/DTDBMgr.a
+++ b/OS/HFS/Extensions/DTDBMgr.a
@@ -13,12 +13,7 @@
 ;	   <SM4>	  6/9/93	pdw		Changed register saving from interruptRegs to pascalRegs in
 ;									completionRoutine because it is supposed to be using this
 ;									convention.
-;	   <SM3>	10/27/92	CSS		Changed some word bsrs to bigjsrs.
-;	   <SM2>	10/27/92	CSS		Changed short branch to word branch.
-;	   <SM1>	 4/1/92		kc		Copied the routines DesktopCloseDownProc, CheckDesktopSupport and  DTDBMgrInit
-;									from FileMgrPatches.a. Removed the "ROM" prefix from the RomBind routines.
 
-;									• Pre-SuperMario comments follow •
 ;		<32>	 9/13/91	JSM		Cleanup header.
 ;		<31>	 5/23/91	dba		MPW 3.2 assembler no longer supports local labels for records
 ;		<30>	 3/28/91	dnf		ewa, #SetFileAttribsIsntAsyncSafe: The SetFileAttribs subroutine
@@ -212,7 +207,6 @@
 			include		'MFPrivate.a'
 			include		'HardwarePrivateEqu.a'
 			include		'Folders.a'
-			include		'InternalOnlyEqu.a'				; <SM3> CSS
 			print		pop
 
 			BLANKS ON
@@ -258,213 +252,6 @@ DTKeyDescriptor:	proc
 			proc
 			_DTDebugRts	'DTDBQueueManager', 0
 			endproc
-;________________________________________________________________________________	<SM1>
-; <36>
-; Routine:		DesktopCloseDownProc
-;
-; Inputs 		param block to _Unmount
-;
-; Outputs:		(none)
-;
-; Function:		Close the desktop database on _Unmount calls
-;
-;________________________________________________________________________________
-; Rolled into TFS.a for SuperMario <SM1> FM
-; Called by UnMountVol in TFSVol.a
-
-DesktopCloseDownProc Proc Export
-			import		FindDTVol
-@regs		reg			a0/a1/a3/d0/d1					;										<43>
-
-			movem.l		@regs, -(sp)
-
-			movea.l		a0,a3							; save the user's pb					<42>
-
-;	d0 - pascal length byte of string															<43>
-;	d1 - size of string allocated on stack														<43>
-
-			moveq.l		#0,d1							; assume no string on stack				<43>
-			move.l		ioNamePtr(a3),d0				; d0 = caller’s name ptr				<43>
-			beq.s		@noName							; bail on nil							<43>
-			movea.l		d0,a0							; get ready to copy						<43>
-			moveq.l		#0,d0							; clear high bytes						<43>
-			move.b		(a0),d0							; d0 = string length					<43>
-			beq.s		@noName							; bail on zero length (d0.l has nil)	<43>
-
-			move.b		d0,d1							; d1 = copy of string length byte		<43>
-			addq.b		#2,d1							; add length byte and rounding fodder	<43>
-			bclr.l		#0,d1							; make it even							<43>
-			suba.w		d1,sp							; allocate a string of the right length	<43>
-			movea.l		sp,a1							; point to it							<43>
-
-@1:			move.b		(a0)+,(a1)+						;										<43>
-			dbra		d0,@1							; copy string length+1 bytes			<43>
-
-			move.l		sp,d0							; point to it again						<43>
-
-@noName:
-			suba.w		#ioHVQElSize,sp					; get a pb								<42>
-			movea.l		sp,a0							; point to it							<42>
-			move.w		ioVRefNum(a3),ioVRefNum(a0)		; copy caller's vRefNum					<42>
-			move.l		d0,ioNamePtr(a0)				; our version of the caller's name		<42>
-			move.w		#-1,ioVolIndex(a0)				; by name&vRef, please					<42>
-			_GetVolInfo									;										<42>
-			bne.s		@done							;										<42>
-
-			move.w		ioVRefNum(a0), d0				; grab the volume that's going away
-			bsr			FindDTVol						; try to find a DTDBQElt for this volume
-			bne.s		@done							; no work to do if the DTDB is closed
-			sub.w		#ioDTQElSize, sp				; allocate a DT param block
-			movea.l		sp, a0
-			move.w		DTDBQElt.DTRefNum(a3), ioRefNum(a0)	; stash the DTRefNum for this volume
-			_DTCloseDown
-			add.w		#ioDTQElSize, sp				; deallocate the param block
-
-@done:
-			adda.w		#ioHVQElSize,sp					; deallocate the pb						<42>
-			adda.w		d1,sp							; deallocate the string					<43>
-			movem.l		(sp)+, @regs
-			rts
-			endproc
-;__________________________________________________________________________________
-;
-; Allocate the DTDBMgr's globals block
-;
-; FSVars has been allocated by btree patches.  
-;__________________________________________________________________________________	<SM1>
-DTDBMgrInit			proc	export
-					export	QMInit
-
-		move.l			#DTGlobals.size, d0			; we need this much space for DT manager
-		_NewPtr			sys, clear
-		bne				@fail						; no? Run away.
-		move.l			FSVarsPtr, a1				; a1 = ptr(FSVars block)
-		move.l			a0, FSVars.DTDBMgr(a1)		; stuff ourselves into our slot in FSVars
-		rts
-
-@fail
-		moveq.l			#dsMemFullErr, d0			; sys heap is full, so punt
-		_SysError
-
-; Allocate the Queue Manager's globals block
-QMInit			
-
-; Allocate a block big enough of all of the Queue Manager's needs:
-;	Queue manager globals
-;	Desktop manager QMRec
-;	Compatibility layer QMRec
-;	Desktop manager stack
-;	Compatibility layer stack
-
-		move.l			#QMGlobals.size+QMRec.size*2+DTStackSize+clStackSize, d0
-		_NewPtr			sys, clear
-		bne.s			@fail						; fail if we can't get memory
-
-		move.l			FSVarsPtr, a1				; a1 = ptr(FSVars block)
-		move.l			a0, FSVars.QMgr(a1)			; leave a pointer to globals in FSVars
-		move.l			a0, a1						; a1 = ptr(FSVars.QMgr)
-		adda.l			#QMGlobals.size, a0			; skip over globals
-		move.l			a0, QMGlobals.DTQueuePtr(a1); stuff pointer to DTMgr's QMRec
-		adda.l			#QMRec.size, a0				; skip over DTMgr's QMRec
-		move.l			a0, QMGlobals.CLQueuePtr(a1); stuff pointer to Comp Layer's QMRec
-
-		adda.l			#QMRec.size+DTStackSize, a0		; skip over QMRec and Stack
-		move.l			QMGlobals.DTQueuePtr(a1), a1	; a1 = ptr(DTMgr's QMRec)
-		move.l			a0, QMRec.stackBase(a1)			; store stack address (stack grows down)
-		move.w			#desktopQType, QMRec.qType(a1)	; set queue type/refnum
-
-		adda.l			#CLStackSize, a0				; skip to end of CLStack
-		move.l			FSVarsPtr, a1					; a1 = ptr(FSVars)
-		move.l			FSVars.QMgr(a1), a1				; a1 = ptr(QM globals)
-		move.l			QMGlobals.CLQueuePtr(a1), a1	; a1 = ptr(Comp Layer's QMRec)
-		move.l			a0, QMRec.stackBase(a1)			; store stack address (stack grows down)
-		move.w			#fsCompatQType, QMRec.qType(a1)		; set queue type/refnum
-
-		rts
-
-@fail:
-		moveq.l			#dsMemFullErr, d0			; sys heap is full, so punt
-		_SysError
-		endproc
-
-; <SM1> FM needed for GetVolParms
-;________________________________________________________________________________	<SM1>
-;
-; Routine:		CheckDesktopSupport													
-;
-; Input:		a2 - pointer to local volume's vcb
-; Output:		zero flag clear if we support the desktop on this volume
-;				zero flag set if we don't
-;
-; Function: 	Indicate whether a volume can support the desktop manager calls
-;
-; Only call this on local hfs volumes
-;
-; The rule:		A local volume gets desktop support if it is either
-;					1) non-ejectable
-;					2) ejectable but bigger than DTMinVolSize
-;
-; AlkBlkSiz is stored as a long and used as a word throughout HFS
-;________________________________________________________________________________
-CDSRegs			reg			d0/d1/a1
-CheckDesktopSupport	proc	export	
-
-			movem.l	CDSRegs, -(sp)
-
-;
-; Is this an MFS volume?
-;
-			cmp.w	#SigWord,vcbSigWord(a2)	; is this an MFS volume?
-			beq.s	@NoSupport			; yes, so use the exciting resource file technique
-;
-; Is this volume bigger than DTMinVolSize?
-;
-			move.w	vcbNmBlks(a2), d0	; d0 = # of allocation blocks on this volume
-			move.w	vcbAlBlkSiz+2(a2), d1	; d1 = allocation block size
-										; AlkBlkSiz is used as a word throughout HFS
-			mulu.w	d1, d0				; d0 = # bytes on this volume
-			cmp.l	#DTMinVolSize, d0	; is this a big volume?
-			bhs.s	@SupportsDT			; then we always support the DTDB
-;
-; It's not a big volume, but check and see if the volume is ejectable
-;
-			move.l	DrvQHdr+qHead, a1	; a1 = ptr (1st drive in Drive Queue)
-
-			move.w	vcbDrvNum(a2), d0	; d0 = drive number for this volume (if online)
-			bne.s	@SearchDrvQ			; if it's online, we can go straight to the search
-
-			move.w	vcbDRefNum(a2), d1	; d1 = + or - DrvNum (since we know we're not online)
-			cmp.w	d0, d1				; = means volume is ejected
-			beq.s	@NoSupport			; which means it gets no DT support
-			move.w	d1, d0				; d0 now = -DrvNum (since we know it's offline)
-			neg.w	d0					; d0 now = DrvNum, so we can search the drive Q
-;
-; We now have the drive number in d0, and we know that the drive is not big enough to
-; automatically get DT support.  We need to see if it is ejectable, and if it is a small
-; non-ejectable volume (say, a ramdisk) we support it.
-;
-@SearchDrvQ:
-			cmp.w	dQDrive(a1), d0		; is this the dQ entry we want?
-			beq.s	@GotDQ
-			move.l	qLink(a1), d1		; get the next dQ entry (test for zero)
-			movea.l	d1, a1				; move to an A reg where we can use it
-			bne.s	@SearchDrvQ			; and keep going if there is one
-			move.w	#nsvErr, d0			; if we have a real vcb, we should find a dQ entry
-			bra.s	@NoSupport			; but if we ever don't, let's return 'no support'
-
-@GotDQ:
-			cmp.b	#8, -3(a1)			; drive queue entry flag bytes => 8 (signed) are non-ejectable <19><51>
-			blt.s	@NoSupport			; we don't support DT on small ejectable volumes
-
-@SupportsDT:
-			moveq.l	#1, d0				; clear the zero flag
-			bra.s	@CDSExit
-
-@NoSupport:
-			moveq.l	#0, d0				; set the zero flag
-@CDSExit:	movem.l	(sp)+, CDSRegs
-			rts
-			endproc
 ;________________________________________________________________________________
 ;
 ; Routine:		BottleNeckIO
@@ -499,9 +286,7 @@ BottleNeckIO		proc	export
 	move.l			a0, FSVars.dtOwnCall(a1); leave a bread crumb for FileShare <17>
 
 	moveq.l			#desktopQType, d2		; our queue type/refnum
-	move.l			a4,-(sp)				; save a4 <SM3> CSS
-	bigjsr			GetQMRecPtr,a4			; a1 = ptr(QMRec) <SM3> CSS
-	move.l			(sp)+,a4				; recover a4 <SM3> CSS
+	bsr				GetQMRecPtr
 	move.l			a6, QMRec.curStack(a1)	; save current alt stack pointer
 	; •• do high water mark checking here
 
@@ -531,9 +316,7 @@ BottleNeckIO		proc	export
 completionRoutine:
 	moveq.l			#desktopQType, d2		; our queue type/refnum
 	MACHINE			mc68020
-	move.l			a4,-(sp)				; save a4 <SM3> CSS
-	bigjsr			GetQMRecPtr,a4			; a1 = ptr(QMRec) <SM3> CSS
-	move.l			(sp)+,a4				; recover a4 <SM3> CSS
+	bsr				GetQMRecPtr
 	move.l			a6, -(sp)				; save a6 for a sec
 	movea.l			QMRec.curStack(a1), a6	; get our a6 back
 	bset.b			#0, hasContinued(a6)	; mark that we've been back
@@ -546,9 +329,7 @@ completionRoutine:
 contDeskThread:
 	moveq.l			#desktopQType, d2		; our queue type/refnum
 	MACHINE			mc68020
-	move.l			a4,-(sp)				; save a4 <SM3> CSS
-	bigjsr			GetQMRecPtr,a4			; a1 = ptr(QMRec) <SM3> CSS
-	move.l			(sp)+,a4				; recover a4 <SM3> CSS
+	bsr				GetQMRecPtr
 	movea.l			QMRec.curStack(a1), a6	; restore alt stack pointer
 	adda.w			#Lsize, a6				; clear off the locals
 	movem.l			(a6)+, BottleNeckRegs	; restore desktop thread registers
@@ -1313,7 +1094,7 @@ FindDTRegs	reg			d4/a0/a2/a3
 	move.w	d3,ioVRefNum(a0)			; vRef of volume to look at
 	clr.w	ioVolIndex(a0)				; no indexing; use VRef only
 	go_HGetVInfo
-	bne 	Error						; punt on errors <SM2> CSS
+	bne.s	Error						; punt on errors
 	
 	move.w	bigPB+ioVAtrb(a6), d0		; get the volume attributes
 	btst.l	#15, d0						; software locked?

--- a/OS/HFS/LaterFileMgrPatches.a
+++ b/OS/HFS/LaterFileMgrPatches.a
@@ -109,5 +109,14 @@ MFSRenamePatch	PatchProc	ExtFSHook, (Plus)
 										;	 ioResult(A0) later...)
 			jmpOld
 			
+			; this is ugly and temporary....
+			nop
+			nop
+			nop
+			nop
+			nop
+			nop
+
+
 			endProc
 			end
\ No newline at end of file

--- a/OS/InterruptHandlers.a
+++ b/OS/InterruptHandlers.a
@@ -465,6 +465,11 @@
 
 ;	interrupt setup primitives record
 
+IntRegs		reg		a0-a3/d0-d3			; registers saved by all interrupt handlers
+IntRegsSize	equ		8*4					; size of IntRegs in bytes - must change if IntRegs changes!
+										; if this changes, then you must update HALc96Routines.a to handle
+										; both old and new cases.
+
 InterruptPrims	RECORD	{intInitPostProc},INCREMENT
 flags			DS.W	1							; miscellaneous flags
 count			DS.W	1							; number of entries in the table

--- a/OS/Keyboard/Kbd.r
+++ b/OS/Keyboard/Kbd.r
@@ -1679,263 +1679,6 @@ resource 'KCHR' (0, USname, KCHRAttributes) {											/*<11>*/
 			}
 		}
 	};
-
-// Norsi (Apple Adjustable) keypad     						<17>  10/22/92  JMF
-
-	resource 'KCAP' ($0E) {
-		{60, 125, 220, 365},
-		{12, 42, 36, 198},
-		{
-			{ {21, 21} }, {
-				noMask, $7A, 50, 10;	/* F1 */
-				noMask, $78, 0, 20;		/* F2 */
-				noMask, $63, 0, 20;		/* F3 */
-				noMask, $76, 20, -40;	/* F4 */
-				noMask, $60, 0, 20;		/* F5 */
-				noMask, $61, 0, 20;		/* F6 */
-				noMask, $62, 20, -40;	/* F7 */
-				noMask, $64, 0, 20;		/* F8 */
-				noMask, $65, 0, 20;		/* F9 */
-				noMask, $6D, 20, -40;	/* F10 */
-				noMask, $67, 0, 20;		/* F11 */
-				noMask, $6F, 0, 20;		/* F12 */
-				noMask, $69, 20, -40;	/* F13 */
-				noMask, $6B, 0, 20;		/* F14 */
-				noMask, $71, 0, 20;		/* F15 */
-				noMask, $72, -80, 30;	/* help */
-				noMask, $73, 0, 20;		/* home */
-				noMask, $74, 0, 20;		/* page up */
-				noMask, $79, 20, 0;		/* page down */
-				noMask, $77, 0, -20;	/* end */
-				noMask, $75, 0, -20;	/* delete */
-				noMask, $7E, 40, 20;	/* up arrow */
-				noMask, $7B, 20, -20;	/* left arrow */
-				noMask, $7D, 0, 20;		/* down arrow */
-				noMask, $7C, 0, 20;		/* right arrow */
-				noMask, $41, 0, 70;		/* . */
-				noMask, $55, -20, 0;	/* 3 */
-				noMask, $54, 0, -20;	/* 2 */
-				noMask, $53, 0, -20;	/* 1 */
-				noMask, $56, -20, 0;	/* 4 */
-				noMask, $57, 0, 20;		/* 5 */
-				noMask, $58, 0, 20;		/* 6 */
-				noMask, $45, 0, 20;		/* + */
-				noMask, $4E, -20, 0;	/* - */
-				noMask, $5C, 0, -20;	/* 9 */
-				noMask, $5B, 0, -20;	/* 8 */
-				noMask, $59, 0, -20;	/* 7 */
-				noMask, $47, -20, 0;	/* clear */
-				noMask, $51, 0, 20;		/* = */
-				noMask, $4B, 0, 20;		/* / */
-				noMask, $43, 0, 20;		/* * */
-			};
-
-			{ {21, 41} }, {
-				noMask, $52, 130, 150;	/* 0 */
-			};
-
-			{ {41, 21} }, {
-				noMask, $4C, 110, 210;	/* enter */
-			};
-		}
-	};
-
-
-
-// Domestic Norsi (Apple Adjustable) keyboard     				<17>  10/22/92  JMF
-
-	resource 'KCAP' ($10) {
-		{60, 45, 240, 435},
-		{12, 42, 36, 348},
-		{
-			{ {21, 21} }, {
-				noMask, $35, 50, 10;	/* escape */
-				noMask, $12, 0, 70;		/* 1 ! */
-				noMask, $13, 0, 20;		/* 2 @ */
-				noMask, $14, 0, 20;		/* 3 # */
-				noMask, $15, 0, 20;		/* 4 $ */
-				noMask, $17, 0, 20;		/* 5 % */
-				noMask, $16, 0, 40;		/* 6 ^ */
-				noMask, $1A, 0, 20;		/* 7 & */
-				noMask, $1C, 0, 20;		/* 8 * */
-				noMask, $19, 0, 20;		/* 9 ( */
-				noMask, $1D, 0, 20;		/* 0 ) */
-				noMask, $1B, 0, 20;		/* - _ */
-				noMask, $18, 0, 20;		/* = + */
-				noMask, $1E, 20, 10;	/* ] } */
-				noMask, $21, 0, -20;	/* [ { */
-				noMask, $23, 0, -20;	/* P */
-				noMask, $1F, 0, -20;	/* O */
-				noMask, $22, 0, -20;	/* I */
-				noMask, $20, 0, -20;	/* U */
-				noMask, $10, 0, -20;	/* Y */
-				noMask, $11, 0, -40;	/* T */
-				noMask, $0F, 0, -20;	/* R */
-				noMask, $0E, 0, -20;	/* E */
-				noMask, $0D, 0, -20;	/* W */
-				noMask, $0C, 0, -20;	/* Q */
-				noMask, $00, 20, 5;		/* A */
-				noMask, $01, 0, 20;		/* S */
-				noMask, $02, 0, 20;		/* D */
-				noMask, $03, 0, 20;		/* F */
-				noMask, $05, 0, 20;		/* G */
-				noMask, $04, 0, 40;		/* H */
-				noMask, $26, 0, 20;		/* J */
-				noMask, $28, 0, 20;		/* K */
-				noMask, $25, 0, 20;		/* L */
-				noMask, $29, 0, 20;		/* ; : */
-				noMask, $27, 0, 20;		/* ' " */
-				noMask, $7E, 20, 45;	/* up arrow */
-				noMask, $2C, 0, -55;	/* / ? */
-				noMask, $2F, 0, -20;	/* . > */
-				noMask, $2B, 0, -20;	/* , < */
-				noMask, $2E, 0, -20;	/* M */
-				noMask, $2D, 0, -20;	/* N */
-				noMask, $0B, 0, -40;	/* B */
-				noMask, $09, 0, -20;	/* V */
-				noMask, $08, 0, -20;	/* C */
-				noMask, $07, 0, -20;	/* X */
-				noMask, $06, 0, -20;	/* Z */
-				noMask, $7B, 20, 215;	/* left arrow */
-				noMask, $7C, 0, 20;		/* right arrow */
-				noMask, $7D, 0, 20;		/* down arrow */
-			};
-
-			{ {21, 26} }, {
-				noMask, $3A, 130, 80;	/* option */
-				noMask, $37, 0, 215;	/* right command */
-			};
-
-			{ {21, 31} }, {
-				noMask, $32, 50, 50;	/* ` ~ */
-				noMask, $3B, 80, 0;		/* control */
-				noMask, $37, 0, 55;		/* left command */
-				noMask, $2A, -60, 245;	/* \ | */
-			};
-
-			{ {21, 36} }, {
-				noMask, $38, 110, 325;	/* right shift */
-			};
-			
-			{ {21, 41} }, {
-				noMask, $30, 70, 50;	/* tab */
-				noMask, $33, -20, 290;	/* backspace */
-			};
-			
-			{ {21, 46} }, {
-				noMask, $39, 90, 50;	/* caps lock */
-				noMask, $24, 0, 285;	/* return */
-			};
-
-			{ {21, 56} }, {
-				noMask, $38, 110, 50;	/* left shift */
-			};
-
-			{ {31, 141} }, {
-				noMask, $31, 140, 145	/* space */
-			};
-
-		}
-	};
-
-
-
-// ISO Norsi (Apple Adjustable) keyboard     				<17>  10/22/92  JMF
-
-	resource 'KCAP' ($11) {
-		{60, 45, 240, 435},
-		{12, 42, 36, 348},
-		{
-			{ {21, 21} }, {
-				noMask, $35, 50, 10;	/* escape */
-				noMask, $12, 0, 70;		/* 1 ! */
-				noMask, $13, 0, 20;		/* 2 @ */
-				noMask, $14, 0, 20;		/* 3 # */
-				noMask, $15, 0, 20;		/* 4 $ */
-				noMask, $17, 0, 20;		/* 5 % */
-				noMask, $16, 0, 40;		/* 6 ^ */
-				noMask, $1A, 0, 20;		/* 7 & */
-				noMask, $1C, 0, 20;		/* 8 * */
-				noMask, $19, 0, 20;		/* 9 ( */
-				noMask, $1D, 0, 20;		/* 0 ) */
-				noMask, $1B, 0, 20;		/* - _ */
-				noMask, $18, 0, 20;		/* = + */
-				noMask, $1E, 20, 10;	/* ] } */
-				noMask, $21, 0, -20;	/* [ { */
-				noMask, $23, 0, -20;	/* P */
-				noMask, $1F, 0, -20;	/* O */
-				noMask, $22, 0, -20;	/* I */
-				noMask, $20, 0, -20;	/* U */
-				noMask, $10, 0, -20;	/* Y */
-				noMask, $11, 0, -40;	/* T */
-				noMask, $0F, 0, -20;	/* R */
-				noMask, $0E, 0, -20;	/* E */
-				noMask, $0D, 0, -20;	/* W */
-				noMask, $0C, 0, -20;	/* Q */
-				noMask, $00, 20, 5;		/* A */
-				noMask, $01, 0, 20;		/* S */
-				noMask, $02, 0, 20;		/* D */
-				noMask, $03, 0, 20;		/* F */
-				noMask, $05, 0, 20;		/* G */
-				noMask, $04, 0, 40;		/* H */
-				noMask, $26, 0, 20;		/* J */
-				noMask, $28, 0, 20;		/* K */
-				noMask, $25, 0, 20;		/* L */
-				noMask, $29, 0, 20;		/* ; : */
-				noMask, $27, 0, 20;		/* ' " */
-				noMask, $2A, 0, 20;		/* \ | */
-				noMask, $7E, 20, 25;	/* up arrow */
-				noMask, $2C, 0, -55;	/* / ? */
-				noMask, $2F, 0, -20;	/* . > */
-				noMask, $2B, 0, -20;	/* , < */
-				noMask, $2E, 0, -20;	/* M */
-				noMask, $2D, 0, -20;	/* N */
-				noMask, $0B, 0, -40;	/* B */
-				noMask, $09, 0, -20;	/* V */
-				noMask, $08, 0, -20;	/* C */
-				noMask, $07, 0, -20;	/* X */
-				noMask, $06, 0, -20;	/* Z */
-				noMask, $32, 0, -20;	/* ` ~ */
-				noMask, $7B, 20, 235;	/* left arrow */
-				noMask, $7C, 0, 20;		/* right arrow */
-				noMask, $7D, 0, 20;		/* down arrow */
-			};
-
-			{ {21, 26} }, {
-				noMask, $3A, 130, 80;	/* option */
-				noMask, $37, 0, 215;	/* right command */
-			};
-
-			{ {21, 31} }, {
-				noMask, $0A, 50, 50;	/* ISO */
-				noMask, $3B, 80, 0;		/* control */
-				noMask, $37, 0, 55;		/* left command */
-			};
-
-			{ {21, 36} }, {
-				noMask, $38, 110, 50;	/* left shift */
-				noMask, $38, 0, 275;	/* right shift */
-			};
-			
-			{ {21, 41} }, {
-				noMask, $30, 70, 50;	/* tab */
-				noMask, $33, -20, 290;	/* backspace */
-			};
-			
-			{ {21, 46} }, {
-				noMask, $39, 90, 50;	/* caps lock */
-			};
-
-			{ {31, 141} }, {
-				noMask, $31, 140, 145	/* space */
-			};
-
-			{ {21, 31}; {41, 5} }, {
-				noMask, $24, 70, 350;	/* return */
-			};
-
-		}
-	};
 	
 #endif
 

--- a/OS/Keyboard/KbdInstall.a
+++ b/OS/Keyboard/KbdInstall.a
@@ -16,10 +16,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<4>	 	10/22/92	JMF		Added changes so that the modifiers of the last KEYBOARD
-;									pressed are the modifiers that the Norsi KEYPAD uses,
-;									since the KEYPAD has no modifier keys of its own.
-;		<3>		10/22/92	JMF		Incorporated ROM keyboard Driver into ADBS Resource ID=2.
 ;		<2>		12/28/89	dba		Used MAIN instead of PROC to get dead code stripping.
 ;	  <1.1>	 	 8/28/89	SES		Removed references to nFiles.
 ;	  <1.0>		11/16/88	CCH		Added to EASE.
@@ -83,10 +79,6 @@ keypadNorsi	EQU		$0E					; Handler ID for Norsi ergonomic keypad
 
 KbdInst		MAIN	EXPORT
 
-			BRA.S	@Start				; Branch around version number
-			
-			DC.W	$0001				; Version number
-			
 @Start		MOVEM.L	D3-D7/A2-A4, -(SP)	; Save the registers
 			LINK	A6, #KISize			; Save space on stack
 
@@ -96,10 +88,9 @@ KbdInst		MAIN	EXPORT
 			_GetADBInfo
 
 			ADDQ.L	#2, SP				; Discard OrigAddr and DeviceType
-			MOVE.L	4(SP), A0			; Put the data address in A0
-			MOVE.L	A0, D0				; See if it is a real address
-			BEQ.S	@AllocBuf			; Skip DisposPtr, if no buffer allocated yet
-			_DisposPtr					; Dispose of data allocated by the ROM
+			MOVE.L	4(SP), A1			; Put the data address in A1
+			MOVE.L	A1, D0				; See if it is a real address
+			BNE.S	KCHRLoad			; Buffer already allocated by ROM
 
 @AllocBuf	MOVE.L	#KbdDSize, D0		; Amount of space needed for new keyboard drvr data
 			_NewPtr	,SYS,CLEAR			; Get a pointer
@@ -180,8 +171,6 @@ GotKMAP
 
 			MOVE.W	D2, D0				; ADB Address
 			MOVE.L	A1, 4(SP)			; Replace the data address
-			LEA		KbdDrvr, A0			
-			MOVE.L	A0, (SP)
 			MOVE.L	SP, A0				; Pointer to two addresses
 			_SetADBInfo
 
@@ -208,350 +197,14 @@ Done
 			UNLK	A6					;							
 			MOVEM.L	(SP)+, D3-D7/A2-A4	; Restore the registers		
 
+			LEA		KbdInst,A0
+			_RecoverHandle
+			_DisposeHandle
+
 			RTS							; End KbdInst
 
 
 
-;_________________________________________________________________________________________
-;
-; Routine:		KbdDrvr 
-; Arguments:	D0.B	ADB Command
-;				A0.L	ADB Buffer address
-;				A1.L	ADB Completion Routine Address (= KbdServ)
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function:		Reads buffer and posts keyboard events as appropriate.
-; Side Effects:	Trashes A0, A1, D0, D1, D2, D3
-;
-;_________________________________________________________________________________________
-
-KbdDrvr		MOVE.L	A2, D3				; See if A2 actually contains a pointer
-			BEQ		KbdDone				; If not, can't go on.
-
-			MOVE.L	A0, A1				; Save A0 in A1
-			LSR.W	#4, D0				; Shift ADB Address down to low nibble
-			MOVEQ	#$F, D1				; Mask for ADB Address
-			AND.L	D1, D0				; D0 now contains ADB Address
-			MOVE.L	D0, D3				; Save it in D3
-			LEA		-10(SP), SP			; Build parameter block on stack
-			MOVE.L	SP, A0				; Point to it
-			_GetADBInfo
-
-			ROR.L	#8, D3				; Rotate ADB Address to high byte
-			MOVE.W	(SP)+, D3			; Put Device Type, Orig Addr in low word
-			ADDQ.L	#8, SP				; Clear off the rest of the stack
-			SWAP	D3					; D3 is now Device Type;Orig Addr;ADB Addr;Unused
-
-			MOVE.B	1(A1), D0			; Get first stroke
-			MOVE.B	2(A1), -(SP)		; Save second one on stack
-			BSR.S	KeyIn
-			MOVE.B	(SP)+, D0			; Get second stroke
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		KeyIn
-; Arguments:	D0.B	Raw Keycode
-;				D3.L	Device Type, Orig Addr, ADB Addr, Unused
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function		Translates keycode and posts event as appropriate.
-; Side Effects:	Trashes A0, A1, D0, D1, D2, D3
-; Called From:	KbdDrvr twice, (1 BSR, 1 fall-through)
-;
-;_________________________________________________________________________________________
-
-KeyIn		CMP.B	#$FF, D0			; Is it not a key?
-			BEQ 	KbdDone				; Skip if so
-
-			CLR.W	KeyLast				; Stop repeating
-			CLR.W	HiKeyLast			; Stop repeating
-
-			MOVEQ	#$7F, D1			; Mask = 01111111 binary
-			AND.B	D0, D1				; Clear all but low 7 bits
-
-			MOVE.L	KMAPPtr(A2), A1		; Get KMAP table address
-			MOVE.B	KMstart(A1, D1), D3	; Get device independent keycode
-			BPL.S	NoExcept			; Handle normally if high bit clear
-
-	; An exception has been indicated.  Find the correct entry in the exception
-	; table and handle as appropriate.
-			BCLR	#7, D3				; Clear the high bit
-			LEA		KMnumEx(A1), A0		; Get to the beginning of the exceptions
-			MOVE.W	(A0)+, D2			; Number of entries in table
-			BEQ.S	NoExcept			; Skip if none
-			SUBQ.W	#1, D2				; Turn it into a zero-based count
-
-ExLoop
-			CMP.B	(A0)+, D0			; See if this is the one
-			BEQ		FoundEx				; Skip if so
-			MOVE.B	1(A0), D1			; Get the string length
-			LEA		2(A0, D1), A0		; Point to the next entry
-			DBRA	D2, ExLoop			; Go around again
-
-NoExcept
-			MOVEQ	#0, D2				; Clear out D2
-			MOVE.B	D3, D2				; Copy virtual keycode to D2
-			LSR.W	#3, D2				; Divide by 8 for byte offset
-
-			TST.B	D0					; Up or down key?
-			BMI.S	KeyUp				; Skip around if key up
-			BSET	D3, KeyBits(A2, D2)	; Set it for key down
-			BRA.S	Hammer
-KeyUp
-			BCLR	D3, KeyBits(A2, D2)	; Clear it for key up
-			BSET	#7, D3				; Remember key up for raw key.
-
- ;* Begin Norsi Keypad changes (keypad uses modifiers from last keyboard pressed) 04/21/92* 
-Hammer		MOVE.L	D3, D0				; Get Device Type, Orig Addr, ADB Addr, keycode
-			ROL.L	#8, D0				; Rotate Device Type into low byte
-			CMP.B	#keypadNorsi, D0	; Is this a Norsi ergonomic KEYPAD?
-			BNE.S	HammerKeyMap		; If not, go update the keymap
-			MOVE.W	KeyMap+6, D0		; Modifier bits of last pressed keyboard  
-			AND.W	#$807F,D0			; Mask off non-modifier bits
-			MOVE.W	KeyBits+6(A2), D1	; Get Norsi KEYPAD's pseudo modifier bits
-			AND.W	#$7F80,D1			; Mask off KEYPAD's old modifier bits
-			OR.W	D0, D1				; Replace KEYPAD's modifier bits with the modifier
-			MOVE.W	D1, KeyBits+6(A2)	;  bits from the last pressed keyboard
- ;* End Norsi Keypad changes (keypad uses modifiers from last keyboard pressed) 04/21/92* 
-			
-HammerKeyMap			
-			MOVEM.L	KeyBits(A2), D0-D2/A0	; Get current devices map of key pressed or not
-			MOVEM.L	D0-D2/A0, KeyMap		; Hammer this devices map into global keymap
-			MOVE.L	D3, D0					; Bits 15-8 contain ADB address
-			LSR.L	#8, D0					; Put it in the low byte
-			MOVE.B	D0, KbdLast				; Stuff it down
-			SWAP	D0						; Now get DeviceType
-			MOVE.B	D0, KbdType				; Update KbdType to show last one used
-	
-	; The next two instructions build the byte of modifier flags from the
-	; global key state information.  This works because the modifier flags
-	; exist in bits $37 to $3E, which appear in the following manner:
-	; Byte	|			6			|			7			|
-	; Bit	|37 36 35 34 33 32 31 30|3F 3E 3D 3C 3B 3A 39 38|
-	;		|^^						|	^^ ^^ ^^ ^^ ^^ ^^ ^^|
-			MOVE.W	KeyBits+6(A2), D0	; Get modifier word
-			ROL.W	#1, D0				; Rotate in command key
-
-			SUBQ.L	#4, SP				; Make room for result
-			MOVE.L	KCHRPtr(A2), -(SP)	; Push address of KCHR resource
-			MOVE.W	D3, -(SP)			; Push keycode (w/o modifiers)
-			MOVE.B	D0, (SP)			; Put modifiers where they belong
-			PEA		DeadKey(A2)			; Push address of dead key state
-			_KeyTrans
-
-			MOVE.W	(SP)+, D0			; Get the high word first
-			BEQ.S	NextWord			; Skip if null
-			BSR.S	PostIt				; Otherwise post the event
-NextWord
-			MOVE.W	(SP)+, D0			; Get the other word
-			BEQ.S	KbdDone				; If null, we're done
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		PostIt
-; Arguments:	D0.W	ASCII Code
-;				D3.W	ADB Address in high byte and raw keycode in low byte
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function		Posts the keyboard event as appropriate.
-; Side Effects:	Trashes A0, D0, D1
-; Called From:	KeyIn twice, (1 BSR, 1 fall-through)
-;
-;_________________________________________________________________________________________
-
-PostIt		ROR.W	#8, D0				; Swap ASCII high and low byte (xxLH)
-			SWAP	D0					; Move to high word (LHxx)
-			MOVE.W	D3, D0				; Move in ADB address and raw keycode (LHFR)
-			ROL.L	#8, D0				; Rotate around (HFRL)
-
-			TST.B	D3					; Key up or down?
-			BMI.S	PostKeyUp			; Skip if key up
-			MOVE.L	Ticks, D1
-			MOVE.L	D1, KeyTime			; Mark the time for auto repeat
-			MOVE.L	D1, KeyRepTime
-			MOVE.W	D0, KeyLast			; Save event message
-			SWAP	D0
-			MOVE.W	D0, HiKeyLast		; Save high word too
-			SWAP	D0
-			MOVE	#KeyDwnEvt, A0		; Get event number
-			_PostEvent					; Post it
-KbdDone
-			RTS							; And leave
-PostKeyUp
-			MOVE	#KeyUpEvt, A0		; Get event number
-			BCLR	#15, D0				; Clear the up/down bit in the raw keycode
-			_PostEvent					; Post it
-			RTS							; End KbdDrvr
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		FoundEx
-; Arguments:	A0.L	Pointer to exception data
-;				A2.L	Pointer to private data area
-;				D3.W	Virtual keycode
-; Output:		None
-; Function		An exception exists for this particular keystroke.  Process it 
-;				appropriately.
-; Side Effects:	Trashes A0, D0, D1, D2
-; Called From:	KeyIn twice, (1 BSR, 1 fall-through)
-;
-;_________________________________________________________________________________________
-FoundEx
-			MOVE.B	(A0)+, D1			; Get the operand
-			BPL.S	@notXORKey			; Skip if not
-
-			MOVEQ	#0, D2				; Clear out D2
-			MOVE.B	D3, D2				; Copy virtual keycode to D2
-			LSR.W	#3, D2				; Divide by 8 for byte offset
-			BTST	D3, KeyBits(A2, D2)	; Get current key state
-			SEQ		D0					; Invert and put in D0
-
-@notXORKey
-			MOVEQ	#$F, D2				; Prepare mask for ADB op
-			AND.B	D1, D2				; D2 is ADB op w/o net address
-			BEQ.S	KbdDone				; If ADB op = 0 (Bus Reset), ignore key
-
-			TST.B	KNoADBOp(A2)		; See if we should even do this
-			BNE		NoExcept			; Skip if not
-			MOVEM.L	D0/A1, -(SP)		; Save D0 & A1
-			MOVE.L	A0, -(SP)			; Data address = mask
-			CMP.B	#TalkCmd, D2		; Is it a talk command?
-			BGE.S	@kbdTalk			; Skip if so
-			PEA		KbdBufFree			; Completion routine = KbdBufFree
-			BRA.S	@kbdBufAlloc
-@kbdTalk
-			PEA		KbdListen			; Completion Routine = KbdListen
-
-@kbdBufAlloc
-			LEA		KNumBufs(A2), A1	; Point to the number of available buffers
-			MOVE.B	(A1)+, D1			; Get the number of buffers
-			BEQ.S	@kNoBufAvail		; Skip if none available
-			SUBQ.W	#1, D1				; Turn it into a zero based count
-@kBufLoop
-			TST.B	(A1)+				; Is the buffer busy?
-			BEQ.S	@kGotABuf			; No, Go use it
-			LEA		KBufLen-1(A1), A1	; Point to the next one
-			DBRA	D1, @kBufLoop		; Go around again
-			BRA.S	@kNoBufAvail		; It's a loss
-
-@kGotABuf
-			MOVE.B	D0, -1(A1)			; Store the up/down state in the busy info
-			BSET	#1, -1(A1)			; Make sure it shows up as busy
-			MOVE.L	A1, -(SP)			; Buffer Address
-
-			MOVE.B	(A0), D1			; Get length of source string
-			CMP.B	#8, D1				; Greater than 8?
-			BLS.S	@kStrCopyLoop		; If not, no problem
-			MOVEQ	#8, D1				; Copy only the first 8 to avoid trashing mem
-@kStrCopyLoop
-			MOVE.B	(A0)+, (A1)+		; Start copying the string
-			DBRA	D1, @kStrCopyLoop	; Repeat D1+1 times
-
-			MOVE.W	D3, D0				; Get the FDB Address
-			CLR.B	D0					; Clear out the low byte
-			LSR.W	#4, D0				; Shift it down to form high nibble of ADB Command
-			OR.B	D2, D0				; Include low op nibble
-			MOVE.L	SP, A0				; Point to parameter block
-			_ADBOp						; Pray that everything is OK
-			BNE.S	@kOpFailed			; Branch if not
-			ADDQ.L	#4, SP				; Pop Buffer Address
-@kNoBufAvail
-			ADDQ.L	#8, SP				; Pop Completion and Data Address
-			MOVEM.L	(SP)+, D0/A1		; Restore D0 & A1
-			BRA		NoExcept			; Finish dealing with the keystroke
-
-@kOpFailed
-			MOVE.L	(SP)+, A1			; Get the buffer address
-			CLR.B	-1(A1)				; Mark it as not busy
-			BRA.S	@kNoBufAvail		; End FoundEx
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		KbdListen
-; Arguments:	D0.B	ADB Command
-;				D1.L	DeviceType, OrigAddr, ADBAddr, Unused (byte order)
-;				A0.L	ADB Buffer Address
-;				A1.L	ADB Completion Routine Address (= KbdListen)
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function:		Sets or clears bits in mask pointed to by A2 in buffer pointed
-;				to by A0.  Used to alter values of registers in ADB devices.
-; Side Effects:	Trashes A0, A1, A2, D0, D1, D2
-;
-;_________________________________________________________________________________________
-
-KbdListen	MOVE.L	A0, A1				; Copy A0 into A1
-			MOVEQ	#0, D1				; Clear out D1
-			MOVE.B	(A1)+, D1			; Get length of buffer
-			MOVE.B	(A2)+, D2			; Get length of mask
-			CMP.B	D2, D1				; Is mask length smaller?
-			BLS.S	@notSmall			; Skip if not
-			MOVE.B	D2, D1				; Use the mask length instead
-@notSmall
-; (A2) is a mask for (A0), 0 meaning don't change, 1 meaning clear or set
-; depending upon the value of -1(A0).
-			TST.B	-1(A0)				; PL = clear, MI = set
-			BPL.S	@endClrLoop
-			BRA.S	@endSetLoop
-
-@setLoop
-			MOVE.B	(A2)+, D2			; Get the mask byte
-			OR.B	D2, (A1)+			; Set the correct bits
-@endSetLoop
-			DBRA	D1, @setLoop		; Go around again
-			BRA.S	@kLoopDone
-
-@clrLoop
-			MOVE.B	(A2)+, D2			; Get the mask byte
-			NOT.B	D2					; Invert it
-			AND.B	D2, (A1)+			; Clear the correct bits
-@endClrLoop
-			DBRA	D1, @clrLoop		; Go around again
-
-@kLoopDone
-			CLR.L	-(SP)				; No data address needed
-			PEA		KbdBufFree			; Completion routine = KbdBufFree
-			MOVE.L	A0, -(SP)			; Use the buffer one more time
-			MOVE.L	SP, A0				; Point to parameter block
-			BCLR	#2, D0				; Turn the talk into a listen command
-			_ADBOp
-			BNE.S	@kLSuccess			; Branch on success
-
-			MOVE.L	(SP), A0			; Get the buffer address
-			CLR.B	-1(A0)				; Mark it as not busy
-@kLSuccess
-			LEA		12(SP), SP			; Pop the parameter block
-			RTS							; End KbdListen
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		KbdBufFree
-; Arguments:	D0.B	ADB Command
-;				D1.L	DeviceType, OrigAddr, ADBAddr, Unused (byte order)
-;				A0.L	ADB Buffer Address
-;				A1.L	ADB Completion Routine Address (= KbdListen)
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function:		Marks the buffer pointed to by A0 as free.
-; Side Effects:	None
-;
-;_________________________________________________________________________________________
-
-KbdBufFree	CLR.B	-1(A0)		; Mark buffer free
-			RTS					; End KbdBufFree
-
-
-
 ;_________________________________________________________________________________________
 ;_________________________________________________________________________________________
 ;_________________________________________________________________________________________

--- a/OS/SCSIMgr/SCSILinkPatch.a
+++ b/OS/SCSIMgr/SCSILinkPatch.a
@@ -493,6 +493,7 @@ SCSIBusyCommon
 ;
 ; 	In SuperMario, this is part of SCSIGlobals.
 
+	export SCSIBusyVector
 FreeHookPending	dc.l	0					; location of pending free-hook flag
 SCSIBusyVector	dc.l	0
 

--- a/OS/SCSIMgr/SCSIMgrInit96.a
+++ b/OS/SCSIMgr/SCSIMgrInit96.a
@@ -57,7 +57,7 @@
 										;	don't print includes
 
 			LOAD		'StandardEqu.d'			; from StandardEqu.a and for building ROMs
-			INCLUDE		'HardwareEqu.a'			;													<T2>
+			INCLUDE		'HardwarePrivateEqu.a'			;													<T2>
 			INCLUDE		'SCSI.a'
 			INCLUDE 	'SCSIPriv.a'
 			INCLUDE		'UniversalEqu.a'		; for TestFor										<T2>

--- a/OS/SlotMgr/SlotMgr.a
+++ b/OS/SlotMgr/SlotMgr.a
@@ -19,7 +19,6 @@
 ;	  <SM11>	11/18/92	kc		Import GetDriverPatch to fix problem introduced by last checkin.
 ;	  <SM10>	11/17/92	kc		Add "IF NOT LC930 THEN" around GetDriverPatch to facilitate dead
 ;									code stripping for the LC930 build.
-;	   <SM9>	10/22/92	CSS		Change some branch short instructions to branches.
 ;	   <SM8>	09-24-92	jmp		Fixed a bug in the GetDevIndex utility where a register was
 ;									being trashed.
 ;	   <SM7>	 6/30/92	kc		Roll in Horror, comments follow:
@@ -391,14 +390,14 @@ GetcString	Proc	Export
 			move.b	spSlot(a0),-(sp)				; save the slot
 
 			_sFindStruct							; get the ptr to the string
-			bne 	@Done							; <SM9> CSS
+			bne.s	@Done
 			movea.l	spsPointer(a0),a3				; a3 = ptr to the string
 
 ;  Calculate the step register
 
 			bset.b	#fConsecBytes,spFlags(a0)		; calc for consecutive bytes
 			_sCalcStep
-			bne 	@Done							; <SM9> CSS 
+			bne.s	@Done
 			move.l	spResult(a0),d1					; d1 = step register
 
 ;	Loop and count all the chars in the string so we know how big a block to allocate. 
@@ -866,8 +865,6 @@ FindDevBase	Proc	Export
 			bne.s	@Major							; minor base offset not found
 			move.l	spResult(a0),d1					; d1 = minor base offset
 			and.l	#$00ffffff,d1					; max offset in minor slot space
-			tst.b	spSlot(a0)						; getting base addr for slot zero ?				<H2>
-			beq.s	@SlotZero
 			bra.s	@FormSmall						; form a 1Mb or 16Mb ptr
 
 ;	No minor base - try to get the major base offset
@@ -877,8 +874,6 @@ FindDevBase	Proc	Export
 			bne.s	@Done							; major base offset not found - error
 			move.l	spResult(a0),d1					; d1 = major base offset
 			and.l	#$0fffffff,d1					; max offset in major slot space
-			tst.b	spSlot(a0)						; getting base addr for slot zero ?				<H2>
-			beq.s	@SlotZero
 
 ;	Form a major base pointer (256Mb space) : d2 = slot number
 
@@ -928,9 +923,6 @@ FindDevBase	Proc	Export
 			movea.l	(sp)+,a1						;										<1.8>
 			rts
 
-@SlotZero	Bsr.l	FindDevBaseSlot0				; Jump to our SlotZero utility.					<H2>
-			Bra.s	@RtnBase						; And exit.
-
 
 ;=========================================================================================
 ;	smAdvanced
@@ -1417,7 +1409,7 @@ EndDynLoad														;							<1.8>
 				
 ;  Get a pointer to the sResource list and find the driver directory.
 StatLoadDrvr	_sRsrcInfo										;Get a pointer to the sResource list.	<C468>
-				BNE 	SError2								; <SM9> CSS 
+				BNE.S	SError2
 				MOVE.B	#sRsrcDrvrDir,spId(ParamBlk$a0)		;Find the driver directory.
 				_sFindStruct
 				BNE.S	SError2
@@ -1454,6 +1446,7 @@ LoadDrvr		MOVE.B	#sMacOS68020,spId(ParamBlk$a0)			;Load a MacOS 68020 driver.
 																;  GOTO SError1.						<C600>
 				MOVE.L	DrvrHand$a,spResult(ParamBlk$a0)		;Put handle to the driver in spResult.	<C600>
 				JSR		([jCacheFlush])							; flush the caches  <18> rb
+				MOVEQ	#0,d0
 				BRA.S	EndStatLoad								;GOTO end.								<C600>
 				
 ;  ERRORS
@@ -1483,15 +1476,6 @@ EndStatLoad		RTS
 ;	Patch out Drivers for any Apple Cards that need it.
 
 BeginGetSlotDrvr
-			IF NOT LC930 THEN
-				Import	GetDriverPatch
-				Bsr		GetDriverPatch						; If GetDriverPatch returns a 
-				Tst.b	D0									;	result >= 0, don’t execute
-				Bge.s	ExitGetSlotDrvr						; Patched, so just return.
-			ENDIF
-;	This is the original entry-point. It is called by GetDevIndex
-				Export	OrigGetSlotDrvr
-OrigGetSlotDrvr
 				MOVEM.L	A2-A3,-(SP)								;Save registers		<C783>
 				MOVE.L	ParamBlk$a0,spBlkPtr$a					;Save spBlkPtr
 				MOVE.B	spId(ParamBlk$a0),SavedId$d				;Save Id.
@@ -1550,7 +1534,7 @@ GetDriverPatch		Proc	Export
 ;
 			Bsr		GetDevIndex							; Get the card/device index into D0.
 			Move.l	D0,D3								; If the device index is negative, then
-			Bmi 	@done								; driver doesn’t need patching.<SM9> CSS	
+			Bmi.s	@done								; driver doesn’t need patching.
 
 ; Next, check to see that we’re pointing to the sResource that has the driver or
 ;	driver loader in it (i.e., we don’t want to be opening the driver multiple
@@ -1646,7 +1630,7 @@ GetDriverPatch		Proc	Export
 			Macro										; Macro for jumping directly int
 			_GetSlotDriver								;	GetSlotDrvr (acting like trap dispatcher).								
 			Movem.l	A1/D1-D2,-(Sp)						; Save registers (A0 i/o, D0 is result).
-			Bsr.l	OrigGetSlotDrvr						; Make call.					<T8>
+;			jsr	OrigGetSlotDrvr						; Make call.					<T8>
 			Tst.w	D0									; Act like Slot Manager for result.
 			Movem.l	(Sp)+,A1/D1-D2						; Restore registers.
 			EndMacro									;
@@ -1728,28 +1712,28 @@ GetDevIndex
 			
 			Export	JsrTbl
 
-DevTbl		Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwTFB,0	 ; TFB  Entry									<11>
-			Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwJMFB,0 ; JMFB Entry									<11>
-			Dc.w	0									
+DevTbl		;Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwTFB,0	 ; TFB  Entry									<11>
+			;Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwJMFB,0 ; JMFB Entry									<11>
+			;Dc.w	0									
 					
 			Align	4
 			
-LoadTbl		Dc.l	TFBDrvr-LoadTbl						; Start of TFB driver code.	
-			Dc.l	TFBDrvrSize-LoadTbl					; Length.
-			Dc.b	sRsrcDrvrDir						; TFB’s have an sRsrcDrvrDir.
-			Dc.b	0									; TFB’s are singly deviced.
-			Dc.b	0,0									; Padding.											<11>
+LoadTbl		;Dc.l	TFBDrvr-LoadTbl						; Start of TFB driver code.	
+			;Dc.l	TFBDrvrSize-LoadTbl					; Length.
+			;Dc.b	sRsrcDrvrDir						; TFB’s have an sRsrcDrvrDir.
+			;Dc.b	0									; TFB’s are singly deviced.
+			;Dc.b	0,0									; Padding.											<11>
 			
-			Dc.l	JMFBDrvr-LoadTbl					; Start of 4•8/8•24 driver code.
-			Dc.l	JMFBDrvrSize-LoadTbl				; Length.
-			Dc.b	sRsrcDrvrDir						; 4•8/8•24’s have an sRsrcDrvrDir.
-			Dc.b	0									; 4•8/8•24’s are singly deviced.
-			Dc.b	0,0									; Padding.
+			;Dc.l	JMFBDrvr-LoadTbl					; Start of 4•8/8•24 driver code.
+			;Dc.l	JMFBDrvrSize-LoadTbl				; Length.
+			;Dc.b	sRsrcDrvrDir						; 4•8/8•24’s have an sRsrcDrvrDir.
+			;Dc.b	0									; 4•8/8•24’s are singly deviced.
+			;Dc.b	0,0									; Padding.
 			
 			Align	4
 			
-JsrTbl		Dc.l	TFBPrimaryInit-JsrTbl				; TFBPrimaryInit
-			Dc.l	JMFBPrimaryInit-JsrTbl				; 4•8/8•24 PrimaryInit
+JsrTbl		;Dc.l	TFBPrimaryInit-JsrTbl				; TFBPrimaryInit
+			;Dc.l	JMFBPrimaryInit-JsrTbl				; 4•8/8•24 PrimaryInit
 
 
 ;=========================================================================================
@@ -1804,28 +1788,13 @@ CommonPRAM
 			CLR.W	D3
 			MOVE.L	D0,D1						; D1 = indicates which routine executing
 			MOVE.B	spSlot(A0),D3				; D3 = slot number with high byte clear
-			BNE.S	@CheckRange					; not slot zero
-
-; <SM2> rb, Start
-;	Check for slot zero and convert slot number to relative slot to index into PRAM.  On		<1.2>
-;	RBV machines, slot zero steals the PRAM from one of the 9-$E slots.  The slot mgr			<1.2>
-;	is only assigned enough PRAM for 6 slots.													<1.2>
-		
-			WITH 	VideoInfo					; <SM3> rb
-			movea.l	UnivInfoPtr,a1					; point to the ProductInfo record			<1.9>
-			adda.l	ProductInfo.VideoInfoPtr(a1),a1	; point to the VideoInfo record				<1.9>
-			move.b	VideoInfo.SlotNumberAlias(a1),d3; get the alias for slot zero PRAM			<1.9>
-
-@CheckRange										; not slot zero
-			MOVEA.L	spParamData(A0),A1			; A1 = ptr to buf to read to or write from		<1.9>
-
 ;	Check range for internal slots with PRAM on the motherboard
 
 			MOVE.W	#smSlotOOBErr,D0			; assume error
 			CMP.B	#sLastSlot,D3
 			BHI.S	@Done						; slot number out of range
 			CMP.B	#FirstPRAMSlot,D3			; a motherboard slot?
-			bge.s	@InternalPRAM				; good slot - get PRAM, <SM2> rb, End
+			bge.s	@InternalPRAM				; good slot - get PRAM
 
 ;	Slot number is in the expansion chassis range.  If an expansion chassis is present,		<1.5>
 ;	call a vendor routine, to handle PRAM requests.
@@ -1838,6 +1807,7 @@ CommonPRAM
 ;	Setup parameters to read or write PRAM from motherboard
 
 @InternalPRAM
+			MOVE.L	$18(A0),A1
 			SUB.B	#FirstPRAMSlot,D3			; convert slot to relative index
 			MULU.W	#SizesPRAMRec,D3			; index to PRAM record for slot
 			ADD.W	#SMPRAMTop,D3				; add offset to slot manager PRAM 
@@ -1963,48 +1933,46 @@ GetsRsrcPtr
 PtrToSlot	Proc	Export
 			With	spBlock
 
-			movem.l	d1-d2,-(sp)						; <SM2> rb
+			movem.l	d1/a1,-(sp)
+
+;	Fail on nil pointer
+
+			CLR.B	spSlot(A0)
 
-;  Verify a good sPointer
-													; <SM2> rb, Start
 			MOVE	#smsPointerNil,D0				; assume nil ptr - set error status
 			MOVE.L	spsPointer(A0),D1				; D1 = sPointer
 			BEQ.S	@Done							; nil pointer - error
 
+;	Test for slot 0 (host)
+
+			CMP.L	RealMemTop,D1					; inside RAM = slot 0
+			BLS.S	@OK
+
+			MOVE.L	ROMBase,A1						; inside ROM (256k) = slot 0
+			CMP.L	A1,D1
+			BLO.S	@NotInRom
+			ADD.L	#$40000,A1
+			CMP.L	A1,D1
+			BLS.S	@OK
+@NotInRom
+
 ;  Determine the slot
 
-			clr.b	d1								; clear low byte of pointer				<2.1>
-			ROL.L	#4,D1							; determine if major or minor space
-			CMP.B	#$0F,D1							; minor space?
-			BEQ.S	@minor							; minor slot space
-
-;	Super slot space - if the high nibble is the same as ROMBase, then this is an access to
-;	the host ROM's declaration data (or ram).  Translate it into slot 0.
-
-			MOVE.B	ROMBase,D2						; D2 = high byte of ROMBase
-			lsr.b	#4,d2							; shift high nib to low nibble			<2.1>
-			CMP.B	D2,D1							; same?
-			BHI.S	@FoundSlot						; must be other super slot space
-			
-;	Pointer is to ram or rom.  Translate it to slot 0.
-			
-			MOVEQ	#0,D1							; access to host ROM - translate to slot 0
-			BRA.S	@FoundSlot
-
-@minor		clr.b	d1								; sxxxxx0F to sxxxxx00					<2.1>
-			ROL.L	#4,D1							; minor space - reg D1 = xxxxx00s
-
-@FoundSlot	MOVE.W	#smSlotOOBErr,D0				; assume out of bounds
+			ROL.L	#4,D1
+			CLR.B	D1
+			ROL.L	#4,D1
+			BEQ.S	@Done
 			CMP.B	#sLastSlot,D1					; good slot number?
 			BHI.S	@Done							; must be slot $0F which is bad
 
 			MOVE.B	D1,spSlot(A0)					; return slot number
-			MOVEQ	#0,D0							; set good return
-			
+		
+@OK			MOVEQ	#0,D0							; set good return
+
 @Done		TST		D0								; set condition codes
-			movem.l	(sp)+,d1-d2
+			movem.l	(sp)+,d1/a1
 			RTS										; done - PtrToSlot
-			ENDP									; <SM2> rb, End
+			ENDP
 
 ;_______________________________________________________________________________________
 ;	ReadFHeader  -  copy a declaration ROM's format header block
@@ -2553,13 +2521,8 @@ DeleteSRTRec
 
 ;	Last SRT block is empty - free the block.  Traverse SRT to end to nil the link ptr.
 
-@Free		MOVE.B	mmu32Bit,-(SP)				; save current mmu state <SM2> rb
-			MOVE.B	#false32b,D0				; <SM2> rb
-			_SwapMMUMode						; switch to 24 bit mode <SM2> rb
-			MOVEA.L	A2,A0						; A0 = ptr to last SRT blk
+@Free		MOVEA.L	A2,A0						; A0 = ptr to last SRT blk
 			_DisposPtr							; free the block
-			MOVE.B	(SP)+,D0					; recover status <SM2> rb
-			_SwapMMUMode						; restore mmu state <SM2> rb
 			MOVEA.L	sRsrcTblPtr,A1				; get ptr to beginning of SRT
 @Loop1		ADDA.W	#srtBlkSize,A1				; inc to end of blk
 			CMPA.L	srtNext(A1),A2				; found end of link ?
@@ -2793,11 +2756,14 @@ pInitEntry
 
 ;	If there is a valid reference number, then find the DCE and calculate the dCtlDevBase	<1.5>
 
-			MOVEQ	#0,D0							; set a good return					<SM2> rb
-			MOVE.W	spRefNum(A0),D1					; get ref num						<SM2> rb
-			BEQ.S	@Done							; no ref num - done					<SM2> rb
-			BSR.S	MapUnit							; return reg A2 = ptr to DCE		<SM2> rb
-			BNE.S	@Error							; some error with ref num or DCE	<SM2> rb
+			MOVEQ	#0,D0							; set a good return
+			MOVE.W	spRefNum(A0),D1					; get ref num
+			BEQ.S	@Done							; no ref num - done
+			MOVE.W	#-1,D0							; set a bad return
+			NOT.W	D1								; test for valid ref number
+			BMI.S	@Error							; invalid - error
+			MOVE.L	([UTableBase],D1.W*4),A2		; DCE handle
+			MOVE.L	(A2),A2							; dereference handle
 
 ;	Read a 24 or 32 bit base address from the sResource										<2.0>
 
@@ -2824,41 +2790,8 @@ pInitEntry
 			MOVEM.L	(SP)+,D1/A2						; restore regs
 			TST.W	D0								; set CCR
 			RTS
-; <SM2> rb, from Zydeco...I give you MapUnit !
-;_______________________________________________________________________________________	<1.5>
-;	MapUnit  -  map a reference number to a pointer to a DCE
-;
-;	Given a driver reference number, get the pointer to it's DCE
-;
-;	Input	: reg D1 = reference number
-;
-;	Output	: reg A2 = ptr to DCE
-;				  D0 = status, 0=ok		CCR reflects status
-;
 
-MapUnit
-			MOVE.W	#rfNumErr,D0		; setup bad ref num error return
-		 	NOT.W	D1					; bitwise complement to get unitnum
-			BMI.S	@Done
-			CMP.W	UnitNtryCnt,D1		; is it in range ?
-			BGE.S	@Done	 			; skip if it's not
 
-			ASL.W	#2,D1				; multiply by four
-			MOVE.L	UTableBase,A2		; get address of unit table
-			MOVE.L	0(A2,D1.W),D1		; add in the offset
-			BEQ.S	@Done 				; branch if there is no driver installed
-
-			MOVE.L	D1,A2				; DCE handle
-			MOVE.L	(A2),D1 			; dereference handle
-			BEQ.S	@SysErr				; DCE should never be purged - call sys error
-			MOVE.L	D1,A2				; pointer to Device Control Entry
-			MOVEQ	#0,D0				; init good return
-
-@Done		TST.W	D0
-			RTS
-
-@SysErr		MOVEQ	#dsIOCoreErr,D0 	; deep shit IOCore error
-			_SysError					; invoke deep shit
 
 ;_______________________________________________________________________________________	<2.0>
 ;	pAllocSRTBlk  -  allocate and initialize an SRT block
@@ -3523,521 +3456,6 @@ pRestoreBus
 
 			ENDWITH									; { stackframe,slotGlobals }			<5>
 
-
-;____________________________________________________________________________
-;
-;  Routine:		p040BusException
-;
-;  Inputs:		a2	-	address to return to from exception when a bus error occurs
-;
-;  Outputs:		ccr set to value in reg d0
-;
-;  Function:	nubus bus error exception handler for 68040-based machines
-;
-;____________________________________________________________________________
-				Export	p040BusException
-p040BusException						;									
-
-;	The 040 Special Status Word (SSW) is different than the 020/030 one.  It looks like	
-;																						
-;		+---------------------------------------------------------------------+			
-;		| CP | CU | CT | CM | MA | ATC | LK | RW | X |  SIZE  |  TT  |   TM   |			
-;		+---------------------------------------------------------------------+			
-;		  15   14   13   12   11   10    9    8    7   6    5  4   3  2      0			
-;																						
-;																						
-;			CP		=	Continuation - Floating Pt. Post Exception Pending				
-;			CU		=	Continuation - Unimplemented Floating Pt. Instruction Exception	
-;			CT		=	Continuation - Trace Exception Pending							
-;			CM		=	Continuation - MOVEM Instruction Execution Pending				
-;			MA		=	Misaligned Access												
-;			ATC		=	ATC Fault														
-;			LK		=	Locked Transfer													
-;			RW		=	Read/Write (1=Read)												
-;			X		=	Undefined														
-;			SIZE	=	Transfer Size													
-;			TT		=	Transfer Type													
-;			TM		=	Transfer Modifier												
-
-aeStackFrame	RECORD		0						; 040 Access Stack Frame				
-savereg			DS.L		1						; space to save working register (D0)
-aeSR			DS.W		1						; status register					
-aePC			DS.L		1						; program counter					
-aeType			DS.B		1						; type of exception stack frame		
-less			DS.B		1						; filling (vector offset)			
-aeEffAddr		DS.L		1						; effective address					
-aeSSW			DS.W		1						; special status word				
-aeWBnS			DS.W		3						; WriteBack #n Status				
-aeFA			DS.L		1						; fault address						
-aeWB3Addr		DS.L		1						; WriteBack 3 Address				
-aeWB3Data		DS.L		1						; WriteBack 3 Data					
-aeWB2Addr		DS.L		1						; WriteBack 2 Address				
-aeWB2Data		DS.L		1						; WriteBack 2 Data					
-aeWB1Addr		DS.L		1						; WriteBack 1 Address				
-aeWB1Data		DS.L		1						; WriteBack 1 Data/Push Data LW0	
-aePD1			DS.L		1						; Push Data LW 1					
-aePD2			DS.L		1						; Push Data LW 2					
-aePD3			DS.L		1						; Push Data LW 3					
-				ENDR
-
-aeXFrameSize	EQU		$3C							; size of an Access Error stack frame	
-aeXFrameType	EQU		$07							; access error exception frame type		
-
-
-			WITH	aeStackFrame,slotGlobals		;									
-
-;	Verify that this is a faulted NuBus read data cycle									
-
-			move.l	d0,-(SP)						; save working register				
-			move.w	aeSSW(SP),d0					; retrieve SSW						
-			andi.w	#$0518,d0						; mask off only ATC, RW, TT			
-			cmp.w	#$0100,d0						; should be ATC=0, RW=1, TT=0		
-			bne.s	@RealBusEx						; can't handle these case - pass it on
-			move.b	aeType(SP),d0					; get format of stack frame			
-			lsr.b	#4,d0							; look at high nibble				
-			cmp.b	#aeXFrameType,d0				; access error exception frame?		
-			bne.s	@RealBusEx						; NO  ... use sys. access error handler
-			move.b	aeFA(SP),d0						; get high byte of fault address	
-			cmp.b	#majorSpace,d0					; in super slot space ($60-$E0)?	
-			blo.s	@RealBusEx						; not in slot address space			
-			cmp.b	#$FF,d0							; in minor slot space range?		
-			beq.s	@RealBusEx						; not in minor slot space			
-			cmp.b	#$F0,d0							; in minor slot space range?		
-			beq.s	@RealBusEx						; not in minor space $F1 - $FE		
-
-;	Have verified that a NuBus read data access caused the bus error.  Pop the exception
-;	stack frame and jump to the error return address in register a2.
-;
-;	***	I don't think this will work correctly.  Given that you could have other exceptions
-;	***	of a lesser priority pending, and could possibly have pending writebacks as well,
-;	***	does this code need to look to complete those writebacks, stuff A2 into aePC(SP)
-;	*** and do an RTE?  Or can we legally/safely stuff A2 into aePC(SP)?				
-
-;			move.l	(sp)+,d0						; restore reg d0					
-;			adda.w	#aeXFrameSize,sp				; pop the exception stack frame		
-;			jmp		(a2)							; take the error return address		
-
-			move.l	a2,aePC(SP)						; (re-)set the PC to where we want to go
-			move.l	(sp)+,d0						; restore reg d0						
-			rte										; return, catching any pending exceptions
-
-;	The bus exception was not caused by a read to NuBus - pass the exception to the
-;	real bus exception handler.
-
-@RealBusEx	MOVE.L	(SP)+,D0						; restore reg D0
-			MOVE.L	([sInfoPtr],sysBusExcptn),-(SP)	; put saved bus exception vector on stack
-			RTS										; jump to bus exception vector
-
-			ENDWITH									; { aeStackFrame,slotGlobals }		
-
-;_______________________________________________________________________________________	<h7> djw
-;	AddCard	-	add a card to the slot manager data structures
-;
-;	There is a stub entrypoint for this routine in the file slotInfo.a which does a long
-;	branch here.  The stub routine is needed for the slot manager's jump table offset
-;	limitation.
-;
-;	Add a card to the slot manager's data structures and run it's primaryInit.  If the
-;	card's current status is not empty, then the slot is rejected as not valid.  Memory
-;	is allocated, so this routine should not be run at interrupt time.
-;
-;	Input	:	a0 = ptr to spBlock
-;	Output	:	none
-;
-;	spBlock	:	-> spSlot			slot number (slot 0 is not valid)
-;
-			Export	AddCard
-			with	spBlock,sInfoRecord,seBlock
-AddCard
-@regs		reg		d1/a0/a2
-			movem.l	@regs,-(sp)
-
-;	If the current slot status is not empty, then the slot may not be re-initialized
-
-			_sFindsInfoRecPtr					; get ptr to sInfoRecord
-			bne		@Done						; slot not valid - done
-			movea.l	spResult(a0),a2				; a2 = ptr to sInfoRecord
-			move.w	#smSlotOOBErr,d0			; assume bad slot
-			cmp.w	#smEmptySlot,		\		; check for empty slot
-					siInitStatusA(a2)
-			bne.s	@Done						; only empty slots are valid
-
-;	Execute the slot manager initialization again on this slot
-
-			slotjsr	initSDeclMgr				; initialize a slot's sInfoRecord
-			slotjsr	sInitSRsrcTable				; initialize the slot resource table (SRT)
-			slotjsr	sInitPRAMRecs				; initialize a slot's PRAM
-
-			clr.b	spFlags(a0)					; clear flag bit to assume cold start
-			cmp.l	#WmStConst,WarmStart		; check low mem for warm start value
-			bne.s	@continue					; cold start
-			bset.b	#fWarmStart,spFlags(a0)		; warm start
-
-@continue
-			move.w	sr,-(sp)
-			ori.w	#HiIntMask,sr				; disable ints for primary init
-			slotjsr	sPrimaryInit				; execute the primaryInit
-			move.w	(sp)+,sr					; restore ints
-
-;	Execute the secondaryInit record														<h12> thru next <h12>
-
-			lea		-seBlockSize(sp),sp			; alloc seBlock
-			movea.l	sp,a2						; a2 = ptr to seBlock
-			move.l	a2,spsExecPBlk(a0)			; set ptr in spblock to sExec blk
-			move.b	#BoardId,sesRsrcId(a2)		; indicates exec code is from board sResource
-			slotjsr	sDoSecondary				; jump thru the vector
-			lea		seBlockSize(sp),sp			; dealloc seBlock							<h12> from last <h12>
-
-@Done
-			movem.l	(sp)+,@regs
-			rts
-			endwith
-
-
-;_______________________________________________________________________________________	<h7> djw
-;	RemoveCard	-	Remove a card from the slot manager
-;
-;	This routine will remove a card from the system by:
-;
-;		1.	Delete all sRsrc's from the SRT for that slot
-;		2.	Delete sInfoRecord and set to empty status
-;		3.	If there is a driver attached to the slot, attempt to close the driver
-;		4.	Remove any slot interrupt queue elements for the slot
-;
-;	Input	:	a0 = ptr to spBlock
-;	Output	:	none
-;
-;	spBlock	:	-> spSlot			slot number (slot 0 is not valid)
-;
-			Export	RemoveCard
-			with	spBlock,SlotIntQElement,slotIntGlobals,srrBlock,sInfoRecord
-
-RemoveCard
-@regs		reg		d1-d3/a1-a2
-			movem.l	@regs,-(sp)
-			lea		-ioQElSize(sp),sp					; alloc iopb
-			movea.l	sp,a2								;									<H14><SM13>
-			clr.l	ioCompletion(a2)					; no completion routine
-			moveq.l	#0,d1
-			move.b	spSlot(a0),d1						; d1 = slot number
-
-;	Loop through SRT deleting all sResources for this slot.
-
-@LoopAgain
-			movea.l	sRsrcTblPtr,a1						; get ptr to beginning of SRT
-			suba.w	#SRTRecSize,a1						; pre-decrement pointer
-@Loop
-			adda.w	#SRTRecSize,a1						; inc to next srrBlock
-			clr.l	spParamData(a0)						; ignore input flags because…
-			bset.b	#fall,spParamData+3(a0)				; …we need to find both enabled and disabled sRsrc's
-			slotjsr	sGetSRTEntry						; get next entry - rtn in ptr in a1
-			bne.s	@noMore								; found all sRsrc's
-			slotjsr	SrToSpBlock							; fill spBlock with srrBlock info
-			cmp.b	spSlot(a0),d1						; is this the slot we are looking at?
-			bne.s	@Loop								; not right slot - continue looking
-
-;	If there is a driver associated with this slot, attempt to close it
-
-			tst.w	spRefNum(a0)						; is there a valid refnum?
-			bpl.s	@remove								; not a refnum
-			move.w	spRefnum(a0),ioRefnum(a2)			; set refnum to close
-			move.l	a0,-(sp)							; save ptr to spBlock
-			movea.l	a2,a0								; a0 = ptr to iopb
-			_Close										; close driver
-			movea.l	(sp)+,a0							; restore a0 = ptr to spBlock
-			
-;	Delete the sRsrc from SRT
-
-@remove
-			slotjsr	sDeleteSRTRec						; delete the found sRsrc
-			bra.s	@LoopAgain							; find and delete all sRsrc's
-
-;	Delete the sInfoRecord
-
-@noMore
-			lea		([sInfoPtr],(4*TotalSlots)	\
-					+(sInfoNewSize*2)),a1				; get ptr to empty sInfo record
-			move.l	a1,([sInfoPtr],d1.w*4)				; set slot to point to empty record
-
-;	Clear the slot interrupt queue for this slot
-;	****	WARNING		****	WARNING		****
-;	This code is very implementation specific.  If slot interrupt table structure
-;	changes, this code will not work.  Also, this routine leaks memory because
-;	it does not free the slot int queue elements
-
-			lea		([SlotQDT],d1.w*4,slotIntQHeads-SQLink),a1	; get address of queue header
-			clr.l	SQLink(a1)									; zero queue link
-
-;	Done
-
-@Done
-			lea		ioQElSize(sp),sp					; de-alloc iopb
-			movem.l	(sp)+,@regs
-			rts
-
-			endwith
-
-;_______________________________________________________________________________________	<h7> djw
-;	CheckSlot	-	check if a card has changed
-;
-;	Check whether a slot's status has changed.  There are 3 slot state changes to
-;	consider:
-;
-;		1.	empty		-->		occupied
-;		2.	occupied	-->		empty
-;		3.	occupied	-->		occupied
-;
-;	If a slot goes from empty to occupied, or occupied to empty, return status that
-;	the slot's state has changed.  If a slot was previously occupied and is still
-;	occupied, then read the board id from the card and match it to the board id in
-;	PRAM.  If they are not the same, then the previous card was removed, and a new
-;	card is now in it's place.
-;
-;	Input	:	a0 = ptr to spBlock
-;
-;	Output	:	d0 = 0 if no change, non-zero if change
-;
-;	spBlock	:	-> spSlot			slot number (slot 0 is not valid)
-;
-			Export	CheckSlot
-			Import	VerifySlot
-			with	spBlock,sInfoRecord
-
-CheckSlot
-@regs		reg		d1-d3/a1-a4
-			movem.l	@regs,-(sp)
-			moveq.l	#0,d3							; set d3 = change status flag
-
-;	get ptr to slot's sInfoRecord so we can check its previous state
-
-			_sFindsInfoRecPtr						; get ptr to sInfoRecord
-			bne		@Return							; slot not valid - no change
-			movea.l	spResult(a0),a4					; a4 = ptr to sInfoRecord
-
-;	If a slot is disabled or reserved, then it is invalid
-
-			cmp.w	#smDisabledSlot,		\		; check for disabled slot
-					siInitStatusA(a4)
-			beq		@Return							; disabled slots not valid
-			cmp.w	#smReservedSlot,		\		; check for reserved slot
-					siInitStatusA(a4)
-			beq		@Return							; reserved slots not valid
-
-			moveq.l	#0,d1							; zero reg
-			move.b	spSlot(a0),d1					; d1 = slot number
-
-;	Save the current sInfoRecord for the slot
-
-			lea		-sInfoNewSize(sp),sp			; alloc temp sInfoRecord
-			move.w	d3,siInitStatusA(sp)			; clear status field
-			move.b	d3,siState(sp)					; clear state variable
-			move.w	siTOConst(a4),siTOConst(sp)		; set bus error retry cnt (not used)
-			move.b	d1,siSlot(sp)					; set slot number
-			move.l	d3,siROMAddr(sp)				; clear ROM address
-			movea.l	sp,a1							; a1 = ptr to temp sInfoRecord
-			move.l	a1,([sInfoPtr],d1.w*4)			; set new temp sInfoRecord ptr for slot
-
-;	Determine whether the slot is empty or occupied
-
-			moveq.l	#-1,d0
-			bfins	d1,d0{4,4}						; inset slot number to get $fsffffff
-			movea.l	d0,a3							; a3 = minor space nubus addr for slot
-			lea		@Empty,a2						; a2 = addr to go if bus error occurs
-			slotjsr	InstallBus						; replace bus excptn, 32 bit mode
-			move.b	(a3),d0							; NUBUS READ - read byte from minor space
-			slotjsr	RestoreBus						; restore mmu state and bus exception vector
-			move.l	a3,siROMAddr(sp)				; set ROM address
-			bra.s	@Verify							; slot is occupied - verify the decl rom
-
-;	If the slot is still empty and was previously empty, then we are done
-
-@Empty
-			slotjsr	RestoreBus						; get here if empty slot
-			move.w	#smEmptySlot,siInitStatusA(a1)	; set empty status
-			bra.s	@CheckError						; check if same as previous status
-
-;	Verify the format header  -  a0 = ptr to spblock, a1 = ptr to sInfoRecord
-
-@Verify
-			bsr.l	VerifySlot						; verify the config rom format
-			tst.w	siInitStatusA(a1)				; is the slot status ok?
-			bne.s	@CheckError						; bad or empty slot - check previous status
-
-;	Config ROM verifies ok - walk through all the sResources looking for the board sResource
-
-			bsr		GetBoardID						; find the board sRsrc and board id
-			beq.s	@Changed						; no board id - a bad card
-
-;	Compare with pram board id.  If sRsrc board id is different, then there is
-;	a different card in the slot.
-
-			move.w	d0,d2							; d2 = board id for new card
-			lea		-8(sp),sp						; alloc pram buffer
-			move.l	sp,spResult(a0)					; pass ptr to pram buffer
-			slotjsr	sReadPRAMRec					; read the current slot pram
-			bne.s	@Changed						; something wrong - change the card
-
-			cmp.w	(sp),d2							; are board id's the same?
-			lea		8(sp),sp						; de-alloc buffer
-			beq.s	@Done							; same board id's - return no change
-			bra.s	@Changed
-
-;	Some error - if same as previously, then mark as unchanged
-
-@CheckError
-			move.w	siInitStatusA(a4),d0				; get previous status
-			cmp.w	siInitStatusA(a1),d0				; same error?
-			beq.s	@Done								; same board id's - no change
-
-;	The card has changed
-
-@Changed
-			moveq.l	#-1,d3							; return error to indicate card changed
-
-;	Done
-
-@Done
-			lea		sInfoNewSize(sp),sp				; free temp sInfoRecord
-			move.l	a4,([sInfoPtr],d1.w*4)			; restore original sInfoRecord
-
-@Return
-			move.l	d3,d0							; return change status
-			movem.l	(sp)+,@regs
-			rts
-
-
-;_______________________________________________________________________________________	<h7> djw
-;	GetBoardID	-	Find and return board id
-;
-;	Find the board sResource and return the board id for the given slot.  This
-;	routine walks through the sResource data structures on the card, not using
-;	the SRT.
-;
-;	Input	:	a0 = ptr to spBlock
-;				a1 = ptr to sInfoRecord
-;	Output	:	d0 = board id or zero		ccr reflects status
-;
-;	spBlock	:	-> spSlot			slot number (slot 0 is not valid)
-;
-
-GetBoardID
-@regs		reg		d1-d4/a1-a2
-			movem.l	@regs,-(sp)
-			moveq.l	#0,d4							; d4 = board id value to return
-
-;	Calculate the step value for this slot so we can step through the sRsrc dir
-
-			move.l	siDirPtr(a1),spsPointer(a0)			; set ptr field to get step value for
-			move.b	siCPUByteLanes(a1),spByteLanes(a0)	; set byte lanes field
-			bset.b	#fConsecBytes,spFlags(a0)			; set flag for step value for bytes
-			_sCalcStep
-			bne		@Done
-
-;	For every entry in the sResource directory, read the sResource type to find the
-;	board sResource.  Also check for ascending order for the sResources in case there
-;	is no $ff at the end.
-
-			move.l	spResult(a0),spParamData(a0)	; set step value for reading bytes
-			move.l	siDirPtr(a1),d2					; set d2 = ptr to current dir entry
-			moveq.l	#0,d1							; zero last id read
-
-@Loop		move.l	d2,spsPointer(a0)				; set spsPointer to addr of id to read in dir
-			slotjsr	Read4Bytes						; read <id><offset> - inc spsPointer to next long
-			bne.s	@Done							; an error - stop searching
-			move.l	spsPointer(a0),d2				; get d2 = ptr to next id to read
-
-;	Check for acsending order in sResource directory id's
-
-			move.b	spResult(a0),d3					; get high byte to get <id> field
-			cmp.b	#$ff,d3							; end of list ?
-			beq.s	@Done							; done - board sResource is not found
-			cmp.b	d1,d3							; is new id greater than last id ?
-			bls.s	@Done							; id's out of order - not found
-			move.b	d3,d1							; set reg d1 = last id read
-
-;	Get a pointer to the sResource id found
-
-			move.l	siDirPtr(a1),spsPointer(a0)		; point to directory
-			move.b	d1,spId(a0)						; find the sRsrc id just read from the dir
-			_sFindStruct
-			bne.s	@Done							; some error
-
-;	With the spsPointer field now pointing to the sRsrc, read the type field
-
-			movea.l	spsPointer(a0),a2				; save ptr to sRsrc
-
-			move.b	#sRsrcType,spId(a0)				; get ptr to type field
-			_sFindStruct
-			bne.s	@Done							; error - no sRsrc type field found
-			lea		-8(sp),sp						; alloc sRsrc_type buffer
-			move.l	sp,spResult(a0)					; set buffer ptr
-			move.l	#8,spSize(a0)					; set size to read
-			_sReadStruct
-			bne.s	@Done							; @@@@Remember to dealloc stack@@@@can't read it - error
-
-			move.l	(sp)+,d0						; get category and type fields
-			move.l	(sp)+,d3						; get drvrSW and drvrHW fields
-			cmp.l	#(catBoard<<16)+typBoard,d0		; board type?
-			bne.s	@Loop							; not found - continue search
-			tst.l	d3								; drvrSW and drvrHW fields should be zero
-			bne.s	@Loop							; not found - continue search
-
-;	At this point, we have found the board sResource.  Read the board id
-
-			move.l	a2,spsPointer(a0)				; restore ptr to sRsrc
-			move.b	#Boardid,spId(a0)				; read board id field from board sRsrc
-			_sReadWord
-			bne.s	@Done							; some error - no board id
-			move.w	spResult+2(a0),d4				; d4 = board id for new card
-
-;	Done
-
-@Done
-			move.w	d4,d0							; return board id or zero
-			movem.l	(sp)+,@regs
-			rts
-
-			endwith
-
-;____________________________________________________________________________								<H8>
-;
-; FindDevBaseSlot0 (called from FindDevBase).
-;
-;	Entry:		a0 points to spBlock.
-;	 			d1 is the major/minorbase offset.
-;
-;	Exit:		a0 points to spBlock.
-;				d2 is the DevBase.
-;
-;	Trashes:	A1/D0-D1.
-;____________________________________________________________________________
-
-			Export	FindDevBaseSlot0
-
-			With	SpBlock
-
-FindDevBaseSlot0
-			
-			movea.l	UnivInfoPtr,a1					; point to the ProductInfo record
-			adda.l	ProductInfo.VideoInfoPtr(a1),a1	; point to the VideoInfo record
-			
-			move.b	#sRsrcFlags,spId(a0)			; get flags to determine whether the pointer
-			_sReadWord								; - should be 24 or 32 bit
-			bne.s	@Do24							; no flag field - default to 24 bit space
-			
-			move.w	spResult+2(a0),d0				; get value of spFlags
-			btst.l	#f32BitMode,D0					; see if 32- or 24-bit base address
-			beq.s	@Do24							; branch if 24-bit base address	
-				
-			Add.l	VideoInfo.VRAMLogAddr32(a1),d1	; 32bit dev base to alias addr for slot zero
-			Bra.s	@Done
-
-@Do24		Add.l	VideoInfo.VRAMLogAddr24(a1),d1	; 24bit dev base to alias addr for slot zero
-@Done		Move.l	d1,d2							; d2 has what we want
-			Rts		
-			
-			EndWith
-
 			Endp									; must have endp for RAM builds			<djw>
 
 			End

--- a/OS/SlotMgr/SlotMgrInit.a
+++ b/OS/SlotMgr/SlotMgrInit.a
@@ -13,73 +13,8 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM15>	 9/12/93	pdw		Removed a push,SwapMMU,pop sequence.
-;	  <SM14>	  9/1/93	SKH		Fixed a bug where only LastSDMSelts were being allocated in the dispatch
-;									table.
-;	  <SM13>	  8/4/93	GMR		RC: Added code to enable slave block transfers for BART machines
-;									(PDM,CF).
-;	  <SM12>	 6/14/93	kc		Roll in Ludwig.
-;	   <LW2>	 3/24/93	mal		Added EnableBlockXfer after PrimaryInit for each slot.
-;									EnableBlockXfer sets bits in a MUNI register if slot has block
-;									xfer sRsrcs indicating it supports block xfers.
-;	  <SM11>	11/17/92	kc		Add "IF NOT LC930 THEN" around patchPrimaryInit to facilitate
-;									dead code stripping for the LC930 build.
-;	   <SM10>	10/14/92	CSS		Change some branch short instructions to branches.
-;	   <SM9>	09-24-92	jmp		Added a pRAM-based mechanism for skipping BootBug altogether if
-;									it is installed.
-;	   <SM8>	08-27-92	jmp		Added support for Brigent, Inc.’s BootBug  card.
-;	   <SM7>	 6/30/92	kc		Roll in Horror, comments follow:
-;	                              	• From SlotMgr.a
-;	    <H5>				djw		Add new selector for DoSecondaryInit.
-;									• From SlotMgrPatch.a
-;	   <H11>				djw		Added DoSecondaryInit routine.
-;	   <SM6>	 5/16/92	kc		Roll in Horror changes. Comments follow:
-;                                   Note: This is going to take some work for the system build but
-;									it is likely to change so we might want to hold off awhile.
-;									• From SlotMgr.a
-;		<H3>	 3/18/92	djw		Add new calls to support docking code - AddCard, RemoveCard,
-;									CheckSlot, and GetSRTEntry.
-;		<H2>	  3/5/92	djw		Replaced InitSlotMgr, InitsRsrcTable, InitPRAMRecs, and
-;									Primary_Init entries in the table with new routines.
-;									• From SlotMgrPatch.a
-;		<H5>	02/05/92	jmp		Unfortunately, I put some tables in the middle of this file
-;									that, in Cyclone, will get bigger.  So, I moved them from the
-;									middle of the file into the pad space.  Also, I generalized the
-;									routine that decides whether a DeclROM’s PrimaryInit/Driver
-;									should be patched by not stopping once I found the version I was
-;									looking for (e.g., in case we need to patch out versions 1, 2,
-;									and 3 of the 8•24 card).
-;		<H2>	10/22/91	SAM/jmp	Discontinued patching out the JMFB PrimaryInit & Driver on the
-;									Bungee (1.1) version of the 4•8/8•24 Card ROM.  From Zydeco-TERROR ROM.
-;		<T6>	 2/25/91	jmp		Added code to check version number of the driver before doing
-;									PrimaryInit and GetDriver patches.
-;		<T3>	11/19/90	jmp		Added in patches for PrimaryInit and GetDriver.
-;									• From SlotInfo.a
-;		<H5>	 3/18/92	djw		Add stub entry points for new docking support routines -
-;									StubAddCard and StubRemoveCard
-;		<H4>	  3/6/92	SWC		We thank Dave for <H3> (getting it working in under 25 tries…),
-;									and move the Docking Manager initialization to StartSDeclMgr
-;									just before running the primary inits so that we can decided
-;									whether or not to install the built-in LCD driver when DBLite
-;									(etc.) is inside a docking station and thus the LCD screen is
-;									not useable.
-;		<H3>	  3/5/92	djw		Rewrote slot manager initialization code (major routines from
-;									beginning of file to SecondaryInit) to facilitate new code for
-;									DBLite docking station.  The major change was to modify the
-;									routines to execute their functions for a single slot instead of
-;									for every slot.
-;		<H2>	10/29/91	jmp		Added a patch to the VerifySlot routine for supporting super
-;									sRsrc directories in Slot $0.
-;	   <SM5>	  5/5/92	JSM		Roll-in changes from Reality:
-;									<17>	  5/4/92	JSM		The checks for isUniversal in this file should just be forROM.
-;																(Dean really didn’t have to do all that work in <14>).
-;	   <SM4>	 2/21/92	RB		delete rude code which snuck in late at night while no one was
-;									looking…
-;	   <SM3>	 2/12/92	RM		Change BRA.S to BRA.L.
-;	   <SM2>	 2/11/92	RB		Fixed InitPRamRecs. It was not working right on the Quadras due
-;									to a confusing situation caused when using forROM, and NOT
-;									forROM in diferent places of the same routine. I hate
-;									them...conditionals.
+;		<17>	  5/4/92	JSM		The checks for isUniversal in this file should just be forROM.
+;									(Dean really didn’t have to do all that work in <14>).
 ;		<15>	  1/7/92	RB		Rolled in Terror changes.
 ;		<14>	 8/30/91	DTY		Define isUniversal here since it’s no longer defined in
 ;									BBSStartup.
@@ -129,7 +64,6 @@
 			Include	'RomEqu.a'
 			Include	'UniversalEqu.a'
 			Include	'SlotMgrEqu.a'
-			Include	'ComVideoEqu.a'								; <15> rb
 			Print	On
 
 		
@@ -184,18 +118,12 @@
 			IMPORT	pRestoreBus
 			IMPORT	pAllocSRTBlk
 
-			IMPORT	GetSRTEntry							;								<h3> djw
-
 			IMPORT	SlotEmpty				;		<djw>
 			IMPORT	pGetBoard				;		<3>
 
 			IMPORT	SlotManager					;											<3>
 			IMPORT	p040BusException			;											<4>
 
-			EXPORT	InitsInfo,InitPrimary,InitsPram,InitsRsrc,InitsInfo
-			EXPORT	Secondary_Init,StubCheckSlot,StubAddCard,StubRemoveCard,SDMJmpTable
-			EXPORT	DoSecondaryInit
-
   			If (&TYPE('SeparateFile') = 'UNDEFINED') Then	; equ indicating whether we are		<3>
 SeparateFile   	Equ 		0								; ... building for 32bit QD INIT
   			Endif											; ... or as a system patch
@@ -297,7 +225,7 @@ SDMJmpTable	Proc
 			DispatchVector	GetTypesRsrc		;$0C			<1.2>
 			DispatchVector	SlotEmpty			;$0D
 			DispatchVector	SlotEmpty			;$0E
-			DispatchVector	DoSecondaryInit		;$0F			<H5>
+			DispatchVector	SlotEmpty			;$0F
 
 				
 ;    Specialized
@@ -315,21 +243,21 @@ SDMJmpTable	Proc
 			DispatchVector	FindDevBase			;$1B
 			DispatchVector	FindDevBase			;$1C map findbigdevbase to finddevbase		<1.6> 
 			DispatchVector	GetsRsrcPtr			;$1D			<1.3>
-			DispatchVector	StubAddCard			;$1E			<h3> djw
-			DispatchVector	StubRemoveCard		;$1F			<h3> djw
+			DispatchVector	SlotEmpty			;$1E
+			DispatchVector	SlotEmpty			;$1F
 
 
 ;    Advanced  (SDM private routines).
-			DispatchVector	InitsInfo			;$20			<h2> djw
-			DispatchVector	InitPrimary			;$21			<h2> djw
+			DispatchVector	SlotEmpty			;$20
+			DispatchVector	SlotEmpty			;$21
 			DispatchVector	CardChanged			;$22
 			DispatchVector	SlotExec			;$23			
 			DispatchVector	OffsetData			;$24
-			DispatchVector	InitsPram			;$25			<h2> djw
+			DispatchVector	InitPramRecs		;$25
 			DispatchVector	ReadPBSize			;$26
-			DispatchVector	StubCheckSlot		;$27			<h3> djw
+			DispatchVector	SlotEmpty			;$27
 			DispatchVector	CalcStep			;$28
-			DispatchVector	InitsRsrc			;$29			<h2> djw
+			DispatchVector	InitsRsrcTable		;$29
 			DispatchVector	SearchSRT			;$2A
 			DispatchVector	UpdateSRT			;$2B
 			DispatchVector	CalcsPointer		;$2C
@@ -352,32 +280,8 @@ SDMJmpTable	Proc
 			DispatchVector	pInstallBus			;$3A
 			DispatchVector	pRestoreBus			;$3B
 			DispatchVector	pAllocSRTBlk		;$3C
-			DispatchVector	GetSRTEntry			;$3D			<h3> djw
 
-;=======================================================================================
-;	Re-wrote the following old routines:
-;		StartSDeclMgr
-;		InitSlotMgr
-;		InitsRsrcTable
-;		InitPRAMRecs
-;		Primary_Init
-;
-;	...into these new routines:
-;		StartSDeclMgr
-;		AllocSlot
-;		InitsInfo
-;		InitsRsrc
-;		InitsPram
-;		InitPrimary
-;
-;	The major rewrite of the slot manager initialization code was to go from each routine
-;	executing a single function for all slot, to routines which would only execute the
-;	function for a given slot.  This change was to facilitate slot manager changes for
-;	DBLite to accomodate their docking module.  The end resulting data structures are
-;	not changed from the previous slot manager version.
-;=======================================================================================
-
-;_______________________________________________________________________________________	<h3> djw
+;_______________________________________________________________________________________
 ;	StartSDeclMgr  -  start the slot manager
 ;
 ;	Initialize the slot manager.  Create the sInfo and the slot resource table.  Load
@@ -390,18 +294,12 @@ SDMJmpTable	Proc
 
 			Proc
 			Export	StartSDeclMgr
-			Import	InitJmpTbl, InitDocking
 			with	spBlock,sInfoRecord,FHeaderRec,slotGlobals,seBlock
 
 StartSDeclMgr
-			sub.w	#spBlockSize,sp				; allocate spBlock
-			movea.l	sp,a0						; setup a0 = ptr to spBlock
+			movem.l	d1/a1/a2,-(sp)
 				
-			jsr		InitJmpTbl					; create the slot manager's dispatch table
-			bne		@Done				
-				
-			bsr		AllocSlot					; allocate all the slot manager data structures
-			bne		@Done
+			bsr		InitSlotMgr
 
 ;	For all the slots, determine its status, verify its format record, log its
 ;	sResources, initialize the PRAM for the slot.
@@ -409,110 +307,69 @@ StartSDeclMgr
 			moveq.l	#sLastSlot,d1				; d1 = slot loop counter from last slot
 @Loop
 			move.b	d1,spSlot(a0)				; set slot number
-			bsr		InitsInfo					; initialize the sInfo table
-			bsr		InitsRsrc					; initialize the slot resource table (SRT)
-			bsr		InitsPram					; initial a slot's PRAM
-			dbra	d1,@Loop
+			_sFindsInfoRecPtr					; get ptr to sInfoRecord
+			movea.l	spResult(a0),a1				; a1 = ptr to sInfoRecord
+			tst.w	siInitStatusA(a1)			; is the slot status ok?
+			bmi.s	@SlotDone					; bad slot - done
 
-;	Initialize the Docking Manager so built-in video and docking cards can use its facilities
+			bsr		VerifySlot					; verify the config rom format
 
-			BSR.L	InitDocking					; initialize the Docking Manager			<H4>
+@SlotDone	dbra	d1,@Loop
 
-;	Set up the warm/cold start flag for later.												<SM8>
+			movem.l	(sp)+,d1/a1/a2
+			rts
 
-			Moveq.l	#0,D2						; D2 = flag for cold start.
-			Cmpi.l	#WmStConst,WarmStart		; Check low mem for warm start value.
-			Bne.s	@Continue					; Cold start.
-			Bset.l	#fWarmStart,D2				; Warm start.
 
-@Continue
-
-;	Determine if there’s a BootBug card installed or not.  If one is installed,
-;	execute it first.  Otherwise, just run the normal sequence.
-
-			Clr.b	-(Sp)						; Initialize our “savedSlot” space.
-			
-			Clr.b	spSlot(A0)					; Start with Slot $0.
-			Clr.b	spID(A0)					; Begin search with ID 0.
-			Clr.b	spExtDev(A0)				; No external device(s).
-			Clr.b	spTBMask(A0)				; No mask in search.
-			Move.w	#CatProto,spCategory(A0)	; Look for:  Proto,
-			Move.w	#TypDebugger,spCType(A0)	;			 Debugger,
-			Move.w	#DrSwMacsBug,spDrvrSW(A0)	;			 MacsBug,
-			Move.w	#DrHwBootBug,spDrvrHW(A0)	;			 BootBug.
-			Clr.l	spParamData(A0)				; Clear the flags field.
-			Ori.b	#(1<<fNext),spParamData+3(A0) ; Search for the 1st one.
-			_GetTypeSRsrc						; If we don’t find a BootBug card
-			Bne.s	@DoZeroFirst				;	then just run the normal sequence.
-			Move.b	spSlot(A0),(Sp)				; Remember which slot has BootBug in it.
-			
-			Move.l	A0,-(Sp)					; Save SpBlockPtr.										<H15>
-			Subq	#4,Sp						; Make a pRAM buffer on the stack.
-			Move.l	Sp,A0						; Point to it.
-			Move.l	#$000400FC,D0				; Set up to read 4 bytes starting at $FC.
-			_ReadXPRAM							; Read ’em.
-			Move.l	(Sp)+,D0					; Get the result, release buffer.
-			Move.l	(Sp)+,A0					; Restore SpBlockPtr.
-			Cmpi.l	#'Skip',D0					; If the BootBug skip signature is set,
-			Beq.s	@DoZeroFirst				;	then skip it.
-			
-;	Now, go execute all the PrimaryInits as usual, except run the BootBug PrimaryInit
-;	first.
-
-			Move.b	D2,spFlags(A0)				; Set flag for warm or cold start.
-			Bsr		InitPrimary					; Execute the PrimaryInit.
-
-@DoZeroFirst
-			Clr.b	spSlot(A0)					; Set slot 0.
-			Move.b	D2,spFlags(A0)				; Set flag for warm or cold start.
-			Bsr		InitPrimary					; Execute the PrimaryInit.
-
-			Moveq.l	#sLastSlot,D1				; D1 = slot loop counter from last slot.
-@Loop1
-			Move.b	D1,spSlot(A0)				; Set the Slot number.
-			Cmp.b	(Sp),D1						; If this is the BootBug slot,
-			Beq.s	@Skip						;	then skip it this time.
-			
-			Move.b	D2,spFlags(A0)				; Set flag for warm or cold start.
-			Bsr		InitPrimary					; Execute the PrimaryInit.
-
-			Bsr		EnableBlockXfer				; Enable block xfer, if this slot is capable	<LW2>
-			
-@Skip		Subq.b	#1,D1
-			Bne.s	@Loop1						; Continue for all slots.
-
-			Tst.b	(Sp)+						; Free up “savedSlot” space.
-@Done
-			Add.w	#spBlockSize,Sp				; Free SpBlock.
-			Moveq.l	#noErr,D0					; Return noErr.
-			Rts									;											<SM8>
-
-
-;_______________________________________________________________________________________	<h3> djw
-;	AllocSlot  -  allocate slot manager data structures
-;
-;	Allocate the slot manager globals, the sInfo table, the sInfoRecords for disabled
-;	and reserved slots, and the first block of sRsrcRecords for the SRT.
-;
-;	Input	: a0 = ptr to spBlock
-;	Output	: d0 = status	ccr reflects status
+;_______________________________________________________________________________________
+;	InitSlotMgr
 ;
 
-AllocSlot
-@regs		reg		a0-a1
+			Export	InitSlotMgr
+
+InitSlotMgr
+@regs		reg		d1-d2/a0-a3
 			movem.l	@regs,-(sp)						; save registers
 
+;	Enumerate all the slots
+;		d0 = number of slots found
+;		sp points to array of index/-1 words
+
+			move.l	sp,SInfoPtr					; create a fake SlotMgr global block for InstallBus
+			sub.w	#slotGlobalSize,sp
+
+			move.l	#minorLast,a1				; explore the standard slot space ($Fn......)
+			move.l	#TotalSlots-1,d1
+			move.l	#0,d0
+
+			lea		@BusError,a2				; switch to 32-bit mode, and jump to a2 on bus error
+			slotjsr	InstallBus
+
+@NextSlot
+			sub.l	#2,sp
+			move.b	(a1),d2
+			add.w	#1,d0
+			move.w	d0,(sp)
+			bra.s	@NoBusError
+@BusError
+			move.w	#-1,(sp)
+@NoBusError
+			sub.l	#minorStep,a1
+			sub.w	#1,d1
+			bne.s	@NextSlot
+
+			slotjsr	RestoreBus					; undo InstallBus
+
 ;	Allocate the necessary memory as one contiguous block
 
-			move.l	#(slotGlobalSize			\	; size of globals
+			mulu.w	#sInfoNewSize,d0				; size of N sInfoRecords
+			add.l	#(slotGlobalSize			\	; size of globals
 					+(4*TotalSlots)				\	; size of sInfor vector table
-					+(3*sInfoNewSize)			\	; size of 3 sInfoRecords (disabled,reserved,empty)
-					),d0							; d0 = number of bytes to alloc
+					),d0
 			_NewPtr	,sys,clear						; alloc block
-			bne.s	@Done							; some error - done
 
 			adda.w	#slotGlobalSize,a0				; globals are at a negative offset from sInfo tbl
 			move.l	a0,sInfoPtr						; set ptr to sInfo table
+			move.l	a0,a1
 
 ;	There are three special sInfoRecords which we are setting up.  These records are shared by
 ;	all slots which have a disabled, reserved, or empty status.  The records are shared because
@@ -524,114 +381,34 @@ AllocSlot
 			move.w	#smDisabledSlot,			\
 					siInitStatusA(a0)				; set slot status to disabled
 			lea		sInfoNewSize(a0),a0				; inc a0 to reserved sInfoRecord
-			move.w	#smReservedSlot,			\
-					siInitStatusA(a0)				; set slot status to reserved
-			lea		sInfoNewSize(a0),a0				; inc a0 to empty sInfoRecord
-			move.w	#smEmptySlot,				\
-					siInitStatusA(a0)				; set slot status to reserved
 
-;	Allocate the first SRT block.
+			move.l	#$40000,d0
+			sub.l	#1,d0
+			add.l	RomBase,d0
+			move.l	d0,siROMAddr(a0)
+			move.w	#1,siTOConst(a0)
 
-			slotjsr	AllocSRTBlk					; return a1 = ptr to blk
-			move.l	a1,sRsrcTblPtr				; save ptr in low mem
-			move.l	a1,([sInfoPtr],lastSRTPtr)	; set ptr to last entry in SRT
+			move.l	a0,(a1) ; ?????
 
-@Done
-			tst.w	d0							; return err in ccr
-			movem.l	(sp)+,@regs
-			rts
-
-
-;_______________________________________________________________________________________	<h3> djw
-;	InitsInfo  -  init a slot's sinfoRecord
-;
-;	Check the NuBus info in the universal tables to see if the given slot is enabled.
-;	If so, then scan the slot to determine whether it is occupied or empty.  If occupied,
-;	then verify the declaration ROM.
-;
-;	Input	:	a0 = ptr to spBlock
-;	Output	:	none
-;
-;	spBlock	:	-> spSlot			slot number
-			Export InitsInfo
-InitsInfo
-@regs		reg		d1/a0-a3
-			movem.l	@regs,-(sp)
-
-			moveq.l	#0,d1
-			move.b	spSlot(a0),d1						; d1 = slot number in question
-			movea.l	sInfoPtr,a1							; a1 = ptr to beginning of sInfoTable
-			
-;	Check if the slot is enabled in the universal tables.  The two currently defined
-;	states are enabled (no bit set), disabled (do no scan), and reserved (hack for VM
-;	to disable VM from looking into slot's address space.  Previously, VM ignored
-;	the disabled error).
-
-			movea.l	a1,a3
-			lea		4*TotalSlots(a3),a3					; a3 = ptr to disabled sInfoRecord
-			move.l	a3,(a1,d1.w*4)						; set slot pointing to disabled record
-
-			with NuBusInfo
-			movea.l	UnivInfoPtr,a2		
-			adda.l	ProductInfo.NuBusInfoPtr(a2),a2		; a2 = ptr to universal slot info tbl
-			btst.b	#slotDisabled,(a2,d1.w)				; test if slot is disabled
-			bne		@Done
-			lea		sInfoNewSize(a3),a3					; a3 = ptr to reserved record
-			move.l	a3,(a1,d1.w*4)						; set slot pointing to reserved record
-			btst.b	#slotReserved,(a2,d1.w)				; test if the slot is reserved
-			bne 	@Done								; <SM10> CSS
-			endwith
-
-;	The slot is enabled for use.  Initially, set the slot to point to the empty sInfoRecord.
-
-			lea		sInfoNewSize(a3),a3					; a3 = ptr to empty record
-			move.l	a3,(a1,d1.w*4)						; set slot pointing to empty record
-
-;	If this is slot zero, then special case the declaration ROM address
-
-			tst.b	d1									; slot 0 ?
-			bne.s	@doRead								; not slot 0
-			movea.l	RomBase,a3							; get base of rom
-			adda.l	ROMHeader.RomSize(a3),a3			; a3 = addr of end of ROM
-			suba.l	#1,a3								; adjust to last byte in ROM
-			bra.s	@Verify								; verify slot 0
-
-;	Do a nubus read to see if the slot is occupied.  If it is, then when we
-;	read, we will not get a bus error.
-
-@doRead
-			moveq.l	#-1,d0
-			bfins	d1,d0{4,4}						; inset slot number to get $fsffffff
-			movea.l	d0,a3							; a3 = minor space nubus addr for slot
-			lea		@Empty,a2						; a2 = addr to go if bus error occurs
-			slotjsr	InstallBus						; replace bus excptn, 32 bit mode
-			move.b	(a3),d0							; NUBUS READ - read byte from minor space
-			slotjsr	RestoreBus						; restore mmu state and bus exception vector
-			bra.s	@Verify							; slot is occupied - verify config rom
-@Empty
-			slotjsr	RestoreBus						; restore mmu state and bus exception vector
-			bra.s	@Done
-
-
-;	The slot is not empty.  Allocate an sInfoRecord for it and verify the card.
-;	a0 = ptr to spBlock, a1 = ptr to sInfoTable, a3 = ptr to top of config rom
-
-@Verify
+			move.w	#1,d0
+@Loop
 			movea.l	a0,a2							; save ptr to spBlock
-			move.l	#sInfoNewSize,d0				; size of sInfoRecord
-			_NewPtr	,sys,clear
-			bne.s	@Done							; err - leave pointing to empty record
-			move.l	a0,(a1,d1.w*4)					; set ptr in sInfo vector table
-			movea.l	a0,a1							; a1 = ptr to sInfoRecord for this slot
-			movea.l	a2,a0							; restore a0 = ptr to spBlock
+			move.w	(sp)+,d1						; pop word from
+			muls.w	#sInfoNewSize,d1				; size of sInfoRecord
+			add.l	d1,a2
+			move.l	a2,(a1,d0.w*4)					; set ptr in sInfo vector table
 
-			move.w	#retryCnt,siTOConst(a1)			; set default bus error retry cnt (not used)
-			move.b	d1,siSlot(a1)					; set slot number
-			move.l	a3,siROMAddr(a1)				; set ROM address
+			move.w	#retryCnt,siTOConst(a2)			; set default bus error retry cnt (not used)
+			move.b	d0,siSlot(a2)					; set slot number
 
-			bsr.s	VerifySlot						; verify the config rom format
+			not.l	siROMAddr(a2)					; set ROM address ???
+			bfins	d0,siROMAddr(a2){4,4}			; inset slot number to get $fsffffff
 
-@Done
+			add.w	#1,d0
+			cmp.w	#sLastSlot,d0
+			ble.s	@Loop
+
+			add.w	#slotGlobalSize,sp				; pop fake globals
 			movem.l	(sp)+,@regs
 			rts
 
@@ -667,8 +444,8 @@ VerifySlot
 			MOVE.L	A2,spResult(A0)			; pass A2 = addr to put format header
 			moveq	#3,d1					; start with byte lane 3						<2.0>
 
-@Loop		BSR		GetByteLane				; get a valid byte lane - return byte lane value in D1
-			BNE		VerifySlotDone			; error - no valid byte lane
+@Loop		BSR.S	GetByteLane				; get a valid byte lane - return byte lane value in D1
+			BNE.S	VerifySlotDone			; error - no valid byte lane
 			_sReadFHeader					; read the format header from the declaration ROM
 			BNE.S	@EndLoop				; some error - try another byte lane			<1.7>
 			
@@ -689,75 +466,10 @@ VerifySlot
 @EndLoop	sub.l	#1,siROMAddr(a1)		; decrement ROM ptr to next byte lane			<1.7>
 			DBRA	D1,@Loop
 			move.w	#smBLFieldBad,d0		; error - could not find a valid byte lane
-			BRA		VerifySlotDone
+
+			BRA.S	VerifySlotDone
 								
-;	Get the pointer to the sResource directory from the declaration ROM and store
-;	it in the sInfo record for future use.  The directory is at an offset from the
-;	directory offset field in the format header.
-			EndWith ; FHeaderRec
-			With XFHeaderRec
-@GoodRom	
-VerifySlotPatch
-
-			Tst.b	spSlot(A0)								; If we’re not looking at slot 0, then 
-			Bne		@StdHeader								; 	just assume a standard header.
-			
-			Move.l	siROMAddr(A1),spsPointer(A0)			; Set ptr to top of ROM.
-			Move.l	#-(fhXBlockSize)+1,spOffsetData(A0)		; Set offset to beginning of extended header.
-			Move.b	siCPUByteLanes(A1),spByteLanes(A0)		; Set byte lanes field.
-			_sCalcsPointer									; Get pointer to extended header.
-			Bne		@StdHeader								; If failed, just try standard header.
-
-@SaveRegs	Reg		A3-A4									; Define some work register.	
-			Movem.l	@SaveRegs,-(Sp)							; Save them.
-			Suba.l	#XFHdrExtraSize,Sp						; Allocate space for extended part of FHeaderRec.
-			Move.l	Sp,A3									; Point to it.
-			Suba.l	#seBlockSize,Sp							; Allocate space for sExec block.
-			Move.l	Sp,A4									; Point to it.
-			
-			Move.l	A3,spResult(A0)							; Point to buffer for extra part of format block.
-			Move.l	#XFHdrExtraSize,spSize(A0)				; Number of bytes to copy.
-			_sReadStruct									; Read extended part of header.
-			Bne.s	@FallBack								; If failed, just try the standard header.
-			
-			Cmpi.l	#TestPattern,fhXSTstPat(A3)				; If the (extended) test pattern doesn’t exist,
-			Bne.s	@FallBack								;	just try the standard header.
-			
-			Move.b	fhFormat(A2),D0							; Get the format ID of the header.
-			Cmp.b	fhXSuperInit(A3),D0						; If not using an appropriately ID’d SuperInit,
-			Bne.s	@FallBack								;	just try the standard header.
-			
-			Move.b	spSlot(A0),seSlot(A4)					; Copy the slot number.
-			Move.b	fhXSuperInit(A3),sesRsrcId(A4)			; Copy the sRsrc/format ID of the SuperInit.
-			Move.b	fhXSuperInit(A3),spID(A0)				; Make sure sExec calls the right SuperInit.
-			Move.l	A4,spsExecPBlk(A0)						; Point to the sExec param block.
-			_SExec											; Call SuperInit.
-			Bne.s	@FallBack								; If failed, just try the standard header.
-			
-			Tst.b	seStatus(A4)							; If upper byte of seStatus is non-zero (a failure),
-			Bne.s	@FallBack								;	just try the standard header.
-			
-			Move.l	siROMAddr(A1),spsPointer(A0)			; Point back to the top of ROM.
-			Move.l	fhXSDirOffset(A3),spOffsetData(A0)		; Load super directory offset.
-			Clr.b	spOffsetData(A0)						; Strip psuedo-spID byte.
-			Add.l	#XOffsetToDir,spOffsetData(A0)			; Negative offset.
-			Move.b	siCPUByteLanes(A1),spByteLanes(A0)		; Set byte-lanes field.
-			_sCalcsPointer									; Get ptr to start of super sRsrc directory.
-			Bne.s	@FallBack								; If failed, just try standard header.
-
-			Move.b	seStatus+1(A4),spID(A0)					; Get the id of the super sRsrc directory.
-			_sFindStruct									; Look for it.
-			Bne.s	@FallBack								; If failed, try standard header.
-			
-			Move.l	spsPointer(A0),siDirPtr(A1)				; Set ptr to sRsrc dir in sInfo record.
-			Adda.l	#XFHdrExtraSize+seBlockSize,Sp			; Restore stack.
-			Movem.l	(Sp)+,@SaveRegs							; Restore work registers.
-			Bra.s	VerifySlotDone
-			
-@FallBack	Adda.l	#XFHdrExtraSize+seBlockSize,Sp			; Restore stack.
-			Movem.l	(Sp)+,@SaveRegs							; Restore work registers.
-
-@StdHeader	MOVE.L	siROMAddr(A1),spsPointer(A0)			; set ptr to slot declaration ROM
+@GoodRom	MOVE.L	siROMAddr(A1),spsPointer(A0)			; set ptr to slot declaration ROM
 			MOVE.L	fhDirOffset(A2),spOffsetData(A0)		; get dir offset from format blk image
 			add.l	#OffsetToDir,spOffsetData(a0)			; negative offset to directory field <2.0>
 			_sCalcsPointer									; calc ptr to directory
@@ -957,8 +669,8 @@ VerifyCRC
 			RTS										; end - VerifyCRC
 
 
-;_______________________________________________________________________________________	<h3> djw
-;	InitsRsrc  -  initialize the slot resource table
+;_______________________________________________________________________________________
+;	InitsRsrcTable  -  initialize the slot resource table
 ;
 ;	Loop through the given slot's sRsrc directory and add all the sRsrcs to the
 ;	SRT.  The SRT is actually made up of fixed sized blocks linked together.  A
@@ -971,28 +683,47 @@ VerifyCRC
 ;
 ;	spBlock	:	-> spSlot			slot number
 
-			Export	InitsRsrc
+			Export	InitsRsrcTable
 			with	srrBlock,srtLink
 			
-InitsRsrc
-@regs		reg		d1-d3/a1-a2
+InitsRsrcTable
+@regs		reg		a1-a2
 			movem.l	@regs,-(sp)
 
+			slotjsr	AllocSRTBlk
+
+			move.l	a1,SRsrcTblPtr
+
+			clr.b	spSlot(a0)					; clear fields used by _InsertSRTRec
+			clr.w	spIOReserved(a0)
+			clr.w	spRefNum(a0)
+			clr.b	spExtDev(a0)
+			clr.b	spHwDev(a0)
+
 ;	Check the slot's status
-
+@NextSlot
 			_sFindsInfoRecPtr					; get ptr to sInfoRecord
-			bne.s	@Done						; slot not valid - done
 			movea.l	spResult(a0),a2				; a2 = ptr to sInfoRecord
 			tst.w	siInitStatusA(a2)			; is the slot status ok?
-			bmi.s	@Done						; bad slot - done
+			bmi.s	@BadSlot					; bad slot - done
+			bsr		@InitTheResourceTable
+@BadSlot
+			add.b	#1,spSlot(a0)
+			cmp.b	#sLastSlot,spSlot(a0)
+			ble.s	@NextSlot
 
+			movem.l	(sp)+,@regs
+			rts
+
+@InitTheResourceTable
+			movem.l	d3-d4/a3,-(sp)
 ;	Calculate the step value for this slot so we can step through the sRsrc dir
 
 			move.l	siDirPtr(a2),spsPointer(a0)			; set ptr field to get step value for
 			move.b	siCPUByteLanes(a2),spByteLanes(a0)	; set byte lanes field
 			bset.b	#fConsecBytes,spFlags(a0)			; set flag for step value for bytes
 			_sCalcStep
-			bne.s	@Done
+			bne		@Done
 			
 ;	Loop through the sResource directory.  Check that the sResource id's are in
 ;	acsending order.  The last entry must have id = $FF.
@@ -1021,25 +752,39 @@ InitsRsrc
 ;	Given the sRsrc id, insert a new entry into the SRT
 
 			move.b	d3,spId(a0)						; set sRsrc id to insert
-			clr.l	spsPointer(a0)					; clear fields used by _InsertSRTRec
-			clr.w	spIOReserved(a0)
-			clr.w	spRefNum(a0)
-			clr.b	spExtDev(a0)
-			clr.b	spHwDev(a0)
-			clr.l	spParamData(a0)					; make sure to insert sRsrc as enabled
+
+			move.l	spResult(a0),d5
+			and.l	#$FFFFFF,d5
+			move.l	d5,spOffsetData(a0)
+
 			_InsertSRTRec							; insert <slot><id> sRsrc into SRT
-			beq.s	@Loop							; continue inserting sRsrc's
+			bne.s	@Done							; continue inserting sRsrc's
 
+			cmp.w	#-1,(a1)
+			bne.s	@no
+			move.l	a1,a3
+
+			slotjsr	AllocSRTBlk
+			move.l	a1,2(a3)
+
+@no
+			clr.l	$18(a0)
+			slotjsr	InitEntry
+			bne.s	@Done
+			add.w	#1,([sInfoPtr],srtCnt)
+			move.l	a1,([sInfoPtr],lastSRTPtr)
+			add.w	#$18,a1
+			bra		@Loop
 @Done
-			movem.l	(sp)+,@regs
+			movem.l	(sp)+,d3-d4/a3
 			rts
 			
 			endwith
 
 
 
-;_______________________________________________________________________________________	<h3> djw
-;	InitsPRAM  -  initialize slot PRAM
+;_______________________________________________________________________________________
+;	InitPramRecs  -  initialize slot PRAM
 ;
 ;	Each slot is assigned 8 bytes of PRAM: <board id><6 user bytes>.  On boot,
 ;	the <board id> is compared against the card in the slot.  If they are
@@ -1053,35 +798,20 @@ InitsRsrc
 ;
 ;	spBlock	:	-> spSlot			slot number
 
-			Export	InitsPRAM
-InitsPRAM
+			Export	InitPramRecs
+InitPramRecs
 @regs		reg		d1-d3/a1-a2
 			movem.l	@regs,-(sp)
 			suba.w	#SizesPRAMRec,sp				; alloc slot PRAM buffer
 			movea.l	sp,a1							; a1 = ptr to PRAM buffer
-			clr.l	(a1)							; zero pram buffer (8 bytes)
-			clr.l	4(a1)
+			moveq	#sLastSlot,d1
 
-;	Get the state of this slot.  If the slot is disabled or reserved, then DO NOT ZERO
-;	PRAM.  If the pram has already been initialized, then do not initialize again.
-
-			_sFindsInfoRecPtr						; get ptr to sInfoRecord
-			bne		@Done							; slot invalid - done
-			movea.l	spResult(a0),a2					; a2 = ptr to sInfoRecord
-
-			cmpi.b	#statePRAMInit,siState(a2)		; has PRAM already been initialized ?
-			bge		@Done							; already initialized - done
-			tst.w	siInitStatusA(a2)				; is the slot status ok?
-			beq.s	@readPRAM						; slot ok - read board id from pram
-			cmp.w	#smDisabledSlot,siInitStatusA(a2)	; is slot disabled?
-			beq.s	@Done							; don't touch disabled slot's pram
-			cmp.w	#smReservedSlot,siInitStatusA(a2)	; is slot reserved?
-			beq.s	@Done							; reserved is the same as disabled
-			bra.s	@writePRAM						; slot status is bad - zero pram
+@NextSlot
 
 ;	Read PRAM to get the current board id.
 
-@readPRAM
+			move.b	d1,spSlot(a0)
+			clr.w	(a1)							; zero board ID in pram buffer
 			move.l	a1,spResult(a0)					; pass ptr to read PRAM bytes into
 			_sReadPRAMRec							; return (a1).w = board id
 			move.w	(a1),d3							; d3 = board id from PRAM
@@ -1096,13 +826,19 @@ InitsPRAM
 ;	slot zero, loop through all the board sResource records found, trying to match the
 ;	pram board id.
 
-			moveq.l	#0,d1							; sRsrc id to start looking at (incase of slot 0)
+			moveq.l	#0,d4							; sRsrc id to start looking at (incase of slot 0)
 
 @Loop
 			move.b	d1,spId(a0)						; pass sRsrc id to routine to begin looking from
 			slotjsr	GetBoard						; return board sRsrc and sInfo rec ptrs
 			bne.s	@writePRAM						; no board sRsrc - write zero PRAM
 
+			movea.l	spResult(a0),a2					; a2 = ptr to sInfoRecord
+			tst.w	siInitStatusA(a2)				; is the slot status ok?
+			bmi.s	@writePRAM						; slot status is bad - zero pram
+			cmpi.b	#statePRAMInit,siState(a2)		; has PRAM already been initialized ?
+			bge.s	@Done							; already initialized - done
+
 ;	Board sResource is found - read the board id
 
 			move.b	spId(a0),d1						; save spId incase we need to loop (for slot 0)
@@ -1121,7 +857,7 @@ InitsPRAM
 
 ;	Board id's are different - if this is slot zero, then look for another board sResource
 
-			tst.b	spSlot(a0)						; slot zero ?
+			tst.b	d1								; slot zero ?
 			beq.s	@Loop							; yes - look for another board sResource
 
 ;	Look for a pram init record on the card's config ROM.  If found, use the values to
@@ -1144,13 +880,16 @@ InitsPRAM
 			_InitSlotPRAM							; initialize board id and user PRAM
 
 @Done
+			dbra	d1,@NextSlot
+			moveq	#0,d0
+
 			adda.w	#SizesPRAMRec,sp				; free pram data buffer
 			movem.l	(sp)+,@regs
 			rts
 
 
-;_______________________________________________________________________________________	<h3> djw
-;	InitPrimary		-	execute primaryInit
+;_______________________________________________________________________________________
+;	Primary_Init		-	execute primaryInit
 ;
 ;	Execute primary init code for a slot having a primaryInit record in it's board
 ;	sResource.  Primary inits are passed parameters in an seBlock.Primary inits are
@@ -1166,9 +905,9 @@ InitsPRAM
 ;				sesRsrcId	->	BoardId
 ;				seFlags		->	spFlags
 ;
-			Export	InitPrimary
+			Export	Primary_Init
 
-InitPrimary
+Primary_Init
 @regs		reg		d1-d3/a1-a3
 			movem.l	@regs,-(sp)
 			suba.w	#seBlockSize,sp
@@ -1176,8 +915,23 @@ InitPrimary
 			move.l	a2,spsExecPBlk(a0)				; set ptr in spblock to sExec blk
 			move.b	#BoardId,sesRsrcId(a2)			; indicates exec code is from board sResource
 
+			moveq	#0,d0							; MMU to 32-bit mode
+			_SwapMMUMode
+			move.b	d0,-(sp)
+
+			move.b	#0,spSlot(a0)
 			bsr.s	doPrimaryInit					; execute the primary init
 
+			moveq	#sLastSlot,d1
+@Loop
+			move.b	d1,spSlot(a0)
+			bsr.s	doPrimaryInit					; execute the primary init
+			subq	#1,d1
+			bnz.s	@Loop
+
+			move.b	(sp)+,d0						; restore MMU
+			_SwapMMUMode
+
 			adda.w	#seBlockSize,sp
 			movem.l	(sp)+,@regs
 			rts
@@ -1215,20 +969,10 @@ doPrimaryInit
 			_sFindStruct
 			bne.s	@Done							; no primary init record - done
 
-			IF NOT LC930 THEN
-
-;	Identify Apple Cards whose PrimaryInit code is faulty, and execute fixed
-;	versions from the CPU ROM.
-			Bsr.s	PatchPrimaryInit					; If PatchPrimaryInit returns a 
-			Tst.b	D0									;	result >= 0, don’t execute
-			Bpl.s	@cleanup							;	normal PrimaryInit.
-			
-			ENDIF
-			
 ;	Load the code and execute the primary init record.
 ;
 			Move.l	A3,spsPointer(A0)					; Restore ptr to board sRsrc.
- 			Move.b	spSlot(A0),seSlot(A2)				; Set slot in sExec blk.
+ 			Move.b	D1,seSlot(A2)						; Set slot in sExec blk.
 			Move.b	spFlags(A0),seFlags(A2)				; Xfer warmstart flag (if present).
  			_sExec										; Execute the code.
 
@@ -1241,172 +985,6 @@ doPrimaryInit
 
 @done		Rts
 
-;____________________________________________________________________________
-;
-; PatchPrimaryInit and support (called from doPrimaryInit).
-;
-;	Entry:		A0		-- points to spBlock.
-;				A1		-- points to sInfoRecord.
-;				A2		-- (after restore from BigJump) points to sExec param blk.
-;				A3		-- points to board sResource.
-;
-;				D1		-- contains spSlot (we use spBlock.spSlot here, though).
-;	
-;	Exit:		A0-A3	-- preserved.
-;				D1		-- preserved.
-;
-;	Purpose:	The purpose of SlotPrimaryInitPatch is to identify Apple
-;				Cards whose PrimaryInit code is faulty, and execute fixed
-;				versions from the CPU ROM.
-;
-;				SlotPrimaryInitPatch is executed from the (non-exported)
-;				routine doPrimayInit in SlotInfo.a.
-;____________________________________________________________________________
-			
-			IF NOT LC930 THEN
-
-			With	seBlock,spBlock
-			Import	GetDevIndex,JsrTbl
-
-PatchPrimaryInit
-
-@saveRegs	Reg		A0-A3/D1/D3							; Define some work and scratch registers,
-			Movem.l	@saveRegs,-(Sp)						; 	and save them on the stack.
-			
-			Move.l	A0,A3								; Save the spBlockPtr for later.
-			
-			Bsr		GetDevIndex							; Get the device/card index into D0.
-			Move.l	D0,D3								; If the device index is negative, then
-			Bmi.s	@done								;	PrimaryInit doesn’t need patching.
-			
-			Lea		JsrTbl,A1							; Point to base of JsrTbl.
-			Lsl.l	#2,D3								; Adjust index.
-			
-			Move.l	A1,A0								; Copy base address.
-			Add.l	D3,A0								; Point to proper entry.
-			Add.l	(A0),A1								; Load A1 with effective address of PrimaryInit.
-			
-			Move.l 	A3,A0								; Restore spBlockPtr.
-			Move.b	spSlot(A0),seSlot(A2)				; Set the right slot number.
-			Move.b	spFlags(A0),seFlags(A2)				; Set the flags.
-			Move.l	A2,A0								; Set A0 to sExecBlkPtr for fake sExec call.
-			Jsr		(A1)								; Execute the PrimaryInit.
-			
-			Move.l	D3,D0								; Return result code.
-			
-@done		Movem.l	(Sp)+,@saveRegs
-			Rts
-
- 			Endwith
-
-			ENDIF
-
-;_______________________________________________________________________________________	<h5> djw
-;	StubCheckSlot	-	check if a slot status has changed
-;
-;	This is a little stub routine for the real CheckSlot routine in the slot manager
-;	overpatch file.  We need this stub because the slot manager jump table in ROM only
-;	has 16 bit offset and the overpatch file is out of range.  We therefore vector to
-;	this stub routine which then jumps to the overpatch file.
-;
-;	Input	: none
-;	Output	: none
-;
-			export	StubCheckSlot
-			import	CheckSlot
-
-StubCheckSlot
-			bra.l	CheckSlot						; go to the real routine
-
-
-;_______________________________________________________________________________________	<h5> djw
-;	StubAddCard	-	add a card to slot manager
-;
-;	This is a little stub routine for the real StubAddCard routine in the slot manager
-;	overpatch file.  We need this stub because the slot manager jump table in ROM only
-;	has 16 bit offset and the overpatch file is out of range.  We therefore vector to
-;	this stub routine which then jumps to the overpatch file.
-;
-;	Input	: none
-;	Output	: none
-;
-			export	StubAddCard
-			import	AddCard
-
-StubAddCard
-			bra.l	AddCard						; go to the real routine
-
-
-;_______________________________________________________________________________________	<h5> djw
-;	StubRemoveCard	-	remove a card from the slot manager
-;
-;	This is a little stub routine for the real CheckSlots routine in the slot manager
-;	overpatch file.  We need this stub because the slot manager jump table in ROM only
-;	has 16 bit offset and the overpatch file is out of range.  We therefore vector to
-;	this stub routine which then jumps to the overpatch file.
-;
-;	Input	: none
-;	Output	: none
-;
-			export	StubRemoveCard
-			import	RemoveCard
-
-StubRemoveCard
-			bra.l	RemoveCard					; go to the real routine
-
-;_______________________________________________________________________________________	start 	<LW2>
-;	EnableBlockXfer		-	find then enable cards capable of support block xfers as a Slave
-;
-;	Input	: a0 = ptr to spBlock
-;	Output	: none
-;
-;	spBlock	:	-> spSlot			slot number
-;				-> spFlags			fWarmStart - if set then a warm start (may be used by primary
-EnableBlockXfer
-			Testfor	BARTExists					; are we on a ColdFusion or PDM
-			bne.s	@goodMach
-			Testfor	MUNIExists					; do we have MUNI Nubus Controller?
-			Beq		@exit						; no, leave
-			
-@goodMach	MoveM.l	A0/D0-D2, -(SP)
-			Clr.b	spID(A0)					; Begin search with ID 0.
-			Clr.b	spExtDev(A0)				; No external device(s).
-			Clr.b	spHwDev(A0)					; No hardware device(s).
-			Clr.b	spTBMask(A0)				; No mask in search.
-			Move.w	#catBoard,spCategory(A0)	; Look for:  Board sRsrc
-			Clr.w	spCType(A0)
-			Clr.w	spDrvrSW(A0)
-			Clr.w	spDrvrHW(A0)
-			Move.l	#(1<<foneslot), spParamData(A0)	; look only in this slot
-			_GetTypeSRsrc						; get slots board sRsrc
-			Bne.s	@done
-			Move.b	#sBlockTransferInfo, spID(A0)
-			_sReadLong							; does slot support block xfers?
-			Bne.s	@done						; no, leave
-			Move.l	spResult(A0), D0			; get sBlockTransferInfo long
-			BTst	#fIsSlave, D0				; handles blk xfer as slave? 
-			Beq.s	@done						; no, leave
-
-			Testfor	BARTExists					; are we on a ColdFusion or PDM
-			beq.s	@muni						; no, must be MUNI
-			BTst	#fSlvXferSz2, D0			; handles blk xfer size of 2?
-			Bne.s	@enable						; yes, go
-			BTst	#fSlvXferSz8, D0			; handles blk xfer size of 8?
-			Bne.s	@enable						; yes, go
-			bra.s	@done						; no, exit
-			
-@muni		BTst	#fSlvXferSz4, D0			; handles blk xfer size of 4?
-			Beq.s	@done						; no, leave
-			
-@enable		MoveQ	#0, D0
-			Move.b	spSlot(A0), D0
-			BSet	#8, D0						; make high word indicate enable blk xfer
-			Move.l	D0, A0
-			_SlotBlockXferCtl			
-
-@done		MoveM.l	(SP)+, A0/D0-D2
-@exit		Rts
-																							;end 	<LW2>
 
 ;_______________________________________________________________________________________
 ;	Secondary_Init	-	secondary initialization
@@ -1457,7 +1035,56 @@ Secondary_Init
 			moveq	#sLastSlot,d1					; start with slot $E					<2.0>
 @Loop
 			move.b	d1,spSlot(a0)
-			bsr.s	DoSecondaryInit					; execute slot secondaryInit code		<h7> djw
+
+			clr.b	spId(a0)						; start looking with id = 0				<4>
+			slotjsr	GetBoard						; get the sInfo and board sRsrc ptrs	<4>
+			bne.s	@Done							; bad slot
+			movea.l	spsPointer(a0),a3				; save ptr to board srsrc
+			movea.l	spResult(a0),a1					; get a1 = ptr to sInfo record
+
+;	Check the status of this slot.  If "temporarily disabled", then enable the slot
+
+			cmpi.b	#stateSInit,siState(a1)			; have we already executed secondary init ?
+			bhs.s	@Done							; yes - skip this slot
+			move.w	siInitStatusA(a1),d0			; get card status
+			bpl.s	@Continue						; status ok
+			cmpi.w	#smInitStatVErr,d0				; is card temporarily disabled ?
+			bne.s	@Done							; no - card is really bad
+			cmpi.w	#svDisabled,siInitStatusV(a1)	; vendor temporarily disabled code ?
+			bgt.s	@Done							; no - a fatal vendor code
+
+			clr.w	siInitStatusA(a1)				; temp disabled - clr err so FindStruct will work
+			bset.b	#fTempEnabled,siStatusFlags(a1)	; make sure temp enabled bit is set
+
+;	Check if the board sResource has a secondary init record
+
+@Continue	move.w	d0,d2							; save status value for siInitStatusA field
+			move.b	#SecondaryInit,spId(a0)			; id to search for
+			_sFindStruct
+			beq.s	@Execute						; secondary init record found
+			move.w	d2,siInitStatusA(a1)			; no secondary init - restore status error
+			bclr.b	#fTempEnabled,siStatusFlags(a1)	; test and clear temp enabled bit
+			beq.s	@Done							; was not set
+			move.w	#smInitStatVErr,siInitStatusA(a1)	; was "temp enabled" - restore error
+			bra.s	@Done							; continue to next slot
+
+;	Load the code and execute the secondary init record
+
+@Execute	move.l	a3,spsPointer(a0)				; restore ptr to board srsrc
+			move.b	d1,seSlot(a2)					; set slot in sExec blk
+			move.b	spFlags(a0),seFlags(a2)			; xfer warmstart flag (if present)
+			_sExec									; execute the code
+
+;	Update the sInfo record status field - vendor status returned in sExec blk
+
+			bclr.b	#fTempEnabled,siStatusFlags(a1)	; clear temp enabled bit
+			move.b	#stateSInit,siState(a1)			; update state variable
+			move.w	seStatus(a2),siInitStatusV(a1)	; update vendor status
+			bpl.s	@Done							; good secondary init status - continue
+			move.w	#smInitStatVErr,siInitStatusA(a1)	; some fatal vendor status returned
+
+@Done
+
 
 @EndLoop	dbra	d1,@Loop						; dec slot count						<2.0>
 			cmpi.b	#sLastSlot,d1					; done ?
@@ -1478,80 +1105,6 @@ Secondary_Init
 			movem.l	(sp)+,d1-d2/a1-a3
 			rts
 
-;_______________________________________________________________________________________	<h11> djw
-;	DoSecondaryInit  	-	find and execute secondaryInit records
-;
-;	Called by Secondary_Init.  For a single slot, find the board sResource and if there
-;	is a secondary init record, execute it.
-;
-;	Input	: reg a0 = ptr to spBlock
-;				  a2 = ptr to sExecBlk
-;	Output	: none
-;
-;   trashes d0/d2-a1/a3.
-;
-;	spBlock	:	-> spSlot			slot number
-;
-			Export	DoSecondaryInit
-
-DoSecondaryInit
-@regs		reg		d0-d2/a1/a3
-			movem.l	@regs,-(sp)
-
-			clr.b	spId(a0)						; start looking with id = 0				<4>
-			slotjsr	GetBoard						; get the sInfo and board sRsrc ptrs	<4>
-			bne.s	@Done							; bad slot
-			movea.l	spsPointer(a0),a3				; save ptr to board srsrc
-			movea.l	spResult(a0),a1					; get a1 = ptr to sInfo record
-
-;	Check the status of this slot.  If "temporarily disabled", then enable the slot
-
-			cmpi.b	#stateSInit,siState(a1)			; have we already executed secondary init ?
-			bhs.s	@Done							; yes - skip this slot
-			move.w	siInitStatusA(a1),d0			; get card status
-			bpl.s	@Continue						; status ok
-			cmpi.w	#smInitStatVErr,d0				; is card temporarily disabled ?
-			bne.s	@Done							; no - card is really bad
-			cmpi.w	#svDisabled,siInitStatusV(a1)	; vendor temporarily disabled code ?
-			bgt.s	@Done							; no - a fatal vendor code
-
-			clr.w	siInitStatusA(a1)				; temp disabled - clr err so FindStruct will work
-			bset.b	#fTempEnabled,siStatusFlags(a1)	; make sure temp enabled bit is set
-
-;	Check if the board sResource has a secondary init record
-
-@Continue	move.w	d0,d2							; save status value for siInitStatusA field
-			move.b	#SecondaryInit,spId(a0)			; id to search for
-			_sFindStruct
-			beq.s	@Execute						; secondary init record found
-			move.w	d2,siInitStatusA(a1)			; no secondary init - restore status error
-			bclr.b	#fTempEnabled,siStatusFlags(a1)	; test and clear temp enabled bit
-			beq.s	@Done							; was not set
-			move.w	#smInitStatVErr,siInitStatusA(a1)	; was "temp enabled" - restore error
-			bra.s	@Done							; continue to next slot
-
-;	Load the code and execute the secondary init record
-
-@Execute	move.l	a3,spsPointer(a0)				; restore ptr to board srsrc
-			move.b	spSlot(a0),seSlot(a2)			; set slot in sExec blk
-			move.b	spFlags(a0),seFlags(a2)			; xfer warmstart flag (if present)
-			_sExec									; execute the code
-
-;	Update the sInfo record status field - vendor status returned in sExec blk
-
-			bclr.b	#fTempEnabled,siStatusFlags(a1)	; clear temp enabled bit
-			move.b	#stateSInit,siState(a1)			; update state variable
-			move.w	seStatus(a2),siInitStatusV(a1)	; update vendor status
-			bpl.s	@Done							; good secondary init status - continue
-			move.w	#smInitStatVErr,siInitStatusA(a1)	; some fatal vendor status returned
-
-@Done
-			movem.l	(sp)+,@regs
-			rts
-			endwith
-
-		If SeparateFile or Not forROM then			;										<8>
-
 ;_______________________________________________________________________________________
 ;	ReConfigVideo  -  select new default video screen
 ;
@@ -1621,8 +1174,6 @@ ROMFROVideo	Equ	$00000b58						; hard offset only applies to Mac II rev A roms	<
 @Done		MOVEQ	#0,D0						; only good returns
 			RTS									; done
 
-		endif									;											<8>
-
 SecondaryEnd
 
 			

--- a/OS/StartMgr/Boot3.a
+++ b/OS/StartMgr/Boot3.a
@@ -23,59 +23,7 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM30>	 11/7/93	SAM		Roll in <MC2> from mc900ftjesus.
-;	   <MC2>	 11/7/93	SAM		Sync-in this file with CPUBootcode.a from the gibbly sources.
-;	  <SM29>	 7/21/93	RC		Changed RegisterROMComponent to selector 42 instead of 27
-;	  <SM28>	 7/20/93	SAM		Cleaned up more stuff.  Moved the processmgr 'proc' resource
-;									loading code *way* forward in the boot.  The scod's end up being
-;									the very first resources in the heap. The "Welcome dialog is
-;									displayed after the scods are loaded.  Removed a couple of 24
-;									bit routines.  Redid the old installmgr code (which is now
-;									called InitSys7ToolBox).  See the comment block around that
-;									change for details.  Made QuickTime components not load on
-;									68010s.  Added labels to the ROM header references.
-;	  <SM27>	 6/17/93	rab		Removed the GetGibbly and CanThisGibblyBootThisMachine routines
-;									and the code that calls them. This code was inadvertantly rolled
-;									in during the Ludwig sync up.
-;	  <SM26>	 6/15/93	SAM		Undid change <LW2> for PDM.  We dont need a gibbly to boot
-;									(we're actually turning the ROM you see...)
-;	  <SM25>	 6/14/93	kc		Roll in Ludwig.
-;	  <LW2>		3/25/93		GS		Added GetGibbly and CanthisGibblyBootThisMachine routines to put 
-;									up the proper Alert when booting a 7.1 System without a Gibbly.
-;	  <SM24>	 4/20/93	SAM		Removed a call to _InitFonts, cuz _InitGraf calls it.
-;	  <SM23>	 2/12/93	PN		Add forROM condition for the previous change
-;	  <SM22>	02/11/93	HY		Fix problem in routine DetachAndExecute.  If a particular resource
-;									is not found in either the ROM or system file then you crash. 
-;	  <SM21>	02/10/93	HY		Enable Appletalk on LCR/LC930 again.  Revert <SM18> changes.
-;	  <SM20>	  2/5/93	SAM		Removed the code that was unimplementing MemoryDispatch based on
-;									MMUtype.  Removed the CPU/MMU checks before calling VM.  VM
-;									knows if it can run.
-;	  <SM19>	01/11/93	jmp		Updated various BoxFlag names.
-;	  <SM18>	12/16/92	HY		Disable Appletalk on LCR/LC930.
-;	  <SM17>	 12/7/92	GMA		We now call RegisterRomComponents directly from Boot3 instead of
-;									through the Manager InstallationVector(in ROM). Rom Components
-;									are registered (through ComponentDispatch) after making the
-;									Cyclone Gibbly Resident. This allows the Components in ROM to
-;									use Localized Strings in the Gibbly without referenceing the
-;									gibbly file directly.
-;	  <SM16>	 12/1/92	RB		Added a call to MakeOverrideMap so that the 'rovm' resource is
-;									used to override some system resources.
-;	  <SM15>	11/20/92	GS		Added the EnablePDMsgs for the Quadra 900/950 .  This was
-;									originally in a linked patch routine to avoid a problem with the
-;									KeySw handler early in the boot process.
-;	  <SM14>	11/18/92	RB		Finally, the Disk Cache code is in ROM so we don't need to
-;									install ptch 41 (the only one in SuperMario ROMs) anymore.
-;	  <SM13>	 11/3/92	RB		Use ROMBase to check for VM being in ROM or not, and call
-;									StripAddress on the resource pointer before checkin it, just in
-;									case we are in 24 bit mode.
-;	  <SM12>	 11/3/92	fau		Corrected a dereference in DetachandExecute.
-;	  <SM11>	11/01/92	HY		Conditionalize changes in <SM10> for LC930 because we don't have 
-;									VM in ROM.
-;	  <SM10>	10/30/92	RB		Give VM in ROM a chance to load when this file is being used as
-;									a ROM Gibbly. VM in ROM is newer than the one in the system and
-;									it behaves correctly in SuperMario based ROMs.
 ;	   <SM9>	10/29/92	SWC		Changed ShutdownEqu.a->Shutdown.a.
-;		<SM8>	10/22/92	CSS		Change short branches to word branches.
 ;		<41>	 8/13/92	JDR		Offset to CloseTheFile was out of range in ForTheFuture.
 ;		<40>	 8/13/92	DTY		#1039434 <BBM>: Don’t register components from QuickTime if
 ;									we’re booting on a 68000.
@@ -471,7 +419,7 @@ supportsMFM				equ		1
 			include	'TextServices.a'		; so we have SetTextServiceLanguage					<14>
 			include	'UniversalEqu.a'		; 													<15>
 
-						MACHINE	MC68020		; <SM28>
+						MACHINE	MC68040
 
 
 _AUXDispatch	 		opword	$ABF9		; <24> A/UX’s trap dispatch *** move to Traps.a
@@ -508,19 +456,6 @@ kFileShareCreator		equ		'hhgg'		; <12>
 kAppleShareCreator		equ		'afps'		; <12>
 kDALCreator				equ		'dald'		; <12>
 
-	IF forROM THEN							; <28>
-
-SysVersForROM			equ		$0710		; <28> jam Cube-E system version into SysVersion lowmem for now
-
-kROMVersionPlus			equ		$0075		; <28>
-kROMVersionSE			equ		$0276		; <28>
-kROMVersionII			equ		$0178		; <28>
-kROMVersionPortable		equ		$037A		; <28>
-kROMVersionIIci			equ		$067C		; <28>
-kROMVersionSuperMario	EQU		$077D		; <28>
-
-	ENDIF									; <28>
-
 
 BootCode	MAIN
 
@@ -563,47 +498,22 @@ SetUpStartupScreen
 			bsr 	LoadDSAT				; get the handle
 			move.l	d0,d6					; stash this away to dispose later
 
-;____________________________________________________________________________________
-; Process Manager segment tweaks.
-;
-; Load these 'scod' resource as low as possible in the system heap to reduce
-; system heap fragmentation.
-;
-; Moved this code here so the 'scod's are THE first resources in the heap.  Reduces
-; fragmentation (7/20/93) SAM  					<SM28>
+			_InitFonts						; prepare to draw some text
 
-kProcessManagerSegmentType	equ		'scod'		; Process Manager segment resource type <28>
+			bsr		EraseMyIcon
 
-				subq	#2,sp					; make room in stack for old resfile id	<28>
-				_CurResFile						; Remember the current resource file, in case we’re booting from a gibbly <28>
-				clr.w	-(sp)					; id zero is always the system file		<28>
-				_UseResFile						; Work on the System file				<28>
+; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-				lea		ProcessManagerSegmentTable,a1	; Table of Process Manager segments to load low	<28>
-@loadSegmentLoop								;										<28>
+CheckForPreGibblySystem
 
-				move.w	(a1)+,d1				; Get a segment number					<28>
-				bz.s	DoneWithSegments		; Been there, done that.				<28>
-				subq	#4,sp					; room for handle result				<28>
-				move.l	#kProcessManagerSegmentType,-(sp) ;	push res type				<28>
-				move.w	d1,-(sp)				; push id								<28>
-				_Get1Resource					; Load it in							<28>
-				addq	#4,sp					; We don’t really care about the resource <28>
-				bra.s	@loadSegmentLoop		; go for the next one					<28>
-
-ProcessManagerSegmentTable						;										<28>
-
-				dc.w	$BFAC					; MiscSeg								<28>
-				dc.w	$BFB0					; KernelSeg								<28>
-				dc.w	$BFB2					; EPPCSeg								<28>
-				dc.w	0						; End of table							<28>
-
-DoneWithSegments								;										<28>
-				_UseResFile						; The current resource file is on the stack <28>
-
-
-			bsr		EraseMyIcon					; Erase the happy Mac a little later (after the processmgr loads) <SM28>
+; If there are no Gibblies that can boot this machine according to 'boot' 2,
+; display the System Too Old version.
 
+			btst	#systemEnabledBit,ExtensionsEnabledByte
+			beq.s	@gibblyPresent
+			moveq	#dsOldSystem,d0
+			_SysError
+@gibblyPresent
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
@@ -666,6 +576,7 @@ ShowStartupScreen
 			move.l	(sp),-(sp)
 			clr.w	-(sp)					; srcCopy mode
 			clr.l	-(sp)					; no maskRgn
+			bsr		EraseMyIcon
 			_CopyBits
 
 			lea		bitMapRec(sp),sp		; get rid of our bitMap on the stack
@@ -676,6 +587,7 @@ ShowStartupScreen
 
 ; Now, do the welcome screen.
 
+			bsr		EraseMyIcon
 			moveq	#dsGreeting,d0			; put up the greeting
 			_SysError
 
@@ -686,6 +598,7 @@ ShowStartupScreen
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 UnimplementedTrap	EQU		$9F
 MemoryDispatchTrap	EQU		$5C
+GestaltTrap			EQU		$AD
 
 SetUpCPUFlag
 
@@ -749,14 +662,10 @@ CheckFor040CacheInhibit								; <5> SAM
 
 			_FlushInstructionCache					; Push both caches back to RAM (FlushICache will do both caches)	<10>
 
-			MACHINE	MC68040							; Generate 040 MOVEC instructions...								<SM28>
-
 			MOVEC	CACR,D0							; Get the CAcheControlRegister
 			AND.L	#~((1<<CACR_DE_040)|(1<<CACR_IE_040)),D0	; Create a mask excluding the DE & IE bits
 			MOVEC	D0,CACR							; Clear DE & IE in the CACR (caches are now inhibited)
 
-			MACHINE	MC68020
-			
 			MOVEQ	#0,D0							; Clear D0															<10>
 			MOVE.W	TimeDBRA,D0						; Get TimeDBRA														<10>
 			DIVU.W	#(1000/k040CyclesPerDBRA),D0	; Compute the clock rate based on TimeDBRA & k040CyclesPerDBRA		<10>
@@ -959,7 +868,6 @@ DoWeHaveEnoughRAMToBoot
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-		IF NOT forROM THEN					; <SM28>
 LoadTemporaryStripAddress
 
 ; Patch loading depends on StripAddress, so install a temporary version for the time before loading.
@@ -980,7 +888,6 @@ LoadTemporaryStripAddress
 			_SetTrapAddress newOS			; StripAddress doesn’t exist, use mine as a bootstrap
 			moveq	#1,d5					; <16> Use D5 to mean we patched _StripAddress.  Any number will do…
 @done
-		ENDIF
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 LoadVMAndDebugger
@@ -1016,6 +923,14 @@ ChooseBufPtrLimit							;													<33>
 
 GetBufPtrLimit		equ			-4			; MemoryDispatch selector to get any bufPtr limit
 
+			move	#GestaltTrap,d0			; no ROM Gestalt means no MMU (Plus, SE, II?)
+			_GetTrapAddress newOS
+			move.l	a0,d1
+			move	#UnimplementedTrap,d0
+			_GetTrapAddress newTool
+			cmp.l	a0,d1
+			beq.s	@noVMLimit
+
 			move.l	#gestaltVMAttr,d0		; is VM on?
 			_Gestalt						;
 			tst.w	d0
@@ -1068,7 +983,7 @@ RelocateBootWorld
 
 			move.l	BootGlobals.logicalMemTop(a5), d0		; starting MemTop					<10>
 			cmp.l	BootGlobals.physicalMemTop(a5), d0		; did we add memory?				<10>
-			bls 	LoadUserAlerts							; if not, don’t bother				<10> <SM8> CSS 
+			bls.s	LoadUserAlerts							; if not, don’t bother				<10>
 
 			lsr.l	#1, d0									; new MemTop/2						<10>
 			move.l	d0, a1									; point to the new stack			<10>
@@ -1076,7 +991,7 @@ RelocateBootWorld
 ; fo the stack, so use the logical page size to figure out how many pages to bring in.			<12>
 			move.l	#gestaltLogicalPageSize, d0				; we want the page size				<12>
 			_Gestalt										; VM implements Gestalt				<12>
-			bne 	LoadUserAlerts							; huh? just bail…					<12> <SM8> CSS 
+			bne.s	LoadUserAlerts							; huh? just bail…					<12>
 			move.l	#kBootStackSizeNeeded, d1				; size of stack needed				<12>
 			move.w	a0, d0									; page size							<12>
 			divu	d0, d1									; number of pages we need			<12>
@@ -1115,14 +1030,12 @@ RelocateBootWorld
 			jmp		(sp)									; go to new code location			<10>
 
 FinishMovingBootWorld										;									<10>
-		IF NOT forROM THEN									;									<SM28> SAM
 			tst.w	d5										; <16> Check our _StripAddress semaphore
 			bz.s	@done									; <16> If D5 is not set, we didn’t patch _StripAddress
 
 			moveq	#$55, d0								;									<10>
 			lea 	TemporaryStripAddress, a0				;									<10>
 			_SetTrapAddress newOS							; retarget the interim StripAddress code	<10>
-		ENDIF
 @done														;									<10>
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
@@ -1190,8 +1103,6 @@ ActivateTrackCache
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-	IF NOT forROM THEN						; <SM2> rb <SM14> rb
-
 LoadFileSystemCache
 
 ; This makes assumptions about the RAM cache that are not true of the 6.X cache:
@@ -1216,116 +1127,13 @@ LoadFileSystemCache
 			moveq	#41,d0
 			bsr 	LoadLowerCaseptch
 
-	ENDIF									; <SM2> rb <SM14> rb
-
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-		IF forROM THEN					;											<28>
-
-; In the SuperMario based ROMs, we do not run PTCH(0) or any other patches.  However, we do
-; need some of the functionality from PTCH(0).  So instead we will execute some of the code
-; which is relevant to SuperMario ROMs.  The code in here comes from the file BeforePatches.a
-; which gets compiled into PTCH(0), the Universal patch. (Or used to be-Universal). If the code
-; in this section gets too big, copy this file into a ROMBoot3.a file so that we do not bother
-; the system guys.
-
-; Make sure that ExpandMem is the latest, we leave this here because when the system changes, we
-; will need to recompile this gibbly resource and ship it with the system disks, therefore the
-; ROM will have an outdated version of ExpandMem.  The loading of new vectors from disk will
-; happen around this time, so the code that allocated the ExpandMem has already been executed
-; and there is no point on replacing it with a new vector.  So let's update ExpandMem. <28>
-
-
-			with	ExpandMemRec		;											<28>
-
-			movea.l ExpandMem,a0		; Let's see if we have the latest			<28>
-			move.l	emSize(a0),d0		; current size of ExpandMem record			<28>
-			cmpi.l	#emRecSize,d0		; already allocated new blocks?				<28>
-			bge.s	@noSpandex			; no change nessesary...  				    <28>
-
-; allocate a new block for the newer ExpandMem
-
-			movea.l a0,a1				; save original ExpandMem pointer			<28>
-			move.l	#emRecSize,d0		; allocate correct amount of space			<28>
-			_NewPtr ,SYS,CLEAR			; make pointer for a bigger and better copy	<28>
-			bne 	@ErrorXit			; no memory ? something must be really wrong <28>
-
-; a0 = pointer allocated for new expandMem of emRecSize bytes.
-; copy original bytes of expandMem into my local space.
-
-			move.l	emSize(a1),d0		; current size of ExpandMem record			<28>
-			exg 	a0,a1				; want source in a0							<28>
-			_BlockMove					; <29June89smb>	copy old data				<28>
-			move.w	#emCurVersion,emVersion(a1) ; version number					<28>
-			move.l	#emRecSize,emSize(a1) 	; size									<28>
-			move.l	a1,ExpandMem		; start using new expandMem					<28>
-
-; dispose of original ExpandMem pointer.
-			_DisposPtr					; still in a0 after move 					<28>
-			beq.s	@noSpandex			; exit if everything is ok					<28>
-
-@ErrorXit	_SysError					; <24Aug89smb>								<28>
-
-			endWith						;											<28>
-
-@noSpandex								; skip around when no room
-
-;____________________________________________________________________________________
-; Jam system version number.												<PP149>
-; *** we may not really want to do this in the ROM gibbly, but it doesn’t hurt
-
-			move.w	#SysVersForROM,SysVersion ; jam sys version number				<28>
-
-;____________________________________________________________________________________
-
-; Check to see if AppleTalk is active.  If it is not, set emAppleTalkInactiveOnBoot
-; to true.  Various other parts of the System will look at this global later on to
-; determine whether or not network code should be loaded.
-
-			move.b	SPConfig,d0				;  Get serial port configuration		<28>
-			and.b	#$0f,d0					;  Mask off Port B bits					<28>
-			beq.s	@appleTalkIsActive		;  Yes.  Don’t set emAppleTalkInactiveOnBoot <62>
-			cmp.b	#useATalk,d0			;  Configured for AppleTalk?			<28>
-			beq.s	@appleTalkIsActive		;  Yes.  Don’t set emAppleTalkInactiveOnBoot <28>
-
-			with	ExpandMemRec						; Get the system's globals	<28>
-			move.l	ExpandMem,a0						; 							<28>
-			move.w	#-1,emAppleTalkInactiveOnBoot(a0)	; just do it				<28>
-			EndWith										;							<28>
-
-@appleTalkIsActive										;							<28>
-
-; loop through all the open resource files, and clear the alternate attributes byte
-; then, set it for the system file
-
-SetupResourceFileAttributes					;											<28>
-			move.l	TopMapHndl,a0			;start with the first map					<28>
-@next										;											<28>
-			move.l	a0,d0					;are we done?								<28>
-			bz.s	@done					;											<28>
-			move.l	(a0),a0					;get the map pointer						<28>
-			bclr	#decompressionPasswordBit,mInMemoryAttr(a0)			; clear the flags for this map <28>
-			move.l	mNext(a0),a0			;go on to the next map						<28>
-			bra.s	@next					;											<28>
-@done										;											<28>
-			move.l	SysMapHndl,a0			;get the system map							<28>
-			move.l	(a0),a0					;											<28>
-			bset	#decompressionPasswordBit,mInMemoryAttr(a0)			; allow dcmps here 		<28>
-			bset	#dontCountOrIndexDuplicatesBit,mInMemoryAttr(a0)	; Don’t count duplicate resources in the System file <28>
-			bset	#twoDeepBit,mInMemoryAttr(a0)						; One deep calls on the System file will search two (or more) maps. <28>
-
-
-		ELSE								; not ROM, System version					<28>
-
 LoadPTCHZero
 
-; PTCH(0) does not get executed in SuperMario based ROMs, only in the System.			<28>
-
 			MOVEQ	#0,D0					; load patches for all ROMs
 			BSR 	LoadPTCH
 
-		ENDIF								; IF forROM									<28>
-
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
@@ -1337,9 +1145,6 @@ LoadPTCHZero
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-	IF NOT forROM THEN						; don’t load ROM specfic patches or linked patches	<28>
-											; for SuperMario									<28>
-
 LoadPTCHROMSpecific
 		
 		; *** obsolete, get rid of this eventually
@@ -1394,70 +1199,6 @@ LoadLinkedPatches
 		
 @done
 
-	ENDIF									; IF NOT forROM									<28>
-
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-; Initialize all the System 7.0 Toolbox managers and finalize the VM installation
-; if its enabled.  Rewrote this (7/20/93) <SM28>.  Make Override needs to be called before
-; all the System 7 toolbox init code runs, TEInit after, and finally ROM component registration.	<SM28>
-;
-
-; In the SuperMario ROM, most of the 7.0 initialization routines have been grouped
-; together so that we can call them trough a 1 vector call.  This vector offset from
-; the start of the ROM is guaranteed not to change.  Later on we may want to change
-; this code so it can tell the vector routine which 7.0 Managers to initialize and
-; which ones not to initialize.  As in:  "We totally re-wrote the Sound Manager, so
-; don't bother installing the old one"
-
-	IF forROM THEN
-									; Override sys resources before initing the 7.0 toolbox stuff	<SM28>
-			
-			move.l	SysMapHndl,-(sp); Push the map to override (the System File map)
-			_MakeOverrideMap		; Override resources in the System with those in the 'romv'
-									; ROM resource.
-
-			WITH	ROMHeader
-			CLR.W	CurMap			; Make the System Map the current one
-
-			MOVE.L	ROMBase,A0					; Get base o ROM
-			ADD.L	InitSys7ToolboxOff(A0),A0	; Add in the offset to the routine of Doom
-			JSR		(A0)						; Call the 7.0 Toolbox initialization code	<SM28>
-					
-DoRegisterROMComponents
-			moveq	#42,d0							; Component Search selector for RegisterROMComponents					<70><72>
-
-			_ComponentDispatch						; register the components ('thng' rsrc's) in ROM
-			ENDWITH
-
-	ENDIF
-
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-
-; Load and Execute GoNative Loader
-LoadGoNative
-	
-			lea		KeyMap,A0				; Point to keymap					<76>
-			cmpi.l	#$03000000,(A0)			; Are both S & A down?
-			beq.s	@noLoad					; -> Nope, load as usual
-		;	cmpi.l	#$00200000,4(A0)		; Is N down?
-		;	beq.s	@noLoad					; -> Yes, (NSA) do not load the NTRBs
-			
-@load		move.w	#0,d0					; ID=0
-			move.l	#'gnld',d1				; type='gnld'
-			bsr		DetachAndExecute
-@noLoad
-
-
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-
-; Load and Execute Emulator Accelerations
-LoadEmulatorAccel
-	
-			move.b	#-1,ROMMapInsert
-			move.w	#1,d0					; ID=1
-			move.l	#'GARY',d1				; type='GARY'
-			bsr		DetachAndExecute
-
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 			bsr		RealityCheck			; check for enough memory to continue
@@ -1648,6 +1389,9 @@ LoadSystemComponents						;													<9>
 
 ; Register any components lurking in the system file											<9>
 
+			btst	#extensionsEnabledBit,ExtensionsEnabledByte
+			bz.s	@skipThings
+
 ;pascal long RegisterComponentResourceFile(short resRefNum, short global)						<9>
 			clr.l	-(sp)					; return value										<9>
 			clr.w	-(sp)					; system map fref									<9>
@@ -1655,14 +1399,7 @@ LoadSystemComponents						;													<9>
 			_RegisterComponentResourceFile	;													<9>
 			addq	#4,sp					; ignore result										<9>
 
-;  In the case where a component had a cmpWantsRegisterMessage, it can happen that the component
-;  manager will clone the component and open it in the app heap  (if the sys heap is full).  Unfortunately,
-;  it looks like when that component is closed, the Component Manager globals still thinks that the cloned
-;  component is around.  This will most likely not be true after all the INITs load, since the sys heap 
-;  will grow pushing the app heap up which makes some handles to the "closed" component now invalid.
-;  The following call will make sure to remove any component instances left around in the app heap.
-
-			_CleanUpApplicationComponents	; clean up any components left in the app heap
+@skipThings
 
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
@@ -1735,14 +1472,6 @@ LoadINITFiles
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-;	Enable PowerDown Messages if Caboose is available											<SM15>
-
-			jsr		EnablePDMsgs
-
-;——————————————————————————————————————————————————————————————————————————————————————————————————
-
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-
 ; Now that networks are usable, give script systems a chance to install fonts over the network.	<14>
 
 			subq	#2,sp					; make room for OSErr result
@@ -2227,8 +1956,8 @@ LoadINITFile
 ; <40> QuickTime components should not be registered on 68000 machines, since they all
 ;		assume the 020.
 
-			cmp.b	#cpu68020,CPUFlag		; <40> Are we on a 68000? (you mean, less than an '020 right? <SM28>)
-			blo.s	@skipQuickTimeFix		; <40> If so, don’t register QuickTime’s components
+			cmp.b	#cpu68000,CPUFlag		; <40> Are we on a 68000?
+			beq.s	@skipQuickTimeFix		; <40> If so, don’t register QuickTime’s components
 
 ;pascal long RegisterComponentResourceFile(short resRefNum, short global)				<9>
 			clr.l	-(sp)					; return value								<9>
@@ -2522,7 +2251,6 @@ GetINITResource
 			rts
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
-	IF NOT forROM THEN						; We's never gonna be a II 							<SM28>
 HandleMacIIWith030							; rewrite to simpler, more informed case			<48>
 
 ; Check for a Mac II ROM with a 68030.
@@ -2581,7 +2309,6 @@ HandleMacIIWith030							; rewrite to simpler, more informed case			<48>
 
 @bail
 			rts
-		ENDIF
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 LoadVM
@@ -2592,9 +2319,14 @@ LoadVM
 			btst.b	#hwCbAUX,HWCfgFlags		; are we under A/UX?
 			bnz.s	@noVM
 
-	IF forROM THEN							; we want the newer VM in ROM						<SM10> rb
-			move.w	#mapTrue,ROMMapInsert	; use the ROM if available							<SM10> rb
-	ENDIF									;													<SM10> rb
+			moveq	#cpu68020,d0
+			cmp.b	cpuFlag,d0
+			blt.s	@yesVM
+			bgt.s	@noVM
+			cmp.b	MMUtype,d0
+			bgt.s	@noVM
+@yesVM
+
 			lea		VMName,a0				; put name of VM into CurApPtr						<37>
 			move.l	a0,CurNamePtr			; Put ptr to the VM string							<37>
 			moveq	#42,d0
@@ -2766,47 +2498,12 @@ DetachAndExecute
 ; Patches are called with their handle in D1.L.
 
 	
-	IF forROM THEN							; Special case ROM's VM					<SM10> rb
-			MOVE.L	D1,-(SP)				; save resource type					<SM10> rb
-			MOVE.W	D0,-(SP)				; save resource id						<SM10> rb
-	ENDIF									;										<SM10> rb
-
 			SUBQ	#4,SP					; make room on the stack
 			MOVE.L	d1,-(SP)
 			MOVE.W	d0,-(SP)
 			_GetResource					; get the resource handle
 			MOVE.L	(SP)+,D1				; save the resource handle
-			BNE.S	@GotResource			; did we find the resource?				<SM22> hy
-	IF forROM THEN							; <SM23> 
-			ADDA.L	#6,SP					; clean up stack and get out of here	<SM22> hy
-	ENDIF		
-			BRA.S	@skip					; we didn’t get it, so just go on		<SM22> hy
-	
-@GotResource								; found it								<SM22> hy
-
-	IF forROM THEN							;										<SM10> rb
-			CMP.L	#'ptch',2(SP)			; was this lowercase patch ?			<SM10> rb
-			BNE.S	@NotROM_VM				; if not, keep on						<SM10> rb
-			CMP.W	#42,(SP)				; was it id 42, VM ?					<SM10> rb
-			BNE.S	@NotROM_VM				; if not, don't special case			<SM10> rb
-			
-			MOVE.L	D1,A0					; put ROM's VM res handle in a0			<SM10> rb
-			MOVE.L	A0,-(SP)				; save this handle, potential ROM res	<SM10> rb
-			MOVE.L	(A0),A0					; let's get its pointer					<SM12> rb
-			MOVE.L	A0,D0					; copy resource pointer to D0			<SM10> rb
-			_StripAddress					; if in 24 bit mode, get rid of flags	<SM13> rb
-			MOVE.L	(SP)+,A0				; recover the resource handle			<SM10> rb
-			CMP.L	ROMBase,D0				; is it a ROM resource ?				<SM10> rb <SM13> rb
-			BLT.S	@NotROM_VM				; if not, don't copy to RAM, it's RAM	<SM10> rb
-			_HandToHand						; copy ROM to memory					<SM10> rb
-			MOVE.L	A0,D1					; and set their handle to ptch 42		<SM10> rb
-			_HLock							; make sure it's locked too				<SM10> rb
-			
-@NotROM_VM									;										<SM10> rb
-			ADDA.L	#6,SP					; recover saved type and id				<SM10> rb
-			
-	ENDIF																
-
+			BEQ.S	@skip
 			MOVE.L	D1,-(SP)				; detach it
 			_DetachResource
 			MOVE.L	D1,A0					; get the handle
@@ -3122,7 +2819,6 @@ AdjustBarrier	;																				<38>
 			rts
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
-	IF NOT forROM THEN								; not for us either... <SM28>
 TemporaryStripAddress
 
 ; This is a copy of StripAddress used on the Plus and SE during initialization.
@@ -3130,13 +2826,10 @@ TemporaryStripAddress
 
 			AND.L	Lo3Bytes,D0
 			RTS
-	ENDIF
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 EraseMyIcon
 
-	IF NOT forROM THEN						; <28>
-
 ; Get rid of the happy Macintosh icon.
 ; The ROMs leave this icon on the screen and now that we have taken part of the
 ; boot process away from the ROM we need to erase that icon.  For the old ROMs we
@@ -3169,23 +2862,6 @@ EraseMyIconTable
 			dc.w	kROMVersionIIci,$17DA			; IIci
 			dc.w	0
 
-	ELSE											;							<28>
-
-; SuperMario based ROMs have a vector at the start of the ROM where the			<28>
-; address of the EraseMyIcon routine from ROM is stored. So let's call it.		<28>
-
-			WITH	ROMHeader
-
-			MOVE.L	ROMBase,A0					; Get base o ROM
-			ADD.L	EraseIconOff(A0),A0			; Add in the offset to the Happy Mac erase code
-			JSR		(A0)						; Erase it.						<SM28>
-
-			ENDWITH
-
-			rts
-
-	ENDIF
-
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 CenterOnMainScreen
@@ -3236,9 +2912,6 @@ CenterOnMainScreen
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-	IF NOT forROM THEN						; This patch is not needed when building this as	<28>
-											; a gibbly for SuperMario based ROMs.				<28>
-
 CachesOffMFMPatch
 
 			MOVE.L	(SP)+,DskRtnAdr		;Save return address
@@ -3266,54 +2939,6 @@ CachesOffMFMPatch
 
 EndCachesOffMFMPatch EQU	*
 
-	ENDIF									; IF NOT forROM										<28>
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-
-
-;__________________________________________________________________________________			<<SM15>> thru next <<SM15>>
-;
-;	EnablePDMsgs - Enable Eclipse PowerDown Messages
-;
-;		This causes Caboose PowerDown messages to be sent to Eclipse instead of
-;		having Caboose turn the power off FOR you.  This way, we can unmount volumes
-;		and flush file caches, etc.  The code that does this is initialized in the ROM
-;		but has problems running before the filesystem is initialized.  Hence, it lives
-;		here because this is where the ShutdownMgr finally gets itself established.
-;__________________________________________________________________________________
-
-
-EnablePDMsgs	
-;	Only perform this initialization on machines that have Caboose-style keyswitches			<5>
-;	(i.e.:  Eclipse + Zydeco)																	<5>
-;	AND now (i.e.:  Cyclone and Cyclone LC)														<5><SM13> rb
-;
-			move.l	d0,-(sp)						; save a handy working register				<5>
-			move.l	#KeyswMask,d0					; get isolation mask ready					<5>
-			and.l	UnivROMFlags,d0					; grab keyswitch bits in UnivROMFlags		<5>
-			sub.l	#KeyswCaboose,d0				; and check if we're a Caboose keyswitch	<5>
-			movem.l	(sp)+,d0						; restore D0 (MOVEM doesn't reset CCR)		<5><SM13> rb
-			blt.s	@exit							; IF Caboose-Style Keyswitch THEN			<5><SM13> rb
-;
-;		Enable Caboose/Cuda to send Power Down Messages
-;
-		WITH	EgretPB
-
-			movem.l	d0/a0-a1,-(sp)					;     create some work registers
-			suba.l	#EgretPbSize,sp					;     make room for PB
-			move.l	sp,a0							;     point A0 to parameter block
-			move.w	#(PseudoPkt << 8) \
-					+ EnDisPDM,pbCmdType(a0)		;     Enable PowerDown Messages
-			clr.l	pbParam(a0)						;     clr parm 								<SM6>
-			move.b	#PDMTurnOn,pbParam(a0)			;     Egret powerdown msg enable			<SM6>
-			clr.l	pbCompletion(a0)				;	  No Completion
-			_EgretDispatch
-
-			adda.l	#EgretPbSize,sp					;     discard the parameter block
-			movem.l	(sp)+,d0/a0-a1					;     restore registers
-@exit												; ENDIF
-			rts										; Return to Caller							<SM15>
-		ENDWITH
-
 
 EndOfBootCode
 

--- a/Patches/BeforePatches.a
+++ b/Patches/BeforePatches.a
@@ -585,6 +585,7 @@ RAMSysInit	PROC	EXPORT
 
 			move.b	SPConfig,d0				; <26> Get serial port configuration
 			and.b	#$0f,d0					; <26> Mask off Port B bits
+			beq.s	@appleTalkIsActive
 			cmp.b	#useATalk,d0			; <26> Configured for AppleTalk?
 			beq.s	@appleTalkIsActive		; <26> Yes.  Don’t set emAppleTalkInactiveOnBoot
 

--- a/Patches/PatchIIROM.a
+++ b/Patches/PatchIIROM.a
@@ -6982,6 +6982,7 @@ InitSlotStuff
 
 
 ;Copy the tickCounts into the new structures
+			move.l	#-1,SlotVBLQ
 			moveq	#sNumSlots-1,d1				; move sNumSlots queue headers
 			lea		([SlotQDT],\				; point to ticks for last slot
 					slotVBLInfos+slotTickCount-\

--- a/Patches/PatchIIciROM.a
+++ b/Patches/PatchIIciROM.a
@@ -596,7 +596,6 @@ Scripts604		EQU		0						;<4.7><08/21/89 pke>
 			Include		'ScriptPriv.a'			;
 			INCLUDE		'GestaltEqu.a'			;
 			INCLUDE		'GestaltPrivateEqu.a'	;
-			INCLUDE		'TextEditPriv.a'		; <1/16/90smb> <16>
 			INCLUDE		'PackMacs.a'			;
 			INCLUDE		'InternalMacros.a'		; <54>
 
@@ -1491,6 +1490,8 @@ gestaltSerial	PROC	EXPORT
 				movea.l	emGestalt(a0),a0				; get gestalt global ptr
 				moveq.l #0,d0							; assume no GPI connections
 				cmpi.w	#gestaltMacLC,machType(a0)		; <107> use real machine name now...
+				beq.s	@noGPI
+				cmpi.w	#gestaltMacLCII,machType(a0)
 				beq.s	@noGPI
 														; IIci and IIsi have GPI connected
 				moveq.l	#(1<<gestaltHasGPIaToDCDa)|\	;	GPIa connected to DCDa
@@ -6359,10 +6360,22 @@ ROMBusErrRecovery	EQU		$00008a6c			; recovery delay routine in ROM				<29>
 			cmp.l	SCSIHsk,d0					; was it a SCSI chip access ?
 			beq.s	@start						; if so, start processing the bus error
 
+			movem.l	d1/a4,-(sp)
+			move.l	SCSIGlobals,a4
+			move.l	SCSI2Base,d1
+			bz.s	@noScsi2
+			cmp.l	scsiGlobalRecord.hhsk5380_2(a4),d0
+			beq.s	@matches
+@noScsi2
+			movem.l	(sp)+,d1/a4
+
 			move.l	(sp)+,d0					; restore d0
 			move.l	OldBusErrVct(a6),-(sp)		; put old bus error handler addr on stack	<end>
 			rts									; jump to old handler, assuming it'll RTE	<29>
 
+@matches
+			movem.l	(sp)+,d1/a4
+
 @start
 
 			subq.w	#1,BusErrCount(a6)			; retry until we get tired
@@ -8047,6 +8060,18 @@ FixUpLooP	move.l		(A0)+, D1
 ;=========================================================================================
 
 
+;————————————————————————————————————————————————————————————————————————————
+; Distinguish LCII from the LC using ROM version
+;
+			cmp.b	#boxMacLC,BoxFlag
+			bne.s	@notLCII
+			move.l	RomBase,a0
+			cmp.b	#$19,ROMHeader.ROMRelease(a0)
+			bne.s	@notLCII
+			move.b	#boxMacLCII,BoxFlag
+@notLCII
+
+
 ;————————————————————————————————————————————————————————————————————————————	GGD <8.4>
 ;	Fix _StripAddress to not check the MMStartMode bit of MMFlags at runtime,
 ;	because the memory manager changes that bit when accessing ROM resources,
@@ -8090,7 +8115,11 @@ FixStripAddress
 			BTST.L	#hwCbPwrMgr,D0						; Do we have a PowerMgr?
 			BEQ.S	@DoneTimLC							; -> No.  This is not a Portable of any kind
 														; We're on a TERROR $67C ROM with a PwrMgr and no FPU.
+			BTST.B	#0,$50FB4000
+			BNZ.S	@jaws25
 			MOVE.B	#boxPowerBook140,boxFlag			; We're on a Tim LC.  Stuff the right boxFlag		<146>			
+			BRA.S	@DoneTimLC
+@jaws25		MOVE.B	#boxPowerBook145,boxFlag
 @DoneTimLC
 
 ;————————————————————————————————————————————————————————————————————————————	<130><131><8><9>
@@ -8148,98 +8177,6 @@ FixStripAddress
 @FixPMLoopEnd	MOVE.L		D2,(A0)+				; stash correct address, bump A0
 				DBRA		D0,@FixPMLoop			; and count down, including zero.	dvb <8.3> end
 
-;__________________________________________________________________________
-;__________________________________________________________________________
-
-FixBackSANE	MOVE.L	#'fpu ',D0			; Gestalt FPU selector
-			_Gestalt					; Do it
-			MOVE.L	A0,D0				; Do we have an FPU?
-			BEQ		@ReallyDone			; -> No, do nothing
-						
-			MOVE.L	ROMBase,A0				; Get ROM base			
-			CMPI.B	#TERRORminorVers,18(A0)	; Is this TERROR 067C ROM?
-			BEQ		@ReallyDone				; -> Yes, leave the ROM SANE enabled!
-			CMPI.B	#ZYDECOminorVers,18(A0)	; Is this Zydeco 067C ROM?
-			BEQ		@ReallyDone				; -> Yes, leave the ROM SANE enabled!
-			
-@DisableSANEinROM
-			MOVE.B	ResLoad,-(SP)			; Save current resLoad state
-			MOVE.W	CurMap,-(SP)			; Save Current Rsrc Map refNum
-			CLR.W	CurMap					; Make the System the current Map (CurMap = 0)
-			
-			SF		ResLoad					; Don't actually read the rsrc
-			CLR.L	-(SP)					; Result
-			MOVE.L	#'PACK',-(SP)			; Type
-			MOVE.W	#4,-(SP)				; Id 4
-			_Get1Resource			
-			MOVE.L	(SP)+,D0				; Did we get it?
-			BEQ		@Done					; -> No, PACK 4 is not on the disk.  Exit Now! (Use the ROM SANE)
-			MOVE.L	D0,-(SP)
-			_ReleaseResource				; Make the System SANE handle go away. (or we'll get it at the _RmveRsrc)
-			
-			SF		ResLoad					; Don't actually read the rsrc
-			CLR.L	-(SP)					; Result
-			MOVE.L	#'PACK',-(SP)			; Type
-			MOVE.W	#5,-(SP)				; Id 5
-			_Get1Resource			
-			MOVE.L	(SP)+,D0				; Did we get it?
-			BEQ		@Done					; -> No, PACK 5 is not on the disk.  Exit Now! (Use the ROM SANE)
-			MOVE.L	D0,-(SP)
-			_ReleaseResource				; Make the System SANE handle go away. (or we'll get it at the _RmveRsrc)
-			
-			ST		RomMapInsert			;  Put the ROM map in first
-			MOVE.W	#1,CurMap				; Make the ROM map current
-			
-			CLR.L	-(SP)					; Result
-			MOVE.L	#'PACK',-(SP)			; Type
-			MOVE.W	#4,-(SP)				; Id 4
-			_Get1Resource			
-			MOVE.L	(SP)+,D0				; Did we get it?
-			BEQ.S	@Try45					; -> No, try 4 five.
-			
-			MOVE.L	D0,-(SP)				; The Handle (save a copy of it)
-			MOVE.L	ROMMapHndl,-(SP)		; Save this
-			MOVE.L	#-1,ROMMapHndl			; To fool SetResAttr into letting use change ROM rsrc attrs
-			
-			MOVE.L	D0,-(SP)				; The Handle (push it. Push it good)
-			MOVE.W	#$50,-(SP)				; A good value (Unprotected)
-			_SetResAttrs
-			MOVE.L	(SP)+,ROMMapHndl
-
-			MOVE.W	#1,CurMap				; Set CurMap to the ROM rsrc map
-			ST		RomMapInsert			; Dont load the rsrc into memory						
-			_RmveResource
-
-@Try45		ST		RomMapInsert			;  Put the ROM map in first
-
-			CLR.L	-(SP)					; Result
-			MOVE.L	#'PACK',-(SP)			; Type
-			MOVE.W	#5,-(SP)				; Id 5
-			_Get1Resource			
-			MOVE.L	(SP)+,D0				; Did we get it?
-			BEQ.S	@Done					; -> No, exit
-			
-			MOVE.L	D0,-(SP)				; The Handle (save a copy of it)
-			MOVE.L	ROMMapHndl,-(SP)		; Save this
-			MOVE.L	#-1,ROMMapHndl			; To fool SetResAttr into letting use change ROM rsrc attrs
-
-			MOVE.L	D0,-(SP)				; The Handle (push it. Push it good)
-			MOVE.W	#$50,-(SP)				; A good value (Unprotected)
-			_SetResAttrs
-			MOVE.L	(SP)+,ROMMapHndl
-			
-			MOVE.W	#1,CurMap				; Set CurMap to the ROM rsrc map
-			ST		RomMapInsert			; Dont load the rsrc into memory						
-			_RmveResource
-
-@Done		MOVE.W	(SP)+,CurMap			; Restore the current res map
-			MOVE.B	(SP)+,resLoad			; Restore ResLoad
-@ReallyDone		
-;__________________________________________________________________________
-;__________________________________________________________________________
-
-
-
 ;____________________________________________________________________________		<2> RMP
 ;	This patch is used to fix a problem in the MPW Shell on Eclipse.  See above.
 
@@ -8694,6 +8631,11 @@ FixQDColors										;								<4.7>
 			CMP.B		#ClockEgret,D0					; Is bit 5 on?
 			BNE.S		@EndOfEgretOnly					; -> Nope, skip this install code
 
+			AND.L		#EgretFWMask,D0
+			BZ.S		@EndOfEgretOnly
+			CMP.L		#Cuda,D0
+			BGE.S		@EndOfEgretOnly
+
 ;----------------------------------------------------------------------------------------------------
 ; 	This patch bypasses the physical read of egret when reading the time. The time is automatically
 ;	updated in the background, therefore the low mem global always reflects the acurate time.

--- a/Patches/ProcessManagerSegmentTweaks.a
+++ b/Patches/ProcessManagerSegmentTweaks.a
@@ -34,21 +34,11 @@ LoadProcessManagerSegmentsLowerInSysHeap	InstallProc	(Plus,SE,II,IIci,Portable)
 				_CurResFile						; Remember the current resource file
 				clr.w	-(sp)
 				_UseResFile						; Work on the System file
-				move.b	ResLoad,-(sp)			; Save current resource load state
 				
 				lea		ProcessManagerSegmentTable,a4	; Table of Process Manager segments to load low
 @loadLoop
 				move.w	(a4)+,d7				; Get the segment number
 				bz.s	@doneWithSegments		; Did ’em all
-				sf		ResLoad					; Don’t load in resources
-				subq	#8,sp					; Space for _SizeResource result too
-				move.l	#kProcessManagerSegmentType,-(sp)
-				move.w	d7,-(sp)
-				_Get1Resource
-				_SizeRsrc						; Find out how big it is
-				move.l	(sp)+,d0				; Get the size
-				_ResrvMem ,Sys					; Make some space low in the heap
-				st		ResLoad					; Load it in for real now
 				subq	#4,sp
 				move.l	#kProcessManagerSegmentType,-(sp)
 				move.w	d7,-(sp)
@@ -57,7 +47,6 @@ LoadProcessManagerSegmentsLowerInSysHeap	InstallProc	(Plus,SE,II,IIci,Portable)
 				bra.s	@loadLoop
 				
 @doneWithSegments
-				move.b	(sp)+,ResLoad			; Restore resource load state
 				_UseResFile						; The current resource file is on the stack
 				rts
 
@@ -66,5 +55,10 @@ ProcessManagerSegmentTable
 				dc.w	$BFB0					; KernelSeg
 				dc.w	$BFB2					; EPPCSeg
 				dc.w	0						; End of table
+
+
+				dcb.b $200, $20
+
+
 				EndProc
 				End
\ No newline at end of file

--- a/Patches/VideoPatch.a
+++ b/Patches/VideoPatch.a
@@ -474,14 +474,16 @@ ROMMinVer		Equ		$12								; Offset from ROMBase to RAM Major version word.
 				Beq.s	StartDAFB						;	then start doing DAFB stuff.
 				Cmp.b	#boxQuadra900,D0				; If this is an Eclipse,					<7>
 				Beq.s	StartDAFB						;	then start doing DAFB stuff.
-				Cmp.b	#boxZydeco,D0					; If this is a Zydeco (Eclipse 33),
+				Cmp.b	#boxQuadra950,D0				; If this is a Zydeco (Eclipse 33),
 				Beq.s	StartDAFB						;	then start doing DAFB stuff.
 				Bra		AllDone							; Otherwise, just go home.
 
 StartDAFB		
 				Move.l	A3,A0							; Get spBlock ptr into A0.
 				Clr.b	spSlot(A0)						; We only care about Slot $0.
+				Clr.b	spId(A0)
 				Clr.b	spExtDev(A0)					; (No external device.)
+				Clr.b	spTBMask(A0)
 				Move.w	#catDisplay,spCategory(A0)		; Look for:	Display,
 				Move.w	#typVideo,spCType(A0)			;  			Video,
 				Move.w	#drSwApple,spDrvrSW(A0)			;  			Apple,
@@ -970,6 +972,7 @@ StartJMFB
 				Move.b	D3,spSlot(A0)					; Set the slot number to search in.
 				Clr.b	spId(A0)						; Begin at id 0.
 				Clr.b	spExtDev(A0)					; No external device.
+				Clr.b	spTBMask(A0)
 				Move.w	#catDisplay,spCategory(A0)		; Look for:	Display,
 				Move.w	#typVideo,spCType(A0)			;  			Video,
 				Move.w	#drSwApple,spDrvrSW(A0)			;  			Apple,

--- a/ProcessMgr/DAHandler.a
+++ b/ProcessMgr/DAHandler.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		 <5>	 9/29/92	DRF		Put back the END that got deleted in <4>
-;		 <4>	 9/25/92	DRF		Get rid of MyGestalt
 ;		 <2>	  1/3/91	fjs		(DFH) pass edit function keys to DAHandler
 ;		 <0>	 x/xx/86	PYG		New Today.
 ;
@@ -172,4 +170,22 @@ GSHSDone
 				
 				ENDPROC
 
+
+
+				SEG			'Init'
+
+;---------------------------------------------------------------------------------------
+; "MyGestalt", resurrected, because it survived through to 7.1.1
+
+MYGESTALT		PROC		EXPORT
+
+				MOVE.L		8(SP),D0
+				_Gestalt
+				MOVE.L		4(SP),A1
+				MOVE.L		A0,(A1)
+				MOVE.L		(SP)+,A0
+				LEA.L		8(SP),SP
+				MOVE.W		D0,(SP)
+				JMP			(A0)
+
 				END

--- a/ProcessMgr/DAHandler.c
+++ b/ProcessMgr/DAHandler.c
@@ -9,8 +9,6 @@
 
 	Change History (most recent first):
 	 
-	  <SM18>	 7/21/93	joe		Back out <SM17>.
-		<16>	 9/25/92	DRF		Get rid of MyGestalt
 		<15>	 4/10/92	JSM		Undo revision 14, we fixed the problem someplace else.
 		<14>	  4/4/92	DTY		#1019369,<FM>: For each desk accessory, remember the current
 									keyboard state, and the keyboard state after the driver has been
@@ -70,7 +68,6 @@
 #include <osutils.h>
 #include <segload.h>
 #include <diskinit.h>
-#include <sound.h>
 #include <GestaltEqu.h>
 #include <Palettes.h>
 #include <Icons.h>
@@ -509,7 +506,7 @@ InitConfig(void)
 	Colorized = false;
 	Has32BitQD = false;
 	
-	if (Gestalt(gestaltQuickdrawVersion,&qdInfo) == noErr)
+	if (MyGestalt(gestaltQuickdrawVersion,&qdInfo) == noErr)
 		{
 		qdInfo &= 0xFFFF;
 		Colorized = (qdInfo >= gestalt8BitQD);

--- a/ProcessMgr/DeskMgrPatches.c
+++ b/ProcessMgr/DeskMgrPatches.c
@@ -65,7 +65,6 @@
 #include <files.h>
 #include <segload.h>
 #include <devices.h>
-#include <sound.h>
 #include <MFPrivate.h>
 #include <MenuMgrPriv.h>
 #include <ResourceMgrPriv.h>

--- a/ProcessMgr/Eppc.c
+++ b/ProcessMgr/Eppc.c
@@ -11,8 +11,6 @@
 	Change History (most recent first):
 	 
 		<26>	 5/29/92	DCL		Included Script.h. GetEnvirons moved for the New Inside Mac.
-		<25>	11/25/91	DTY		Add #include <MemoryMgrPriv.h> to get interface for MoveHLow in
-									its new home.
 		<24>	11/21/91	DTY		Rolling in the 7•Up version of findFreeSessionRecord that
 									allocates the session record low in the System Heap instead of
 									in the middle of the temporary heap. This is conditionalized for
@@ -206,7 +204,9 @@
 #include <Errors.h>
 #include <MFPrivate.h>
 #include <Memory.h>
-#include <MemoryMgrPriv.h>
+#pragma parameter MoveHLow(__A0)
+pascal void MoveHLow(Handle h)
+ = 0xA09D; 
 #include <PPCToolBox.h>
 #include <AppleEventsInternal.h>
 #include <Errors.h>

--- a/ProcessMgr/Glue.h
+++ b/ProcessMgr/Glue.h
@@ -150,4 +150,6 @@ debugger(StringPtr message)
 /*	_Debugger
  */
  
+pascal OSErr MyGestalt(OSType selector,long *response);
+
 #endif __GLUE__

--- a/ProcessMgr/ProcessMgrMisc.a
+++ b/ProcessMgr/ProcessMgrMisc.a
@@ -10,12 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<19>	11/25/92	DRF		Add a conditional patch inside a_hfsdispatch to save and restore
-;									A2 across calls the the real _HFSDispatch. This is a temporary
-;									fix until the PowerPC trap glue follows the proper register
-;									saving conventions. Code is conditionalized under “PsychicTV”
-;									and will be removed at the earliest possibility.
-;		<18>	 9/25/92	DRF		Get rid of MyGestalt, since inline glue exists
 ;		<17>	 3/30/92	DTY		#1025416,<DDG>: Add gestaltSkiaGlobalsSwitched to the list of
 ;									attributes for gestaltOSAttr.
 ;		<16>	11/25/91	DTY		Call GetParallelFCBFromRefNum in the _OpenRF patch to nail the
@@ -898,16 +892,7 @@ DoOldCall
 				lea		patchtraps, a5					; get patch array address
 				move.l	(a5,d2.w),a5					; get old routine
 				exg.l	a1,a5							; restore a5, a1 <- old trap
-
-	if	(PsychicTV) then
-				move.l	a2,-(sp)						; <19>
-	endif
 				jsr		(a1)							; call old trap
-
-	if	(PsychicTV) then
-				move.l	(sp)+,a2						; <19>
-	endif
-
 				move.l	(sp)+,MemTop					; restore memtop
 				rts										; and return to it
 
@@ -1759,4 +1744,21 @@ MNGSaveRegs		REG			d0-d1/a0-a2					; working registers
 		
 				ENDPROC
 
+
+				SEG			'INIT'
+
+;---------------------------------------------------------------------------------------
+; "MyGestalt", resurrected, because it survived through to 7.1.1
+
+MYGESTALT		PROC		EXPORT
+
+				MOVE.L		8(SP),D0
+				_Gestalt
+				MOVE.L		4(SP),A1
+				MOVE.L		A0,(A1)
+				MOVE.L		(SP)+,A0
+				LEA.L		8(SP),SP
+				MOVE.W		D0,(SP)
+				JMP			(A0)
+
 				END

--- a/ProcessMgr/Processes.c
+++ b/ProcessMgr/Processes.c
@@ -742,7 +742,9 @@ CreateProcess(InternalLaunchPBPtr pParams, PEntryPtr pNewProc, PEntryPtr pLaunch
 	BlockMove(pCode0->jt, (Ptr)currenta5 + pCode0->jtoffset, pCode0->jtsize);
 
 	/* Now that things are set up, we can release segment 0 */
+#if PsychicTV
 	if (SAVESEGHANDLE != nil)
+#endif
 		ReleaseResource(SAVESEGHANDLE);
 
 	/* Try to set APPLLIMIT to ssize below current stack.  We get an error if this

--- a/ProcessMgr/Startup.c
+++ b/ProcessMgr/Startup.c
@@ -9,9 +9,6 @@
 
 	Change History (most recent first):
 
-	  <SM28>	 7/21/93	joe		Back out <SM27>.
-		<27>	10/28/92	DTY		Use new Get/Set macros to access ExpandMem.
-		<26>	 9/25/92	DRF		Get rid of MyGestalt, since inline glue exists
 		<25>	 8/26/92	DTY		Change ModSquad’s funky conditional to use #ifdefs like everyone
 									else.
 		<24>	 8/26/92	DTY		Roll in latest changes for A/UX.
@@ -511,35 +508,35 @@ InitConfig(void)
 #endif HAS_AUX_PROCESSMGR
 
 	/* Check processor addressing mode */
-	if (Gestalt(gestaltAddressingModeAttr,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltAddressingModeAttr,&gestaltResult) == noErr)
 		In32BitMode = ((gestaltResult & (1 << gestalt32BitAddressing)) != 0);
 
 	/* Check QuickDraw version */
-	if (Gestalt(gestaltQuickdrawVersion,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltQuickdrawVersion,&gestaltResult) == noErr)
 		Colorized = ((gestaltResult & 0xFFFF) >= gestalt8BitQD);
 
 	/* Does this machine have an FPU? */
-	if (Gestalt(gestaltFPUType,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltFPUType,&gestaltResult) == noErr)
 		MachineHasFPU = (gestaltResult != gestaltNoFPU);
 
 	/* Does this machine have an older style keyboard (without an escape key)? */
-	if (Gestalt(gestaltKeyboardType,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltKeyboardType,&gestaltResult) == noErr)
 		MachineHasMacPlusKbd = (gestaltResult <= gestaltMacPlusKbd);
 
-	if (Gestalt(gestaltGraphicsVersion,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltGraphicsVersion,&gestaltResult) == noErr)
 		skiaExists = true;
 	else
 		skiaExists = false;
 		
 #ifdef MODSQUAD
 	/* Check whether drag manager is installed. */
-	if (Gestalt(gestaltDragMgrVersion, &gestaltResult) == noErr)
+	if (MyGestalt(gestaltDragMgrVersion, &gestaltResult) == noErr)
 		gDragMgrIsAvailable = true;
 #endif
 
 #ifdef HAS_AUX_PROCESSMGR
 	/* Check whether we're running under AUX. */
-	if (Gestalt(gestaltAUXVersion, &gestaltResult) == noErr	&& AUX_EnableCoffLaunch())
+	if (MyGestalt(gestaltAUXVersion, &gestaltResult) == noErr	&& AUX_EnableCoffLaunch())
 		AUXIsPresent = true;
 #endif HAS_AUX_PROCESSMGR
 	}

--- a/ProcessMgr/Switch.a
+++ b/ProcessMgr/Switch.a
@@ -9,17 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		 <8>	10/28/92	DTY		It turns out that going through the trap dispatcher is really
-;									expensive, so go back to calling the BlockMove routine directly.
-;									However, set up D1 with the BlockMoveData trap word so that the
-;									cache doesn’t get flushed.  Add a conditional compile so that
-;									_BlockMove is used when building PsychicTV, so the emulator can
-;									still catch BlockMove.
-;		 <7>	10/27/92	DTY		Call BlockMoveData through the dispatcher instead of calling the
-;									BlockMove routine directly.  This gets us two wins:  1)  If we
-;									run under Gary’s emulator, BlockMove is done natively.  2)  On
-;									68K machines, the cache won’t get flushed because we call
-;									BlockMoveData.
 ;		 <6>	 3/22/91	DFH		csd,#85216: Don’t disable interrupts while neutralizing VBL
 ;									tasks, because it leaves interrupts off too long. Instead, set
 ;									the inVBL bit to keep the vertical retrace code from messing
@@ -264,7 +253,7 @@ saveInfo
 				movea.l	saveArea(a1),a1					; get the handle
 				movea.l	(a1),a1							; (destination) get pointer heap block
 				movea.l	sp,a0							; (source) get pointer to stacked info
-				_BlockMoveData							; copy the data
+				_BlockMove								; copy the data
 
 ; cleanup up and leave
 leaveNow
@@ -287,8 +276,8 @@ dummyvbl		PROC	EXPORT
 ; save_lmemtab.  Copy the switchable lomem into a safe area.
 save_lmemtab	PROC	EXPORT
 				IMPORT	(switchTabPtr, blockTrapAddr):DATA
-SaveRegs		REG		a2-a4/d1-d2
-SaveRegSize		EQU		5*4
+SaveRegs		REG		a2-a4/d2
+SaveRegSize		EQU		4*4
 
 				movem.l	SaveRegs,-(sp)					; save work registers
 				move.l	SaveRegSize+4(sp),a4			; get pointer to PCB storage
@@ -339,21 +328,11 @@ SaveOneLoop
 				bra.s	SaveAllLoop						; now get next entry
 
 ; call _BlockMove, since it's faster for larger chunks
-;
-; <8> Going through the trap dispatcher is more expensive than I thought.  Go back
-;	to calling the BlockMove routine directly.  However, set up D1 so that the caches
-;	still don’t get flushed.  We still want to call the trap for PsychicTV however, so
-;	that the emulator can do it’s native BlockMove.
 
 UseBlockMove		
 				move.l	a4,a1							; a1 = destination
 				add.l	d0,a4							; update our storage address
-	if not(PsychicTV) then
-				move.w	#$A22E,d1						; <8>
 				jsr		(a3)
-	else
-				_BlockMove								; <8>
-	endif
 				
 				bra.s	SaveAllLoop						; now get next entry
 
@@ -368,8 +347,8 @@ AllSaved
 ; restore_lmemtab.  Copy the saved switchable lomem back into lomem.
 restore_lmemtab	PROC	EXPORT
 				IMPORT	(switchTabPtr, blockTrapAddr):DATA
-SaveRegs		REG		a2-a4/d1-d2
-SaveRegSize		EQU		5*4
+SaveRegs		REG		a2-a4/d2
+SaveRegSize		EQU		4*4
 
 				movem.l	SaveRegs,-(sp)					; save work registers
 				move.l	SaveRegSize+4(sp),a4			; get pointer to PCB storage
@@ -419,22 +398,11 @@ RestoreOneLoop
 				bra.s	RestoreAllLoop					; now get next entry
 		
 ; call _BlockMove, since it's faster for larger chunks
-;
-; <8> Going through the trap dispatcher is more expensive than I thought.  Go back
-;	to calling the BlockMove routine directly.  However, set up D1 so that the caches
-;	still don’t get flushed.  We still want to call the trap for PsychicTV however, so
-;	that the emulator can do it’s native BlockMove.
-;
 
 UseBlockMove		
 				move.l	a4,a0							; setup source pointer for blockmove
 				add		d0,a4							; and increment pointer by count
-	if not(PsychicTV) then
-				move.w	#$A22E,d1						; <8>
 				jsr		(a3)
-	else
-				_BlockMove								; <8>
-	endif
 				
 				bra.s	RestoreAllLoop					; now get next entry
 		

--- a/ProcessMgr/Switch.c
+++ b/ProcessMgr/Switch.c
@@ -10,7 +10,6 @@
 	Change History (most recent first):
 	 
 		<22>	10/28/92	DTY		Use new Get/Set macros to access ExpandMem.
-		<21>	10/27/92	DTY		Change BlockMoves to BlockMoveData.
 		<20>	 9/11/92	DRF		Take out “while(FSBUSY);” in “TheFuture” to allow for faster
 									switching.
 		<19>	 8/26/92	DTY		Roll in latest changes for A/UX.
@@ -374,7 +373,7 @@ save_lomem(PEntryPtr pp)
 	pc->appllimit = APPLLIMIT;
 	pc->applzone = APPLZONE;
 	pc->currenta5 = (unsigned long)CURRENTA5;
-	BlockMoveData(CURAPNAME, &pc->curapname, *((unsigned char *)CURAPNAME) + 1);
+	BlockMove(CURAPNAME, &pc->curapname, *((unsigned char *)CURAPNAME) + 1);
 	pc->curlayer = GetCurLayer();
 	pc->topmaphandle = TOPMAPHANDLE;
 	pc->curmap = CURMAP;
@@ -439,7 +438,7 @@ restore_lomem(PEntryPtr pp, Boolean shouldRestoreVolatile)
 	 */
 	APPLLIMIT = pc->appllimit;
 	CURRENTA5 = pc->currenta5;
-	BlockMoveData(&pc->curapname, CURAPNAME, Length(&(pc->curapname)) + 1);
+	BlockMove(&pc->curapname, CURAPNAME, Length(&(pc->curapname)) + 1);
 	SetCurLayer(pc->curlayer);
 	TOPMAPHANDLE = pc->topmaphandle;
 	CURMAP = pc->curmap;

--- a/ProcessMgr/WindowMgrPatches.c
+++ b/ProcessMgr/WindowMgrPatches.c
@@ -9,11 +9,6 @@
 
 	Change History (most recent first):
 
-		 <7>	11/15/92	JDR		Changed QuickDraw.h to not use the dangerous pattern, which
-									defines a pattern as a struct. This code was calling BlockMove
-									to copy the 8 byte pattern, but patterns are structs so Pattern
-									= Pattern works fine. I fixed the includes a bit too, and the
-									dependencies were wrong by the way so I fixed them as well.
 		 <6>	 5/19/92	YK		#1030028: Remove <4> and <5> since SWM is not an application
 									now.    Roll back to <3>.
 		 <5>	 1/14/92	YK		Added checking code for TSM. Removed the include statement that
@@ -26,6 +21,7 @@
 
 */
 
+#define dangerousPattern
 #include <QuickDraw.h>
 #include <Windows.h>
 #include <Resources.h>
@@ -71,7 +67,7 @@ c_initwindows(void)
 		DSWNDUPDATE |= ((char)0x80);
 
 		SetPort(WMGRPORT);
-		DESKPATTERN = **GetPattern(deskPatID);
+		BlockMove(*GetPattern(deskPatID), &DESKPATTERN, sizeof(Pattern));
 		ShowCursor();
 
 		olda5 = ProcessMgrA5SimpleSetup();

--- a/QuickDraw/BitBlt.a
+++ b/QuickDraw/BitBlt.a
@@ -10,14 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	 12/2/92	kc		Roll in CopyBits changes from QuickDrawPatches.a in Reality
-;	   <R24>	 10/2/92	SAH		Fixed a word alignment bug in the fast bSetup0 and bSetup8
-;									patches (word alignment would cause the Move16 code to fail).
-;									Also added a check in the bSetup8 patch to make sure that the
-;									left edge quadlong alignment would remain constant across
-;									scanlines.
-;	   <R23>	 10/1/92	SAH		Brought in fast bSetup8 patch for 040 machines that uses
-;									Move16's.
 ;	   <R20>	 4/10/92	SAH		Moved in the working fast bSetup0 patch for 68040 machines from
 ;									QDIIciPatchROM.a.
 ;	   <SM4>	 7/30/92	chp		Moved a short branch inside the conditional generated by <SM3>
@@ -1045,7 +1037,7 @@ LLast0	MOVE.L	D5,D1			;copy last mask
 ;-------------------------------------------------------
 bSETUP0
 
-OFFSET		EQU		38
+OFFSET		EQU		36
 
 		MOVE	SRCBUMP(A6),D6		;get srcwid into a register
 		MOVE	A3,D7				;put dstwid into a more useful register
@@ -1059,18 +1051,6 @@ OFFSET		EQU		38
 		CMP		#8,D2				;are at least 8 longs being moved?
 		BLT.S	@normal				;no, use normal case
 
-	; <02OCT92 SAH>		<24>
-	; we need to make sure that everything is long aligned. If srcPtr, dstPtr, srcWid or dstWid
-	; are word aligned, we need to go slow...
-
-		move.w	a4,d0				;get copy of src address				<02OCT92 SAH>		<24>
-		move.w	a5,d3				;get copy of dst address				<02OCT92 SAH>		<24>
-		or.w	d3,d0				;or in with src address					<02OCT92 SAH>		<24>
-		or.w	d6,d0				;or in srcWid							<02OCT92 SAH>		<24>
-		or.w	d7,d0				;or in dstWid							<02OCT92 SAH>		<24>
-		and.w	#3,d0				;and all four with long align mask		<02OCT92 SAH>		<24>
-		bne.s	@normal				;if any one is word aligned, go slow	<02OCT92 SAH>		<24>
-
 		MOVE	D2,D3				;are srcwid and dstwid both quadlong multiples?
 		LSL		#2,D3				;	((srcwid + (longs*4)) | (dstwid + (longs*4))) & 0x000F == 0)
 		MOVE	D6,D0
@@ -1154,7 +1134,6 @@ OFFSET		EQU		38
 		SUBQ.L	#1,D5				;++rightmask
 		MOVE.L	HEIGHT(A6),D1		;(put height into high word)
 		MOVE	D3,D1				;(set up initial quadblocks count)
-		nop							;finish any write in pipeline (may not need this one)
 		JMP		(A0)
 
 		MACRO						;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
@@ -1170,14 +1149,12 @@ OFFSET		EQU		38
 		AND.L	D4,D0				;splice src and dst together through leftmask
 		EOR.L	D2,D0				;
 		MOVE.L	D0,(A5)+			;save result to dst
-		nop							;finish any write in pipeline
 		JMP		(A1)				;go copy partial or full quadlong blocks
 
 		MOVE.L	(A4)+,(A5)+			;copy partial left quadlong block
 		MOVE.L	(A4)+,(A5)+
 		MOVE.L	(A4)+,(A5)+
-@left	nop							;finish any write in pipeline
-		JMP		(A2)				;go copy quadlong blocks
+@left	JMP		(A2)				;go copy quadlong blocks
 
 @mv256	myMOVE16			;MOVE16	(A4)+,(A5)+			;copy 32 longs
 		myMOVE16			;MOVE16	(A4)+,(A5)+
@@ -1225,7 +1202,6 @@ OFFSET		EQU		38
 		SUBQ	#1,D1				;decrement linecount
 		BEQ		GoHome				;leave if zero
 		SWAP	D1					;swap linecount out of low word
-		nop							;finish any write in pipeline
 		JMP		(A0)				;go do another line
 		
 		MOVE.L	(A4)+,(A5)+			;copy partial right quadlong block
@@ -1238,7 +1214,6 @@ OFFSET		EQU		38
 		SUBQ	#1,D1				;decrement linecount
 		BEQ.S	GoHome				;leave if zero
 		SWAP	D1					;swap linecount out of low word
-		nop							;finish any write in pipeline
 		JMP		(A0)				;go do another line
 
 		IF @right - @rmask - OFFSET THEN
@@ -1766,42 +1741,6 @@ bSETUP8		TST.B	alphaMode(A6)			;drawing in alpha mode?
 ; <13>	End of alpha channel changes
 
 @bSETUP8
-;
-;	<02OCT92 SAH>		<24>
-;	We first need to check if we can go fast. There are several conditions for this:
-;	1. At least 16 longs are being moved (otherwise slow case is faster)
-;	2. The destination address is long aligned (we cannot handle word aligned addresses).
-;	3. hBump is a long multiple (same reason as 3).
-;	4. The dst maintains the same quadlong phase across all scanlines
-;	5. The pattern is constant.
-;
-
-			cmp.w	#16,d2			; must have at least 16 to make fast case worthwhile (cond 1)
-			blt.s	@slowCase		; less, so go slow
-			
-			cmp.b	#cpu68040,cpuFlag	;is this an '040 or greater machine?
-			blt.s	@slowCase		; less, so go slow
-	
-			move.w	a5,d0			; get copy of dst address (cond 2 and 3)			<02OCT92 SAH>		<24>
-			move.w	a3,d3			; get copy of hBump									<02OCT92 SAH>		<24>
-			or.w	d3,d0			; or it in											<02OCT92 SAH>		<24>
-			and.w	#3,d0			; check if hBump and dst address are long aligned	<02OCT92 SAH>		<24>
-			bne.s	@slowCase		; either one is word aligned, so go slow			<02OCT92 SAH>		<24>
-			
-			move.w	a3,d3			; get a copy of the hBump (cond 4)					<02OCT92 SAH>		<24>
-			move.w	d2,d0			; get the number of longs to write					<02OCT92 SAH>		<24>
-			addq.w	#1,d0			; make it a one based count							<02OCT92 SAH>		<24>
-			lsl.w	#2,d0			; make it bytes										<02OCT92 SAH>		<24>
-			add.w	d0,d3			; add the number of bytes to write					<02OCT92 SAH>		<24>
-			and.w	#$f,d3			; is the quadlong phase the same?					<02OCT92 SAH>		<24>
-			bne.s	@slowCase		; no, so go slow									<02OCT92 SAH>		<24>
-
-			move.l	expat(a6),a0	; get start of expanded pattern (cond 5)
-			move.l	(a0),d4			; get first pattern long (d4 not used yet)
-			moveq	#15,d0			; get count
-@0			cmp.l	(a0)+,d4		; compare
-			dbne	d0,@0			; continue if still equal
-			beq		fastBSETUP8		; if == 0, then pattern is solid and we can go fast
 			
 @slowCase	move.w	d2,d3			; get count of longwords to move
 			move.l	d1,d4			; get copy of firstMask
@@ -1879,126 +1818,7 @@ bSETUP8		TST.B	alphaMode(A6)			;drawing in alpha mode?
 			add.w	d7,d7			; shift the pattern index
 			dbeq	d2,@rowLoop		; loop through all source rows
 			dbne	d2,@resetPat	; reset pattern and loop
-			bra.s	GoHome			; then quit
-
-;
-;	<25SEP92 SAH> Fast pattern case for constant patterns. Can only be installed on 040
-;	machines when VM is off.
-;
-;-------------------------------------------------------
-;		a0 = left block		d0 = scratch
-;		a1 = middle block	d1 = scratch
-;		a2 = right block	d2 = scratch
-;		a3 = middle src		d3 = blockCount
-;		a4 = hBump			d4 = firstMask
-;		a5 = dstPtr			d5 = lastMask
-;		a6 = locals			d6 = pattern data
-;		a7 = sp				d7 = stack offset / rowCount
-;-------------------------------------------------------
-			
-
-; macro for MOVE16	(A3)+,(A5)+	
-		MACRO						;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
-		aMOVE16						;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
-		DC.L $F623D000				;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
-		ENDM						;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
-
-fastBSETUP8	move.w	a3,a4			; put hBump in more consistant register
-			move.w	d2,d3			; get count of longwords to move
-			subq.w	#1,d3			; make one based count of number of middle longs
-			move.l	d1,d4			; get copy of firstMask
-			movea.l	expat(a6),a3	; get ptr to pattern table
-			move.l	(a3),d6			; get source long from pattern
-		
-		; find offset for left edge alignment
-			moveq	#0,d2			; init left count to zero
-			lea		@left,a0		; get end of left edge table
-			moveq	#4,d0			; figure out the number of left longs 4 - ((a5 + 4) & 0xf)
-			add.w	a5,d0			; (a5 + 4)
-			and.w	#$f,d0			; & 0xf
-			lsr.w	#2,d0			; convert to longs
-			beq.s	@leftAligned	; left is already aligned
-			moveq	#4,d1			;
-			sub.w	d0,d1			; 4 - ...
-			sub.w	d1,d3			; subtract the longs we do on the left edge
-			neg.w	d1				; we want to look backwards
-			lea		(a0,d1*2),a0	; get offset
-@leftAligned
-		
-		; find offset for right edge alignment
-			lea		@right,a2		; get end of right edge table
-			moveq	#3,d2			; get a mask for right edge count
-			and.w	d3,d2			; get the odd longs
-			neg.w	d2				; offset backwards
-			lea		(a2,d2.w*2),a2	; get start of blit
-		
-		; now figure out how much to move in the middle
-			lea		@blockLoopEnd,a1	; assume we have nothing to do
-			lsr.w	#2,d3			; each move16 moves 4 longs
-			moveq	#$3,d0			; get mask for first time through (each loop does 4 move16's)
-			and.w	d3,d0			; and find the number to do
-			neg.w	d0				; negate the count
-			lea		(a1,d0.w*4),a1	; offset back into table
-			lsr.w	#2,d3			; convert remaining longs to groups of four
-		
-		; now create our stack buffer for move16
-			move.w	sp,d0			; get copy of stack
-			and.w	#$f,d0			; get quadlong mask
-			add.w	#64,d0			; add 64 bytes for base table
-			move.w	d0,d7			; save how much we subtracted...
-			swap	d7				;	 in high word of d7
-			sub.w	d0,sp			; subtract room on stack
-			moveq	#7,d0			; we want to write 16 longs (we do two at a time)
-			move.l	sp,a3			; get start of table
-@0			move.l	d6,(a3)+		; fill table
-			move.l	d6,(a3)+		; fill table
-			dbra	d0,@0
-			
-			move.w	Height(a6),d7	; get row count
-			subq.w	#1,d7			; zero based for DBRA
-
-@rowLoop	move.w	d3,d2			; setup block loop counter (for move16)
-			move.l	sp,a3			; restore block base
-			move.l	(a5),d1			; get a long of dst
-			move.l	d6,d0			; get a long of src
-			eor.l	d1,d0			; 
-			and.l	d4,d0			; mask first long
-			eor.l	d1,d0			;
-			move.l	d0,(a5)+		; put result to dest
-			jmp		(a0)			; jumpt to start of left edge
-			
-			move.l	d6,(a5)+		; long 1
-			move.l	d6,(a5)+		; long 2
-			move.l	d6,(a5)+		; long 3
-@left		nop						; clear pipeline
-			jmp		(a1)			; jump into middle block
-			
-@blockLoop	aMOVE16		;	move16	(a3)+,(a5)+		; move 16 longs
-			aMOVE16		;	move16	(a3)+,(a5)+		; move 12 longs
-			aMOVE16		;	move16	(a3)+,(a5)+		; move 8 longs
-			aMOVE16		;	move16	(a3)+,(a5)+		; move 4 longs
-@blockLoopEnd
-			move.l	sp,a3			; restore block base
-			dbra	d2,@blockLoop	; move remaining blocks of 16 longs
-
-			jmp		(a2)			; jump into right edge block
-			
-			move.l	d6,(a5)+		; long 1
-			move.l	d6,(a5)+		; long 2
-			move.l	d6,(a5)+		; long 3
-@right			
-			move.l	d6,d0			; get a long of src
-			move.l	(a5),d1			; get a long of dst
-			eor.l	d1,d0			;
-			and.l	d5,d0			; splice with mask
-			eor.l	d1,d0			;
-			move.l	d0,(a5)+		; put result to dest
-
-			adda.w	a4,a5			; update dest address
-			dbra	d7,@rowLoop		; loop through all source rows
-			swap	d7				; get stack offset back
-			add.w	d7,sp			; restore stack
-			rts						; then quit
+			bra		GoHome			; then quit
 
 	ALIGN	Alignment
 
@@ -4334,11 +4154,8 @@ bTransparent
 ; rolled in SMC’s changes from QDciPatchROM.a <sm 6/9/92>stb
 
 		lea		@RealbTransparent1,a1		;										<26SEP90 SMC> <10>
-		tst.l	(sp)			;is bump amount negative?							<14AUG90 KON>
-		bmi.s	@1				;													<14AUG90 KON>
-		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?						<08Oct90 SMC> <72>
-		BEQ		bTransparent8				;										<08Oct90 SMC> <72>
-		BRA.S	@RealbTransparent1			;										<08Oct90 SMC> <72>
+		tst.w	(sp)			;is bump amount negative?							<14AUG90 KON>
+		bpl.s	@RealbTransparent1;													<14AUG90 KON>
 	@1:	sub.l	(SP),D6			;bump src right OR left by 1 pixel first time only	<14AUG90 KON>
 		lea		@RealbTransparent,a1	;remember correct entry point for remaining scans	<14AUG90 KON>
 @RealbTransparent

--- a/QuickDraw/CCrsrCore.a
+++ b/QuickDraw/CCrsrCore.a
@@ -12,9 +12,6 @@
 ;
 ;	   <SM6>	 9/12/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM5>	  2/4/93	CSS		Update from Horror:
-;		<H3>	 7/13/92	djw		<GED> Overpatched DrawCursor, EraseCursor and SetCrsrData,
-;									vectorizing them to allow access later.
 ;	   <SM4>	 6/11/92	stb		<sm 6/9/92>stb Add comments from QDciPatchROM.a to ShowCursor,
 ;									SetCCursor
 ;	   <SM3>	 5/16/92	kc		Add forRom conditionals around last change.
@@ -549,19 +546,18 @@ HideCursor
 		;Fall into EraseCursor
 
 ;________________________________________________________________________
-;	<SM5> CSS Horror vectorized this vector.  We are supporting this to be
-;   compatible with Horror.
-;	EraseCursor calls a vectorized version of the routine via lomem.
-;	EraseCursor is vectorized to gain access to low level cursor blit routines.
-;	(NOTE: Vector is initialized in StartInit.a to routine named VEraseCursor.)
-
 ; EraseCursor is much like HideCursor, but doesn't decrement the CrsrState	<dvb 19sep88>
 
+			IMPORT	UNBLITCURSOR
 EraseCursor
-		move.l	EraseCrsrVector,-(sp)			;<SM5> CSS
-		rts										;jump to the vectored routine <SM5> CSS
-DoneHid	CLR.B	CRSRBUSY						;CHANGE COMPLETE
-		RTS
+			MOVE.B	#1,CRSRBUSY 					;MARK CHANGE IN PROGRESS
+			TST.B	CRSRVIS 						;IS CURSOR VISIBLE?
+			BEQ.S	DoneHid							;NO, DON'T TRY TO REMOVE IT
+			
+			BSR		UNBLITCURSOR					;Zap Pixels
+
+DoneHid		CLR.B	CRSRBUSY						;CHANGE COMPLETE
+			RTS
 
 
 ;_______________________________________________________________________
@@ -607,20 +603,24 @@ ShowCursor
 		;fall into DrawCursor
 
 ;________________________________________________________________________
-;	<SM5> CSS Horror vectorized this vector.  We are supporting this to be
-;   compatible with Horror.
-;   DrawCursor calls a vectorized version of the routine via lomem.
-;	DrawCursor is vectorized to gain access to low level cursor blit routines.
-;	(NOTE: Vector is initialized in StartInit.a to routine named VDrawCursor.)
-
 ; DrawCursor is much like ShowCursor, but doesn't increment the CrsrState	<dvb 19sep88>
 
+			IMPORT	BLITCURSOR
 DrawCursor
-		move.l	DrawCrsrVector,-(sp)			; <SM5> CSS
-		rts										;jump to the vectored routine <SM5> CSS
+			MOVE.B	#1,CRSRBUSY 					;MARK CHANGE IN PROGRESS
+		
+			TST		CRSRSTATE
+			BMI.S	DoneSho							;QUIT IF STILL HIDDEN
+			CLR 	CRSRSTATE						;DON'T LET CRSRSTATE GET > 0
+			TST.B	CRSRVIS 						;IS CURSOR ALREADY VISIBLE?
+			BNE.S	DoneSho							;YES, DON'T TRY TO REDRAW
+			TST.B	CrsrObscure						;Skip if obscured
+			BNE.S	DoneSho
 
-DoneSho	CLR.B	CRSRBUSY						;CHANGE COMPLETE
-		RTS
+			BSR		BLITCURSOR						;Do the real work: put pixels up
+
+DoneSho		CLR.B	CRSRBUSY						;CHANGE COMPLETE
+			RTS
 
 ;_______________________________________________________________________
 ;
@@ -908,8 +908,6 @@ SetCrsrData		PROC	EXPORT
 ;  This routine is called to initialize low-memory locations
 ;  to the necessary values for the grafDevice pointer in A1.
 ;
-				IMPORT	SetCrsrDelay			;<SM5> CSS
-				bsr.l	SetCrsrDelay			;<SM5> CSS
 				MOVE.L	CRSRPTR,A0				;get handle to cursor data
 				MOVE.L	(A0),A0					;get pointer to cursor data
 

--- a/QuickDraw/ColorMgr.a
+++ b/QuickDraw/ColorMgr.a
@@ -5,19 +5,9 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM9>	11/29/93	SAM		Yet another getCTable mod.  Move the handle to the clut copy
-;									into A0 prior to the seed range check.
 ;	   <SM8>	 11/7/93	SAM		Changed GetCTable to get a new seed if the id > 1023 (kMinSeed).
-;	   <SM7>	 9/29/93	SAM		From mc900ftjesus
-;	   <MC4>	 9/27/93	SAM		Rewrote the guts of GetCTable.  The result of calling GetCtable
-;									is a Handle to a ram based copy of the clut (whether its in ROM
-;									or not).  It no longer requires that you have 2x sixeof(clut)
-;									heap space. Made GetCTable not set ctSeed if the ct ID is ≤ 8.
 ;	   <SM6>	 9/13/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM5>	  3/3/93	PN		Fix the rGetResource in MakeITable by adjusting the CurMap to
-;									point to SysMap before calling rGetResource. Roll in patch
-;									StartRGetResourceFromSystemMapFormitqResources
 ;	   <SM4>	 1/21/93	KW		(LW3 fau) Rolled in the MySaveEntries patch:  In SaveEntries, if
 ;									the bpp is ≥ 16bpp it will exit with an error, but the code was
 ;									not returning the stack to it's correct state.  Renamed all the
@@ -418,10 +408,6 @@ AdjZone
 
 		move.w		#0,isTmpHandle(a6)	;assume handles are not in temp memory	<28Feb90 KON>
 
-; Here is the fix for rGetResource from ResourceMgrPatches.a
-		move.w	CurMap,-(sp)			; Save the current resource map. <SM5>
-		move.w	SysMap,CurMap			; <27> Start searching from the System file instead of the top <SM5>	
-
 ; allocate space on the heap for the queue, reading queue size from resource
 
 		SUBQ		#4,SP				; make room for the function return		<C835/20Feb87> DAF
@@ -430,8 +416,6 @@ AdjZone
 		_rGetResource					; system first, then ROM				<C835/20Feb87> DAF
 		MOVE.L		(SP)+,A0			; get the handle						<C835/20Feb87> DAF
 	
-		move.w		(sp)+,CurMap		; Restore the current resource map <SM5>
-		
 		MOVE.L		(A0),A0				; get the pointer in A0					<C835/20Feb87> DAF
 		MOVE.L		-12(A0,D7*4),D0		; get the queue size (adjust for no 1 or 2 bit resolutions) <C835/20Feb87> DAF
 		MOVE.L		D0,D3				; hold it for a second
@@ -2651,49 +2635,40 @@ notRes			MOVE	4(SP),D0				; Get requested ID
 				BRA.S	RTD2
 
 
-readIt			MOVEM.L	D6/D7,-(SP)				; Save some work registers					<SAM 27SEP93>
-				MOVE.W	#mapTrue,ROMMapInsert	; Put the ROM map at the lend of the list
-				SUBQ	#4,A7					; space for result
+readIt			SUBQ	#4,A7					; space for result
 				MOVE.L	#'clut',-(SP)			; resource type
-				MOVE	20(SP),-(SP)			; push ID number
+				MOVE	12(SP),-(SP)			; push ID number
 				_GetResource					; Get it.
-				MOVE.L	(SP)+,D7				; Did we get the resource?
-				BEQ.S	@readFail				; -> Nope, Clear A0 and exit.
+				MOVE.L	(SP)+,D0				; Did we get the resource?
+				BEQ.S	@otherThing
 
-				MOVE.L	D7,-(SP)				; Push the Resource Handle
+				MOVE.L	D0,-(SP)				; Push the Resource Handle
+				MOVE.L	D0,-(SP)				; Push the Resource Handle
 				_DetachResource					; Free it from the Map
+				MOVE.L	(SP)+,A0
+				_HNoPurge
+
+				MOVE.L	(A0),A1
+				SUBQ	#4,SP
+				_rGetCTSeed
+				MOVE.L	(SP)+,(A1)
 
-				MOVE.L	D7,D6					; Put the orig in D6
-				MOVE.L	D7,A0					; Get the handle in A0
-				MOVE.L	D7,A1					; Get the handle in A1
-				
-				MOVE.L	(A1),A1					; Get the ptr
-				CMP.L	ROMBase,A1				; Is the clut in ROM?
-				BLO.S	@SetTheSeed				; -> No. Its in RAM. Set the seed and leave
-				
-				_HandToHand						; Make a copy in a new handle in RAM
-				MOVE.L	A0,D6					; Save the copy in D6
-												
-				MOVE.L	D7,A0					; Get the resource handle in A0
-				_DisposHandle					; Free the ROM handle
-				
-				MOVE.L	D6,A0					; Move the copy into A0						<SM9>
-				TST.L	D6						; Did we get the copy?
-				BEQ.S	@ReadFail				; -> No. Clear A0 and exit
-				
-@SetTheSeed		CMPI.W	#1023,18(SP)			; Is this a request for a system clut?		<MC4><MC5>
-				BLS.S	@done					; -> Yes, leave the seed alone!				<MC4>
-				
-				CLR.L	-(SP)					; make room for function return
-				_rGetCTSeed						; get the next seed and leave it on the stack
-				MOVE.L	D6,A0					; Get the copy in A0
-				MOVE.L	(SP)+,([A0],ctSeed)		; Set the Seed in the copy
-				
-				_HNoPurge						; Make sure it doesn't go away
 				BRA.S	@Done					; -> Got It!
 
+@otherThing
+				MOVE	#$FFFF,RomMapInsert
+				SUBQ	#4,SP
+				MOVE.L	#'clut',-(SP)
+				MOVE	12(SP),-(SP)
+				_GetResource
+				MOVE.L	(SP)+,D0
+				BEQ.S	@readFail
+
+				MOVE.L	D0,A0
+				_HandToHand
+				BEQ.S	@done
+
 @readFail		SUBA.L	A0,A0					; A miserable failure.
-@done			MOVEM.L	(SP)+,D6/D7				; Restore the work registers
-				RTD		#2						; Lose ID, and go home.
+@done			RTD		#2						; Lose ID, and go home.
 
 

--- a/QuickDraw/FastTraps.a
+++ b/QuickDraw/FastTraps.a
@@ -7,10 +7,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	 10/6/93	SAM		The QDExtensions macros were not setting the upper word of the
-;									selector (what contains the param count for each routine).  This
-;									confused the native dispatcher.  The macros have been updated to
-;									contain the full longword of info in D0.
 ;	   <SM4>	 10/13/92	CSS		Nop calls if the machine doesn't support 24 bit mode
 ;									(SwapMMUMode and StripAddress).
 ;		 <8>	 7/26/92	DTY		Add fast traps for DeviceLoop and GetGray to get the ROM
@@ -1098,115 +1094,115 @@ selectGetGray			equ		25
 		
 				MACRO
 				_NewGWorld
-				MOVE.L	#$160000,D0
+				MOVEQ	#$0,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_LockPixels
-				MOVE.L	#$40001,D0
+				MOVEQ	#$1,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_UnlockPixels
-				MOVE.L	#$40002,D0
+				MOVEQ	#$2,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_UpdateGWorld
-				MOVE.L	#$160003,D0
+				MOVEQ	#$3,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_DisposeGWorld
-				MOVE.L	#$40004,D0
+				MOVEQ	#$4,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_GetGWorld
-				MOVE.L	#$80005,D0
+				MOVEQ	#$5,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_SetGWorld
-				MOVE.L	#$80006,D0
+				MOVEQ	#$6,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_CTabChanged
-				MOVE.L	#$40007,D0
+				MOVEQ	#$7,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_PixPatChanged
-				MOVE.L	#$40008,D0
+				MOVEQ	#$8,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_PortChanged
-				MOVE.L	#$40009,D0
+				MOVEQ	#$9,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_GDeviceChanged
-				MOVE.L	#$4000A,D0
+				MOVEQ	#$A,D0
 				_QDExtensions
 				ENDM
 		
 				MACRO
 				_AllowPurgePixels
-				MOVE.L	#$4000B,D0
+				MOVEQ	#$B,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_NoPurgePixels
-				MOVE.L	#$4000C,D0
+				MOVEQ	#$C,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_GetPixelsState
-				MOVE.L	#$4000D,D0
+				MOVEQ	#$D,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_SetPixelsState
-				MOVE.L	#$8000E,D0
+				MOVEQ	#$E,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_GetPixBaseAddr
-				MOVE.L	#$4000F,D0
+				MOVEQ	#$F,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_NewScreenBuffer
-				MOVE.L	#$E0010,D0
+				MOVEQ	#$10,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_DisposeScreenBuffer
-				MOVE.L	#$40011,D0
+				MOVEQ	#$11,D0
 				_QDExtensions
 				ENDM
 		
 				MACRO
 				_GetGWorldDevice
-				MOVE.L	#$40012,D0
+				MOVEQ	#$12,D0
 				_QDExtensions
 				ENDM
 		
@@ -1214,7 +1210,7 @@ selectGetGray			equ		25
 		
 				MACRO
 				_QDDone
-				MOVE.L	#$40013,D0
+				MOVEQ	#$13,D0
 				_QDExtensions
 				ENDM
 		

--- a/QuickDraw/GDevice.a
+++ b/QuickDraw/GDevice.a
@@ -13,12 +13,6 @@
 ;									devices.
 ;	   <SM4>	  4/8/93	IH		Add some comments on Display Manager assumptions about
 ;									InitGDevice to InitGDevice header.
-;	   <SM3>	  2/4/93	CSS		Update from Horror:
-;		<H2>	 7/10/92	SWC		Made a change to GetDevPixMap to fix a problem with fixed
-;									devices. It was generating a new ctSeed unconditionally, which
-;									caused problems with the IconUtilities package since the Palette
-;									Manager would say that the tolerance between the device's and
-;									system CLUTs wasn't close enough to draw a multi-bit icon.
 ;	   <SM2>	 6/11/92	stb		<sm 6/9/92>stb Synched with QDciPatchROM.a, added comments to
 ;									DisposGDevice and InitGDevice.
 ;		 <8>	 7/24/90	gbm		get rid of stupid branch
@@ -782,17 +776,11 @@ GetFromSlot	MOVE.B	#mTable,spID(A0)			; the fixed table							<2.3>
 			MOVE.L	A1,spResult(A0)				; put handle in destination					<2.3>
 			_sReadStruct						; read the table from the ROM				<2.3>
 
-;••• <SM3> CSS rollin patch GetDevPixMapPatch from horror
-			MOVE.L	ctSeed(A1),D0				; get the current seed						<H2>
-			BEQ.S	@GetNewSeed					; -> it's zero, so generate a new one		<H2>
-			CMPI.L	#minSeed,D0					; is it a resource ID?						<H2>
-			BLE.S	@UseOriginalSeed			; -> yes, assume we know what we're doing	<H2>
 @GetNewSeed	SUBQ	#4,SP						; make room for function result				<2.3>
 			_rGetCTSeed							; get a new, unique ctable seed				<2.3>
 			MOVE.L	(SP)+,ctSeed(A1)			; put in the new seed						<2.3>
 @UseOriginalSeed
 												;   transindex/ctflags set below			<2.3>
-;••• <SM3> CSS end rollin GetDevPixMapPatch from Horror
 
 			MOVE.L	A4,spsPointer(A0)			; Restore the pointer to mode list.			<C742>
 			bra.s	TableOK

--- a/QuickDraw/GWorld.a
+++ b/QuickDraw/GWorld.a
@@ -7,9 +7,6 @@
 ;
 ;	   <SM5>	 9/12/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM4>	 6/14/93	kc		Roll in Ludwig.
-;	   <LW2>	 3/25/93	fau		Made the NewGWorld call allocate a buffer whose width is a whole
-;									number of quadwords, in order to help digitizer grabs.
 ;	   <SM3>	10/28/92	SWC		Replaced obsolete INCLUDEd filenames with their replacements.
 ;	   <SM2>	 6/11/92	stb		<sm 6/9/92>stb Synch with QDciPatchROM.a; added comments to
 ;									NewGWorld, UpdateGWorld, Pixmap32Bit, GetGWorldPixMap,
@@ -900,12 +897,6 @@ allocateBuffer
 		addq	#1,d0						; add one long as per simplified formula above
 		lsl.l	#2,d0						; convert longs to bytes
 
-; Make buffer's width quad longword aligned on both ends.  This will help when doing 
-; video digitizer grabs on Cyclone.
-
-		addi.l	#15,d0						; Add 15 bytes to make it to the next quad-w boundary 	<LW2>fau
-		andi.b	#$f0,d0						; Chop the remainder									<LW2>fau
-		
 		move	d0,bytesPerRow(a6)			; save # of bytes in a row
 
 		move	localRect+bottom(a6),d1		; compute height of rectangle

--- a/QuickDraw/PaletteMgr.a
+++ b/QuickDraw/PaletteMgr.a
@@ -9,18 +9,9 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM11>	10/28/93	SAH		Rolled out change SM9 because it brought out bugs in the font
-;									manager. Rolled out change 14 because it caused the bug that
-;									caused change SM9. Both of these are correct changes, we just
-;									need to take them out until FlushFonts really flushes ALL the
-;									fonts (for all processes)...
 ;	  <SM10>	10-19-93	jmp		Removed the ctSeed whacking (Kon explained the error of my
 ;									ways).  We’ll have to come up with some other method to fix
 ;									dimming.
-;	   <SM9>	 9/20/93	SAH		Fixed a bug in ActivatePalette where it would always mark black
-;									or white tolerant entries as handled. It really needed to make
-;									sure they weren't explicit as well.
-;	   <SM8>	 9/13/93	SAM		Added a "code" to PMExit to call _TrashProcess (HeapUtilities).
 ;	   <SM7>	08-03-93	jmp		Changed the SetDepth code so that the MenuBar gets redrawn first
 ;									after a depth switch.  This is the way the pre-System7 Monitors
 ;									'cdev' did things.  And it looks much nicer.
@@ -622,17 +613,6 @@ linkSize	DS.B		0						; linky number
 			WITH	PXVars
 			LINK	A6,#linkSize
 
-			movem.l	a0-a2/d0-d2,-(sp)		; Those pesky c routines					<mc8>
-			sub.l	a0,a0					; Pass the current process (0)
-			move.w	#12,d0					; _TrashProcess
-			;_FigmentDispatch				; let everyone know this stuff is gone
-			dc.w	$A0A4
-			movem.l	(sp)+,a0-a2/d0-d2		; Restore em
-
-		IF (forRom OR theFuture) THEN
-			MOVE.l	WindowList,wList(A6)	; <SM2> FM save the current window list
-		ENDIF
-		
 			TST.B	QDExist					; if InitGraf has not been called yet…
 			BNE.S	@doNothing				; (a5) not valid and there is nothing to do
 			CMP.L	#PMgrNil,PMgrHandle		; If the palette manager doesnt exist...
@@ -667,7 +647,7 @@ linkSize	DS.B		0						; linky number
 			JSR		CheckAllDeviceCluts		; A pretty simple patch, really.
 			CLR		-(SP)					; No Setentries on Scatter
 			JSR		ScatterDevices
-			BSR		CheckForJuggler			; Is Jugglertm active?
+			BSR.S	CheckForJuggler			; Is Jugglertm active?
 			BNE.S	@doNothing				; No=>WMgr is void, next line dangerous
 			JSR		UpdateDevices
 			MOVE.L	mainDevice,theGDevice
@@ -1243,14 +1223,7 @@ Correlate	PROC	EXPORT
 			MOVE.L	(A3),A3					; A3-> device colortable
 			CLR.L	D3						; Clear the upper bits, for BF ops
 ExplLoop	MOVE	ciUsage(A2),D7			; D7 = usage of this entry
-	if 0 then
-		; <SAH 28OCT93>
-		; I'm taking this code out for now. It causes us to not add entries that we used to add. This code
-		; is not installed for IIci ROMs. It only began being installed for SuperMario. By taking it out we
-		; bring the palette manager back to the Quadra Rom but bring back a bug with tolerant+explicit+
-		; inhibited...
 			BMI.S	ExplLoopEnd				; Already handled?
-	endif
 			BTST	#TolerantBit,D7			; A Tolerator?
 			BEQ.S	ExplLoopEnd				; No, try next
 			BTST	#ExplicitBit,D7			; Explicit Tolerator?
@@ -4631,7 +4604,7 @@ linkSize	DS.B		0							; size of record
 			WITH		SDVars
 			
 			LINK		A6,#linkSize
-			MOVEM.L		A2-A3/D3-D5,-(SP)			;												<6>
+			MOVEM.L		A2/D3-D5,-(SP)				;												<6>
 
 			MOVE		#paramErr,result(A6) ; default to failure!
 
@@ -4660,11 +4633,7 @@ linkSize	DS.B		0							; size of record
 			MOVE		(SP)+,D4					; did we find one?
 			BEQ			@goHome
 
-@gotMode	Movea.l		gd(A6),A2					; Get GDHandle into A2.
-			Movea.l		(A2),A2						; Get a GDPtr into A2.
-			Btst		#mainScreen,gdFlags(A2)		; If we’re not on the menubar screen,
-			Beq.s		@NotMain1					;	then just keep going.
-			Move.w		theMenu,D5					; Get the currently hilited menuID.
+@gotMode	Move.w		theMenu,D5					; Get the currently hilited menuID.
 			Clr.w		-(Sp)						; And unhilite it.
 			_HiliteMenu
 @NotMain1
@@ -4687,12 +4656,8 @@ linkSize	DS.B		0							; size of record
 			MOVE.L		gd(A6),-(SP)				; push the handle
 			_InitGDevice
 
-			Btst		#mainScreen,gdFlags(A2)		; If we’re not on the menubar screen,
-			Beq.s		@NotMain2					;	then just keep going.
 			Move.w		D5,-(Sp)					; Get the hilite state.
 			_HiliteMenu								; Restore it.
-			_DrawMenuBar							; Draw the MenuBar.
-@NotMain2
 
 			CLR.L		-(SP)						; Activate the front palette
 			_FrontWindow							; before drawing anything.

--- a/QuickDraw/Patches/DrawPicture32Patch.a
+++ b/QuickDraw/Patches/DrawPicture32Patch.a
@@ -470,6 +470,139 @@ FixStdGetPicInGetPicData	INSTALLPROC		(Plus)
 		move.w	#PStdGetPic_Plus,(a0)			;jam in the correct vector for the Mac. Plus
 		rts
 
+		; ugly temporary
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+		nop
+
+
 		ENDPROC
 
 GETUBYTE	FUNC	EXPORT

--- a/QuickDraw/Patches/DrawPicturePortable.a
+++ b/QuickDraw/Patches/DrawPicturePortable.a
@@ -1861,5 +1861,1318 @@ ABORT	jmpROM	RomAbort						; Jump into ROM
 DONE	jmpROM	RomDone							; Jump into ROM
 		ENDIF
 
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
 		ENDPROC
 

--- a/QuickDraw/Patterns.a
+++ b/QuickDraw/Patterns.a
@@ -12,8 +12,6 @@
 ;
 ;	   <SM8>	 9/12/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM7>	 1/15/93	kc		Change JSR to JMP to fix bug introduced in last checkin.
-;	   <SM6>	 1/13/93	kc		Change BSR ot JSR to appease the Linker gods.
 ;	   <SM4>	 8/18/92	CSS		Update from Reality:
 ;									<16> 8/18/92 SAH	#1040323 <KON>: Fixed Indexed SeedCFill bug by making
 ;														MakeScaleTbl check to see if fg color is black and bg color is
@@ -119,7 +117,7 @@ GetCCursor	PROC	EXPORT
 			MOVE	4(SP),D0				; get the cursor's resource ID
 			MOVE.L	#'crsr',D1				; get the desired resource type
 			MOVEQ	#CRSRRec,D2				; get size of cursor record
-			JMP		PATSHARE
+			BRA.S	PATSHARE
 			NOP								; silence the assembler <13>
 
 

--- a/QuickDraw/Pictures.a
+++ b/QuickDraw/Pictures.a
@@ -14,11 +14,6 @@
 ;									DrawPicture, XTXFONT, TXRATIO, AddFontToTbl, LineLayout,
 ;									GlyphState, BITSOP, tryBands, PutPicVerb, UpdatePat, DONEW,
 ;									NEWPP, PutPicPixPat, PutDirectPMData.
-;	   <SM2>	 4/15/92	RB		Rolled in patch to DrawPicture from QuickDrawPatches.a. Save and
-;									restore global info so DrawPicture is reentrant. Do not draw
-;									purged Picture Handles and mark Handles non purgeable before
-;									doing the DrawPicture. This fixes bugs in balloon help while
-;									printing, and a bug in ResEdit while printing in the background.
 ;		<43>	 10/2/91	DTY		Conditionalise last change for TheFuture.
 ;		<42>	 10/1/91	KON		Bail on picture playback if StdGetPic an AbortPicPlayBackErr.
 ;		<41>	 7/10/91	JSM		Remove obsolete SysVers conditional.
@@ -980,31 +975,16 @@ saveOutline		equ		saveQdChExtra-1			;Byte
 savePreserve	equ		saveOutline-1			;Byte
 saveFractional	equ		savePreserve-1			;Byte
 saveUnscaled	equ		saveFractional-1		;Byte
-SavePatAlign	EQU 	saveUnscaled-4			; 							<SM2> rb
-SavePlayPic		EQU 	SavePatAlign-4			; 							<SM2> rb
-SavePlayIndex	equ		SavePlayPic-4			; 							<SM2> rb
-SaveHandleState	equ		SavePlayIndex-2			; 							<SM2> rb
-VARSIZE 		EQU 	SaveHandleState			;TOTAL BYTES OF LOCALS 		<SM2> rb
+VARSIZE 		EQU 	saveUnscaled			;TOTAL BYTES OF LOCALS
 
 
 		LINK	A6,#VARSIZE 					;ALLOCATE LOCALS
 		MOVEM.L D3-D7/A2-A4,-(SP)				;SAVE REGISTERS
 		MOVE.L	GRAFGLOBALS(A5),A4				;POINT TO QUICKDRAW GLOBALS
 		MOVE.L	THEPORT(A4),A3					;POINT TO CURRENT GRAFPORT
-		MOVE.L	MYPICTURE(A6),D0				;IS PICHANDLE NIL ?						<SM2> rb
+
+		TST.L	MYPICTURE(A6)					;IS PICHANDLE NIL ?						<SM2> rb
 		BEQ 	GOHOME							;YES, QUIT
-		MOVE.L  D0,A0							; put handle in a0						<SM2> rb
-		MOVE.L 	(A0),D0							; has the handle been purged ?			<SM2> rb
-		BEQ		GOHOME							; if so, then skip drawing picture		<SM2> rb
-
-; remember some state so we can go re-entrant
-		_HGetState								; get the handle's state				<SM2> rb
-		MOVE.B	D0,SaveHandleState(A6)			; and save it, so it can be restored	<SM2> rb
-		_HNoPurge								; make picture handle unpurgeable		<SM2> rb
-
-		MOVE.L	PATALIGN(A4),SavePatAlign(A6)	; save this baby...						<SM2> rb
-		MOVE.L	PLAYPIC(A4),SavePlayPic(A6)		; and his baby brother					<SM2> rb
-		MOVE.L	PLAYINDEX(A4),SavePlayIndex(A6)	; and his big sister					<SM2> rb
 
 ;--------------------------------------------------
 ;
@@ -1318,13 +1298,9 @@ DONELP	MOVE.W	(A0)+,(A3)+ 					;COPY A WORD INTO THEPORT
 ;
 ;  RESTORE GLOBAL VARS AND QUIT
 ;
-		MOVE.L	SavePatAlign(A6),PATALIGN(A4)	; Restore PATALIGN						<SM2> rb
-		MOVE.L	SavePlayPic(A6),PLAYPIC(A4) 	; Restore PLAYPIC 						<SM2> rb
-		MOVE.L	SavePlayIndex(A6),PLAYINDEX(A4)	; And PLAYINDEX							<SM2> rb
-
-		MOVE.B	SavehandleState(A6),D0			; get saved pic handle state 			<SM2> rb
-		MOVE.L	MyPicture(A6),A0				; get pic handle in a0 again 			<SM2> rb
-		_HSetState								; and restore the handle's properties 	<SM2> rb
+		CLR.L	PATALIGN(A4)
+		CLR.L	PLAYPIC(A4)
+		CLR.L	PLAYINDEX(A4)
 
 GOHOME	MOVEM.L (SP)+,D3-D7/A2-A4				;RESTORE REGISTERS
 		UNLINK	PARAMSIZE,'DRAWPICT'

--- a/QuickDraw/QD.a
+++ b/QuickDraw/QD.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 9/12/93	SAM		Added "NOT forROM" around the code that implements
-;									_Translate24to32.  SuperMario is a 32-bit only ROM.
 ;		<19>	 8/30/91	DTY		Define hasCQD since we took it out of BBSStartup.  QuickDraw
 ;									used to use {Defs32}, so hasCQD needs to be true as it was in
 ;									that case.
@@ -131,6 +129,7 @@ WholeErrors 	EQU 1
 			INCLUDE		'qdHooks.a'
 			INCLUDE 	'fontPrivate.a'
 				 
+			INCLUDE		'CrsrDevEqu.a'
 			INCLUDE 	'colorequ.a'
 			INCLUDE		'SlotMgrEqu.a'
 			INCLUDE		'ROMEqu.a'
@@ -410,7 +409,6 @@ FastStart	PROC	EXPORT
 			; to override.
 
 			; Does the Translate24To32 dispatch trap exist?
-	IF NOT forROM THEN							; SuperMario is a 32-bit only ROM.
 			MOVE.W	#$A091, D0					; Translate24To32 Trap number
 			_GetTrapAddress ,NewOS				; get the address of Translate24To32
 			MOVEA.L	A0, A1						; Hold it for a sec
@@ -424,7 +422,6 @@ FastStart	PROC	EXPORT
 			ADD.L	A4,a0					; really get the actual address
 			_SetTrapAddress ,newOS	
 @skip		
-	ENDIF
 			lea		$4081c11c,a0			;point to copyright notice in rom78
 			move.l	a0,d7					;make a copy
 			

--- a/QuickDraw/QDHooks.a
+++ b/QuickDraw/QDHooks.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 9/12/93	SAM		Removed rSwapMMUMode and rTranslate24to32 from the ROM build
-;									(SuperMario is a 32-bit mode only ROM).
 ;		 <5>	11/26/90	SMC		Added more macros for alpha channel bug fixes.  With BAL.
 ;		 <4>	10/31/90	SMC		Added macros for alpha channel bug fixes.
 ;		 <3>	 6/20/90	CL		Moving the rswapmmumode macro from CQD.a into this file so it
@@ -30,27 +28,15 @@
 CPU		EQU		$020
 	ENDIF
 
-	IF forROM THEN						; <SM2>
-		MACRO
-		_rSwapMMUMode
-		ENDM
-	ELSE
 		MACRO
 		_rSwapMMUMode
 		JSR		([$400+$5d*4])
 		ENDM
-	ENDIF
 
-	IF forROM THEN						; <SM2>
-		MACRO
-		_rTranslate24To32
-		ENDM
-	ELSE
 		MACRO
 		_rTranslate24To32
 		JSR		([$400+$91*4])
 		ENDM
-	ENDIF
 	
 		MACRO
 		_BitBlt

--- a/QuickDraw/QDUtil.a
+++ b/QuickDraw/QDUtil.a
@@ -11,9 +11,6 @@
 ;	   <SM7>	 9/12/93	joe		seperately conditionalize out ElsieTranslate24To32.
 ;	   <SM6>	 9/12/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM5>	 1/26/93	kc		Fix bug in GetAlphaMask. (renamed mask to alphaMask to avoid
-;									name collision)
-;	   <SM4>	 1/25/93	kc		Roll in Shannon Holland's alpha channel stuff.
 ;	   <SM3>	 7/16/92	CSS		Update from Reality:
 ;	   <R21>	 6/8/92		SAH		#1031825: Changed ColorMap to ignore the multColor flag.
 ;	   <SM2>	 6/11/92	stb		<sm 6/9/92>stb Synch with QDciPatch.a; added comments to
@@ -128,24 +125,6 @@
 ;  22Jan89	BAL		Altered DrawSlab loops to use patVPos as a long.
 
 
-;																	; <SM4>.start
-; Macros to set the alpha channel mask.
-; These will be moved into an interface file as soon as
-; the High Level API for manipulating the alpha channel is complete.
-;
-		MACRO
-		_GetForeAlphaMask
-		MOVE.W	#$0F,d0
-		JSR		([$E00+$3C0*4])
-		ENDM
-
-		MACRO
-		_GetBackAlphaMask
-		MOVE.W	#$10,d0
-		JSR		([$E00+$3C0*4])
-		ENDM															; <SM4>.end
-
-
 VisRgnChanged	PROC	EXPORT				;<26MAR90 KON>
 ;-----------------------------------------------------------
 ;
@@ -569,7 +548,7 @@ VARSIZE			EQU		0					;SIZE OF LOCALS
 		BPL		@noalpha					;yes, alpha mode is illegal
 		MOVE.W	dstPix+pixelSize(A6),D0		;get depth of destination
 		CMP.W	#16,D0						;direct device?
-		BLT		@noalpha					;no, skip this stuff											; <SM4>
+		BLT.S	@noalpha					;no, skip this stuff											; <SM4>
 		MOVE.L	grafVars(A2),D4				;get grafvars handle
 		BEQ		@noalpha					;no grafvars, no alpha
 		MOVE.L	D4,A0						;copy handle
@@ -577,16 +556,13 @@ VARSIZE			EQU		0					;SIZE OF LOCALS
 		BTST	#PmNewGVBit-8,pmFlags(A1)	;make sure grafvars have been expanded
 		BEQ.S	@noalpha					;if not, bail
 		MOVE.B	streamMode(A1),alphaMode(A6);save alpha mode in stack frame
-		SUB		#18,SP						;make room on stack for results and first error					; <SM4>.start
-		move.l	a0,-(sp)					;push GrafVars handle											
-		PEA		14(SP)						;push pointer to where we want results for background stream	
-		subq	#2,sp						;room for error													
-		move.l	a0,-(sp)					;push GrafVars handle											
-		PEA		16(SP)						;push pointer to where we want results for foreground stream	
-		_GetForeAlphaMask					;get foreground stream and ratio								
-		addq	#2,sp						;clear error													
-		_GetBackAlphaMask					;get background stream and ratio								
-		addq	#2,sp						;clear error													; <SM4>.end
+		SUB		#16,SP						;make room on stack for results and first error					; <SM4>.start
+		PEA		backStream(A1)
+		PEA		12(SP)
+		PEA		foreStream(A1)
+		PEA		12(SP)
+		_StreamToMask
+		_StreamToMask
 		MOVE.L	(SP)+,D0					;get alpha mask
 		MOVE.L	(SP)+,D4					;get alpha fore color
 		CMP.W	#srcXor,D5					;are we xoring?
@@ -955,12 +931,6 @@ xrgbGray	DC.W	$7FFF,$7FFF,$7FFF		;GRAY
 AlphaDispatch	PROC	EXPORT
 
 		IMPORT	RSetHSize
-		IMPORT	SetForeAlpha												; <SM4>.start
-		IMPORT	SetBackAlpha
-		IMPORT	GetForeAlpha
-		IMPORT	GetBackAlpha
-		IMPORT	GetForeAlphaMask
-		IMPORT	GetBackAlphaMask											; <SM4>.end
 
 		JMP		@dispatch(PC,D0.W*4)
 @dispatch
@@ -975,12 +945,6 @@ AlphaDispatch	PROC	EXPORT
 		BRA.W	GetBackTransparency
 		BRA.W	ResizeGrafVars
 		BRA.W	GetStreamMode
-		BRA.W	SetForeAlpha												; <SM4>.start
-		BRA.W	SetBackAlpha
-		BRA.W	GetForeAlpha
-		BRA.W	GetBackAlpha
-		BRA.W	GetForeAlphaMask
-		BRA.W	GetBackAlphaMask											; <SM4>.end
 
 ;
 ; FUNCTION AlphaVersion:INTEGER;
@@ -1180,181 +1144,6 @@ StreamToMask PROC EXPORT
 		RTD		#8
 
 
-;																													; <SM4>.start
-; FUNCTION SetForeAlpha(type: LONG; value: INTEGER) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): unsigned short alpha value
-;	(on stack): long alpha type
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-
-SetForeAlpha PROC EXPORT
-
-alpha		EQU		4						;[unsigned word] alpha value
-type		EQU		alpha+2					;[long] alpha type
-error		EQU		type+4					;[word] OSErr result
-paramSize	EQU		type					;size of parameters
-
-		clr.w	error(sp)					;clear error result
-		move.w	alpha(sp),-(sp)				;push alpha value
-		_SetForeTransparency				;set the foreground transparency
-		RTD		#paramSize
-		
-		
-;
-; FUNCTION SetBackAlpha(type: LONG; value: INTEGER) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): unsigned short alpha value
-;	(on stack): long alpha type
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-
-SetBackAlpha PROC EXPORT
-
-alpha		EQU		4						;[unsigned word] alpha value
-type		EQU		alpha+2					;[long] alpha type
-error		EQU		type+4					;[word] OSErr result
-paramSize	EQU		type					;size of parameters
-
-		clr.w	error(sp)					;clear error result
-		move.w	alpha(sp),-(sp)				;push alpha value
-		_SetBackTransparency				;set the background transparency
-		RTD		#paramSize
-
-
-		
-;
-; FUNCTION GetForeAlpha(VAR type: LONG; VAR value: INTEGER) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): long *alpha
-;	(on stack): long *type
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-
-GetForeAlpha PROC EXPORT
-
-alpha		EQU		4						;[long] alpha value
-type		EQU		alpha+4					;[long] alpha type
-error		EQU		type+4					;[word] OSErr result
-paramSize	EQU		type					;size of parameters
-
-		clr.w	error(sp)					;clear error result
-		subq	#2,sp						;room for short result
-		_GetForeTransparency				;get the foreground transparency
-		move.w	(sp)+,d0					;get alpha result
-		move.l	alpha(sp),a0				;get alpha var
-		move.w	d0,(a0)						;write alpha
-		move.l	type(sp),a0					;get type var
-		move.l	#'vido',(a0)				;write type
-		RTD		#paramSize
-
-		
-;
-; FUNCTION GetBackAlpha(VAR type: LONG; VAR value: INTEGER) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): long *alpha
-;	(on stack): long *type
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-
-GetBackAlpha PROC EXPORT
-
-alpha		EQU		4						;[long] alpha value
-type		EQU		alpha+4					;[long] alpha type
-error		EQU		type+4					;[word] OSErr result
-paramSize	EQU		type					;size of parameters
-
-		clr.w	error(sp)					;clear error result
-		subq	#2,sp						;room for short result
-		_GetBackTransparency				;get the background transparency
-		move.w	(sp)+,d0					;get alpha result
-		move.l	alpha(sp),a0				;get alpha var
-		move.w	d0,(a0)						;write alpha
-		move.l	type(sp),a0					;get type var
-		move.l	#'vido',(a0)				;write type
-		RTD		#paramSize
-
-
-		
-;
-; FUNCTION GetForeAlphaMask(grafVars: Handle,mask^: LONG) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): long mask ptr
-;	(on stack): long grafVars Handle
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-;
-; Note:
-;	We assume that the GrafVars are expanded
-;
-
-GetForeAlphaMask PROC EXPORT
-
-alphaMask	EQU		4						;[long] grafVars handle
-GrafVarsH	EQU		alphaMask+4				;[long] grafVars handle <SM5>
-error		EQU		grafVars+4				;[word] OSErr result
-paramSize	EQU		grafVars				;size of parameters
-
-		clr.w	error(sp)					;clear error
-		move.l	([GrafVarsH,sp]),a0			;get ptr to GrafVars
-		pea		foreStream(a0)				;push pointer to foreground stream and ratio
-		move.l	alphaMask+4(sp),-(sp)		;push ptr to stream and mask
-		_StreamToMask
-		RTD		#paramSize
-		
-
-		
-;
-; FUNCTION GetBackAlphaMask(grafVars: Handle,mask^: LONG) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): long mask ptr
-;	(on stack): long grafVars Handle
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-;
-; Note:
-;	We assume that the GrafVars are expanded
-;
-
-GetBackAlphaMask PROC EXPORT
-
-alphaMask	EQU		4						;[long] grafVars handle
-GrafVarsH	EQU		alphaMask+4				;[long] grafVars handle <SM5>
-error		EQU		grafVars+4				;[word] OSErr result
-paramSize	EQU		grafVars				;size of parameters
-
-		clr.w	error(sp)					;clear error
-		move.l	([GrafVarsH,sp]),a0			;get ptr to GrafVars
-		pea		backStream(a0)				;push pointer to background stream and ratio
-		move.l	alphaMask+4(sp),-(sp)		;push ptr to stream and mask
-		_StreamToMask
-		RTD		#paramSize																									; <SM4>.end
-
-
 GetCPixel FUNC  EXPORT
 		EXPORT	GETPIXEL
 		IMPORT 	HideCursor,ShowCursor,PortToMap

--- a/QuickDraw/Regions.a
+++ b/QuickDraw/Regions.a
@@ -7,7 +7,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	 1/25/93	kc		Roll in Shannon Holland's alpha channel fix to DrawRgn.
 ;	   <SM3>	 6/11/92	stb		<sm 6/9/92>stb Synch with QDciPatchROM.a; comments added to
 ;									StdRgn, MapRgn
 ;	   <SM2>	 5/21/92	kc		Change the name of QuickDraws wrapper for NewHandle to
@@ -259,10 +258,8 @@ VARSIZE		EQU		BBOX					;SIZE OF LOCALS
 		PEA		BBOX(A6)					;PUSH SRCRECT
 		CLR.L	-(SP)						;NO MASKRECT
 		PEA		BBOX(A6)					;PUSH DSTRECT
-		MOVE	MODE(A6),D1					;PUSH MODE										; <SM4>
-		OR		#$8,D1						;set the pattern bit in case the user forgot to	; <SM4>
-		_GetStreamMode						;strip mode										; <SM4>
-		MOVE.W	D1,-(SP)					;save stripped mode								; <SM4>
+		MOVE	MODE(A6),-(SP)				;PUSH MODE
+		OR		#$8,(SP)					;set the pattern bit in case the user forgot to
 		MOVE.L	PAT(A6),-(SP)				;PUSH PAT
 		MOVE.L	CLIPRGN(A1),-(SP)			;PUSH CLIPRGN
 		MOVE.L	VISRGN(A1),-(SP)			;PUSH VISRGN

--- a/QuickDraw/RgnBlt.a
+++ b/QuickDraw/RgnBlt.a
@@ -10,13 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	  6/3/93	CSS		Per Shannon Holland and KON, The code RgnBlt checks for a
-;									pattern which is solid background color when it should check for
-;									a pattern which is a solid foreground color.
-;	   <SM3>	01/06/93	HI		#1052740: Modified D0 to D3 in RgnBlt in rcMASK0 section.
-;									Previously, it was masking out the destination instead of
-;									the source; so the images were drawn incorrectly. ANDing
-;									with D3 masks out the source and fixes the bug. (Hoon Im)
 ;	   <SM2>	 6/12/92	stb		<sm 6/9/92>stb Synch with QDciPatchROM.a; added comments to
 ;									rMASK8, rXMASK8, rslowHilite, rTransparent.
 ;		<11>	11/26/90	SMC		Fixed pattern hiliting once and for all.  With BAL.
@@ -281,12 +274,12 @@ CLRMASK CLR.L	-(SP)						;ALLOCATE AND CLEAR
 		TST		PATROW(A6)					;BIG PATTERN?
 		BNE.S	@oldWay						;if so, assume pattern contains background color
 		MOVE.L	exPat(A6),A0				;check if non-background pattern
-		MOVE.L	FCOLOR(A6),D1				;get foreground color <SM4> CSS
+		MOVE.L	BCOLOR(A6),D1				;get background color
 		MOVEQ	#$0F,D0						;number of longs in a short pattern
 @nextPatRow
 		CMP.L	(A0)+,D1					;is the row non-background?
 		DBEQ	D0,@nextPatRow				;if so, check for more rows
- 		BNE.S	@oldWay						;if not, can’t do fast hiliting <SM4> CSS
+ 		BEQ.S	@oldWay						;if not, can’t do fast hiliting
 		MOVE	#$10,locMode(A6)			;set the mode to the fast hilite variety
 		BRA.S	@newWay						;assume D0 = -1
 @noHilite
@@ -1481,7 +1474,7 @@ rcMASK0	move.w	hBump(a6),a4	;get hbump in a4
 		EOR.L	D5,D3			;apply bkcolor to src				<9>
 		MOVE.L	(A2),D0			;get dst							<9>
 		EOR.L	D0,D3			;apply it to src					<9>
-		AND.L	(A1)+,D3		;make it							<9> <SM3>
+		AND.L	(A1)+,D0		;make it							<9>
 		EOR.L	D0,D3			;reapply dst to src					<9>
 		MOVE.L	D3,(A2)			;move result to dst					<9>
 		add		a4,a2			;%%%bump dst
@@ -4109,15 +4102,6 @@ rslowHilite
 
 rTransparent
 rTransparentIndexed
-		TST.L	D3						;right to left?									<sm 6/9/92>stb
-		BMI.S	@1						;if so, skip									<sm 6/9/92>stb
-		CMP.W	#8,DSTPIX+PIXELSIZE(A6)	;is it 8 bit mode?								<sm 6/9/92>stb
-		BEQ		rTransparent8			;yes, go use quickdraw							<sm 6/9/92>stb
-									; if it is, go use Andy’s QuickerDraw special 8-bit case
-									; which doesn’t have this problem					<sm 6/9/92>stb
-	@1:	LEA		@RealrTransparent,A0; this fixes a bug that the optimization introduced	<sm 6/9/92>stb
-		MOVE.L	A0,ModeCase(A6)		; which was causing the loss of pattern data		<sm 6/9/92>stb
-@RealrTransparent
 		MOVE	patHMask(A6),D1		;set up source constriction
 		MOVE 	pixInLong1(A6),A0	;set up absolute long bump
 		MOVE	longBump(A6),A2		;set up long bump

--- a/QuickDraw/ScaleBlt.a
+++ b/QuickDraw/ScaleBlt.a
@@ -7,11 +7,6 @@
 ;
 ;	   <SM9>	  7/6/93	kc		Roll in Ludwig.
 ;	   <SM8>	  7/6/93	kc		Roll in bug fix from Shannon Holland.
-;	   <SM7>	01/19/93	HI		#1060484:Fixed bug in scIndToInd where it was not
-;									properly offseting while masking. Fixes bugs where
-;									>1 bit images are clipped and some garbage is drawn
-;									as a result. For a detailed information of the bug
-;									fix, read the header of scIndToInd. (Hoon Im)
 ;	   <SM6>	 12/4/92	CSS		Revert SM5 as SM4 already fixed this bug.
 ;	   <SM5>	 12/2/92	kc		Roll in <R22> from QuickDrawPatches in Reality.
 ;		<R22>	 8/13/92	SAH		#1039892: Fixed a bug in the ScaleBlt 1->16 non-colorizing loop
@@ -356,9 +351,6 @@ ScaleColorBit	EQU		3
 		dbne	d0,@1
 		bne.s	@ScaleOK					;tables are not equal so perform pixel scaling
 
-		Bclr	#ScaleColorBit,XlateFlag+1(a6)	; •••  We are not scaling and it's an idendity map,
-												; •••  so set this bit for the callee
-
 ;if we installed a proc get rid of it before short circuiting stretch
 	
 		TST		D7							;DID WE INSTALL A PROC
@@ -2310,24 +2302,12 @@ scIndexedto16
 ;	<28MAY92 SAH>
 ;		scale and clip indexed source to indexed dst
 ;
-;	<SM7>
-;		If mask data contains an offset, then set the destination alignment
-;		to 0 and recalculate the source alignment value. Use the high word
-;		of D4 to store srcShift-dstShift value; this value is used to
-;		convert a destination alignment value to a source alignment value.
-;		If srcShift-dstShift >= 0 (higher bit depth to lower bit depth), then
-;		shift the dstAlign value to the left; if srcShift-dstShift < 0
-;		(lower bit depth to higher bit depth), then shift the dstAlign value to
-;		the right. Subtract the resulting value from the source offset value;
-;		this causes the source buffer pointer to be offset by the appropriate
-;		value and a new srcAlign value to be calculated.
-;
 ;-------------------------------------------------------
 ;		a0 = tmpsrc			d0 = vert/scratch
 ;		a1 = tmpmask		d1 = scanCount/scratch
 ;		a2 = tmpdst			d2 = scratch / dst pixel
 ;		a3 = scaleTbl		d3 = run cnt / scanCount
-;		a4 = srcPtr/patPtr	d4 = srcShift-dstShift / dst pixel size		<SM7>
+;		a4 = srcPtr/patPtr	d4 = dst pixel size
 ;		a5 = dstPtr			d5 = scratch
 ;		a6 = locals			d6 = bit offset in src / offset in dst
 ;		a7 = 				d7 = src shift / dst shift
@@ -2346,11 +2326,6 @@ scIndtoInd
 		
 		move.l	scaleTbl(a6),a3		;set this up once
 		
-		swap	d4					;use high word						<SM7>
-		move.w	srcShift(a6),d4		;calculate the difference of		<SM7>
-		sub.w	dstShift(a6),d4		;source and destination bit shifts	<SM7>
-		swap	d4					;use low word						<SM7>
-
 		lea		@first,a0			;go here from now on
 		move.l	A3,scaleBltA3(a6)	;save for reload after seekMask
 		move.l	a0,ScaleCase(a6)	;remember for later
@@ -2403,19 +2378,6 @@ scIndtoInd
 		swap	d7				;get shift
 		lsl.w	d7,d5			;make into bit skip
 		swap	d7				;put shift back
-		swap	d4				;get bit shift difference				<SM7>
-		tst.w	d4				;shift left or right?					<SM7>
-		bmi.s	@shiftRight		;shift right							<SM7>
-		lsl.w	d4,d0			;convert dst alignment to src alignment	<SM7>
-		bra.s	@afterShift		;										<SM7>
-@shiftRight						;										<SM7>
-		neg.w	d4				;get absolute value						<SM7>
-		lsr.w	d4,d0			;convert dst alignment to src alignment	<SM7>
-		neg.w	d4				;revert shift difference value			<SM7>
-@afterShift						;										<SM7>
-		swap	d4				;get dst pixel size						<SM7>
-		sub.w	d0,d5			;subtract								<SM7>
-		move.w	#0,d0			;no dst alignment						<SM7>
 		add.w	d5,d6			;bump src offset
 		move.w	d6,d5			;make a copy							
 		and.w	#$1f,d6			;make offset mod 32

--- a/QuickDraw/Stretch.a
+++ b/QuickDraw/Stretch.a
@@ -885,16 +885,6 @@ skipTable
 		btst.l	#ColorizeInModeCaseBit,d0
 		beq		@CheckSwapping				; not modecase: go on
 
-;
-; This code reintroduced from version 54 for CubeE.
-;
-
-	if CubeE then							; <56>
-		move.l	([theGDevice]),a0			; <56> get a pointer to the device
-		tst.l	GDSearchProc(A0)			; <56> check the head of the search chain
-		beq		@CheckSwapping				; <56> no search proc: go on
-	endif									; <56> 
-
 ;
 ; fcolor and bcolor were mapped using search proc by colormap.  We want to use
 ; the unmapped versions.

--- a/Resources/Sys.r
+++ b/Resources/Sys.r
@@ -9,10 +9,6 @@
 
 	Change History (most recent first):
 
-	   <SM3>	 8/25/93	BH		Added dialogs for use by manual-eject drive software. This may
-									not be the most appropriate place for them, but they need a home
-									for now.
-	   <SM2>	 3/24/93	dwc		Changed to include AppleTalk resource AT58 instead of AT57.
 	   <290>	 1/23/92	hsK		Deleted 'dtab' resource which is no more used by the Dictionary
 									manager.
 	   <289>	 1/18/92	DTY		Lock the print driver so that it will get loaded low in the
@@ -819,16 +815,15 @@
 
 //__________________________________________________________________________________________________
 // version
-
 	#define VersionString \
 		"Macintosh System version " SysVersion "\n\n\n" \
-		"© Apple Computer, Inc. 1983-1991\n" \
+		"© Apple Computer, Inc. 1983-1992\n" \
 		"All rights reserved."
 
 	resource 'STR ' (0) { VersionString };
 
 	resource 'vers' (1) {
-		LIntVers, LangInt, SysVersion, SysVersion", © Apple Computer, Inc. 1983-1991"
+		LIntVers, LangInt, SysVersion, SysVersion", © Apple Computer, Inc. 1983-1992"
 	};
 
 	resource 'BNDL' (0) {
@@ -885,7 +880,34 @@
 		"PowerBook 100",		// 24 Asahi
 		"PowerBook 140",		// 25 TimLC
 		"Macintosh Quadra 950",	// 26 Zydeco		<13> Leave 4 trailing spaces for the Installer
-		"Macintosh",			// 27 DBLite
+		"",						// 27 not used
+		"",						// 28 not used
+		"",						// 29 not used
+		"",						// 30 not used
+		"",						// 31 not used
+		"",						// 32 not used
+		"",						// 33 not used
+		"",						// 34 not used
+		"",						// 35 not used
+		"",						// 36 not used
+		"Macintosh LC II",		// 37
+		"",						// 38 not used
+		"",						// 39 not used
+		"",						// 40 not used
+		"",						// 41 not used
+		"",						// 42 not used
+		"",						// 43 not used
+		"",						// 44 not used
+		"",						// 45 not used
+		"",						// 46 not used
+		"",						// 47 not used
+		"",						// 48 not used
+		"",						// 49 not used
+		"",						// 50 not used
+		"",						// 51 not used
+		"",						// 52 not used
+		"",						// 53 not used
+		"PowerBook 145",		// 54
 	} };
 
 	type 'dbex' { integer=0; };		// nothing
@@ -927,7 +949,7 @@
 			$0006, $0007, $0008, $0009,
 			$000A, $000B, $000C, $000D,
 			$000E, $000F, $0010, $0011,
-			$0012, $0013, $0014, $0015
+			$0012, $0013, $0014
 		};
 	};
 
@@ -953,7 +975,7 @@
 	// Picasso Macintosh icon (loaded by System Error Handler)
 
 	resource 'cicn' (-16396, purgeable) {
-		{0, 0, 32, 32}, 4,			// bounds, bits per pixel
+		16, {0, 0, 32, 32}, 4,			// bounds, bits per pixel
 	// mask
 		$"0007FF80 00080000 00087E20 00080120"
 		$"00080120 04080120 0C080120 08080120"
@@ -1129,7 +1151,7 @@
 
 	IncSys "ParityINIT.a.rsrc" codeAs 'INIT' (10, sysHeap, locked);
 
-	IncSys "EDiskShutdownPtch.a.rsrc" codeAs 'INIT' (12, sysHeap, locked);
+//	IncSys "EDiskShutdownPtch.a.rsrc" codeAs 'INIT' (12, sysHeap, locked);
 	
 	
 	resource 'mcky' (0, sysHeap, purgeable) { { 255, 255, 255, 255, 255, 255, 255, 255 } };
@@ -1168,8 +1190,8 @@
 //__________________________________________________________________________________________________
 // AppleTalk
 
-	// AppleTalk 58 resources
- 	include $$Shell("Misc")"APTK58.rsrc" not 'ckid';
+	// AppleTalk 57 resources
+ 	include $$Shell("Misc")"APTK57.rsrc" not 'ckid';
 	
 	// ^^ incorporates the following:
 	// IncSys "AppleTalk.rsrc" not 'vers';
@@ -1180,16 +1202,16 @@
 		"Your system has been placed in AppleTalk zone “",
 
 		"”.  "
-		"To select a different zone, please click the Network icon in the Control Panel, "
+		"To select a different zone, please open the Network icon in the Control Panels Folder, "
 		"then click the selected AppleTalk connection icon.",
 
 		"Access to your AppleTalk internet has now become available.  To use "
-		"the internet, please click the Network icon in the Control Panel, "
+		"the internet, please open the Network icon in the Control Panels Folder, "
 		"then click the selected AppleTalk connection icon.",
 
 		"An unexpected change in your AppleTalk internet has interrupted network access.  "
-		"To resume network use, please click the "
-		"Network icon in the Control Panel, "
+		"To resume network use, please open the "
+		"Network icon in the Control Panels Folder, "
 		"then click the selected AppleTalk connection icon.",
 	} };
 
@@ -1241,6 +1263,10 @@
 		"The Router could not run.  "
 		"The Router file is damaged.  "
 		"Please reinstall the Router.",
+
+		"The Router could not run. "
+		"The Router is not compatible with Virtual Memory. "
+		"The built-in LocalTalk port will be used for your AppleTalk connection.",
 	} };
 
 //__________________________________________________________________________________________________
@@ -1333,7 +1359,7 @@ resource 'PICT' (-16387) {
 	IncSys 	"Choose.r.rsrc" 'CNTL' (CTB_ChooseCNTLID) as 'CNTL' (CTB_ChooseCNTLID, sysHeap, purgeable);
 	IncSys 	"Choose.r.rsrc" 'MENU' (CTB_ChooseMENUID) as 'MENU' (CTB_ChooseMENUID, sysHeap);
 
-	IncSys 	"StandardNBP.p.rsrc" codeAs CTB_NuLookupType (CTB_NuLookupID, sysHeap, purgeable, locked);
+//	IncSys 	"StandardNBP.p.rsrc" codeAs CTB_NuLookupType (CTB_NuLookupID, sysHeap, purgeable, locked);
 	IncSys 	"StandardNBPHelp.r.rsrc" 'hdlg' (CTB_NulookuphdlgID) as 'hdlg' (CTB_NulookuphdlgID, sysHeap, purgeable);
 	IncSys 	"StandardNBP.r.rsrc" 'DLOG' (CTB_NulookupDLOGID) as 'DLOG' (CTB_NulookupDLOGID, sysHeap, purgeable);
 	IncSys 	"StandardNBP.r.rsrc" 'DITL' (CTB_NulookupDITLID) as 'DITL' (CTB_NulookupDITLID, sysHeap, purgeable);
@@ -1908,6 +1934,7 @@ resource 'STR ' (-16391, purgeable) { "Font Cache" };
 	data 'FONT' (384, "Geneva", purgeable) {};
 	IncSys "SystemFonts.rsrc" 'FONT' (393) as 'FONT' (393, purgeable);
 	IncSys "SystemFonts.rsrc" 'FONT' (396) as 'FONT' (396, purgeable);
+	IncSys "SystemFonts.rsrc" 'FONT' (521) as 'FONT' (521, purgeable);
 
 	resource 'FOND' (4, "Monaco", purgeable) {
 		FakeFONDFlags, 4, FakeFONDFields, 1, { 9, plain, 521; }, FakeFONDTables
@@ -1954,7 +1981,7 @@ resource 'STR#' (glyphNameResID, purgeable) { {
 //__________________________________________________________________________________________________
 // Gestalt
 
-	IncSys "Gestalt.rsrc" codeAs 'ptch' (5, sysHeap, locked);
+//	IncSys "Gestalt.rsrc" codeAs 'ptch' (5, sysHeap, locked);
 
 //__________________________________________________________________________________________________
 // pslt • Nubus pseudo-slot mapping definitions
@@ -2121,16 +2148,24 @@ resource 'pslt' (gestaltEclipse33, purgeable) {
 
 	IncSys "International.rsrc" 'kcs#' (0) as 'kcs#' (0, sysHeap, purgeable);
 	IncSys "International.rsrc" 'kcs4' (0) as 'kcs4' (0, sysHeap, purgeable);
-	IncSys "International.rsrc" 'kcs8' (0) as 'kcs8' (0, sysHeap, purgeable);
+	IncSys "International.rsrc" 'kcs#' (16383) as 'kcs#' (16383, sysHeap, purgeable);
+	IncSys "International.rsrc" 'kcs4' (16383) as 'kcs4' (16383, sysHeap, purgeable);
 	IncSys "International.rsrc" 'kcs#' (-16491) as 'kcs#' (-16491, sysHeap, purgeable);
 	IncSys "International.rsrc" 'kcs4' (-16491) as 'kcs4' (-16491, sysHeap, purgeable);
-	IncSys "International.rsrc" 'kcs8' (-16491) as 'kcs8' (-16491, sysHeap, purgeable);
+	IncSys "International.rsrc" 'kcs#' (-16492) as 'kcs#' (-16492, sysHeap, purgeable);
+	IncSys "International.rsrc" 'kcs4' (-16492) as 'kcs4' (-16492, sysHeap, purgeable);
 	IncSys "International.rsrc" 'STR#' (-16491) as 'STR#' (-16491, sysHeap, purgeable);
+	IncSys "International.rsrc" 'STR#' (-16492) as 'STR#' (-16492, sysHeap, purgeable);
+	IncSys "International.rsrc" 'STR#' (-16493) as 'STR#' (-16493, sysHeap, purgeable);
+	IncSys "International.rsrc" 'STR#' (-16494) as 'STR#' (-16494, sysHeap, purgeable);
+	IncSys "International.rsrc" 'STR#' (-16495) as 'STR#' (-16495, sysHeap, purgeable);
 	IncSys "International.rsrc" 'hmnu' (-16491) as 'hmnu' (-16491, sysHeap, purgeable);	// Keyboard menu help strings	<185>
-	IncSys "International.rsrc" 'DLOG' (-16491) as 'DLOG' (-16491, sysHeap, purgeable);	// About Keyboards…				<208>
-	IncSys "International.rsrc" 'DITL' (-16491) as 'DITL' (-16491, sysHeap, purgeable);	// About Keyboards…				<208>
 	IncSys "International.rsrc" 'DLOG' (-16492) as 'DLOG' (-16492, sysHeap, purgeable);	// About Keyboards…				<208>
 	IncSys "International.rsrc" 'DITL' (-16492) as 'DITL' (-16492, sysHeap, purgeable);	// About Keyboards…				<208>
+	IncSys "International.rsrc" 'DLOG' (-16493) as 'DLOG' (-16493, sysHeap, purgeable);	// About Keyboards…
+	IncSys "International.rsrc" 'DITL' (-16493) as 'DITL' (-16493, sysHeap, purgeable);	// About Keyboards…
+	IncSys "International.rsrc" 'DLOG' (-16494) as 'DLOG' (-16494, sysHeap, purgeable);	// About Keyboards…
+	IncSys "International.rsrc" 'DITL' (-16494) as 'DITL' (-16494, sysHeap, purgeable);	// About Keyboards…
 
 //__________________________________________________________________________________________________
 // List Mgr
@@ -2540,13 +2575,6 @@ resource 'ppci' (-16409)
 	IncSys "Scheduler.rsrc";
 	IncSys "DAHandler.rsrc";
 
-//__________________________________________________________________________________________________
-// SANE
-
-	IncSys "FPHW.rsrc" 'RSRC' (0) as 'PACK' (4, sysHeap, locked);
-	IncSys "ElemsHW.rsrc" 'RSRC' (0) as 'PACK' (5, sysHeap, locked);
-
-
 //__________________________________________________________________________________________________
 // QuickDraw
 
@@ -3101,16 +3129,6 @@ resource 'ppci' (-16409)
 	} };
 
 //__________________________________________________________________________________________________
-// EDisk
-	resource 'STR#' (-4097, sysHeap, Locked) {
-		{
-			"The contents of the RAM Disk volume “^1” will be lost by shutting down.  "
-			"Do you wish to continue?",
-			"OK",
-			"Cancel",
-		}
-	};
-//__________________________________________________________________________________________________
 // Virtual Memory
 
 	include $$Shell("Misc")"VM.rsrc" not 'ckid';
@@ -3165,7 +3183,7 @@ data 'ppat' (18, sysheap, purgeable) {
 // color desktop pattern = dithered gray
 	resource 'ppat' (16, sysHeap, purgeable) {
 		$"AA55AA55AA55AA55",			// black & white pattern
-		{0, 0, 8, 8}, 4,				// bounds, bits per pixel
+		4, {0, 0, 8, 8}, 4,				// bounds, bits per pixel
 	// 4-bit color image
 		$"10101010"
 		$"01010101"
@@ -3540,78 +3558,4 @@ data 'ppat' (18, sysheap, purgeable) {
 
 #if hasAppleEventMgr
 	IncSys "AppleEventMgr.rsrc";
-#endif
-
-//__________________________________________________________________________________________________
-// Manual-eject drive stuff
-// This dialog and alert are used by the manual-eject drive software to communicate with the user
-// when a dirty disk has been manually-ejected.  This may not be the best place for them, but they
-// need to go somewhere for now.
-
-#if hasManEject
-resource 'DLOG' (-16413, sysheap, purgeable) {
-	{73, 114, 159, 411},
-	dBoxProc,
-	visible,
-	noGoAway,
-	0x0,
-	-16413,
-	""
-};
-
-resource 'DITL' (-16414, sysheap) {
-	{	/* array DITLarray: 2 elements */
-		/* [1] */
-		{60, 229, 80, 287},
-		Button {
-			enabled,
-			"OK"
-		},
-		/* [2] */
-		{9, 72, 54, 287},
-		StaticText {
-			disabled,
-			"Failing to update your disk may result i"
-			"n data loss."
-		}
-	}
-};
-
-resource 'DITL' (-16413, sysheap, purgeable) {
-	{	/* array DITLarray: 3 elements */
-		/* [1] */
-		{60, 229, 80, 287},
-		Button {
-			enabled,
-			"OK"
-		},
-		/* [2] */
-		{9, 72, 54, 287},
-		StaticText {
-			disabled,
-			"You may now safely remove the disk."
-		},
-		/* [3] */
-		{9, 10, 41, 42},
-		Icon {
-			disabled,
-			1
-		}
-	}
-};
-
-resource 'ALRT' (-16414, sysheap, purgeable) {
-	{73, 114, 159, 411},
-	-16414,
-	{	/* array: 4 elements */
-		/* [1] */
-		OK, visible, sound1,
-		/* [2] */
-		OK, visible, sound1,
-		/* [3] */
-		OK, visible, sound1,
-		/* [4] */
-		OK, visible, sound1
-	}
-};
 #endif
\ No newline at end of file

--- a/Tidbits/UserAlerts.a
+++ b/Tidbits/UserAlerts.a
@@ -9,10 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 8/25/93	BH		Added stuff for manual-eject drive support and tweaked the old
-;									disk-switch alert a bit.  The changes are all conditionalized
-;									with hasManEject.  There is probably a better way to do this,
-;									but this stuff needs somewhere to go for now.
 ;		<18>	 6/12/91	LN		removed #include 'HardwareEqu.a'
 ;		<17>	  3/4/91	dba		dty: get rid of SysVers conditionals
 ;		<16>	  2/7/91	dnf		kst, #79676: Use dsRecoverVCBPtr to draw the name of the volume
@@ -131,6 +127,7 @@ dsiRemoveDisk			equ		-16401	; <SM1> <BH 25Aug93>
 dstMissingPatch			equ		-20000
 dstParityError			equ		-20001
 dstSystemDamaged		equ		-20002
+dstSCSIWarn				equ		-20003
 
 dstApplicationBusy		equ		-20100
 dstFinderMissing		equ		-20101
@@ -184,17 +181,13 @@ dssCancel				equ		-23104
 ;
 ; Entry count: bump 1 for each new item.
 
-	IF NOT hasManEject THEN
-	NumEntries: set 47
-		; 11 alerts
-		; 10 texts
+	NumEntries: set 49
+		; 12 alerts
+		; 11 texts
 		;  4 icons
 		;  8 button lists
 		;  5 button strings
 		;  9 procs
-	ELSE						; if hasManEject
-		NumEntries: set 52		; 13 + 9 + 5 + 8 + 5 + 12
-	ENDIF
 	
 			dc.w	NumEntries
 
@@ -216,14 +209,7 @@ dssCancel				equ		-23104
 
 			; other errors
 
-	IF hasManEject THEN														; <SM1> <BH 25Aug93>
-			dc.w	dsRemoveDisk,10,0,0,dsiRemoveDisk,dspDrawRmvDsk,0		; eject request
-			dc.w	dsDirtyDisk,10,0,0,dsiInsertDisk,dspDrawDirtyDsk,0		; ejected dirty
-			dc.w	dsReinsert,10,0,0,dsiInsertDisk,dspDrawDiskName,0		; new disk-switch
-	ELSE
 			dc.w	dsReinsert,10,dstInsertDisk,0,dsiDiskSwap,dspDrawDiskName,0
-	ENDIF
-	
 			dc.w	dsStknHeap,10,dstGeneralError,0,dsiBomb,dspStackSniffError,dsbRestartResume
 
 			; Startup, INITs, or apps ate too much of BufPtr space or the current heap
@@ -246,6 +232,10 @@ dssCancel				equ		-23104
 			dc.w	dsNoPatch,10,dstMissingPatch,0,dsiStop,0,dsbRestart
 			dc.w	dsParityErr,10,dstParityError,0,dsiBomb,0,dsbRestart
 
+			; SCSI Disk Mode
+
+			dc.w	dsSCSIWarn,10,dstSCSIWarn,0,dsiStop,0,0
+
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 ;
 ; Text definitions.
@@ -265,7 +255,6 @@ GeneralErrorMessage
 			align
 @end
 
-	IF NOT hasManEject THEN		; Drawn by proc below in man-eject systems <SM1> <BH 25Aug93>
 InsertDiskMessage
 			dc.w	dstInsertDisk,@end-@rest
 @rest
@@ -274,7 +263,6 @@ InsertDiskMessage
 			DC.B	0
 			align
 @end
-	ENDIF	; NOT hasManEject
 	
 SwitchOffMessage
 			dc.w	dstSwitchOff,@end-@rest
@@ -358,6 +346,20 @@ SomebodyAteAlltheRAMMessage
 			align
 @end
 
+CableRemovedMessage
+			dc.w	dstSCSIWarn,@end-@rest
+@rest
+			dc.w	88,114
+			dc.b	'/'
+			dc.b	'Hard Disk Cable Warning/'
+			dc.b	'/'
+			dc.b	'You must first shutdown the Macintosh before/'
+			dc.b	'attaching any SCSI hard disk cables.  Disconnect/'
+			dc.b	'the cable from the back of the machine right now./'
+			dc.b	0
+			align
+@end
+
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 ;
 ; icon definitions
@@ -385,7 +387,6 @@ BombIcon
 
 ; disk-switched icon
 
-	IF NOT hasManEject THEN	; <SM1> <BH 25Aug93>
 							; The disk-switch icon for manual-eject systems is different
 DiskSwapIcon
 			dc.w	dsiDiskSwap,@end-@rest
@@ -401,38 +402,6 @@ DiskSwapIcon
 			dc.l	$01000000, $00800100, $007B5400, $00000000
 @end
 
-	ELSE					; Disk insert and remove icons for manual-eject systems
-
-DiskInsertIcon				; Used by both disk-switch and manual-eject stuff
-			dc.w	dsiInsertDisk,@end-@rest
-@rest
-			dc.w	12,20,44,52
-			dc.l	$00000000, $00000000, $00000000, $0001FFF0
-			dc.l	$00011148, $00411144, $00E11044, $01F11FC4
-			dc.l	$03F90004, $00E10004, $00E13FE4, $00E14014
-			dc.l	$00E14014, $00E14C14, $00E15214, $00016214
-			dc.l	$00014414, $0001CFFC, $00008920, $00008620
-			dc.l	$00008020, $00008020, $00008020, $00008040
-			dc.l	$00008080, $00008100, $00010200, $00010400
-			dc.l	$0003FC00, $0003FC00, $0003FC00, $00000000
-@end
-
-DiskRemoveIcon
-			dc.w	dsiRemoveDisk,@end-@rest
-@rest
-			dc.w	12,20,44,52
-			dc.l	$00000000, $00000000, $00000000, $0001FFF0
-			dc.l	$00011148, $00E11144, $00E11044, $00E11FC4
-			dc.l	$00E10004, $00E10004, $00E13FE4, $03F94014
-			dc.l	$01F14014, $00E14C14, $00415214, $00016214
-			dc.l	$00014414, $0001CFFC, $00008920, $00008620
-			dc.l	$00008020, $00008020, $00008020, $00008040
-			dc.l	$00008080, $00008100, $00010200, $00010400
-			dc.l	$0003FC00, $0003FC00, $0003FC00, $00000000
-@end
-
-	ENDIF	; NOT hasManEject
-
 ; stop icon
 
 DSStopIcon
@@ -822,7 +791,6 @@ MessagesTable
 
 EndDoSystemErrorButtons
 
-	IF NOT hasManEject THEN	; This proc has been replaced for man-eject systems <SM1> <BH 25Aug93>
 ; —————————————————————————————————————————————————
 ;
 ; DrawDiskName is used to by the disk switch alert
@@ -841,137 +809,6 @@ DrawDiskName
 			rts
 EndDrawDiskName
 	
-	ELSE
-
-; The following procedures are used to draw the various disk-insertion and disk-removal
-; syserr messages for manual-eject systems.  The old DrawDiskName has been superseded by
-; the one below for these systems.
-
-; These constants are used by the disk-message-drawing code that follows
-TextTop		EQU		24
-TextEdge	EQU		72
-LineHeight	EQU		16
-
-;________________________________________________________________________________
-; DrawNameStr is used by the following three procs to draw the name of the disk
-; they need in their alert boxes.  A pointer to the string to draw as the name is
-; passed on top of the stack.  The strings included in this proc are also used by
-; the other procs.
-;________________________________________________________________________________
-			dc.w	dspDrawNameStr,EndDrawNameStr-DrawNameStr
-DrawNameStr
-			MOVEA.L	(SP)+,A0		; pop return addr
-			MOVE.L	(SP)+,D0		; and parameter
-			MOVEM.L	A0/D0,-(SP)		; swap them on the stack
-			
-			MOVE.W	#210,-(SP)									; “
-			MOVE.L	#((TextTop+LineHeight)<<16)+TextEdge,-(SP)	; start of second line
-			_MoveTo												; go there
-			_DrawChar											; draw “
-			
-			_DrawString											; draw name (already on stack)
-			
-			MOVE.W	#211,-(SP)									; ”
-			MOVE.W	#46,-(SP)									; .
-			_DrawChar											; draw .
-			_DrawChar											; draw ”
-			
-			RTS
-			
-; These strings are used by the disk-message-drawing procedures
-				STRING	pascal
-InsertString	DC.B	'Please insert the disk'
-RemoveString	DC.B	'Please remove the disk'
-UpdateString1	DC.B	'It needs to be updated'
-UpdateString2	DC.B	'before you remove it.'
-FromString		DC.B	'from drive '
-				STRING	asis
-				ALIGN
-EndDrawNameStr
-
-; DrawDiskName draws the message "Please insert the disk 'xxxx'"  It is used by both
-; the old disk-switch syserr and the new manual-eject error for ejected dirty disks.
-; It gets the disk name from the dsRecoverNamePtr field of the filesystem vars as the
-; old disk-switch code did.
-			dc.w	dspDrawDiskName,EndDrawDiskName-DrawDiskName
-DrawDiskName
-			PEA		InsertString						; "Please insert the disk"
-			MOVE.L	#(TextTop<<16)+TextEdge,-(SP)		; start of top line
-			_MoveTo										; go there
-			_DrawString									; draw message
-			
-			MOVEA.L	FSVarsPtr,A1
-			MOVE.L	FSVars.dsRecoverNamePtr(A1),-(SP)	; get name string
-			BSR		DrawNameStr							; draw it on second line
-			
-			RTS
-EndDrawDiskName
-
-
-; DrawDirtyDisk draws the same message as DrawDiskName and adds "It needs to be updated
-; before you remove it" below.  It is used to request the return of a manually-ejected
-; dirty disk.
-			dc.w	dspDrawDirtyDsk,EndDrawDirtyDsk-DrawDirtyDsk
-DrawDirtyDsk
-			PEA		UpdateString2									; "before you remove it."
-			MOVE.L	#((TextTop+3*LineHeight)<<16)+TextEdge,-(SP)	; start of fourth line
-			PEA		UpdateString1									; "It needs to be updated"
-			MOVE.L	#((TextTop+2*LineHeight)<<16)+TextEdge,-(SP)	; start of third line
-			PEA		InsertString									; "Please insert the disk"
-			MOVE.L	#(TextTop<<16)+TextEdge,-(SP)					; start of top line
-			_MoveTo													; go there
-			_DrawString												; draw "Please insert..."
-			_MoveTo													; go to third line
-			_DrawString												; draw "It needs..."
-			_MoveTo													; go to fourth line
-			_DrawString												; draw "before you..."
-			
-			MOVEA.L	FSVarsPtr,A1
-			MOVE.L	FSVars.dsRecoverNamePtr(A1),-(SP)	; get name string
-			BSR		DrawNameStr							; draw it on second line
-			
-			RTS
-EndDrawDirtyDsk
-
-
-; DrawRmvDsk draws the message "Please remove the disk 'xxxx' from drive y."  It is used
-; by the _Eject trap to get the user to eject a disk from a manual-eject drive.  The name
-; and drive number are pointed to by the dsRecoverNamePtr field of the filesystem vars used
-; by the disk-insertion procs.  If no name is available, the name ptr is set to nil and the
-; proc does not draw it, producing "Please remove the disk from drive y."  There is always
-; a drive number available.
-			dc.w	dspDrawRmvDsk,EndDrawRmvDsk-DrawRmvDsk
-DrawRmvDsk
-			MOVEA.L	FSVarsPtr,A1
-			MOVEA.L	FSVars.dsRecoverNamePtr(A1),A1	; A1 -> struct { short drvNum; char *diskName; }
-			
-			PEA		RemoveString									; "Please remove the disk"
-			MOVE.L	#(TextTop<<16)+TextEdge,-(SP)					; start of top line
-			MOVE.W	#46,-(SP)										; .
-			MOVE.W	(A1),D0											; drive number
-			OR.B	#$30,D0											; ASCII equivalent
-			MOVE.W	D0,-(SP)
-			PEA		FromString										; "from drive "
-			MOVE.L	#((TextTop+LineHeight)<<16)+TextEdge,-(SP)		; start of second line
-			
-			TST.L	2(A1)											; disk name OK?
-			BEQ.S	@drawfrom										; no: skip to "from drive"
-			MOVE.L	2(A1),-(SP)										; get disk name
-			BSR		DrawNameStr										; draw it on second line
-			MOVE.L	#((TextTop+2*LineHeight)<<16)+TextEdge,(SP)		; start of third line for "from..."
-			
-@drawfrom	_MoveTo													; go to proper line
-			_DrawString												; draw "from drive "
-			_DrawChar												; draw number
-			_DrawChar												; draw .
-			_MoveTo													; go to top line
-			_DrawString												; draw "Please remove..."
-			
-			RTS
-EndDrawRmvDsk
-
-	ENDIF	; hasManEject
-
 ; —————————————————————————————————————————————————
 ;
 ; DrawCurrentName is used to draw the name of the INIT or application which ate up too much memory.

--- a/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgr.c
+++ b/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgr.c
@@ -225,8 +225,8 @@ err1:
 		DisposHandle( (Handle)hConn );	
 err0:
 		CRMReleaseRF(procID);							/* close file or decrement useCount */
-		GetMemErr() = savedMem;							// restore the error values
-		GetResErr() = savedRes;
+		//GetMemErr() = savedMem;							// restore the error values
+		//GetResErr() = savedRes;
 		
 		return( nil );
 }

--- a/Toolbox/ControlMgr/ButtonCDEF.a
+++ b/Toolbox/ControlMgr/ButtonCDEF.a
@@ -14,7 +14,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<SM2>	10/22/92	CSS		Change short branches to word branches.
 ;		<14>	 4/11/91	gbm		csd, KSM, BRC#86464: Fix many references to the control
 ;									rectangle which are invalid because the control handle can be
 ;									unlocked.
@@ -159,7 +158,7 @@ FrameSize		EQU	 -58
 
 			CMP.W	#$3FFF,ROM85		; do we have color QD?
 			SLS		IsColor(A6)			; set boolean depending on color or B&W system
-			BHI		@BWSys				; no, this system has B&W QD <SM2> CSS 
+			BHI.S	@BWSys				; no, this system has B&W QD
 
 ; save the current port’s colors and textMode						<C59/30Jun86> DAF
 

--- a/Toolbox/ControlMgr/PopupCDEF.c
+++ b/Toolbox/ControlMgr/PopupCDEF.c
@@ -9,8 +9,6 @@
 
 	Change History (most recent first):
 
-	   <SM4>	11/19/92	RB		Set ROMMapInsert to mapTRue to look for resources in ROM first.
-		<43>	11/13/92	JDR		Updated QuickDraw.h to not use the dangerous pattern type.
 		<42>	 11/7/92	JDR		Removed the PopupPrivateData record, which is now a public
 									structure.  Change occurances of the usage too,
 		<41>	 11/3/92	DTY		Strip out unnecessary includes.
@@ -287,6 +285,7 @@
 		Make popup return different part codes
 */
 
+#define dangerousPattern
 #include <Types.h>
 #include <Controls.h>
 #include <Fonts.h>
@@ -860,8 +859,7 @@ long DoTrack(ControlHandle hControl, short theVar)
 	useSpandex = (growWidth > 0);
 
 	if (useSpandex) {										// invoke spandex MDEF
-		*(short*) RomMapInsert = mapTrue;												// <SM4> rb
-		theHandle = (SpandexH) GetResource(SpandexResType, SpandexMDEF);				// <SM4> rb
+		theHandle = (SpandexH) GetResource(SpandexResType, SpandexMDEF);
 		if (theHandle != nil) {								// load in spandex MDEF
 			LoadResource( (Handle) theHandle );				// load in case of purged -- now unpurgeable so remove this
 			HLock( (Handle) theHandle );

--- a/Toolbox/ControlMgr/ScrollBarCDEF.a
+++ b/Toolbox/ControlMgr/ScrollBarCDEF.a
@@ -12,34 +12,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM6>	  2/1/94	SWC		Changed the entry code for setting up the drawing environment to
-;									only do that for calls that will actually be doing some drawing.
-;									This is to prevent the situation where a ‘clut’ resource is
-;									continuously being loaded (by GetCTable) and unloaded (by
-;									DisposeCTable) when all that's being done is hit testing, region
-;									calculations, etc. This fixes a problem when running Microsoft
-;									Excel 4.0 on a PowerBook: since the resource was always being
-;									purged, GetResource ended up doing a disk read, which registers
-;									as machine usage to the Power Manager, and thus the PowerBook
-;									never auto-sleeps. A beneficial side effect for desktop machines
-;									is that running thru this code will now be a bit faster. While I
-;									was at it, changed word branches to short branches, where
-;									appropriate.
-;	   <SM5>	  6/7/93	CSS		Resupport drawthumboutline and make it do something different
-;									for ROM (render a rgn instead of a rect).
-;	   <SM4>	 4/30/93	CSS		DragTheRgn now will drag a black outline instead of a yellow one
-;									when dragging the scroll bar thumb. So, take out <SM3>. Also,
-;									desupported the DrawThumbOutline Message which was for the hack
-;									on FrameRect which we no longer do.
-;	   <SM3>	 4/21/93	CSS		Implement a custom dragging routine so that we can draw a black
-;									box instead of a yellow one (the standard dragging in
-;									dragcontrol uses dragthergn which uses xor and creates a nice
-;									yellow color in 256 colors). This routine will use hilite mode
-;									in color and notpatxor in black&white. This was implemented in
-;									7.1 as a nice comefrompatch hack on _FrameRect (e.g. if we are
-;									dragging and if we came from _DragControl... you get the idea).
-;	   <SM2>	11/19/92	RB		Set ROMMapInsert to mapTrue to look for resources in ROM first
-;									when doing GetResource calls.
 ;		<36>	 5/30/91	DTY		We look for things to make it go faster.
 ;		<35>	 4/11/91	gbm		dba, ws#-dba041001: Stop trying to do fancy offscreen stuff to
 ;									buffer screen drawing if we're not actually drawing to the
@@ -309,8 +281,14 @@ hilite				equ		50
 
 ; test if the message is in range
 
+			cmp.w	#6,message(A6)
+			bls.s	@MsgOK
+			cmp.w	#10,message(A6)
+			beq.s	@MsgOK
+			cmp.w	#11,message(A6)
+			beq.s	@MsgOK
 			cmp.w	#drawThumbOutlineMsg,message(A6) ; compare to highest value
-			bhi.s	OORange				; We respond to 0-12								<1.2><SM6>
+			bne		OORange				; We respond to 0-12								<1.2>
 @MsgOK
 
 ; save the penState and set it our way
@@ -319,6 +297,62 @@ hilite				equ		50
 			_GetPenState				; remember current penState
 			_PenNormal					; set the pen the way we	want it
 
+; sets up the drawing environment for calls that do drawing
+
+; Determine type of system.  We need to know if we have color QuickDraw and a color
+;	window manager port.
+
+			cmp.w	#$3FFF,ROM85		; do we have color QD?
+			SLS		IsColor(A6)			; set boolean depending on color or B&W system
+			BHI.s	@BWSys				; no, this system has B&W QD
+
+; save the current port's colors
+
+			move.l	GrafGlobals(A5),A0	; get pointer to grafGlobals	<C407/16Nov86> DAF
+			move.l	thePort(A0),A0		; get pointer to thePort		<C407/16Nov86> DAF
+
+			PEA		SavFgCol(A6)		; save foreColor
+			_GetForeColor				;
+			PEA		SavBkCol(A6)		; save backColor too
+			_GetBackColor				;
+
+
+; get the CtlAuxRec for this guy and lock it's colortable			<DAF 26Apr86>
+
+			CLR.l	-(SP)				; return the handle here
+			CLR.b	-(SP)				; space for boolean func return
+			move.l	CtlHndl(A6),-(SP)	; push the control handle
+			PEA		6(SP)				; push a pointer to placeholder
+			_GetAuxCtl					; get its auxRec
+			addQ	#2,SP				; don't need boolean result
+			move.l	(SP)+,A0			; get auxCtl handle
+			move.l	(A0),A0				; a pointer to the auxCtlRec
+			move.l	acCTable(A0),A0		; get colortable's handle		<1.3>
+			move.l	A0,AuxCtlHndl(A6)	; save the handle
+			_HLock						; lock the handle
+			move.l	(A0),AuxCtlPtr(A6)	; save a pointer
+
+; ------------- get a pixmap for drawing the gadgets ------------
+
+			subq.l	#4, SP					; room for a PixMapHandle
+			move.l	#'pmap', -(SP)			; the Pixmap resource type
+			move.w	#kPixmapID, -(SP)		; ID of working pixmap
+			_GetResource
+			move.l	(SP), workPixmap(A6)	; save it for later
+			
+			
+			move.w	#kClutID,-(sp)			; ID of clut for pixmap
+			_GetCTable
+			move.l	(sp)+,workCLUT(a6)
+
+			move.l	workPixmap(a6),a0
+			move.l	(a0),a0
+			move.l	workCLUT(a6),pmTable(a0)	; Stash colour table into pmap handle
+			
+@BWSys
+			clr.l	tempPixels(A6)			; init this to NIL
+
+
 ; fetch the parameters into registers
 
 			lea 	8(A6),A0			; get ptr to first parameter
@@ -331,6 +365,11 @@ hilite				equ		50
 
 ; case out on the message number
 
+			cmp.w	#6,d0
+			bls		@nocollapse
+			subq	#3,d0
+@nocollapse
+
 			add 	D0,D0				; double for word index
 			lea 	GoScrollBar,A1		; get table address
 			add 	0(A1,D0),A1 		; compute dispatch address
@@ -341,9 +380,23 @@ hilite				equ		50
 			PEA 	SavePen(A6) 		; push savePenState
 			_SetPenState				; restore original pen state
 
+			tst.b	IsColor(A6)			;
+			beq.s	@NoColor1			; if on B&W, then skip
+
+			move.l	AuxCtlHndl(A6),A0	; unlock the CDEF
+			_HUnlock
+			PEA		SavFgCol(A6)		;
+			_RGBForeColor				;
+			PEA		SavBkCol(A6)		;
+			_RGBBackColor				;
+
+			move.l	workCLUT(a6),-(sp)
+			_DisposCTable
+			
+@NoColor1
+
 ; we're done -- restore registers and return to caller
 
-
 OORange									; 'Out Of Range, of course'
 			moveM.l (SP)+,D3-D6/A1-A4	; restore work registers
 			UNLK	A6					; unlink	stack frame
@@ -351,9 +404,6 @@ TenBytExit	move.l	(SP)+,A0			; get return address
 			add 	#12,SP				; strip parameters
 			JMP 	(A0)				; return	to caller
 
-JustRTS		clr.l	ProcResult(a6)		; indicate we didn't handle this message
-			rts
-			
 GoScrollBar
 			DC.w	DrawSBar-GoScrollBar	; draw is message 0
 			DC.w	HitSBar-GoScrollBar		; hit test is message 1
@@ -362,92 +412,12 @@ GoScrollBar
 			DC.w	DispSBar-GoScrollBar	; de-allocate indicator region (4)
 			DC.w	MoveSBar-GoScrollBar	; move indicator call (5)
 			DC.w	ThumbSBar-GoScrollBar	; message 6 is thumb dragging
-			DC.w	JustRTS-GoScrollBar		; message 7 is thumb dragging custom message
-			DC.w	JustRTS-GoScrollBar		; message 8 is not supported
-			DC.w	JustRTS-GoScrollBar		; message 9 is not supported
-			DC.w	CalcWholeSBar-GoScrollBar; calc whole regions is message 10		<1.2>
-			DC.w	CalcThumbSBar-GoScrollBar; calc thumb regions is message 11		<1.2>
-			DC.w	DrawThumbOutline-GoScrollBar;									<26>
-
-
-; sets up the drawing environment for calls that do drawing
-
-InitDrawingStuff						;											<SM6>
-
-; Determine type of system.  We need to know if we have color QuickDraw and a color
-;	window manager port.
-
-			cmp.w	#$3FFF,ROM85		; do we have color QD?
-			SLS		IsColor(A6)			; set boolean depending on color or B&W system
-			BHI.s	@BWSys				; no, this system has B&W QD
-
-; save the current port's colors
-
-			move.l	GrafGlobals(A5),A0	; get pointer to grafGlobals	<C407/16Nov86> DAF
-			move.l	thePort(A0),A0		; get pointer to thePort		<C407/16Nov86> DAF
-
-			PEA		SavFgCol(A6)		; save foreColor
-			_GetForeColor				;
-			PEA		SavBkCol(A6)		; save backColor too
-			_GetBackColor				;
-
-
-; get the CtlAuxRec for this guy and lock it's colortable			<DAF 26Apr86>
-
-			CLR.l	-(SP)				; return the handle here
-			CLR.b	-(SP)				; space for boolean func return
-			move.l	CtlHndl(A6),-(SP)	; push the control handle
-			PEA		6(SP)				; push a pointer to placeholder
-			_GetAuxCtl					; get its auxRec
-			addQ	#2,SP				; don't need boolean result
-			move.l	(SP)+,A0			; get auxCtl handle
-			move.l	(A0),A0				; a pointer to the auxCtlRec
-			move.l	acCTable(A0),A0		; get colortable's handle		<1.3>
-			move.l	A0,AuxCtlHndl(A6)	; save the handle
-			_HLock						; lock the handle
-			move.l	(A0),AuxCtlPtr(A6)	; save a pointer
-
-; ------------- get a pixmap for drawing the gadgets ------------
-
-			subq.l	#4, SP					; room for a PixMapHandle
-			move.l	#'pmap', -(SP)			; the Pixmap resource type
-			move.w	#kPixmapID, -(SP)		; ID of working pixmap
-			move.w	#MapTrue,RomMapInsert				;									<SM2> rb
-			_GetResource					; look in ROM first							<SM2> rb
-			move.l	(SP), workPixmap(A6)	; save it for later
-			
-			
-			move.w	#kClutID,-(sp)			; ID of clut for pixmap
-			_GetCTable
-			move.l	(sp)+,workCLUT(a6)
-
-			move.l	workPixmap(a6),a0
-			move.l	(a0),a0
-			move.l	workCLUT(a6),pmTable(a0)	; Stash colour table into pmap handle
-			
-@BWSys
-			clr.l	tempPixels(A6)			; init this to NIL
-			rts
-
+			DC.w	CalcWholeSBar-GoScrollBar
+			DC.w	CalcThumbSBar-GoScrollBar
+			DC.w	DrawThumbOutline-GoScrollBar
 
 ; clean up color stuff												<DAF 28Apr86>
 
-RestoreDrawingStuff						;												<SM6>
-			tst.b	IsColor(A6)			;
-			beq.s	@NoColor1			; if on B&W, then skip
-
-			move.l	AuxCtlHndl(A6),A0	; unlock the CDEF
-			_HUnlock
-			PEA		SavFgCol(A6)		;
-			_RGBForeColor				;
-			PEA		SavBkCol(A6)		;
-			_RGBBackColor				;
-
-			move.l	workCLUT(a6),-(sp)
-			_DisposCTable
-			
-@NoColor1	rts
-
 
 
 CDefDrawFrame	RECORD	0				; stack frame for DeviceLoop draw proc
@@ -466,8 +436,6 @@ ParamSize		EQU		*-StartParams
 ; desired "hilite" area code.
 
 DrawSBar
-			bsr		InitDrawingStuff	; initialize the drawing environment				<SM6>
-
 		; if we are drawing to the screen, use _DeviceLoop to handle the case of
 		; multiple monitors. If we are not drawing to the screen, then _DeviceLoop
 		; could do the wrong thing--just draw the control directly.
@@ -498,7 +466,7 @@ DrawSBar
 			move.w	#fakeDeviceFlags, -(SP)	; assume non-CQD case
 			clr.l	-(SP)				; NIL gDeviceHandle for non-CQD machines
 			btst	#6, ROM85			; Color QuickDraw available?
-			bnz.s	@deviceAndFlagsOk	; of not, fake versions on stack are correct		<SM6>
+			bne		@deviceAndFlagsOk	; of not, fake versions on stack are correct
 			move.l	theGDevice, A1		; current device GDHandle
 			move.l	A1, (SP)			; fix gdHandle on stack
 			move.l	(A1), A1			; point to the device
@@ -506,8 +474,8 @@ DrawSBar
 @deviceAndFlagsOk
 
 			clr.l	-(SP)				; flag clear (not drawing to screen)
-			bsr.s	CDefDrawControl		; draw the control									<SM6>
-			bra.s	RestoreDrawingStuff	; cleanup after doing drawing						<SM6>
+			bsr		CDefDrawControl		; draw the control
+			rts
 
 @drawToScreen
 			subq	#4, SP				; room for RgnHandle
@@ -529,7 +497,7 @@ DrawSBar
 			move.l	controlRgn(A6), -(SP)
 			_DisposRgn
 
-			bra		RestoreDrawingStuff	; cleanup after doing drawing						<SM6>
+			rts
 
 
 CDefDrawControl
@@ -669,7 +637,7 @@ SkipDown
 			bsr		SetupColors						;
 			PEA		TempRect						; push the rectangle
 			_EraseRect								; paint the shade on the scroll bar
-			bra.s	DoIndicator						; done drawing background of scroll bar
+			bra		DoIndicator						; done drawing background of scroll bar
 @whiteOutScrollBar
 			PEA		TempRect						; push the rectangle
 			move.l	(A5),A0 						; get grafGlobals
@@ -697,12 +665,12 @@ SkipDown
 
 DoIndicator
 			bsr		IsDisabled				; is it disabled
-			bz.s	FrameCtl				; yes => go frame the control						<SM6>
+			bz		FrameCtl				; yes => go frame the control
 
 			move.l	IndicatorRect(A6),TempRect
 			move.l	IndicatorRect+4(A6),TempRect+4
 			tst.b	shaded(a6)				; is it shaded
-			bnz.s	@drawShadedThumb		; yes => handle shaded thumb						<SM6>
+			bnz		@drawShadedThumb		; yes => handle shaded thumb
 			
 			move.l	#$FFFF0000,d0			; Inset height
 			tst.w	isHoriz(a6)				; Horizontal thumb?
@@ -797,7 +765,7 @@ DrawArrowBox
 			tst.b	shaded(a6)			; If we’re drawing in black and white, then
 			bz.s	@bwScrollBar		; it doesn’t matter if we’re disabled or not.
 			
-			bsr.s	IsDisabled			; If disabled & drawing in colour,						<SM6>
+			bsr		IsDisabled			; If disabled & drawing in colour,
 			bnz.s	@notDisabled		; use black and white arrows to draw.
 			
 ; Set up colours to match faint gray used in body of scroll bar
@@ -847,7 +815,7 @@ IsDisabled
 			move.l	(A3),A0 			; get sBar pointer
 			move.w	ContrlMin(A0),D0	; get the min
 			cmp.w	ContrlMax(A0),D0	; same as the max?
-			beq.s	doneChecking		;														<SM6>
+			beq		doneChecking
 			move.b	ContrlHilite(A0),D0 ; get the hilite parameter
 			addQ.b	#1,D0				; was it	255?
 doneChecking
@@ -1093,7 +1061,7 @@ GetIndRgn
 ; the whole region was requested
 
 CalcWholeSBar
-			move.l	#1, ProcResult(A6)	; return 1 to show that we respond				<V1.2>
+			move.b	#1, ProcResult+3(A6); return 1 to show that we respond				<V1.2>
 GetWholeRgn
 			move.l	D3,-(SP)			; push the region handle
 			PEA 	ContrlRect(A0)		; push rectangle	pointer
@@ -1101,7 +1069,7 @@ GetWholeRgn
 			rts 						; all done!
 
 CalcThumbSBar
-			move.l	#1, ProcResult(A6)	; return 1 to show that we respond				<V1.2>
+			move.b	#1, ProcResult+3(A6); return 1 to show that we respond				<V1.2>
 			BRA.s	GetIndRgn			;												<V1.2>
 
 PlotLtGray
@@ -1112,13 +1080,13 @@ PlotLtGray
 			beq.s	@useOldStyle		; no => fill using black on white
 			move.w	#wHiliteShade8,D0	; use a dark gray for dots in pattern
 			move.w	#cArrowShade2,D1	; use a light gray for the background
-			bra.s	@plotPAT			;												<SM6>
+			bra		@plotPAT
 @useOldStyle
 			move.w	#cFrameColor,D0		; black foreground
 			move.w	#cBodyColor,D1		; white background
 @plotPAT
 			bsr		SetupColors			; set up the foreground and background colors
-			bsr.s	GetOldStyleLtGray	; use common routine to get the PAT				<SM6>
+			bsr		GetOldStyleLtGray	; use common routine to get the PAT
 			move.l	(A0),-(SP)			; dereference to get PatPtr
 			_FillRect					; fill the rect
 @doneGetLtGray
@@ -1534,7 +1502,7 @@ SetupRatioColor
 			move.l	(A0)+, endRGB(A6)					; copy red and green
 			move.w	(A0), endRGB+4(A6)					; copy blue
 			move.w	(SP)+, D2							; get shade percentage
-			bsr		MakeRatioRGB						; create a shade between the two		<SM6>
+			bsr		MakeRatioRGB						; create a shade between the two
 			rts
 
 ; ================================================
@@ -1645,8 +1613,7 @@ SetupColorPict
 			subq.l	#4, SP								; room for the PicHandle
 			move.l	#'pixs', -(SP)
 			move.w	d0, -(SP)							; push the resource ID
-			move.w	#MapTrue,RomMapInsert				;									<SM2> rb
-			_GetResource								; look in ROM first					<SM2> rb
+			_GetResource
 			move.l	(SP)+, A0							; pixels handle
 			_HLock										; don’t want it to move
 			move.l	A0, tempPixels(A6)					; save for dispose
@@ -1726,8 +1693,6 @@ AdjustRect
 ; <26> The following routine is used to draw the outline of the thumb during dragging.
 DrawThumbOutline
 
-				bsr		InitDrawingStuff				; initialize the drawing environment	<SM6>
-
 	IF NOT forROM THEN
 				subq.l	#4,sp							; get a new rgn
 				_NewRgn
@@ -1747,7 +1712,7 @@ DrawThumbOutline
 				_DisposRgn
 	ENDIF
 				ST		ProcResult(a6)
-				bra		RestoreDrawingStuff				; cleanup after doing drawing			<SM6>
+				rts
 
 
 ; <26> The following routine is for drawing of the outline of a dragged thumb.
@@ -1791,7 +1756,7 @@ ThumbDrawRoutine
 			_FrameRect
 		ENDIF
 
-		bra.s		@doneDrawThumb				;												<SM6>
+		bra			@doneDrawThumb
 @colorWindow									; yes => use the HiliteMode
 		bsr			SetupWMgrCPort
 		move.w		#hilite,-(sp)					; set HiliteMode

--- a/Toolbox/DiskInit/DiskInitBadBlock.c
+++ b/Toolbox/DiskInit/DiskInitBadBlock.c
@@ -98,10 +98,6 @@
 #include <HFSDefs.h>
 #include <Disks.h>
 
-typedef	unsigned long	ulong;				/* idiosyncrasy of the author */
-typedef	unsigned short	ushort;
-typedef	unsigned char	uchar;
-
 #define	BUFSIZE		18				/* test buffer size, in sectors (mb >=18) */ 
 							/* 18 is bad 'cause it's greater than a track (KSCT) */
 #define	CLUMP		1				/* coallesce badspots only if they are contig */

--- a/Toolbox/ListMgr/TextLDEF.a
+++ b/Toolbox/ListMgr/TextLDEF.a
@@ -21,7 +21,6 @@
 ;	Change History (most recent first):
 ;
 ;	   <SM4>	 11/5/92	SWC		Changed PackMacs.a->Packages.a.
-;		<SM3>	10/14/92	CSS		Change some branch short instructions to word branches.
 ;		<11>	 2/26/92	DTY		#1018596: When calculating the pen position to start drawing the
 ;									text for a cell, take teSysJust into account for right-left
 ;									systems. If teSysJust is non zero, compute the pen position from
@@ -209,7 +208,7 @@ ListDraw
 				MOVE.W		D3,-(SP)			; length of text
 				_TextWidth
 				CMP.W		(SP),D7				; will string fit? <11> Leave width on stack
-				BGE 		@noTruncate			; yes, no need to truncate <SM3> CSS 
+				BGE.S 		@noTruncate			; yes, no need to truncate
 
 				addq		#2,sp				; <11> Width isn’t needed til after truncation.  Lose it.
 				

--- a/Toolbox/MenuMgr/MenuMgr.a
+++ b/Toolbox/MenuMgr/MenuMgr.a
@@ -408,6 +408,11 @@ GetParamRamData	PROC	ENTRY
 				rts
 				ENDPROC
 
+InsrtResMenu proc export
+	nop
+	nop
+	nop
+
 InitProcMenu	PROC	EXPORT
 ; Begin <2.3 EMT>
 

--- a/Toolbox/MenuMgr/MenuMgrPatch.a
+++ b/Toolbox/MenuMgr/MenuMgrPatch.a
@@ -70,7 +70,8 @@
 		endif											; <12>
 	endif												; <12>
 	
-			load		'StandardEqu.d'
+			include		'MenuMgr.a'
+
 			include		'LinkedPatchMacros.a'
 			include		'ScriptPriv.a'					; <13>
 
@@ -103,8 +104,6 @@
 			MakePatch	DelMenuItem,$A952
 			MakePatch	MenuChoice,_MenuChoice,(Plus,SE,Portable)
 
-			include		'MenuMgr.a'
-
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 ;	SetClipForCallDrawMDEF
 ;

--- a/Toolbox/MenuMgr/StandardMBDF.a
+++ b/Toolbox/MenuMgr/StandardMBDF.a
@@ -10,7 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<SM3>	10/22/92	CSS		Change some branch short instructions to word branches.
 ;		<49>	 4/30/92	DTY		#1027995 <KSM>: SetTitleColor expects a4 to point to a MenuInfo
 ;									record on entry. The BannerMsg routine calls SetTitleColor
 ;									without setting up a4. This kinda makes sense, since the menu
@@ -826,7 +825,7 @@ SkipSysLoop
 DONEDRAWMLOOP
 				BSR		ClipMBar				; Restore the clip to the whole menu bar <10>
 				move	saveD3(a6), d0			; get savedID of hilited menu			<FJL A428>
-				beq 	DrawDone				; branch if none						<FJL A428> <SM3> CSS 
+				beq.s	DrawDone				; branch if none						<FJL A428>
 				move	d0,d3					; and put it in d3 too					<FJL A428>
 				bsr		GetTitleRect			; get selected title's rect				<FJL A428>
 				move.l	menuOH(a3,d3),a0		; get selected menuHandle				<FJL A428>
@@ -1468,7 +1467,7 @@ CalcBar
 				MOVE.L	SystemMenuList, A0		; Get system menulist
 				MOVE.L	(A0), A1				; deref system menulist handle
 				TST.W	lastMenu(A1)			; Are there any system menus?
-				BEQ 	SystemMenusAreIN		; Well, there aren't any -- so they are all in! <SM3> CSS 
+				BEQ.S	SystemMenusAreIN		; Well, there aren't any -- so they are all in!
 
 				BSR		FindFirstSystemMenu6BO	; See if the system menus are in.
 				BNE.S	SystemMenusAreIN		; Yes, they are (D0 is offset to 1st one)
@@ -1721,7 +1720,7 @@ HiliteBar
 				BSR		ClipMBar				;								<EMT S297>
 
 				MOVE.W	param2+2(A6),D0			; get the hilite selector
-				BEQ	FlipBar						; if index = 0 then flip bar		<FJL C175><35> <SM3> CSS 
+				BEQ.S	FlipBar						; if index = 0 then flip bar		<FJL C175><35>
 
 				CMP.W	#1,param2(a6)			; hi-word has hilite
 				BGT.S	DoneHilite				; if not in range we support then bye-bye

--- a/Toolbox/MenuMgr/StandardMDEF.a
+++ b/Toolbox/MenuMgr/StandardMDEF.a
@@ -11,15 +11,7 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	 12/7/92	CSS		Update from Reality:
-;									<64> 12/4/92 KSM	Don't call DisposHandle if NIL upon exiting even though the call
-;														can handle it. It wastes time and inhibits debugging other
-;														things.
 ;	   <SM3>	 11/5/92	SWC		Changed PackMacs.a->Packages.a.
-;	   <SM2>	10/16/92	RB		Removed SOME of the NOT forROM conditionals, since some of that
-;									code did not make sense anymore for SuperMario ROMs. This fixed
-;									the disabled menu items not being drawn in gray color instead of
-;									gray pattern.
 ;		<63>	 8/22/91	KSM		csd,#Bruges: fix font/face cleanup problem in script systems.
 ;		<62>	 3/26/91	KSM		rlc,#85632: Reset the font back to the default after script
 ;									changed it.
@@ -442,9 +434,7 @@ MDEFSaveReg	REG		D3-D7/A2-A4
 			move.l	a3, a0				; get menuHandle
 			_HUnlock					; and unlock it before we leave
 
-			move.l	arrowHandle(a6),d0	; the arrow handle or NIL					<48><64>
-			beq.s	@skipDispose		; Don't bother if already NIL				<64>
-			move.l	d0,a0				; Get ready for DisposeHandle				<64>
+			move.l	arrowHandle(a6),a0	; the arrow handle							<48>
 			_DisposeHandle				; DisposeHandle can deal with NIL			<48>
 @skipDispose
 
@@ -1933,7 +1923,7 @@ DrawDash
 			BRA		DoneDrawItem		; dive	back into mainstream
 
 NotDash
-	;	IF NOT forROM THEN				; only do this for System builds, not ROMs				<33><SM2> rb
+		IF NOT forROM THEN				; only do this for System builds, not ROMs				<33>
 			TST.B	onColorMachine(a6)	; on color machine?
 			BEQ.S	@skipPenMode		; no, skip _TextMode
 			TST.B	enableState(a6)		;										<34>
@@ -1942,7 +1932,7 @@ NotDash
 			MOVE.W	D0,-(SP)
 			_TextMode
 @skipPenMode							; <51=BRC#79297>
-	;	ENDIF							; { NOT forROM }										<33><SM2> rb
+		ENDIF							; { NOT forROM }										<33>
 
 			ADDQ.W	#2, D5				; Add the 2 pixels here instead				<S550	27Jul88	EMT>
 
@@ -2299,16 +2289,16 @@ DRAWITEXT
 
 			TST.B	enableState(A6)		; If enabled, don’t bitclear or reset textmode
 			BNE.S	DoneDrawItem
-	;IF (not forROM) THEN																		<SM2> rb
+	IF (not forROM) THEN
 			TST.B	onColorMachine(A6)	; If color, we drew in gray so don’t bitclear
 			BNE.S	@fixcolor
-	;ENDIF																						<SM2> rb
+	ENDIF
 			BSR.S	BitClearItem
-	;IF (not forROM) THEN																		<SM2> rb
+	IF (not forROM) THEN
 @fixColor
 			MOVE.W	#srcOr,-(SP)
 			_TextMode
-	;ENDIF																						<SM2> rb
+	ENDIF
 
 DoneDrawItem
 			bsr		ResetPreviousColors	; restore colors saved in the stackframe <FJL C408>
@@ -2603,7 +2593,7 @@ doneExpand
 ;						This code returns an even multiple of MFHeight if the menu scrolls.
 
 DoCalcMsg
-	;	IF NOT forROM THEN					;									<2.2>	<SM2> rb
+		IF NOT forROM THEN					;									<2.2>
 			BSR.S	PushThePort
 ;			CMP.W	#$3FFF, ROM85			; color machine ?							<PMAB364	23Jan88	EMT>
 			TST.B	onColorMachine(A6)		; color machine ?							<S394	12Feb88	DBG>
@@ -2618,7 +2608,7 @@ DoCalcMsg
 
 @SetPort									;											<PMAB364	23Jan88	EMT>
 			_SetPort						; set it									<PMAB364	23Jan88	EMT>
-	;	ENDIF	; if NOT forROM															<SM2> rb
+		ENDIF	; if NOT forROM
 
 ; since calc msg could be called at any time, we need to reset the wmgr’s textfont here else
 ; could get incorrectly sized menus
@@ -2728,9 +2718,9 @@ DoCalcDone1								; if NIL menu, return 0				<EHB 10-Apr-85>
 ;			CLR.W	-(SP)					; better restore style to normal
 ;			_TextFace						; set the style
 
-	;	IF NOT forROM THEN					; <2.2>										<SM2> rb
+		IF NOT forROM THEN					; <2.2>
 			_SetPort						; restore original grafPort					<PMAB364	23Jan88	EMT>
-	;	ENDIF	; if NOT forROM															<SM2> rb
+		ENDIF	; if NOT forROM
 
 			rts								; all done! so return to dispatcher
 

--- a/Toolbox/ResourceMgr/ResourceMgrExtensions.a
+++ b/Toolbox/ResourceMgr/ResourceMgrExtensions.a
@@ -1989,6 +1989,245 @@ MakeOverrideMap	Proc	Export
 				jmpROM	RStdExit						; <25> rb
 				EndProc
 				
+;____________________________________________________________________________________________________
+; StdDirIDExit
+;
+; This is a way out of Resource Mgr patches that clears the dirID global.
+; It does very little of what StdExit in the Resource Manager does:
+; For example, it does not restore saved registers.
+
+StdDirIDExit	PROC	EXPORT
+
+		move.l	ExpandMem,a0			; point to extended low-memory
+		clr.l	ExpandMemRec.resourceMgrDirID(a0)	; get rid of special dirID (done in StdExit on newer ROMs)
+
+		move.l	(sp)+,a0				; get return address in A0
+		add.l	d0,sp					; pop off parameters
+		jmp		(a0)					; return
+
+		endproc	
+	
+	
+	
+	
+;____________________________________________________________________________________________________
+; CreateResFile(fileName: Str255);
+
+CreateResFileDirIDExit PatchProc	_CreateResFile,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		move.l	4(sp),-(sp)				; pass file name
+	If forRom Then													; <2> kc.start
+		Import	CreateResFile
+		jsr		CreateResFile
+	Else
+		jsrOld							; create resource file
+	Endif															; <2> kc.end
+
+		moveq	#4,d0					; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; HCreateResFile(vRefNum: INTEGER; dirID: LONGINT; fileName: Str255);
+; This procedure needs to be named differently to get linked into LinkedPatches.rsrc by LinkPatch.
+
+CreateDirIDResFile PatchProc	_HCreateResFile,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		move.l	ExpandMem,a0			; point to extended low-memory
+		move.l	4+4(sp),ExpandMemRec.resourceMgrDirID(a0)	; jam in the dirID
+
+		move.w	4+4+4(sp),d0			; get the vRefNum
+
+		move.l	4(sp),-(sp)				; pass file name
+		pea		ReturnHere				; start doing a CreateResFile
+		jsrROM	StdZEntry				; save registers, etc. (D0 is saved across this call)
+		move.w	d0,ioStkFrame+ioVRefNum(a6)	; stuff vRefNum into parameter block
+		jmpROM	AfterStdZEntryInCreateResFile	; join CreateResFile
+ReturnHere
+
+		moveq	#4+4+2,d0				; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; OpenResFile(fileName: Str255): INTEGER;
+
+OpenResFileDirIDExit PatchProc	_OpenResFile,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		subq	#2,sp					; make room for result
+		move.l	2+4(sp),-(sp)			; pass file name
+	If forRom Then													; <2> kc.start
+		Import	OpenResFile
+		jsr		OpenResFile
+	Else
+		jsrOld							; open resource file
+	Endif															; <2> kc.end
+		move.w	(sp)+,4+4(sp)			; propagate result out
+
+		moveq	#4,d0					; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; OpenRFPerm(fileName: Str255; vRefNum: INTEGER; permission: SignedByte): INTEGER;
+
+OpenRFPermDirIDExit PatchProc	_OpenRFPerm,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		subq	#2,sp					; make room for result
+		move.l	2+4+2+2(sp),-(sp)		; pass file name
+		move.w	4+2+4+2(sp),-(sp)		; pass vRefNum
+		move.b	2+4+2+4(sp),-(sp)		; pass permission
+
+		jsrOld							; open resource file
+
+		move.w	(sp)+,4+2+2+4(sp)		; propagate result out
+
+		moveq	#2+2+4,d0				; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; HOpenResFile(vRefNum: INTEGER; dirID: LONGINT; fileName: Str255; permission: SignedByte): INTEGER;
+; This procedure needs to be named differently to get linked into LinkedPatches.rsrc by LinkPatch.
+
+OpenDirIDResFile PatchProc	_HOpenResFile,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		move.l	ExpandMem,a0			; point to extended low-memory
+		move.l	4+2+4(sp),ExpandMemRec.resourceMgrDirID(a0)	; jam in the dirID
+
+		subq	#2,sp					; make room for result
+		move.l	2+4+2(sp),-(sp)			; pass file name
+		move.w	4+2+4+2+4+4(sp),-(sp)	; pass vRefNum
+		move.b	2+4+2+4(sp),-(sp)		; pass permission
+		jsrROM	ROMOpenRFPerm			; open resource file
+		move.w	(sp)+,4+2+4+4+2(sp)		; propagate result out for HOpenResFile
+
+		moveq	#2+4+4+2,d0				; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; patch to Create to use dirID
+;
+; This patch should only apply to the Create call in CreateResFile.
+; Since come-from patches are a pain, instead we assume that the “resourceMgrDirID”
+; global will be zero, except for some cases when Create is called from CreateResFile.
+;
+; Come-from patches are now cake with linked patches, so this routine has been changed into
+; a proper come-from patch.  <2>  DTY 6/27/90
+
+
+NewCreate ComeFromPatchProc	_Create,AfterCreateInCreateResFile,(Plus,SE,II,Portable,IIci)
+		move.l	a0,-(sp)				; save pointer to the old parameter block
+
+		sub		#ioHQElSize,sp			; make room for new parameter block
+
+		move.l	ioFileName(a0),ioFileName(sp)	; use the same file name
+		move.w	ioVRefNum(a0),ioVRefNum(sp)		; use the same vRefNum
+		move.b	ioFileType(a0),ioFileType(sp)	; use the same “file type”
+		move.l	ExpandMem,a1					; point to extended low-memory
+		move.l	ExpandMemRec.resourceMgrDirID(a1),d0	; get the dirID
+		move.l	d0,ioDirID(sp)					; put in the dirID
+
+		move.l	sp,a0					; use the new parameter block
+		or.w	#newHFS,d1				; set the HFS bit in the trap word (passed by dispatcher)
+		jsrOld							; Call old _Create
+
+		add		#ioHQElSize,sp			; get rid of the parameter block
+
+		move.l	(sp)+,a0				; get pointer to the old parameter block
+		move.w	d0,ioResult(a0)			; put result in the old parameter block
+
+		rts
+
+		endproc
+
+;____________________________________________________________________________________________________
+; patch to OpenRF to use dirID
+;
+; This patch should only apply to the OpenRF call in ORFCommon.
+; Since come-from patches are a pain, instead we assume that the “resourceMgrDirID”
+; global will be zero, except for some cases when OpenRF is called from ORFCommon.
+;
+; Come-from patches are now cake with linked patches, so this routine has been changed into
+; a proper come-from patch.  <2>  DTY 6/27/90
+
+NewOpenRF ComeFromPatchProc	_OpenRF,AfterOpenRFInORFCommon,(Plus,SE,II,Portable,IIci)
+		move.l	a0,-(sp)				; save pointer to the old parameter block
+
+		sub		#ioHQElSize,sp			; make room for new parameter block
+
+		move.l	ExpandMem,a1			; point to extended low-memory
+		move.l	ExpandMemRec.resourceMgrDirID(a1),d0	; get the dirID
+		move.l	d0,ioDirID(sp)			; put in the dirID
+
+		move.l	ioFileName(a0),ioFileName(sp)	; use the same file name
+		move.w	ioVRefNum(a0),ioVRefNum(sp)		; use the same vRefNum
+		move.b	ioFileType(a0),ioFileType(sp)	; use the same “file type”
+		move.b	ioPermssn(a0),ioPermssn(sp)		; use the same permissions
+		move.l	ioOwnBuf(a0),ioOwnBuf(sp)		; and the same file buffer
+
+		move.l	sp,a0					; use the new parameter block
+		or.w	#newHFS,d1				; set the HFS bit in the trap word (passed by dispatcher)
+		jsrOld							; Call old _OpenRF routine
+
+		move.w	ioRefNum(sp),d1			; get the refNum result into a register
+
+		add		#ioHQElSize,sp			; get rid of the parameter block
+
+		move.l	(sp)+,a0				; get pointer to the old parameter block
+		move.w	d0,ioResult(a0)			; put result in the old parameter block
+		move.w	d1,ioRefNum(a0)			; put refNum in the old parameter block
+
+		rts
+
+		endproc
+
+;____________________________________________________________________________________________________
+; Un-implement (de-announce) _AddReference and _RmveReference traps
+
+InstallResourceMgrExtensions	InstallProc	(Plus,SE,II,Portable,IIci)
+
+		move.w	#$9f,d0
+		_GetTrapAddress newTool			; get the address of the Unimplemented trap
+		move.w	#$1AC,d0
+		_SetTrapAddress newTool			; nuke AddReference
+		move.w	#$1AE,d0
+		_SetTrapAddress newTool			; nuke RmveReference
+
+		rts
+
+		EndProc
+
+;____________________________________________________________________________________________________
+; patch to _SetEOF inside CheckGrow to check for resource file too large
+;
+; CheckGrow is called by AddResource, ChangedResource, SetResInfo, and (more or less) by
+; SetResourceSize above. It calls _SetEOF to grow the file to accomodate these operations.
+; Unfortunately, while the File Mgr supports files > 16 meg, the Resource Mgr does not.
+; This patch checks if the size passed to _SetEOF is too big, and returns eofErr (for lack of
+; a better error) in this case.
+
+ValidateFileSizeInCheckGrow ComeFromPatchProc _SetEOF,AfterSetEOFInCheckGrow,(Plus,SE,II,Portable,IIci)
+	
+		tst.b	(a1)					; get new size of file set up by CheckGrow (a1 points to ioLEOF inside param block)
+										; note: 16 meg = $01000000, so if any bits are set in first byte it’s >= 16 meg
+		beqOld							; no, grow the file as usual
+		move.w	#eofErr,d0				; yes, return an error (not really an eofErr, but it is the end of the resource fork)
+		rts
+
+		endproc
+
 ;____________________________________________________________________________________________________
 ; InsertOverrideMap(overrideMap, mapToOverride: Handle);
 ;

--- a/Toolbox/ResourceMgr/ResourceMgrPatches.a
+++ b/Toolbox/ResourceMgr/ResourceMgrPatches.a
@@ -775,247 +775,6 @@ MyGetResource	PatchProc	_GetResource,(Plus,SE,II,Portable,IIci)
 		EndProc
 
 	endif
-;____________________________________________________________________________________________________
-; StdDirIDExit
-;
-; This is a way out of Resource Mgr patches that clears the dirID global.
-; It does very little of what StdExit in the Resource Manager does:
-; For example, it does not restore saved registers.
-
-StdDirIDExit	PROC	EXPORT
-
-		move.l	ExpandMem,a0			; point to extended low-memory
-		clr.l	ExpandMemRec.resourceMgrDirID(a0)	; get rid of special dirID (done in StdExit on newer ROMs)
-
-		move.l	(sp)+,a0				; get return address in A0
-		add.l	d0,sp					; pop off parameters
-		jmp		(a0)					; return
-
-		endproc	
-	
-	
-	
-	
-;____________________________________________________________________________________________________
-; CreateResFile(fileName: Str255);
-
-CreateResFileDirIDExit PatchProc	_CreateResFile,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		move.l	4(sp),-(sp)				; pass file name
-	If forRom Then													; <2> kc.start
-		Import	CreateResFile
-		jsr		CreateResFile
-	Else
-		jsrOld							; create resource file
-	Endif															; <2> kc.end
-
-		moveq	#4,d0					; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; HCreateResFile(vRefNum: INTEGER; dirID: LONGINT; fileName: Str255);
-; This procedure needs to be named differently to get linked into LinkedPatches.rsrc by LinkPatch.
-
-CreateDirIDResFile PatchProc	_HCreateResFile,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		move.l	ExpandMem,a0			; point to extended low-memory
-		move.l	4+4(sp),ExpandMemRec.resourceMgrDirID(a0)	; jam in the dirID
-
-		move.w	4+4+4(sp),d0			; get the vRefNum
-
-		move.l	4(sp),-(sp)				; pass file name
-		pea		ReturnHere				; start doing a CreateResFile
-		jsrROM	StdZEntry				; save registers, etc. (D0 is saved across this call)
-		move.w	d0,ioStkFrame+ioVRefNum(a6)	; stuff vRefNum into parameter block
-		jmpROM	AfterStdZEntryInCreateResFile	; join CreateResFile
-ReturnHere
-
-		moveq	#4+4+2,d0				; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; OpenResFile(fileName: Str255): INTEGER;
-
-OpenResFileDirIDExit PatchProc	_OpenResFile,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		subq	#2,sp					; make room for result
-		move.l	2+4(sp),-(sp)			; pass file name
-	If forRom Then													; <2> kc.start
-		Import	OpenResFile
-		jsr		OpenResFile
-	Else
-		jsrOld							; open resource file
-	Endif															; <2> kc.end
-		move.w	(sp)+,4+4(sp)			; propagate result out
-
-		moveq	#4,d0					; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; OpenRFPerm(fileName: Str255; vRefNum: INTEGER; permission: SignedByte): INTEGER;
-
-OpenRFPermDirIDExit PatchProc	_OpenRFPerm,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		subq	#2,sp					; make room for result
-		move.l	2+4+2+2(sp),-(sp)		; pass file name
-		move.w	4+2+4+2(sp),-(sp)		; pass vRefNum
-		move.b	2+4+2+4(sp),-(sp)		; pass permission
-
-		jsrOld							; open resource file
-
-		move.w	(sp)+,4+2+2+4(sp)		; propagate result out
-
-		moveq	#2+2+4,d0				; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; HOpenResFile(vRefNum: INTEGER; dirID: LONGINT; fileName: Str255; permission: SignedByte): INTEGER;
-; This procedure needs to be named differently to get linked into LinkedPatches.rsrc by LinkPatch.
-
-OpenDirIDResFile PatchProc	_HOpenResFile,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		move.l	ExpandMem,a0			; point to extended low-memory
-		move.l	4+2+4(sp),ExpandMemRec.resourceMgrDirID(a0)	; jam in the dirID
-
-		subq	#2,sp					; make room for result
-		move.l	2+4+2(sp),-(sp)			; pass file name
-		move.w	4+2+4+2+4+4(sp),-(sp)	; pass vRefNum
-		move.b	2+4+2+4(sp),-(sp)		; pass permission
-		jsrROM	ROMOpenRFPerm			; open resource file
-		move.w	(sp)+,4+2+4+4+2(sp)		; propagate result out for HOpenResFile
-
-		moveq	#2+4+4+2,d0				; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; patch to Create to use dirID
-;
-; This patch should only apply to the Create call in CreateResFile.
-; Since come-from patches are a pain, instead we assume that the “resourceMgrDirID”
-; global will be zero, except for some cases when Create is called from CreateResFile.
-;
-; Come-from patches are now cake with linked patches, so this routine has been changed into
-; a proper come-from patch.  <2>  DTY 6/27/90
-
-
-NewCreate ComeFromPatchProc	_Create,AfterCreateInCreateResFile,(Plus,SE,II,Portable,IIci)
-		move.l	a0,-(sp)				; save pointer to the old parameter block
-
-		sub		#ioHQElSize,sp			; make room for new parameter block
-
-		move.l	ioFileName(a0),ioFileName(sp)	; use the same file name
-		move.w	ioVRefNum(a0),ioVRefNum(sp)		; use the same vRefNum
-		move.b	ioFileType(a0),ioFileType(sp)	; use the same “file type”
-		move.l	ExpandMem,a1					; point to extended low-memory
-		move.l	ExpandMemRec.resourceMgrDirID(a1),d0	; get the dirID
-		move.l	d0,ioDirID(sp)					; put in the dirID
-
-		move.l	sp,a0					; use the new parameter block
-		or.w	#newHFS,d1				; set the HFS bit in the trap word (passed by dispatcher)
-		jsrOld							; Call old _Create
-
-		add		#ioHQElSize,sp			; get rid of the parameter block
-
-		move.l	(sp)+,a0				; get pointer to the old parameter block
-		move.w	d0,ioResult(a0)			; put result in the old parameter block
-
-		rts
-
-		endproc
-
-;____________________________________________________________________________________________________
-; patch to OpenRF to use dirID
-;
-; This patch should only apply to the OpenRF call in ORFCommon.
-; Since come-from patches are a pain, instead we assume that the “resourceMgrDirID”
-; global will be zero, except for some cases when OpenRF is called from ORFCommon.
-;
-; Come-from patches are now cake with linked patches, so this routine has been changed into
-; a proper come-from patch.  <2>  DTY 6/27/90
-
-NewOpenRF ComeFromPatchProc	_OpenRF,AfterOpenRFInORFCommon,(Plus,SE,II,Portable,IIci)
-		move.l	a0,-(sp)				; save pointer to the old parameter block
-
-		sub		#ioHQElSize,sp			; make room for new parameter block
-
-		move.l	ExpandMem,a1			; point to extended low-memory
-		move.l	ExpandMemRec.resourceMgrDirID(a1),d0	; get the dirID
-		move.l	d0,ioDirID(sp)			; put in the dirID
-
-		move.l	ioFileName(a0),ioFileName(sp)	; use the same file name
-		move.w	ioVRefNum(a0),ioVRefNum(sp)		; use the same vRefNum
-		move.b	ioFileType(a0),ioFileType(sp)	; use the same “file type”
-		move.b	ioPermssn(a0),ioPermssn(sp)		; use the same permissions
-		move.l	ioOwnBuf(a0),ioOwnBuf(sp)		; and the same file buffer
-
-		move.l	sp,a0					; use the new parameter block
-		or.w	#newHFS,d1				; set the HFS bit in the trap word (passed by dispatcher)
-		jsrOld							; Call old _OpenRF routine
-
-		move.w	ioRefNum(sp),d1			; get the refNum result into a register
-
-		add		#ioHQElSize,sp			; get rid of the parameter block
-
-		move.l	(sp)+,a0				; get pointer to the old parameter block
-		move.w	d0,ioResult(a0)			; put result in the old parameter block
-		move.w	d1,ioRefNum(a0)			; put refNum in the old parameter block
-
-		rts
-
-		endproc
-
-;____________________________________________________________________________________________________
-; Un-implement (de-announce) _AddReference and _RmveReference traps
-
-InstallResourceMgrExtensions	InstallProc	(Plus,SE,II,Portable,IIci)
-
-		move.w	#$9f,d0
-		_GetTrapAddress newTool			; get the address of the Unimplemented trap
-		move.w	#$1AC,d0
-		_SetTrapAddress newTool			; nuke AddReference
-		move.w	#$1AE,d0
-		_SetTrapAddress newTool			; nuke RmveReference
-
-		rts
-
-		EndProc
-
-;____________________________________________________________________________________________________
-; patch to _SetEOF inside CheckGrow to check for resource file too large
-;
-; CheckGrow is called by AddResource, ChangedResource, SetResInfo, and (more or less) by
-; SetResourceSize above. It calls _SetEOF to grow the file to accomodate these operations.
-; Unfortunately, while the File Mgr supports files > 16 meg, the Resource Mgr does not.
-; This patch checks if the size passed to _SetEOF is too big, and returns eofErr (for lack of
-; a better error) in this case.
-
-ValidateFileSizeInCheckGrow ComeFromPatchProc _SetEOF,AfterSetEOFInCheckGrow,(Plus,SE,II,Portable,IIci)
-	
-		tst.b	(a1)					; get new size of file set up by CheckGrow (a1 points to ioLEOF inside param block)
-										; note: 16 meg = $01000000, so if any bits are set in first byte it’s >= 16 meg
-		beqOld							; no, grow the file as usual
-		move.w	#eofErr,d0				; yes, return an error (not really an eofErr, but it is the end of the resource fork)
-		rts
-
-		endproc
-
-;____________________________________________________________________________________________________
-
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 ;	STILL TO DO

--- a/Toolbox/ResourceMgr/ResourceOverridePatches.a
+++ b/Toolbox/ResourceMgr/ResourceOverridePatches.a
@@ -203,6 +203,10 @@
 ;									implemented.
 ;		 <1>	10/17/91	DTY		first checked in
 
+	IF &TYPE('PrNonPortable') = 'UNDEFINED' THEN
+		PrNonPortable: EQU 1
+	ENDIF
+
 			include		'Traps.a'
 			include		'SysEqu.a'
 			include		'SysErr.a'

--- a/Toolbox/ScriptMgr/International.r
+++ b/Toolbox/ScriptMgr/International.r
@@ -646,7 +646,7 @@
 
 	resource 'STR#' (kKeybdMenuItemsID, sysHeap, purgeable) { {			// strings for menu items			<x121><25>
 		"\0x00";														// marker for default keybd			<2><9>
-		"About Keyboards";												//									<2><23>
+		"About Keyboards…";												//									<2><23>
 //		"Next Script";													// currently not used
 //		"Next Keyboard in Script";										// currently not used
 	} };
@@ -740,7 +740,7 @@
 			{14, 15, 46, 447},
 			StaticText {
 				disabled,
-				"About Keyboards"										//	<23>
+				"About Keyboards…"										//	<23>
 			}
 		}
 	};
@@ -763,7 +763,7 @@
 			{14, 17, 44, 422},
 			StaticText {
 				disabled,
-				"About Keyboards"										//	<23>
+				"About Keyboards…"										//	<23>
 			}
 		}
 	};
@@ -792,7 +792,7 @@
 			{14, 15, 46, 447},
 			StaticText {
 				disabled,
-				"About Keyboards"					
+				"About Keyboards…"					
 			}
 		}
 	};

--- a/Toolbox/ScriptMgr/ScriptMgrInit.a
+++ b/Toolbox/ScriptMgr/ScriptMgrInit.a
@@ -13,28 +13,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM11>	 5/27/93	CSS		Don't initialize emNumer and emDenom because these are obsolete
-;									fields.
-;	  <SM10>	 5/21/93	CSS		Initialize some expandmem: emNumer, emDenom, emScriptAppGlobals
-;									from ScriptMgrExtTail.a.
-;	   <SM9>	 5/21/93	CSS		Rollin from Reality:
-;		<33>	 5/19/93	PKE		#1086200: Change roman dispatch table initialization to handle
-;									nil entries in romanDispTable by setting the corresponding
-;									dispatch table entry to be nil. Then make nil entries in
-;									romanDispTable for IsSpecialFont and RawPrinterValues for ROM
-;									builds.
-;	   <SM8>	 1/27/93	CSS		Rollin fix to auto-install scripts. This fix loads the itlb
-;									resource for each script an determines if the auto-install bit
-;									(for simple scripts) is set. If it is this patch installs the
-;									script. This fixes a bug Radar#1060646 "WorldScript I and/or
-;									Cyrillic does not work correctly." Wherein, the Cyrillic script
-;									was not installing. Also, fixed the vectors for getscript and
-;									setscript for roman scripts to call the new routines
-;									"RomanGetScript" and "RomanSetScript." This is per Radar bug
-;									#1025998.
-;	   <SM7>	12/15/92	CSS		Look for dictionary manager in ROM.
-;	   <SM6>	11/19/92	RB		When looking for the standard Chicago font, look in ROM first.
-;	   <SM5>	 10/2/92	PN		Add initDictionary to the initialization process
 ;		<32>	 6/17/92	HA		#1029756,<PKE>: Removing StyledlineBreak  to
 ;									ScriptMgrExtensions.a.
 ;		<31>	 6/12/92	FM		More changes to bring the rom build up to date with system 7
@@ -654,11 +632,8 @@ BootConf
 		move.w	#(sisHighCall-smGetScript)/2,d0	; number of entries - 1
 		move.l	a2,-(sp)						; save a2
 @romanTabLoop
-		movea.l	#0,a2							; assume 0 entry in dispatch table		<33>
 		move.w	(a1)+,d1						; get offset from romanDispTable
-		beq.s	@gotAddress						; if 0, leave entry as 0				<33>
 		lea		0(a4,d1.w),a2					; make it a real vector
-@gotAddress										;										<33>
 		move.l	a2,(a0)+						; stuff it in table
 		dbra	d0,@romanTabLoop				; if more, keep going
 		move.l	(sp)+,a2						; restore a2
@@ -669,7 +644,6 @@ BootConf
 		subq	#4,sp							; return room
 		move.l	#'FOND',-(sp)					; see if we have real Chicago
 		move.w	d4,-(sp)						; id
-		MOVE.W	#MapTrue,RomMapInsert			; look in ROM first								<SM6> rb
 		_GetResource
 		tst.l	(sp)+							; was it there?
 		bne.s	@SkipResetFond					; yes, skip
@@ -704,129 +678,6 @@ BadError								;								<05/30/89 pke><9>
 
 RomanDone
 	
-; -----------------------------------------------------------------------------
-; Perform auto-initialization of script	systems based on info in their itlb	 <SM8> CSS
-
-; Skip if Opt-E or Shift														
-		btst	#0,KeyMap+7		; shift key down?								
-		bne		DoneAutoInit	; if yes, skip script install					
-		btst	#2,KeyMap+7		; option key down?								
-		beq.s	@noSkipInstall	; no, skip check.					
-		subq	#2,sp			; make room for Boolean result						
-		move.w	#'e',-(sp)		; push 'e' as the char to test for					
-
-		import	iTestLetter		;													
-		bsr		iTestLetter		; returns TRUE if key with Roman 'e' being pressed	
-
-		tst.b	(sp)+			; what was the result?								
-		bne		DoneAutoInit	; if Opt-e, skip script install						
-@noSkipInstall					;				
-
-; no Opt-E, go ahead
-		with	scriptRecord,itlbRecord,ItlbExtRecord
-		GetSMgrCore	a4							; reset a4 to point to SMgrRecord
-		move.w	#smgrCount-1,d3					; for all entries.
-			
-@SimpleLoopStart
-		move.w	d3,d0							; copy index.
-		lsl.w	#2,d0							; long word offset.
-		move.l	smgrEntry(a4,d0.w),d0			; script installed?
-		bne		@NextSimple						; yes -> try next entry.
-		
-		subq.l	#4,sp							; make room for handle.
-		move.l	#'itlb',-(sp)					; push bundle type.
-		move.w	d3,-(sp)						; push bundle number.
-		_GetResource							; load the resource.
-		move.l	(sp)+,d0						; handle = nil?
-		beq		@NextSimple						; yes -> try next entry.
-
-; we have a prospective itlb, so check if the simple bit is on
-		move.l	d0,a3							; load bundle handle.
-		move.l	(a3),a0							; load bundle pointer.
-		btst.b	#smsfAutoInit,itlbFlags+1(a0)	; auto-init it? (+1 for mem test)
-		beq		@ReleaseSimple					; no, try next one
-
-; we have a simple script, so allocate the record, load the font numbers
-
-		move.l	itlbLocalSize(a0),d0			; requested size for script locals
-		cmp.l	#scriptSize,d0					; must be ≥ ScriptRecord size
-		bcc.s	@doneFixLocalRecordSize			; if it already is, skip fix
-		move.l	#scriptSize,d0					; if too small, fix it
-@doneFixLocalRecordSize
-		_NewPtr	sys,clear						; allocate script local data
-		bne		BadError						; if error, bail
-		move.l	a0,a2							; save entry pointer.
-		move.w	d3,d0							; get script number
-		asl.w	#2,d0							; *4 for long array
-		move.l	a2,smgrEntry(a4,d0.w)			; store in SMgr globals.
-	
-; Use SimpleTable to initialize scriptVersion, scriptCreator, scriptFile instead		
-; of explicitly initializing them here.
-
-; Copy font information from itlb, and check it.
-; For 7.0, this is moved to InitScripts.												
-
-; copy relevant entries from Roman ScriptRecord to simple ScriptRecord
-; a2=simple ScriptRecord
-
-		move.l	smgrEntry+(smRoman*4)(a4),a0	; address of roman globals
-		lea		SimpleTable,a1					; load table pointer.
-@SimpleEntryLoop	
-		move.w	(a1)+,d0						; get offset (and trap code).
-		blt.s	@ReleaseSimple					; last entry is -1.						
-		move.w	0(a0,d0.w),0(a2,d0.w)			; copy Roman word to simple scriptRecord
-		bra.s	@SimpleEntryLoop				; do the next routine.
-
-@ReleaseSimple
-; Don't bother releasing anymore														
-		
-@NextSimple		
-		subq	#1,d3							; don't do Roman
-		bgt.s	@SimpleLoopStart				; keep going until 0 or less
-		bra		DoneAutoInit					; clean exit							
-		endWith									;
-
-; -----------------------------------------------------------------------------
-; Table of ScriptRecord fields to copy from Roman when auto-initializing
-; a script.
-;
-; Moved initialization of scriptVersion, scriptCreator, scriptFile here instead
-; of explicitly initializing them above.
-;
-; Changed terminator to be -1, cause one of the fields we want to initialize
-; with this table has an offset of 0.
-; -----------------------------------------------------------------------------
-
-SimpleTable
-			with	ScriptRecord
-			dc.w	scriptVersion				;								
-			dc.w	scriptCreator				;			
-			dc.w	scriptCreator+2				; (long)						
-			dc.w	scriptFile					;								
-			dc.w	scriptFile+2				; (long)						
-			dc.w	scriptDispTable
-			dc.w	scriptDispTable+2			; (long)
-			dc.w	scriptDispLow
-			dc.w	scriptDispHigh
-			dc.w	scriptPrint
-			dc.w	scriptPrint+2				; (long)
-			dc.w	scriptTrap
-			dc.w	scriptTrap+2				; (long)
-			dc.w	scriptName
-			dc.w	scriptName+2				; (long)
-			dc.w	$ffff						; now -1 is terminato
-			endwith
-
-DoneAutoInit
-
-; -----------------------------------------------------------------------------
-; Update from ScriptMgrExtTail.a <SM10> CSS
-;
-; Initialize emScriptAppGlobals field.
-;
-			move.l	ExpandMem,a0
-			move.l	#-1,ExpandMemRec.emScriptAppGlobals(a0)
-
 SMgrInitDone
 ;Roll in from ScripMgrExtTail.a
 	IF forROM then
@@ -845,27 +696,6 @@ SmgrExit
 
 	endWith
 
-;=======================================================================
-;
-;	InitDictionaryMgr
-;		Called to load the 'dimg' file which contains the 
-;		Dictionary Manager code.  We load the resources stick
-;		them into expand mem, and call it a day.
-;		JH, 10-9-91
-;========================================================================
-
-InitDictionaryMgr
-			with	ExpandMemRec
-			clr.l	-(sp)								;room for our handle
-			move.l	#'dimg',-(sp)						;looking for a 'dimg' resource
-			move.w	#-16385,-(sp)						;with an id of -16385
-			move.w	#MapTrue,RomMapInsert				;check if resource is in ROM (it should be) <SM7> CSS
-			_GetResource								;see if we can get it
-			move.l	ExpandMem,a0						;ptr to expandmem rec into a0
-			move.l	(sp)+,emDictionaryMgrPackHandle(a0)	;move the handle into our expandmem handle
-	;		move.w	#0,emDictionaryMgrUseCount(a0)		;0 our count
-			rts
-			endwith	;ExpandMemRec
 ; -----------------------------------------------------------------------------
 ; Utility routine to allocate and clear global space
 ; (was above BufPtr in old systems)  <10/10/88ldc>
@@ -1125,7 +955,7 @@ utilTable
 		export	romanDispTable
 		import	BitBucket, BitBucketReg
 		
-		import	RomanGetScript, RomanSetScript, CharByte						; <SM8> CSS
+		import	rGetScript, rSetScript, CharByte
 		import	Translit, FindWord, HiliteText
 		import	VisibleLength
 	  IF forRom THEN								;							<21>
@@ -1150,8 +980,8 @@ utilTable
 
 romanDispTable										;							<04/26/89 pke>
 	 IF (NOT forRom) THEN							;							<x2><x4><x10><21>
-		dc.w	RomanGetScript	- romanDispTable	; GetScript		(12)		<x10> <SM8> CSS
-		dc.w	RomanSetScript	- romanDispTable	; SetScript		(14)		<x10> <SM8> CSS
+		dc.w	rGetScript		- romanDispTable	; GetScript		(12)		<x10>
+		dc.w	rSetScript		- romanDispTable	; SetScript		(14)		<x10>
 		dc.w	CharByte		- romanDispTable	; CharByte		(16)
 		dc.w	BitBucket		- romanDispTable	; CharType		(18)		<26>
 		dc.w	BitBucket		- romanDispTable	; Pixel2Char	(20)
@@ -1173,8 +1003,8 @@ romanDispTable										;							<04/26/89 pke>
 		dc.w	BitBucket		- romanDispTable	; NMeasureJust	(52)
 		dc.w	BitBucket		- romanDispTable	; NPortionText	(54)
 	 ELSE
-		dc.w	RomanGetScript	- romanDispTable	; GetScript		(12)		<x10> <SM8> CSS
-		dc.w	RomanSetScript	- romanDispTable	; SetScript		(14)		<x10> <SM8> CSS
+		dc.w	rGetScript		- romanDispTable	; GetScript		(12)		<x10>
+		dc.w	rSetScript		- romanDispTable	; SetScript		(14)		<x10>
 		dc.w	CharByte		- romanDispTable	; CharByte		(16)
 		dc.w	CharType		- romanDispTable	; CharType		(18)		<26>
 		dc.w	Pixel2Char		- romanDispTable	; Pixel2Char	(20)

--- a/Toolbox/ScriptMgr/ScriptMgrMisc.a
+++ b/Toolbox/ScriptMgr/ScriptMgrMisc.a
@@ -12,9 +12,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	 5/21/93	CSS		Delete body of SMgrCalRect as it is obsolete per P. Edberg's
-;									review. Leave an RTS so that the vector here still works.
-;		<SM4>	10/22/92	CSS		Change some branch short instructions to word branches.
 ;		<10>	 6/12/92	FM		Broke out the SMgrpostMunging routine into its own proc, and put
 ;									it here. It used to be in ScriptMgrPatch.a. This way it can be
 ;									used in the rom build without all the unecessary patch code for
@@ -205,7 +202,7 @@ xSwapKybd								; <06/30/89 pke>
 
 		bne.s	@loadItlk					; no - go load itlk. Otherwise…
 		_UseResFile							; restore old resfile (refnum on stack)	<5><6>
-		bra 	DoneKybd					; bail, keep old KCHR & itlk. 			<SM4> CSS 
+		bra.s	DoneKybd					; bail, keep old KCHR & itlk.
 
 @loadItlk
 ; if we already have an itlk, dispose of it											<6>
@@ -463,11 +460,51 @@ DoneEvent
 ; warning:	This routine is a trap patch for InitMenus.
 ;			This routine saves all registers.
 ;
-; This routine is obsolete.
+; This routine calculates the bounds of the menubar icon.
 ; ----------------------------------------------------------------------------
 
+mbarIconPix	equ	16
+
 SMgrCalcRect Proc Export
+		with	SMgrRecord
+
+		movem.l	a2,-(sp)
+		GetSMgrCore a2
+
+		move.w	MBarHeight,d0				; vertical placement
+		lsr.w	#1,d0
+		subq	#mbarIconPix/2,d0
+		move.w	d0,smgrRect+top(a2)
+		add.w	#mbarIconPix,d0
+		move.w	d0,smgrRect+bottom(a2)
+
+		subq	#4,sp
+		move.l	sp,-(sp)
+		_GetWMgrPort
+		move.l	(sp)+,a0
+
+		tst.b	smgrIconSideFlag(a2)		; horizontal placement
+		bnz.s	@iconLeft
+
+@iconRight									; ...on one side...
+		move.w	portRect+right(a0),d0
+		sub.w	smgrIconOffset(a2),d0
+		move.w	d0,smgrRect+right(a2)
+		sub.w	#mbarIconPix,d0
+		move.w	d0,smgrRect+left(a2)
+		bra.s	@return
+@iconLeft									; ...or the other.
+		move.w	portRect+left(a0),d0
+		add.w	smgrIconOffset(a2),d0
+		move.w	d0,smgrRect+left(a2)
+		add.w	#mbarIconPix,d0
+		move.w	d0,smgrRect+right(a2)
+
+@return
+		movem.l	(sp)+,a2
 		rts
+
+		endwith
 		endproc
 
 ; ----------------------------------------------------------------------------

--- a/Toolbox/ScriptMgr/ScriptMgrUtilDate.a
+++ b/Toolbox/ScriptMgr/ScriptMgrUtilDate.a
@@ -14,7 +14,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	11/12/92	PN		Get rid of ≥ 020 conditionals for ROM builds
 ;	   <SM4>	 11/6/92	SWC		Changed PackMacs.a->Packages.a.
 ;		<15>	 6/12/92	FM		remove MacsBug symbols and obsolete smgrKeepMacsBugSymbols
 ;									conditional. Replaced long divisions w/ a macro that uses a
@@ -237,8 +236,12 @@ genCdevRangeHi	equ	$DA319179			; =3660681599, secs for 2019-Dec-31 23:59:59
 		macro
 			LongDiv
 			
-				machine	mc68020
+			IF &SETTING('MACHINE') = 'MC68000' THEN
+				bsr		LongDivFunc
+			ELSE
 				divs.l	d2,d0:d1			; do it
+			ENDIF
+
 			
 		endm
 
@@ -1213,6 +1216,74 @@ RD2SRegs	reg	a2/d3-d7
 	
 
 
+;============================================================================
+;    Arguments: d0:d1 = dividend (u64), d2 = divisor (u32)
+;    Returns: d0 = remainder (u32), d1 = quotient (u32)
+;============================================================================
+
+LongDivFunc	proc	export
+
+		cmp.b	#cpu68020, CPUFlag
+		blt.s	@useSANE
+
+@useDIVS
+		machine	MC68020
+		divs.l	d2,d0:d1
+		rts
+		machine	MC68000
+
+@useSANE
+
+DivRec		record  {oldA6},decr
+return		ds.l    1
+oldA6		ds.l    1
+divisor		ds.l	1
+dividend	ds.d	1
+argBuffer
+float80		ds.x	1
+remultiply	ds.d	1
+quotient	ds.l	1
+localFrame	equ		*
+			endr
+
+		with	DivRec
+
+		link	a6,#localFrame
+
+		lea		argBuffer(a6),a0
+		move.l	d0,(a0)+			; save dividend
+		move.l	d1,(a0)+			; ...
+		move.l	d2,(a0)				; and divisor
+
+		pea		dividend(a6)		; convert to 80-float
+		pea		float80(a6)
+		FC2X
+
+		pea		divisor(a6)			; divide via SANE
+		pea		float80(a6)
+		FDIVL
+
+		pea		float80(a6)			; quotient as long
+		pea		quotient(a6)
+		FX2L
+
+		move.l	quotient(a6),-(sp)	; get quotient * divisor
+		move.l	divisor(a6),-(sp)
+		pea		remultiply(a6)
+		_LongMul
+
+		move.l	quotient(a6),d1		; result: quotient
+
+		move.l	dividend+4(a6),d0	; result: remainder
+		sub.l	remultiply+4(a6),d0
+
+		unlk	a6
+		rts
+
+		endWith
+		endProc
+
+
 ;============================================================================
 ;pascal void LongSecs2Date (longSecs, longDate, selector)
 ;    LongDate*		longSecs;
@@ -1253,6 +1324,7 @@ RS2DRegs	reg	a2/d3-d7
 
 		with	LS2DRec,LongDateRec
 		import	MonthStarts,LeapStarts,secsInDayX
+		import	LongDivFunc
 
 		CheckSelector
 		link	a6,#localFrame

--- a/Toolbox/ShutDownMgr/ShutDownMgr.a
+++ b/Toolbox/ShutDownMgr/ShutDownMgr.a
@@ -20,9 +20,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM33>	 11/6/93	SAM		Roll <MC8> from mc900ftjesus.
-;	   <MC8>	 11/6/93	SAM		Now handle the restart from the "..safe to switch off..." case
-;									correctly (ie restore the nanok warmstart).
 ;	  <SM32>	 11/6/93	SAM		Roll <MC7> from mc900ftjesus.
 ;	   <MC7>	 11/6/93	SAM		Changed ClearWarmStart to check for a V0 style emulator and if
 ;									present to clear the emu warmstart flag.
@@ -393,7 +390,7 @@ ShutDown		move.l	(SP)+,D2			; save return
 				move.w	(SP)+,D0			; get opcode word
 				move.l	D2,-(SP)			; restore the return
 				subq	#SDPowerOff,D0
-				bcs.w	ShutInit			; if d0=0, _SDInit a selector in ROM versions
+				bcs.w	@unknownSelector
 				beq		ShutPower			; if d0=1, Shutdown
 
 				subq	#SDInstall-SDPowerOff,D0	
@@ -531,7 +528,6 @@ ShutRestart
 
 				move.l	#emuWarmStartConst,D0	; Does the upper long match?
 				move.l	#WmStConst,D1			; Does the upper long match?
-				bsr		UpdateEmuWarmstart		; Write the warmstart (We may have come from a shutdown...) <MC8>
 							
 				tst.l	VMGlobals				; Is VM running?
 				bmi.s	@noVM					; -> No.  Assume we're in Supervisor Mode				
@@ -920,40 +916,6 @@ DoUnmount
 
 @AllFlushed
 			add.W	#IOQElSize,SP				; deallocate pBlock
-			
-	; Wait for all floppy drives that have diskettes inserted to eject, or for 2 seconds,
-	; whichever comes first.  (Note:  This should now be “universal,” even
-	; for CPUs that don’t have auto-eject floppy mechanisms.)
-
-taskActive	equ		7							; High bit of qType word is active flag.
-
-			moveq.l	#(tmXQSize/2)-1,D0			; Set up the init-loop counter.
-@clrTask	clr.w	-(Sp)						; Allocate and clear a TMTask record.
-			dbra	D0,@clrTask					; Do it one word at a time.
-			move.l	Sp,A0						; Point to the TMTask record.
-			_InsXTime							; Install it.
-			
-			move.l	#2*1000*1000,D0				; We need ~1.5sec, but we’ll say 2sec for safety.
-			neg.l	D0							; (Negate for µsec timer.)
-			_PrimeTime							; Start the TMTask.
-
-			move.l	DrvQHdr+QHead,D0			; Now, get a pointer to the first drvQElem.
-@Repeat		move.l	D0,A1						; Copy the drvQElem pointer into A1.
-			cmpi.w	#-5,dqRefNum(A1)			; If this isn’t a floppy (.Sony) driver drive,
-			bne.s	@Until						;	then just go on.
-			
-@WaitEject	btst.b	#taskActive,qType(A0)		; If the TMTask has completed,
-			beq.s	@TimedOut					;	then we can now exit this loop.
-			move.l	-4(A1),D0					; Otherwise, get the drvQElem flags.
-			andi.l	#$00FF0000,D0				; If the media is still in the mechanism,
-			bne.s	@WaitEject					;	then just wait.
-			
-@Until		move.l	qLink(A1),D0				; Otherwise, get the next entry in the queue.
-			bne.s	@Repeat						; Loop until done.
-			
-@TimedOut	_RmvTime							; Remove TMTask.
-
-			adda.w	#tmXQSize,Sp				; Reclaim the stack space.
 		  	rts
 
 ;_______________________________________________________________________					<5>
@@ -972,88 +934,9 @@ ClearWarmStart
 			
 			moveq	#0,D0							; hi long
 			moveq	#0,D1							; lo long
-			bsr.l	UpdateEmuWarmstart				; Clear the warmstart					<MC8>	
 			
 			rts
 
-
-
-;_______________________________________________________________________					<MC8> SAM
-;
-; UpdateEmuWarmstart - 
-;
-;	 The emulator warmstart flag lives in the writeprotected diagnostic info block in the Nanokernel's
-;	 data page.  We need to "map" the diag page to a normally mapped page of RAM, write the warmstart
-;	 constant, and remap the memory back the way it was.  Oh, I'm using logical page number 1
-;	 (i.e. $1000 - 4k pages). Oh, yeah, the RAM at $1000 never actually gets modified...
-;
-;	Entry - D0.l warmstart low
-;			D1.1 warmstart high
-;
-;_______________________________________________________________________					<MC8>
-			Export	UpdateEmuWarmstart
-
-UpdateEmuWarmstart	
-			With	nkDiagInfo	
-
-			testFor	has68kEmulator					; Does this machine have a V0 style emulator?
-			beq		@Done							; -> Nope, we're done.  Exit.
-			
-			move	SR,-(SP)						; Save SR
-			ori.w	#hiIntMask,SR					; Disable interrupts
-			movem.l	D2-D7,-(SP)						; Save some D regs
-			
-			move.l	D0,D6
-			move.l	D1,D7
-			move.w	#12,D2							; Shift Count (12 bits in 4k)
-			
-			lea		1,A0							; Logical page #1 ($1000)
-			_nkGetPTEntryGivenPage					; Get its Pte
-			move.l	D0,D3							; Save the Pte in D3
-			
-			move.l	(nkDiagInfoPtr),D0				; Get the DiagPage Logical Address
-			move.l	D0,D5							; Make a copy
-			and.l	#4096-1,D5						; Get the offset into the page
-			
-			lsr.l	D2,D0							; Make it a page number
-	
-			move.l	D0,A0							; Page into A0
-			_nkGetPTEntryGivenPage					; Get the Diag Pte
-			move.l	D0,D4							; Save it
-			
-			lea		1,A0							; Get the buffer page number in A0
-			lea		1,A1							; Say page is inited (#1)
-			_nkMMUMarkBacking						; Mark this page as outta here
-	
-			lea		1,A0							; Logical Page number of the buffer
-			move.l	D4,D0							; Get the Diag Pte
-			lsr.l	D2,D0							; Get its Physical Page number
-			move.l	D0,A1							; Set Physical Page
-			_nkMMUMarkResidentGlue					; Map the diag's physical address to the buffer's logical addr
-	
-			lea		$1000,A0						; Get our logical starting point
-			add.l	D5,A0							; Add in the offset from the start of the diag page
-			
-			move.l	D6,DiagWarmStartLow(A0)
-			move.l	D7,DiagWarmStartHigh(A0)
-	
-			lea		1,A0							; Get the lo Page number in A0
-			lea		1,A1							; Say page is inited (#1)
-			_nkMMUMarkBacking						; Mark this page as outta here
-	
-			lea		1,A0							; Get the lo Page number in A0
-			move.l	D3,D0							; Get the LoPage's Pte
-			lsr.l	D2,D0							; Get its Physical Page number
-			move.l	D0,A1							; Set Physical Page
-			_nkMMUMarkResidentGlue					; Move the HiPage to the loPage's logical addr
-	
-			movem.l	(SP)+,D2-D7						; Save some D regs
-			move	(SP)+,SR						; Restore IRQ enable state
-
-@Done		rts										; all done
-			
-			EndWith
-
 ;_______________________________________________________________________					<5>
 ; ZapVCBQueue - This routine goes through the VCB Queue, and calls HUnmountVol for each entry.
 ;
@@ -1122,7 +1005,7 @@ BlankDesktop
 
 			; allocate a grafPort using the stack and initialize it
 
-			BigJsr	AllocFakeRgns,A1		; init dummy vis and clip to wide-open			
+;			BigJsr	AllocFakeRgns,A1		; init dummy vis and clip to wide-open			
 			MOVE.L	A6,-(SP)				; push address of grafPort
 			_InitPort						; initialize the port.  This particular case
 											;  doesn’t move memory, even when it calls COPYRGN!

--- a/Toolbox/WindowMgr/StandardWDEF.a
+++ b/Toolbox/WindowMgr/StandardWDEF.a
@@ -446,7 +446,7 @@ IsNoZoom
 
 			move.l	WMgrPort,-(SP)		; B&W, set to window manager port
 			_SetPort					;
-			bra		@CommonSys			; done for the B&W environment <SM1> CSS
+			bra.s	@CommonSys			; done for the B&W environment <SM1> CSS
 
 ; ------------- doin it with color -------------
 ; when using the WMgrCPort, it is the defproc’s responsibility to reconcile
@@ -538,7 +538,6 @@ IsNoZoom
 			subq.l	#4, SP					; room for a PixMapHandle
 			move.l	#'pmap', -(SP)			; the Pixmap resource type
 			move.w	#kPixmapID, -(SP)		; ID of working pixmap
-			move.w	#MapTrue,RomMapInsert	;												<SM3> rb
 			_GetResource					; look in ROM first								<SM3> rb
 			move.l	(SP)+, workPixmap(A6)	; save it for later
 			move.l	#16,D0					; allocate a bogus ctab 						<21>
@@ -1663,11 +1662,8 @@ WDefDrawGIcon
 			move.l	portRect+botRight(windowReg),(rectReg)	; botRight=topLeft
 			move.l	(rectReg),botRight(rectReg)				; copy into botRight, too
 
-			add.w	d4,left(rectReg)						; <SM5> 	reintroduced from <34>
-			add.w	d4,right(rectReg)						; <SM5>
-			swap	d4										; <SM5>
-			add.w	d4,top(rectReg)							; <SM5>
-			add.w	d4,bottom(rectReg)						; <SM5>
+			add.l	d4,0(a4)
+			add.l	d4,4(a4)
 
 			sub.w	#scrollBarSize-2,top(rectReg)			; remove scroll area
 			sub.w	#scrollBarSize-2,left(rectReg)
@@ -2359,7 +2355,6 @@ SetupColorPict
 			move.w	(A2, D0.w), -(SP)					; push the resource ID
 			cmpi.w	#kHighlightPix,(sp)
 			seq		gadgetHighlight(a6)					; Set if we’re highlighting
-			move.w	#MapTrue,RomMapInsert				;										<SM3> rb
 			_GetResource								; look in ROM first						<SM3> rb
 			move.l	(SP)+, A0							; pixels handle
 			_HLock										; don’t want it to move

--- a/Toolbox/WindowMgr/WindowList.a
+++ b/Toolbox/WindowMgr/WindowList.a
@@ -258,7 +258,7 @@ DoOld				MOVE.L		(SP)+, A1
 wlBringToFront		PatchProc	_BringToFront
 
 					MOVE.L		4(SP), -(SP)
-					CLR.W		DragFlag										<LW2>
+;					CLR.W		DragFlag										<LW2>
 					IMPORT		BringToFrontGuts
 					LEA			BringToFrontGuts, A0
 					IMPORT		TwoByFour

--- a/Toolbox/WindowMgr/WindowMgrPatches.a
+++ b/Toolbox/WindowMgr/WindowMgrPatches.a
@@ -516,6 +516,20 @@ ShowHideActivatePalette PatchProc _ShowHide,(II)
 @done
 			RTD		#6							; strip parameters and return
 
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+
 			EndProc
 	ENDIF
 
@@ -1151,16 +1165,16 @@ oldCloseWindow
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 
-				MakePatch __CheckUpdate,_CheckUpdate
-				
-	IF hasLayerlessApps THEN
-				MakePatch __patchCalcVis,_CalcVis
-				MakePatch __patchCalcVisBehind,_CalcVBehind
-	ELSE
-				MakePatch __CalcVis,_CalcVis
-				MakePatch __CalcVisBehind,_CalcVBehind
-	ENDIF
-				MakePatch __FrontWindow,_FrontWindow
+;				MakePatch __CheckUpdate,_CheckUpdate
+;				
+;	IF hasLayerlessApps THEN
+;				MakePatch __patchCalcVis,_CalcVis
+;				MakePatch __patchCalcVisBehind,_CalcVBehind
+;	ELSE
+;				MakePatch __CalcVis,_CalcVis
+;				MakePatch __CalcVisBehind,_CalcVBehind
+;	ENDIF
+;				MakePatch __FrontWindow,_FrontWindow
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 __NewWindow		PatchProc	_NewWindow

--- /dev/null
+++ b/TrashTalk.a
@@ -0,0 +1,259 @@
+	include 'LinkedPatchMacros.a'
+
+
+	case on
+
+
+	string asis
+
+
+
+TRASHTALK PROC EXPORT
+
+CALLWITHREGISTERSPRESERVED PROC EXPORT
+ dc.b 'CALLWITHREGISTER'
+
+CHECKCSPB PROC EXPORT
+ dc.b 'CHECKCSPB       '
+
+CMCATSEARCH PROC EXPORT
+ dc.b 'CMCATSEARCH     '
+
+CMCREATEUPDATECNPATCH PROC EXPORT
+ dc.b 'CMCREATEUPDATECN'
+
+CMDELETECNAFTERSETUP PROC EXPORT
+ dc.b 'CMDELETECNAFTERS'
+
+CMMOVECNAFTERSETUP PROC EXPORT
+ dc.b 'CMMOVECNAFTERSET'
+
+CMRENAMECNAFTERSETUP PROC EXPORT
+ dc.b 'CMRENAMECNAFTERS'
+
+CMRENAMECNEXIT1 PROC EXPORT
+ dc.b 'CMRENAMECNEXIT1 '
+
+CREATEFILEIDREF PROC EXPORT
+ dc.b 'CREATEFILEIDREF '
+
+DELETEFILEIDREF PROC EXPORT
+ dc.b 'DELETEFILEIDREF '
+
+DTADDAPPL PROC EXPORT
+ dc.b 'DTADDAPPL       '
+
+DTADDICON PROC EXPORT
+ dc.b 'DTADDICON       '
+
+DTCLOSEDOWN PROC EXPORT
+ dc.b 'DTCLOSEDOWN     '
+
+DTFLUSH PROC EXPORT
+ dc.b 'DTFLUSH         '
+
+DTGETAPPL PROC EXPORT
+ dc.b 'DTGETAPPL       '
+
+DTGETCOMMENT PROC EXPORT
+ dc.b 'DTGETCOMMENT    '
+
+DTGETICON PROC EXPORT
+ dc.b 'DTGETICON       '
+
+DTGETICONINFO PROC EXPORT
+ dc.b 'DTGETICONINFO   '
+
+DTGETINFO PROC EXPORT
+ dc.b 'DTGETINFO       '
+
+DTGETPATH PROC EXPORT
+ dc.b 'DTGETPATH       '
+
+DTREMOVEAPPL PROC EXPORT
+ dc.b 'DTREMOVEAPPL    '
+
+DTREMOVECOMMENT PROC EXPORT
+ dc.b 'DTREMOVECOMMENT '
+
+DTRESET PROC EXPORT
+ dc.b 'DTRESET         '
+
+DTSETCOMMENT PROC EXPORT
+ dc.b 'DTSETCOMMENT    '
+
+EXTERNALMAKEFSSPEC PROC EXPORT
+ dc.b 'EXTERNALMAKEFSSP'
+
+FIND6BOFROMID PROC EXPORT
+ dc.b 'FIND6BOFROMID   '
+
+FINDDTVOL PROC EXPORT
+ dc.b 'FINDDTVOL       '
+
+GETOFFFSQUEUE PROC EXPORT
+ dc.b 'GETOFFFSQUEUE   '
+
+MAKEFSSPEC PROC EXPORT
+ dc.b 'MAKEFSSPEC      '
+
+PBHEXCHANGEFILES PROC EXPORT
+ dc.b 'PBHEXCHANGEFILES'
+
+POPMENUSTATE PROC EXPORT
+ dc.b 'POPMENUSTATE    '
+
+PTCHHMGETBALLOONS PROC EXPORT
+ dc.b 'PTCHHMGETBALLOON'
+
+PTCHHMSHOWHELPABOUTDIALOG PROC EXPORT
+ dc.b 'PTCHHMSHOWHELPAB'
+
+PTCHHMTOGGLEWHATIS PROC EXPORT
+ dc.b 'PTCHHMTOGGLEWHAT'
+
+PTCHHMUPDATEHELPMENU PROC EXPORT
+ dc.b 'PTCHHMUPDATEHELP'
+
+PUSHMENUSTATE PROC EXPORT
+ dc.b 'PUSHMENUSTATE   '
+
+QMENQUEUE PROC EXPORT
+ dc.b 'QMENQUEUE       '
+
+RESOLVEFILEIDREF PROC EXPORT
+ dc.b 'RESOLVEFILEIDREF'
+
+SCSIINIT96 PROC EXPORT
+ dc.b 'SCSIINIT96      '
+
+SCSIMGR_96 PROC EXPORT
+ dc.b 'SCSIMGR_96      '
+
+VALIDATEMENUBAR PROC EXPORT
+ dc.b 'VALIDATEMENUBAR '
+
+DTDELETE PROC EXPORT
+ dc.b 'DTDELETE        '
+
+DTOPENINFORM PROC EXPORT
+ dc.b 'DTOPENINFORM    '
+
+FINDFIRSTSYSTEMMENU6BO PROC EXPORT
+ dc.b 'FINDFIRSTSYSTEMM'
+
+DSEDIT PROC EXPORT
+ dc.b 'DSEDIT          '
+
+FAKEUPEVENT PROC EXPORT
+ dc.b 'FAKEUPEVENT     '
+
+NOTOWNACTIVATOR PROC EXPORT
+ dc.b 'NOTOWNACTIVATOR '
+
+REPLACECITATIONS PROC EXPORT
+ dc.b 'REPLACECITATIONS'
+
+PRESHOWHIDE PROC EXPORT
+ dc.b 'PRESHOWHIDE     '
+
+__ACTIVEWINDOW PROC EXPORT
+ dc.b '__ACTIVEWINDOW  '
+
+__AUTOPOSITIONWINDOW PROC EXPORT
+ dc.b '__AUTOPOSITIONWI'
+
+__BEGINUPDATE PROC EXPORT
+ dc.b '__BEGINUPDATE   '
+
+__CALCVIS PROC EXPORT
+ dc.b '__CALCVIS       '
+
+__CALCVISBEHIND PROC EXPORT
+ dc.b '__CALCVISBEHIND '
+
+__CHECKUPDATEIN PROC EXPORT
+ dc.b '__CHECKUPDATEIN '
+
+__CHECKWINDOW PROC EXPORT
+ dc.b '__CHECKWINDOW   '
+
+__CLIPABOVE PROC EXPORT
+ dc.b '__CLIPABOVE     '
+
+__CLOSEWINDOW PROC EXPORT
+ dc.b '__CLOSEWINDOW   '
+
+__EACHWINDOW PROC EXPORT
+ dc.b '__EACHWINDOW    '
+
+__FINDWINDOW PROC EXPORT
+ dc.b '__FINDWINDOW    '
+
+__FRONTWINDOWIN PROC EXPORT
+ dc.b '__FRONTWINDOWIN '
+
+__GETCURLAYER PROC EXPORT
+ dc.b '__GETCURLAYER   '
+
+__GETDESKPORT PROC EXPORT
+ dc.b '__GETDESKPORT   '
+
+__GETPARENT PROC EXPORT
+ dc.b '__GETPARENT     '
+
+__GETROOTLAYER PROC EXPORT
+ dc.b '__GETROOTLAYER  '
+
+__GETSUBWINDOWS PROC EXPORT
+ dc.b '__GETSUBWINDOWS '
+
+__GETWINDOWSTATE PROC EXPORT
+ dc.b '__GETWINDOWSTATE'
+
+__GLOBALPORTRECT PROC EXPORT
+ dc.b '__GLOBALPORTRECT'
+
+__INITLAYERS PROC EXPORT
+ dc.b '__INITLAYERS    '
+
+__ISLAYER PROC EXPORT
+ dc.b '__ISLAYER       '
+
+__NEWLAYER PROC EXPORT
+ dc.b '__NEWLAYER      '
+
+__PAINTBEHIND PROC EXPORT
+ dc.b '__PAINTBEHIND   '
+
+__PAINTONE PROC EXPORT
+ dc.b '__PAINTONE      '
+
+__PAINTONEPAL PROC EXPORT
+ dc.b '__PAINTONEPAL   '
+
+__POSITIONWINDOW PROC EXPORT
+ dc.b '__POSITIONWINDOW'
+
+__REDRAWALL PROC EXPORT
+ dc.b '__REDRAWALL     '
+
+__SETCURLAYER PROC EXPORT
+ dc.b '__SETCURLAYER   '
+
+__SETWINDOWSTATE PROC EXPORT
+ dc.b '__SETWINDOWSTATE'
+
+__SWAPCURLAYER PROC EXPORT
+ dc.b '__SWAPCURLAYER  '
+
+__WINDOWTYPE PROC EXPORT
+ dc.b '__WINDOWTYPE    '
+
+NEWWINDOWCOMMON PROC EXPORT
+ dc.b 'NEWWINDOWCOMMON '
+
+
+
+
+	END

--- /dev/null
+++ b/TrashTalk.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
-- 
2.18.0

