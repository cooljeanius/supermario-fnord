From: Horst Beepmanh <>
Subject: Source

---
diff --git a/Drivers/Backlight/PWM.c b/Drivers/Backlight/PWM.c
--- a/Drivers/Backlight/PWM.c
+++ b/Drivers/Backlight/PWM.c
@@ -10,26 +10,6 @@
 
 	Change History (most recent first):
 	
-	   <SM3>	 2/11/93	CSS		Update from Horror.  Comments follow:
-	   <H10>	 6/30/92	ag		Moved cpu depended initialization code to cpu.c file, input
-									routines to input.c, and table routines to backlight.c file.
-		<H9>	 5/26/92	ag		Added write to PONTI to turnoff backlight through PONTI bit.
-		<H8>	  5/7/92	ag		Use new table record for min/max limits. Added new entry for
-									Dartanian.
-		<H7>	 4/24/92	ag		set default to single table operation except on TIM (LC). added
-									new vector for custom input control to handle hardware
-									dependencies.
-		<H6>	12/17/91	SWC		Added boxDBLiteLC to the list in InitPWMControls. Grouped boxTIM
-									and boxDartanian since their code is identical.
-		<H5>	12/16/91	HJR		Added boxDartanian to the list.
-		<H4>	 9/10/91	SWC		Changed Get_AtoD to get the current setting of the up/down
-									buttons.
-		<H3>	 8/27/91	SWC		Changed references to get/set contrast to use get/set brightness
-									on machines other than TIM. On TIM, they used the contrast
-									command to control screen brightness. Added PWM table for
-									DB-Lite.
-		<H2>	  8/5/91	SWC		Changed Get_AtoD to use GetScreenCmd to get the current contrast
-									instead of reading from the A-D if not on TIM.
 		 <3>	 3/24/92	JSM		Nuke boxFlag codenames.
 		 <2>	 3/23/92	JSM		OSEvents.h is obsolete, use Events.h.
 		 <1>	10/24/91	SAM/KSM	Rolled in Regatta file.
@@ -78,30 +58,78 @@
 #include "PowerMgr.h"
 #include "backlight.h"
 
+#define	READ_ATOD_CHANNEL	0xD8
+#define	READ_BUTTON_VALUE	0xD9
+
+#define	BACKLIGHT_POT_CHANNEL	0
+#define STATUS					0
+#define POWERBYTE				1
+#define TEMPBYTE				2
+
+extern short			PotInputRangeShiftTblPWM[];
+extern unsigned char	timTblLow[];
+extern unsigned char	timTbl[];
+extern unsigned char	asahiTbl[];
+extern short			PWMMaxTbl[];
+
 /*page
  ***************************************************************************************************
  ** PWM software ***********************************************************************************
  ***************************************************************************************************
  */
 
-OSErr InitPWMControls(driverGlobalPtr	globalPtr)
+void InitPWMControls(driverGlobalPtr	globalPtr)
 
 {
 	unsigned int	startvalue;
+	int boxFlag;
+
+	/* setup default values */
+	globalPtr->flyByWire = true;
+	globalPtr->freeflag = true;
+	globalPtr->dualTable = true;
+
+	globalPtr->userInputSampleRate = 10;
+	globalPtr->maximumTable = &PWMMaxTbl;
+	globalPtr->settingTableLow = &timTblLow;
+	globalPtr->settingTable = globalPtr->settingTableHigh = &timTbl;
+
+	boxFlag = *(unsigned char *)0xCB3;
+	switch (boxFlag)
+		{
+		case 18: // PowerBook 100, Asahi
+			globalPtr->freeflag = false;
+			globalPtr->dualTable = false;
+			globalPtr->settingTable = &asahiTbl;
+			break;
+		case 15: // PowerBook 170, TIM
+			if (*JAWS_SPEED_FSTN_REG_PTR & JAWS_FSTN)
+				globalPtr->dualTable = false;
+			break;
+		}
 
 	/* initialize dual table variables */
 	if (globalPtr->dualTable) 
 		{
 		globalPtr->slewLimit		= true;				/* maximum change per/accrun */
-		(*globalPtr->tableProc)(globalPtr);				/* determine table based on current charger state */
+		globalPtr->lowThreshold		= 163;
+		globalPtr->hiThreshold		= 173;
+		globalPtr->tableProc		= ChargerAdjust;
+		globalPtr->lowTable			= LowTable(globalPtr);
+		if (globalPtr->lowTable)
+			globalPtr->settingTable = globalPtr->settingTableLow;
 		};
 
+	globalPtr->setlevelproc = SetPWM;
+	globalPtr->userInputProc = PotControl;
+	globalPtr->closeProc = PWMCloseRoutine;
+	globalPtr->controlProc = PWMControl;
+	globalPtr->statusProc = PWMStatus;
+
 	/* initialize backlight hardware */	
-	startvalue 						= (*globalPtr->userInputProc)(globalPtr);				/* <H8> */
+	startvalue 						= PotControl(globalPtr);
 	globalPtr->userBrightness 		= -1;
-	globalPtr->userBrightness 		= (*globalPtr->setlevelproc)(startvalue,globalPtr);		/* <H8> */
-	
-	return(noErr);
+	globalPtr->userBrightness 		= SetPWM(startvalue,globalPtr);
 };
 
 /*
@@ -113,10 +141,148 @@ OSErr InitPWMControls(driverGlobalPtr	globalPtr)
 int PWMCloseRoutine (driverGlobalPtr	globalPtr)
 
 {
-	(*globalPtr->setlevelproc)(globalPtr->settingTable->minimum,globalPtr);
+	SetPWM(0,globalPtr);
 	return(0);
 };
 
+/*
+ ***************************************************************************************************
+ *
+ *
+ ***************************************************************************************************
+ */
+
+int SetPWM(int	new,driverGlobalPtr	globalPtr)
+{
+	PMgrPBlock		pb;									/* power manager pb */
+	unsigned char	val;								/* hardware value setting */
+	
+	PEG_TO_LIMITS(new, globalPtr->maximumTable[globalPtr->powerRange], 0);				/* limit value to valid range */
+	val = globalPtr->settingTable[new];					/* look up value from table */
+
+	if ((globalPtr->userBrightness >= 0) && (val == globalPtr->lastHWSetting)) return(new);/* nothing to do; 90/05/15 just turn on; 90/07/02 avoid touching */
+	if (globalPtr->slewChange)
+		{
+		if (abs(globalPtr->lastHWSetting - val) > globalPtr->slewLimit)
+			val = globalPtr->lastHWSetting + ((globalPtr->lastHWSetting > val) ? -globalPtr->slewLimit : globalPtr->slewLimit);
+		else
+			globalPtr->slewChange = false;
+		};
+	globalPtr->lastHWSetting	= val;					/* save the new hardware setting */
+
+	pb.pmgrCmd					= ScreenSetCmd;			/*  everyone else uses "set brightness" */
+	pb.pmgrCnt					= 1;
+	pb.pmgrXPtr 				= &val;
+	pb.pmgrRPtr 				= nil;
+	PMgr(&pb);											/* set the pwm */
+
+	return(new);										/* return the current value */
+};
+
+/*page
+ ***************************************************************************************************
+ *
+ *
+ ***************************************************************************************************
+ */
+
+unsigned char Get_AtoD(int	channel)
+{
+	PMgrPBlock		pb;									/* power manager pb */
+	char			atodChannel;						/* a to d channel to read [0-8] */
+	unsigned char	value;								/* return value */
+	OSErr			error;								/* pmgr error */
+
+
+	atodChannel	= channel;								/* load channel value into buffer */
+
+	pb.pmgrCmd	= READ_ATOD_CHANNEL;					/* load read channel command */
+	pb.pmgrCnt	= 1;									/* transmit buffer count is 1 byte */
+	pb.pmgrXPtr = &atodChannel;							/* pointer to transmit buffer */
+	pb.pmgrRPtr = &value;								/* pointer to receive buffer */
+	
+	error = PMgr(&pb);
+
+	return( (error) ? 0 : value);
+};
+
+/*page
+ ***************************************************************************************************
+ *
+ *
+ ***************************************************************************************************
+ */
+
+unsigned char Get_PGEButton(int	channel)
+{
+	PMgrPBlock		pb;									/* power manager pb */
+	char			atodChannel;						/* a to d channel to read [0-8] */
+	unsigned char	value;								/* return value */
+	OSErr			error;								/* pmgr error */
+
+
+	atodChannel	= channel;								/* load channel value into buffer */
+
+	pb.pmgrCmd	= READ_BUTTON_VALUE;					/* load read channel command */
+	pb.pmgrCnt	= 1;									/* transmit buffer count is 1 byte */
+	pb.pmgrXPtr = &atodChannel;							/* pointer to transmit buffer */
+	pb.pmgrRPtr = &value;								/* pointer to receive buffer */
+	
+	error = PMgr(&pb);
+
+	return( (error) ? 0 : value);
+};
+
+/*page
+ ***************************************************************************************************
+ *
+ *
+ ***************************************************************************************************
+ */
+unsigned char GetPortableValues(int	parameter)
+{
+
+	PMgrPBlock		pb;									/* power manager pb */
+	OSErr			err;								/* power manager error */
+	unsigned char	rbuf[3];							/* buffer for send command */
+
+	pb.pmgrCmd = BatteryStatusImmCmd;					/* on old pmgr, read battery status (immediate not averaged) */
+	pb.pmgrCnt = 0;
+	pb.pmgrXPtr = nil;
+	pb.pmgrRPtr = rbuf;
+
+	err = PMgr(&pb);
+	return( (err) ? 0 : rbuf[parameter]);				/* return 0 if error, else read value */
+}
+
+/*page
+ ***************************************************************************************************
+ *
+ *
+ ***************************************************************************************************
+ */
+int PotControl (driverGlobalPtr	globalPtr)
+
+{
+#pragma	unused (globalPtr)
+
+	unsigned int	potvalue;
+	
+	potvalue = globalPtr->freeflag ? Get_AtoD(BACKLIGHT_POT_CHANNEL) : GetPortableValues(TEMPBYTE);
+
+	if (abs(globalPtr->lastatod - potvalue) <= 5) 		/* was the change less than 100mv */
+		potvalue = globalPtr->lastatod;					/* is less than, the use old value */
+
+	globalPtr->lastatod = potvalue;						/* update last a to d value */
+	potvalue >>= 3;										/* scale to 0 to 31 */
+	if (potvalue)										/* if non-zero, check for subrange limiting */
+		{
+		potvalue >>= PotInputRangeShiftTblPWM[globalPtr->powerRange]; /* rescale in low power levels */
+		if (!potvalue) potvalue = 1;					/* make sure we don't change the backlight state */
+		};
+	return(potvalue);
+};
+
 /*page
  ***************************************************************************************************
  *
@@ -144,7 +310,7 @@ OSErr PWMControl(CntrlParam *ctlPB,driverGlobalPtr	globalPtr)		/* 'open' entry p
 			{
 			case kSetScreenBrightness:					/* set brightness level */
 				tempvalue = ctlPB->csParam[0];
-				globalPtr->userBrightness 	= (*globalPtr->setlevelproc)(tempvalue,globalPtr);
+				globalPtr->userBrightness 	= SetPWM(tempvalue,globalPtr);
 				break;
 				
 			default:
@@ -154,37 +320,43 @@ OSErr PWMControl(CntrlParam *ctlPB,driverGlobalPtr	globalPtr)		/* 'open' entry p
 	return(error);
 };
 
-/*
+/*page
  ***************************************************************************************************
  *
+ * The status routine…
+ *
+ *	return:
+ *		noErr		- task completed successfully
+ *		statusErr	- illegal status selector
+ *
  *
  ***************************************************************************************************
  */
 
-int SetPWM(int	new,driverGlobalPtr	globalPtr)
+OSErr PWMStatus(CntrlParam *ctlPB,driverGlobalPtr	globalPtr)
 {
-	PMgrPBlock		pb;									/* power manager pb */
-	unsigned char	val;								/* hardware value setting */
-	
-	PEG_TO_LIMITS(new, globalPtr->maximumTable[globalPtr->powerRange], globalPtr->settingTable->minimum);	/* <H8> use new tables */				/* limit value to valid range */
-	val = globalPtr->settingTable->table[new];					/* look up value from table */
+	OSErr 		error;
 
-	if ((globalPtr->userBrightness >= 0) && (val == globalPtr->lastHWSetting)) return(new);/* nothing to do; 90/05/15 just turn on; 90/07/02 avoid touching */
-	if (globalPtr->slewChange)
+	error	= noErr;
+
+	switch(ctlPB->csCode) 
 		{
-		if (abs(globalPtr->lastHWSetting - val) > globalPtr->slewLimit)
-			val = globalPtr->lastHWSetting + ((globalPtr->lastHWSetting > val) ? -globalPtr->slewLimit : globalPtr->slewLimit);
-		else
-			globalPtr->slewChange = false;
+		case kGetScreenBrightness:						/* get brightness level */
+			ctlPB->csParam[0] = globalPtr->userBrightness;
+			break;
+			
+		case kGetBrightnessRange:
+			ctlPB->csParam[0] = 31;
+			ctlPB->csParam[1] = 0;
+			break;
+
+		case kGetMaximum:
+			ctlPB->csParam[0] = globalPtr->maximumTable[globalPtr->powerRange];
+			break;
+
+		default:
+			error = statusErr;
 		};
-	globalPtr->lastHWSetting	= val;					/* save the new hardware setting */
-
-	pb.pmgrCmd					= SetBrightnessCmd;		/*  everyone else uses "set brightness" */
-	pb.pmgrCnt					= 1;
-	pb.pmgrXPtr 				= &val;
-	pb.pmgrRPtr 				= nil;
-	PMgr(&pb);											/* set the pwm */
-
-	return(new);										/* return the current value */
-};
 
+	return(error);
+}
diff --git a/Drivers/Backlight/Register.c b/Drivers/Backlight/Register.c
--- a/Drivers/Backlight/Register.c
+++ b/Drivers/Backlight/Register.c
@@ -9,13 +9,6 @@
 
 	Change History (most recent first):
 
-	   <SM5>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
-									machines
-	   <SM4>	 2/11/93	CSS		Update from Horror.  Comments follow:
-		<H4>	 6/30/92	ag		Moved cpu depended initialization code to cpu.c file, and input
-									routines to input.c.
-		<H3>	  5/7/92	ag		Use new table record for min/max limits.
-		<H2>	 4/24/92	ag		return error from initialization.
 		 <2>	 3/23/92	JSM		OSEvents.h is obsolete, use Events.h.
 		 <1>	10/24/91	SAM/KSM	Rolled in Regatta file.
 	
@@ -117,7 +110,10 @@ typedef	struct
 	char				keymodifiers;
 	short				unused;
 	} posteventtype, *posteventtypeptr;
-extern setTableType		PortableTbl5V;
+extern posteventtype	postEventData;
+extern unsigned char	PortableTbl5V[];
+extern unsigned char	PortableTable7V[];
+extern short			PortableMaxTbl[];
 
 int		GetBacklightInfo(short	mask, short shift);
 void	SaveBacklightInfo(short new,short	mask, short shift);
@@ -125,23 +121,82 @@ void	SaveBacklightInfo(short new,short	mask, short shift);
 		TurnOnOff(Boolean on);
 		setNewKeys(int		keycombo);
 
+/*page
+ ***************************************************************************************************
+ *
+ *
+ ***************************************************************************************************
+ */
+void ChargerAdjust  (driverGlobalPtr	globalPtr)
+{		
+	unsigned int				oldTable;
+
+	oldTable			= globalPtr->lowTable;					/* save the current table being used */
+	globalPtr->lowTable =  LowTable(globalPtr);					/* get the new table to use */
+	if (globalPtr->lowTable == oldTable) return;				/* are we changing tables ???, no exit */
+
+	globalPtr->slewChange		= true;							/* if change, set tmp slew on */					
+	globalPtr->settingTable		= globalPtr->lowTable ? globalPtr->settingTableLow :globalPtr->settingTableHigh ;							
+};
+
+/*page
+ ***************************************************************************************************
+ *
+ *
+ ***************************************************************************************************
+ */
+unsigned int LowTable  (driverGlobalPtr	globalPtr)
+
+{
+	PmgrGlobals					**pmgrglobalhdl;				/* handle to power manager globals */
+	Boolean						wasLowTable;					/* current table being used */
+	Boolean						hiTable;						/* use hi level table  now */
+
+	pmgrglobalhdl 	= (PmgrGlobals **) 0x0D18;					/* handle to power manager globals */
+
+	wasLowTable		= globalPtr->lowTable;						/* current table */
+	hiTable 		= false;									/* assume low table */
+	if ((wasLowTable && ((*pmgrglobalhdl)->BatAvg >= globalPtr->hiThreshold)) ||
+		(!wasLowTable && ((*pmgrglobalhdl)->BatAvg >= globalPtr->lowThreshold)))
+		{
+		hiTable = (*pmgrglobalhdl)->Charger & 0x01;				/* qualify table with charger */
+		};
+	return(hiTable ? 0 : 1);									/* return 1 if low table, 0 if high */
+};
+
 /*page
  ***************************************************************************************************
  ** Register control software **********************************************************************
  ***************************************************************************************************
  */
 
-OSErr InitRegControls(driverGlobalPtr	globalPtr)
+void InitRegControls(driverGlobalPtr	globalPtr)
 
 {
 	int					SetBrightness();
 	int					KbdControl();
 	int					RegisterClose();
-	unsigned int		pramBrightness;
+	OSErr				RegisterStatus(CntrlParam *, driverGlobalPtr);
+	OSErr				RegisterControl(CntrlParam *, driverGlobalPtr);
+	int					pramBrightness;
 	void				ShutdownBacklight();
+	posteventtypeptr	postdataptr;
 
 	
-	if (BACKLIGHTSIGREG & TABLE_5V) globalPtr->settingTable = &PortableTbl5V;							
+	postdataptr = &postEventData;
+	postdataptr->keysActive = 0;
+	postdataptr->keymodifiers = 0;
+
+	globalPtr->userInputSampleRate = 1;
+
+	globalPtr->settingTable = (BACKLIGHTSIGREG & TABLE_5V) ? PortableTbl5V : PortableTable7V;
+
+	globalPtr->maximumTable = &PortableMaxTbl;
+	globalPtr->setlevelproc = SetBrightness;
+	globalPtr->userInputProc = KbdControl;
+	globalPtr->closeProc = RegisterClose;
+	globalPtr->statusProc = RegisterStatus;
+	globalPtr->controlProc = RegisterControl;
 
 	globalPtr->keycodes 		= GetPramKeyData();
 	pramBrightness 				= GetPramBrightness();	/* get pram setting */
@@ -149,13 +204,14 @@ OSErr InitRegControls(driverGlobalPtr	globalPtr)
 	setNewKeys(globalPtr->keycodes);
 	if (pramBrightness < 0) 									/* check for valid brightness value */
 		{
-		pramBrightness = globalPtr->settingTable->minimum+1;				/* <H3> load default brightness */
-		SaveBrightness(globalPtr->settingTable->minimum+1);					/* <H3> validate, as save new brightness */
+		pramBrightness = 1;
+		SaveBrightness(1);
 		};
 
 
-	globalPtr->userBrightness 	= globalPtr->settingTable->maximum;			/* <H3> */
-	globalPtr->userBrightness 	= SetBrightness(globalPtr->settingTable->minimum,globalPtr);	/* <H3> initialize pot */
+	globalPtr->userBrightness	= 30;
+	globalPtr->lastHWSetting	= globalPtr->settingTable[30];
+	globalPtr->userBrightness 	= SetBrightness(0,globalPtr);
 	globalPtr->userBrightness 	= SetBrightness(pramBrightness,globalPtr);	/* set brightness level */
 	
 	if (BACKLIGHTSIGREG == BACKLIGHTSIG_UPGRD)
@@ -166,8 +222,6 @@ OSErr InitRegControls(driverGlobalPtr	globalPtr)
 		};
 
 	ShutDwnInstall( (ShutDwnProcPtr) ShutdownBacklight,sdRestartOrPower);	/* install shutdown task */
-
-	return(noErr);
 };
 
 /*page
@@ -274,20 +328,16 @@ int SetBrightness(int	new, driverGlobalPtr	globalPtr)
 	char			signature;
 	Boolean			onBitHigh;
 	Boolean			countDownBit;
-	int				current;
 	unsigned char	tablevalue;
 	Boolean			initialize;
 
 
 
 	initialize = (globalPtr->userBrightness < 0);
-	PEG_TO_LIMITS(new, globalPtr->maximumTable[globalPtr->powerRange], globalPtr->settingTable->minimum);	/* <H3> limit value to valid range */
-	current = (initialize)
-				? globalPtr->settingTable->minimum		/* <H3> */
-				: globalPtr->userBrightness;
+	PEG_TO_LIMITS(new, globalPtr->maximumTable[globalPtr->powerRange], 0);
 
-	tablevalue = globalPtr->settingTable->table[new];	/* <H3> look up value from table */
-	if (!initialize && (tablevalue == globalPtr->lastHWSetting) )
+	tablevalue = globalPtr->settingTable[new];
+	if (tablevalue == globalPtr->lastHWSetting)
 		return(new);								/* nothing to do; 90/05/15 just turn on; 90/07/02 avoid touching */
 
 	/* setup control bits */
@@ -297,13 +347,13 @@ int SetBrightness(int	new, driverGlobalPtr	globalPtr)
 	backlightreg 	= (Ptr) PORTABLE_HW;
 	regvalue		= COUNT_BIT + L_CS_BIT;			/* start with count and CS inactive */
 
-	if ((onBitHigh && (new != globalPtr->settingTable->minimum)) || (!onBitHigh && (new == globalPtr->settingTable->minimum)))  /* <H3> */
+	if ((onBitHigh && new) || (!onBitHigh && !new))
 		regvalue |= ON_BIT; 						/* upgrade has opposite polarity */
 
-	if ((countDownBit && (new <= current)) || (!countDownBit && (new >= current)))
+	if ((countDownBit && (new <= globalPtr->userBrightness)) || (!countDownBit && (new >= globalPtr->userBrightness)))
 		regvalue |= COUNTDN_BIT;	/* set the count down bit if new > current */
 
-	strobes = (new == globalPtr->settingTable->minimum)  /* <H3> */
+	strobes = (new == 0)
 				? MAXSTROBECOUNT					/* if minimum, bang against stops */
 				: abs(globalPtr->lastHWSetting - tablevalue);
 
@@ -410,8 +460,8 @@ int KbdControl (driverGlobalPtr	globalPtr)
 int RegisterClose (driverGlobalPtr	globalPtr)
 
 {
-	globalPtr->userBrightness 	= globalPtr->settingTable->maximum;									/* <H3> */
-	globalPtr->userBrightness 	= SetBrightness(globalPtr->settingTable->minimum,globalPtr);		/* <H3> initialize pot */
+	globalPtr->userBrightness 	= 30;
+	globalPtr->userBrightness 	= SetBrightness(0,globalPtr);
 
 	SleepQRemove(&globalPtr->sleepQelement);					/* remove sleep task */
 	ShutDwnRemove( (ShutDwnProcPtr) ShutdownBacklight);			/* remove shutdown task */
@@ -445,7 +495,7 @@ OSErr RegisterControl(CntrlParam *ctlPB,driverGlobalPtr	globalPtr)		/* 'open' en
 		{
 		case kSetScreenBrightness:										/* set brightness level */
 			tempvalue = ctlPB->csParam[0];
-			globalPtr->userBrightness 	= (*globalPtr->setlevelproc)(tempvalue,globalPtr);
+			globalPtr->userBrightness 	= SetBrightness(tempvalue,globalPtr);
 			break;
 		case kSaveScreenBrightness:										/* save brightness level */
 			SaveBrightness(globalPtr->userBrightness);
@@ -488,15 +538,25 @@ OSErr RegisterStatus(CntrlParam *ctlPB,driverGlobalPtr	globalPtr)			/* 'open' en
 	error	= noErr;
 	switch(ctlPB->csCode) 
 		{
+		case kGetScreenBrightness:
+			ctlPB->csParam[0] = globalPtr->userBrightness;
+			break;
 		case kGetBrightnessKeys:								/* return current saved brightness */
 			ctlPB->csParam[0] = globalPtr->keycodes;
 			break;
+		case kGetBrightnessRange:
+			ctlPB->csParam[0] = 30;
+			ctlPB->csParam[1] = 0;
+			break;
 		case kGetPBacklight:
 			ctlPB->csParam[0] = GetPramBrightness();
 			break;
 		case kGetPKey:
 			ctlPB->csParam[0] = GetPramKeyData();
 			break;
+		case kGetMaximum:
+			ctlPB->csParam[0] = globalPtr->maximumTable[globalPtr->powerRange];
+			break;
 
 		default:
 			error = statusErr;
@@ -508,11 +568,14 @@ setNewKeys(int		keycombo)
 
 {
 	char						newKey;
+	posteventtypeptr			postdataptr;
 
 	newKey			= 0;
 	if (keycombo & 0x01) newKey |= 0x10;
 	if (keycombo & 0x02) newKey |= 0x02;
 	if (keycombo & 0x04) newKey |= 0x08;
 	
+	postdataptr = &postEventData;
+	postdataptr->keymodifiers = newKey;
 };
 
diff --git a/Drivers/Backlight/backlight.a b/Drivers/Backlight/backlight.a
--- a/Drivers/Backlight/backlight.a
+++ b/Drivers/Backlight/backlight.a
@@ -9,27 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
-;									machines
-;	   <SM3>	 11/8/93	JRH		boxDBLite16 is now boxPowerBookDuo250. boxDBLite20 is now
-;									boxPenLite. boxEscher25 is now boxYeagerFSTN. boxEscher33 is now
-;									boxPowerBookDuo270C.
-;	   <SM2>	 2/11/93	CSS		Updated some code names to real names, and include
-;									boxflags from InternalOnlyEqu.a rather than from
-;									backlightequ.a.  Update from Horror. Comments follow:
-;	   <H10>	 1/21/93	RLE		add support for Escher
-;		<H9>	 7/13/92	SWC		Yet another pass at the DBLite table. Deja vu, eh?
-;		<H8>	 6/30/92	ag		Added cpu info tables for cpu dependent information.
-;		<H7>	  5/7/92	ag		Changed the structure of the backlight tables. Included in the
-;									tables are a header which indicates the minimun and maximum
-;									values.
-;		<H6>	 4/10/92	SWC		Yet another pass at the DBLite table.
-;		<H5>	  3/4/92	SWC		Next pass at the DBLite table.
-;		<H4>	 2/12/92	SWC		Changed the DB-Lite table limits to have a narrower range of
-;									values.
-;		<H3>	 9/10/91	SWC		Changed the DB-Lite table to have a span of 0..127 instead of
-;									0..255 since the backlight values don't go that high.
-;		<H2>	 8/26/91	SWC		Added a PWM lookup table for DB-Lite.
 ;		 <9>	10/28/91	SAM		Rolled in Regatta file.
 ;		
 ;	Regatta Change History:
@@ -92,6 +71,40 @@ VBLEntry		PROC		EXPORT
 				rts
 
 
+;----------------------------------------------------------------------------------
+;
+MyPostEvent		PROC		EXPORT
+				movem.l	d1/a1,-(sp)
+				lea		postEventData,a1
+				move.l	a0,d1
+				tst.b	5(a1)					; postEventData.keymodifiers
+				beq.s	@noKey
+				cmp.w	#3,d1
+				beq.s	@specialMode
+				tst.b	4(a1)					; postEventData.keysActive
+				beq.s	@noKey
+				cmp.w	#5,d1
+				bne.s	@noKey
+				bra.s	@return
+@specialMode	move.w	$17A,d1
+				rol.w	#1,d1					; d1=1 if command key down
+				cmp.b	5(a1),d1
+				bne.s	@noKey
+
+@yesKey			st		4(a1)					; postEventData.keysActive
+				bra.s	@return
+
+@noKey			sf		4(a1)					; postEventData.keysActive
+				move.l	0(a1),a1
+				jsr		(a1)
+
+@return			movem.l	(sp)+,d1/a1
+				rts
+
+				EXPORT	postEventData
+postEventData	dcb.b	8,0						; see struct in Register.c
+
+
 ;-----------------------------------------------------------------------------------
 ;
 ;
@@ -105,28 +118,11 @@ SleepEntry		PROC		EXPORT
 				move.l	(sp)+,d0
 				clr.l	d0
 				rts								;
-;--------------------------------------------------------------------------------------------------------------
-;
-GetBkltPrimInfo	proc		export
-				with		PmgrRec,PmgrPrimitivesRec
-
-				movea.l		PmgrBase,a0			; point to power manager globals
-				LoadTbl		BklightTblPtr,a0,a0	; get backlight table pointer in a0
-				move.l		a0,d0				; move pointer to d0 for C return
-				rts
-
-
-
-
-			END
 
 ;-----------------------------------------------------------------------------------
 ;
 PortableTable7V	PROC		EXPORT
-			dc.w		0					; minimum value								<H7>
-			dc.w		@end - @start		;											<H7>
-
-@start		dc.b		0					; 0											<H7>
+			dc.b		0					; 0
 			dc.b		1					; 1
 			dc.b		2					; 2
 			dc.b		3					; 3
@@ -156,16 +152,14 @@ PortableTable7V	PROC		EXPORT
 			dc.b		36					; 27
 			dc.b		40					; 28
 			dc.b		45					; 29
-@end		dc.b		50					; 30										<H7>
+			dc.b		50					; 30
+			dc.b		0
 
 
 ;--------------------------------------------------------------------------------------------------------------
 ;
 PortableTbl5V	PROC		EXPORT
-			dc.w		0					; minimum value								<H7>
-			dc.w		@end - @start		;											<H7>
-@start
-			dc.b		0					; 0											<H7>
+			dc.b		0					; 0
 			dc.b		2					; 1
 			dc.b		5					; 2
 			dc.b		7					; 3
@@ -195,55 +189,61 @@ PortableTbl5V	PROC		EXPORT
 			dc.b		66					; 27
 			dc.b		70					; 28
 			dc.b		75					; 29
-@end		dc.b		80					; 30										<H7>
+			dc.b		80					; 30
+			dc.b		0
+
+
+;-------------------------------------------------------------------------------------------------------------
+;
+PortableMaxTbl	PROC		EXPORT			; power range
+			dc.w		30					; 0
+			dc.w		15					; 1
+			dc.w		15					; 2
+			dc.w		 7					; 3
+			dc.w		 3					; 4
 
 
 ;--------------------------------------------------------------------------------------------------------------
 ;
 asahiTbl	PROC		EXPORT
-			dc.w		0					; minimum value								<H7>
-			dc.w		@end - @start		;											<H7>
-
-@start		dc.b		0					; 0											<H7>
-			dc.b		1					; 1
-			dc.b		2					; 2
-			dc.b		3					; 3
-			dc.b		4					; 4
-			dc.b		5					; 5
-			dc.b		6					; 6
-			dc.b		7					; 7
-			dc.b		8					; 8
-			dc.b		9					; 9
-			dc.b		10					; 10
-			dc.b		11					; 11
-			dc.b		12					; 12
-			dc.b		13					; 13
-			dc.b		14					; 14
-			dc.b		15					; 15
-			dc.b		16					; 16
-			dc.b		17					; 17
-			dc.b		18					; 18
-			dc.b		19					; 19
-			dc.b		20					; 20
-			dc.b		21					; 21
-			dc.b		22					; 22
-			dc.b		23					; 23
-			dc.b		24					; 24
+			dc.b		0					; 0
+			dc.b		5					; 1
+			dc.b		6					; 2
+			dc.b		7					; 3
+			dc.b		8					; 4
+			dc.b		9					; 5
+			dc.b		10					; 6
+			dc.b		10					; 7
+			dc.b		11					; 8
+			dc.b		12					; 9
+			dc.b		13					; 10
+			dc.b		14					; 11
+			dc.b		15					; 12
+			dc.b		15					; 13
+			dc.b		16					; 14
+			dc.b		17					; 15
+			dc.b		18					; 16
+			dc.b		19					; 17
+			dc.b		20					; 18
+			dc.b		20					; 19
+			dc.b		21					; 20
+			dc.b		22					; 21
+			dc.b		23					; 22
+			dc.b		24					; 23
+			dc.b		25					; 24
 			dc.b		25					; 25
 			dc.b		26					; 26
 			dc.b		27					; 27
 			dc.b		28					; 28
 			dc.b		29					; 29
 			dc.b		30					; 30
-@end		dc.b		31					; 31										<H7>
+			dc.b		31					; 31
+
 
 ;--------------------------------------------------------------------------------------------------------------
 ;
 timTbl		PROC		EXPORT
-			dc.w		0					; minimum value								<H7>
-			dc.w		@end - @start		;											<H7>
-
-@start		dc.b		31					; 0											<H7>
+			dc.b		31					; 0
 			dc.b		30					; 1
 			dc.b		29					; 2
 			dc.b		28					; 3
@@ -274,15 +274,13 @@ timTbl		PROC		EXPORT
 			dc.b		3					; 28
 			dc.b		2					; 29
 			dc.b		1					; 30
-@end		dc.b		0					; 31										<H7>
+			dc.b		0					; 31
+
 
 ;--------------------------------------------------------------------------------------------------------------
 ;
 timTblLow	PROC		EXPORT
-			dc.w		0					; minimum value								<H7>
-			dc.w		@end - @start		;											<H7>
-
-@start		dc.b		31					; 0											<H7>
+			dc.b		31					; 0
 			dc.b		30					; 1
 			dc.b		30					; 2
 			dc.b		29					; 3
@@ -313,16 +311,8 @@ timTblLow	PROC		EXPORT
 			dc.b		11					; 28
 			dc.b		11					; 29
 			dc.b		10					; 30
-@end		dc.b		10					; 31										<H7>
+			dc.b		10					; 31
 
-;--------------------------------------------------------------------------------------------------------------
-;
-PortableMaxTbl	PROC		EXPORT			; power range
-			dc.w		30					; 0
-			dc.w		15					; 1
-			dc.w		15					; 2
-			dc.w		 7					; 3
-			dc.w		 3					; 4
 
 ;--------------------------------------------------------------------------------------------------------------
 ;
@@ -342,289 +332,4 @@ PotInputRangeShiftTblPWM	PROC		EXPORT
 			dc.w		2					; 3
 			dc.w		3					; 4
 
-;--------------------------------------------------------------------------------------------------------------
-;
-dbTbl		PROC		EXPORT				;											<H2>
-			dc.w		0					; minimum value								<H7>
-			dc.w		@end - @start		;											<H7>
-
-@start		DC.B		127					; 0											<H7>
-			DC.B		89					; 1
-			DC.B		87					; 2
-			DC.B		86					; 3
-			DC.B		84					; 4
-			DC.B		82					; 5
-			DC.B		81					; 6
-			DC.B		79					; 7
-			DC.B		77					; 8
-			DC.B		76					; 9
-			DC.B		74					; 10
-			DC.B		71					; 11
-			DC.B		69					; 12
-			DC.B		67					; 13
-			DC.B		66					; 14
-			DC.B		64					; 15
-			DC.B		62					; 16
-			DC.B		61					; 17
-			DC.B		59					; 18
-			DC.B		57					; 19
-			DC.B		56					; 20
-			DC.B		54					; 21
-			DC.B		52					; 22
-			DC.B		51					; 23
-			DC.B		49					; 24
-			DC.B		47					; 25
-			DC.B		46					; 26
-			DC.B		44					; 27
-			DC.B		42					; 28
-			DC.B		41					; 29
-			DC.B		39					; 30
-@end		DC.B		38					; 31									<H7>
-
-
-;--------------------------------------------------------------------------------------------------------------
-;
-DartTable	proc		export
-			dc.w		0					; minimum value
-			dc.w		@end - @start
-
-@start		dc.b		3					; 0
-			dc.b		2					; 1
-			dc.b		1					; 2
-@end		dc.b		0					; 3
-
-;
-;
-DartMaxTbl	PROC	EXPORT					; power range
-			dc.w		3					; 0
-			dc.w		2					; 1
-			dc.w		2					; 2
-			dc.w		1					; 3
-			dc.w		0					; 4
-
-;--------------------------------------------------------------------------------------------------------------
-;
-;	generic exit for non-supported functions
-;
-StandardExit PROC	EXPORT
-			rts
-;--------------------------------------------------------------------------------------------------------------
-;
-;	list to supported cpu's (boxflags)
-;
-cpuTable	PROC		EXPORT	
-
-			dc.w		boxPortable
-			dc.l		Portableinfo		- cpuTable
-
-			dc.w		boxPowerBook100
-			dc.l		PowerBook100info	- cpuTable
-
-			dc.w		boxPowerBookDuo250											;	<SM3>
-			dc.l		PowerBookDuoinfo	- cpuTable
-
-			dc.w		boxDBLite20
-			dc.l		PowerBookDuoinfo	- cpuTable
-
-			dc.w		boxPowerBookDuo210
-			dc.l		PowerBookDuoinfo	- cpuTable
-
-			dc.w		boxPowerBookDuo230
-			dc.l		PowerBookDuoinfo	- cpuTable
-
-			dc.w		boxPowerBook140										; cpu id
-			dc.l		PowerBook170info	- cpuTable
-
-			dc.w		boxPowerBook170										; cpu id
-			dc.l		PowerBook170info	- cpuTable
-
-			dc.w		boxPowerBook180
-			dc.l		PowerBook180info	- cpuTable
-
-			dc.w		boxPowerBook160
-			dc.l		PowerBook180info	- cpuTable
-
-			dc.w		boxYeagerFSTN												;	<SM3>
-			dc.l		PowerBookDuoinfo	- cpuTable
-
-			dc.w		boxPowerBookDuo270C											;	<SM3>
-			dc.l		PowerBookDuoinfo	- cpuTable
-
-
-			dc.w		-1
-
-;--------------------------------------------------------------------------------------------------------------
-;
-;
-			import		StandardExit
-			import		SetBrightness,KbdControl,InitRegControls,RegisterClose,RegisterControl,RegisterStatus
-			import		SetPWM,PotControl,InitPWMControls,PWMCloseRoutine,PWMControl,GenericStatus,PortableBacklightValue
-			import		SetDart,GetDart,InitTimControls,InitDartControls,PowerMgrPot,ChargerAdjust
-			import		PGE_button
-
-			with		backlightflags
-
-;--------------------------------------------------------------------------------------------------------------
-;
-;
-Portableinfo
-			dc.l		 (0 << disableHWinput)\					; operating flag	(stops user input)
-						+(0 << kbdactive)\						; operating flag 	(kbd control inprogress)
-						+(1 << vbl_ok)\							; operating flag	(allow vbl operations)
-						+(0 << flyByWire)\						; config flag		(hardware input)
-						+(0 << freeflag)\						; (n/a) unused flag
-						+(0 << dualTable)\						; config flag		(use multi tables)
-						+(0 << lowTable)\						; operating flag 	(currently using low table)
-						+(0 << slewChange)						; operating flag 	(table transition inprogress)
-			dc.l		SetBrightness		- Portableinfo		; set routine
-			dc.l		KbdControl			- Portableinfo		; get user input routine
-			dc.l		InitRegControls		- Portableinfo		; initialization routine
-			dc.l		RegisterClose		- Portableinfo		; close routine
-			dc.l		RegisterControl		- Portableinfo		; control routine
-			dc.l		RegisterStatus		- Portableinfo		; status routine
-			dc.l		StandardExit		- Portableinfo		; (n/a) charger state change routine
-			dc.l		PortableMaxTbl		- Portableinfo		; table of maximum value for different power ranges
-			dc.l		PortableTable7V		- Portableinfo		; low range table
-			dc.l		PortableTable7V		- Portableinfo		; high range table
-			dc.l		PowerMgrPot			- Portableinfo		; hardware dependent var
-			dc.w		1										; vbl count SampleRate
-			dc.w		0										; (n/a) lowThreshold
-			dc.w		0										; (n/a) hiThreshold
-
-;--------------------------------------------------------------------------------------------------------------
-;
-;
-PowerBook100info
-			dc.l		 (0 << disableHWinput)\					; operating flag	(stops user input)
-						+(0 << kbdactive)\						; operating flag 	(kbd control inprogress)
-						+(1 << vbl_ok)\							; operating flag	(allow vbl operations)
-						+(1 << flyByWire)\						; config flag		(hardware input)
-						+(0 << freeflag)\						; unused flag
-						+(0 << dualTable)\						; config flag		(use multi tables)
-						+(0 << lowTable)\						; operating flag 	(currently using low table)
-						+(0 << slewChange)						; operating flag 	(table transition inprogress)
-			dc.l		SetPWM				- PowerBook100info	; set routine
-			dc.l		PotControl			- PowerBook100info	; get user input routine
-			dc.l		InitPWMControls		- PowerBook100info	; initialization routine
-			dc.l		PWMCloseRoutine		- PowerBook100info	; close routine
-			dc.l		PWMControl			- PowerBook100info	; control routine
-			dc.l		GenericStatus		- PowerBook100info	; status routine
-			dc.l		StandardExit		- PowerBook100info	; (n/a) charger state change routine
-			dc.l		PWMMaxTbl			- PowerBook100info	; table of maximum value for different power ranges
-			dc.l		asahiTbl			- PowerBook100info	; low range table
-			dc.l		asahiTbl			- PowerBook100info	; high range table
-			dc.l		PortableBacklightValue- PowerBook100info; hardware dependent var
-			dc.w		10										; vbl count SampleRate
-			dc.w		0										; (n/a) lowThreshold
-			dc.w		0										; (n/a) hiThreshold
-
-;--------------------------------------------------------------------------------------------------------------
-;
-;
-HITABLETHRESHOLD170		equ		(685 - 512)
-LOWTABLETHRESHOLD170	equ		(675 - 512)
-
-PowerBook170info
-			dc.l		 (0 << disableHWinput)\					; operating flag	(stops user input)
-						+(0 << kbdactive)\						; (n/a) operating flag 	(kbd control inprogress)
-						+(1 << vbl_ok)\							; operating flag	(allow vbl operations)
-						+(1 << flyByWire)\						; config flag		(hardware input)
-						+(1 << freeflag)\						; (n/a) 
-						+(0 << dualTable)\						; config flag		(use multi tables)
-						+(0 << lowTable)\						; operating flag 	(currently using low table)
-						+(0 << slewChange)						; operating flag 	(table transition inprogress)
-			dc.l		SetPWM				- PowerBook170info	; set routine
-			dc.l		PotControl			- PowerBook170info	; get user input routine
-			dc.l		InitTimControls		- PowerBook170info	; initialization routine
-			dc.l		PWMCloseRoutine		- PowerBook170info	; close routine
-			dc.l		PWMControl			- PowerBook170info	; control routine
-			dc.l		GenericStatus		- PowerBook170info	; status routine
-			dc.l		ChargerAdjust		- PowerBook170info	; charger state change routine
-			dc.l		PWMMaxTbl			- PowerBook170info	; table of maximum value for different power ranges
-			dc.l		timTblLow			- PowerBook170info	; low range table
-			dc.l		timTbl				- PowerBook170info	; high range table
-			dc.l		PowerMgrPot			- PowerBook170info	; hardware dependent var
-			dc.w		10										; vbl count SampleRate
-			dc.w		LOWTABLETHRESHOLD170					; voltage threshold before switching from high to low table
-			dc.w		HITABLETHRESHOLD170 					; voltage threshold before switching from low to high table
-
-
-;--------------------------------------------------------------------------------------------------------------
-;
-;
-PowerBook180info
-			dc.l		 (0 << disableHWinput)\					; operating flag	(stops user input)
-						+(0 << kbdactive)\						; (n/a) operating flag 	(kbd control inprogress)
-						+(1 << vbl_ok)\							; operating flag	(allow vbl operations)
-						+(1 << flyByWire)\						; config flag		(hardware input)
-						+(1 << freeflag)\						; (n/a) 
-						+(1 << dualTable)\						; config flag		(use multi tables)
-						+(0 << lowTable)\						; operating flag 	(currently using low table)
-						+(0 << slewChange)						; operating flag 	(table transition inprogress)
-			dc.l		SetPWM				- PowerBook180info	; set routine
-			dc.l		PotControl			- PowerBook180info	; get user input routine
-			dc.l		InitPWMControls		- PowerBook180info	; initialization routine
-			dc.l		PWMCloseRoutine		- PowerBook180info	; close routine
-			dc.l		PWMControl			- PowerBook180info	; control routine
-			dc.l		GenericStatus		- PowerBook180info	; status routine
-			dc.l		ChargerAdjust		- PowerBook180info	; charger state change routine
-			dc.l		PWMMaxTbl			- PowerBook180info	; table of maximum value for different power ranges
-			dc.l		timTblLow			- PowerBook180info	; low range table
-			dc.l		timTbl				- PowerBook180info	; high range table
-			dc.l		PowerMgrPot			- PowerBook180info	; hardware dependent var
-			dc.w		10										; vbl count SampleRate
-			dc.w		LOWTABLETHRESHOLD170					; voltage threshold before switching from high to low table
-			dc.w		HITABLETHRESHOLD170 					; voltage threshold before switching from low to high table
-
-PowerBook180infoHWControl
-			dc.l		 (0 << disableHWinput)\					; operating flag	(stops user input)
-						+(0 << kbdactive)\						; operating flag 	(kbd control inprogress)
-						+(1 << vbl_ok)\							; operating flag	(allow vbl operations)
-						+(1 << flyByWire)\						; config flag		(hardware input)
-						+(1 << freeflag)\
-						+(0 << dualTable)\						; config flag		(use multi tables)
-						+(0 << lowTable)\						; operating flag 	(currently using low table)
-						+(0 << slewChange)						; operating flag 	(table transition inprogress)
-			dc.l		SetPWM				- PowerBook180info	; set routine
-			dc.l		PotControl			- PowerBook180info	; get user input routine
-			dc.l		InitDartControls	- PowerBook180info	; initialization routine
-			dc.l		PWMCloseRoutine		- PowerBook180info	; close routine
-			dc.l		PWMControl			- PowerBook180info	; control routine
-			dc.l		GenericStatus		- PowerBook180info	; status routine
-			dc.l		0										; (n/a) charger state change routine
-			dc.l		DartMaxTbl			- PowerBook180info		; table of maximum value for different power ranges
-			dc.l		DartTable			- PowerBook180info		; low range table
-			dc.l		DartTable			- PowerBook180info		; high range table
-			dc.l		PowerMgrPot			- PowerBook180info		; hardware dependent var
-			dc.w		10										; vbl count SampleRate
-			dc.w		0										; (n/a) lowThreshold
-			dc.w		0										; (n/a) hiThreshold
-
-;--------------------------------------------------------------------------------------------------------------
-;
-;
-PowerBookDuoinfo
-			dc.l		 (0 << disableHWinput)\					; operating flag	(stops user input)
-						+(0 << kbdactive)\						; operating flag 	(kbd control inprogress)
-						+(1 << vbl_ok)\							; operating flag	(allow vbl operations)
-						+(1 << flyByWire)\						; config flag		(hardware input)
-						+(1 << freeflag)\
-						+(0 << dualTable)\						; config flag		(use multi tables)
-						+(0 << lowTable)\						; operating flag 	(currently using low table)
-						+(0 << slewChange)						; operating flag 	(table transition inprogress)
-			dc.l		SetPWM				- PowerBookDuoinfo	; set routine
-			dc.l		PotControl			- PowerBookDuoinfo	; get user input routine
-			dc.l		InitPWMControls		- PowerBookDuoinfo	; initialize routine
-			dc.l		PWMCloseRoutine		- PowerBookDuoinfo	; close routine
-			dc.l		PWMControl			- PowerBookDuoinfo	; control routine
-			dc.l		GenericStatus		- PowerBookDuoinfo	; status routine
-			dc.l		StandardExit		- PowerBookDuoinfo	; (n/a) charger state change routine
-			dc.l		PWMMaxTbl			- PowerBookDuoinfo	; table of maximum value for different power ranges
-			dc.l		dbTbl				- PowerBookDuoinfo	; low range table
-			dc.l		dbTbl				- PowerBookDuoinfo	; high range table
-			dc.l		PGE_button			- PowerBookDuoinfo	; hardware dependent var
-			dc.w		10										; vbl count SampleRate
-			dc.w		0										; (n/a) lowThreshold
-			dc.w		0										; (n/a) hiThreshold
-
 			END
diff --git a/Drivers/Backlight/backlight.c b/Drivers/Backlight/backlight.c
--- a/Drivers/Backlight/backlight.c
+++ b/Drivers/Backlight/backlight.c
@@ -9,16 +9,6 @@
 
 	Change History (most recent first):
 
-	   <SM6>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
-									machines
-	   <SM5>	 9/2/93		SKH		Update from Horror.
-	   <SM4>	 2/11/93	CSS		Update from Horror. Comments follow <H5-H2>:
-		<H5>	 11/9/92	ag		Corrected compare statement. The compiler generated a long
-									compare, so we must type cast the value to avoid the mismatch in
-									types.
-		<H4>	 6/30/92	ag		Use cpu info tables for configuring cpu dependent information.
-		<H3>	 4/24/92	ag		added support for error returns on hardware initialization.
-									this will return an open error on unknown hardware.
 	    <H2>	  8/5/91	SWC		Make InitPWMControls the default init choice in DRVROpen so that
 									proc vectors are always initialized.
 		<12>	 3/30/92	JSM		Rolled this file into SuperMario project.
@@ -172,13 +162,8 @@ pascal OSErr DRVROpen(CntrlParam *ctlPB,DCtlPtr dCtl)				/* 'open' entry point *
 #pragma	unused (ctlPB)
 	register driverGlobalPtr	globalPtr;							/* pointer to globals */
 	PmgrGlobals					**pmgrglobalhdl;					/* handle to power manager globals */
-	OSErr						error;
-	cpuDependentInfoType 		*cpuinfo;
-	OSErr						(*openProc)();
+	char						boxFlag;
 	
-	cpuinfo = GetBkltPrimInfo();
-	if (!cpuinfo) return(openErr);
-
   	globalPtr	= (driverGlobalPtr) NewPtrSysClear(sizeof(driverGlobaltypes));	
 	if (!globalPtr) return(openErr);								/* not enough memory, return error */
 
@@ -188,45 +173,24 @@ pascal OSErr DRVROpen(CntrlParam *ctlPB,DCtlPtr dCtl)				/* 'open' entry point *
 /* setup variables */
 	globalPtr->version			= DRIVERVERSION;					/* driver version number, in globals for easy patching */
 
-	*((unsigned int *)(((int)&(globalPtr->version)) + sizeof(globalPtr->version))) =  cpuinfo->bkltinfo->flags;
-	globalPtr->lowThreshold			= cpuinfo->bkltinfo->lowThreshold; 		/*low hysteresis threshold */
-	globalPtr->hiThreshold			= cpuinfo->bkltinfo->hiThreshold;			/* high hysteresis threshold */
-	globalPtr->userInputSampleRate 	= cpuinfo->bkltinfo->userInputSampleRate;	/* sample every 160ms */
+  	globalPtr->vbl_ok = true;
 
 	globalPtr->lastLevel		= (*pmgrglobalhdl)->LastLevel;		/* get current power level */
 //	globalPtr->userRange		= 0;								/* allow full power level */
 	globalPtr->powerRange		= Larger(globalPtr->lastLevel,globalPtr->userRange);
 
-/* initialize tables */	
-	globalPtr->maximumTable			= (short *) (cpuinfo->bkltroutines->maxTable);							
-	globalPtr->settingTableLow		= (setTableType *) (cpuinfo->bkltroutines->lowTable); /* <H8> */						
-	globalPtr->settingTableHigh		= (setTableType *) (cpuinfo->bkltroutines->hiTable);	/* <H8> */						
-	globalPtr->settingTable			= globalPtr->settingTableHigh;							
-
-/* initialize vectors */	
-	globalPtr->setlevelproc			= (intFunction) (cpuinfo->bkltroutines->setProc);			/* proc to set level */						
-	globalPtr->userInputProc		= (intFunction) (cpuinfo->bkltroutines->getProc);		/* proc to read user input */
-	openProc						= (osFunction) (cpuinfo->bkltroutines->open);	/* routine to close pwm hardware */
-	globalPtr->closeProc			= (intFunction) (cpuinfo->bkltroutines->close);	/* routine to close pwm hardware */
-	globalPtr->controlProc			= (osFunction) (cpuinfo->bkltroutines->control);		/* passed control routine */
-	globalPtr->statusProc			= (osFunction) (cpuinfo->bkltroutines->status);	/* passed status routine */
-	globalPtr->hardwareDependentPtr = (Ptr) (cpuinfo->bkltroutines->hwDependentVar);
-	globalPtr->tableProc 			= (voidFunction) (cpuinfo->bkltroutines->tableProc);	
-
-
-/* call custom initialization routine */	
-	if (openProc) 
+	boxFlag = *(char *)0xCB3;
+	switch (boxFlag)
 		{
-		error = (*openProc)(globalPtr);
-		if (error)
-			{
-			DisposPtr((Ptr) globalPtr);									/* release memory */
-			dCtl->dCtlStorage 	= NULL;	
-			return(error);												/* clear out saved value for next open */
-			};
-		};
-
-
+		case 4: // Portable
+			InitRegControls(globalPtr);
+			break;
+		case 15: // PowerBook 170, TIM
+		case 18: // PowerBook 100, Asahi
+		default:
+			InitPWMControls(globalPtr);
+			break;
+		}
 
 	globalPtr->brightnessVbl.globals 			= (Ptr) globalPtr;
 	globalPtr->brightnessVbl.vblpb.qType 		= vType;
@@ -257,7 +221,6 @@ pascal OSErr DRVRClose(CntrlParam *ctlPB,DCtlPtr dCtl)			/* 'open' entry point *
 
 	globalPtr			= (driverGlobalPtr) dCtl->dCtlStorage;	/* set context to my global data area */
 
-	globalPtr->slewChange	= false;							/* always turn off slew during close <H6> */					
 	VRemove((QElemPtr) &globalPtr->brightnessVbl.vblpb);		/* remove vbl task */
 	if (globalPtr->closeProc != NULL) 							/* if hw close proc … */
 		(*globalPtr->closeProc)(globalPtr);						/* … call close proc */
@@ -390,27 +353,10 @@ pascal OSErr DRVRStatus(CntrlParam *ctlPB,DCtlPtr dCtl)			/* 'open' entry point
 	globalPtr->vbl_ok = false;									/* disable vbl task */
 	switch(ctlPB->csCode) 
 		{
-		case kGetUserInput:
-			ctlPB->csParam[0] = globalPtr->
-						userInputProc( globalPtr );				/* Get the button inputs	*/
-			break;
-
 		case KGetVersion:												
 			ctlPB->csParam[0] = globalPtr->version;				/* return current driver version */
 			break;
 
-		case kGetScreenBrightness:								/* <H4> return current saved brightness */
-			ctlPB->csParam[0] = globalPtr->userBrightness;
-			break;
-
-		case kGetBrightnessRange:								/* <H4> return range of brightness values */
-			ctlPB->csParam[0] = globalPtr->settingTable->maximum;/* <H4> using new tables, return max setting */
-			ctlPB->csParam[1] = globalPtr->settingTable->minimum;/* <H4> using new tables, return min setting */
-			break;
-		case kGetMaximum:										/* <H4> */
-			ctlPB->csParam[0] = globalPtr->maximumTable[globalPtr->powerRange];
-			break;
-
 		default:
 			error = (*globalPtr->statusProc)(ctlPB,globalPtr);
 		};
@@ -526,7 +472,7 @@ PowerChange  (driverGlobalPtr	globalPtr, int currentPowerLevel)
 		{
 		if (!globalPtr->flyByWire && userInput)					/* if only software controls and backlight on */
 			{
-			userInput >>= 1;									/* reduce power by 1/2 */
+			userInput = globalPtr->userBrightness >> 1;			/* reduce power by 1/2 */
 			if (!userInput) userInput = 1;						/* insure at least on */
 			};
 		};
@@ -539,47 +485,20 @@ PowerChange  (driverGlobalPtr	globalPtr, int currentPowerLevel)
  *
  ***************************************************************************************************
  */
-
-/*page
- ***************************************************************************************************
- *
- *
- ***************************************************************************************************
- */
-unsigned int LowTable  (driverGlobalPtr	globalPtr)
-
+int GetBacklightInfo(short mask, short shift)
 {
-	PmgrGlobals					**pmgrglobalhdl;				/* handle to power manager globals */
-	Boolean						wasLowTable;					/* current table being used */
-	Boolean						hiTable;						/* use hi level table  now */
-
-	pmgrglobalhdl 	= (PmgrGlobals **) 0x0D18;					/* handle to power manager globals */
-
-	wasLowTable		= globalPtr->lowTable;						/* current table */
-	hiTable 		= false;									/* assume low table */
-	if ((wasLowTable && ((*pmgrglobalhdl)->BatAvg >= globalPtr->hiThreshold)) ||
-		(!wasLowTable && ((*pmgrglobalhdl)->BatAvg >= globalPtr->lowThreshold)))
-		{
-		hiTable = (*pmgrglobalhdl)->Charger & 0x01;				/* qualify table with charger */
-		};
-	return(hiTable ? 0 : 1);									/* return 1 if low table, 0 if high */
-};
+	unsigned char buf;
+	ReadXPram(0x74, sizeof(buf), &buf);
+	return (buf & mask) >> shift;
+}
 
-/*page
- ***************************************************************************************************
- *
- *
- ***************************************************************************************************
- */
-void ChargerAdjust  (driverGlobalPtr	globalPtr)
-{		
-	unsigned int				oldTable;
-
-	oldTable			= globalPtr->lowTable;					/* save the current table being used */
-	globalPtr->lowTable =  LowTable(globalPtr);					/* get the new table to use */
-	if (globalPtr->lowTable == oldTable) return;				/* are we changing tables ???, no exit */
-
-	globalPtr->slewChange		= true;							/* if change, set tmp slew on */					
-	globalPtr->settingTable		= globalPtr->lowTable ? globalPtr->settingTableLow :globalPtr->settingTableHigh ;							
-};
+void SaveBacklightInfo(short new, short mask, short shift)
+{
+	int addr = 0x70;
+	unsigned char buf;
+	ReadXPram(addr + 4, sizeof(buf), &buf);
+	buf &= ~mask;
+	buf |= (new << shift) & mask;
+	WriteXPram(addr + 4, sizeof(buf), &buf);
+}
 
diff --git a/Drivers/Backlight/backlight.h b/Drivers/Backlight/backlight.h
--- a/Drivers/Backlight/backlight.h
+++ b/Drivers/Backlight/backlight.h
@@ -9,23 +9,6 @@
 
 	Change History (most recent first):
 
-	   <SM7>	  1/5/94	kc		Add Function ProtoTypes to prevent compiler warnings.
-	   <SM6>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
-									machines
-	   <SM5>	 9/2/93		SKH		Roll in changes from Horror
-	   <SM4>	 2/11/93	CSS		Remove boxflags from this file.  
-	   								Update from Horror.  Comments follow <H10-2>:
-	   <H10>	 1/21/93	RLE		add Escher box flags
-		<H9>	 6/30/92	ag		Added new type definitions.
-		<H8>	  5/7/92	ag		Added new type definitions to accomodate table changes.
-		<H7>	 4/24/92	ag		added new hardware dependent field for general use by hardware
-									dependent code.  added new typedefs to allow for easier type
-									conhersion.
-		<H6>	12/17/91	SWC		Added boxDBLiteLC.
-		<H5>	12/16/91	HJR		Added boxDartanian.
-	    <H4>	 11/5/91	SWC		Fixed boxDBLite again because we got pushed out to a new value.
-		<H3>	 9/10/91	SWC		Fixed boxAsahi and boxDBLite to reflect final values.
-		<H2>	  8/5/91	SWC		Added boxDBLite to list of CPUs we work with.
  		 <8>	 3/30/92	JSM		Rolled this file into SuperMario project.
 		 <7>	 3/24/92	JSM		Nuke boxFlag codenames.
 		 <6>	10/28/91	SAM		Rolled in Regatta file.
@@ -65,7 +48,7 @@
  *
  */
 #define	DRIVERMAJORVERSION		0x0100
-#define	DRIVERMINORVERSION		0x0001
+#define	DRIVERMINORVERSION		0x0002
 #define DRIVERVERSION			(DRIVERMAJORVERSION + DRIVERMINORVERSION)
 
 /* Control Calls */
@@ -154,13 +137,6 @@ typedef struct
 	VBLTask				vblpb;
 	} vblstruct;
 
-typedef struct
-	{
-	short				minimum;
-	short				maximum;
-	unsigned char		table[];
-	} setTableType;									/* <H8> new structure for tables */
-
 typedef struct
 	{
 	SleepQRec		sleepQelement;					/* sleep queue element, MUST stay on top */
@@ -187,9 +163,9 @@ typedef struct
 	short			slewLimit;
 	unsigned short	lowThreshold;
 	unsigned short	hiThreshold;
-	setTableType	*settingTable;					/* <H8> pointer to record now */
-	setTableType	*settingTableLow;				/* <H8> pointer to record now */
-	setTableType	*settingTableHigh;				/* <H8> pointer to record now */
+	unsigned char	*settingTable;
+	unsigned char	*settingTableLow;
+	unsigned char	*settingTableHigh;
 	short			*maximumTable;
 
 	short			lastLevel;						/* last power level */
@@ -203,8 +179,6 @@ typedef struct
 	short			mousedownTicks;					/* first notice of mouse down in tick count */
 	short			keycodes;						/* key combinations */
 	short			lastatod;						/* last raw a to d value */
-	
-	Ptr				hardwareDependentPtr;			/* private storage for hardware dependent code */
 	} driverGlobaltypes, *driverGlobalPtr;
 
 typedef struct 
@@ -248,20 +222,20 @@ typedef struct
 #define	SaveBrightness(new)		SaveBacklightInfo(new+1,VALUE_MASK, 0)
 #define	SaveKeyData(new)		SaveBacklightInfo(new,KEY_MASK, 5)
 
-/* <H8> new ponti defintions */
-#define	PONTILMPCTLREG			*((unsigned char *) 0x50f96C00)
-#define	PONTILMPON				0
-#define	PONTILMPHWCTL			1
-#define	PONTILMPMUX0			2
-#define	PONTILMPMUX1			3
-
 typedef	int 	(*intFunction)();
 typedef OSErr	(*osFunction)();
 typedef void	(*voidFunction)();
 
 int abs(int);
 unsigned char GetPortableValues(int	parameter);
-OSErr InitPWMControls(driverGlobalPtr globalPtr);
+void InitPWMControls(driverGlobalPtr globalPtr);
 unsigned char Get_AtoD(int channel);
 unsigned char Get_PGEButton(int	channel);
-int SetPWM(int new, driverGlobalPtr globalPtr);
\ No newline at end of file
+int SetPWM(int new, driverGlobalPtr globalPtr);
+void InitRegControls(driverGlobalPtr globalPtr);
+int PotControl (driverGlobalPtr globalPtr);
+int PWMCloseRoutine (driverGlobalPtr globalPtr);
+OSErr PWMControl(CntrlParam *ctlPB,driverGlobalPtr globalPtr);
+OSErr PWMStatus(CntrlParam *ctlPB,driverGlobalPtr globalPtr);
+unsigned int LowTable (driverGlobalPtr globalPtr);
+void ChargerAdjust (driverGlobalPtr globalPtr);
diff --git a/Drivers/Video/TFBDriver.a b/Drivers/Video/TFBDriver.a
--- a/Drivers/Video/TFBDriver.a
+++ b/Drivers/Video/TFBDriver.a
@@ -10,7 +10,6 @@
 ;	Change History (most recent first):
 ;
 ;	   <SM3>	 11/3/92	SWC		Changed SlotEqu.a->Slots.a and VideoEqu.a->Video.a.
-;		<SM2>	10/27/92	CSS		Changed some short branches to word branches.
 ;		 <8>	 8/21/91	JSM		Clean up header.
 ;		 <7>	  4/3/91	jmp		TFB registers are byte wide, but the TFB reset register was
 ;									being written to as a word.  So, I changed a Move.w to a Move.b
@@ -811,11 +810,11 @@ SetGamma										; <C522/15Dec86> DAF
 			MOVE.L	D0,A1							; get pointer to new gamma table
 
 			TST.L	GVersion(A1)					; version, type = 0?
-			BNE 	BadCtl							; => no, return error <SM2> CSS
+			BNE.S	BadCtl							; => no, return error
 			CMP		#8,GDataWidth(A1)				; is data width 8?
-			BNE 	BadCtl							; => no, return error <SM2> CSS
+			BNE.S	BadCtl							; => no, return error
 			CMP		#256,GDataCnt(A1)				; 256 values per channel?
-			BNE 	BadCtl							; => no, return error <SM2> CSS
+			BNE.S	BadCtl							; => no, return error
 
 ; if new table is different size, reallocate memory
 
diff --git a/Interfaces/AIncludes/AppleTalk.a b/Interfaces/AIncludes/AppleTalk.a
--- a/Interfaces/AIncludes/AppleTalk.a
+++ b/Interfaces/AIncludes/AppleTalk.a
@@ -8,9 +8,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 1/29/93	RB		Change the SCCLockout value to 600 instead of 2600, because the
-;									other bits in the status register should remain unchanged for
-;									NewKernel.
 ;		<11>	  7/1/92	DCL		Obsoleted ATalkEqu.a which now includes this file.
 ;		<10>	 6/14/91	JL		Equated clientName and xppSubCode to $1C insteead of csCode
 ;									because csCode is in SysEqu.a which would have to be included.
@@ -134,9 +131,9 @@ crcErr			EQU 		-2
 underrunErr   	EQU 		-3
 lengthErr 		EQU 		-4
 ;
-; SCC interrupt priority		Should NEVER MOVE.W this value, just ORI.W						<SM2> rb
+; SCC interrupt priority
 ;
-sccLockout		EQU 		$600     				; This value works on both Mac and Lisa		<SM2> rb
+sccLockout		EQU 		$2600     				; This value works on both Mac and Lisa
 ;
 ;
 ;+ MPP (control calls to NBP, DDP and ABLAP)
diff --git a/Interfaces/AIncludes/FSPrivate.a b/Interfaces/AIncludes/FSPrivate.a
--- a/Interfaces/AIncludes/FSPrivate.a
+++ b/Interfaces/AIncludes/FSPrivate.a
@@ -10,8 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 4/14/92	kc		Change LenBTCB from 54 to 74. Change hfsStkLen from 1280 to
-;									1792.
 ;		<13>	 1/30/91	gbm		sab, #38: Change the ‘already including this file’ variable to
 ;									all uppercase (for security reasons)
 ;		<12>	 8/28/90	KST		Make FCFree work as FCtrash on 6.0 RamCache
@@ -122,7 +120,7 @@ maxHFSTrap		EQU 		17        				; Highest TFS trap dispatch index
 hfsVars   		EQU 		$36A      				; Start of TFS variables in RAM version
 ; (previously RgSvArea)
 hfsTmpSize		EQU 		16        				; Additional temporary space for TFS
-hfsStkLen 		EQU 		1792      				; Allocate a decent-sized chunk of memory	<SM2>
+hfsStkLen 		EQU 		1280      				; Allocate a decent-sized chunk of memory
 HFSStkTop 		EQU 		$36A      				; Temporary location of pointer to top of Stack
 HFSStkPtr 		EQU 		$36E      				; Temporary location of TFS Stack pointer
 WDCBsPtr  		EQU 		$372      				; Working Directory queue header
@@ -384,7 +382,7 @@ btcNodeSize   	EQU 		42        				; BTree node size in bytes (word)
 btcKeyLen 		EQU 		44        				; max key length (word)
 btcNNodes 		EQU 		46        				; total number of nodes (long)
 btcFree   		EQU 		50        				; number of free nodes (long)
-LenBTCB   		EQU 		74        				; length of a BTCB		<SM2>
+LenBTCB   		EQU 		54        				; length of a BTCB
 
 ;
 ; BTree Variables (btVars) layout
diff --git a/Interfaces/AIncludes/GestaltEqu.a b/Interfaces/AIncludes/GestaltEqu.a
--- a/Interfaces/AIncludes/GestaltEqu.a
+++ b/Interfaces/AIncludes/GestaltEqu.a
@@ -10,63 +10,13 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM26>	 12/2/93	JDR		updated gestaltFinderAttr, added gestaltQuickTimeFeatures
-;	  <SM25>	 11/8/93	JRH		Added gestaltPowerBookDuo250 and gestaltPowerBookDuo270C.
-;	  <SM24>	10/28/93	SAM		Roll in <MC4> from mc900ftjesus.
-;	   <MC4>	10/28/93	SAM		Changed gestaltNativeCPUtype equates (making each cpu type take
-;									a range of 256 per architecture).
-;	  <SM23>	10/14/93	pdw		Added 'scsi' selector and bits.
-;	  <SM22>	09-24-93	jmp		Rolled in various equates from the Excelsior sources.
-;	  <SM21>	 8/12/93	BG		Updated the MachineType list to be somewhere closer to current.
-;	  <SM20>	  8/4/93	JDR		synch with Sound Mgr project.
-;		<19>	  8/4/93	IH		#1101633,1098397,1101795,1101636,1102280 <KON>: Fix 1102280. Add
-;									CloseView and Display Manager gestalt selectors.
-;	  <SM18>	 6/23/93	CSS		Update from Reality:
-;		<67>	  6/9/93	DRF		#1087472: Add gestaltFinderSupports4GBVolumes and
-;									gestaltFinderHandlesCFMFailures to gestaltFinderAttr.
-;		<66>	  6/1/93	DTY		Standardize Icon Utilities selector name.
-;		<65>	 5/11/93	JMF		Added equates for gestaltKeyboardType for the Apple
-;									Adjustable Keyboard (ISO & US) & Keypad
-;		<64>	 4/27/93	KIP		Add gestalt16BitSoundIO, gestaltStereoInput and
-;									gestaltLineLevelInput selectors.
-;		<63>	 3/29/93	ash		Added gestalt attribute/selectors for Macintosh PC Exchange as
-;									well as additional selector for Translation Manager.
-;		<62>	 3/29/93	ngk		Add GestaltValue macros
-;		<61>	 3/19/93	mgl		Add gestaltFinderAttr for Finder attributes.
-;		<60>	  3/5/93	JDR		Added gestalt16BitAudioSupport.
-;		<59>	 2/26/93	hjcr	Add the gestaltBgndMouseDownSupport bit
-;		<58>	 1/18/93	ash		Add selectors for Macintosh Easy Open and Translation Manager
-;	  <SM17>	 6/14/93	kc		Roll in Ludwig.
-;	   <LW3>	 4/29/93	fau		Bug #1081636:  Update from Reality:  changed some of the
-;									gestaltSoundattr bit assignments and added some others.
-;	  <SM16>	  3/2/93	CSS		Update from Horror. Comments follow:
-;		<H4>	12/15/92	RLE		add more released machines
-;		<H3>	 6/16/92	SWC		Added gestaltAppleEventsAttr.
-;		<H2>	11/12/91	jmp		Just brought this file slightly more up-to-date than it was;
-;	  <SM15>	 2/11/93	SAM		Added EMMU emulated MMU type. (Hooray for change SM14 !!!)
-;     <SM14>	02/10/93	HY		Remove change <SM13>.
-;	  <SM13>	01/11/93	HY		Added bit gestaltNoAtlkSupport in the gestaltMiscAttr selector.
-;	  <SM12>	12/13/92	SAM		Added gestaltNativeCPUtype and gestaltSysArchitecture.  Cleaned
-;									up this file (what a mess!)
-;	   <SM11>	10/27/92	fau		Added a gestaltHasEnhancedLTtlk bit to gestaltHardwareAttr.
-;	   <SM10>	 7/29/92	CSS		Update from Reality:
-;									<57> 7/28/92 JDR	<DCL> Added Sound Mgr 3.0 flags.
-;	   <SM9>	 7/28/92	WS		add realtime manager attribute for gestalt call
-;	   <SM8)	 7/20/92	CSS		Remove information about soundhardware from this file 
-;									as JDR has put the same information into GestaltEquPriv.a.
-;	   <SM7>	 7/15/92	RB		Added the gestalt result for Classic hardware.
-;	   <SM6>	 7/14/92	RB		Added the selector and types associated with sound hardware.
-;	   <SM5>	 6/10/92	CSS		Roll-in Reality changes:	
-;									<56> 6/5/92	 DC		Add the selector for checking for the presence of icon
-;														utilities.
-;									<55> 6/2/92	 JSM	#1031451 <csd>: Add gestaltPowerBook145.
-;									<54> 5/27/92 KIP	#1030293,<JDR>: Add gestaltPlayAndRecord bit for sound
-;														attributes.
-;									<53> 5/27/92 DCL	Moved gestaltQuadra950 into the public consciousness.
-;	   <SM4>	 5/20/92	KW		Put in Pandora additions P2
-;	   <SM3>	 5/19/92	CS		fix header
-;	   <SM2>	 5/19/92	CS		Integrated changes from Reality:
-;									<52> 4/9/92 JSM #1026795,<DTY>: Add gestaltMacLCII.
+;		<56>	 6/5/92		DC		Add the selector for checking for the presence of icon
+;									utilities.
+;		<55>	 6/2/92		JSM		#1031451 <csd>: Add gestaltPowerBook145.
+;		<54>	 5/27/92	KIP		#1030293,<JDR>: Add gestaltPlayAndRecord bit for sound
+;									attributes.
+;		<53>	 5/27/92	DCL		Moved gestaltQuadra950 into the public consciousness.
+;		<52>	  4/9/92	JSM		#1026795,<DTY>: Add gestaltMacLCII.
 ;		<51>	  1/7/92	KST		Added gestaltTSMgrVersion.
 ;		<50>	 12/3/91	SAM		Moved 'hwdr' bits gestaltHasSCSI961 and gestaltHasSCSI962 here
 ;									from the private Gestalt equates.
@@ -203,11 +153,6 @@ gestaltAppleTalkVersion		EQU		'atlk'    		; AppleTalk version
 gestaltAUXVersion			EQU 	'a/ux'    		; a/ux version, if present
 gestaltAUXNotPresent		EQU		0
 
-gestaltCloseViewAttr		EQU		'BSDa'			; CloseView attributes
-
-gestaltCloseViewEnabled					EQU 0		; Closeview enabled (dynamic bit - returns current state)
-gestaltCloseViewDisplayMgrFriendly		EQU 1		; Closeview compatible with Display Manager (FUTURE)
-
 gestaltComponentMgr 		EQU		'cpnt'			; Component Mgr version
 
 gestaltTSMgrVersion			EQU		'tsmv'			; Text Services Mgr version, if present
@@ -218,19 +163,6 @@ gestaltConnMgrCMSearchFix	EQU		1				; do we have fix to CMAddSearch?
 gestaltConnMgrErrorString	EQU		2
 gestaltConnMgrMultiAsyncIO	EQU		3
 
-gestaltNativeCPUtype		EQU		'cput'			; The native CPU type			<SM12><MC4>
-	; 68000 Architecture
-gestaltCPU68000				EQU 	$000
-gestaltCPU68010				EQU 	$001
-gestaltCPU68020				EQU 	$002
-gestaltCPU68030				EQU 	$003
-gestaltCPU68040				EQU 	$004
-	; PowerPC Architecture
-gestaltCPU601				EQU		$101			; IBM 601
-gestaltCPU603				EQU		$103
-gestaltCPU604				EQU		$104
-
-
 gestaltCRMAttr				EQU		'crm '			; comm resource mgr attributes
 gestaltCRMPresent			EQU		0				
 gestaltCRMPersistentFix		EQU		1				; fix for persistent connections present
@@ -247,11 +179,6 @@ gestaltDictionaryMgrPresent	EQU		0				; Dictionary Manager attributes
 gestaltDITLExtAttr			EQU		'ditl'    		; AppenDITL, etc. calls from CTB
 gestaltDITLExtPresent		EQU		0     			; True if calls are present
 
-gestaltDisplayMgrAttr		EQU		'dply'			; Display Manager attributes
-gestaltDisplayMgrPresent 	EQU		 0				; True if Display Mgr is present
-
-gestaltDisplayMgrVers		EQU		'dplv'			; Display Manager version
-
 gestaltEasyAccessAttr		EQU 	'easy'    		; Easy Access attributes
 gestaltEasyAccessOff		EQU		0     			; if Easy Access present, but off (no icon)
 gestaltEasyAccessOn			EQU		1     			; if Easy Access "On"
@@ -260,21 +187,10 @@ gestaltEasyAccessLocked		EQU		3     			; if Easy Access "Locked"
 
 gestaltEditionMgrAttr		EQU 	'edtn'    		; Edition Mgr attributes
 gestaltEditionMgrPresent	EQU		0     			; True if Edition Mgr present
-gestaltEditionMgrTranslationAware	EQU		1		; True if edition manager is translation manager aware
-gestaltTranslationMgrHintOrder		EQU		1		; True if hint order reversal in effect 
 
 gestaltAppleEventsAttr		EQU		'evnt'    		; Apple Events attributes
 gestaltAppleEventsPresent	EQU		0     			; True if Apple Events present
 
-gestaltFinderAttr			EQU		'fndr'			; Finder attributes
-gestaltFinderDropEvent		EQU		0				; Finder recognizes drop event
-gestaltFinderMagicPlacement	EQU		1				; Finder supports magic icon placement
-gestaltFinderCallsAEProcess	EQU		2				; Finder calls AEProcessAppleEvent
-gestaltOSLCompliantFinder	EQU		3				; Finder is scriptable and recordable
-gestaltFinderSupports4GBVolumes	EQU		4			; Finder correctly handles 4GB volumes
-gestaltFinderHandlesCFMFailures	EQU		5			; Finder handles Code Fragment Manager errors
-gestaltFinderHasClippings	EQU		6				; Finder supports Drag Manager clipping files
-
 gestaltFindFolderAttr		EQU  	'fold'    		; FindFolder attributes
 gestaltFindFolderPresent	EQU		0     			; True if FindFolder present
 
@@ -307,7 +223,6 @@ gestaltHasSoftPowerOff		EQU		19				; Capable of software power off
 gestaltHasSCSI961			EQU		21				; 53C96 SCSI controller on internal bus	<50>
 gestaltHasSCSI962			EQU		22				; 53C96 SCSI controller on external bus	<50>
 gestaltHasUniversalROM		EQU		24				; Do we gots a Universal ROM?			<49>
-gestaltHasEnhancedLtalk		EQU		30				; Do we have Enhanced LocalTalk
 
 gestaltHelpMgrAttr			EQU		'help'    		; Help Mgr Attributes
 gestaltHelpMgrPresent		EQU 	0     			; true if help mgr is present
@@ -327,9 +242,6 @@ gestaltADBKbdII				EQU		10
 gestaltADBISOKbdII			EQU		11
 gestaltPwrBookADBKbd		EQU		12				; <49>
 gestaltPwrBookISOADBKbd		EQU		13				; <49>
-gestaltAppleAdjustKeypad	EQU		14				; <65>
-gestaltAppleAdjustADBKbd	EQU		15				; <65>
-gestaltAppleAdjustISOKbd	EQU		16				; <65>
 
 
 gestaltLowMemorySize		EQU  	'lmem'    		; size of low-memory area
@@ -346,7 +258,6 @@ gestaltAMU					EQU 	1     			; address management unit
 gestalt68851				EQU 	2     			; 68851 PMMU
 gestalt68030MMU				EQU 	3     			; 68030 built-in MMU
 gestalt68040MMU				EQU 	4     			; 68040 built-in MMU
-gestaltEMMU1				EQU		5				; Emulated MMU type 1 (Power PC systems)
 
 gestaltNotificationMgrAttr	EQU		'nmgr'   		; notification manager attributes
 gestaltNotificationPresent	EQU		0    			; notification manager exists
@@ -367,17 +278,12 @@ gestaltTempMemTracked		EQU 	6         		; temporary memory handles are tracked
 gestaltIPCSupport			EQU 	7         		; IPC support is present
 gestaltSysDebuggerSupport	EQU 	8         		; system debugger support is present
 ; gestaltSkiaGlobalsSwitched is #9. I don't know why it is not here
-gestaltBgndMouseDownSupport	EQU		10				; Background mouse down support is present
 
 
 gestaltOSTable				EQU		'ostt'			; OS trap table base
 gestaltToolboxTable			EQU		'tbtt'			; Toolbox trap table base
 gestaltExtToolboxTable		EQU		'xttt'			; Extended Toolbox trap table base
 
-gestaltPCXAttr 				EQU 	'pcxg'			; PC Exchange attributes
-gestaltPCXHas8and16BitFAT	EQU		0				; PC Exchange supports both 8 and 16 bit FATs
-gestaltPCXHasProDOS 		EQU		1				; PC Exchange supports ProDOS
-
 gestaltLogicalPageSize		EQU		'pgsz'    		; logical page size
 
 gestaltPowerMgrAttr			EQU   	'powr'        	; power manager attributes
@@ -426,12 +332,8 @@ gestaltHasColor				EQU		0				; color quickdraw present							<37>
 gestaltHasDeepGWorlds		EQU		1				; GWorlds can be deeper than 1-bit					<37>
 gestaltHasDirectPixMaps		EQU		2				; PixMaps can be direct (16 or 32 bit)				<37>
 gestaltHasGrayishTextOr		EQU		3				; supports text mode grayishTextOr					<37>
-gestaltSupportsMirroring	Equ		4				; Supports video mirroring via the Display Manager.
 
 gestaltPhysicalRAMSize		EQU		'ram '    		; physical RAM size
-gestaltRBVAddr				EQU		'rbv '			; RBV base address									<SM4>
-gestaltSCCReadAddr			EQU		'sccr'			; SCC read base address								<SM4>
-gestaltSCCWriteAddr			EQU		'sccw'			; SCC write base address							<SM4>
 
 gestaltPopupAttr			EQU		'pop!'			; popup cdef attributes
 gestaltPopupPresent			EQU		0
@@ -439,26 +341,11 @@ gestaltPopupPresent			EQU		0
 gestaltResourceMgrAttr		EQU		'rsrc'    		; Resource Mgr attributes
 gestaltPartialRsrcs			EQU   	0     			; True if partial resources exist
 
-gestaltRealtimeMgrAttr		EQU		'rtmr'			; Realtime manager attributes						<SM9> WS
-gestaltRealtimeMgrPresent	EQU		0				; true if Realtime manager is present				<SM9> WS  
-
-gestaltScrapMgrAttr				EQU		'scra'		; Scrap manager attributes
-gestaltScrapMgrTranslationAware	EQU		0			; True if scrap manager is translation manager aware
-
 gestaltScriptMgrVersion		EQU		'scri'    		; Script Manager version number 					<08/05/89 pke>
 gestaltScriptCount			EQU		'scr#'    		; number of active script systems					<08/05/89 pke>
 
-gestaltSlotAttr				EQU		'slot'			; slot manager attributes							<SM4>
-gestaltSlotMgrExists		EQU		0				; true if slot mgr exists							<SM4>
-gestaltNuBusPresent			EQU		1				; NuBus slots are present							<SM4>
-gestaltSESlotPresent		EQU		2				; SE PDS slot present								<SM4>
-gestaltSE30SlotPresent		EQU		3				; SE/30 slot present								<SM4>
-gestaltPortableSlotPresent	EQU		4				; Portable's slot present							<SM4>
-
 gestaltNuBusConnectors		EQU		'sltc'			; bitmap of slots with NuBus connectors				<26>
 
-gestaltFirstSlotNumber		EQU		'slt1'			; returns first physical slot						<SM4>
-
 gestaltSoundAttr			EQU		'snd '        	; sound attributes
 gestaltStereoCapability		EQU		0         		; sound hardware has stereo capability
 gestaltStereoMixing			EQU   	1         		; stereo mixing on external speaker
@@ -466,28 +353,15 @@ gestaltSoundIOMgrPresent	EQU		3				; The Sound I/O Manager is present
 gestaltBuiltInSoundInput	EQU		4				; built-in Sound Input hardware is present
 gestaltHasSoundInputDevice 	EQU		5				; Sound Input device available
 gestaltPlayAndRecord		EQU		6				; built-in hardware can play and record simultaneously
-gestalt16BitSoundIO			EQU		7				; sound hardware can play and record 16-bit samples
-gestaltStereoInput			EQU		8				; sound hardware can record stereo
-gestaltLineLevelInput		EQU		9				; sound input port requires line level
-													; the following bits are not defined prior to Sound Mgr 3.0
-gestaltSndPlayDoubleBuffer	EQU		10				; SndPlayDoubleBuffer available, set by Sound Mgr 3.0 and later
-gestaltMultiChannels		EQU		11				; multiple channel support, set by Sound Mgr 3.0 and later
-gestalt16BitAudioSupport	EQU		12				; 16 bit audio data supported, set by Sound Mgr 3.0 and later
 
 gestaltSpeechAttr 			EQU		'ttsc'			; Speech Manager attributes
 gestaltSpeechMgrPresent		EQU		0				; bit set indicates that Speech Manager exists
 
-gestaltSysArchitecture		EQU		'sysa'			; System architecture								<SM12>
-gestalt68k					EQU		1				; Motorola MC68k architecture
-gestaltPowerPC				EQU		2				; IBM PowerPC architecture
-
 gestaltStdNBPAttr			EQU		'nlup'			; standard nbp attributes
 gestaltStdNBPPresent		EQU		0
 
 gestaltStandardFileAttr				EQU		'stdf'  ; Standard File attributes
 gestaltStandardFile58				EQU   	0     	; True if selectors 5-8 (StandardPutFile-CustomGetFile) are supported
-gestaltStandardFileTranslationAware	EQU		1		; True if standard file is translation manager aware
-gestaltStandardFileHasColorIcons	EQU		2		; True if standard file has 16x16 color icons
 
 gestaltTextEditVersion		EQU		'te  '    		; TextEdit version number
 gestaltTE1					EQU 	1     			; TextEdit in MacIIci ROM
@@ -505,28 +379,16 @@ gestaltStandardTimeMgr		EQU		1         		; standard time mgr is present
 gestaltRevisedTimeMgr		EQU 	2         		; revised time mgr is present
 gestaltExtendedTimeMgr		EQU		3         		; extended time mgr is present
 
-gestaltVIA1Addr				EQU		'via1'			; VIA 1 base address								<SM4>
-gestaltVIA2Addr				EQU		'via2'			; VIA 2 base address								<SM4>
-
 gestaltVMAttr				EQU 	'vm  '    		; virtual memory attributes
 gestaltVMPresent			EQU 	0     			; virtual memory is present
 
-gestaltTranslationAttr		EQU		'xlat'			; Translation manager attributes
-gestaltTranslationMgrExists	EQU		0				; TRUE if translation manager exists
-
-gestaltIconUtilitiesAttr	EQU		'icon'			; Icon Utilities attributes
+gestaltIconUtilities		EQU		'icon'			; Icon Utilities attributes
 gestaltIconUtilitiesPresent	EQU		0				; true if icon utilities are present
 
 gestaltCompressionMgr		EQU		'icmp'			; returns version of the Image Compression Manager
 gestaltQuickTime			EQU		'qtim'			; returns version of QuickTime
-gestaltQuickTimeFeatures	EQU		'qtrs'			; return QuickTime features
 gestaltPPCQuickTimeLibPresent EQU	0
 
-gestaltSCSI 				EQU		'scsi'			; SCSI Manager attributes
-gestaltAsyncSCSI			EQU		0				; Supports Asynchronous SCSI 
-gestaltAsyncSCSIInROM		EQU		1				; Async scsi is in ROM (available for booting) 
-gestaltSCSISlotBoot			EQU		2				; This ROM supports Slot-style SCSI boots 
-
 
 **************************
 * Info-only Selectors
@@ -554,55 +416,14 @@ gestaltClassicII			EQU		23				; <49>
 gestaltPowerBook100			EQU		24				; <49>
 gestaltPowerBook140			EQU		25				; <49>
 gestaltQuadra950			EQU		26				; <53>
-gestaltMacLCIII				EQU		27				; <SM21>
-gestaltPowerBookDuo210		EQU		29				; <H4>
-gestaltCentris650			EQU		30				; <SM21>
-gestaltPowerBookDuo230		EQU		32				; <H4>
-gestaltPowerBook180			EQU		33				; <H4>
-gestaltPowerBook160			EQU		34				; <H4>
-gestaltQuadra800			EQU		35				; <SM21>
 gestaltMacLCII				EQU		37				; <52>
-gestaltPowerBookDuo250		EQU		38				; 
-gestaltMacIIvx				EQU		45				; <SM21>
-gestaltColorClassic			EQU		49				; <SM21>
-gestaltPowerbook180c		EQU		50				; <SM21>
-gestaltCentris610			EQU		52				; <SM21>
 gestaltPowerBook145			EQU		54				; <55>
-gestaltLC520				EQU		56				; <SM21>
-gestaltCentris660AV			EQU		60				; <SM21>
-gestaltQuadra660AV			EQU		gestaltCentris660AV; thank you, Ian Diery
-gestaltPowerBookDuo270C		EQU		77				; 
-gestaltQuadra840AV			EQU		78				; <SM21>
 
 gestaltMachineIcon			EQU		'micn'        	; machine icon
 
 gestaltROMSize				EQU 	'rom '        	; ROM size
 gestaltROMVersion			EQU 	'romv'        	; ROM version
 gestaltSystemVersion		EQU  	'sysv'    		; system version
-
-gestaltInternalDisplay		EQU		'idsp'			; slot number of internal display location
-
-	IF &TYPE('_NewGestaltValue') = 'UNDEFINED' THEN
-
-		MACRO
-		_NewGestaltValue
-			move.w		#$0401,d0
-			dc.w		$ABF1
-		ENDM
-
-		MACRO
-		_ReplaceGestaltValue
-			move.w		#$0402,d0
-			dc.w		$ABF1
-		ENDM
-
-		MACRO
-		_DeleteGestaltValue
-			move.w		#$0203,d0
-			dc.w		$ABF1
-		ENDM
-
-	ENDIF	; _NewGestaltValue
 	
 	
 	
diff --git a/Interfaces/AIncludes/HardwareEqu.a b/Interfaces/AIncludes/HardwareEqu.a
--- a/Interfaces/AIncludes/HardwareEqu.a
+++ b/Interfaces/AIncludes/HardwareEqu.a
@@ -564,7 +564,7 @@ machine   		EQU 		0
 rom85Bits 		EQU 		$7F   					; New ROMs, No Power Off.
 
 ; === Interrupt Masks ===
-hiIntMask 		EQU 		$0300					; programmer switch only
+hiIntMask 		EQU 		$0700					; programmer switch only
 sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
 sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
 viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
@@ -669,7 +669,7 @@ machine   		EQU 		2
 rom85Bits 		EQU 		$7F   					; New ROMs, No Power Off.
 
 ; === Interrupt Masks ===
-hiIntMask 		EQU 		$0300					; programmer switch only
+hiIntMask 		EQU 		$0700					; programmer switch only
 sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
 sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
 viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
@@ -773,7 +773,7 @@ machine   		EQU 		3
 rom85Bits 		EQU 		$7F   					; New ROMs, No Power Off.
 
 ; === Interrupt Masks ===
-hiIntMask 		EQU 		$0300					; programmer switch only
+hiIntMask 		EQU 		$0700					; programmer switch only
 sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
 sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
 viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
diff --git a/Interfaces/AIncludes/SonyEqu.a b/Interfaces/AIncludes/SonyEqu.a
--- a/Interfaces/AIncludes/SonyEqu.a
+++ b/Interfaces/AIncludes/SonyEqu.a
@@ -80,10 +80,22 @@ onMacPP   		EQU 		0
 onNuMac   		EQU 		0
   				ENDIF
 
+          IF      (&TYPE('onHafMac') = 'UNDEFINED') THEN
+onHafMac      EQU     0
+          ENDIF
+
   				IF  		(&TYPE('onHcMac') = 'UNDEFINED') THEN
 onHcMac   		EQU 		0
   				ENDIF
 
+          IF      (&TYPE('onMac16') = 'UNDEFINED') THEN
+onMac16       EQU     0
+          ENDIF
+
+          IF      (&TYPE('onMac32') = 'UNDEFINED') THEN
+onMac32       EQU     0
+          ENDIF
+
 ; forDiskDup should be set to 0 for most uses
 
   				IF  		(&TYPE('forDiskDup') = 'UNDEFINED') THEN
@@ -140,6 +152,11 @@ maxDCDcnt 		EQU 		2
 iwmMode   		EQU 		$17
   				ENDIF
 
+          IF      (&TYPE('maxDrvNum') = 'UNDEFINED') THEN
+maxDrvNum     EQU     4
+          ENDIF
+
+
 
   				IF  		SonyNonPortable THEN
 
@@ -273,6 +290,8 @@ drive3			EQU 		drive2+drvLclLth  		; * real external for MacPP
 floppyLclEnd  	EQU 		drive3+drvLclLth
   				ELSEIF		onMac | onNuMac | onMac32 THEN
 floppyLclEnd  	EQU 		drive2+drvLclLth
+          ELSE
+floppyLclEnd EQU $99
   				ENDIF
 
 track 			EQU 		0         				; current track location (used for spd)
@@ -362,7 +381,7 @@ chipState 		EQU 		sonyVarEnd    			; Byte holds flag to indicate IWM on or off
 sonyVarEnd		SET 		chipState+2       		; end of sony vars excluding DCD
   				ENDIF
 
-  				IF  		hasPwrControls | hasPowerMgr THEN		; <1.1>
+  				IF  		(hasPwrControls | hasPowerMgr) and NOT onHcMac and NOT onMac THEN		; <1.1>
 chipState 		EQU 		sonyVarEnd    			; Bit7 - saved VIA dir, 6..0 - pmgr enables <1.1>
 diskSleepQEL	EQU			chipState+2				; sleep/wakeup queue element
 sonyVarEnd		SET 		diskSleepQEL+SleepqRec.SleepqSize	; end of sony vars excluding DCD
@@ -371,9 +390,7 @@ sonyVarEnd		SET 		diskSleepQEL+SleepqRec.SleepqSize	; end of sony vars excluding
 				IF			forDiskDup THEN
 fmtParams		EQU			sonyVarEnd				;pointer to parameters for special format command
 gcrFmtByte		EQU			fmtParams+4				; saved GCR format byte for duplicator
-clock32Mhz		EQU			gcrFmtByte+2			; ( 1) Clock speed: $FF=32Mhz, $00=16Mhz				<H3><SM4>
-DisableRetries	EQU			clock32Mhz+1			; ( 1) $FF=Don't perform retries, $00=normal			<H4><SM4>
-sonyVarEnd		SET			DisableRetries+1
+sonyVarEnd		SET			gcrFmtByte+1
 				ENDIF
 
 
@@ -460,15 +477,12 @@ dqDIP 			EQU 		-3        				; $FC-$FF = disk just ejected,
 ; 2 = disk has been read
 ; >8 = non-ejectable disk
 dqWrPrt   		EQU 		-4        				; Bit 7 of this byte: 1=disk is write protected.
-
-dqManEjBit		EQU			5						; bit 5 of the dqInstall byte is set after  <SM5> <BH 03Aug93>
 													; installation for a manual-eject drive
 ;_______________________________________;
 ;
 ; (1) Floppy drive constants (tuneable).
 
 kSeekTime 		EQU 		120       				; 12 ms trk-to-trk
-kHdSetTime		EQU			100*10					; 100 ms head settle time								<H6><SM4>
 kEjectTime		EQU 		7500      				; .75 seconds eject time
 kEjectWait		EQU 		-4        				; - number of VBL calls after eject before dip check
 kSectTime 		EQU 		100       				; minimum sector time in 100 us increments (10 ms)
@@ -599,7 +613,6 @@ iconIDCC  		EQU 		20        				; 'get icon id' control code
 iconCC			EQU 		21        				; 'get icon' control code
 iconLogCC 		EQU 		22        				; 'get logical icon' code
 infoCC			EQU 		23        				; 'get drive info' code
-RetriesCC		EQU			17232					; 'Enable/Disable Retries' code			<H4><SM4>
   				IF  		forDiskDup THEN
 FmtCopyCC 		EQU 		$5343     				;one-pass format/copy/verify for disk duplicator
   				ENDIF
@@ -611,7 +624,6 @@ fmtLstCode		EQU 		6         				;Returns a list of disk formats
   				IF  		supportsMFM THEN
 mfmStsCode		EQU 		10        				;'Get MFM status' status code
   				ENDIF
-SpdChkSts		EQU		17232						; Checks disk speed at a given track	<H5><SM4>
   				IF  		forDiskDup THEN
 DupVerSts 		EQU 		$4456     				;disk duplicator version supported (to match features)
 FmtByteSts		EQU 		$5343     				;return address header format byte
diff --git a/Interfaces/AIncludes/SysEqu.a b/Interfaces/AIncludes/SysEqu.a
--- a/Interfaces/AIncludes/SysEqu.a
+++ b/Interfaces/AIncludes/SysEqu.a
@@ -6,13 +6,8 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	  9/9/93	pdw		Added SetOSPassword.
-;	   <SM4>	 4/20/93	CSS		Update from Reality:
-;									<34>	 3/30/93	JDR		Added ioMisc.
-;	   <SM3>	 11/10/92	CSS		Rollins from Reality:
-;									<33>	10/28/92	JDR		Added Time Manager task record.
-;	   <SM2>	 5/17/92	kc		Add selectors for the _MemoryDispatch trap.
-;                                   Add CacheFlags and bCopybackMode Equates.
+;		<34>	 3/30/93	JDR		Added ioMisc.
+;		<33>	10/28/92	JDR		Added Time Manager task record.
 ;		<32>	12/31/91	RB		Added new exception vectors from Terror.
 ;		<31>	10/28/91	SAM/KSM	Rolled in Regatta file.
 ;		
@@ -293,7 +288,6 @@ TheGDevice		EQU 		$0CC8 					; (long) the current graphics device
 CQDGlobals		EQU 		$0CCC 					; (long) quickDraw global extensions
 
 DeskCPat  		EQU 		$0CD8 					; [PixPatHandle] Handle to desk pixPat
-SetOSPassword	EQU			$0CDC					; (long) used as password by SetOSDefault (StartMgr)
 
 TimeVIADB 		EQU 		$0CEA 					; (word) number of iter's of VIA access & DBRA.	<1.3>
 VIA2	   		EQU 		$0CEC 					; VIA2 base address [pointer]					<2.7>
@@ -1045,11 +1039,6 @@ RAMBase   		EQU 		$2B2  					; RAM base address [pointer]
 SysVersion		EQU 		$15A  					; version # of RAM-based system [word]
 RndSeed   		EQU 		$156  					; random seed/number [long]
 
-; Cache-related stuff
-
-CacheFlags		EQU			$B72					; cache flags [byte]							<T9>
-bCopybackMode	EQU			7						; bit indicating cache mode on 68040			<T9>
-
 ; fields for _GetDefaultStartup: [DefStartRec]
 ; SlotDev:
 sdExtDevID		EQU 		$0    					; [byte]
@@ -1603,16 +1592,6 @@ size				EQU			*			; minimum size of table
 defaultSize			EQU			size + (MemoryBlock.size * defaultPhysicalEntryCount)
 					ENDR
 
-; selectors for the _MemoryDispatch trap
-holdMemory			EQU			0			; selector for _HoldMemory
-unholdMemory		EQU			1			; selector for _UnholdMemory
-lockMemory			EQU			2			; selector for _LockMemory
-lockMemoryContiguous EQU		4			; selector for _LockMemoryContiguous
-unlockMemory		EQU			3			; selector for _UnlockMemory
-getPhysical			EQU			5			; selector for _GetPhysical
-getReal				EQU			6			; selector for _GetReal call
-getPageDesc			EQU			7			; selector for _GetPageDesc call
-
 ;___________________________________________________________________________
 ;
 
diff --git a/Interfaces/AIncludes/Traps.a b/Interfaces/AIncludes/Traps.a
--- a/Interfaces/AIncludes/Traps.a
+++ b/Interfaces/AIncludes/Traps.a
@@ -9,9 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM18>	 9/13/93	SAM		Removed the 24bit conds around the removate of SwapMMUMode,
-;									StripAddress, and Translate24to32.  I also removed all the
-;									redefinitions of Translate24to32 throughout the sources.
 ;	  <SMG2>	  9/1/93	chp		Took out _DMAIntInstall again. No one needs it now.
 ;	  <SM16>	 7/21/93	RC		back out <sm 15>
 ;	  <SM14>	 6/14/93	kc		Roll in Ludwig. (leave behind _DMAIntInstall for SAM)
@@ -2110,18 +2107,10 @@ _HGetState		OPWORD  	$A069
 _HSetState		OPWORD  	$A06A
 _InitFS   		OPWORD  	$A06C
 _InitEvents   	OPWORD  	$A06D
-
-	Macro							; SuperMario is a 32-bit only ROM
-	_SwapMMUMode
-	EndM
-	Macro							; SuperMario is a 32-bit only ROM
-	_StripAddress
-	EndM
-	Macro							; SuperMario is a 32-bit only ROM
-	_Translate24To32
-	EndM
-
+_StripAddress 	OPWORD  	$A055
+_Translate24To32 OPWORD  	$A091
 _SetAppBase   	OPWORD  	$A057
+_SwapMMUMode  	OPWORD  	$A05D
 _SlotVInstall 	OPWORD  	$A06F
 _SlotVRemove  	OPWORD  	$A070
 _AttachVBL		OPWORD  	$A071
diff --git a/Interfaces/CIncludes/Desk.h b/Interfaces/CIncludes/Desk.h
--- a/Interfaces/CIncludes/Desk.h
+++ b/Interfaces/CIncludes/Desk.h
@@ -45,7 +45,7 @@ Created: Saturday, July 27, 1991 at 2:53 PM
 enum {
 
  accEvent = 64,
- accRun = 65,
+// accRun = 65,
  accCursor = 66,
  accMenu = 67,
  accUndo = 68,
diff --git a/Interfaces/CIncludes/GestaltEqu.h b/Interfaces/CIncludes/GestaltEqu.h
--- a/Interfaces/CIncludes/GestaltEqu.h
+++ b/Interfaces/CIncludes/GestaltEqu.h
@@ -33,9 +33,6 @@ Created: Sunday, January 6, 1991 at 9:27 PM
 	  <SM13>	 2/11/93	SAM		Added Emulated MMU type.
 	  <SM12>	12/13/92	SAM		Added gestaltNativeCPUtype and gestaltSysArchitecture.
 									Straightened out this file a bit.
-	   <SM11>	 11/10/92	CSS		Update from Reality:
-	   								<60> 10/28/92 JDR	Added inline versions of ReplaceGestalt and NewGestalt for the
-														SystemSevenOrLater includes.
 	   <SM10>	 8/28/92	CSS		Update from Reality:
 	   								<59> 8/28/92 DCL	Fixed enums with commas before the closing brace. MPW now
 														complains.
@@ -646,28 +643,13 @@ typedef pascal OSErr (*SelectorFunctionProcPtr)(OSType selector, long *response)
 #ifdef __cplusplus
 extern "C" {
 #endif
-#if SystemSevenOrLater
 
 #pragma parameter __D0 Gestalt(__D0,__A1)
 pascal OSErr Gestalt(OSType selector,long *response)
     = {0xA1AD,0x2288};
-
-#pragma parameter __D0 NewGestalt(__D0,__A0)
-pascal OSErr NewGestalt(OSType selector,SelectorFunctionProcPtr gestaltFunction)
-    = {0xA3AD};
-
-#pragma parameter __D0 ReplaceGestalt(__D0,__A0,__A1)
-pascal OSErr ReplaceGestalt(OSType selector,SelectorFunctionProcPtr gestaltFunction,SelectorFunctionProcPtr *oldGestaltFunction)
-	= {0x2F09, 0xA5AD, 0x225F, 0x2288};
-
-#else
-
-pascal OSErr Gestalt(OSType selector,long *response);
 pascal OSErr NewGestalt(OSType selector,SelectorFunctionProcPtr gestaltFunction);
 pascal OSErr ReplaceGestalt(OSType selector,SelectorFunctionProcPtr gestaltFunction,SelectorFunctionProcPtr *oldGestaltFunction);
 
-#endif
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/Interfaces/CIncludes/Sound.h b/Interfaces/CIncludes/Sound.h
new file mode 100644
--- /dev/null
+++ b/Interfaces/CIncludes/Sound.h
@@ -0,0 +1,510 @@
+/************************************************************
+
+Created: Monday, January 28, 1991 at 6:54 PM
+    Sound.h
+    C Interface to the Macintosh Libraries
+
+
+        Copyright Apple Computer, Inc.    1986-1990
+        All rights reserved
+
+************************************************************/
+
+
+#ifndef __SOUND__
+#define __SOUND__
+
+#ifndef __TYPES__
+#include <Types.h>
+#endif
+
+#ifndef __FILES__
+#include <Files.h>
+#endif
+
+
+enum {
+
+    swMode = -1,                            /* Sound Driver modes */
+    ftMode = 1,
+    ffMode = 0,
+
+
+#define synthCodeRsrc 'snth'                /* Resource types used by Sound Manager */
+#define soundListRsrc 'snd '
+
+#define twelfthRootTwo 1.05946309434
+
+    rate22khz = 0x56EE8BA3,                 /* 22254.54545 in fixed-point */
+    rate11khz = 0x2B7745D1,                 /* 11127.27273 in fixed-point */
+
+/* synthesizer numbers for SndNewChannel */
+    squareWaveSynth = 1,                    /*square wave synthesizer*/
+    waveTableSynth = 3,                     /*wave table synthesizer*/
+    sampledSynth = 5,                       /*sampled sound synthesizer*/
+
+/* old Sound Manager MACE synthesizer numbers */
+    MACE3snthID = 11,
+    MACE6snthID = 13,
+
+/* command numbers for SndDoCommand and SndDoImmediate */
+    nullCmd = 0,
+    initCmd = 1,
+    freeCmd = 2,
+    quietCmd = 3,
+    flushCmd = 4,
+    reInitCmd = 5,
+
+    waitCmd = 10,
+    pauseCmd = 11,
+    resumeCmd = 12,
+    callBackCmd = 13
+};
+enum {
+    syncCmd = 14,
+    emptyCmd = 15,
+
+    tickleCmd = 20,
+    requestNextCmd = 21,
+    howOftenCmd = 22,
+    wakeUpCmd = 23,
+    availableCmd = 24,
+    versionCmd = 25,
+    totalLoadCmd = 26,
+    loadCmd = 27,
+
+    scaleCmd = 30,
+    tempoCmd = 31,
+
+    freqDurationCmd = 40,
+    restCmd = 41,
+    freqCmd = 42,
+    ampCmd = 43,
+    timbreCmd = 44,
+    getAmpCmd = 45,
+
+    waveTableCmd = 60,
+    phaseCmd = 61
+};
+enum {
+
+    soundCmd = 80,
+    bufferCmd = 81,
+    rateCmd = 82,
+    continueCmd = 83,
+    doubleBufferCmd = 84,
+    getRateCmd = 85,
+
+    sizeCmd = 90,
+    convertCmd = 91,
+
+    stdQLength = 128,
+    dataOffsetFlag = 0x8000,
+
+    waveInitChannelMask = 0x07,
+    waveInitChannel0 = 0x04,
+    waveInitChannel1 = 0x05,
+    waveInitChannel2 = 0x06,
+    waveInitChannel3 = 0x07,
+
+/* channel initialization parameters */
+    initPanMask = 0x0003,                   /* mask for right/left pan values */
+    initSRateMask = 0x0030,                 /* mask for sample rate values */
+    initStereoMask = 0x00C0,                /* mask for mono/stereo values */
+    initCompMask = 0xFF00,                  /* mask for compression IDs */
+
+    initChanLeft = 0x0002                   /* left stereo channel */
+};
+enum {
+    initChanRight = 0x0003,                 /* right stereo channel */
+    initNoInterp = 0x0004,                  /* no linear interpolation */
+    initNoDrop = 0x0008,                    /* no drop-sample conversion */
+    initMono = 0x0080,                      /* monophonic channel */
+    initStereo = 0x00C0,                    /* stereo channel */
+    initMACE3 = 0x0300,                     /* MACE 3:1 */
+    initMACE6 = 0x0400,                     /* MACE 6:1 */
+
+    initChan0 = 0x0004,                     /* channel 0 - wave table only */
+    initChan1 = 0x0005,                     /* channel 1 - wave table only */
+    initChan2 = 0x0006,                     /* channel 2 - wave table only */
+    initChan3 = 0x0007,                     /* channel 3 - wave table only */
+
+    stdSH = 0x00,                           /* Standard sound header encode value */
+    extSH = 0xFF,                           /* Extended sound header encode value */
+    cmpSH = 0xFE,                           /* Compressed sound header encode value */
+
+    notCompressed = 0,                      /* compression ID's */
+    twoToOne = 1,
+    eightToThree = 2,
+    threeToOne = 3,
+    sixToOne = 4,
+
+    outsideCmpSH = 0                        /* MACE constants */
+};
+enum {
+    insideCmpSH = 1,
+    aceSuccess = 0,
+    aceMemFull = 1,
+    aceNilBlock = 2,
+    aceBadComp = 3,
+    aceBadEncode = 4,
+    aceBadDest = 5,
+    aceBadCmd = 6,
+    sixToOnePacketSize = 8,
+    threeToOnePacketSize = 16,
+    stateBlockSize = 64,
+    leftOverBlockSize = 32,
+
+    firstSoundFormat = 0x0001,              /* general sound format */
+    secondSoundFormat = 0x0002,             /* special sampled sound format (HyperCard) */
+
+    dbBufferReady = 0x00000001,             /* double buffer is filled */
+    dbLastBuffer = 0x00000004,              /* last double buffer to play */
+
+    sysBeepDisable = 0x0000,                /* SysBeep() enable flags */
+    sysBeepEnable = 0x0001,
+
+    unitTypeNoSelection = 0xFFFF,           /* unitTypes for AudioSelection.unitType */
+    unitTypeSeconds = 0x0000
+};
+
+
+/*            Structures for Sound Driver            */
+
+
+typedef unsigned char FreeWave[30001]; 
+
+struct FFSynthRec {
+    short mode;
+    Fixed count;
+    FreeWave waveBytes;
+};
+
+typedef struct FFSynthRec FFSynthRec;
+typedef FFSynthRec *FFSynthPtr;
+
+struct Tone {
+    short count;
+    short amplitude;
+    short duration;
+};
+
+typedef struct Tone Tone;
+
+
+typedef Tone Tones[5001];
+
+struct SWSynthRec {
+    short mode;
+    Tones triplets;
+};
+
+typedef struct SWSynthRec SWSynthRec;
+typedef SWSynthRec *SWSynthPtr;
+
+
+typedef unsigned char Wave[256]; 
+typedef Wave *WavePtr;
+
+struct FTSoundRec {
+    short duration;
+    Fixed sound1Rate;
+    long sound1Phase;
+    Fixed sound2Rate;
+    long sound2Phase;
+    Fixed sound3Rate;
+    long sound3Phase;
+    Fixed sound4Rate;
+    long sound4Phase;
+    WavePtr sound1Wave;
+    WavePtr sound2Wave;
+    WavePtr sound3Wave;
+    WavePtr sound4Wave;
+};
+
+typedef struct FTSoundRec FTSoundRec;
+typedef FTSoundRec *FTSndRecPtr;
+
+struct FTSynthRec {
+    short mode;
+    FTSndRecPtr sndRec;
+};
+
+typedef struct FTSynthRec FTSynthRec;
+typedef FTSynthRec *FTSynthPtr;
+
+
+typedef pascal void (*SndCompletionProcPtr)(void);
+
+/*            Structures for Sound Manager            */
+
+struct SndCommand {
+    unsigned short cmd;
+    short param1;
+    long param2;
+};
+
+typedef struct SndCommand SndCommand;
+
+
+typedef long Time;                          /* in half milliseconds */
+
+
+
+typedef struct SndChannel SndChannel;
+typedef SndChannel *SndChannelPtr;
+
+
+typedef pascal void (*SndCallBackProcPtr)(SndChannelPtr chan, SndCommand cmd);
+
+struct SndChannel {
+    struct SndChannel *nextChan;
+    Ptr firstMod;                           /* reserved for the Sound Manager */
+    SndCallBackProcPtr callBack;
+    long userInfo;
+    Time wait;                              /* The following is for internal Sound Manager use only.*/
+    SndCommand cmdInProgress;
+    short flags;
+    short qLength;
+    short qHead;                            /* next spot to read or -1 if empty */
+    short qTail;                            /* next spot to write = qHead if full */
+    SndCommand queue[stdQLength];
+};
+
+/* MACE structures */
+struct StateBlock {
+    short stateVar[stateBlockSize];
+};
+
+typedef struct StateBlock StateBlock;
+typedef StateBlock *StateBlockPtr;
+
+struct LeftOverBlock {
+    unsigned long count;
+    char sampleArea[leftOverBlockSize];
+};
+
+typedef struct LeftOverBlock LeftOverBlock;
+typedef LeftOverBlock *LeftOverBlockPtr;
+
+struct ModRef {
+    unsigned short modNumber;
+    long modInit;
+};
+
+typedef struct ModRef ModRef;
+
+struct SndListResource {
+    short format;
+    short numModifiers;
+    ModRef modifierPart[1];                 /*This is a variable length array*/
+    short numCommands;
+    SndCommand commandPart[1];              /*This is a variable length array*/
+    char dataPart[1];                       /*This is a variable length array*/
+};
+
+typedef struct SndListResource SndListResource;
+typedef SndListResource *SndListPtr;
+
+struct SoundHeader {
+    Ptr samplePtr;                          /* if NIL then samples are in sampleArea */
+    unsigned long length;                   /* length of sound in bytes */
+    Fixed sampleRate;                       /* sample rate for this sound */
+    unsigned long loopStart;                /* start of looping portion */
+    unsigned long loopEnd;                  /* end of looping portion */
+    unsigned char encode;                   /* header encoding */
+    unsigned char baseFrequency;            /* baseFrequency value */
+    char sampleArea[1];
+};
+
+typedef struct SoundHeader SoundHeader;
+typedef SoundHeader *SoundHeaderPtr;
+
+
+struct CmpSoundHeader {
+    Ptr samplePtr;                          /* if nil then samples are in sample area */
+    unsigned long numChannels;              /* number of channels i.e. mono = 1 */
+    Fixed sampleRate;                       /* sample rate in Apples Fixed point representation */
+    unsigned long loopStart;                /* loopStart of sound before compression */
+    unsigned long loopEnd;                  /* loopEnd of sound before compression */
+    unsigned char encode;                   /* data structure used , stdSH, extSH, or cmpSH */
+    unsigned char baseFrequency;            /* same meaning as regular SoundHeader */
+    unsigned long numFrames;                /* length in frames ( packetFrames or sampleFrames ) */
+    extended AIFFSampleRate;                /* IEEE sample rate */
+    Ptr markerChunk;                        /* sync track */
+    Ptr futureUse1;                         /* reserved by Apple */
+    Ptr futureUse2;                         /* reserved by Apple */
+    StateBlockPtr stateVars;                /* pointer to State Block */
+    LeftOverBlockPtr leftOverSamples;       /* used to save truncated samples between compression calls */
+    unsigned short compressionID;           /* 0 means no compression, non zero means compressionID */
+    unsigned short packetSize;              /* number of bits in compressed sample packet */
+    unsigned short snthID;                  /* resource ID of Sound Manager snth that contains NRT C/E */
+    unsigned short sampleSize;              /* number of bits in non-compressed sample */
+    char sampleArea[1];                     /* space for when samples follow directly */
+};
+
+typedef struct CmpSoundHeader CmpSoundHeader;
+typedef CmpSoundHeader *CmpSoundHeaderPtr;
+
+struct ExtSoundHeader {
+    Ptr samplePtr;                          /* if nil then samples are in sample area */
+    unsigned long numChannels;              /* number of channels,  ie mono = 1 */
+    Fixed sampleRate;                       /* sample rate in Apples Fixed point representation */
+    unsigned long loopStart;                /* same meaning as regular SoundHeader */
+    unsigned long loopEnd;                  /* same meaning as regular SoundHeader */
+    unsigned char encode;                   /* data structure used , stdSH, extSH, or cmpSH */
+    unsigned char baseFrequency;            /* same meaning as regular SoundHeader */
+    unsigned long numFrames;                /* length in total number of frames */
+    extended AIFFSampleRate;                /* IEEE sample rate */
+    Ptr markerChunk;                        /* sync track */
+    Ptr instrumentChunks;                   /* AIFF instrument chunks */
+    Ptr AESRecording;
+    unsigned short sampleSize;              /* number of bits in sample */
+    unsigned short futureUse1;              /* reserved by Apple */
+    unsigned long futureUse2;               /* reserved by Apple */
+    unsigned long futureUse3;               /* reserved by Apple */
+    unsigned long futureUse4;               /* reserved by Apple */
+    char sampleArea[1];                     /* space for when samples follow directly */
+};
+
+typedef struct ExtSoundHeader ExtSoundHeader;
+typedef ExtSoundHeader *ExtSoundHeaderPtr;
+
+struct ConversionBlock {
+    short destination;
+    short unused;
+    CmpSoundHeaderPtr inputPtr;
+    CmpSoundHeaderPtr outputPtr;
+};
+
+typedef struct ConversionBlock ConversionBlock;
+typedef ConversionBlock *ConversionBlockPtr;
+
+struct SMStatus {
+    short smMaxCPULoad;
+    short smNumChannels;
+    short smCurCPULoad;
+};
+
+typedef struct SMStatus SMStatus;
+typedef SMStatus *SMStatusPtr;
+
+struct SCStatus {
+    Fixed scStartTime;
+    Fixed scEndTime;
+    Fixed scCurrentTime;
+    Boolean scChannelBusy;
+    Boolean scChannelDisposed;
+    Boolean scChannelPaused;
+    Boolean scUnused;
+    unsigned long scChannelAttributes;
+    long scCPULoad;
+};
+
+typedef struct SCStatus SCStatus;
+typedef SCStatus *SCStatusPtr;
+
+struct AudioSelection {
+    long unitType;
+    Fixed selStart;
+    Fixed selEnd;
+};
+
+typedef struct AudioSelection AudioSelection;
+typedef AudioSelection *AudioSelectionPtr;
+
+struct SndDoubleBuffer {
+    long dbNumFrames;
+    long dbFlags;
+    long dbUserInfo[2];
+    char dbSoundData[1];
+};
+
+typedef struct SndDoubleBuffer SndDoubleBuffer;
+typedef SndDoubleBuffer *SndDoubleBufferPtr;
+
+
+typedef pascal void (*SndDoubleBackProcPtr) (SndChannelPtr channel,
+                                            SndDoubleBufferPtr doubleBufferPtr);
+
+struct SndDoubleBufferHeader {
+    short dbhNumChannels;
+    short dbhSampleSize;
+    short dbhCompressionID;
+    short dbhPacketSize;
+    Fixed dbhSampleRate;
+    SndDoubleBufferPtr dbhBufferPtr[2];
+    SndDoubleBackProcPtr dbhDoubleBack;
+};
+
+typedef struct SndDoubleBufferHeader SndDoubleBufferHeader;
+typedef SndDoubleBufferHeader *SndDoubleBufferHeaderPtr;
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+pascal OSErr SndDoCommand(SndChannelPtr chan,const SndCommand *cmd,Boolean noWait)
+    = 0xA803; 
+pascal OSErr SndDoImmediate(SndChannelPtr chan,const SndCommand *cmd)
+    = 0xA804; 
+pascal OSErr SndNewChannel(SndChannelPtr *chan,short synth,long init,SndCallBackProcPtr userRoutine)
+    = 0xA807; 
+pascal OSErr SndDisposeChannel(SndChannelPtr chan,Boolean quietNow)
+    = 0xA801; 
+pascal OSErr SndPlay(SndChannelPtr chan,Handle sndHdl,Boolean async)
+    = 0xA805; 
+pascal OSErr SndAddModifier(SndChannelPtr chan,ProcPtr modifier,short id,
+    long init)
+    = 0xA802; 
+pascal OSErr SndControl(short id,SndCommand *cmd)
+    = 0xA806; 
+
+pascal void SetSoundVol(short level); 
+#pragma parameter GetSoundVol(__A0)
+pascal void GetSoundVol(short *level)
+    = {0x4218,0x10B8,0x0260}; 
+pascal void StartSound(const void *synthRec,long numBytes,SndCompletionProcPtr completionRtn); 
+pascal void StopSound(void); 
+pascal Boolean SoundDone(void); 
+
+pascal NumVersion SndSoundManagerVersion(void)
+    = {0x203C,0x000C,0x0008,0xA800}; 
+pascal OSErr SndStartFilePlay(SndChannelPtr chan,short fRefNum,short resNum,
+    long bufferSize,void *theBuffer,AudioSelectionPtr theSelection,ProcPtr theCompletion,
+    Boolean async)
+    = {0x203C,0x0D00,0x0008,0xA800}; 
+pascal OSErr SndPauseFilePlay(SndChannelPtr chan)
+    = {0x203C,0x0204,0x0008,0xA800}; 
+pascal OSErr SndStopFilePlay(SndChannelPtr chan,Boolean async)
+    = {0x203C,0x0308,0x0008,0xA800}; 
+pascal OSErr SndChannelStatus(SndChannelPtr chan,short theLength,SCStatusPtr theStatus)
+    = {0x203C,0x0010,0x0008,0xA800}; 
+pascal OSErr SndManagerStatus(short theLength,SMStatusPtr theStatus)
+    = {0x203C,0x0014,0x0008,0xA800}; 
+pascal void SndGetSysBeepState(short *sysBeepState)
+    = {0x203C,0x0018,0x0008,0xA800}; 
+pascal OSErr SndSetSysBeepState(short sysBeepState)
+    = {0x203C,0x001C,0x0008,0xA800}; 
+pascal OSErr SndPlayDoubleBuffer(SndChannelPtr chan,SndDoubleBufferHeaderPtr theParams)
+    = {0x203C,0x0020,0x0008,0xA800}; 
+
+pascal NumVersion MACEVersion(void)
+    = {0x203C,0x0000,0x0010,0xA800}; 
+pascal void Comp3to1(const void *inBuffer,void *outBuffer,unsigned long cnt,
+    const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+    = {0x203C,0x0004,0x0010,0xA800}; 
+pascal void Exp1to3(const void *inBuffer,void *outBuffer,unsigned long cnt,
+    const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+    = {0x203C,0x0008,0x0010,0xA800}; 
+pascal void Comp6to1(const void *inBuffer,void *outBuffer,unsigned long cnt,
+    const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+    = {0x203C,0x000C,0x0010,0xA800}; 
+pascal void Exp1to6(const void *inBuffer,void *outBuffer,unsigned long cnt,
+    const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+    = {0x203C,0x0010,0x0010,0xA800}; 
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/Interfaces/CIncludes/Sound.h.idump b/Interfaces/CIncludes/Sound.h.idump
new file mode 100644
--- /dev/null
+++ b/Interfaces/CIncludes/Sound.h.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Interfaces/CIncludes/Sound.h.rdump b/Interfaces/CIncludes/Sound.h.rdump
new file mode 100644
--- /dev/null
+++ b/Interfaces/CIncludes/Sound.h.rdump
@@ -0,0 +1,176 @@
+data 'MPSR' (1005) {
+	$"0009 4D6F 6E61 636F 0042 01E3 01CF 026E"            /* ..Monaco.B.....n */
+	$"01CF 027E 0000 0000 0000 0000 8200 0014"            /* ...~............ */
+	$"0001 0006 0004 002A 0003 0142 01E3 002A"            /* .......*...B...* */
+	$"0003 0142 01E3 A42B A620 0000 0000 0000"            /* ...B...+. ...... */
+	$"0000 0000 0000 0100"                                /* ........ */
+};
+
+data 'MPSR' (1007) {
+	$"0076 0000 01BE 0000 0202 0773 774D 6F64"            /* .v.........swMod */
+	$"6500 0000 0203 0000 0212 0766 744D 6F64"            /* e..........ftMod */
+	$"6500 0000 0213 0000 0222 0766 664D 6F64"            /* e........".ffMod */
+	$"6500 0000 0225 0000 027B 0D73 796E 7468"            /* e....%...{.synth */
+	$"436F 6465 5273 7263 0000 027C 0000 0298"            /* CodeRsrc...|.... */
+	$"0D73 6F75 6E64 4C69 7374 5273 7263 0000"            /* .soundListRsrc.. */
+	$"030D 0000 0359 0972 6174 6531 316B 687A"            /* .....Y.rate11khz */
+	$"0000 0387 0000 03CE 0F73 7175 6172 6557"            /* .........squareW */
+	$"6176 6553 796E 7468 0000 03CF 0000 0415"            /* aveSynth........ */
+	$"0F77 6176 6554 6162 6C65 5379 6E74 6800"            /* .waveTableSynth. */
+	$"0000 0416 0000 2BB9 0D73 616D 706C 6564"            /* ......+..sampled */
+	$"5379 6E74 6800 0000 0492 0000 2E8C 0B4D"            /* Synth..........M */
+	$"4143 4533 736E 7468 4944 0000 04A8 0000"            /* ACE3snthID...... */
+	$"04BD 0B4D 4143 4536 736E 7468 4944 0000"            /* ...MACE6snthID.. */
+	$"04F9 0000 0509 076E 756C 6C43 6D64 0000"            /* .......nullCmd.. */
+	$"050A 0000 051A 0769 6E69 7443 6D64 0000"            /* .......initCmd.. */
+	$"051B 0000 052B 0766 7265 6543 6D64 0000"            /* .....+.freeCmd.. */
+	$"052C 0000 053D 0971 7569 6574 436D 6400"            /* .,...=.quietCmd. */
+	$"0000 053E 0000 054F 0966 6C75 7368 436D"            /* ...>...O.flushCm */
+	$"6400 0000 0550 0000 0562 0972 6549 6E69"            /* d....P...b.reIni */
+	$"7443 6D64 0000 0564 0000 0575 0777 6169"            /* tCmd...d...u.wai */
+	$"7443 6D64 0000 0576 0000 0588 0970 6175"            /* tCmd...v.....pau */
+	$"7365 436D 6400 0000 0589 0000 059C 0972"            /* seCmd..........r */
+	$"6573 756D 6543 6D64 0000 059D 0000 05B1"            /* esumeCmd........ */
+	$"0B63 616C 6C42 6163 6B43 6D64 0000 05BC"            /* .callBackCmd.... */
+	$"0000 05CD 0773 796E 6343 6D64 0000 05CE"            /* .....syncCmd.... */
+	$"0000 05E0 0965 6D70 7479 436D 6400 0000"            /* .....emptyCmd... */
+	$"05E2 0000 05F5 0974 6963 6B6C 6543 6D64"            /* .......tickleCmd */
+	$"0000 05F6 0000 060E 0F72 6571 7565 7374"            /* .........request */
+	$"4E65 7874 436D 6400 0000 060F 0000 0624"            /* NextCmd........$ */
+	$"0B68 6F77 4F66 7465 6E43 6D64 0000 0625"            /* .howOftenCmd...% */
+	$"0000 0638 0977 616B 6555 7043 6D64 0000"            /* ...8.wakeUpCmd.. */
+	$"0639 0000 064F 0D61 7661 696C 6162 6C65"            /* .9...O.available */
+	$"436D 6400 0000 0650 0000 0664 0B76 6572"            /* Cmd....P...d.ver */
+	$"7369 6F6E 436D 6400 0000 0665 0000 067B"            /* sionCmd....e...{ */
+	$"0D74 6F74 616C 4C6F 6164 436D 6400 0000"            /* .totalLoadCmd... */
+	$"067C 0000 068D 076C 6F61 6443 6D64 0000"            /* .|.....loadCmd.. */
+	$"068F 0000 06A1 0973 6361 6C65 436D 6400"            /* .......scaleCmd. */
+	$"0000 06A2 0000 06B4 0974 656D 706F 436D"            /* .........tempoCm */
+	$"6400 0000 06B6 0000 06CF 0F66 7265 7144"            /* d..........freqD */
+	$"7572 6174 696F 6E43 6D64 0000 06D0 0000"            /* urationCmd...... */
+	$"06E1 0772 6573 7443 6D64 0000 06E2 0000"            /* ...restCmd...... */
+	$"06F3 0766 7265 7143 6D64 0000 06F4 0000"            /* ...freqCmd...... */
+	$"0704 0761 6D70 436D 6400 0000 0705 0000"            /* ...ampCmd....... */
+	$"0718 0974 696D 6272 6543 6D64 0000 0719"            /* ...timbreCmd.... */
+	$"0000 072C 0967 6574 416D 7043 6D64 0000"            /* ...,.getAmpCmd.. */
+	$"072E 0000 0744 0D77 6176 6554 6162 6C65"            /* .....D.waveTable */
+	$"436D 6400 0000 0745 0000 0756 0970 6861"            /* Cmd....E...V.pha */
+	$"7365 436D 6400 0000 0762 0000 0774 0973"            /* seCmd....b...t.s */
+	$"6F75 6E64 436D 6400 0000 0775 0000 0788"            /* oundCmd....u.... */
+	$"0962 7566 6665 7243 6D64 0000 0789 0000"            /* .bufferCmd...... */
+	$"079A 0772 6174 6543 6D64 0000 079B 0000"            /* ...rateCmd...... */
+	$"07B0 0B63 6F6E 7469 6E75 6543 6D64 0000"            /* ...continueCmd.. */
+	$"07B1 0000 07CA 0F64 6F75 626C 6542 7566"            /* .......doubleBuf */
+	$"6665 7243 6D64 0000 07CB 0000 07DF 0B67"            /* ferCmd.........g */
+	$"6574 5261 7465 436D 6400 0000 07E1 0000"            /* etRateCmd....... */
+	$"07F2 0773 697A 6543 6D64 0000 07F3 0000"            /* ...sizeCmd...... */
+	$"0807 0B63 6F6E 7665 7274 436D 6400 0000"            /* ...convertCmd... */
+	$"0809 0000 081E 0B73 7464 514C 656E 6774"            /* .......stdQLengt */
+	$"6800 0000 08B4 0000 08D0 1177 6176 6549"            /* h..........waveI */
+	$"6E69 7443 6861 6E6E 656C 3300 0000 08FA"            /* nitChannel3..... */
+	$"0000 094A 0B69 6E69 7450 616E 4D61 736B"            /* ...J.initPanMask */
+	$"0000 094B 0000 0998 0D69 6E69 7453 5261"            /* ...K.....initSRa */
+	$"7465 4D61 736B 0000 0999 0000 09E6 0F69"            /* teMask.........i */
+	$"6E69 7453 7465 7265 6F4D 6173 6B00 0000"            /* nitStereoMask... */
+	$"09E7 0000 0A31 0D69 6E69 7443 6F6D 704D"            /* .....1.initCompM */
+	$"6173 6B00 0000 0A33 0000 0A78 0D69 6E69"            /* ask....3...x.ini */
+	$"7443 6861 6E4C 6566 7400 0000 0A83 0000"            /* tChanLeft....... */
+	$"0AC9 0D69 6E69 7443 6861 6E52 6967 6874"            /* ...initChanRight */
+	$"0000 0ACA 0000 0B13 0D69 6E69 744E 6F49"            /* .........initNoI */
+	$"6E74 6572 7000 0000 0B14 0000 0B5F 0B69"            /* nterp........_.i */
+	$"6E69 744E 6F44 726F 7000 0000 0B60 0000"            /* nitNoDrop....`.. */
+	$"0BA4 0969 6E69 744D 6F6E 6F00 0000 0D47"            /* ...initMono....G */
+	$"0000 0D94 0969 6E69 7443 6861 6E33 0000"            /* .....initChan3.. */
+	$"0D96 0000 0DEA 0573 7464 5348 0000 0DEB"            /* .......stdSH.... */
+	$"0000 0E3F 0565 7874 5348 0000 0E40 0000"            /* ...?.extSH...@.. */
+	$"0E96 0563 6D70 5348 0000 0E98 0000 0EDA"            /* ...cmpSH........ */
+	$"0D6E 6F74 436F 6D70 7265 7373 6564 0000"            /* .notCompressed.. */
+	$"0EDB 0000 0EEC 0974 776F 546F 4F6E 6500"            /* .......twoToOne. */
+	$"0000 0EED 0000 0F02 0D65 6967 6874 546F"            /* .........eightTo */
+	$"5468 7265 6500 0000 0F03 0000 0F16 0B74"            /* Three..........t */
+	$"6872 6565 546F 4F6E 6500 0000 0F17 0000"            /* hreeToOne....... */
+	$"0F28 0973 6978 546F 4F6E 6500 0000 0F2A"            /* .(.sixToOne....* */
+	$"0000 0F6A 0D6F 7574 7369 6465 436D 7053"            /* ...j.outsideCmpS */
+	$"4800 0000 0F75 0000 0F89 0B69 6E73 6964"            /* H....u.....insid */
+	$"6543 6D70 5348 0000 0F8A 0000 0F9D 0B61"            /* eCmpSH.........a */
+	$"6365 5375 6363 6573 7300 0000 0F9E 0000"            /* ceSuccess....... */
+	$"0FB1 0B61 6365 4D65 6D46 756C 6C00 0000"            /* ...aceMemFull... */
+	$"0FB2 0000 0FC6 0B61 6365 4E69 6C42 6C6F"            /* .......aceNilBlo */
+	$"636B 0000 0FC7 0000 0FDA 0B61 6365 4261"            /* ck.........aceBa */
+	$"6443 6F6D 7000 0000 0FDB 0000 0FF0 0D61"            /* dComp..........a */
+	$"6365 4261 6445 6E63 6F64 6500 0000 0FF1"            /* ceBadEncode..... */
+	$"0000 1004 0B61 6365 4261 6444 6573 7400"            /* .....aceBadDest. */
+	$"0000 1034 0000 1052 1574 6872 6565 546F"            /* ...4...R.threeTo */
+	$"4F6E 6550 6163 6B65 7453 697A 6500 0000"            /* OnePacketSize... */
+	$"10D0 0000 112A 1173 6563 6F6E 6453 6F75"            /* .....*.secondSou */
+	$"6E64 466F 726D 6174 0000 112C 0000 1175"            /* ndFormat...,...u */
+	$"0D64 6242 7566 6665 7252 6561 6479 0000"            /* .dbBufferReady.. */
+	$"1176 0000 11C2 0D64 624C 6173 7442 7566"            /* .v.....dbLastBuf */
+	$"6665 7200 0000 11C4 0000 120C 0F73 7973"            /* fer..........sys */
+	$"4265 6570 4469 7361 626C 6500 0000 122A"            /* BeepDisable....* */
+	$"0000 1281 1375 6E69 7454 7970 654E 6F53"            /* .....unitTypeNoS */
+	$"656C 6563 7469 6F6E 0000 1282 0000 129E"            /* election........ */
+	$"0F75 6E69 7454 7970 6553 6563 6F6E 6473"            /* .unitTypeSeconds */
+	$"0000 12DE 0000 1305 0946 7265 6557 6176"            /* .........FreeWav */
+	$"6500 0000 1307 0000 139D 0B46 4653 796E"            /* e..........FFSyn */
+	$"7468 5265 6300 0000 139F 0000 1404 0554"            /* thRec..........T */
+	$"6F6E 6500 0000 1407 0000 1420 0554 6F6E"            /* one........ .Ton */
+	$"6573 0000 1422 0000 14A3 0B53 5753 796E"            /* es...".....SWSyn */
+	$"7468 5265 6300 0000 14A6 0000 14C7 0557"            /* thRec..........W */
+	$"6176 6500 0000 14C8 0000 14DE 0757 6176"            /* ave..........Wav */
+	$"6550 7472 0000 14E0 0000 1662 0B46 5453"            /* ePtr.......b.FTS */
+	$"6F75 6E64 5265 6300 0000 16EC 0000 171E"            /* oundRec......... */
+	$"1553 6E64 436F 6D70 6C65 7469 6F6E 5072"            /* .SndCompletionPr */
+	$"6F63 5074 7200 0000 175A 0000 17D2 0B53"            /* ocPtr....Z.....S */
+	$"6E64 436F 6D6D 616E 6400 0000 17D5 0000"            /* ndCommand....... */
+	$"181B 0554 696D 6500 0000 181F 0000 1AE9"            /* ...Time......... */
+	$"0B53 6E64 4368 616E 6E65 6C00 0000 1B01"            /* .SndChannel..... */
+	$"0000 1B85 0B53 7461 7465 426C 6F63 6B00"            /* .....StateBlock. */
+	$"0000 1B87 0000 1C37 0D4C 6566 744F 7665"            /* .......7.LeftOve */
+	$"7242 6C6F 636B 0000 1C39 0000 1C9A 074D"            /* rBlock...9.....M */
+	$"6F64 5265 6600 0000 1C9C 0000 1E3E 0F53"            /* odRef........>.S */
+	$"6E64 4C69 7374 5265 736F 7572 6365 0000"            /* ndListResource.. */
+	$"1E40 0000 20C9 0B53 6F75 6E64 4865 6164"            /* .@.. ..SoundHead */
+	$"6572 0000 20CC 0000 27B3 0F43 6D70 536F"            /* er.. ...'..CmpSo */
+	$"756E 6448 6561 6465 7200 0000 2D81 0000"            /* undHeader...-... */
+	$"2E64 0F43 6F6E 7665 7273 696F 6E42 6C6F"            /* .d.ConversionBlo */
+	$"636B 0000 2E66 0000 2F05 0953 4D53 7461"            /* ck...f../..SMSta */
+	$"7475 7300 0000 2F07 0000 304A 0953 4353"            /* tus.../...0J.SCS */
+	$"7461 7475 7300 0000 3266 0000 33CE 1553"            /* tatus...2f..3..S */
+	$"6E64 446F 7562 6C65 4275 6666 6572 4865"            /* ndDoubleBufferHe */
+	$"6164 6572 0000 33F8 0000 3459 0D53 6E64"            /* ader..3...4Y.Snd */
+	$"446F 436F 6D6D 616E 6400 0000 345A 0000"            /* DoCommand...4Z.. */
+	$"34AE 0F53 6E64 446F 496D 6D65 6469 6174"            /* 4..SndDoImmediat */
+	$"6500 0000 3523 0000 3575 1153 6E64 4469"            /* e...5#..5u.SndDi */
+	$"7370 6F73 6543 6861 6E6E 656C 0000 3576"            /* sposeChannel..5v */
+	$"0000 35C9 0753 6E64 506C 6179 0000 35CA"            /* ..5..SndPlay..5. */
+	$"0000 3631 0F53 6E64 4164 644D 6F64 6966"            /* ..61.SndAddModif */
+	$"6965 7200 0000 3632 0000 3672 0B53 6E64"            /* ier...62..6r.Snd */
+	$"436F 6E74 726F 6C00 0000 3674 0000 369A"            /* Control...6t..6. */
+	$"0B53 6574 536F 756E 6456 6F6C 0000 369B"            /* .SetSoundVol..6. */
+	$"0000 3703 0B47 6574 536F 756E 6456 6F6C"            /* ..7..GetSoundVol */
+	$"0000 3704 0000 3763 0B53 7461 7274 536F"            /* ..7...7c.StartSo */
+	$"756E 6400 0000 3764 0000 3781 0953 746F"            /* und...7d..7..Sto */
+	$"7053 6F75 6E64 0000 3B33 0000 3BB0 1353"            /* pSound..;3..;..S */
+	$"6E64 506C 6179 446F 7562 6C65 4275 6666"            /* ndPlayDoubleBuff */
+	$"6572 0000 3E6B 0000 3F39 0745 7870 3174"            /* er..>k..?9.Exp1t */
+	$"6F36"                                               /* o6 */
+};
+
+data 'MPSR' (1008) {
+	$"002A 0003 0142 01E3 002A 0003 0142 01E3"            /* .*...B...*...B.. */
+	$"0000 0000 0000 0000 0000 0000 0000"                 /* .............. */
+};
+
+data 'vers' (1, purgeable) {
+	$"0320 8000 0000 0533 2E32 2E30 2433 2E32"            /* . .....3.2.0$3.2 */
+	$"2E30 20A9 2041 7070 6C65 2043 6F6D 7075"            /* .0 . Apple Compu */
+	$"7465 722C 2049 6E63 2E20 3139 3835 2D39"            /* ter, Inc. 1985-9 */
+	$"31"                                                 /* 1 */
+};
+
+data 'vers' (2, purgeable) {
+	$"0320 8000 0000 0333 2E32 074D 5057 2033"            /* . .....3.2.MPW 3 */
+	$"2E32"                                               /* .2 */
+};
+
diff --git a/Interfaces/PInterfaces/Sound.p b/Interfaces/PInterfaces/Sound.p
new file mode 100644
--- /dev/null
+++ b/Interfaces/PInterfaces/Sound.p
@@ -0,0 +1,455 @@
+
+{
+Created: Monday, December 2, 1991 at 5:09 PM
+ Sound.p
+ Pascal Interface to the Macintosh Libraries
+
+  Copyright Apple Computer, Inc. 1986-1991
+  All rights reserved
+}
+
+
+{$IFC UNDEFINED UsingIncludes}
+{$SETC UsingIncludes := 0}
+{$ENDC}
+
+{$IFC NOT UsingIncludes}
+ UNIT Sound;
+ INTERFACE
+{$ENDC}
+
+{$IFC UNDEFINED UsingSound}
+{$SETC UsingSound := 1}
+
+{$I+}
+{$SETC SoundIncludes := UsingIncludes}
+{$SETC UsingIncludes := 1}
+{$IFC UNDEFINED UsingTypes}
+{$I $$Shell(PInterfaces)Types.p}
+{$ENDC}
+{$IFC UNDEFINED UsingFiles}
+{$I $$Shell(PInterfaces)Files.p}
+{$ENDC}
+{$SETC UsingIncludes := SoundIncludes}
+
+CONST
+swMode = -1;								{ Sound Driver modes }
+ftMode = 1;
+ffMode = 0;
+
+synthCodeRsrc = 'snth';						{ Resource types used by Sound Manager }
+soundListRsrc = 'snd ';
+
+twelfthRootTwo = 1.05946309434;
+rate22khz = $56EE8BA3;						{ 22254.54545 in fixed-point }
+rate11khz = $2B7745D1;						{ 11127.27273 in fixed-point }
+
+{ synthesizer numbers for SndNewChannel }
+squareWaveSynth = 1;						{square wave synthesizer}
+waveTableSynth = 3;							{wave table synthesizer}
+sampledSynth = 5;							{sampled sound synthesizer}
+
+{ old Sound Manager MACE synthesizer numbers }
+MACE3snthID = 11;
+MACE6snthID = 13;
+
+{ command numbers for SndDoCommand and SndDoImmediate }
+nullCmd = 0;
+initCmd = 1;
+freeCmd = 2;
+quietCmd = 3;
+flushCmd = 4;
+reInitCmd = 5;
+
+waitCmd = 10;
+pauseCmd = 11;
+resumeCmd = 12;
+callBackCmd = 13;
+syncCmd = 14;
+emptyCmd = 15;
+
+tickleCmd = 20;
+requestNextCmd = 21;
+howOftenCmd = 22;
+wakeUpCmd = 23;
+availableCmd = 24;
+versionCmd = 25;
+totalLoadCmd = 26;
+loadCmd = 27;
+
+scaleCmd = 30;
+tempoCmd = 31;
+
+freqDurationCmd = 40;
+restCmd = 41;
+freqCmd = 42;
+ampCmd = 43;
+timbreCmd = 44;
+getAmpCmd = 45;
+
+waveTableCmd = 60;
+phaseCmd = 61;
+
+soundCmd = 80;
+bufferCmd = 81;
+rateCmd = 82;
+continueCmd = 83;
+doubleBufferCmd = 84;
+getRateCmd = 85;
+
+sizeCmd = 90;
+convertCmd = 91;
+
+stdQLength = 128;
+dataOffsetFlag = $8000;
+
+waveInitChannelMask = $07;
+waveInitChannel0 = $04;
+waveInitChannel1 = $05;
+waveInitChannel2 = $06;
+waveInitChannel3 = $07;
+
+{ channel initialization parameters }
+initPanMask = $0003;						{ mask for right/left pan values }
+initSRateMask = $0030;						{ mask for sample rate values }
+initStereoMask = $00C0;						{ mask for mono/stereo values }
+initCompMask = $FF00;						{ mask for compression IDs }
+
+initChanLeft = $0002;						{ left stereo channel }
+initChanRight = $0003;						{ right stereo channel }
+initNoInterp = $0004;						{ no linear interpolation }
+initNoDrop = $0008;							{ no drop-sample conversion }
+initMono = $0080;							{ monophonic channel }
+initStereo = $00C0;							{ stereo channel }
+initMACE3 = $0300;							{ MACE 3:1 }
+initMACE6 = $0400;							{ MACE 6:1 }
+
+initChan0 = $0004;							{ channel 0 - wave table only }
+initChan1 = $0005;							{ channel 1 - wave table only }
+initChan2 = $0006;							{ channel 2 - wave table only }
+initChan3 = $0007;							{ channel 3 - wave table only }
+
+stdSH = $00;								{ Standard sound header encode value }
+extSH = $FF;								{ Extended sound header encode value }
+cmpSH = $FE;								{ Compressed sound header encode value }
+
+notCompressed = 0;							{ compression ID's }
+twoToOne = 1;
+eightToThree = 2;
+threeToOne = 3;
+sixToOne = 4;
+
+outsideCmpSH = 0;							{ MACE constants }
+insideCmpSH = 1;
+aceSuccess = 0;
+aceMemFull = 1;
+aceNilBlock = 2;
+aceBadComp = 3;
+aceBadEncode = 4;
+aceBadDest = 5;
+aceBadCmd = 6;
+sixToOnePacketSize = 8;
+threeToOnePacketSize = 16;
+stateBlockSize = 64;
+leftOverBlockSize = 32;
+
+firstSoundFormat = $0001;					{ general sound format }
+secondSoundFormat = $0002;					{ special sampled sound format (HyperCard) }
+
+dbBufferReady = $00000001;					{ double buffer is filled }
+dbLastBuffer = $00000004;					{ last double buffer to play }
+
+sysBeepDisable = $0000;						{ SysBeep() enable flags }
+sysBeepEnable = $0001;
+
+unitTypeNoSelection = $FFFF;				{ unitTypes for AudioSelection.unitType }
+unitTypeSeconds = $0000;
+
+TYPE
+{   Structures for Sound Driver   }
+
+
+FreeWave = PACKED ARRAY [0..30000] OF Byte;
+
+FFSynthPtr = ^FFSynthRec;
+FFSynthRec = RECORD
+ mode: INTEGER;
+ count: Fixed;
+ waveBytes: FreeWave;
+ END;
+
+Tone = RECORD
+ count: INTEGER;
+ amplitude: INTEGER;
+ duration: INTEGER;
+ END;
+
+
+Tones = ARRAY [0..5000] OF Tone;
+
+SWSynthPtr = ^SWSynthRec;
+SWSynthRec = RECORD
+ mode: INTEGER;
+ triplets: Tones;
+ END;
+
+
+Wave = PACKED ARRAY [0..255] OF Byte;
+WavePtr = ^Wave;
+
+FTSndRecPtr = ^FTSoundRec;
+FTSoundRec = RECORD
+ duration: INTEGER;
+ sound1Rate: Fixed;
+ sound1Phase: LONGINT;
+ sound2Rate: Fixed;
+ sound2Phase: LONGINT;
+ sound3Rate: Fixed;
+ sound3Phase: LONGINT;
+ sound4Rate: Fixed;
+ sound4Phase: LONGINT;
+ sound1Wave: WavePtr;
+ sound2Wave: WavePtr;
+ sound3Wave: WavePtr;
+ sound4Wave: WavePtr;
+ END;
+
+FTSynthPtr = ^FTSynthRec;
+FTSynthRec = RECORD
+ mode: INTEGER;
+ sndRec: FTSndRecPtr;
+ END;
+
+{   Structures for Sound Manager   }
+
+SndCommand = PACKED RECORD
+ cmd: INTEGER;
+ param1: INTEGER;
+ param2: LONGINT;
+ END;
+
+
+Time = LONGINT;								{ in half milliseconds }
+
+
+
+SndChannelPtr = ^SndChannel;
+SndChannel = PACKED RECORD
+ nextChan: SndChannelPtr;
+ firstMod: Ptr;								{ reserved for the Sound Manager }
+ callBack: ProcPtr;
+ userInfo: LONGINT;
+ wait: Time;								{ The following is for internal Sound Manager use only.}
+ cmdInProgress: SndCommand;
+ flags: INTEGER;
+ qLength: INTEGER;
+ qHead: INTEGER;							{ next spot to read or -1 if empty }
+ qTail: INTEGER;							{ next spot to write = qHead if full }
+ queue: ARRAY [0..stdQLength - 1] OF SndCommand;
+ END;
+
+{ MACE structures }
+StateBlockPtr = ^StateBlock;
+StateBlock = RECORD
+ stateVar: ARRAY [0..stateBlockSize - 1] OF INTEGER;
+ END;
+
+LeftOverBlockPtr = ^LeftOverBlock;
+LeftOverBlock = RECORD
+ count: LONGINT;
+ sampleArea: PACKED ARRAY [0..leftOverBlockSize - 1] OF Byte;
+ END;
+
+ModRef = RECORD
+ modNumber: INTEGER;
+ modInit: LONGINT;
+ END;
+
+SndListPtr = ^SndListResource;
+SndListResource = RECORD
+ format: INTEGER;
+ numModifiers: INTEGER;
+ modifierPart: ARRAY [0..0] OF ModRef;		{This is a variable length array}
+ numCommands: INTEGER;
+ commandPart: ARRAY [0..0] OF SndCommand;	{This is a variable length array}
+ dataPart: PACKED ARRAY [0..0] OF Byte;		{This is a variable length array}
+ END;
+
+SoundHeaderPtr = ^SoundHeader;
+SoundHeader = PACKED RECORD
+ samplePtr: Ptr;							{ if NIL then samples are in sampleArea }
+ length: LONGINT;							{ length of sound in bytes }
+ sampleRate: Fixed;							{ sample rate for this sound }
+ loopStart: LONGINT;						{ start of looping portion }
+ loopEnd: LONGINT;							{ end of looping portion }
+ encode: Byte;								{ header encoding }
+ baseFrequency: Byte;						{ baseFrequency value }
+ sampleArea: PACKED ARRAY [0..0] OF Byte;
+ END;
+
+CmpSoundHeaderPtr = ^CmpSoundHeader;
+CmpSoundHeader = PACKED RECORD
+ samplePtr: Ptr;							{ if nil then samples are in sample area }
+ numChannels: LONGINT;						{ number of channels i.e. mono = 1 }
+ sampleRate: Fixed;							{ sample rate in Apples Fixed point representation }
+ loopStart: LONGINT;						{ loopStart of sound before compression }
+ loopEnd: LONGINT;							{ loopEnd of sound before compression }
+ encode: Byte;								{ data structure used , stdSH, extSH, or cmpSH }
+ baseFrequency: Byte;						{ same meaning as regular SoundHeader }
+ numFrames: LONGINT;						{ length in frames ( packetFrames or sampleFrames ) }
+ AIFFSampleRate: Extended80;				{ IEEE sample rate }
+ markerChunk: Ptr;							{ sync track }
+ futureUse1: Ptr;							{ reserved by Apple }
+ futureUse2: Ptr;							{ reserved by Apple }
+ stateVars: StateBlockPtr;					{ pointer to State Block }
+ leftOverSamples: LeftOverBlockPtr;			{ used to save truncated samples between compression calls }
+ compressionID: INTEGER;					{ 0 means no compression, non zero means compressionID }
+ packetSize: INTEGER;						{ number of bits in compressed sample packet }
+ snthID: INTEGER;							{ resource ID of Sound Manager snth that contains NRT C/E }
+ sampleSize: INTEGER;						{ number of bits in non-compressed sample }
+ sampleArea: PACKED ARRAY [0..0] OF Byte;	{ space for when samples follow directly }
+ END;
+
+ExtSoundHeaderPtr = ^ExtSoundHeader;
+ExtSoundHeader = PACKED RECORD
+ samplePtr: Ptr;							{ if nil then samples are in sample area }
+ numChannels: LONGINT;						{ number of channels,  ie mono = 1 }
+ sampleRate: Fixed;							{ sample rate in Apples Fixed point representation }
+ loopStart: LONGINT;						{ same meaning as regular SoundHeader }
+ loopEnd: LONGINT;							{ same meaning as regular SoundHeader }
+ encode: Byte;								{ data structure used , stdSH, extSH, or cmpSH }
+ baseFrequency: Byte;						{ same meaning as regular SoundHeader }
+ numFrames: LONGINT;						{ length in total number of frames }
+ AIFFSampleRate: Extended80;				{ IEEE sample rate }
+ markerChunk: Ptr;							{ sync track }
+ instrumentChunks: Ptr;						{ AIFF instrument chunks }
+ AESRecording: Ptr;
+ sampleSize: INTEGER;						{ number of bits in sample }
+ futureUse1: INTEGER;						{ reserved by Apple }
+ futureUse2: LONGINT;						{ reserved by Apple }
+ futureUse3: LONGINT;						{ reserved by Apple }
+ futureUse4: LONGINT;						{ reserved by Apple }
+ sampleArea: PACKED ARRAY [0..0] OF Byte;	{ space for when samples follow directly }
+ END;
+
+ConversionBlockPtr = ^ConversionBlock;
+ConversionBlock = RECORD
+ destination: INTEGER;
+ unused: INTEGER;
+ inputPtr: CmpSoundHeaderPtr;
+ outputPtr: CmpSoundHeaderPtr;
+ END;
+
+SMStatusPtr = ^SMStatus;
+SMStatus = PACKED RECORD
+ smMaxCPULoad: INTEGER;
+ smNumChannels: INTEGER;
+ smCurCPULoad: INTEGER;
+ END;
+
+SCStatusPtr = ^SCStatus;
+SCStatus = RECORD
+ scStartTime: Fixed;
+ scEndTime: Fixed;
+ scCurrentTime: Fixed;
+ scChannelBusy: BOOLEAN;
+ scChannelDisposed: BOOLEAN;
+ scChannelPaused: BOOLEAN;
+ scUnused: BOOLEAN;
+ scChannelAttributes: LONGINT;
+ scCPULoad: LONGINT;
+ END;
+
+AudioSelectionPtr = ^AudioSelection;
+AudioSelection = PACKED RECORD
+ unitType: LONGINT;
+ selStart: Fixed;
+ selEnd: Fixed;
+ END;
+
+SndDoubleBufferPtr = ^SndDoubleBuffer;
+SndDoubleBuffer = PACKED RECORD
+ dbNumFrames: LONGINT;
+ dbFlags: LONGINT;
+ dbUserInfo: ARRAY [0..1] OF LONGINT;
+ dbSoundData: PACKED ARRAY [0..0] OF Byte;
+ END;
+
+SndDoubleBufferHeaderPtr = ^SndDoubleBufferHeader;
+SndDoubleBufferHeader = PACKED RECORD
+ dbhNumChannels: INTEGER;
+ dbhSampleSize: INTEGER;
+ dbhCompressionID: INTEGER;
+ dbhPacketSize: INTEGER;
+ dbhSampleRate: Fixed;
+ dbhBufferPtr: ARRAY [0..1] OF SndDoubleBufferPtr;
+ dbhDoubleBack: ProcPtr;
+ END;
+
+
+FUNCTION SndDoCommand(chan: SndChannelPtr;cmd: SndCommand;noWait: BOOLEAN): OSErr;
+ INLINE $A803;
+FUNCTION SndDoImmediate(chan: SndChannelPtr;cmd: SndCommand): OSErr;
+ INLINE $A804;
+FUNCTION SndNewChannel(VAR chan: SndChannelPtr;synth: INTEGER;init: LONGINT;
+ userRoutine: ProcPtr): OSErr;
+ INLINE $A807;
+FUNCTION SndDisposeChannel(chan: SndChannelPtr;quietNow: BOOLEAN): OSErr;
+ INLINE $A801;
+FUNCTION SndPlay(chan: SndChannelPtr;sndHdl: Handle;async: BOOLEAN): OSErr;
+ INLINE $A805;
+FUNCTION SndAddModifier(chan: SndChannelPtr;modifier: ProcPtr;id: INTEGER;
+ init: LONGINT): OSErr;
+ INLINE $A802;
+FUNCTION SndControl(id: INTEGER;VAR cmd: SndCommand): OSErr;
+ INLINE $A806;
+
+PROCEDURE SetSoundVol(level: INTEGER);
+PROCEDURE GetSoundVol(VAR level: INTEGER);
+PROCEDURE StartSound(synthRec: Ptr;numBytes: LONGINT;completionRtn: ProcPtr);
+PROCEDURE StopSound;
+FUNCTION SoundDone: BOOLEAN;
+
+FUNCTION SndSoundManagerVersion: NumVersion;
+ INLINE $203C,$000C,$0008,$A800;
+FUNCTION SndStartFilePlay(chan: SndChannelPtr;fRefNum: INTEGER;resNum: INTEGER;
+ bufferSize: LONGINT;theBuffer: Ptr;theSelection: AudioSelectionPtr;theCompletion: ProcPtr;
+ async: BOOLEAN): OSErr;
+ INLINE $203C,$0D00,$0008,$A800;
+FUNCTION SndPauseFilePlay(chan: SndChannelPtr): OSErr;
+ INLINE $203C,$0204,$0008,$A800;
+FUNCTION SndStopFilePlay(chan: SndChannelPtr;async: BOOLEAN): OSErr;
+ INLINE $203C,$0308,$0008,$A800;
+FUNCTION SndChannelStatus(chan: SndChannelPtr;theLength: INTEGER;theStatus: SCStatusPtr): OSErr;
+ INLINE $203C,$0010,$0008,$A800;
+FUNCTION SndManagerStatus(theLength: INTEGER;theStatus: SMStatusPtr): OSErr;
+ INLINE $203C,$0014,$0008,$A800;
+PROCEDURE SndGetSysBeepState(VAR sysBeepState: INTEGER);
+ INLINE $203C,$0018,$0008,$A800;
+FUNCTION SndSetSysBeepState(sysBeepState: INTEGER): OSErr;
+ INLINE $203C,$001C,$0008,$A800;
+FUNCTION SndPlayDoubleBuffer(chan: SndChannelPtr;theParams: SndDoubleBufferHeaderPtr): OSErr;
+ INLINE $203C,$0020,$0008,$A800;
+
+FUNCTION MACEVersion: NumVersion;
+ INLINE $203C,$0000,$0010,$A800;
+PROCEDURE Comp3to1(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$0004,$0010,$A800;
+PROCEDURE Exp1to3(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$0008,$0010,$A800;
+PROCEDURE Comp6to1(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$000C,$0010,$A800;
+PROCEDURE Exp1to6(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$0010,$0010,$A800;
+
+
+{$ENDC} { UsingSound }
+
+{$IFC NOT UsingIncludes}
+ END.
+{$ENDC}
+
diff --git a/Interfaces/PInterfaces/Sound.p.idump b/Interfaces/PInterfaces/Sound.p.idump
new file mode 100644
--- /dev/null
+++ b/Interfaces/PInterfaces/Sound.p.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Interfaces/RIncludes/Types.r b/Interfaces/RIncludes/Types.r
--- a/Interfaces/RIncludes/Types.r
+++ b/Interfaces/RIncludes/Types.r
@@ -145,7 +145,6 @@ type 'acur' {
            fill word;                    /* Pad word to make longint       */
        };
 };
-#ifdef oldTemp
 /*--------------------------actb • Alert Color old Lookup Table--------------------------*/
 	type 'actb' {
 			unsigned hex longint = 0;								/* ctSeed				*/
@@ -170,32 +169,6 @@ type 'acur' {
 					unsigned integer;								/*		blue			*/
 			};
 	};
-#else
-/*----------------------------actb • Alert Color Lookup Table----------------------------*/
-	type 'actb' {
-			unsigned hex longint = 0;								/* ctSeed				*/
-			integer = 1;											/* ctFlags				*/
-			integer = $$Countof(ColorSpec) - 1;						/* ctSize				*/
-			wide array ColorSpec {
-					integer		wContentColor,						/* value				*/
-								wFrameColor,
-								wTextColor,
-								wHiliteColor,
-								wTitleBarColor,
-								wHiliteLight,
-								wHiliteDark,
-								wTitleBarLight,
-								wTitleBarDark,
-								wDialogLight,
-								wDialogDark,
-								wTingeLight,
-								wTingeDark;
-					unsigned integer;								/* RGB:	red				*/
-					unsigned integer;								/*		green			*/
-					unsigned integer;								/*		blue			*/
-			};
-	};
-#endif
 /*--------------------------aedt • Apple Events Template---------------------------------*/
 /* Resource definition used for associating a value with an apple event */
 /* This really only useful for general dispatching */
diff --git a/Internal/Asm/AppleDeskBusPriv.a b/Internal/Asm/AppleDeskBusPriv.a
--- a/Internal/Asm/AppleDeskBusPriv.a
+++ b/Internal/Asm/AppleDeskBusPriv.a
@@ -11,16 +11,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM3>	 7/7/92		CSS		Remove includes to ApplDeskBusPriv.a and roll changes
-;									from that file into this one:
-;	  								<SM1> 5/2/92	kc		Roll in Horror. Comments follow:
-;		 							<2>	  8/5/91	SC		Added new bits to the PMGR ADB flags.
-;									Updated from Reality:
-;		 							<6>	 4/24/92	JF		Added comment to let everyone know that one of three unused
-;									l						ongs in ADBVars is now being used.
-;	   <SM2>	 5/25/92	RB		Commented out the definition of talkCmd and listenCmd since they
-;									are also defined in EgretEqu.a, which seems to be included
-;									everywhere.
 ;		 <5>	 8/21/91	JSM		Clean up header.
 ;		 <4>	 1/30/91	gbm		sab, #38: Change the ‘already including this file’ variable to
 ;									all uppercase (for security reasons)
@@ -48,8 +38,8 @@ __INCLUDINGAPPLEDESKBUSPRIV__	SET	1
 
 maskADBCmd		EQU			$0C					; Mask for ADB command
 resetCmd		EQU			$00					; Command for Bus Reset
-; <SM2> rb	talkCmd   		EQU 		$0C   				; Command for Talk R0
-; <SM2> rb	listenCmd 		EQU 		$08   				; Command for Listen R0 
+talkCmd   		EQU 		$0C   				; Command for Talk R0
+listenCmd 		EQU 		$08   				; Command for Listen R0 
 kbdAddr   		EQU 		$02   				; keyboard type device 
 mouseAddr 		EQU 		$03   				; mouse type device 
 numFDBAdr 		EQU 		16   				; number of avaiblae FDB address 
@@ -62,8 +52,6 @@ Flags			ds.b	1				; modifier/status flags (bit definitions below)
 NoReply			equ		1				; flag for 'command timed out'
 SRQReq			equ		2				; int flag for 'device requesting service'
 SetPollEnables	equ		5				; Update auto-enable bit mask from ADBData field	<1.4>
-PollEnable		equ		6				; enable auto polling and auto srq polling
-ExplicitCmd		equ		7				; message contains an explicit cmd
 
 DataCount		ds.b	1				; number of bytes of ADBData (0..8) (cmd not included)
 ADBCmd			ds.b	1				; ADB command to send / command that replied
@@ -128,7 +116,7 @@ hasDev			ds.w	1	    			; every bit corresponds to an device address
 devMap			ds.w	1	  				; device address map (2 bytes)
 
 				ds.l	1					; unused space												<6>
-				ds.l	1					; •• Now Used! ••  Pointer to Extended ADB Data (4 bytes)	<6>
+				ds.l	1					; unused space												<6>
 				ds.l	1					; unused space												<6>
 				
 fDBCmd			ds.b	1		  			; last fDB command (1 byte)
diff --git a/Internal/Asm/CommToolboxPriv.a b/Internal/Asm/CommToolboxPriv.a
--- a/Internal/Asm/CommToolboxPriv.a
+++ b/Internal/Asm/CommToolboxPriv.a
@@ -260,7 +260,6 @@ private				DS.W	1		; INTEGER;
 appList				DS.L	1		; CRMAppRecPtr;
 resFiles			DS.L	1		; ResFileRecHdl;
 toolResChain 		DS.L	1		; ResourceMapHandle;
-CommToolBoxTable	DS.L	1		; ptr to table
 secret				DS.L	16		; LONGINT
 CTBBlockSize		EQU	*
 					ENDR
diff --git a/Internal/Asm/Decompression.a b/Internal/Asm/Decompression.a
--- a/Internal/Asm/Decompression.a
+++ b/Internal/Asm/Decompression.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		 <1>	 4/14/92	stb		first checked in
-;		<19>	 4/14/91	stb		<sm1>stb Add to SuperMario project for use by ResourceMgr.a.  Corrected some speling.
 ;		<18>	  7/9/91	JSM		No need to define SysVers here.
 ;		<17>	 1/30/91	gbm		sab, #38: Change the name of one of the decompressor header
 ;									files (because Sheila said it was okay)
@@ -195,7 +193,8 @@ maxReplacement		EQU	6		;end of substitution list.
 ;
 ;---------------------------------------------------------------------------------
 ExtendedResource	Record	0
-signature			DS.L	1		;used for robustness.  Tells if data is compressed now.
+signature
+signiture			DS.L	1		;used for robustness.  Tells if data is compressed now.
 headerLength		DS.W	1		;length of this header in bytes.
 headerVersion		DS.B	1		;number of items in this header. ( must be < 128 ).
 extendedAttributes	DS.B	1		;extension to the attributes for this resource.
diff --git a/Internal/Asm/DialogsPriv.a b/Internal/Asm/DialogsPriv.a
--- a/Internal/Asm/DialogsPriv.a
+++ b/Internal/Asm/DialogsPriv.a
@@ -31,8 +31,6 @@
 	IF &TYPE('__INCLUDINGDIALOGSPRIV__') = 'UNDEFINED' THEN
 __INCLUDINGDIALOGSPRIV__	SET	1
 
-	IF forROM OR TheFuture THEN
-
 	; format of globals in emDialogGlobals
 
 DialogMgrGlobals	record	0
@@ -43,8 +41,6 @@ SavedMenuState		ds.l	1
 DialogMgrGlobalsSize equ	*
 					endr
 
-	ENDIF						; forROM OR TheFuture
-
 ; bits for flag byte
 cannotTwitchOutOfDialogBit		EQU 7
 systemHandlesMenusBit			EQU	6
diff --git a/Internal/Asm/GestaltPrivateEqu.a b/Internal/Asm/GestaltPrivateEqu.a
--- a/Internal/Asm/GestaltPrivateEqu.a
+++ b/Internal/Asm/GestaltPrivateEqu.a
@@ -146,7 +146,7 @@
 __INCLUDINGGESTALTPRIVATEEQU__	SET	1
 
 
-gestaltVers					EQU		4			; gestalt version (is this an oxymoron, or what? )
+gestaltVers					EQU		1			; gestalt version (is this an oxymoron, or what? )
 
 ;kInitialEntryCount			EQU		80			; initial number of slots at boot time
 gestaltFlagIsValueMask		EQU		1			; bit in flags that means value is not ProcPtr
@@ -165,8 +165,9 @@ size			equ		*
 				ENDR
 
 GestaltGlobals	RECORD	0
+longH
 tableH			ds.l	1						; handle to table of longs
-slotsUsed		ds.l	1						; number of entries in table
+slotsUsed
 maxSlots		ds.l	1						; number of entries in table
 memSize			ds.l	1						; amount of memory in this machine
 realTop			ds.l	1						; adjusted memory size
@@ -175,10 +176,6 @@ fpu				ds.b	1						; fpu type
 mmu				ds.b	1						; mmu type
 parityStatus	ds.l	1						; parity status
 myScratch		ds.l	1						; scratch area
-emu68k			ds.b	1						; 68k emulator installed flag
-nativeCPU		ds.b	1						; native cpu type
-nativePageSize	ds.l	1						; native page size
-ediskSize		ds.l	1						; edisk size <SM18> CSS
 GestaltRecSize	equ		*
 				ENDR
 
diff --git a/Internal/Asm/HardwarePrivateEqu.a b/Internal/Asm/HardwarePrivateEqu.a
--- a/Internal/Asm/HardwarePrivateEqu.a
+++ b/Internal/Asm/HardwarePrivateEqu.a
@@ -8,40 +8,10 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM30>	12/13/93	PN		Roll in KAOs and Horror changes to support Malcom and AJ
-;									machines
-;	  <SM29>	11/16/93	SAM		Added an eieio macro for use on systems that have non serialized
-;									i/o space.  Basically, the macro will expand to a 68k NOP if
-;									"forNonSerializedIO" is set to true.
-;	  <SM28>	 11/9/93	KW		added eieioSTP macro.  When forSTP601 is defined as True, a 68k
-;									nop instruction will be added.  Emulator turns 68k nop into
-;									eieio.  Only effects the CygnusX1 ROM
 ;	  <SM27>	  8/4/93	JDR		private sound defines are in SoundPrivate.a
-;	  <SM26>	 7/20/93	SAM		Fixed the ROMHeader record.  Added the fields the SuperMario
-;									guys forgot to add to the end of the structure.
-;	  <SM25>	 7/14/93	RC		Added BART nubus controller register defs for PDM and Cold
-;									Fusion
-;	  <SM24>	  5/6/93	SAM		More generic AMIC stuff.
-;	  <SM23>	 4/22/93	SAM		Added some general AMIC equates (for PDM).
 ;	  <SM22>	 3/31/93	chp		Synchronize SuperMario with changes from <LW2>.
 ;	   <LW2>	 2/24/93	chp		Added equates for the PSC wait/request multiplexer control bits
 ;									in VIA1.
-;	  <SM21>	01-12-93	jmp		Added in the CSC equates.
-;	  <SM20>	 12/4/92	SWC		Added ascPlayRecA to the ASC equates.
-;	  <SM19>	 12/1/92	EH		Added Pratt Memory controller equates and Via1 equates for
-;									Blackbird.
-;	  <SM18>	 11/6/92	rab		Roll in Horror changes. Comments follow:
-;	   <H28> 	10/12/92	BG		Added symbolic constants for refering to the CPU ID bits that
-;									describe CPU_SPEED and CPU_ID values for Wombat/WLCD/Vail040.
-;	   <H27>	  9/6/92	jab		Added SCSI configuration info for BIOS.
-;	   <H26>	 8/25/92	BG		Added definitions for BIOS configuration registers.
-;	  <SM17>	10/27/92	fau		Added a YMCABase to the YMCA equ's.
-;	  <SM16>	 9/30/92	fau		Added a couple of constants for YMCA register sizes to aid in
-;									the SizeMem programming;  renamed a couple of YMCA registers to
-;									something better.
-;	  <SM15>	 9/16/92	WS		Fix bug change / to _
-;	  <SM14>	 9/16/92	WS
-;	  <SM14>	 9/15/92	gjs		Added the YMCA equates for EVT-4.
 ;	  <SM13>	 8/17/92	CCH		Bumped HeapStart to $2800.
 ;	  <SM12>	  8/7/92	JDB		Changed Singer control register to have 0 for the output
 ;									attenuation and  5 for the input gain.
@@ -217,6 +187,43 @@
 __INCLUDINGHARDWAREPRIVATEEQU__	SET	1
 
 
+  				IF  		(&TYPE('onMac') = 'UNDEFINED') THEN 
+onMac 			EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onMacPP') = 'UNDEFINED') THEN
+onMacPP   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onNuMac') = 'UNDEFINED') THEN
+onNuMac   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onHafMac') = 'UNDEFINED') THEN
+onHafMac   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onHcMac') = 'UNDEFINED') THEN
+onHcMac   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onMac16') = 'UNDEFINED') THEN
+onMac16   		EQU 		0
+  				ENDIF
+
+  				IF  		(&TYPE('onMac32') = 'UNDEFINED') THEN
+onMac32   		EQU 		0
+  				ENDIF
+
+onAnything		EQU 		onMac|onMacPP|onHcMac|onHafMac|onNuMac|onMac16|onMac32
+
+
+; *** If HWNonPortable is defined to be non-zero, Then a machine type must be specified!
+; *** If a machine is specified, HWNonPortable must be non-zero, specified or not.
+  				IF  		(&TYPE('HWNonPortable') = 'UNDEFINED') THEN
+HWNonPortable 	EQU 		onAnything
+  				ENDIF
+
 
 ;__________________________________________________________________________________________
 ;
@@ -432,6 +439,34 @@ sDTIME			EQU			$140
 
 sTEST			equ			$180
 
+
+;---------------------------------------------------
+;  Apple Sound Chip register offsets
+;---------------------------------------------------
+
+ascVersion      equ     $800    ; [byte]
+ascMode       equ     $801    ; [byte] 2 means waveform
+ascChipControl    equ     $802    ; [byte]
+ascFifoControl    equ     $803    ; [byte]
+ascFifoInt      equ     $804    ; [byte]
+ascWaveOneShot    equ     $805    ; [byte]
+ascVolControl   equ     $806    ; [byte]
+ascClockRate    equ     $807    ; [byte]
+ascPlayRecA     equ     $80a    ; [byte]
+ascPlayRecB     equ     $80b    ; [byte]
+ascTestReg      equ     $80f    ; [byte]
+
+bmSrcTimeIncrA    equ     $f04    ; [byte]
+bmSrcTimeIncrB    equ     $f24    ; [byte]
+bmLeftScaleA    equ     $f06    ; [byte]
+bmLeftScaleB    equ     $f26    ; [byte]
+bmRightScaleA   equ     $f07    ; [byte]
+bmRightScaleB   equ     $f27    ; [byte]
+bmFifoControlA    equ     $f08    ; [byte]
+bmFifoControlB    equ     $f28    ; [byte]
+bmIntControlA   equ     $f09    ; [byte]
+bmIntControlB   equ     $f29    ; [byte]
+
 ;__________________________________________________________________________________________
 ;
 ;
@@ -651,7 +686,7 @@ vPCR  			EQU 		$1800 					; PERIPH. CONTROL REG.
 vIFR  			EQU 		$1A00 					; INT. FLAG REG.
 vIER  			EQU 		$1C00 					; INT. ENABLE REG.
 vBufA 			EQU 		$1E00 					; BUFFER A
-vBufD 			EQU 		vBufA 					; disk head select is buffer A			<3.5>
+;(see below) vBufD 			EQU 		vBufA 					; disk head select is buffer A			<3.5>
 
 ;---------------------------------------------------
 ; VIA IFR/IER bits
@@ -671,51 +706,49 @@ ifIRQ 			EQU 		7 						; any interrupt
 ; VIA1 Port A definitions
 ;---------------------------------------------------
 
-vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+;(see below) vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
 
-vTestJ			EQU 		0 						; Burn In Test jumper		(input)
+;(see below) vTestJ			EQU 		0 						; Burn In Test jumper		(input)
 
-vCpuId0			EQU			1						; CPU Identification bit 0	(input)
-vCpuId1			EQU			2						; CPU Identification bit 1	(input)
-vSync 			EQU 		3 						; Synchronous modem
-vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
-vCpuId2			EQU			4						; CPU Identification bit 2
+;(see below) vCpuId0			EQU			1						; CPU Identification bit 0	(input)
+;(see below) vCpuId1			EQU			2						; CPU Identification bit 1	(input)
+;(see below) vSync 			EQU 		3 						; Synchronous modem
+;(see below) vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+;(see below) vCpuId2			EQU			4						; CPU Identification bit 2
 vReqAEnable		EQU			4						; enable ReqA into vSCCWrReq (PSC only)		<LW2>
-vHeadSel  		EQU 		5 						; head select line for Sony
-vCpuId3			EQU			6						; CPU Identification bit 3
-vRev8Bd   		EQU 		6 						; =0 for rev 8 board>
+;(see below) vHeadSel  		EQU 		5 						; head select line for Sony
+;(see below) vCpuId3			EQU			6						; CPU Identification bit 3
+;(see below) vRev8Bd   		EQU 		6 						; =0 for rev 8 board>
 vReqBEnable		EQU			6						; enable ReqB into vSCCWrReq (PSC only)		<LW2>
-vSCCWrReq 		EQU 		7 						; SCC write/request line
+;(see below) vSCCWrReq 		EQU 		7 						; SCC write/request line
 
 ;---------------------------------------------------
 ; VIA1 Port B definitions
 ;---------------------------------------------------
 
 vEclipseLED		EQU			0						; flashable Eclipse LED (how quaint!)		<23>
-vRTCData  		EQU 		0 						; real time clock data
+;(see below) vRTCData  		EQU 		0 						; real time clock data
 vRMP0			EQU			0						; Reserved for RMP (PSC only)
-vENetIDClk		EQU			0						; Ethernet ID ROM clock	for Whitney			<SM19>
-vRTCClk   		EQU 		1 						; real time clock clock pulses
+;(see below) vRTCClk   		EQU 		1 						; real time clock clock pulses
 vRMP1			EQU			1						; Reserved for RMP (PSC only)
-vENetIDData   	EQU 		1 						; Ethernet ID ROM clock	for Whitney			<SM19>
-vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+;(see below) vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
 vRMP2			EQU			2						; Reserved for RMP (PSC only)
-vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+;(see below) vFDBInt   		EQU 		3 						; Front Desk bus interrupt
 vXcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
 vSDMCable		EQU			3						; SCSI DiskMode cable sense for Dartanian	<H15>
 vCudaTREQ		EQU			3						; Cuda transaction request input		<P2><SM4> rb
 vSDMDiskID		EQU			4						; DiskMode HD ID (bits 4-6) for Dartanian	<H15>
-vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+;(see below) vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
 vViafullbit		EQU			4						; Egret via full bit					<6>
 vCudaBYTEACK	EQU			4						; Cuda byte acknowledge output			<P2><SM4> rb
-vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+;(see below) vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
 vSyssesbit		EQU			5						; Egret system session bit				<6><SM4> rb
 vCudaTIP		EQU			5						; Cuda interface transaction in progress output <P2>
 vAUXIntEnb 		EQU 		6 						; switch to A/UX interrupt scheme (output)	<23>
-vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
+;(see below) vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
 vJMPDude6		EQU			6						; Reserved for JMP (PSC only)
-vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
-vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+;(see below) vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
+;(see below) vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
 vSWInt	  		EQU 		7 						; cause a software interrupt	(output)	<23>
 vJMPDude7		EQU			7						; Reserved for JMP (PSC only)
 
@@ -1138,9 +1171,7 @@ DAFB_CRB3			EQU			$3C				; vRAM Color Register, bank 3
 Swatch_BaseOffset	EQU			$100			; Swatch offset from DAFBBase
 Swatch_BaseOffset1	EQU			$124			; parameter offset
 Swatch_ParmSize1	EQU			$12				; size of Swatch parameter list
-; ••• This number is off by 2, we think.  BG/NJV
-; Swatch_NumRegs		Equ			30				; Number of Swatch registers.
-Swatch_NumRegs		Equ			28				; Number of Swatch registers.
+Swatch_NumRegs		Equ			30				; Number of Swatch registers.
 
 Swatch_Mode			EQU			$100			; Swatch general control
 Swatch_IntMsk		EQU			$104			; Swatch interrupt control
@@ -1188,7 +1219,6 @@ ACDC_ParmSize		EQU			$1				; size of ACDC parameter list
 ;----------
 
 Clk_BaseOffset		EQU			$300			; National offset from DAFBBase
-Clk_ChipIntOffset	EQU			$C0				; Clock Chip Interface offset from National offset from DAFBBase <H33>
 Clk_ParmSize		EQU			$10 			; size of National parameter list
 Clk_ParmSize1		Equ			$0A				; (Once programmed, the last six bytes are always the same.)
 
@@ -1217,44 +1247,6 @@ GSCDiag0			Equ		$1D						; Undocumented “diagnostic” registers.
 GSCDiag1			Equ		$1E
 GSCDiag2			Equ		$1F
 
-;----------
-; CSC register definitions (offsets from VDACAddr in ProductInfo) ($50F2 0000)					<H30> jmp
-;----------
-CSCDeviceID			Equ		$00						; Device revision register; read only.
-CSCPanelID			Equ		$02						; “Senseline” register; read only.
-CSCPanelIDControl	Equ		$04						; Extended senseline control.
-CSCPanelType		Equ		$06						; Controls mono/color, size, etc….
-CSCPanelSetup		Equ		$08						; Controls polarity, power, etc….
-CSCDataOutputForm	Equ		$0A						; Controls datapath output type.
-CSCFRCControl		Equ		$0C						; “DAC” control from CLUT for panel.
-CSCPolyMAdj			Equ		$0E						; M adjustment for FRC.
-CSCPolyNAdj			Equ		$10						; N adjustment for FRC.
-CSCDisplayDataForm	Equ		$12						; 1,2,4,8,16 bpp.
-CSCDisplayStatus	Equ		$14						; IFR,IER,blanking.
-CSCRefreshRate		Equ		$16						; Controls refresh cycles per scanline.
-CSCVRAMControl		Equ		$18						; Controls VRAM clocking.
-CSCHSkewHi			Equ		$1A						; Effectively, controls the horizontal
-CSCHSkewLo			Equ		$1C						;	timing.
-CSCACDClkHi			Equ		$1E						; Effectively, controls the dot-clock
-CSCACDClkLo			Equ		$20						; 	timing.
-CSCVSkewHi			Equ		$22						; Effectively, control the vertical
-CSCVSkewLo			Equ		$24						; 	timing.
-CSCMemConfig		Equ		$26						; Controls addressing for type of VRAM.
-CSCLPStart			Equ		$28						; Controls start of timing diagram.
-CSCLPWidth			Equ		$2A						; Controls width of timing diagram.
-CSCFLMControl		Equ		$2C						; What does this do?
-
-CSCFrstReg			Equ		CSCPanelType			; First CSC register we need to save/restore.
-CSCLastReg			Equ		CSCFLMControl+2			; Last  CSC register we need to save/restore.
-CSCNumRegs			Equ		((CSCLastReg-CSCFrstReg)/2) ; Total number of registers to save/restore.
-
-CSCGTweak			Equ		$3C						; For “tweaking” the gray-only panels.
-
-CSCAddrRegW			Equ		$40						; Sets the index of the NEXT Palette Write.
-CSCAddrRegR			Equ		$46						; Sets the index of the NEXT Palette Read.
-CSCDataReg			Equ		$42						; Accessed as an R-G-B tripple into the Palette.
-
-CSCMaskReg			Equ		$44						; Logically masks out video data; set to all $F's.
 
 ;----------
 ; Sonora register definitions (offsets from SonoraAddr in ProductInfo) ($50F0 0000)				<H4><H6>
@@ -1285,17 +1277,6 @@ SonoraSetClr	Equ			7						; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
 ;
 SonoraVBLIRQEn	Equ			6						; Enable/Disable built-in video VBL
 
-;----------
-; Additional register definitions implemented in the Ardbeg variation of the Sonora chip		<HK4><H31> thru next <H31>
-;----------
-
-ArdbegPwr		EQU			$00A					; Ardbeg chip Power Management register
-
-;----------
-; Power Management register bit definitions
-;----------
-ArdbegPwrSaver	EQU 		0						; 1=Monitor power saver mode enabled (monitor power is off) <H31>
-
 ;----------
 ; Ariel register definitions (offsets from VDACAddr in ProductInfo) ($50F2 4000)				<H6>
 ;----------
@@ -1304,33 +1285,7 @@ ArielDataReg	Equ			1						; Offset to r/w data register
 ArielConfigReg	Equ			2						; Offset to r/w control register
 ArielKeyReg		Equ			3						; Offset to r/w key color register
 
-;----------
-; FIFO Memory Definitions for Whitney/Hardrock machines
-;----------
-FIFOMEM_BASE	Equ			$50F24000				; Logical address assignment for base of FIFO's
-FIFO_0_OFFSET	Equ			(16*1024)
-FIFO_1_OFFSET	Equ			(32*1024)
-FIFO_2_OFFSET	Equ			(48*1024)
 
-;----------
-; Whitney register definitions <ged>
-;----------
-
-WhitneyPwrCtl	Equ			$50F96000				; Whitney power control register
-WhitneyRev		Equ			$50F96004				; Whitney revision register
-
-;----------
-; Whitney power register bit definitions 														<K4>
-;----------
-
-WhitneySCCclk	equ			7						; 1 = SCC pClk forced low
-WhitneyInt3En	equ			6						; 1 = MDM_IRQ_L causes level 3 interrupt
-WhitneySWIMclk	equ			5						; 1 = Swim clock forced low
-WhitneySWIMReset equ		4						; 0 = reset SWIM chip
-WhitneyKEYclk	equ			3						; 1 = KEY_C16 forced low
-WhitneySCCpwr	equ			2						; 1 = power off serial driver chip
-WhitneyEnetReset equ		1						; 0 = reset SONIC chip
-WhitneyEnetPwr	equ			0						; 1 = power off Sonic chip
 ;----------
 ; MMC register definitions (offsets from MMCAddr in ProductInfo) ($50F3 0400)				<P2><SM4> rb, start
 ;----------
@@ -1365,135 +1320,6 @@ MMC_ClockSelect	EQU			$48						; Endeavor Input Clock Select (NTSC/PAL) [M18].
 
 MMC_Bypass		EQU			$4C						; RGB or Composite bypass [M19].
 
-;----------
-; YMCA register definitions (offsets from YMCAAddr in ProductInfo) ($50F3 0400)			<SM16> fau, start
-;----------
-YMCABase		EQU			$50F30400				; Used in YMCASizeBank 'cause we ran out of registers.  <SM17>
-YMCAMaxSize		EQU			5						; Maximum value that can be programed into the size registers
-BankBdryRegSize	EQU			7						; Size in bits of the boundary registers
-BankSizeRegSize	EQU			3						; Size in bits of the size register
-
-YMCA_DRAMspeed0	EQU			$00						; DRAM timing register 0 [M0].
-YMCA_DRAMspeed1	EQU			$04						; DRAM timing register 1 [M1].
-
-YMCA_CPUspeed0	EQU			$08						; Clock speed 0 [M2].
-YMCA_CPUspeed1	EQU			$0C						; Clock speed 1 [M3].
-
-YMCA_ROMspeed0	EQU			$10						; ROM cycle time 0 [M4].
-YMCA_ROMspeed1	EQU			$14						; ROM cycle time 1 [M5].
-YMCA_ROMspeed2	EQU			$18						; ROM cycle time 2 [M6].
-
-YMCA_DSPspeed	EQU			$1C						; DSP clock speed [M7].
-
-YMCA_DRAMwidth0	EQU			$20						; DRAM width 0 [M8].
-YMCA_DRAMwidth1	EQU			$24						; DRAM width 1 [M9].
-YMCA_DRAMwidth2	EQU			$28						; DRAM width 2 [M10].
-YMCA_DRAMwidth3	EQU			$2C						; DRAM width 3 [M11].
-
-YMCA_EPROMmode	EQU			$30						; EPROM mode [M12].
-
-YMCA_040Mode	EQU			$34						; 040 Special Mode [M13].
-
-YMCA_CPUID0		EQU			$38						; CPU ID 0 [M14].
-YMCA_CPUID1		EQU			$3C						; CPU ID 1 [M15].
-YMCA_CPUID2		EQU			$40						; CPU ID 2 [M16].
-YMCA_CPUID3		EQU			$44						; CPU ID 3 [M17].
-
-YMCA__ClockSelect	EQU		$48						; Endeavor Input Clock Select [M18].
-YMCA_Bypass 		EQU		$4C						; Composite out or RGB [M19].
-
-YMCA_DRAMBank0_A20 EQU		$50						; DRAM Bank0 Addr A20 [M20].
-YMCA_DRAMBank0_A21 EQU		$54						; DRAM Bank0 Addr A21 [M21].
-YMCA_DRAMBank0_A22 EQU		$58						; DRAM Bank0 Addr A22 [M22].
-YMCA_DRAMBank0_A23 EQU		$5C						; DRAM Bank0 Addr A23 [M23].
-YMCA_DRAMBank0_A24 EQU		$60						; DRAM Bank0 Addr A24 [M24].
-YMCA_DRAMBank0_A25 EQU		$64						; DRAM Bank0 Addr A25 [M25].
-YMCA_DRAMBank0_A26 EQU		$68						; DRAM Bank0 Addr A26 [M26].
-YMCA_DRAMBank0_Sz0 EQU		$6C						; DRAM Bank0 Size 0   [M27].
-YMCA_DRAMBank0_Sz1 EQU		$70						; DRAM Bank0 Size 1   [M28].
-YMCA_DRAMBank0_Sz2 EQU		$74						; DRAM Bank0 Size 2   [M29].
-
-YMCA_DRAMBank1_A20 EQU		$78						; DRAM Bank1 Addr A20 [M30].
-YMCA_DRAMBank1_A21 EQU		$7C						; DRAM Bank1 Addr A21 [M31].
-YMCA_DRAMBank1_A22 EQU		$80						; DRAM Bank1 Addr A22 [M32].
-YMCA_DRAMBank1_A23 EQU		$84						; DRAM Bank1 Addr A23 [M33].
-YMCA_DRAMBank1_A24 EQU		$88						; DRAM Bank1 Addr A24 [M34].
-YMCA_DRAMBank1_A25 EQU		$8C						; DRAM Bank1 Addr A25 [M35].
-YMCA_DRAMBank1_A26 EQU		$90						; DRAM Bank1 Addr A26 [M36].
-YMCA_DRAMBank1_Sz0 EQU		$94						; DRAM Bank1 Size 0   [M37].
-YMCA_DRAMBank1_Sz1 EQU		$98						; DRAM Bank1 Size 1   [M38].
-YMCA_DRAMBank1_Sz2 EQU		$9C						; DRAM Bank1 Size 2   [M39].
-
-YMCA_DRAMBank2_A20 EQU		$A0						; DRAM Bank2 Addr A20 [M40].
-YMCA_DRAMBank2_A21 EQU		$A4						; DRAM Bank2 Addr A21 [M41].
-YMCA_DRAMBank2_A22 EQU		$A8						; DRAM Bank2 Addr A22 [M42].
-YMCA_DRAMBank2_A23 EQU		$AC						; DRAM Bank2 Addr A23 [M43].
-YMCA_DRAMBank2_A24 EQU		$B0						; DRAM Bank2 Addr A24 [M44].
-YMCA_DRAMBank2_A25 EQU		$B4						; DRAM Bank2 Addr A25 [M45].
-YMCA_DRAMBank2_A26 EQU		$B8						; DRAM Bank2 Addr A26 [M46].
-YMCA_DRAMBank2_Sz0 EQU		$BC						; DRAM Bank2 Size 0   [M47].
-YMCA_DRAMBank2_Sz1 EQU		$C0						; DRAM Bank2 Size 1   [M48].
-YMCA_DRAMBank2_Sz2 EQU		$C4						; DRAM Bank2 Size 2   [M49].
-
-YMCA_DRAMBank3_A20 EQU		$C8						; DRAM Bank3 Addr A20 [M50].
-YMCA_DRAMBank3_A21 EQU		$CC						; DRAM Bank3 Addr A21 [M51].
-YMCA_DRAMBank3_A22 EQU		$D0						; DRAM Bank3 Addr A22 [M52].
-YMCA_DRAMBank3_A23 EQU		$D4						; DRAM Bank3 Addr A23 [M53].
-YMCA_DRAMBank3_A24 EQU		$D8						; DRAM Bank3 Addr A24 [M54].
-YMCA_DRAMBank3_A25 EQU		$DC						; DRAM Bank3 Addr A25 [M55].
-YMCA_DRAMBank3_A26 EQU		$E0						; DRAM Bank3 Addr A26 [M56].
-YMCA_DRAMBank3_Sz0 EQU		$E4						; DRAM Bank3 Size 0   [M57].
-YMCA_DRAMBank3_Sz1 EQU		$E8						; DRAM Bank3 Size 1   [M58].
-YMCA_DRAMBank3_Sz2 EQU		$EC						; DRAM Bank3 Size 2   [M59].
-
-YMCA_DRAMBank4_A20 EQU		$F0						; DRAM Bank4 Addr A20 [M60].
-YMCA_DRAMBank4_A21 EQU		$F4						; DRAM Bank4 Addr A21 [M61].
-YMCA_DRAMBank4_A22 EQU		$F8						; DRAM Bank4 Addr A22 [M62].
-YMCA_DRAMBank4_A23 EQU		$FC						; DRAM Bank4 Addr A23 [M63].
-YMCA_DRAMBank4_A24 EQU		$100					; DRAM Bank4 Addr A24 [M64].
-YMCA_DRAMBank4_A25 EQU		$104					; DRAM Bank4 Addr A25 [M65].
-YMCA_DRAMBank4_A26 EQU		$108					; DRAM Bank4 Addr A26 [M66].
-YMCA_DRAMBank4_Sz0 EQU		$10C					; DRAM Bank4 Size 0   [M67].
-YMCA_DRAMBank4_Sz1 EQU		$110					; DRAM Bank4 Size 1   [M68].
-YMCA_DRAMBank4_Sz2 EQU		$114					; DRAM Bank4 Size 2   [M69].
-
-YMCA_DRAMBank5_A20 EQU		$118					; DRAM Bank5 Addr A20 [M70].
-YMCA_DRAMBank5_A21 EQU		$11C					; DRAM Bank5 Addr A21 [M71].
-YMCA_DRAMBank5_A22 EQU		$120					; DRAM Bank5 Addr A22 [M72].
-YMCA_DRAMBank5_A23 EQU		$124					; DRAM Bank5 Addr A23 [M73].
-YMCA_DRAMBank5_A24 EQU		$128					; DRAM Bank5 Addr A24 [M74].
-YMCA_DRAMBank5_A25 EQU		$12C					; DRAM Bank5 Addr A25 [M75].
-YMCA_DRAMBank5_A26 EQU		$130					; DRAM Bank5 Addr A26 [M76].
-YMCA_DRAMBank5_Sz0 EQU		$134					; DRAM Bank5 Size 0   [M77].
-YMCA_DRAMBank5_Sz1 EQU		$138					; DRAM Bank5 Size 1   [M78].
-YMCA_DRAMBank5_Sz2 EQU		$13C					; DRAM Bank5 Size 2   [M79].
-
-YMCA_DRAMBank6_A20 EQU		$140					; DRAM Bank6 Addr A20 [M80].
-YMCA_DRAMBank6_A21 EQU		$144					; DRAM Bank6 Addr A21 [M81].
-YMCA_DRAMBank6_A22 EQU		$148					; DRAM Bank6 Addr A22 [M82].
-YMCA_DRAMBank6_A23 EQU		$14C					; DRAM Bank6 Addr A23 [M83].
-YMCA_DRAMBank6_A24 EQU		$150					; DRAM Bank6 Addr A24 [M84].
-YMCA_DRAMBank6_A25 EQU		$154					; DRAM Bank6 Addr A25 [M85].
-YMCA_DRAMBank6_A26 EQU		$158					; DRAM Bank6 Addr A26 [M86].
-YMCA_DRAMBank6_Sz0 EQU		$15C					; DRAM Bank6 Size 0   [M87].
-YMCA_DRAMBank6_Sz1 EQU		$160					; DRAM Bank6 Size 1   [M88].
-YMCA_DRAMBank6_Sz2 EQU		$164					; DRAM Bank1 Size 2   [M89].
-
-YMCA_DRAMBank7_A20 EQU		$168					; DRAM Bank7 Addr A20 [M90].
-YMCA_DRAMBank7_A21 EQU		$16C					; DRAM Bank7 Addr A21 [M91].
-YMCA_DRAMBank7_A22 EQU		$170					; DRAM Bank7 Addr A22 [M92].
-YMCA_DRAMBank7_A23 EQU		$174					; DRAM Bank7 Addr A23 [M93].
-YMCA_DRAMBank7_A24 EQU		$178					; DRAM Bank7 Addr A24 [M94].
-YMCA_DRAMBank7_A25 EQU		$17C					; DRAM Bank7 Addr A25 [M95].
-YMCA_DRAMBank7_A26 EQU		$180					; DRAM Bank7 Addr A26 [M96].
-YMCA_DRAMBank7_Sz0 EQU		$184					; DRAM Bank7 Size 0   [M97].
-YMCA_DRAMBank7_Sz1 EQU		$188					; DRAM Bank7 Size 1   [M98].
-YMCA_DRAMBank7_Sz2 EQU		$18C					; DRAM Bank7 Size 2   [M99].
-
-YMCA_Test_Mode 		EQU		$190					; Enable Test Mode    [M100].
-YMCA_Refresh_Test   EQU		$194					; Refresh Test Mode   [M101].
-
-;													;											<SM16> fau, end
 ;----------
 ; MUNI (NuBus) register definitions																<P6>
 ;----------
@@ -1633,7 +1459,7 @@ MSCFlashWrEnb	EQU			$23						; flash ROM write enable
 MSCPowerCycle	EQU			$50FA0000-$50F26000		; CPU power off control register			<H2>
 
 ;  ======  VIA2 BufferB Equivalent		Address: $50F26000	 =====
-MSCEnableFPU	EQU			0						; 0 = enable on-board floating point processor	<H29>
+MSCExpansion	EQU			0						; 0 = enable on-board external cache (not currently used)
 ;v2PMack		EQU 		1 						; Power manager handshake acknowledge
 ;v2PMreq		EQU 		2 						; Power manager handshake request
 ;reserved3		EQU			3						; reserved
@@ -1722,84 +1548,6 @@ MSCDefConfig	EQU			(1<<MSC25MHz)|\			; 25MHz system								<H9>
 							(%000<<MSCSize0)		; set 2MB so there's real RAM for BootBeep	<H10>
 
 
-BIOSAddr		EQU			$50F18000				; verified by hasBIOSAddr in ExtValid		<H26><SM18>
-
-BIOS_Config		EQU			0						; contains bit 0:  0 = BCLK ≥ 33MHz			<H26>
-													;                  1 = BCLK ≤ 25MHz			<H26>
-BIOS_SONIC_SCSI	EQU			$200					; contains SONIC and SCSI parameters		<H26>
-BIOSSCSIFilter	EQU			$40						; bit 6 = SONIC stuff, all the rest are SCSI<H31>
-													; (bit 7 in BIOS is undefined)				<H31>
-BIOScfg20MHz	EQU			$1B						; 3-clk PDMA Write and Read 				<H27><SM18>
-BIOScfg25MHz	EQU			$3F						; 3-clk PDMA Write and Read/DRQCHK on		<H27><SM18>
-BIOScfg33MHz	EQU			$12						; 4-clk PDMA Write and Read 				<H27><SM18>
-BIOScfg40MHz	EQU			$00						; 5-clk PDMA Write and Read					<H27><SM18>
-
-BIOS_REVISION	EQU			$300					; bits 5:7 is BIOS revision number			<H26>
-bBIOSW1Cmplt	EQU			$2						; bit positions...			 				<H27>
-bBIOSR1Cmplt	EQU			$1						;					 						<H27>
-bBIOSSCSIBERR	EQU			$0						;						 					<H27>
-
-BIOS_PDMA		EQU			$300					; bits 0:2 are Pseudo-DMA control bits		<H26>
-BIOS_SCSI_RESID	EQU			$400					; bits 0:16 are latched SCSI data			<H26>
-BIOS_BRIGHTNESS	EQU			$500					; 8 bits of 0-$FF brightness				<H31>
-BIOS_CONTRAST	EQU			$501					; 8 bits of 0-$FF contrast					<H31>
-BIOS_Timeout	EQU			$600					; bits 0:11 are watchdog timer timeout cntr	<H26>
-
-BIOS_Config2	EQU			$100					; for Primus/Optimus bios					<H35>
-bBIOSBR30116BIT	EQU			$0						; bit positions...							<H35>
-bBIOSIOCSTime	EQU			$1						;											<H35>
-bBIOSENETIRQLVL	EQU			$2						;											<H35>
-
-;__________________________________________________________________________________________		<SM23> SAM
-;	AMIC (Apple Memory mapped I/O Controller) Creative name huh? Equates
-;	First used on PDM/Cold Fusion
-;__________________________________________________________________________________________
-
-AMICBase		EQU			$50F30000				; AMIC base
-AMICDMABase		EQU			$50F31000				; DMA Buffer Base Address (256k alignment)
-AMICSCSIDMABase	EQU			$0000					; SCSI DMA Buffer Base Address [scsi has its own buffer] (8 byte alignment)
-
-AMICSCSICntrl	EQU			$1008					; SCSI DMA control register
-
-AMICEnetTxCntrl	EQU			$0C20					; Ethernet transmit DMA control register
-AMICEnetRxCntrl	EQU			$1028					; Ethernet receive DMA control register
-
-AMICFloppyCntrl	EQU			$1068					; Floppy DMA control register
-
-AMICSCCTxACntrl	EQU			$1088					; SCC port A transmit DMA control register
-AMICSCCRxACntrl	EQU			$1098					; SCC port A receive DMA control register
-
-AMICSCCTxBCntrl	EQU			$10A8					; SCC port B transmit DMA control register
-AMICSCCRxBCntrl	EQU			$10B8					; SCC port B receive DMA control register
-
-AMICIrqBase		EQU			$50F2A000				; AMIC's interrupt register base
-AMICIrqFlags	EQU			$0000					; Interrupt source register
-AMICDMAFlags0	EQU			$0008					; DMA interrupt source register
-AMICDMAFlags1	EQU			$000A					; DMA interrupt source register
-
-PDMrbvSize 		EQU			768*1024				; 768k for RBV							<SM24>
-PDMDMAbufSize	EQU			160*1024				; 160k for the DMA buffer
-PDMDMAlogAddr	EQU			$61000000				; Logical address of the DMA buffer
-
-;__________________________________________________________________________________________
-;	BART (PDM/Cold Fusion NuBus Controller) Equates
-;	First used on PDM/Cold Fusion
-;__________________________________________________________________________________________
-BARTBase		EQU			$F0000000				; BART Register Base
-
-BARTResetReg	EQU			$F0000000				; bit zero of this register will reset NuBus
-BARTResetBit	EQU			$0
-
-BARTSlowReg		EQU			$F0000001				; Setting bit 8 will add wait states
-BARTSlowBit		EQU			$8
-
-BARTOffSltE		EQU			$F0000011				; Setting bit 8 will cause slot E to be disabled (for Cold Fusion)
-BARTOFFBit		EQU			$8
-
-BARTBurstReg	EQU			$80						; Offset from base to slot zero burst reg (not actually used directly)
-BARTBurstRegOff	EQU			$08						; Offset from Busrt Reg to next slot Reg ($80, $78, $70, $68 ... $10)
-BARTBurstBit	EQU			$8
-
 
 ;__________________________________________________________________________________________
 ;
@@ -1992,56 +1740,6 @@ NiagraFlashEnbl	EQU			$30000					; Enable flash from Niagra
 NiagraFPUAcc	EQU			$34000					; FPU access detected
 NiagraSpeedReg	EQU			$36000					; Returns the CPU clock frequency
 
-;---------------------------------------------------
-; Pratt Memory Controller Equates
-;---------------------------------------------------
-
-PrattChipID		EQU			$5ffffff8				; Pratt ID register address (chip version)		CSR0
-PrattSysStat	EQU			$0007					; CPU speed	register offset						CSR1								
-PrattROMSpeed	EQU			$000B					; ROM speed register offset						CSR2
-PrattRAMDensity	EQU			$000F					; RAM density register offset					CSR3
-PrattRAMConfig	EQU			$0013					; RAM configuration register offset				CSR4
-PrattRefresh	EQU			$0017					; RAM refresh register offset					CSR5
-PrattNapReg		EQU			$001B					; PowerCycling enable register offset			CSR6
-PrattVersion	EQU			$001F					; Unused register offset (always reads zero)	CSR7
-
-													;CSR1 System Status Register
-Pratt16MHzCPU	EQU			%00000000				; CPU speed reg config values (bits 0:1)
-Pratt20MHzCPU	EQU			%00000001				; 
-Pratt25MHzCPU	EQU			%00000010				; 
-Pratt33MHzCPU	EQU			%00000011				;
-PrattFlashLBit	EQU			2						; bit position for Flash detection (0 = Flash is present)
-PrattROMBit		EQU			3						; bit position for ROM boot (1 = ROM in system)
-
-Pratt250nsROM	EQU			%00000000				;CSR2 ROM speed reg config values
-Pratt200nsROM	EQU			%00000001				;
-Pratt150nsROM	EQU			%00000010				;
-Pratt120nsROM	EQU			%00000011				;
-
-													;CSR3/4 RAM sizing bit definitions
-PrattDensBits	EQU			%00001111				; bit mask showing active density config bits
-PrattBankBits	EQU			%00111111				; bit mask showing active bank occupancy bits
-PrattDefDensity	EQU			%00000111				; Default RAM Density value for Pratt (all 8MB banks)
-PrattDefConfig	EQU			%00111111				; Default RAM Bank Configuration for Pratt (all banks occupied)		
-PrattNumbanks	EQU			6						; Total number of RAM banks, onboard plus expansion
-
-Pratt0MBbank	EQU			%11111100				; Onboard RAM bank bit masks 
-Pratt2MBbank	EQU			%11111110
-Pratt4MBbank	EQU			%11111101
-Pratt8MBbank	EQU			%11111111
-
-Pratt0MBExBank	EQU			%11110011				; Expansion RAM bank bit masks
-Pratt2MBExBank	EQU			%11110011
-Pratt4MBExBank	EQU			%11111011
-Pratt8MBExBank	EQU			%11110111
-
-													;CSR5 Test Control Bits
-PrattFreqRfsh	EQU			0						; Pratt frequent refresh control bit
-PrattDBRfshOnly	EQU			1						; Do daughterboard refresh only bit
-PrattShortRamp	EQU			2						; Do short power rampup bit
-
-PrattPwrCyclBit	EQU			0						;CSR6 Power Cycling bit (= 1 to power cycle) 
-
 ;---------------------------------------------------								<SM4> rb, start
 ; Ponti Register Equates  (NiagraGUR register space + offset
 ;---------------------------------------------------
@@ -2073,109 +1771,7 @@ PontiLmpHWCtl		EQU			1				; (1 = Hardware control) 	- if set, hardware control l
 PontiLmpMux0		EQU			2				; (1 = 1/2 pot) 			- 1/2 scale pot reduction
 PontiLmpMux1		EQU			3				; (1 = 1/4 pot) 			- 1/4 scale pot reduction
 PontiLmpSPIDir		EQU			4				; (1 = shift out) 			- direction of shift register
-
-;---------------------------------------------------								<K9> HJR
-; HardRock Register Equates
-;---------------------------------------------------
-HardRockSlotBase	EQU			$FB000000
-
-HardRockCodecICR	EQU			HardRockSlotBase + $1020
-HardRockCodecSRCR	EQU			HardRockSlotBase + $1024
-HardRockCodecEnReg	EQU			HardRockSlotBase + $1028
-HardRockCodecOutAtt	EQU			HardRockSlotBase + $1030
-HardRockCodecInGain	EQU			HardRockSlotBase + $1034
-
-HardRockFifoBase	EQU			HardRockSlotBase + $2000
-HardRockFifoControl	EQU			HardRockSlotBase + $2000 +4
-
-HRChan_run12		EQU			12				; 1 = enable channel 12
-HRChan_run9			EQU			9				; 1 = enable channel 9
-HRChan_run7			EQU			7				; 1 = enable channel 7
-HRChan_run6			EQU			6				; 1 = enable channel 6
-HRChan_run5			EQU			5				; 1 = enable channel 5
-HRChan_run4			EQU			4				; 1 = enable channel 4
-HRChan_run3			EQU			3				; 1 = enable channel 3
-HRChan_run2			EQU			2				; 1 = enable channel 2
-HRChan_run1			EQU			1				; 1 = enable channel 1
-HRSPI_Voice_Sel		EQU			0				; 1 = Voice DMA data goes through SPI Interface
-												; 0 = Voice DMA data goes through CODEC Interface
-
-HardRockFifoCTL0	EQU			HardRockFifoBase + $10
-HardRockFifoCTL1	EQU			HardRockFifoBase + $20
-HardRockFifoCTL2	EQU			HardRockFifoBase + $30
-
-HardRockFifoBase0	EQU			HardRockFifoBase + $1C
-HardRockFifoBase1	EQU			HardRockFifoBase + $2C
-HardRockFifoBase2	EQU			HardRockFifoBase + $3C
-
-HardRockFifoRec		RECORD		0,Increment		; 
-HRFifoConfig		DS.W		1				; 0
-HRFifoInt			DS.W		1				; 2
-HRFifoReserved		DS.W		2				; 4
-HRFifoReadptr		DS.W		1				; 8
-HRFifoWriteptr		DS.W		1				; A
-HRFifoBase			DS.L		1				; C
-HRFiforecSize		EQU			*-HardRockFifoRec
-					ENDR
-
-HRFifoConfig64b		EQU			6				; Fifo config size of 64 bytes	
-HRFifoConfig128b	EQU			7				; Fifo config size of 128 bytes	
-HRFifoConfig256b	EQU			8				; Fifo config size of 256 bytes	
-HRFifoConfig512b	EQU			9				; Fifo config size of 512 bytes	
-HRFifoConfig1k		EQU			10				; Fifo config size of 1 kbytes	
-HRFifoConfig2k		EQU			11				; Fifo config size of 2 kbytes	
-HRFifoConfig4k		EQU			12				; Fifo config size of 4 kbytes	
-HRFifoConfig8k		EQU			13				; Fifo config size of 8 kbytes	
-
-HRFifoConfigVal		EQU			HRFifoConfig1k	; Currently set Fifo size to 1k
-HRFifoSz			EQU			$400			; $400 = #1024 = 1k
-HRFifoWrapVal		EQU			HRFifoSz-1
-
-HardRockFifoIntMsk0	EQU			HardRockFifoBase + $12
-HardRockFifoIntMsk1	EQU			HardRockFifoBase + $22
-HardRockFifoIntMsk2	EQU			HardRockFifoBase + $32
-
-HRIntMask			EQU			0				; 1 = interrupt masked, 0 = interrupt enabled
-
-HardRockReadIntRec	RECORD		0,Increment		; 
-HRIntFlags			DS.B		1
-HRRcvFlags			DS.B		1
-HRDataCount			DS.W		1
-					ENDR
-
-HardRockModemPwrReg	EQU			HardRockSlotBase + $20
-HardRockModemRstClr	EQU			2				; 0 = deassertion of CHIQUITA_RESET_L is high level
-												; 1 = deassertion of CHIQUITA_RESET_L is tristate level
-HardRockModem_RST	EQU			1				; 0 = assert CHIQUITA_RESET_L
-HardRockModem_PWR	EQU			0				; 1 = Enable power to modem
-
-HardRockModem_base	EQU			HardRockSlotBase + $4000
-
-HardRockSPIMdmCtl	EQU			$000
-HardRockSPIAck		EQU			2				; (1 = ack idle)
-HardRockSPIReq		EQU			3				; (1 = req idle)
-
-HardRockSndCtl		EQU			$400
-HardRockSndSPIIrqMsk EQU		0				; (1 = mask int)
-
-HardRockSPISftReg	EQU			$800
-
-HardRockLmpSftCtl	EQU			$C00
-HardRockLmpSPIDir	EQU			4				; (1 = shift out) 			- direction of shift register
-
-ModemExtCmdRec	RECORD			0,Increment		; 
-modemcmdsel		ds.b			1
-modemdata		ds.b			1
-				endr
-
-WriteFifoRect	RECORD			0,Increment		; 
-writeflags		ds.b			1
-writecnthi		ds.b			1
-writecntlo		ds.b			1
-writepad		ds.b			1				;															<K9>
-				endr
-
-
+												;									<SM4> rb, end
 ;-------------------------------------																		<H21> thru next <H21>
 ;	djMEMC memory controller equates
 ;-------------------------------------
@@ -2185,20 +1781,6 @@ writepad		ds.b			1				;															<K9>
 
 MEMCAddr			EQU		$50F0E000				; same for both Wombat + WLCD memory maps
 
-;	djMEMC-specific CPU_ID bit values
-
-djVIA_CPU_TYPE_MASK	EQU		%01000010				; PA6, PA1 = CPU type bits								<SM18>
-djCPU_TYPE_VAIL040	EQU		%00000000				; Vail 040   = 00										<SM18>
-djCPU_TYPE_FRIDGE	EQU		%00000010				; Frigidaire = 01										<SM18>
-djCPU_TYPE_WLCD		EQU		%01000000				; WLCD       = 10										<SM18>
-djCPU_TYPE_LEGO		EQU		%01000010				; Lego       = 11										<SM18>
-
-djVIA_CPU_SPEED_MASK EQU	%00010100				; PA4, PA2 = CPU speed bits								<SM18>
-djCPU_SPEED_20MHZ	EQU		%00000000				; 20MHz      = 00										<SM18>
-djCPU_SPEED_25MHZ	EQU		%00000100				; 25MHz      = 01										<SM18>
-djCPU_SPEED_33MHZ	EQU		%00010000				; 33MHz      = 10										<SM18>
-djCPU_SPEED_40MHZ	EQU		%00010100				; 40MHz      = 11										<SM18>
-
 MEMCRegisterStart	EQU		0
 MEMCIntleaveEnable	EQU		MEMCRegisterStart		; DRAM interleave enable reg.
 dj_OneBufferedBusBit EQU	5
@@ -2235,31 +1817,31 @@ MEMCRefresh			EQU		MEMCconfig+4			; DRAM refresh rate register
 ; Interrupt Masks
 ;---------------------------------------------------
 
-hiIntMask 		EQU 		$0700					; programmer switch only
-pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
-sccIntMask		EQU 		$0400					; SCC interrupt level
-sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
-slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
-viaIntMask		EQU 		$0100					; VIA1 interrupt level
-loIntMask 		EQU 		$0100
+;(see below) hiIntMask 		EQU 		$0700					; programmer switch only
+;(see below) pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
+;(see below) sccIntMask		EQU 		$0400					; SCC interrupt level
+;(see below) sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
+;(see below) slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
+;(see below) viaIntMask		EQU 		$0100					; VIA1 interrupt level
+;(see below) loIntMask 		EQU 		$0100
 
 
 ;---------------------------------------------------
 ; Hardware Base Addresses
 ;---------------------------------------------------
 
-WrOffs			EQU			0						; SCSI write addrs are same as read base
-MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
-MskVIA1			EQU			1						; VIA 1 is level 1
-MskADB			EQU			1						; ADB is level 1
-Msk60Hz			EQU			1						; 60 Hz is level 1
-MskSCSI			EQU			2						; SCSI is level 2
-MskSound		EQU			2						; sound is level 2						<4.5>
-MskSlots		EQU			2						; slots are level 2 interrupts
-MskRTC			EQU			3						; RTC is level 3
-MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
-MskPwrOff		EQU			6						; Poweroff button is level 6
-MskNMI			EQU			7						; NMI switch is level 7
+;(see below) WrOffs			EQU			0						; SCSI write addrs are same as read base
+;(see below) MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
+;(see below) MskVIA1			EQU			1						; VIA 1 is level 1
+;(see below) MskADB			EQU			1						; ADB is level 1
+;(see below) Msk60Hz			EQU			1						; 60 Hz is level 1
+;(see below) MskSCSI			EQU			2						; SCSI is level 2
+;(see below) MskSound		EQU			2						; sound is level 2						<4.5>
+;(see below) MskSlots		EQU			2						; slots are level 2 interrupts
+;(see below) MskRTC			EQU			3						; RTC is level 3
+;(see below) MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
+;(see below) MskPwrOff		EQU			6						; Poweroff button is level 6
+;(see below) MskNMI			EQU			7						; NMI switch is level 7
 
 
 ; ---------------------------------------------------------------------------------------------------	<T8>
@@ -2336,32 +1918,32 @@ CACR_WA_030				EQU		13				; bit # of write allocate enable on 030s				<T8>
 
 
 
-Machine   		EQU 		7						; new Machine number for patches			<18>
+;(see below) Machine   		EQU 		7						; new Machine number for patches			<18>
 
 ;---------------------------------------------------
 ; System Software Information
 ;---------------------------------------------------
 
-numOsTrap 		EQU 		256   					; number of os traps
-ToolTable 		EQU 		$0E00 					; start of toolbox trap table
-numTbTrap 		EQU 		1024   					; number of toolbox traps
-numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
+;(see below) numOsTrap 		EQU 		256   					; number of os traps
+;(see below) ToolTable 		EQU 		$0E00 					; start of toolbox trap table
+;(see below) numTbTrap 		EQU 		1024   					; number of toolbox traps
+;(see below) numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
 JMemMgr24		EQU			$1E00					; jump vector start for 24 bit Memory Manager 		<v1.9>
 JMemMgr32		EQU			$1F00					; jump vector start for 32 bit Memory Manager 		<v1.9>
-HeapStart 		EQU 		$2800 					; Low mem is now 10k bytes							<SM13>
-defSysHeap		EQU 		$18000    				; Default size of the system heap
-nDfltStackSize	EQU 		$6000 					; Default stack size
+;(see below) HeapStart 		EQU 		$2800 					; Low mem is now 10k bytes							<SM13>
+;(see below) defSysHeap		EQU 		$18000    				; Default size of the system heap
+;(see below) nDfltStackSize	EQU 		$6000 					; Default stack size
 
 **** maybe not so temporary to allow things to build ****									<3.5>
-oneSecConst   	EQU 		8 						; gets converted to $80000 for onesec constant<3.5>
+;(see below) oneSecConst   	EQU 		8 						; gets converted to $80000 for onesec constant<3.5>
 	IF BlackBirdDebug THEN
-ROMStart  		EQU 		$40000000 				; ••PN BlackBirdstarting address of final ROM code	<3.5>
+;(see below) ROMStart  		EQU 		$40000000 				; ••PN BlackBirdstarting address of final ROM code	<3.5>
 	ELSE
-ROMStart  		EQU 		$40800000 				; starting address of final ROM code	<3.5>
+;(see below) ROMStart  		EQU 		$40800000 				; starting address of final ROM code	<3.5>
 	ENDIF
-snd2MemTop		EQU 		$300  					; SoundLow to Memtop
-pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
-bufWorldSize  	EQU 		8192		   			; total size of the BufPtr world		<H16>
+;(see below) snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+;(see below) pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+;(see below) bufWorldSize  	EQU 		8192		   			; total size of the BufPtr world		<H16>
 
 ;---------------------------------------------------								<SM4> rb, start
 ;  Sound parameters																			<P4>
@@ -2370,146 +1952,6 @@ sampleSize		equ			4				; number of bytes per sample
 bufferSize		equ			960				; number of samples per buffer
 sampleRate		equ			24 * 1024		; 24KHz sample rate
 
-;---------------------------------------------------------------------
-;  Whitney Sound Register Offsets (from ASC base in UniversalTables.a)
-;---------------------------------------------------------------------
-wSndInABWritePtr	equ			$f54		; [word] A/B input FIFO write pointer (alias at $f04)
-wSndInAReadPtr		equ			$f52		; [word] A input FIFO read pointer
-wSndInBReadPtr		equ			$f56		; [word] B input FIFO read pointer
-
-wSndOutAWritePtr	equ			$f58		; [word] A output FIFO write pointer
-wSndOutBWritePtr	equ			$f5c		; [word] B output FIFO write pointer
-wSndOutABReadPtr	equ			$f5a		; [word] A/B output FIFO read pointer (alias at $f26)
-
-wSndControl			equ			$f40		; [byte] configures Singer power/FIFO size/sample rate, etc.
-wSndFIFOBase		equ			$f44		; [long] physical base address of FIFO
-wSndFIFOBaseHi		equ			$f44		; [word] high order (physical) word of FIFO base address in RAM
-wSndFIFOBaseLo		equ			$f46		; [word] low order word of FIFO base address in RAM
-
-wSndAData			equ			$1000		; [word] 16-bit sound in/out data for left channel
-wSndBData			equ			$1800		; [word] 16-bit sound in/out data for right channel
-
-wSndSingerCtl1		equ			$f48		; [word] Singer mute/input select/gain control
-wSndSingerCtl2		equ			$f4a		; [word] Singer attenuation/digital out control
-wSndSingerStat1		equ			$f4c		; [word] Singer valid/clipping/error/rev status
-wSndSingerStat2		equ			$f4e		; [word] Singer digital input status
-
-;---------------------------------------------------
-;  Whitney Sound Register Bit Definitions
-;---------------------------------------------------
-
-; === sndControl register ===
-wSampleRateMsk	equ			$03				; Mask for sample rate bits
-wFIFOSizeMsk	equ			$0C				; Mask for FIFO size bits
-
-wSampleRate		equ			0				; Sample rate field for Singer Serial Clock (2 bits)
-wSampleRate1	equ			0				;  lsbit
-wSampleRate2	equ			1				;  msbit
-
-wFIFOSize		equ			2				; FIFO size (2 bits)
-wFIFOSize1		equ			2				;  lsbit
-wFIFOSize2		equ			3				;  msbit
-
-wSingerClk		equ			4				; Singer master clock enable
-wSingerPower	equ			5				; Singer power enable
-wSingerSNDFlag	equ			6				; Singer sound flag
-;				equ			7				; unused
-
-; === sndSingerCtl1 register ===
-wRGainMsk		equ			$000F			; Mask for right channel input gain
-wLGainMsk		equ			$00F0			; Mask for left channel input gain
-wRGain			equ			0				; Singer right input A/D gain (4 bits)
-wRGain1			equ			0				;  lsb
-wRGain2			equ			1
-wRGain3			equ			2
-wRGain4			equ			3				;  msb
-
-wLGain			equ			4				; Singer left input A/D gain (4 bits)
-wLGain1			equ			4				;  lsb
-wLGain2			equ			5
-wLGain3			equ			6
-wLGain4			equ			7				;  msb
-
-wInSelRight		equ			8				; Input select for right channel
-wInSelLeft		equ			9				; Input select for left channel
-
-wMute			equ			10				; Mute enable
-
-wWordAOut		equ			11				; Word A Out 17:21 (5 bits) - 0's, see Singer spec
-;				equ			12
-;				equ			13
-;				equ			14
-;				equ			15
-
-; === sndSingerCtl2 register ===
-wDigOut			equ			0				; Singer digital output (4 bits)
-wDigOut4		equ			0				;  output 4
-wDigOut3		equ			1				;  output 3
-wDigOut2		equ			2				;  output 2
-wDigOut1		equ			3				;  output 1
-
-wRAtten			equ			4				; Singer right D/A attenuation (4 bits)
-wRAtten1		equ			4				;  lsb
-wRAtten2		equ			5
-wRAtten3		equ			6
-wRAtten4		equ			7				;  msb
-
-wLAtten			equ			8				; Singer left D/A attenuation (4 bits)
-wLAtten1		equ			8				;  lsb
-wLAtten2		equ			9
-wLAtten3		equ			10
-wLAtten4		equ			11				;  msb
-
-
-wWordBOut		equ			12				; Word B Out 49:52 (5 bits) - 0's in SM1, see Singer spec
-;				equ			13
-;				equ			14
-;				equ			15
-
-; === sndSingerStat1 register ===
-wRev			equ			0				; Singer revision number (4 bits)
-wRev1			equ			0				;  lsb
-wRev2			equ			1
-wRev3			equ			2
-wRev4			equ			3				;  msb
-
-wErr			equ			4				; Singer error code (4 bits)
-wErr1			equ			4				;  lsb
-wErr2			equ			5
-wErr3			equ			6
-wErr4			equ			7				;  msb
-
-wRClip			equ			8				; Right clipping indicator
-wLClip			equ			9				; Left clipping indicator
-
-wADValid		equ			10				; A/D valid data indicator
-
-wWordAIn		equ			11				; Word A In 17:21 (5 bits), see Singer spec
-;				equ			12
-;				equ			13
-;				equ			14
-;				equ			15
-
-; === sndSingerStat2 register ===
-wDigIn			equ			0				; Singer digital input (4 bits)
-wDigIn4			equ			0				;  input 4
-wDigIn3			equ			1				;  input 3
-wDigIn2			equ			2				;  input 2
-wDigIn1			equ			3				;  input 1
-
-wWordBIn		equ			4				; Word B In 49:60 (12 bits), see Singer spec
-;				equ			5
-;				equ			6
-;				equ			7
-;				equ			8
-;				equ			9
-;				equ			10
-;				equ			11
-;				equ			12
-;				equ			13
-;				equ			14
-;				equ			15
-
 ;---------------------------------------------------
 ;  PSC Hardware Defs
 ;---------------------------------------------------
@@ -2718,7 +2160,7 @@ pdspSet			equ			7				; "0" clears, "1" sets for any bit field [0:6] containing a
 ; ???
 ;---------------------------------------------------
 
-seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+;seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
 
 ;---------------------------------------------------
 ; Hardware configuration bits.
@@ -2778,30 +2220,30 @@ dsRectLen 		EQU 		(DSrectBR**$FFFF)-(DSrectTL**$FFFF)
 ; System Error Equates
 ;---------------------------------------------------
 
-seVars			EQU 		seRegs        			; start of system error data space (wrap city)
-seVSize   		EQU 		128       				; # of bytes in space
-seD0  			EQU 		seVars        			; loc of saved reg D0
-seA0  			EQU 		seD0+32       			; loc of saved reg A0
-seA7  			EQU 		seA0+28       			; loc of saved reg A7
-sePC  			EQU 		seA7+4        			; loc of saved PC
-seSR  			EQU 		sePC+4        			; loc of saved SR
-seAccess  		EQU 		seSR+2        			; PC address during bus/address error
-seCmdSize 		EQU 		seAccess+4    			; # of bytes of parameters passed in _debugger call
-se000BE   		EQU 		seCmdSize+2       		; 8 bytes of bus error info for 68000
-seLastVar 		EQU 		se000BE+8     			; last var in System Error data space
+;seVars			EQU 		seRegs        			; start of system error data space (wrap city)
+;seVSize   		EQU 		128       				; # of bytes in space
+;seD0  			EQU 		seVars        			; loc of saved reg D0
+;seA0  			EQU 		seD0+32       			; loc of saved reg A0
+;seA7  			EQU 		seA0+28       			; loc of saved reg A7
+;sePC  			EQU 		seA7+4        			; loc of saved PC
+;seSR  			EQU 		sePC+4        			; loc of saved SR
+;seAccess  		EQU 		seSR+2        			; PC address during bus/address error
+;seCmdSize 		EQU 		seAccess+4    			; # of bytes of parameters passed in _debugger call
+;se000BE   		EQU 		seCmdSize+2       		; 8 bytes of bus error info for 68000
+;seLastVar 		EQU 		se000BE+8     			; last var in System Error data space
 
 
 ;---------------------------------------------------
 ; ROM based debugger nub
 ;---------------------------------------------------
 
-rdPort			EQU 		seLastVar     			; Number of port currently in use (0 => no link, 1 => A, 2 => B)
-rdCode			EQU 		rdPort+2      			; Ptr to code download buffer.
-rdAtrap   		EQU 		rdCode+4      			; Saved Rom Atrap handler
-rdLowTrap 		EQU 		rdAtrap+4     			; low value for trap handling
-rdHiTrap  		EQU 		rdLowTrap+2       		; high value for trap handling
-rdResult  		EQU 		rdHiTrap+2    			; result of executing down-loaded code, etc. (16 bytes)
-rdEnd 			EQU 		rdResult+16       		; end of vars
+;rdPort			EQU 		seLastVar     			; Number of port currently in use (0 => no link, 1 => A, 2 => B)
+;rdCode			EQU 		rdPort+2      			; Ptr to code download buffer.
+;rdAtrap   		EQU 		rdCode+4      			; Saved Rom Atrap handler
+;rdLowTrap 		EQU 		rdAtrap+4     			; low value for trap handling
+;rdHiTrap  		EQU 		rdLowTrap+2       		; high value for trap handling
+;rdResult  		EQU 		rdHiTrap+2    			; result of executing down-loaded code, etc. (16 bytes)
+;rdEnd 			EQU 		rdResult+16       		; end of vars
 
 
 ;---------------------------------------------------
@@ -2811,10 +2253,10 @@ rdEnd 			EQU 		rdResult+16       		; end of vars
 ; NOTE: Keep mbDotAddr immediately before mBlocAddr
 
 mbBufSize 		EQU 		34
-mbBuffer  		EQU 		seLastVar     			; buffer for input
-mbSign			EQU 		mbBuffer+mbBufSize    	; ST => negative sign during conversion
-mbDotAddr 		EQU 		mbSign+2      			; saved address
-mBlocAddr 		EQU 		mbDotAddr+4       		; saved location
+;mbBuffer  		EQU 		seLastVar     			; buffer for input
+;mbSign			EQU 		mbBuffer+mbBufSize    	; ST => negative sign during conversion
+;mbDotAddr 		EQU 		mbSign+2      			; saved address
+;mBlocAddr 		EQU 		mbDotAddr+4       		; saved location
 
 
 ;---------------------------------------------------
@@ -2873,9 +2315,6 @@ CheckSum1			DS.L		1					; $0034 checksum 1
 CheckSum2			DS.L		1					; $0038 checksum 2
 CheckSum3			DS.L		1					; $003C checksum 3
 RomSize				DS.L		1					; $0040 HiRam stuffs size of ROM in bytes here
-EraseIconOff		DS.L		1					; $0044 Offset to code to ease the Happy Mac icon
-InitSys7ToolboxOff	DS.L		1					; $0048 Offset to System 7.0 toolbox init code
-SubVers				DS.L		1					; $004C Yet another subversion (sigh)
 				ENDR
 
 
@@ -2888,60 +2327,9 @@ locValid2		EQU			6						; this must be 0
 inEmulatorBit	EQU			1						; running in emulator
 inRamBit		EQU			0						; running in ram
 
-;----------
-; TestInRam Macro																	<4.4>
-;
-; This macro tests the RomLoc byte in the ROM header to determine the ROM is located
-; in RAM.
-;----------
-			MACRO
-				TestInRam	&reg
-			    lea		@testInRamData,&reg
-				move.w	#$1,(&reg)					; write to "ROM"
-				tst.w	@testInRamData				; did it stick?
-				bra.s	@testDone
-@testInRamData	dc.w	0
-@testDone
-			ENDM
 
-;----------
-; WhitneyRevAtLeast Macro
-;	Sets the Z bit in the CCR if Whitney revision is greater or equal to &rev parameter passed in
-;	 else clears the Z bit
-; NOTE: This macro no longer supports the original rev Whitney b/c the hack used will interfere with
-;		modem operation.
-;----------
-			MACRO
-				WhitneyRevAtLeast	&rev
-				cmpi.b	#&rev,WhitneyRev
-				bmi.s	@older
-				ori		#$04,CCR				;set the Z bit
-				bra.s	@exit
-@older			andi	#$FB,CCR				;clear the Z bit
-@exit
-			ENDM	
-
-;----------
-; PrattFlashSystem Macro
-;	Sets the Z bit in the CCR if Pratt detects Flash on the expansion board,
-;	 else clears the Z bit
-;----------
-PrattSysStatReg	EQU		$50080007
-			MACRO
-				PrattFlashSystem	
-				btst.b	#PrattFlashLBit,PrattSysStatReg		; Is this a flash rom system
-			ENDM	
-
-ForAmusementOnly	equ		0
-				If	ForAmusementOnly then
-;__________________________________________________________________________________________
-;
-;
-; Old 16 bit Equates for onMac, onMacPP, and onHcMac
-;
-;
-;__________________________________________________________________________________________
 
+				If	onMac then
 ;=======================================;
 ;  Macintosh Plus Hardware Information	;
 ;=======================================;
@@ -2958,12 +2346,12 @@ viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
 loIntMask 		EQU 		$0100
 
 ; === VIA1 BUFFER A ===
-;vSound			EQU 		$7    					; sound volume bits (0..2)
+vSound			EQU 		$7    					; sound volume bits (0..2)
 vSndPg2   		EQU 		3 						; select sound page 2 if 0
-;vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+vHeadSel  		EQU 		5 						; head select line for Sony
 vPage2			EQU 		6 						; select video page 2 if 0
-;vSCCWrReq 		EQU 		7 						; SCC write/request line
+vSCCWrReq 		EQU 		7 						; SCC write/request line
 
 vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
 							(1<<vSndPg2)|\			; sound page 2 select is an output
@@ -2981,14 +2369,14 @@ vAInit 			EQU 		(1)|\					; sound volume level initially 1
 
 
 ; === VIA1 BUFFER B ===
-;vRTCData  		EQU 		0 						; real time clock data
-;vRTCClk   		EQU 		1 						; real time clock clock pulses
-;vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
 vSW   			EQU 		3 						; mouse switch (0 when down)
 vX2   			EQU 		4 						; mouse X level
 vY2   			EQU 		5 						; mouse Y level
 vH4   			EQU 		6 						; horizontal sync
-;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
 
 vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
 							(1<<vRTCClk)|\			; real time clock clock is an output
@@ -3064,7 +2452,9 @@ stlDelay  		EQU 		$30   					; default bus settle delay		*** patch only ***
 ROMDoEject		EQU 		$40001E   				; jump to DoEject utility		*** patch only ***
 dACKRd			EQU 		$200  					; offset of psuedo-DMA - READ	*** patch only ***
 
+seRegs      EQU     $3FFC80           ; Sys Error Regs w/o Overlay
 
+  				ELSEIF  	onMacPP THEN
 ;=======================================;
 ;	Macintosh SE Hardware Information	;
 ;=======================================;
@@ -3081,12 +2471,12 @@ viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
 loIntMask 		EQU 		$0100
 
 ; === VIA1 BUFFER A ===
-;vSound			EQU 		$7    					; sound volume bits (0..2)
-;vSync 			EQU 		3 						; Synchronous modem
+vSound			EQU 		$7    					; sound volume bits (0..2)
+vSync 			EQU 		3 						; Synchronous modem
 vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vHeadSel  		EQU 		5 						; head select line for Sony
 vPage2			EQU 		6 						; select video page 2 if 0
-;vSCCWrReq 		EQU 		7 						; SCC write/request line
+vSCCWrReq 		EQU 		7 						; SCC write/request line
 
 vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
 							(1<<vSync)|\			; Synchronous modem is an output
@@ -3105,15 +2495,15 @@ vAInit 			EQU 		(1)|\					; sound volume level initially 1
 
 
 ; === VIA1 BUFFER B ===
-;vRTCData  		EQU 		0 						; real time clock data
-;vRTCClk   		EQU 		1 						; real time clock clock pulses
-;vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
-;vFDBInt   		EQU 		3 						; Front Desk bus interrupt
-;vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
-;vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
 vSCSIMask 		EQU 		6 						; SCSI IRQ mask
 vH4   			EQU 		vSCSIMask				; SCSI IRQ mask (was horiz. sync)
-;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
 
 vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
 							(1<<vRTCClk)|\			; real time clock clock is an output
@@ -3183,7 +2573,9 @@ HeapStart 		EQU 		$1600 					; Aladdin starting point
 defSysHeap		EQU 		$18000    				; Default size of the system heap
 nDfltStackSize	EQU 		$2000 					; Default stack size
 
+seRegs      EQU     $3FFC80           ; Sys Error Regs w/o Overlay
 
+  				ELSEIF  	onHcMac THEN
 ;===========================================;
 ;	Macintosh Portable Hardware Information	;
 ;===========================================;
@@ -3212,12 +2604,12 @@ vAInit			EQU 		$00   					; VBufA initial values
 vPMreq			EQU 		0 						; Power manager handshake request
 vPMack			EQU 		1 						; Power manager handshake acknowledge
 vTestJ			EQU 		2 						; Test jumper
-;vSync 			EQU 		3 						; Synchronous modem
+vSync 			EQU 		3 						; Synchronous modem
 vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vHeadSel  		EQU 		5 						; head select line for Sony
 vStereo   		EQU 		6 						; Stereo sound enable
-;vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
-;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)	(output)
+vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)	(output)
 
 vBOut 			EQU 		(1<<vPMreq)|\			; Power mgr handshake request is an output
 							(0<<vPMack)|\			; Power mgr handshake acknowledge is an input
@@ -3300,57 +2692,59 @@ HeapStart 		EQU 		$1E00 					; Portable starting point	<1.2>
 DefSysHeap		EQU 		$18000    				; Default size of the system heap
 NDfltStackSize	EQU 		$2000 					; Default stack size
 
+seRegs      EQU     $0C30           ; offset to Sys Error Regs w/o Overlay
 
+  				ELSEIF  	onMac16 THEN
 ;===================================================;
 ;	Universal 16 bit Macintosh Hardware Information	;
 ;===================================================;
 
 
 ; === Interrupt Masks ===
-hiIntMask 		EQU 		$0700					; programmer switch only
+hiIntMask 		EQU 		$0300					; programmer switch only
 sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
 sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
 viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
 loIntMask 		EQU 		$0100
 
 ; === VIA1 BUFFER A ===
-;vSound			EQU 		$7    					; sound volume bits (0..2)
+vSound			EQU 		$7    					; sound volume bits (0..2)
 vSndPg2   		EQU 		3 						; select sound page 2 if 0
-;vSync 			EQU 		3 						; Synchronous modem
-;vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
-;vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vSync 			EQU 		3 						; Synchronous modem
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
+vHeadSel  		EQU 		5 						; head select line for Sony
 vPage2			EQU 		6 						; select video page 2 if 0
-;vSCCWrReq 		EQU 		7 						; SCC write/request line
+vSCCWrReq 		EQU 		7 						; SCC write/request line
 
 ; === VIA1 BUFFER B ===
-;vRTCData  		EQU 		0 						; real time clock data
-;vRTCClk   		EQU 		1 						; real time clock clock pulses
-;vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
 vSW   			EQU 		3 						; mouse switch (0 when down)
-;vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
 vX2   			EQU 		4 						; mouse X level
-;vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
 vY2   			EQU 		5 						; mouse Y level
-;vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
 vH4   			EQU 		6 						; horizontal sync
 vSCSIMask 		EQU 		6 						; SCSI IRQ mask
-;vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)
 
 vPMreq			EQU 		0 						; Power manager handshake request
 vPMack			EQU 		1 						; Power manager handshake acknowledge
 vTestJ			EQU 		2 						; Test jumper
-;vSync 			EQU 		3 						; Synchronous modem
-;vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
-;vHeadSel  		EQU 		5 						; head select line for Sony
+vSync 			EQU 		3 						; Synchronous modem
+vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
+vHeadSel  		EQU 		5 						; head select line for Sony
 vStereo   		EQU 		6 						; Stereo sound enable
-;vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
+vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
 
 ; === VIA1 BUFFER A/B ===
-;vSync 			EQU 		3 						; Synchronous modem						<3.1>
+vSync 			EQU 		3 						; Synchronous modem						<3.1>
 vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)	<3.1>
-;vHeadSel  		EQU 		5 						; head select line for Sony				<3.1>
-;vSCCWrReq 		EQU 		7 						; SCC write/request line				<3.1>
+vHeadSel  		EQU 		5 						; head select line for Sony				<3.1>
+vSCCWrReq 		EQU 		7 						; SCC write/request line				<3.1>
 
 ; === Hardware Base Addresses ===
 
@@ -3366,11 +2760,4295 @@ HeapStart 		EQU 		$1E00 					; Laguna starting point	<1.2>
 DefSysHeap		EQU 		$18000    				; Default size of the system heap
 NDfltStackSize	EQU 		$2000 					; Default stack size
 
+seRegs      EQU     $0C30           ; offset to Sys Error Regs w/o Overlay
 
+  				ELSEIF  	onMac32 THEN
+;===================================================;
+;	Universal 32 bit Macintosh Hardware Information	;
+;===================================================;
 
-  				ENDIF								; ForAmusementOnly
+machine   		EQU 		6						; for patch file $067C					<3.5>
+
+; === Interrupt Masks ===
+hiIntMask 		EQU 		$0700					; programmer switch only
+pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
+sccIntMask		EQU 		$0400					; SCC interrupt level
+sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
+slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
+viaIntMask		EQU 		$0100					; VIA1 interrupt level
+loIntMask 		EQU 		$0100
+
+; === VIA1 BUFFER A ===
+vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+vTestJ			EQU 		0 						; Burn In Test jumper		(input)
+vCpuId0			EQU			1						; CPU Identification bit 0	(input)
+vCpuId1			EQU			2						; CPU Identification bit 1	(input)
+vSync 			EQU 		3 						; Synchronous modem
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+vCpuId2			EQU			4						; CPU Identification bit 2
+vHeadSel  		EQU 		5 						; head select line for Sony
+vRev8Bd   		EQU 		6 						; =0 for rev 8 board
+vCpuId3			EQU			6						; CPU Identification bit 3
+vSCCWrReq 		EQU 		7 						; SCC write/request line
+
+; === VIA1 BUFFER B ===
+vRTCData  		EQU 		0 						; real time clock data
+v0reserved		EQU			0						; reserved bit in Erickson				<6>
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+v1reserved		EQU			1						; reserved bit in Erickson				<6>
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+v2reserved		EQU			2						; reserved bit in Erickson				<6>
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+xcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+viafullbit		EQU			4						; Egret via full bit					<6>
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+syssesbit		EQU			5						; Egret system session bit				<6>
+vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
+v6reserved		EQU			6						; reserved bit in Erickson				<6>
+vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
+v7reserved		EQU			7						; reserved bit in Erickson				<6>
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+
+
+; === Hardware Base Addresses ===
+
+WrOffs			EQU			0						; SCSI write addrs are same as read base
+
+MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
+MskVIA1			EQU			1						; VIA 1 is level 1
+MskADB			EQU			1						; ADB is level 1
+Msk60Hz			EQU			1						; 60 Hz is level 1
+MskSCSI			EQU			2						; SCSI is level 2
+MskSound		EQU			2						; sound is level 2						<4.5>
+MskSlots		EQU			2						; slots are level 2 interrupts
+MskRTC			EQU			3						; RTC is level 3
+MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
+MskPwrOff		EQU			6						; Poweroff button is level 6
+MskNMI			EQU			7						; NMI switch is level 7
+
+; === System Software Information ===
+snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world
+seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+
+
+  				ELSEIF  	onHafMac THEN
+;===================================;
+;	Mac IIci Hardware Information	;
+;===================================;
+
+machine   		EQU 		6
+
+; === Interrupt Masks ===
+hiIntMask 		EQU 		$0700 					; programmer switch only
+pwrOffEnbl		EQU 		$2500 					; mask to allow poweroff interrupts
+sccIntMask		EQU 		$0400 					; SCC interrupt level
+sccEnblMask   	EQU 		$FBFF 					; mask to enable SCC interrupts
+via2IntMask   	EQU 		$0200 					; VIA2 interrupt level		<v1.4><1.9>
+slotIntMask   	EQU 		via2IntMask   			; slot's interrupt level	<v1.4><1.9>
+viaIntMask		EQU 		$0100 					; VIA1 interrupt level
+loIntMask 		EQU 		$0100
+
+; === VIA1 BUFFER A ===
+vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+vTestJ			EQU 		0 						; Burn In Test jumper		(input)
+vCpuId0			EQU			1						; CPU Identification bit 0	(input)
+vCpuId1			EQU			2						; CPU Identification bit 1	(input)
+vSync 			EQU 		3 						; Synchronous modem
+vCpuId2			EQU			4						; CPU Identification bit 2
+vHeadSel  		EQU 		5 						; head select line for Sony
+vCpuId3			EQU			6						; CPU Identification bit 3
+vSCCWrReq 		EQU 		7 						; SCC write/request line
+
+vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
+							(1<<vSync)|\			; Synchronous modem is an output
+							(0<<vCpuId2)|\			; CPU Identification bit 2 is an input
+							(1<<vHeadSel)|\			; head select line is an output
+							(0<<vCpuId3)|\			; CPU Identification bit 3 is an input
+							(0<<vSCCWrReq)			; SCC write/request line is an input
+
+vAInit 			EQU 		(1)|\					; sound volume level initially 1
+							(0<<vSync)|\			; Synchronous modem disabled (active high)
+							(0<<vCpuId2)|\			; CPU Identification bit 2 is an input
+							(1<<vHeadSel)|\			; head select line is an output
+							(0<<vCpuId3)|\			; CPU Identification bit 3 is an input
+							(0<<vSCCWrReq)			; SCC write/request line is an input
+
+vBufD 			EQU 		vBufA 					; disk head select is buffer A
+
+
+; === VIA1 BUFFER B ===
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
+vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+
+vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
+							(1<<vRTCClk)|\			; real time clock clock is an output
+							(1<<vRTCEnb)|\			; clock enable is an output
+							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
+							(1<<vFDesk1)|\			; FDB state bit 0 is an output
+							(1<<vFDesk2)|\			; FDB state bit 1 is an output
+							(1<<vPGCEnb)|\			; PGC enable is an output
+							(1<<vSndEnb)			; sound enable is an output
+
+vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
+							(1<<vRTCClk)|\			; real time clock clock is high
+							(1<<vRTCEnb)|\			; clock initially disabled
+							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
+							(1<<vFDesk1)|\			; FDB state bit 0 is initially state 3
+							(1<<vFDesk2)|\			; FDB state bit 1 is initially state 3
+							(1<<vPGCEnb)|\			; Parity Checking is initially disabled
+							(1<<vSndEnb)			; sound is disabled
+
+
+; === RBV BUFFER B ===
+RvBInit			EQU			(1<<RvCDis)|\			; cache disabled	<3.3>
+							(1<<RvBusLk)|\			; Bus unlocked
+							(1<<RvPowerOff)|\		; Power on
+							(1<<RvCFlush)|\			; don't flush cache
+							(0<<RvTM1A)|\			; NuBus timeout bits are inputs
+							(0<<RvTM0A)|\			; NuBus timeout bits are inputs
+							(0<<RvSndExt)|\			; sound/speaker mode is an input
+							(1<<RvPGCTest)			; generate correct parity
+
+
+; === Hardware Base Addresses ===
+
+VBase 			EQU 		$50F00000   			; VIA base address
+AVBufA			EQU 		VBase+vBufA 			; VIA buffer A
+AVBufB			EQU 		VBase+vBufB  			; VIA buffer B
+
+SCCRBase  		EQU 		$50F04000   			; SCC base read address
+SCCWBase  		EQU 		$50F04000   			; SCC base write address
+sccWrite  		EQU 		SCCWBase-SCCRBase		; general offset for write from read
+
+NewSCSIBase   	EQU 		$50F10000 				; rev8 base addr SCSI interface
+NewSCSIDMA		EQU 		$50F12000 				; rev8 base addr SCSI DMA (corrected)
+NewSCSIHsk		EQU 		$50F06000 				; rev8 base addr SCSI handshake
+MacSCSIBase   	EQU 		$50F10000 				; base addr SCSI interface
+MacSCSIDMA		EQU 		$50F12000 				; base addr SCSI DMA
+MacSCSIHsk		EQU 		$50F06000 				; base addr SCSI handshake
+wrOffs			EQU 		0 						; write addrs are same as read base
+
+SndBase			EQU 		$50F14000 				; sound chip's base address
+
+; === Video Parameters ===
+
+RBVBase			EQU			$50F26000				; RBV base address				<v1.4><1.4>
+vDACBase		EQU			$50F24000				; base of clut
+
+; === System Software Information ===
+snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world
+seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+
+  				ELSEIF  	onNuMac THEN
+;=======================================================;
+;	Macintosh II, IIx, IIcx, SE30 Hardware Information	;
+;=======================================================;
+
+hwCfgBits 		EQU 		hwCmSCSI++hwCmClock++hwCmFPU++hwCmMMU++hwCmADB
+machine   		EQU 		1
+rom85Bits 		EQU 		$3F   					; New ROMs, Power Off ability.
+
+; === Interrupt Masks ===
+hiIntMask 		EQU 		$0700 					; programmer switch only
+pwrOffEnbl		EQU 		$2500 					; mask to allow poweroff interrupts
+sccIntMask		EQU 		$0400 					; SCC interrupt level
+sccEnblMask   	EQU 		$FBFF 					; mask to enable SCC interrupts
+via2IntMask   	EQU 		$0200 					; VIA2 interrupt level		<v1.4><1.9>
+slotIntMask   	EQU 		via2IntMask   			; slot's interrupt level	<v1.4><1.9>
+viaIntMask		EQU 		$0100 					; VIA1 interrupt level
+loIntMask 		EQU 		$0100
+
+; === VIA1 BUFFER A ===
+vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+vSync 			EQU 		3 						; Synchronous modem
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+vHeadSel  		EQU 		5 						; head select line for Sony
+vRev8Bd   		EQU 		6 						; =0 for rev 8 board
+vSCCWrReq 		EQU 		7 						; SCC write/request line
+
+vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
+							(1<<vSync)|\			; Synchronous modem is an output
+							(1<<vOverlay)|\			; overlay bit is an output
+							(1<<vHeadSel)|\			; head select line is an output
+							(0<<vRev8Bd)|\			; board ID is an input
+							(0<<vSCCWrReq)			; SCC write/request line is an input
+
+vAInit 			EQU 		(1)|\					; sound volume level initially 1
+							(0<<vSync)|\			; Synchronous modem disabled (active high)
+							(0<<vOverlay)|\			; overlay is turned off
+							(0<<vHeadSel)|\			; head select line is an output
+							(0<<vRev8Bd)|\			; board ID is an input
+							(0<<vSCCWrReq)			; SCC write/request line is an input
+
+vBufD 			EQU 		vBufA 					; disk head select is buffer A
+
+
+; === VIA1 BUFFER B ===
+vRTCData  		EQU 		0 						; real time clock data
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+;				EQU			6						; unused
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+
+vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
+							(1<<vRTCClk)|\			; real time clock clock is an output
+							(1<<vRTCEnb)|\			; clock enable is an output
+							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
+							(1<<vFDesk1)|\			; FDB state bit 0 is an output
+							(1<<vFDesk2)|\			; FDB state bit 1 is an output
+							(1<<vSndEnb)			; sound enable is an output
+
+vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
+							(1<<vRTCClk)|\			; real time clock clock is high
+							(1<<vRTCEnb)|\			; clock initially disabled
+							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
+							(1<<vFDesk1)|\			; FDB state bit 0 is initially state 3
+							(1<<vFDesk2)|\			; FDB state bit 1 is initially state 3
+							(0<<vSndEnb)			; sound is enabled
+
+
+; === VIA2 BUFFER A ===
+v2AOut			EQU 		(0<<v2IRQ1)|\     		; slot 1 interrupt is an input
+  				(0<<v2IRQ2)|\ 						; slot 2 interrupt is an input
+  				(0<<v2IRQ3)|\ 						; slot 3 interrupt is an input
+  				(0<<v2IRQ4)|\ 						; slot 4 interrupt is an input
+  				(0<<v2IRQ5)|\ 						; slot 5 interrupt is an input
+  				(0<<v2IRQ6)|\ 						; slot 6 interrupt is an input
+  				(1<<v2RAM0)|\ 						; ram size bit 0 is an output
+  				(1<<v2RAM1)   						; ram size bit 1 is an output
+
+v2AInit			EQU			(0<<v2IRQ1)|\			; slot 1 interrupt is an input
+							(0<<v2IRQ2)|\			; slot 2 interrupt is an input
+							(0<<v2IRQ3)|\			; slot 3 interrupt is an input
+							(0<<v2IRQ4)|\			; slot 4 interrupt is an input
+							(0<<v2IRQ5)|\			; slot 5 interrupt is an input
+							(0<<v2IRQ6)|\			; slot 6 interrupt is an input
+							(0<<v2RAM0)|\			; or ram size bit 0 with 0
+							(0<<v2RAM1)				; or ram size bit 1 with 0
+
+
+; === VIA2 BUFFER B ===
+v2BOut			EQU			(0<<v2CDis)|\			; cache disabled	<3.3>
+  				(0<<v2BusLk)|\						; Bus unlocked
+  				(0<<v2PowerOff)|\ 					; Power on
+  				(0<<vFC3)|\   						; don't flush cache
+  				(0<<v2TM1A)|\ 						; NuBus timeout bits are inputs
+  				(0<<v2TM0A)|\ 						; NuBus timeout bits are inputs
+  				(0<<v2SndExt)|\   					; sound/speaker mode is an input
+  				(1<<v2VBL)							; 60Hz pseudo VBL output
+
+v2BInit			EQU			(1<<v2CDis)|\			; cache disabled (input when not in use)	<3.3>
+							(0<<v2BusLk)|\			; Bus unlocked	(input when not in use)
+							(1<<v2PowerOff)|\		; Power on	(input when not in use)
+							(0<<vFC3)|\				; don't flush cache	(input when not in use)
+							(0<<v2TM1A)|\			; NuBus timeout bits are inputs
+							(0<<v2TM0A)|\			; NuBus timeout bits are inputs
+							(0<<v2SndExt)|\			; sound/speaker mode is an input
+							(0<<v2VBL)				; 60Hz pseudo VBL output
+
+
+; === Hardware Base Addresses ===
+
+VBase 			EQU 		$50F00000     			; VIA base address
+AVBufA			EQU 		VBase+vBufA       		; VIA buffer A
+AVBufB			EQU 		VBase+vBufB       		; VIA buffer B
+
+VBase2			EQU 		$50F02000 				; VIA2 base address				<v1.4>
+
+SCCRBase  		EQU 		$50F04000     			; SCC base read address
+SCCWBase  		EQU 		$50F04000     			; SCC base write address
+sccWrite  		EQU 		SCCWBase-SCCRBase     	; general offset for write from read
+
+NewSCSIBase   	EQU 		$50F10000     			; rev8 base addr SCSI interface
+NewSCSIDMA		EQU 		$50F12000     			; rev8 base addr SCSI DMA (corrected)
+NewSCSIHsk		EQU 		$50F06000     			; rev8 base addr SCSI handshake
+MacSCSIBase   	EQU 		$50F10000     			; base addr SCSI interface
+MacSCSIDMA		EQU 		$50F12000     			; base addr SCSI DMA
+MacSCSIHsk		EQU 		$50F06000     			; base addr SCSI handshake
+wrOffs			EQU 		0 						; write addrs are same as read base
+
+SndBase   		EQU 		$50F14000     			; sound chip's base address
+
+; === System Software Information ===
+snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world
+seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+
+
+  				ENDIF
 
 HardwarePrivate EQU 		1
 
   				ENDIF								; __INCLUDINGHARDWAREPRIVATEEQU__
 
+; Everything below is empty calories to keep this file compiling
+;__________________________________________________________________________________________
+;
+; Welcome to the New Hardware Equates File.  By following some simple procedures this file
+; can keep its youthful appearance for years to come.  This file is a recombination of
+; HardwareEqu.a and HardwarePrivateEqu.a.  Everyone should be using this file only.  Please
+; change any of your files that use either of the hardware equate files to use only this one.
+; HardwareEqu.a will be left as an historical artifact for future generations.
+;
+; To help you navigate through this file use the "Mark" menu item, and please help to keep
+; it current.  When you add a new section, add a handy mark to find it again.  Equates are
+; grouped in a semi-logical way in the follwing order:
+;
+;		Chip Offsets - Register offsets for the 'standard' Mac peripheral chips.
+;		Chip Offsets 2 - Register offsets for the 'non-standard' Mac peripheral chips.
+;		VIA1 - Register offsets and pin descriptions.
+;		VIA2 - Register offsets and pin descriptions.
+;		RBV - Register offsets and pin descriptions.
+;		VISA - Register offsets and pin descriptions.
+;		Memory Controllers - Register definitions and miscellaneous equates.
+;		Interrupts - Auto vector names and mask definitions.
+;		Miscellaneous - The "Smorgasboard" of equates.
+;		Old 16 Bit Equates - Machine dependent equates for Mac, MacPP, HcMac, and Mac16.
+;
+;
+;__________________________________________________________________________________________
+
+
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; Chip Offsets - Register offsets for "standard" Mac chips.  This includes the following:
+;				 IWM, SWIM, SCC, SCSI (with and without DMA), ASC.
+;
+;
+;__________________________________________________________________________________________
+
+
+;---------------------------------------------------
+; IWM Offsets
+;---------------------------------------------------
+
+	IF &TYPE('ph0L') = 'UNDEFINED' THEN ; generated for fun
+ph0L  			EQU 		0 						; disk address offsets from base
+	ENDIF ; generated for fun
+	IF &TYPE('ph0H') = 'UNDEFINED' THEN ; generated for fun
+ph0H  			EQU 		$200
+	ENDIF ; generated for fun
+	IF &TYPE('ph1L') = 'UNDEFINED' THEN ; generated for fun
+ph1L  			EQU 		$400
+	ENDIF ; generated for fun
+	IF &TYPE('ph1H') = 'UNDEFINED' THEN ; generated for fun
+ph1H  			EQU 		$600
+	ENDIF ; generated for fun
+	IF &TYPE('ph2L') = 'UNDEFINED' THEN ; generated for fun
+ph2L  			EQU 		$800
+	ENDIF ; generated for fun
+	IF &TYPE('ph2H') = 'UNDEFINED' THEN ; generated for fun
+ph2H  			EQU 		$A00
+	ENDIF ; generated for fun
+	IF &TYPE('ph3L') = 'UNDEFINED' THEN ; generated for fun
+ph3L  			EQU 		$C00
+	ENDIF ; generated for fun
+	IF &TYPE('ph3H') = 'UNDEFINED' THEN ; generated for fun
+ph3H  			EQU 		$E00
+	ENDIF ; generated for fun
+	IF &TYPE('mtrOff') = 'UNDEFINED' THEN ; generated for fun
+mtrOff			EQU 		$1000
+	ENDIF ; generated for fun
+	IF &TYPE('mtrOn') = 'UNDEFINED' THEN ; generated for fun
+mtrOn 			EQU 		$1200
+	ENDIF ; generated for fun
+	IF &TYPE('intDrive') = 'UNDEFINED' THEN ; generated for fun
+intDrive  		EQU 		$1400 					; enable internal drive address
+	ENDIF ; generated for fun
+	IF &TYPE('extDrive') = 'UNDEFINED' THEN ; generated for fun
+extDrive  		EQU 		$1600 					; enable external drive address
+	ENDIF ; generated for fun
+	IF &TYPE('q6L') = 'UNDEFINED' THEN ; generated for fun
+q6L   			EQU 		$1800
+	ENDIF ; generated for fun
+	IF &TYPE('q6H') = 'UNDEFINED' THEN ; generated for fun
+q6H   			EQU 		$1A00
+	ENDIF ; generated for fun
+	IF &TYPE('q7L') = 'UNDEFINED' THEN ; generated for fun
+q7L   			EQU 		$1C00
+	ENDIF ; generated for fun
+	IF &TYPE('q7H') = 'UNDEFINED' THEN ; generated for fun
+q7H   			EQU 		$1E00
+	ENDIF ; generated for fun
+
+	IF &TYPE('IWMInitMode') = 'UNDEFINED' THEN ; generated for fun
+IWMInitMode		equ			$17						; initial IWM mode setting				<3.5>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+;  SWIM offsets
+;---------------------------------------------------
+
+	IF &TYPE('wData') = 'UNDEFINED' THEN ; generated for fun
+wData 			EQU 		$0000 					;Write a data byte
+	ENDIF ; generated for fun
+	IF &TYPE('wMark') = 'UNDEFINED' THEN ; generated for fun
+wMark 			EQU 		$0200 					;Write a mark byte
+	ENDIF ; generated for fun
+	IF &TYPE('wCRC') = 'UNDEFINED' THEN ; generated for fun
+wCRC  			EQU 		$0400 					;Write a 2-byte CRC (1 access does both)
+	ENDIF ; generated for fun
+	IF &TYPE('wIWMConfig') = 'UNDEFINED' THEN ; generated for fun
+wIWMConfig		EQU 		wCRC  					;Set IWM configuration
+	ENDIF ; generated for fun
+	IF &TYPE('wParams') = 'UNDEFINED' THEN ; generated for fun
+wParams   		EQU 		$0600 					;Set the 16 parameter registers
+	ENDIF ; generated for fun
+	IF &TYPE('wPhase') = 'UNDEFINED' THEN ; generated for fun
+wPhase			EQU 		$0800 					;Set phase lines states and directions
+	ENDIF ; generated for fun
+	IF &TYPE('wSetup') = 'UNDEFINED' THEN ; generated for fun
+wSetup			EQU 		$0A00 					;Set the current configuration
+	ENDIF ; generated for fun
+	IF &TYPE('wZeroes') = 'UNDEFINED' THEN ; generated for fun
+wZeroes   		EQU 		$0C00 					;Mode reg: 1's clr bits, 0's=don't care
+	ENDIF ; generated for fun
+	IF &TYPE('wOnes') = 'UNDEFINED' THEN ; generated for fun
+wOnes 			EQU 		$0E00 					;Mode reg: 1's set bits, 0's=don't care
+	ENDIF ; generated for fun
+	IF &TYPE('rData') = 'UNDEFINED' THEN ; generated for fun
+rData 			EQU 		$1000 					;Read a data byte
+	ENDIF ; generated for fun
+	IF &TYPE('rCorrection') = 'UNDEFINED' THEN ; generated for fun
+rCorrection   	EQU 		rData 					;Read the correction factor
+	ENDIF ; generated for fun
+	IF &TYPE('rMark') = 'UNDEFINED' THEN ; generated for fun
+rMark 			EQU 		$1200 					;Read a mark byte
+	ENDIF ; generated for fun
+	IF &TYPE('rError') = 'UNDEFINED' THEN ; generated for fun
+rError			EQU 		$1400 					;Error register
+	ENDIF ; generated for fun
+	IF &TYPE('rParams') = 'UNDEFINED' THEN ; generated for fun
+rParams   		EQU 		$1600 					;Parameters (16 bytes deep at this addr)
+	ENDIF ; generated for fun
+	IF &TYPE('rPhase') = 'UNDEFINED' THEN ; generated for fun
+rPhase			EQU 		$1800 					;Phase lines states and directions
+	ENDIF ; generated for fun
+	IF &TYPE('rSetup') = 'UNDEFINED' THEN ; generated for fun
+rSetup			EQU 		$1A00 					;Read the current configuration
+	ENDIF ; generated for fun
+	IF &TYPE('rStatus') = 'UNDEFINED' THEN ; generated for fun
+rStatus   		EQU 		$1C00 					;Status (returns current mode reg value)
+	ENDIF ; generated for fun
+	IF &TYPE('rHandshake') = 'UNDEFINED' THEN ; generated for fun
+rHandshake		EQU 		$1E00 					;Handshake register
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; 8530 SCC Offsets
+;---------------------------------------------------
+
+	IF &TYPE('aData') = 'UNDEFINED' THEN ; generated for fun
+aData 			EQU 		6 						; offset for A channel data
+	ENDIF ; generated for fun
+	IF &TYPE('aCtl') = 'UNDEFINED' THEN ; generated for fun
+aCtl  			EQU 		2 						; offset for A channel control
+	ENDIF ; generated for fun
+	IF &TYPE('bData') = 'UNDEFINED' THEN ; generated for fun
+bData 			EQU 		4 						; offset for B channel data
+	ENDIF ; generated for fun
+	IF &TYPE('bCtl') = 'UNDEFINED' THEN ; generated for fun
+bCtl  			EQU 		0 						; offset for B channel control
+	ENDIF ; generated for fun
+	IF &TYPE('sccData') = 'UNDEFINED' THEN ; generated for fun
+sccData   		EQU 		4 						; general offset for data from control
+	ENDIF ; generated for fun
+	IF &TYPE('rxBF') = 'UNDEFINED' THEN ; generated for fun
+rxBF  			EQU 		0 						; SCC receive buffer full
+	ENDIF ; generated for fun
+	IF &TYPE('txBE') = 'UNDEFINED' THEN ; generated for fun
+txBE  			EQU 		2 						; SCC transmit buffer empty
+	ENDIF ; generated for fun
+	IF &TYPE('RxCA') = 'UNDEFINED' THEN ; generated for fun
+RxCA			EQU			0						; Receive Character Available
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; 53C80 SCSI Register Defs, Offsets
+;---------------------------------------------------
+
+	IF &TYPE('sCDR') = 'UNDEFINED' THEN ; generated for fun
+sCDR  			EQU 		$00   					; Current SCSI Read Data
+	ENDIF ; generated for fun
+	IF &TYPE('sODR') = 'UNDEFINED' THEN ; generated for fun
+sODR  			EQU 		$00   					; Output data register
+	ENDIF ; generated for fun
+	IF &TYPE('sICR') = 'UNDEFINED' THEN ; generated for fun
+sICR  			EQU 		$10   					; Initiator Command Register - READ/WRITE
+	ENDIF ; generated for fun
+	IF &TYPE('iRST') = 'UNDEFINED' THEN ; generated for fun
+iRST  			EQU 		$80   					; *RST asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iAIP') = 'UNDEFINED' THEN ; generated for fun
+iAIP  			EQU 		$40   					; arbitration in progress (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bAIP') = 'UNDEFINED' THEN ; generated for fun
+bAIP  			EQU 		6 						; bit test for arbitration in progress
+	ENDIF ; generated for fun
+	IF &TYPE('aTMD') = 'UNDEFINED' THEN ; generated for fun
+aTMD  			EQU 		$40   					; assert Test Mode (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iLA') = 'UNDEFINED' THEN ; generated for fun
+iLA   			EQU 		$20   					; Lost arbitration (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bLA') = 'UNDEFINED' THEN ; generated for fun
+bLA   			EQU 		5 						; bit test for Lost Arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('aDIFF') = 'UNDEFINED' THEN ; generated for fun
+aDIFF 			EQU 		$20   					; assert Differential enable (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iACK') = 'UNDEFINED' THEN ; generated for fun
+iACK  			EQU 		$10   					; *ACK is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iBSY') = 'UNDEFINED' THEN ; generated for fun
+iBSY  			EQU 		$08   					; *BSY is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iSEL') = 'UNDEFINED' THEN ; generated for fun
+iSEL  			EQU 		$04   					; *SEL is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iATN') = 'UNDEFINED' THEN ; generated for fun
+iATN  			EQU 		$02   					; *ATN is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('iDB') = 'UNDEFINED' THEN ; generated for fun
+iDB   			EQU 		$01   					; Data bus is asserted
+	ENDIF ; generated for fun
+	IF &TYPE('sMR') = 'UNDEFINED' THEN ; generated for fun
+sMR   			EQU 		$20   					; Mode Register - READ/WRITE
+	ENDIF ; generated for fun
+	IF &TYPE('iBDMA') = 'UNDEFINED' THEN ; generated for fun
+iBDMA 			EQU 		$80   					; Block Mode DMA
+	ENDIF ; generated for fun
+	IF &TYPE('iTGT') = 'UNDEFINED' THEN ; generated for fun
+iTGT  			EQU 		$40   					; Target Mode
+	ENDIF ; generated for fun
+	IF &TYPE('iPTY') = 'UNDEFINED' THEN ; generated for fun
+iPTY  			EQU 		$20   					; Enable Parity Checking
+	ENDIF ; generated for fun
+	IF &TYPE('iIPTY') = 'UNDEFINED' THEN ; generated for fun
+iIPTY 			EQU 		$10   					; Enable Parity interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('iIEOP') = 'UNDEFINED' THEN ; generated for fun
+iIEOP 			EQU 		$08   					; Enable EOP interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('iMBSY') = 'UNDEFINED' THEN ; generated for fun
+iMBSY 			EQU 		$04   					; Monitor BSY
+	ENDIF ; generated for fun
+	IF &TYPE('iDMA') = 'UNDEFINED' THEN ; generated for fun
+iDMA  			EQU 		$02   					; DMA Mode
+	ENDIF ; generated for fun
+	IF &TYPE('iARB') = 'UNDEFINED' THEN ; generated for fun
+iARB  			EQU 		$01   					; Arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('sTCR') = 'UNDEFINED' THEN ; generated for fun
+sTCR  			EQU 		$30   					; Target Command Register - READ/WRITE
+	ENDIF ; generated for fun
+	IF &TYPE('iREQ') = 'UNDEFINED' THEN ; generated for fun
+iREQ  			EQU 		$08   					; Assert *REQ
+	ENDIF ; generated for fun
+	IF &TYPE('iMSG') = 'UNDEFINED' THEN ; generated for fun
+iMSG  			EQU 		$04   					; Assert *MSG
+	ENDIF ; generated for fun
+	IF &TYPE('iCD') = 'UNDEFINED' THEN ; generated for fun
+iCD   			EQU 		$02   					; Assert C/*D
+	ENDIF ; generated for fun
+	IF &TYPE('iIO') = 'UNDEFINED' THEN ; generated for fun
+iIO   			EQU 		$01   					; Assert I/*O
+	ENDIF ; generated for fun
+	IF &TYPE('sCSR') = 'UNDEFINED' THEN ; generated for fun
+sCSR  			EQU 		$40   					; Current SCSI Bus Status (READ)
+	ENDIF ; generated for fun
+	IF &TYPE('aRST') = 'UNDEFINED' THEN ; generated for fun
+aRST  			EQU 		$80   					; *RST
+	ENDIF ; generated for fun
+	IF &TYPE('aBSY') = 'UNDEFINED' THEN ; generated for fun
+aBSY  			EQU 		$40   					; *BSY
+	ENDIF ; generated for fun
+	IF &TYPE('bBSY') = 'UNDEFINED' THEN ; generated for fun
+bBSY  			EQU 		6 						; bit test for *BSY
+	ENDIF ; generated for fun
+	IF &TYPE('aREQ') = 'UNDEFINED' THEN ; generated for fun
+aREQ  			EQU 		$20   					; *REQ
+	ENDIF ; generated for fun
+	IF &TYPE('bREQ') = 'UNDEFINED' THEN ; generated for fun
+bREQ  			EQU 		5 						; bit test for *REQ
+	ENDIF ; generated for fun
+	IF &TYPE('aMSG') = 'UNDEFINED' THEN ; generated for fun
+aMSG  			EQU 		$10   					; *MSG
+	ENDIF ; generated for fun
+	IF &TYPE('bMSG') = 'UNDEFINED' THEN ; generated for fun
+bMSG  			EQU 		4 						; bit test for *MSG
+	ENDIF ; generated for fun
+	IF &TYPE('aCD') = 'UNDEFINED' THEN ; generated for fun
+aCD   			EQU 		$08   					; C/*D
+	ENDIF ; generated for fun
+	IF &TYPE('bCD') = 'UNDEFINED' THEN ; generated for fun
+bCD   			EQU 		3 						; bit test for C/*D
+	ENDIF ; generated for fun
+	IF &TYPE('aIO') = 'UNDEFINED' THEN ; generated for fun
+aIO   			EQU 		$04   					; I/*O
+	ENDIF ; generated for fun
+	IF &TYPE('bIO') = 'UNDEFINED' THEN ; generated for fun
+bIO   			EQU 		2 						; bit test for I/*O
+	ENDIF ; generated for fun
+	IF &TYPE('aSEL') = 'UNDEFINED' THEN ; generated for fun
+aSEL  			EQU 		$02   					; *SEL
+	ENDIF ; generated for fun
+	IF &TYPE('bSEL') = 'UNDEFINED' THEN ; generated for fun
+bSEL  			EQU 		1 						; bit test for *SEL
+	ENDIF ; generated for fun
+	IF &TYPE('aDBP') = 'UNDEFINED' THEN ; generated for fun
+aDBP  			EQU 		$01   					; *DBP
+	ENDIF ; generated for fun
+	IF &TYPE('sSER') = 'UNDEFINED' THEN ; generated for fun
+sSER  			EQU 		$40   					; Select Enable Register (WRITE)
+	ENDIF ; generated for fun
+	IF &TYPE('sBSR') = 'UNDEFINED' THEN ; generated for fun
+sBSR  			EQU 		$50   					; Bus & Status Register (READ)
+	ENDIF ; generated for fun
+	IF &TYPE('iEDMA') = 'UNDEFINED' THEN ; generated for fun
+iEDMA 			EQU 		$80   					; End of DMA
+	ENDIF ; generated for fun
+	IF &TYPE('bEDMA') = 'UNDEFINED' THEN ; generated for fun
+bEDMA 			EQU 		7 						; bit test for end of DMA
+	ENDIF ; generated for fun
+	IF &TYPE('iDMAR') = 'UNDEFINED' THEN ; generated for fun
+iDMAR 			EQU 		$40   					; DMA Request
+	ENDIF ; generated for fun
+	IF &TYPE('bDMAR') = 'UNDEFINED' THEN ; generated for fun
+bDMAR 			EQU 		6 						; bit test for DMA Req
+	ENDIF ; generated for fun
+	IF &TYPE('iPERR') = 'UNDEFINED' THEN ; generated for fun
+iPERR 			EQU 		$20   					; Parity Error
+	ENDIF ; generated for fun
+	IF &TYPE('iIREQ') = 'UNDEFINED' THEN ; generated for fun
+iIREQ 			EQU 		$10   					; Interrupt Request
+	ENDIF ; generated for fun
+	IF &TYPE('bIREQ') = 'UNDEFINED' THEN ; generated for fun
+bIREQ 			EQU 		4 						; bit test for interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('iPM') = 'UNDEFINED' THEN ; generated for fun
+iPM   			EQU 		$08   					; Phase Match
+	ENDIF ; generated for fun
+	IF &TYPE('bPM') = 'UNDEFINED' THEN ; generated for fun
+bPM   			EQU 		3 						; bit test for Phase Match
+	ENDIF ; generated for fun
+	IF &TYPE('iBERR') = 'UNDEFINED' THEN ; generated for fun
+iBERR 			EQU 		$04   					; Bus Error
+	ENDIF ; generated for fun
+	IF &TYPE('ATN') = 'UNDEFINED' THEN ; generated for fun
+ATN   			EQU 		$02   					; *ATN
+	ENDIF ; generated for fun
+	IF &TYPE('ACK') = 'UNDEFINED' THEN ; generated for fun
+ACK   			EQU 		$01   					; *ACK
+	ENDIF ; generated for fun
+	IF &TYPE('bACK') = 'UNDEFINED' THEN ; generated for fun
+bACK  			EQU 		0 						; bit test for ACK
+	ENDIF ; generated for fun
+	IF &TYPE('sDMAtx') = 'UNDEFINED' THEN ; generated for fun
+sDMAtx			EQU 		$50   					; DMA Transmit Start (WRITE)
+	ENDIF ; generated for fun
+	IF &TYPE('sIDR') = 'UNDEFINED' THEN ; generated for fun
+sIDR  			EQU 		$60   					; Data input register (READ)
+	ENDIF ; generated for fun
+	IF &TYPE('sTDMArx') = 'UNDEFINED' THEN ; generated for fun
+sTDMArx   		EQU 		$60   					; Start Target DMA receive (WRITE)
+	ENDIF ; generated for fun
+	IF &TYPE('sRESET') = 'UNDEFINED' THEN ; generated for fun
+sRESET			EQU 		$70   					; Reset Parity/Interrupt (READ)
+	ENDIF ; generated for fun
+	IF &TYPE('sIDMArx') = 'UNDEFINED' THEN ; generated for fun
+sIDMArx   		EQU 		$70   					; Start Initiator DMA receive (WRITE)
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+;  SCSI DMA chip register offsets
+;---------------------------------------------------
+
+;  Note that the 53C80 registers are provided on the SCSI DMA chip.  The registers
+;  described here are in addition to the 53C80 registers.
+
+	IF &TYPE('sDCTRL') = 'UNDEFINED' THEN ; generated for fun
+sDCTRL			EQU			$80
+	ENDIF ; generated for fun
+	IF &TYPE('bDMAEN') = 'UNDEFINED' THEN ; generated for fun
+bDMAEN			EQU			0						; bit to enable SCSI DMA
+	ENDIF ; generated for fun
+	IF &TYPE('iDMAEN') = 'UNDEFINED' THEN ; generated for fun
+iDMAEN			EQU			$0001					; mask to enable SCSI DMA
+	ENDIF ; generated for fun
+	IF &TYPE('bINTREN') = 'UNDEFINED' THEN ; generated for fun
+bINTREN			EQU			1						; bit to enable SCSI DMA interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('iINTREN') = 'UNDEFINED' THEN ; generated for fun
+iINTREN			EQU			$0002					; mask to enable SCSI DMA interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('bTIMEEN') = 'UNDEFINED' THEN ; generated for fun
+bTIMEEN			EQU			2						; bit to enable watchdog timer intr's
+	ENDIF ; generated for fun
+	IF &TYPE('iTIMEEN') = 'UNDEFINED' THEN ; generated for fun
+iTIMEEN			EQU			$0004					; mask to enable watchdog timer intr's
+	ENDIF ; generated for fun
+	IF &TYPE('bHSKEN') = 'UNDEFINED' THEN ; generated for fun
+bHSKEN			EQU			3						; bit to enable hardware-handshaking (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iHSKEN') = 'UNDEFINED' THEN ; generated for fun
+iHSKEN			EQU			$0008					; mask to enable hardware-handshaking (write)
+	ENDIF ; generated for fun
+	IF &TYPE('bRESET') = 'UNDEFINED' THEN ; generated for fun
+bRESET			EQU			4						; bit to reset SCSI DMA chip (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iRESET') = 'UNDEFINED' THEN ; generated for fun
+iRESET			EQU			$0010					; mask to reset SCSI DMA chip (write)
+	ENDIF ; generated for fun
+	IF &TYPE('bFIFO') = 'UNDEFINED' THEN ; generated for fun
+bFIFO			EQU			4						; bit indicating bytes left in FIFO (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iFIFO') = 'UNDEFINED' THEN ; generated for fun
+iFIFO			EQU			$0010					; mask indicating bytes left in FIFO (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bTEST') = 'UNDEFINED' THEN ; generated for fun
+bTEST			EQU			5						; bit to enable SCSI Test Mode (write)
+	ENDIF ; generated for fun
+	IF &TYPE('iTEST') = 'UNDEFINED' THEN ; generated for fun
+iTEST			EQU			$0020					; mask to enable SCSI Test Mode (write)
+	ENDIF ; generated for fun
+	IF &TYPE('bSCSIP') = 'UNDEFINED' THEN ; generated for fun
+bSCSIP			EQU			6						; bit indicating SCSI intr pending (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iSCSIP') = 'UNDEFINED' THEN ; generated for fun
+iSCSIP			EQU			$0040					; mask indicating SCSI intr pending (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bTIMEP') = 'UNDEFINED' THEN ; generated for fun
+bTIMEP			EQU			7						; bit indicating timer intr pending (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iTIMEP') = 'UNDEFINED' THEN ; generated for fun
+iTIMEP			EQU			$0080					; mask indicating timer intr pending (read)
+	ENDIF ; generated for fun
+	IF &TYPE('bDMABERR') = 'UNDEFINED' THEN ; generated for fun
+bDMABERR		EQU			8						; bit indicating DMA bus error (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iDMABERR') = 'UNDEFINED' THEN ; generated for fun
+iDMABERR		EQU			$0100					; mask indicating DMA bus error (read)
+	ENDIF ; generated for fun
+	IF &TYPE('iARBID') = 'UNDEFINED' THEN ; generated for fun
+iARBID			EQU			$0E00					; mask to get target ID for arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('bARBIDEN') = 'UNDEFINED' THEN ; generated for fun
+bARBIDEN		EQU			12						; bit to enable hardware arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('iARBIDEN') = 'UNDEFINED' THEN ; generated for fun
+iARBIDEN		EQU			$1000					; mask to enable hardware arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('bWONARB') = 'UNDEFINED' THEN ; generated for fun
+bWONARB			EQU			13						; bit indicating successful arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('iWONARB') = 'UNDEFINED' THEN ; generated for fun
+iWONARB			EQU			$2000					; mask indicating successful arbitration
+	ENDIF ; generated for fun
+	IF &TYPE('iINFIFO') = 'UNDEFINED' THEN ; generated for fun
+iINFIFO			EQU			$C000					; mask to get bytes left in FIFO (read)
+	ENDIF ; generated for fun
+
+	IF &TYPE('sDCNT') = 'UNDEFINED' THEN ; generated for fun
+sDCNT			EQU			$C0
+	ENDIF ; generated for fun
+
+	IF &TYPE('sDADDR') = 'UNDEFINED' THEN ; generated for fun
+sDADDR			EQU			$100
+	ENDIF ; generated for fun
+
+	IF &TYPE('sDTIME') = 'UNDEFINED' THEN ; generated for fun
+sDTIME			EQU			$140
+	ENDIF ; generated for fun
+
+	IF &TYPE('sTEST') = 'UNDEFINED' THEN ; generated for fun
+sTEST			equ			$180
+	ENDIF ; generated for fun
+
+;__________________________________________________________________________________________
+;
+;
+; Chip Offsets - Register offsets for "non standard" Mac chips.  This includes the following:
+;				 OSS and IOP.
+;
+;
+;__________________________________________________________________________________________
+
+
+;---------------------------------------------------
+;  OSS (Operating System Support) Chip Address & Offsets
+;---------------------------------------------------
+
+	IF &TYPE('OSSMskFirst') = 'UNDEFINED' THEN ; generated for fun
+OSSMskFirst		equ			$000					;offset to first interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlot9') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlot9		equ			OSSMskFirst				;offset to slot 9 interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotA') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotA		equ			$001					;offset to slot A interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotB') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotB		equ			$002					;offset to slot B interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotC') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotC		equ			$003					;offset to slot C interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotD') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotD		equ			$004					;offset to slot D interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSlotE') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSlotE		equ			$005					;offset to slot E interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskPSwm') = 'UNDEFINED' THEN ; generated for fun
+OSSMskPSwm		equ			$006					;offset to SWIM PIC interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskPScc') = 'UNDEFINED' THEN ; generated for fun
+OSSMskPScc		equ			$007					;offset to SCC PIC interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskSnd') = 'UNDEFINED' THEN ; generated for fun
+OSSMskSnd		equ			$008					;offset to Sound interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskScsi') = 'UNDEFINED' THEN ; generated for fun
+OSSMskScsi		equ			$009					;offset to SCSI interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMsk60Hz') = 'UNDEFINED' THEN ; generated for fun
+OSSMsk60Hz		equ			$00A					;offset to 60 Hz interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskVia1') = 'UNDEFINED' THEN ; generated for fun
+OSSMskVia1		equ			$00B					;offset to VIA1 interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskRTC') = 'UNDEFINED' THEN ; generated for fun
+OSSMskRTC		equ			$00C					;offset to RTC interrupt mask register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskADB') = 'UNDEFINED' THEN ; generated for fun
+OSSMskADB		equ			$00D					;offset to ADB interrupt mask register (not used)		<5.1>
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskRPU') = 'UNDEFINED' THEN ; generated for fun
+OSSMskRPU		equ			$00E					;offset to RPU interrupt mask register					<4.8>
+	ENDIF ; generated for fun
+	IF &TYPE('OSSMskLast') = 'UNDEFINED' THEN ; generated for fun
+OSSMskLast		equ			OSSMskRPU				;offset to last interrupt mask register
+	ENDIF ; generated for fun
+
+	IF &TYPE('rpuReset') = 'UNDEFINED' THEN ; generated for fun
+rpuReset		EQU			$010					; RPU write offset to reset serial ptr					<4.9>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OSSIntStat') = 'UNDEFINED' THEN ; generated for fun
+OSSIntStat		equ			$202					;offset to interrupt status register. Bits are:			<3.7>
+	ENDIF ; generated for fun
+													;  15:  interrupt 15 (spare) pending
+													;  14:  interrupt 14 (RPU) pending						<4.8>
+													;  13:  interrupt 13 (spare) pending					<5.1>
+													;  12:  interrupt 12 (RTC) pending
+													;  11:  interrupt 11 (VIA1) pending
+													;  10:  interrupt 10 (60 Hz) pending
+													;   9:  interrupt 9 (SCSI) pending
+													;   8:  interrupt 8 (sound) pending
+													;   7:  interrupt 7 (SCC PIC) pending
+													;   6:  interrupt 6 (SWIM PIC) pending
+													;   5:  interrupt 5 (slot E) pending
+													;   4:  interrupt 4 (slot D) pending
+													;   3:  interrupt 3 (slot C) pending
+													;   2:  interrupt 2 (slot B) pending
+													;   1:  interrupt 1 (slot A) pending
+													;   0:  interrupt 0 (slot 9) pending
+
+;••••• NOTE: In the new OSS, the interrupt status register is a long word starting at $200.			<3.7>
+;•••••		 Since only the low-order word is currently used, making a single change here			<3.7>
+;•••••		 has less impact on the ROM sources.  When we permanently switch over to the			<3.7>
+;•••••		 new OSS hardware, then it may make sense to fix this equate and change all its			<3.7>
+;•••••		 uses from MOVE.Ws to MOVE.Ls.															<3.7>
+
+	IF &TYPE('OSSRomCntl') = 'UNDEFINED' THEN ; generated for fun
+OSSRomCntl		equ			$204					;offset to ROM control register.  Bits are:
+	ENDIF ; generated for fun
+													;  <to be specified - see Steve Ray's spec>				<2.0>
+
+	IF &TYPE('OSSPwrOff') = 'UNDEFINED' THEN ; generated for fun
+OSSPwrOff		equ			OSSRomCntl				;power off is now a bit in the ROM control register		<5.1>
+	ENDIF ; generated for fun
+	IF &TYPE('OSSPwrOffBit') = 'UNDEFINED' THEN ; generated for fun
+OSSPwrOffBit	equ			7						;    7:  write a 1 here to power off the machine		<2.1><3.7>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OSSCntrCntl') = 'UNDEFINED' THEN ; generated for fun
+OSSCntrCntl		equ			$205					;offset to counter control register.  Bits are
+	ENDIF ; generated for fun
+													;  7-2:  unused
+													;    1:  test control.  A 1 causes each 4 bit
+													;        counter segment to count in parallel
+													;    0:  counter hold.  A 1 holds current value
+													;        so all 64 bits can be read.  Hold doesn't
+													;        affect counting, though!
+
+	IF &TYPE('OSSInpStat') = 'UNDEFINED' THEN ; generated for fun
+OSSInpStat		equ			$206					;offset to input status register.  Bits are
+	ENDIF ; generated for fun
+													;  7-2:  not used, read as zero
+													;    1:  SCC write request. Not used if PIC present
+													;    0:  mini-phono device plugged in flag.  A 1
+													;        means a device IS plugged in.
+
+	IF &TYPE('OSS60HzAck') = 'UNDEFINED' THEN ; generated for fun
+OSS60HzAck		equ			$207					;offset to 'Clear 60 Hz interrupt flag' register.  Both	<3.7>
+	ENDIF ; generated for fun
+													; writes and reads clear it, so might as well write it.
+
+	IF &TYPE('OSSCounter') = 'UNDEFINED' THEN ; generated for fun
+OSSCounter		equ			$208					;offset to 64 bit counter register.  Low order 8
+	ENDIF ; generated for fun
+													;.bits are always read as zero (maybe not in future...)
+
+;  Bit numbers in OSS interrupt status register
+
+	IF &TYPE('OSSIntIOPSWIM') = 'UNDEFINED' THEN ; generated for fun
+OSSIntIOPSWIM	equ			6						;bit # of SWIM IOP in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntIOPSCC') = 'UNDEFINED' THEN ; generated for fun
+OSSIntIOPSCC	equ			7						;bit # of SCC IOP in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntSound') = 'UNDEFINED' THEN ; generated for fun
+OSSIntSound		equ			8						;bit # of ASC in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntSCSI') = 'UNDEFINED' THEN ; generated for fun
+OSSIntSCSI		equ			9						;bit # of SCSI in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntVBL60Hz') = 'UNDEFINED' THEN ; generated for fun
+OSSIntVBL60Hz	equ			10						;bit # of 60Hz VBL in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntVia1') = 'UNDEFINED' THEN ; generated for fun
+OSSIntVia1		equ			11						;bit # of VIA 1 in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntRTC') = 'UNDEFINED' THEN ; generated for fun
+OSSIntRTC		equ			12						;bit # of RTC in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntADB') = 'UNDEFINED' THEN ; generated for fun
+OSSIntADB		equ			13						;bit # of ADB in interrupt status register
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntRPU') = 'UNDEFINED' THEN ; generated for fun
+OSSIntRPU		equ			14						;bit # of RPU in interrupt status register		<4.8>
+	ENDIF ; generated for fun
+	IF &TYPE('OSSIntLast') = 'UNDEFINED' THEN ; generated for fun
+OSSIntLast		equ			14						;bit # of last interrupt source
+	ENDIF ; generated for fun
+
+	IF &TYPE('OSSRomInit') = 'UNDEFINED' THEN ; generated for fun
+OSSRomInit		EQU			$D						; initial value for ROM control register<3.5>
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+;  IOP (Input Output Processor) Chip Offsets and bit definitions
+;---------------------------------------------------
+
+	IF &TYPE('iopRamAddrH') = 'UNDEFINED' THEN ; generated for fun
+iopRamAddrH		equ			$0000-$20				; high byte of shared RAM address register
+	ENDIF ; generated for fun
+	IF &TYPE('iopRamAddrL') = 'UNDEFINED' THEN ; generated for fun
+iopRamAddrL		equ			$0002-$20				; low byte of shared RAM address register
+	ENDIF ; generated for fun
+	IF &TYPE('iopRamAddr') = 'UNDEFINED' THEN ; generated for fun
+iopRamAddr		equ			iopRamAddrL-1			; WORD access to shared RAM address register
+	ENDIF ; generated for fun
+
+	IF &TYPE('iopRamData') = 'UNDEFINED' THEN ; generated for fun
+iopRamData		equ			$0008-$20				; shared RAM data register (byte, word, or long)
+	ENDIF ; generated for fun
+	IF &TYPE('iopStatCtl') = 'UNDEFINED' THEN ; generated for fun
+iopStatCtl		equ			$0004-$20				; IOP Status and Control register
+	ENDIF ; generated for fun
+
+;	bit numbers within the iopStatCtl register
+	IF &TYPE('iopInBypassMode') = 'UNDEFINED' THEN ; generated for fun
+iopInBypassMode	equ			0						; IOP is in BYPASS mode
+	ENDIF ; generated for fun
+	IF &TYPE('iopIncEnable') = 'UNDEFINED' THEN ; generated for fun
+iopIncEnable	equ			1						; enable addr pointer increment
+	ENDIF ; generated for fun
+	IF &TYPE('iopRun') = 'UNDEFINED' THEN ; generated for fun
+iopRun			equ			2						; 0 -> reset IOP, 1 -> run IOP
+	ENDIF ; generated for fun
+	IF &TYPE('iopGenInterrupt') = 'UNDEFINED' THEN ; generated for fun
+iopGenInterrupt	equ			3						; interrupt the IOP
+	ENDIF ; generated for fun
+	IF &TYPE('iopInt0Active') = 'UNDEFINED' THEN ; generated for fun
+iopInt0Active	equ			4						; interrupt 0 active
+	ENDIF ; generated for fun
+	IF &TYPE('iopInt1Active') = 'UNDEFINED' THEN ; generated for fun
+iopInt1Active	equ			5						; interrupt 1 active
+	ENDIF ; generated for fun
+	IF &TYPE('iopBypassIntReq') = 'UNDEFINED' THEN ; generated for fun
+iopBypassIntReq	equ			6						; peripheral chip interrupt request in bypass mode
+	ENDIF ; generated for fun
+	IF &TYPE('iopSCCWrReq') = 'UNDEFINED' THEN ; generated for fun
+iopSCCWrReq		equ			7						; 0 -> SCC REQ active, 1 -> inactive
+	ENDIF ; generated for fun
+
+;	commands bytes to write to the iopStatCtl register
+	IF &TYPE('setIopIncEnable') = 'UNDEFINED' THEN ; generated for fun
+setIopIncEnable	equ			(1<<iopIncEnable)|\		; set increment enable
+							(1<<iopRun)				; leave iop running
+	ENDIF ; generated for fun
+
+	IF &TYPE('clrIopIncEnable') = 'UNDEFINED' THEN ; generated for fun
+clrIopIncEnable	equ			(0<<iopIncEnable)|\		; reset increment enable
+							(1<<iopRun)				; leave iop running
+	ENDIF ; generated for fun
+
+	IF &TYPE('clrIopInt0') = 'UNDEFINED' THEN ; generated for fun
+clrIopInt0		equ			(1<<iopInt0Active)|\	; clear interrupt 0 active
+							(1<<iopRun)|\			; leave iop running
+							(1<<iopIncEnable)		; leave increment enabled
+	ENDIF ; generated for fun
+
+	IF &TYPE('clrIopInt1') = 'UNDEFINED' THEN ; generated for fun
+clrIopInt1		equ			(1<<iopInt1Active)|\	; clear interrupt 1 active
+							(1<<iopRun)|\			; leave iop running
+							(1<<iopIncEnable)		; leave increment enabled
+	ENDIF ; generated for fun
+
+	IF &TYPE('setIopGenInt') = 'UNDEFINED' THEN ; generated for fun
+setIopGenInt	equ			(1<<iopGenInterrupt)|\	; interrupt the IOP
+							(1<<iopRun)|\			; leave iop running
+							(1<<iopIncEnable)		; leave increment enabled
+	ENDIF ; generated for fun
+
+	IF &TYPE('resetIopRun') = 'UNDEFINED' THEN ; generated for fun
+resetIopRun		equ			(0<<iopRun)|\			; stop iop from running
+							(1<<iopInt0Active)|\	; clear interrupt 0 active
+							(1<<iopInt1Active)|\	; clear interrupt 1 active
+							(1<<iopIncEnable)		; set increment enable
+	ENDIF ; generated for fun
+
+	IF &TYPE('setIopRun') = 'UNDEFINED' THEN ; generated for fun
+setIopRun		equ			(1<<iopRun)|\			; start iop running
+							(1<<iopInt0Active)|\	; clear interrupt 0 active
+							(1<<iopInt1Active)|\	; clear interrupt 1 active
+							(1<<iopIncEnable)		; set increment enable
+	ENDIF ; generated for fun
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; VIA1 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
+; are grouped together.  New definitions for VIA1 pins are added such that the grouping is
+; maintained.
+;
+;
+;__________________________________________________________________________________________
+
+;---------------------------------------------------
+; 6522 VIA1 (and VIA2) register offsets
+;---------------------------------------------------
+
+	IF &TYPE('vBufB') = 'UNDEFINED' THEN ; generated for fun
+vBufB 			EQU 		0 						; BUFFER B
+	ENDIF ; generated for fun
+	IF &TYPE('vBufAH') = 'UNDEFINED' THEN ; generated for fun
+vBufAH			EQU 		$200  					; buffer a (with handshake) [ Dont use! ]
+	ENDIF ; generated for fun
+	IF &TYPE('vDIRB') = 'UNDEFINED' THEN ; generated for fun
+vDIRB 			EQU 		$400  					; DIRECTION B
+	ENDIF ; generated for fun
+	IF &TYPE('vDIRA') = 'UNDEFINED' THEN ; generated for fun
+vDIRA 			EQU 		$600  					; DIRECTION A
+	ENDIF ; generated for fun
+	IF &TYPE('vT1C') = 'UNDEFINED' THEN ; generated for fun
+vT1C  			EQU 		$800  					; TIMER 1 COUNTER (L.O.)
+	ENDIF ; generated for fun
+	IF &TYPE('vT1CH') = 'UNDEFINED' THEN ; generated for fun
+vT1CH 			EQU 		$A00  					; timer 1 counter (high order)
+	ENDIF ; generated for fun
+	IF &TYPE('vT1L') = 'UNDEFINED' THEN ; generated for fun
+vT1L  			EQU 		$C00  					; TIMER 1 LATCH (L.O.)
+	ENDIF ; generated for fun
+	IF &TYPE('vT1LH') = 'UNDEFINED' THEN ; generated for fun
+vT1LH 			EQU 		$E00  					; timer 1 latch (high order)
+	ENDIF ; generated for fun
+	IF &TYPE('vT2C') = 'UNDEFINED' THEN ; generated for fun
+vT2C  			EQU 		$1000 					; TIMER 2 LATCH (L.O.)
+	ENDIF ; generated for fun
+	IF &TYPE('vT2CH') = 'UNDEFINED' THEN ; generated for fun
+vT2CH 			EQU 		$1200 					; timer 2 counter (high order)
+	ENDIF ; generated for fun
+	IF &TYPE('vSR') = 'UNDEFINED' THEN ; generated for fun
+vSR   			EQU 		$1400 					; SHIFT REGISTER
+	ENDIF ; generated for fun
+	IF &TYPE('vACR') = 'UNDEFINED' THEN ; generated for fun
+vACR  			EQU 		$1600 					; AUX. CONTROL REG.
+	ENDIF ; generated for fun
+	IF &TYPE('vPCR') = 'UNDEFINED' THEN ; generated for fun
+vPCR  			EQU 		$1800 					; PERIPH. CONTROL REG.
+	ENDIF ; generated for fun
+	IF &TYPE('vIFR') = 'UNDEFINED' THEN ; generated for fun
+vIFR  			EQU 		$1A00 					; INT. FLAG REG.
+	ENDIF ; generated for fun
+	IF &TYPE('vIER') = 'UNDEFINED' THEN ; generated for fun
+vIER  			EQU 		$1C00 					; INT. ENABLE REG.
+	ENDIF ; generated for fun
+	IF &TYPE('vBufA') = 'UNDEFINED' THEN ; generated for fun
+vBufA 			EQU 		$1E00 					; BUFFER A
+	ENDIF ; generated for fun
+	IF &TYPE('vBufD') = 'UNDEFINED' THEN ; generated for fun
+vBufD 			EQU 		vBufA 					; disk head select is buffer A			<3.5>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; VIA IFR/IER bits
+;---------------------------------------------------
+
+	IF &TYPE('ifCA2') = 'UNDEFINED' THEN ; generated for fun
+ifCA2 			EQU 		0 						; CA2 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifCA1') = 'UNDEFINED' THEN ; generated for fun
+ifCA1 			EQU 		1 						; CA1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifSR') = 'UNDEFINED' THEN ; generated for fun
+ifSR  			EQU 		2 						; SR shift register done
+	ENDIF ; generated for fun
+	IF &TYPE('ifCB2') = 'UNDEFINED' THEN ; generated for fun
+ifCB2 			EQU 		3 						; CB2 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifCB1') = 'UNDEFINED' THEN ; generated for fun
+ifCB1 			EQU 		4 						; CB1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifT2') = 'UNDEFINED' THEN ; generated for fun
+ifT2  			EQU 		5 						; T2 timer2 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifT1') = 'UNDEFINED' THEN ; generated for fun
+ifT1  			EQU 		6 						; T1 timer1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('ifIRQ') = 'UNDEFINED' THEN ; generated for fun
+ifIRQ 			EQU 		7 						; any interrupt
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; VIA1 Port A definitions
+;---------------------------------------------------
+
+	IF &TYPE('vSound') = 'UNDEFINED' THEN ; generated for fun
+vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
+	ENDIF ; generated for fun
+
+	IF &TYPE('vTestJ') = 'UNDEFINED' THEN ; generated for fun
+vTestJ			EQU 		0 						; Burn In Test jumper		(input)
+	ENDIF ; generated for fun
+
+	IF &TYPE('vCpuId0') = 'UNDEFINED' THEN ; generated for fun
+vCpuId0			EQU			1						; CPU Identification bit 0	(input)
+	ENDIF ; generated for fun
+	IF &TYPE('vCpuId1') = 'UNDEFINED' THEN ; generated for fun
+vCpuId1			EQU			2						; CPU Identification bit 1	(input)
+	ENDIF ; generated for fun
+	IF &TYPE('vSync') = 'UNDEFINED' THEN ; generated for fun
+vSync 			EQU 		3 						; Synchronous modem
+	ENDIF ; generated for fun
+	IF &TYPE('vOverlay') = 'UNDEFINED' THEN ; generated for fun
+vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
+	ENDIF ; generated for fun
+	IF &TYPE('vCpuId2') = 'UNDEFINED' THEN ; generated for fun
+vCpuId2			EQU			4						; CPU Identification bit 2
+	ENDIF ; generated for fun
+	IF &TYPE('vReqAEnable') = 'UNDEFINED' THEN ; generated for fun
+vReqAEnable		EQU			4						; enable ReqA into vSCCWrReq (PSC only)		<LW2>
+	ENDIF ; generated for fun
+	IF &TYPE('vHeadSel') = 'UNDEFINED' THEN ; generated for fun
+vHeadSel  		EQU 		5 						; head select line for Sony
+	ENDIF ; generated for fun
+	IF &TYPE('vCpuId3') = 'UNDEFINED' THEN ; generated for fun
+vCpuId3			EQU			6						; CPU Identification bit 3
+	ENDIF ; generated for fun
+	IF &TYPE('vRev8Bd') = 'UNDEFINED' THEN ; generated for fun
+vRev8Bd   		EQU 		6 						; =0 for rev 8 board>
+	ENDIF ; generated for fun
+	IF &TYPE('vReqBEnable') = 'UNDEFINED' THEN ; generated for fun
+vReqBEnable		EQU			6						; enable ReqB into vSCCWrReq (PSC only)		<LW2>
+	ENDIF ; generated for fun
+	IF &TYPE('vSCCWrReq') = 'UNDEFINED' THEN ; generated for fun
+vSCCWrReq 		EQU 		7 						; SCC write/request line
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; VIA1 Port B definitions
+;---------------------------------------------------
+
+	IF &TYPE('vEclipseLED') = 'UNDEFINED' THEN ; generated for fun
+vEclipseLED		EQU			0						; flashable Eclipse LED (how quaint!)		<23>
+	ENDIF ; generated for fun
+	IF &TYPE('vRTCData') = 'UNDEFINED' THEN ; generated for fun
+vRTCData  		EQU 		0 						; real time clock data
+	ENDIF ; generated for fun
+	IF &TYPE('vRMP0') = 'UNDEFINED' THEN ; generated for fun
+vRMP0			EQU			0						; Reserved for RMP (PSC only)
+	ENDIF ; generated for fun
+	IF &TYPE('vRTCClk') = 'UNDEFINED' THEN ; generated for fun
+vRTCClk   		EQU 		1 						; real time clock clock pulses
+	ENDIF ; generated for fun
+	IF &TYPE('vRMP1') = 'UNDEFINED' THEN ; generated for fun
+vRMP1			EQU			1						; Reserved for RMP (PSC only)
+	ENDIF ; generated for fun
+	IF &TYPE('vRTCEnb') = 'UNDEFINED' THEN ; generated for fun
+vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
+	ENDIF ; generated for fun
+	IF &TYPE('vRMP2') = 'UNDEFINED' THEN ; generated for fun
+vRMP2			EQU			2						; Reserved for RMP (PSC only)
+	ENDIF ; generated for fun
+	IF &TYPE('vFDBInt') = 'UNDEFINED' THEN ; generated for fun
+vFDBInt   		EQU 		3 						; Front Desk bus interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('vXcvrsesbit') = 'UNDEFINED' THEN ; generated for fun
+vXcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
+	ENDIF ; generated for fun
+	IF &TYPE('vSDMCable') = 'UNDEFINED' THEN ; generated for fun
+vSDMCable		EQU			3						; SCSI DiskMode cable sense for Dartanian	<H15>
+	ENDIF ; generated for fun
+	IF &TYPE('vCudaTREQ') = 'UNDEFINED' THEN ; generated for fun
+vCudaTREQ		EQU			3						; Cuda transaction request input		<P2><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('vSDMDiskID') = 'UNDEFINED' THEN ; generated for fun
+vSDMDiskID		EQU			4						; DiskMode HD ID (bits 4-6) for Dartanian	<H15>
+	ENDIF ; generated for fun
+	IF &TYPE('vFDesk1') = 'UNDEFINED' THEN ; generated for fun
+vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
+	ENDIF ; generated for fun
+	IF &TYPE('vViafullbit') = 'UNDEFINED' THEN ; generated for fun
+vViafullbit		EQU			4						; Egret via full bit					<6>
+	ENDIF ; generated for fun
+	IF &TYPE('vCudaBYTEACK') = 'UNDEFINED' THEN ; generated for fun
+vCudaBYTEACK	EQU			4						; Cuda byte acknowledge output			<P2><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('vFDesk2') = 'UNDEFINED' THEN ; generated for fun
+vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('vSyssesbit') = 'UNDEFINED' THEN ; generated for fun
+vSyssesbit		EQU			5						; Egret system session bit				<6><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('vCudaTIP') = 'UNDEFINED' THEN ; generated for fun
+vCudaTIP		EQU			5						; Cuda interface transaction in progress output <P2>
+	ENDIF ; generated for fun
+	IF &TYPE('vAUXIntEnb') = 'UNDEFINED' THEN ; generated for fun
+vAUXIntEnb 		EQU 		6 						; switch to A/UX interrupt scheme (output)	<23>
+	ENDIF ; generated for fun
+	IF &TYPE('vPGCEnb') = 'UNDEFINED' THEN ; generated for fun
+vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
+	ENDIF ; generated for fun
+	IF &TYPE('vJMPDude6') = 'UNDEFINED' THEN ; generated for fun
+vJMPDude6		EQU			6						; Reserved for JMP (PSC only)
+	ENDIF ; generated for fun
+	IF &TYPE('vPGCErr') = 'UNDEFINED' THEN ; generated for fun
+vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
+	ENDIF ; generated for fun
+	IF &TYPE('vSndEnb') = 'UNDEFINED' THEN ; generated for fun
+vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
+	ENDIF ; generated for fun
+	IF &TYPE('vSWInt') = 'UNDEFINED' THEN ; generated for fun
+vSWInt	  		EQU 		7 						; cause a software interrupt	(output)	<23>
+	ENDIF ; generated for fun
+	IF &TYPE('vJMPDude7') = 'UNDEFINED' THEN ; generated for fun
+vJMPDude7		EQU			7						; Reserved for JMP (PSC only)
+	ENDIF ; generated for fun
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; VIA2 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
+; are grouped together.  New definitions for VIA2 pins are added such that the grouping is
+; maintained.
+;
+;
+;__________________________________________________________________________________________
+
+;---------------------------------------------------
+; VIA2 Port A definitions
+;---------------------------------------------------
+
+	IF &TYPE('v2IRQ1') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ1			EQU 		0 						; slot 1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2EnetIRQ') = 'UNDEFINED' THEN ; generated for fun
+v2EnetIRQ		EQU			0						; on-board ethernet								<8><23>
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ2') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ2			EQU 		1 						; slot 2 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ3') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ3			EQU 		2 						; slot 3 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ4') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ4			EQU 		3 						; slot 4 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ5') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ5			EQU 		4 						; slot 5 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2IRQ6') = 'UNDEFINED' THEN ; generated for fun
+v2IRQ6			EQU 		5 						; slot 6 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('v2RAM0') = 'UNDEFINED' THEN ; generated for fun
+v2RAM0			EQU 		6 						; RAM size bit 0
+	ENDIF ; generated for fun
+	IF &TYPE('v2LCDIRQ') = 'UNDEFINED' THEN ; generated for fun
+v2LCDIRQ		EQU			6						; on-board LCD video
+	ENDIF ; generated for fun
+	IF &TYPE('v2VideoIRQ') = 'UNDEFINED' THEN ; generated for fun
+v2VideoIRQ		EQU			6						; on-board video								<8><23>
+	ENDIF ; generated for fun
+	IF &TYPE('v2RAM1') = 'UNDEFINED' THEN ; generated for fun
+v2RAM1			EQU 		7 						; RAM size bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('v2CardIn') = 'UNDEFINED' THEN ; generated for fun
+v2CardIn		EQU			7						; on-board video
+	ENDIF ; generated for fun
+	IF &TYPE('v2SyncOnGreen') = 'UNDEFINED' THEN ; generated for fun
+v2SyncOnGreen	EQU			7						; for enabling/disabling Sync-on-Green (DAFB)	<T20>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; VIA2 Port B definitions
+;---------------------------------------------------
+
+	IF &TYPE('v2ConfigLE') = 'UNDEFINED' THEN ; generated for fun
+v2ConfigLE		EQU			0						; DFAC config latch enable						<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('v2CDis') = 'UNDEFINED' THEN ; generated for fun
+v2CDis			EQU 		0 						; cache disable (when 1)	<3.3>
+	ENDIF ; generated for fun
+	IF &TYPE('v2Keyswitch') = 'UNDEFINED' THEN ; generated for fun
+v2Keyswitch		EQU			0						; 900/950 ONLY - keyswitch shadow bit (1=SECURE)<T14><T17><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('v2BusLk') = 'UNDEFINED' THEN ; generated for fun
+v2BusLk   		EQU 		1 						; Bus lockout
+	ENDIF ; generated for fun
+	IF &TYPE('v2PMack') = 'UNDEFINED' THEN ; generated for fun
+v2PMack			EQU 		1 						; Power manager handshake acknowledge
+	ENDIF ; generated for fun
+	IF &TYPE('v2PowerOff') = 'UNDEFINED' THEN ; generated for fun
+v2PowerOff		EQU 		2 						; soft power off signal (when 0)
+	ENDIF ; generated for fun
+													; (also 900/950 keyswitch OFF bit)				<T17><SM4> rb
+	IF &TYPE('v2PMreq') = 'UNDEFINED' THEN ; generated for fun
+v2PMreq			EQU 		2 						; Power manager handshake request
+	ENDIF ; generated for fun
+	IF &TYPE('v2ConfigData') = 'UNDEFINED' THEN ; generated for fun
+v2ConfigData 	EQU 		3 						; DFAC config data								<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('v2FC3') = 'UNDEFINED' THEN ; generated for fun
+v2FC3  			EQU 		3 						; PMMU FC3 indicator
+	ENDIF ; generated for fun
+	IF &TYPE('vFC3') = 'UNDEFINED' THEN ; generated for fun
+vFC3  			EQU 		3 						; PMMU FC3 indicator
+	ENDIF ; generated for fun
+	IF &TYPE('v2SndInSel0') = 'UNDEFINED' THEN ; generated for fun
+v2SndInSel0		EQU			3						; Eclipse only - sound input select bit 0		<t19><H17>
+	ENDIF ; generated for fun
+	IF &TYPE('v2ConfigClk') = 'UNDEFINED' THEN ; generated for fun
+v2ConfigClk		EQU 		4 						; DFAC config clock								<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('v2TM1A') = 'UNDEFINED' THEN ; generated for fun
+v2TM1A			EQU 		4 						; bit for NUBus
+	ENDIF ; generated for fun
+	IF &TYPE('v2TM0A') = 'UNDEFINED' THEN ; generated for fun
+v2TM0A			EQU 		5 						; and another
+	ENDIF ; generated for fun
+	IF &TYPE('v2Speed') = 'UNDEFINED' THEN ; generated for fun
+v2Speed			EQU 		5 						; 25/33 Mhz 68040 input (0=25MHz, 1=33 MHz)
+	ENDIF ; generated for fun
+	IF &TYPE('v2MicCtl') = 'UNDEFINED' THEN ; generated for fun
+v2MicCtl		EQU			5						; microphone control on Wombats					<H17><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('v2HMMU') = 'UNDEFINED' THEN ; generated for fun
+v2HMMU			EQU			5 						; HMMU 24/32									<15> HJR
+	ENDIF ; generated for fun
+	IF &TYPE('v2CDis2') = 'UNDEFINED' THEN ; generated for fun
+v2CDis2			EQU			6						; On Tim the CDIS is on pb6						<15> HJR
+	ENDIF ; generated for fun
+	IF &TYPE('v2SndExt') = 'UNDEFINED' THEN ; generated for fun
+v2SndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio
+	ENDIF ; generated for fun
+	IF &TYPE('v2SndInSel1') = 'UNDEFINED' THEN ; generated for fun
+v2SndInSel1		EQU			6						; Q900/950 only - sound input select bit 1		<t19><SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('v2VBL') = 'UNDEFINED' THEN ; generated for fun
+v2VBL 			EQU 		7 						; pseudo VBL signal
+	ENDIF ; generated for fun
+	IF &TYPE('v2ModemRST') = 'UNDEFINED' THEN ; generated for fun
+v2ModemRST		EQU			7						; Modem.Reset									<15> HJR
+	ENDIF ; generated for fun
+
+
+
+													; temporary Cyclone equates <SM4> rb, start, <SM5> rb
+
+
+; <SM7> rb, • TEMP EQUATES
+
+	IF &TYPE('CycloneEVT1Reg') = 'UNDEFINED' THEN ; generated for fun
+CycloneEVT1Reg	EQU			$A55A2800				; id which identifies an EVT1 cyclone in CPURegID <SM9> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2SIntEVT1') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2SIntEVT1	EQU			$000					; Slot interrupt reg. offset					<SM9> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2IFREVT1') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2IFREVT1	EQU			$004					; VIA2 interrupt flag reg. offset				<SM9> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2IEREVT1') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2IEREVT1	EQU			$008					; VIA2 interrupt enable reg. offset				<SM9> rb
+	ENDIF ; generated for fun
+
+	IF &TYPE('PSCVIA2SInt') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2SInt		EQU			$1E00					; Slot interrupt reg. offset					<SM7> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2IFR') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2IFR		EQU			$1A00					; VIA2 interrupt flag reg. offset				<SM7> rb
+	ENDIF ; generated for fun
+	IF &TYPE('PSCVIA2IER') = 'UNDEFINED' THEN ; generated for fun
+PSCVIA2IER		EQU			$1C00					; VIA2 interrupt enable reg. offset				<SM7> rb
+	ENDIF ; generated for fun
+
+
+; PSC VIA2 Slot Interrupt Register equates
+	IF &TYPE('PSCSlotC') = 'UNDEFINED' THEN ; generated for fun
+PSCSlotC		EQU			3						; slot C int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSlotD') = 'UNDEFINED' THEN ; generated for fun
+PSCSlotD		EQU			4						; slot D int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSlotE') = 'UNDEFINED' THEN ; generated for fun
+PSCSlotE		EQU			5						; slot E int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCOVBVBL') = 'UNDEFINED' THEN ; generated for fun
+PSCOVBVBL		EQU			6						; on-board video vbl int.
+	ENDIF ; generated for fun
+
+; PSC VIA2 Interrupt Flag and Interrupt Enable Registers equates
+	IF &TYPE('PSCSCSI0') = 'UNDEFINED' THEN ; generated for fun
+PSCSCSI0		EQU			0						; SCSI int., same as bit 3
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSlot') = 'UNDEFINED' THEN ; generated for fun
+PSCSlot			EQU			1						; any slot int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCMUNI') = 'UNDEFINED' THEN ; generated for fun
+PSCMUNI			EQU			2						; MUNI int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSCSI3') = 'UNDEFINED' THEN ; generated for fun
+PSCSCSI3		EQU			3						; SCSI int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCFDC') = 'UNDEFINED' THEN ; generated for fun
+PSCFDC			EQU			5						; floppy int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCSNDFRM') = 'UNDEFINED' THEN ; generated for fun
+PSCSNDFRM		EQU			6						; sound frame int.
+	ENDIF ; generated for fun
+	IF &TYPE('PSCANY') = 'UNDEFINED' THEN ; generated for fun
+PSCANY			EQU			7						; any of the above
+	ENDIF ; generated for fun
+
+													; <SM4> rb, end, <SM5> rb
+
+
+;----------
+;RBV (Ram Based Video) register definitions
+;----------
+
+	IF &TYPE('RvDataB') = 'UNDEFINED' THEN ; generated for fun
+RvDataB			EQU			$000					; VIA2 data reg. B equivalent	<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvExp') = 'UNDEFINED' THEN ; generated for fun
+RvExp			EQU			$001					; RBV Expansion Register		<3>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSInt') = 'UNDEFINED' THEN ; generated for fun
+RvSInt			EQU			$002					; Slot interrupts reg.			<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIFR') = 'UNDEFINED' THEN ; generated for fun
+RvIFR			EQU			$003					; interrupt flag reg.			<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvMonP') = 'UNDEFINED' THEN ; generated for fun
+RvMonP			EQU			$010					; monitor parameters reg.		<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvChpT') = 'UNDEFINED' THEN ; generated for fun
+RvChpT			EQU			$011					; chip test reg.				<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSEnb') = 'UNDEFINED' THEN ; generated for fun
+RvSEnb			EQU			$012					; Slot interrupt enable reg.	<v1.4><2.5>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIER') = 'UNDEFINED' THEN ; generated for fun
+RvIER			EQU			$013					; interrupt flag enable reg.	<v1.4><2.5>
+	ENDIF ; generated for fun
+
+;----------
+;Common Via 2 and RBV (Ram Based Video) register offsets
+;----------
+
+
+	IF &TYPE('Rv2DataB') = 'UNDEFINED' THEN ; generated for fun
+Rv2DataB		EQU			vBufB++RvDataB			; RBV/VIA2 data reg. B equivalent	<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2Exp') = 'UNDEFINED' THEN ; generated for fun
+Rv2Exp			EQU			RvExp					; RBV Expansion Register			<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2SInt') = 'UNDEFINED' THEN ; generated for fun
+Rv2SInt			EQU			RvSInt					; Slot interrupts reg.				<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2IFR') = 'UNDEFINED' THEN ; generated for fun
+Rv2IFR			EQU			vIFR++RvIFR				; RBV/VIA2 interrupt flag reg.		<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2MonP') = 'UNDEFINED' THEN ; generated for fun
+Rv2MonP			EQU			RvMonP					; monitor parameters reg.			<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2ChpT') = 'UNDEFINED' THEN ; generated for fun
+Rv2ChpT			EQU			RvChpT					; chip test reg.					<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2SEnb') = 'UNDEFINED' THEN ; generated for fun
+Rv2SEnb			EQU			RvSEnb					; Slot interrupt enable reg.		<H8>
+	ENDIF ; generated for fun
+	IF &TYPE('Rv2IER') = 'UNDEFINED' THEN ; generated for fun
+Rv2IER			EQU			vIER++RvIER				; iRBV/VIA2 interrupt enable reg.	<H8>
+	ENDIF ; generated for fun
+
+
+;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====									<v1.4>
+	IF &TYPE('RvCDis') = 'UNDEFINED' THEN ; generated for fun
+RvCDis			EQU 		0 						; cache disable (when 1)					<v1.4><3.3>
+	ENDIF ; generated for fun
+	IF &TYPE('RvBusLk') = 'UNDEFINED' THEN ; generated for fun
+RvBusLk   		EQU 		1 						; Bus lockout								<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvPowerOff') = 'UNDEFINED' THEN ; generated for fun
+RvPowerOff		EQU 		2 						; soft power off signal (when 0)			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvCFlush') = 'UNDEFINED' THEN ; generated for fun
+RvCFlush		EQU 		3 						; Flush external cache (when 0)				<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvTM1A') = 'UNDEFINED' THEN ; generated for fun
+RvTM1A			EQU 		4 						; bit for NUBus								<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvTM0A') = 'UNDEFINED' THEN ; generated for fun
+RvTM0A			EQU 		5 						; and another								<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSndExt') = 'UNDEFINED' THEN ; generated for fun
+RvSndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio		<v1.4>
+	ENDIF ; generated for fun
+													; jack in use								<v1.4>
+	IF &TYPE('RvPGCTest') = 'UNDEFINED' THEN ; generated for fun
+RvPGCTest		EQU			7						; 1 = generate good parity, 0 = generate errors
+	ENDIF ; generated for fun
+
+;  ======  Future Expansion   Address: $50026001	 =====										<v1.4>
+
+;  ======  Slot Interrupts   Address: $50026002	 =====											<v1.4>
+	IF &TYPE('RvIRQ1') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ1			EQU 		0 						; slot 1 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ2') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ2			EQU 		1 						; slot 2 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ3') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ3			EQU 		2 						; slot 3 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ4') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ4			EQU 		3 						; slot 4 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ5') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ5			EQU 		4 						; slot 5 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ6') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ6			EQU 		5 						; slot 6 interrupt							<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ0') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ0			EQU 		6 						; slot 0 interrupt or internal video 		<v1.4>
+	ENDIF ; generated for fun
+													; blanking interrupt						<v1.4>
+;RvResr			EQU 		7 						; reserved 									<v1.4>
+
+;  ======  Interrupt Flags   Address: $50026003	 =====											<v1.4>
+	IF &TYPE('RvSCSIDRQ') = 'UNDEFINED' THEN ; generated for fun
+RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvAnySlot') = 'UNDEFINED' THEN ; generated for fun
+RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvExpIRQ') = 'UNDEFINED' THEN ; generated for fun
+RvExpIRQ		EQU			2						; 1 = expansion int. (reserved)				<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSCSIRQ') = 'UNDEFINED' THEN ; generated for fun
+RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSndIRQ') = 'UNDEFINED' THEN ; generated for fun
+RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup				<v1.4>
+	ENDIF ; generated for fun
+;RvResr			EQU 		5 						; reserved 									<v1.4>
+;RvResr			EQU 		6 						; reserved									<v1.4>
+;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt			<v1.4>
+													; on WRITE, 1 = 1-bits in bits 0-6 write 1's<v1.4>
+													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>
+
+;  ======  Monitor Parameters   Address: $50026010	 =====										<v1.4>
+	IF &TYPE('RvColor1') = 'UNDEFINED' THEN ; generated for fun
+RvColor1		EQU			0						; (lsb) R/W 000 = 1bit, 001 = 2 bit			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvColor2') = 'UNDEFINED' THEN ; generated for fun
+RvColor2		EQU			1						; 		R/W 010 = 4bit, 011 = 8 bit			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvColor3') = 'UNDEFINED' THEN ; generated for fun
+RvColor3		EQU			2						; (msb) Read 1xx = Reserved					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvMonID1') = 'UNDEFINED' THEN ; generated for fun
+RvMonID1		EQU			3						; READ 000,011,100=reserved; x01=15" monitor<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvMonID2') = 'UNDEFINED' THEN ; generated for fun
+RvMonID2		EQU			4						; 010=Mod'IIGSmonitor;110=MacII monitors	<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvMonID3') = 'UNDEFINED' THEN ; generated for fun
+RvMonID3		EQU 		5 						; 111= 9" build in monitor					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvVIDOff') = 'UNDEFINED' THEN ; generated for fun
+RvVIDOff		EQU 		6 						; 1 = Video off								<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvVID3St') = 'UNDEFINED' THEN ; generated for fun
+RvVID3St		EQU			7						; 1 = all video outputs tri-stated			<v1.4>
+	ENDIF ; generated for fun
+
+;  ======  Chip Test   Address: $50026011	 =====												<v1.4>
+	IF &TYPE('RvC60') = 'UNDEFINED' THEN ; generated for fun
+RvC60			EQU			0						; 1 = C60 clock run 128 x normal			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSpd1') = 'UNDEFINED' THEN ; generated for fun
+RvSpd1			EQU			1						; (lsb) 00 = normal, 01=medium				<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSpd2') = 'UNDEFINED' THEN ; generated for fun
+RvSpd2			EQU			2						; (msb) 10 = fast, 11 = very fast			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvHndShk3') = 'UNDEFINED' THEN ; generated for fun
+RvHndShk3		EQU			3						; 1=VID.REQ & VID.RES tri-stated			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIOClk3') = 'UNDEFINED' THEN ; generated for fun
+RvIOClk3		EQU			4						; 1=C16M, C8M, C3.7M tri-stated				<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvC30M') = 'UNDEFINED' THEN ; generated for fun
+RvC30M			EQU 		5 						; 1=30.24 mHz clock for all monitors		<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSDTClk') = 'UNDEFINED' THEN ; generated for fun
+RvSDTClk		EQU 		6 						; 1 = Dot clock halted						<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvTstRes') = 'UNDEFINED' THEN ; generated for fun
+RvTstRes		EQU			7						; 1 = reset video counters					<v1.4>
+	ENDIF ; generated for fun
+
+;  ======  Slot Interrupts Enable   Address: $50026012	 =====									<v1.4>
+	IF &TYPE('RvIRQ1En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ1En		EQU 		0 						; slot 1 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ2En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ2En		EQU 		1 						; slot 2 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ3En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ3En		EQU 		2 						; slot 3 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ4En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ4En		EQU 		3 						; slot 4 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ5En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ5En		EQU 		4 						; slot 5 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ6En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ6En		EQU 		5 						; slot 6 interrupt enabled					<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvIRQ0En') = 'UNDEFINED' THEN ; generated for fun
+RvIRQ0En		EQU 		6 						; slot 0 interrupt or internal video enabled<v1.4>
+	ENDIF ; generated for fun
+;RvSetClr		EQU			7						; on READs, always reads 0					<v1.4>
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
+													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>
+
+;  ======  Interrupt Flags Enable   Address: $50026013	 =====
+	IF &TYPE('RvSCSIDRQEn') = 'UNDEFINED' THEN ; generated for fun
+RvSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvAnySlotEn') = 'UNDEFINED' THEN ; generated for fun
+RvAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled		<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvExpIRQEn') = 'UNDEFINED' THEN ; generated for fun
+RvExpIRQEn		EQU			2						; 1 = expansion int. (reserved) enabled		<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSCSIRQEn') = 'UNDEFINED' THEN ; generated for fun
+RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled			<v1.4>
+	ENDIF ; generated for fun
+	IF &TYPE('RvSndIRQEn') = 'UNDEFINED' THEN ; generated for fun
+RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled	<v1.4>
+	ENDIF ; generated for fun
+;RvResr			EQU 		5 						; reserved 									<v1.4>
+;RvResr			EQU 		6 						; reserved									<v1.4>
+;RvSetClr		EQU			7						; on READs, always reads 1					<v1.4>
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
+													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>
+
+;----------
+; VDAC register definitions
+;----------
+
+	IF &TYPE('vDACwAddReg') = 'UNDEFINED' THEN ; generated for fun
+vDACwAddReg		EQU			$0000					;   offset from vDACBase for write address reg
+	ENDIF ; generated for fun
+	IF &TYPE('vDACrAddReg') = 'UNDEFINED' THEN ; generated for fun
+vDACrAddReg		EQU			$000C					;   offset from vDACBase for read address register <v4.2>
+	ENDIF ; generated for fun
+	IF &TYPE('vDACwDataReg') = 'UNDEFINED' THEN ; generated for fun
+vDACwDataReg	EQU			$0004					;   offset from vDACBase for write data reg
+	ENDIF ; generated for fun
+
+	IF &TYPE('vDACPixRdMask') = 'UNDEFINED' THEN ; generated for fun
+vDACPixRdMask	EQU			$0008					;   offset from vDACBase for pixel mask
+	ENDIF ; generated for fun
+
+
+;__________________________________________________________________________________________
+;
+;
+; VISA Pin Definitions and Register Offsets - Multiple names for the same pin are grouped
+; together.  New definitions for VISA pins are added such that the grouping is maintained.
+;
+;
+;__________________________________________________________________________________________
+
+
+;----------
+; VISA register definitions - generally, these equates are a precise subset
+;		of the RBV equates.
+;----------
+
+; these registers are accessed off of VIA1 lomem
+	IF &TYPE('VsData1A') = 'UNDEFINED' THEN ; generated for fun
+VsData1A		EQU		  	$1E00					; VIA1 data reg A
+	ENDIF ; generated for fun
+	IF &TYPE('VsData1B') = 'UNDEFINED' THEN ; generated for fun
+VsData1B		EQU			$0000					; VIA1 data reg B
+	ENDIF ; generated for fun
+
+; these registers are accessed off of VISA lomem
+	IF &TYPE('VsData2B') = 'UNDEFINED' THEN ; generated for fun
+VsData2B		EQU			$000					; VIA2 data reg B equivalent
+	ENDIF ; generated for fun
+	IF &TYPE('VsExp') = 'UNDEFINED' THEN ; generated for fun
+VsExp			EQU			$001					; VISA Expansion Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsSInt') = 'UNDEFINED' THEN ; generated for fun
+VsSInt			EQU			$002					; Slot Interrupt Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsIFR') = 'UNDEFINED' THEN ; generated for fun
+VsIFR			EQU			$003					; Interrupt Flag Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsMonP') = 'UNDEFINED' THEN ; generated for fun
+VsMonP			EQU			$010					; Monitor Parameters Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsSEnb') = 'UNDEFINED' THEN ; generated for fun
+VsSEnb			EQU			$012					; Slot Interrupt Enable Register
+	ENDIF ; generated for fun
+	IF &TYPE('VsIER') = 'UNDEFINED' THEN ; generated for fun
+VsIER			EQU			$013					; Interrupt Flag Enable Register
+	ENDIF ; generated for fun
+
+;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====
+;*VsResr		EQU			0						; reserved
+;*VsResr		EQU			1						; reserved
+;*VsResr		EQU			2						; reserved
+	IF &TYPE('VsFC3') = 'UNDEFINED' THEN ; generated for fun
+VsFC3			EQU			3						; select 32-bit map.  0=24 bit, 1=32 bit
+	ENDIF ; generated for fun
+;*VsResr		EQU			4						; reserved
+;*VsResr		EQU			5						; reserved
+	IF &TYPE('VsSndExt') = 'UNDEFINED' THEN ; generated for fun
+VsSndExt		EQU			6						; Always reads as 1 - play sounds in Mono
+	ENDIF ; generated for fun
+;*VsResr		EQU			7						; reserved
+
+;  ======  Future Expansion   Address: $50026001	 =====
+	IF &TYPE('VsA2Mode') = 'UNDEFINED' THEN ; generated for fun
+VsA2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
+	ENDIF ; generated for fun
+	IF &TYPE('VsVResEn') = 'UNDEFINED' THEN ; generated for fun
+VsVResEn		EQU			1						; 1=enable vertical counter reset for video genlock
+	ENDIF ; generated for fun
+	IF &TYPE('VsFlWrEn') = 'UNDEFINED' THEN ; generated for fun
+VsFlWrEn	 	EQU			2						; 1=enable writes to flash EEPROM
+	ENDIF ; generated for fun
+	IF &TYPE('Vs1BV') = 'UNDEFINED' THEN ; generated for fun
+Vs1BV			EQU			3						; 1=low base for 1-bit mode, 0=high base
+	ENDIF ; generated for fun
+	IF &TYPE('VsPg2') = 'UNDEFINED' THEN ; generated for fun
+VsPg2			EQU			4						; 1=main video page, 0=sec video page
+	ENDIF ; generated for fun
+;*VsResr		EQU			5						; reserved
+	IF &TYPE('VsSiz0') = 'UNDEFINED' THEN ; generated for fun
+VsSiz0			EQU			6						; RAM size control bit 00=1MB, 01=1.5MB
+	ENDIF ; generated for fun
+	IF &TYPE('VsSiz1') = 'UNDEFINED' THEN ; generated for fun
+VsSiz1			EQU			7						; 	10=3MB,11=9MB
+	ENDIF ; generated for fun
+
+;  ======  Slot Interrupts   Address: $50026002	 =====
+;*VsResr		EQU			0						; reserved
+;*VsResr		EQU			1						; reserved
+;*VsResr		EQU			2						; reserved
+;*VsResr		EQU			3						; reserved
+;*VsResr		EQU			4						; reserved
+	IF &TYPE('VsSIRQ') = 'UNDEFINED' THEN ; generated for fun
+VsSIRQ			EQU			5						; expansion slot interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('VsVBLInt') = 'UNDEFINED' THEN ; generated for fun
+VsVBLInt		EQU			6						; slot zero (built-in) VBL interrupt
+	ENDIF ; generated for fun
+;*VsResr		EQU			7						; reserved
+
+
+;  ======  Interrupt Flags   Address: $50026003	 =====
+	IF &TYPE('VsSCSIDRQ') = 'UNDEFINED' THEN ; generated for fun
+VsSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrup
+	ENDIF ; generated for fun
+	IF &TYPE('VsAnySlot') = 'UNDEFINED' THEN ; generated for fun
+VsAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
+	ENDIF ; generated for fun
+;*VsResr		EQU			2						; reserved
+	IF &TYPE('VsSCSIRQ') = 'UNDEFINED' THEN ; generated for fun
+VsSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('VsSndIRQ') = 'UNDEFINED' THEN ; generated for fun
+VsSndIRQ		EQU			4						; 1 = Apple Sound Chip interrupt
+	ENDIF ; generated for fun
+;RvResr			EQU 		5 						; reserved
+;RvResr			EQU 		6 						; reserved
+	IF &TYPE('RvSetClr') = 'UNDEFINED' THEN ; generated for fun
+RvSetClr		EQU			7						; on READ, 1 = any enabled interrupt
+	ENDIF ; generated for fun
+													; on WRITE, 1 = 1-bits in bits 0-6 write 1's
+													;  			0 = 1-bits in bits 0-6 write 0's
+
+;  ======  Monitor Parameters   Address: $50026010	 =====
+;*VsResr		EQU			0						; (lsb)
+	IF &TYPE('VsColor') = 'UNDEFINED' THEN ; generated for fun
+VsColor			EQU			1						; (compat w/RBV) R/W 000 = 1bit, R/W 010 = 4bit
+	ENDIF ; generated for fun
+;*VsResr		EQU			2						; (msb)
+	IF &TYPE('VsMonConn') = 'UNDEFINED' THEN ; generated for fun
+VsMonConn		EQU			3						; (lsb)1=no monitor connected
+	ENDIF ; generated for fun
+;*VsResr		EQU			4						; (compat w/RBV)
+	IF &TYPE('VsMonSel') = 'UNDEFINED' THEN ; generated for fun
+VsMonSel		EQU 		5 						; (msb) Monitor select 1=Jersey, 0=Rubik
+	ENDIF ; generated for fun
+;*VsResr		EQU 		6 						; reserved
+;*VsResr		EQU			7						; reserved
+
+
+;  ======  Slot Interrupts Enable   Address: $50026012	 =====
+;*VsResr		EQU			0						; reserved
+;*VsResr		EQU			1						; reserved
+;*VsResr		EQU			2						; reserved
+;*VsResr		EQU			3						; reserved
+;*VsResr		EQU			4						; reserved
+	IF &TYPE('VsExtIRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('VsIntIRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsIntIRQEn		EQU 		6 						; internal video interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('VsSetClr') = 'UNDEFINED' THEN ; generated for fun
+VsSetClr		EQU			7						; on READs, always reads 0
+	ENDIF ; generated for fun
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
+													;  			0 = 1-bits in bits 0-6 write 0's
+
+;  ======  Interrupt Flags Enable   Address: $50026013	 =====
+	IF &TYPE('VsSCSIDRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('VsAnySlotEn') = 'UNDEFINED' THEN ; generated for fun
+VsAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled
+	ENDIF ; generated for fun
+;*VsResr		EQU			2						; reserved
+	IF &TYPE('VsSCSIRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('VsSndIRQEn') = 'UNDEFINED' THEN ; generated for fun
+VsSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
+	ENDIF ; generated for fun
+;VsResr			EQU 		5 						; reserved
+;VsResr			EQU 		6 						; reserved
+;RvSetClr		EQU			7						; on READs, always reads 1
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
+													;  			0 = 1-bits in bits 0-6 write 0's
+
+
+;----------
+; V8 register definitions - generally compatible with the VISA equates above, but a few equates
+;	have changed names.
+;----------
+
+; these registers are accessed off of the V8 lomem
+	IF &TYPE('V8Exp') = 'UNDEFINED' THEN ; generated for fun
+V8Exp			EQU			$001					; V8 Expansion Register
+	ENDIF ; generated for fun
+	IF &TYPE('V8SInt') = 'UNDEFINED' THEN ; generated for fun
+V8SInt			EQU			$002					; V8 Slot Interrupt Register
+	ENDIF ; generated for fun
+	IF &TYPE('V8MonP') = 'UNDEFINED' THEN ; generated for fun
+V8MonP			EQU			$010					; Monitor Parameters Register
+	ENDIF ; generated for fun
+	IF &TYPE('V8SEnb') = 'UNDEFINED' THEN ; generated for fun
+V8SEnb			EQU			$012					; Slot Interrupt Enable Register
+	ENDIF ; generated for fun
+
+;  ======  Future Expansion   Address: $50F26001	 =====
+	IF &TYPE('V8A2Mode') = 'UNDEFINED' THEN ; generated for fun
+V8A2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
+	ENDIF ; generated for fun
+	IF &TYPE('V8512Row') = 'UNDEFINED' THEN ; generated for fun
+V8512Row		EQU			1						; 1=V8 rowbytes is 256, 0=rowbytes is 512
+	ENDIF ; generated for fun
+	IF &TYPE('V8vRAMIn') = 'UNDEFINED' THEN ; generated for fun
+V8vRAMIn	 	EQU			2						; 1=refresh video from vRAM, 0=refresh from dRAM
+	ENDIF ; generated for fun
+;*V8Resr		EQU			3						; no 1BV on V8
+;*V8Resr		EQU			4						; no VP2 on V8
+	IF &TYPE('V8Siz0') = 'UNDEFINED' THEN ; generated for fun
+V8Siz0			EQU			5						; RAM size control bit 0
+	ENDIF ; generated for fun
+	IF &TYPE('V8Siz1') = 'UNDEFINED' THEN ; generated for fun
+V8Siz1			EQU			6						; RAM size control bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('V8Siz2') = 'UNDEFINED' THEN ; generated for fun
+V8Siz2			EQU			7						; RAM size control bit 2
+	ENDIF ; generated for fun
+
+;  ======  Monitor Parameters   Address: $50F26010	 =====
+	IF &TYPE('V8Col0') = 'UNDEFINED' THEN ; generated for fun
+V8Col0			EQU			0						; Video depth control bit 0
+	ENDIF ; generated for fun
+	IF &TYPE('V8Col1') = 'UNDEFINED' THEN ; generated for fun
+V8Col1			EQU			1						; Video depth control bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('V8Col2') = 'UNDEFINED' THEN ; generated for fun
+V8Col2			EQU			2						; Video depth control bit 2
+	ENDIF ; generated for fun
+	IF &TYPE('V8MonID1') = 'UNDEFINED' THEN ; generated for fun
+V8MonID1		EQU			3						; Monitor sense ID bit 1
+	ENDIF ; generated for fun
+	IF &TYPE('V8MonID2') = 'UNDEFINED' THEN ; generated for fun
+V8MonID2		EQU			4						; Monitor sense ID bit 2
+	ENDIF ; generated for fun
+	IF &TYPE('V8MonID3') = 'UNDEFINED' THEN ; generated for fun
+V8MonID3		EQU			5						; Monitor sense ID bit 3
+	ENDIF ; generated for fun
+;*VsResr		EQU 		6 						; reserved
+;*VsResr		EQU			7						; reserved
+
+;  ======  Slot Interrupts Enable   Address: $50F26012	 =====
+;*V8Resr		EQU			0						; reserved
+;*V8Resr		EQU			1						; reserved
+;*V8Resr		EQU			2						; reserved
+;*V8Resr		EQU			3						; reserved
+;*V8Resr		EQU			4						; reserved
+	IF &TYPE('V8ExtIRQEn') = 'UNDEFINED' THEN ; generated for fun
+V8ExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
+	ENDIF ; generated for fun
+	IF &TYPE('V8IntIRQEn') = 'UNDEFINED' THEN ; generated for fun
+V8IntIRQEn		EQU 		6 						; internal video interrupt enabled
+	ENDIF ; generated for fun
+;*V8Resr		EQU			7						; reserved
+
+
+;----------
+; Elsie VDAC register definitions
+;----------
+
+; VISA/Bt450 registers
+
+	IF &TYPE('VsDACwAddReg') = 'UNDEFINED' THEN ; generated for fun
+VsDACwAddReg	EQU			$0000					;   offset from vDACBase for write address reg
+	ENDIF ; generated for fun
+	IF &TYPE('VsDACwDataReg') = 'UNDEFINED' THEN ; generated for fun
+VsDACwDataReg	EQU			$0001					;   offset from vDACBase for write data reg
+	ENDIF ; generated for fun
+
+; V8/Ariel registers
+
+	IF &TYPE('V8DACrAddReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACrAddReg	EQU			$0000					; offset for read address reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACwAddReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACwAddReg	EQU			$0000					; offset for write address reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACrDataReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACrDataReg	EQU			$0001					; offset for read data reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACwDataReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACwDataReg	EQU			$0001					; offset for write data reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACrCntlReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACrCntlReg	EQU			$0002					; offset for read control reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACwCntlReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACwCntlReg	EQU			$0002					; offset for write control reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACrKeyReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACrKeyReg	EQU			$0003					; offset for read key color reg
+	ENDIF ; generated for fun
+	IF &TYPE('V8DACwKeyReg') = 'UNDEFINED' THEN ; generated for fun
+V8DACwKeyReg	EQU			$0003					; offset for write key color reg
+	ENDIF ; generated for fun
+
+	IF &TYPE('V8vRAMBase') = 'UNDEFINED' THEN ; generated for fun
+V8vRAMBase		EQU			$50F40000				; base address of V8 VRAM, if present
+	ENDIF ; generated for fun
+
+; End of VISA changes								<4> <cv>
+
+
+;----------
+; DAFB register definitions (offsets from DAFBBase in ProductInfo) ($F980 0000)
+;----------
+
+	IF &TYPE('DAFB_BaseOffset') = 'UNDEFINED' THEN ; generated for fun
+DAFB_BaseOffset		EQU			$0				; DAFB offset from DAFBBase
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_ParmSize') = 'UNDEFINED' THEN ; generated for fun
+DAFB_ParmSize		EQU			$5				; size of DAFB programmed subset
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_NumRegs') = 'UNDEFINED' THEN ; generated for fun
+DAFB_NumRegs		Equ			(16-4)			; Number of DAFB registers (Color Regs are really vRAM).
+	ENDIF ; generated for fun
+
+	IF &TYPE('DAFB_VidBaseHi') = 'UNDEFINED' THEN ; generated for fun
+DAFB_VidBaseHi		EQU			$0				; DAFB video base address, bits 20:9
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_VidBaseLo') = 'UNDEFINED' THEN ; generated for fun
+DAFB_VidBaseLo		EQU			$4				; DAFB video base address, bits 8:5 (4:0 always zero)
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_RowWords') = 'UNDEFINED' THEN ; generated for fun
+DAFB_RowWords		EQU			$8				; DAFB rowlongs size
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_ClkCfg') = 'UNDEFINED' THEN ; generated for fun
+DAFB_ClkCfg			EQU			$C				; DAFB clock configuration
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_Config') = 'UNDEFINED' THEN ; generated for fun
+DAFB_Config			EQU			$10				; DAFB general configuration
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_BlkWrtEn') = 'UNDEFINED' THEN ; generated for fun
+DAFB_BlkWrtEn		EQU			$14				; DAFB block write enable
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_PgMdEn') = 'UNDEFINED' THEN ; generated for fun
+DAFB_PgMdEn			EQU			$18				; DAFB page mode enable
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_Sense') = 'UNDEFINED' THEN ; generated for fun
+DAFB_Sense			EQU			$1C				; DAFB sense line
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_Reset') = 'UNDEFINED' THEN ; generated for fun
+DAFB_Reset			EQU			$20				; DAFB reset control
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_SCSIch0') = 'UNDEFINED' THEN ; generated for fun
+DAFB_SCSIch0		EQU			$24				; Turbo SCSI channel 0 control (not used)
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_SCSIch1') = 'UNDEFINED' THEN ; generated for fun
+DAFB_SCSIch1		EQU			$28				; Turbo SCSI channel 1 control (not used)
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_Test') = 'UNDEFINED' THEN ; generated for fun
+DAFB_Test			EQU			$2C				; DAFB test control
+	ENDIF ; generated for fun
+
+	IF &TYPE('DAFB_CRB0') = 'UNDEFINED' THEN ; generated for fun
+DAFB_CRB0			EQU			$30				; vRAM Color Register, bank 0
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_CRB1') = 'UNDEFINED' THEN ; generated for fun
+DAFB_CRB1			EQU			$34				; vRAM Color Register, bank 1
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_CRB2') = 'UNDEFINED' THEN ; generated for fun
+DAFB_CRB2			EQU			$38				; vRAM Color Register, bank 2
+	ENDIF ; generated for fun
+	IF &TYPE('DAFB_CRB3') = 'UNDEFINED' THEN ; generated for fun
+DAFB_CRB3			EQU			$3C				; vRAM Color Register, bank 3
+	ENDIF ; generated for fun
+
+;----------
+; Swatch (in DAFB) register definitions (offsets from DAFBBase in ProductInfo)
+;----------
+
+	IF &TYPE('Swatch_BaseOffset') = 'UNDEFINED' THEN ; generated for fun
+Swatch_BaseOffset	EQU			$100			; Swatch offset from DAFBBase
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_BaseOffset1') = 'UNDEFINED' THEN ; generated for fun
+Swatch_BaseOffset1	EQU			$124			; parameter offset
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ParmSize1') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ParmSize1	EQU			$12				; size of Swatch parameter list
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_NumRegs') = 'UNDEFINED' THEN ; generated for fun
+Swatch_NumRegs		Equ			30				; Number of Swatch registers.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Swatch_Mode') = 'UNDEFINED' THEN ; generated for fun
+Swatch_Mode			EQU			$100			; Swatch general control
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_IntMsk') = 'UNDEFINED' THEN ; generated for fun
+Swatch_IntMsk		EQU			$104			; Swatch interrupt control
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_IntStat') = 'UNDEFINED' THEN ; generated for fun
+Swatch_IntStat		EQU			$108			; Swatch interrupt status
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ClrCrsrInt') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ClrCrsrInt	EQU			$10C			; Swatch clear cursor interrupt (not used in this form)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ClrAnimInt') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ClrAnimInt	EQU			$110			; Swatch clear animation interrupt (not used in this form)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ClrVBLInt') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ClrVBLInt	EQU			$114			; Swatch clear VBL interrupt (not used in this form)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_CrsrLine') = 'UNDEFINED' THEN ; generated for fun
+Swatch_CrsrLine		EQU			$118			; Swatch cursor interrupt trigger line
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_AnimLine') = 'UNDEFINED' THEN ; generated for fun
+Swatch_AnimLine		EQU			$11C			; Swatch animation interrupt trigger line
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_Test') = 'UNDEFINED' THEN ; generated for fun
+Swatch_Test			EQU			$120			; Swatch counter test
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HSyncRegs') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HSyncRegs	EQU			$124			; Swatch horizontal sync registers (set as a group)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HSerr') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HSerr		Equ			$124			;   HSerr
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_Hlfln') = 'UNDEFINED' THEN ; generated for fun
+Swatch_Hlfln		Equ			$128			;   Hlfln
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HEq') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HEq			Equ			$12C			;   HEq
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HSP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HSP			Equ			$130			;   HSP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HBWay') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HBWay		Equ			$134			;   HBWay
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HBrst') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HBrst		Equ			$138			;   HBrst
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HBP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HBP			Equ			$13C			;   HBP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HAL') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HAL			Equ			$140			;   HAL
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HFP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HFP			Equ			$144			;   HFP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_HPix') = 'UNDEFINED' THEN ; generated for fun
+Swatch_HPix			Equ			$148			;   HPix
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VSyncRegs') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VSyncRegs	EQU			$14C			; Swatch vertical sync registers (set as a group)
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VHLine') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VHLine		Equ			$14C			;	VHLine
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VSync') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VSync		Equ			$150			;	VSync
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VBPEq') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VBPEq		Equ			$154			;	VBPEq
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VBP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VBP			Equ			$158			;	VBP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VAL') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VAL			Equ			$15C			;	VAL
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VFP') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VFP			Equ			$160			;	VFP
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_VFPEq') = 'UNDEFINED' THEN ; generated for fun
+Swatch_VFPEq		Equ			$164			;	VFPEq
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_TimeAdj') = 'UNDEFINED' THEN ; generated for fun
+Swatch_TimeAdj		EQU			$168			; Swatch miscellaneous timing adjust
+	ENDIF ; generated for fun
+	IF &TYPE('Swatch_ActLine') = 'UNDEFINED' THEN ; generated for fun
+Swatch_ActLine		EQU			$16C			; Swatch active video line (read-only)
+	ENDIF ; generated for fun
+
+;----------
+; ACDC register definitions (offsets from DAFBBase in ProductInfo, also in vDACBase)
+;----------
+
+	IF &TYPE('ACDC_AddrReg') = 'UNDEFINED' THEN ; generated for fun
+ACDC_AddrReg		EQU			$200			; set position in ACDC internal RAM
+	ENDIF ; generated for fun
+	IF &TYPE('ACDC_DataReg') = 'UNDEFINED' THEN ; generated for fun
+ACDC_DataReg		EQU			$210			; read/write data in ACDC internal RAM
+	ENDIF ; generated for fun
+	IF &TYPE('ACDC_ConfigReg') = 'UNDEFINED' THEN ; generated for fun
+ACDC_ConfigReg		EQU			$220			; ACDC offset from DAFBBase
+	ENDIF ; generated for fun
+	IF &TYPE('ACDC_ParmSize') = 'UNDEFINED' THEN ; generated for fun
+ACDC_ParmSize		EQU			$1				; size of ACDC parameter list
+	ENDIF ; generated for fun
+
+
+;----------
+; National Clock Chip register definitions (offsets from DAFBBase in ProductInfo)
+;----------
+
+	IF &TYPE('Clk_BaseOffset') = 'UNDEFINED' THEN ; generated for fun
+Clk_BaseOffset		EQU			$300			; National offset from DAFBBase
+	ENDIF ; generated for fun
+	IF &TYPE('Clk_ParmSize') = 'UNDEFINED' THEN ; generated for fun
+Clk_ParmSize		EQU			$10 			; size of National parameter list
+	ENDIF ; generated for fun
+	IF &TYPE('Clk_ParmSize1') = 'UNDEFINED' THEN ; generated for fun
+Clk_ParmSize1		Equ			$0A				; (Once programmed, the last six bytes are always the same.)
+	ENDIF ; generated for fun
+
+;----------
+; Misc. DAFB Parms
+;----------
+	IF &TYPE('Misc_ParmSize') = 'UNDEFINED' THEN ; generated for fun
+Misc_ParmSize		Equ			$4				; Just for consistency with other DAFB parms.
+	ENDIF ; generated for fun
+
+
+;----------
+; GSC register definitions (offsets from VDACAddr in ProductInfo) ($50F2 0000)					<H5> jmp
+;----------
+	IF &TYPE('GSCDeviceID') = 'UNDEFINED' THEN ; generated for fun
+GSCDeviceID			Equ		$00						; Device revision register; read only.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelID') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelID			Equ		$01						; “Senseline” read/write register.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelControl') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelControl		Equ		$02						; Switches r/w sense of PanelID reg.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelSetup') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelSetup		Equ		$03						; Panel intialization register.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCGrayScale') = 'UNDEFINED' THEN ; generated for fun
+GSCGrayScale		Equ		$04						; The depth-switching register.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPolyAdj') = 'UNDEFINED' THEN ; generated for fun
+GSCPolyAdj			Equ		$05						; Allows for grayscale adjustment.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelAdj') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelAdj			Equ		$06						; Allows for panel adjustment.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCACDClk') = 'UNDEFINED' THEN ; generated for fun
+GSCACDClk			Equ		$07						; Who knows?
+	ENDIF ; generated for fun
+	IF &TYPE('GSCRefreshRate') = 'UNDEFINED' THEN ; generated for fun
+GSCRefreshRate		Equ		$08						; Refresh cycles per scanline.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCBlankShade') = 'UNDEFINED' THEN ; generated for fun
+GSCBlankShade		Equ		$09						; Shade of gray for depth switches.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCPanelSkew') = 'UNDEFINED' THEN ; generated for fun
+GSCPanelSkew		Equ		$0A						; Who knows?
+	ENDIF ; generated for fun
+
+	IF &TYPE('GSCDiag0') = 'UNDEFINED' THEN ; generated for fun
+GSCDiag0			Equ		$1D						; Undocumented “diagnostic” registers.
+	ENDIF ; generated for fun
+	IF &TYPE('GSCDiag1') = 'UNDEFINED' THEN ; generated for fun
+GSCDiag1			Equ		$1E
+	ENDIF ; generated for fun
+	IF &TYPE('GSCDiag2') = 'UNDEFINED' THEN ; generated for fun
+GSCDiag2			Equ		$1F
+	ENDIF ; generated for fun
+
+
+;----------
+; Sonora register definitions (offsets from SonoraAddr in ProductInfo) ($50F0 0000)				<H4><H6>
+;----------
+
+	IF &TYPE('SonoraVIA2Base') = 'UNDEFINED' THEN ; generated for fun
+SonoraVIA2Base	Equ			$26000					; Base address of VIA2
+	ENDIF ; generated for fun
+
+	IF &TYPE('SonoraVIA2Data') = 'UNDEFINED' THEN ; generated for fun
+SonoraVIA2Data	Equ			$00						; VIA2 Data Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraRAMSize') = 'UNDEFINED' THEN ; generated for fun
+SonoraRAMSize	EQU			$01						; DRAM config
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraSlotIFR') = 'UNDEFINED' THEN ; generated for fun
+SonoraSlotIFR	Equ			$02						; Slot Interrupt Flags Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVIA2IFR') = 'UNDEFINED' THEN ; generated for fun
+SonoraVIA2IFR	Equ			$03						; VIA2 Interrupt Flags Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVRAMSize') = 'UNDEFINED' THEN ; generated for fun
+SonoraVRAMSize	Equ			$04						; VRAM config
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraSpeedReg') = 'UNDEFINED' THEN ; generated for fun
+SonoraSpeedReg	Equ			$05						; System CPU Speed (waitstate) Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraSlotIER') = 'UNDEFINED' THEN ; generated for fun
+SonoraSlotIER	Equ			$12						; Slot Interrupt Enable Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVIA2IER') = 'UNDEFINED' THEN ; generated for fun
+SonoraVIA2IER	Equ			$13						; Interrupt Flag Register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVdCtlBase') = 'UNDEFINED' THEN ; generated for fun
+SonoraVdCtlBase	Equ			$28000					; Base address of video control registers
+	ENDIF ; generated for fun
+
+	IF &TYPE('SonoraVdModeReg') = 'UNDEFINED' THEN ; generated for fun
+SonoraVdModeReg	Equ			$00						; Monitor code and video blanking register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVdColrReg') = 'UNDEFINED' THEN ; generated for fun
+SonoraVdColrReg Equ			$01						; Framebuffer pixel depth control register
+	ENDIF ; generated for fun
+	IF &TYPE('SonoraVdSenseRg') = 'UNDEFINED' THEN ; generated for fun
+SonoraVdSenseRg	Equ			$02						; Senseline register
+	ENDIF ; generated for fun
+
+; Bits for Misc Sonora Regs
+;
+	IF &TYPE('SonoraSetClr') = 'UNDEFINED' THEN ; generated for fun
+SonoraSetClr	Equ			7						; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
+	ENDIF ; generated for fun
+													;  			 0 = 1-bits in bits 0-6 write 0's
+
+; Bits for SonoraSlotIER
+;
+	IF &TYPE('SonoraVBLIRQEn') = 'UNDEFINED' THEN ; generated for fun
+SonoraVBLIRQEn	Equ			6						; Enable/Disable built-in video VBL
+	ENDIF ; generated for fun
+
+;----------
+; Ariel register definitions (offsets from VDACAddr in ProductInfo) ($50F2 4000)				<H6>
+;----------
+	IF &TYPE('ArielAddrReg') = 'UNDEFINED' THEN ; generated for fun
+ArielAddrReg	Equ			0						; Offset to r/w address register
+	ENDIF ; generated for fun
+	IF &TYPE('ArielDataReg') = 'UNDEFINED' THEN ; generated for fun
+ArielDataReg	Equ			1						; Offset to r/w data register
+	ENDIF ; generated for fun
+	IF &TYPE('ArielConfigReg') = 'UNDEFINED' THEN ; generated for fun
+ArielConfigReg	Equ			2						; Offset to r/w control register
+	ENDIF ; generated for fun
+	IF &TYPE('ArielKeyReg') = 'UNDEFINED' THEN ; generated for fun
+ArielKeyReg		Equ			3						; Offset to r/w key color register
+	ENDIF ; generated for fun
+
+
+;----------
+; MMC register definitions (offsets from MMCAddr in ProductInfo) ($50F3 0400)				<P2><SM4> rb, start
+;----------
+
+	IF &TYPE('MMC_DRAMspeed0') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMspeed0	EQU			$00						; DRAM timing register 0 [M0].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMspeed1') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMspeed1	EQU			$04						; DRAM timing register 1 [M1].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_CPUspeed0') = 'UNDEFINED' THEN ; generated for fun
+MMC_CPUspeed0	EQU			$08						; Clock speed 0 [M2].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_CPUspeed1') = 'UNDEFINED' THEN ; generated for fun
+MMC_CPUspeed1	EQU			$0C						; Clock speed 1 [M3].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_ROMspeed0') = 'UNDEFINED' THEN ; generated for fun
+MMC_ROMspeed0	EQU			$10						; ROM cycle time 0 [M4].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_ROMspeed1') = 'UNDEFINED' THEN ; generated for fun
+MMC_ROMspeed1	EQU			$14						; ROM cycle time 1 [M5].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_ROMspeed2') = 'UNDEFINED' THEN ; generated for fun
+MMC_ROMspeed2	EQU			$18						; ROM cycle time 2 [M6].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_DSPspeed') = 'UNDEFINED' THEN ; generated for fun
+MMC_DSPspeed	EQU			$1C						; DSP clock speed [M7].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_DRAMwidth0') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMwidth0	EQU			$20						; DRAM width 0 [M8].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMwidth1') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMwidth1	EQU			$24						; DRAM width 1 [M9].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMwidth2') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMwidth2	EQU			$28						; DRAM width 2 [M10].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMwidth3') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMwidth3	EQU			$2C						; DRAM width 3 [M11].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_EPROMmode') = 'UNDEFINED' THEN ; generated for fun
+MMC_EPROMmode	EQU			$30						; EPROM mode [M12].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_DRAMrange2') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMrange2	EQU			$34						; DRAM bank range 0 [M13].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMrange1') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMrange1	EQU			$38						; DRAM bank range 1 [M14].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_DRAMrange0') = 'UNDEFINED' THEN ; generated for fun
+MMC_DRAMrange0	EQU			$3C						; DRAM bank range 2 [M15].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_CPUID0') = 'UNDEFINED' THEN ; generated for fun
+MMC_CPUID0		EQU			$40						; CPU ID 0 [M16].
+	ENDIF ; generated for fun
+	IF &TYPE('MMC_CPUID1') = 'UNDEFINED' THEN ; generated for fun
+MMC_CPUID1		EQU			$44						; CPU ID 1 [M17].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_ClockSelect') = 'UNDEFINED' THEN ; generated for fun
+MMC_ClockSelect	EQU			$48						; Endeavor Input Clock Select (NTSC/PAL) [M18].
+	ENDIF ; generated for fun
+
+	IF &TYPE('MMC_Bypass') = 'UNDEFINED' THEN ; generated for fun
+MMC_Bypass		EQU			$4C						; RGB or Composite bypass [M19].
+	ENDIF ; generated for fun
+
+;----------
+; MUNI (NuBus) register definitions																<P6>
+;----------
+
+; <SM7> rb, • TEMP for EVT1							;											<SM7> rb
+
+	IF &TYPE('MUNIBaseEVT1') = 'UNDEFINED' THEN ; generated for fun
+MUNIBaseEVT1	EQU			$50F30800				; Base address of Muni for EVT1				<SM9> rb
+	ENDIF ; generated for fun
+
+
+	IF &TYPE('MUNIBase') = 'UNDEFINED' THEN ; generated for fun
+MUNIBase		EQU			$50F30000				; Base address of Muni.						<SM7> rb
+	ENDIF ; generated for fun
+
+
+
+	IF &TYPE('MUNI_IntCntrl') = 'UNDEFINED' THEN ; generated for fun
+MUNI_IntCntrl	EQU			$00						; Interrupt control register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_IntStatus') = 'UNDEFINED' THEN ; generated for fun
+MUNI_IntStatus	EQU			$04						; Interrupt status register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_Control') = 'UNDEFINED' THEN ; generated for fun
+MUNI_Control	EQU			$08						; System control register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_BlkAttmpt') = 'UNDEFINED' THEN ; generated for fun
+MUNI_BlkAttmpt	EQU			$0C						; Block attempt register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_Status') = 'UNDEFINED' THEN ; generated for fun
+MUNI_Status		EQU			$10						; Status register.
+	ENDIF ; generated for fun
+	IF &TYPE('MUNI_Test') = 'UNDEFINED' THEN ; generated for fun
+MUNI_Test		EQU			$14						; Test control register.
+	ENDIF ; generated for fun
+
+;----------
+; Civic register definitions (offsets from CivicAddr in ProductInfo) ($50F3 6000)
+;----------
+
+	IF &TYPE('Civic_VBLInt') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBLInt	Equ			$000					; Read-only VBL flag register
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VBLEnb') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBLEnb	Equ			$110					; Enables VBL interrupt.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VBLClr') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBLClr	Equ			$120					; Clear VBL interrupt.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_Enable') = 'UNDEFINED' THEN ; generated for fun
+Civic_Enable	Equ			$004					; Enables Civic’s timing generator (Casio).
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Reset') = 'UNDEFINED' THEN ; generated for fun
+Civic_Reset		Equ			$10C					; Resets Casio.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VDCInt') = 'UNDEFINED' THEN ; generated for fun
+Civic_VDCInt	Equ			$008					; Read-only VDC flag register.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VDCClr') = 'UNDEFINED' THEN ; generated for fun
+Civic_VDCClr	Equ			$00C					; Clears VDC interrupt.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VDCEnb') = 'UNDEFINED' THEN ; generated for fun
+Civic_VDCEnb	Equ			$010					; Enables VDC interrupt.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VDCClk') = 'UNDEFINED' THEN ; generated for fun
+Civic_VDCClk	Equ			$018					; Enables VDC clock.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VidInSize') = 'UNDEFINED' THEN ; generated for fun
+Civic_VidInSize	Equ			$014					; Controls video-in Rows (1024 vs. 1536 bytes).
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VidInDble') = 'UNDEFINED' THEN ; generated for fun
+Civic_VidInDble	Equ			$208					; Controls whether Civic Doubles each Video-in Field
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_ScanCtl') = 'UNDEFINED' THEN ; generated for fun
+Civic_ScanCtl	Equ			$01C					; Controls progressive vs. interlaced scans.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_GSCDivide') = 'UNDEFINED' THEN ; generated for fun
+Civic_GSCDivide	Equ			$020					; Controls graphics clock divide count.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VSCDivide') = 'UNDEFINED' THEN ; generated for fun
+Civic_VSCDivide	Equ			$02C					; Controls video-in clock divide count.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VRAMSize') = 'UNDEFINED' THEN ; generated for fun
+Civic_VRAMSize	Equ			$040					; Controls VRAM sizing (1 vs. 2 Mbytes).
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_RfrshCtl') = 'UNDEFINED' THEN ; generated for fun
+Civic_RfrshCtl	Equ			$044					; Controls the refresh mode.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_BusSize') = 'UNDEFINED' THEN ; generated for fun
+Civic_BusSize	Equ			$04C					; Controls the bus size (32 vs. 64 bits).
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_SpeedCtl') = 'UNDEFINED' THEN ; generated for fun
+Civic_SpeedCtl	Equ			$050					; Controls the timing (25 vs. 33 MHz).
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_ConvEnb') = 'UNDEFINED' THEN ; generated for fun
+Civic_ConvEnb	Equ			$054					; Enables convolution.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_ReadSense') = 'UNDEFINED' THEN ; generated for fun
+Civic_ReadSense	Equ			$088					; Sense-line registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_SenseCtl') = 'UNDEFINED' THEN ; generated for fun
+Civic_SenseCtl	Equ			$058					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Sense0') = 'UNDEFINED' THEN ; generated for fun
+Civic_Sense0	Equ			$05C					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Sense1') = 'UNDEFINED' THEN ; generated for fun
+Civic_Sense1	Equ			$060					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Sense2') = 'UNDEFINED' THEN ; generated for fun
+Civic_Sense2	Equ			$064					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_SenseTst') = 'UNDEFINED' THEN ; generated for fun
+Civic_SenseTst	Equ			$068					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_SyncClr') = 'UNDEFINED' THEN ; generated for fun
+Civic_SyncClr	Equ			$06C					; Disables RGB (Sync) output.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_BaseAddr') = 'UNDEFINED' THEN ; generated for fun
+Civic_BaseAddr	Equ			$0C0					; Base address of active video.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_RowWords') = 'UNDEFINED' THEN ; generated for fun
+Civic_RowWords	Equ			$094					; Row long words of active video.
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_AdjF1') = 'UNDEFINED' THEN ; generated for fun
+Civic_AdjF1		Equ			$128					; Timing adjust registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_AdjF2') = 'UNDEFINED' THEN ; generated for fun
+Civic_AdjF2		Equ			$124					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_Piped') = 'UNDEFINED' THEN ; generated for fun
+Civic_Piped		Equ			$440					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_HSerr') = 'UNDEFINED' THEN ; generated for fun
+Civic_HSerr		Equ			$180					; Horizontal timing registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HlfLn') = 'UNDEFINED' THEN ; generated for fun
+Civic_HlfLn		Equ			$280					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HEq') = 'UNDEFINED' THEN ; generated for fun
+Civic_HEq		Equ			$2C0					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HSP') = 'UNDEFINED' THEN ; generated for fun
+Civic_HSP		Equ			$300					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HBWay') = 'UNDEFINED' THEN ; generated for fun
+Civic_HBWay		Equ			$340					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HAL') = 'UNDEFINED' THEN ; generated for fun
+Civic_HAL		Equ			$380					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HFP') = 'UNDEFINED' THEN ; generated for fun
+Civic_HFP		Equ			$3C0					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HPix') = 'UNDEFINED' THEN ; generated for fun
+Civic_HPix		Equ			$400					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VHLine') = 'UNDEFINED' THEN ; generated for fun
+Civic_VHLine	Equ			$480					; Vertical timing registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VSync') = 'UNDEFINED' THEN ; generated for fun
+Civic_VSync		Equ			$4C0					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VBPEqu') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBPEqu	Equ			$500					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VBP') = 'UNDEFINED' THEN ; generated for fun
+Civic_VBP		Equ			$540					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VAL') = 'UNDEFINED' THEN ; generated for fun
+Civic_VAL		Equ			$580					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VFP') = 'UNDEFINED' THEN ; generated for fun
+Civic_VFP		Equ			$640					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VFPEqu') = 'UNDEFINED' THEN ; generated for fun
+Civic_VFPEqu	Equ			$680					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_CurLine') = 'UNDEFINED' THEN ; generated for fun
+Civic_CurLine	Equ			$6C0					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VInHAL') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInHAL	Equ			$1C0					; Video-in timing registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VInHFPD') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInHFPD	Equ			$200					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VInHFP') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInHFP	Equ			$240					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VInVAL') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInVAL	Equ			$5C0					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VInVFP') = 'UNDEFINED' THEN ; generated for fun
+Civic_VInVFP	Equ			$600					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_HLDB') = 'UNDEFINED' THEN ; generated for fun
+Civic_HLDB		Equ			$114					; Horizontal test/control registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HHLTB') = 'UNDEFINED' THEN ; generated for fun
+Civic_HHLTB		Equ			$118					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_HActHi') = 'UNDEFINED' THEN ; generated for fun
+Civic_HActHi	Equ			$11C
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_VLDB') = 'UNDEFINED' THEN ; generated for fun
+Civic_VLDB		Equ			$100					; VSync test/control registers.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VHLTB') = 'UNDEFINED' THEN ; generated for fun
+Civic_VHLTB		Equ			$104					;
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_VActHi') = 'UNDEFINED' THEN ; generated for fun
+Civic_VActHi	Equ			$108					;
+	ENDIF ; generated for fun
+
+	IF &TYPE('Civic_TestEnb') = 'UNDEFINED' THEN ; generated for fun
+Civic_TestEnb	Equ			$12C					; Enables Casio test mode.
+	ENDIF ; generated for fun
+	IF &TYPE('Civic_CntTest') = 'UNDEFINED' THEN ; generated for fun
+Civic_CntTest	Equ			$140					; Count test register.
+	ENDIF ; generated for fun
+
+;----------
+; Sebastian register definitions (offsets from SebastianAddr in ProductInfo) ($50F3 0000)
+;----------
+
+	IF &TYPE('SebastAddrReg') = 'UNDEFINED' THEN ; generated for fun
+SebastAddrReg	Equ			$000					; CLUT/DAC Address register.
+	ENDIF ; generated for fun
+	IF &TYPE('SebastDataReg') = 'UNDEFINED' THEN ; generated for fun
+SebastDataReg	Equ			$010					; CLUT/DAC Data register.
+	ENDIF ; generated for fun
+	IF &TYPE('SebastPCBR') = 'UNDEFINED' THEN ; generated for fun
+SebastPCBR		Equ			$020					; CLUT/DAC Pixel Bus Control register.
+	ENDIF ; generated for fun
+
+;----------
+; Endeavor register definitions
+;----------
+
+	IF &TYPE('Endeavor') = 'UNDEFINED' THEN ; generated for fun
+Endeavor		Equ			$50F2E000				; Base address of Endeavor in Cyclone.
+	ENDIF ; generated for fun
+
+	IF &TYPE('EndeavorM') = 'UNDEFINED' THEN ; generated for fun
+EndeavorM		Equ			$000					; 8-bit numerator.
+	ENDIF ; generated for fun
+	IF &TYPE('EndeavorN') = 'UNDEFINED' THEN ; generated for fun
+EndeavorN		Equ			$010					; 8-bit denominator.
+	ENDIF ; generated for fun
+	IF &TYPE('EndeavorClk') = 'UNDEFINED' THEN ; generated for fun
+EndeavorClk		Equ			$020					; Clock select (A or B).
+	ENDIF ; generated for fun
+
+;----------
+; MSC register definitions (offsets from MSCAddr in ProductInfo) ($50F2 6000)
+;----------
+
+	IF &TYPE('MSCSlotIFR') = 'UNDEFINED' THEN ; generated for fun
+MSCSlotIFR		EQU			$02						; slots interrupt flags
+	ENDIF ; generated for fun
+	IF &TYPE('MSCVIA2IFR') = 'UNDEFINED' THEN ; generated for fun
+MSCVIA2IFR		EQU			$03						; VIA 2 interrupt flags
+	ENDIF ; generated for fun
+	IF &TYPE('MSCConfig') = 'UNDEFINED' THEN ; generated for fun
+MSCConfig		EQU			$10						; RAM, clock configuration
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSlotIER') = 'UNDEFINED' THEN ; generated for fun
+MSCSlotIER		EQU			$12						; slots interrupt enables
+	ENDIF ; generated for fun
+	IF &TYPE('MSCVIA2IER') = 'UNDEFINED' THEN ; generated for fun
+MSCVIA2IER		EQU			$13						; VIA 2 interrupt enables
+	ENDIF ; generated for fun
+	IF &TYPE('MSCClkCntl') = 'UNDEFINED' THEN ; generated for fun
+MSCClkCntl		EQU			$21						; peripherals clock control
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSndCntl') = 'UNDEFINED' THEN ; generated for fun
+MSCSndCntl		EQU			$22						; sound control
+	ENDIF ; generated for fun
+	IF &TYPE('MSCFlashWrEnb') = 'UNDEFINED' THEN ; generated for fun
+MSCFlashWrEnb	EQU			$23						; flash ROM write enable
+	ENDIF ; generated for fun
+	IF &TYPE('MSCPowerCycle') = 'UNDEFINED' THEN ; generated for fun
+MSCPowerCycle	EQU			$50FA0000-$50F26000		; CPU power off control register			<H2>
+	ENDIF ; generated for fun
+
+;  ======  VIA2 BufferB Equivalent		Address: $50F26000	 =====
+	IF &TYPE('MSCExpansion') = 'UNDEFINED' THEN ; generated for fun
+MSCExpansion	EQU			0						; 0 = enable on-board external cache (not currently used)
+	ENDIF ; generated for fun
+;v2PMack		EQU 		1 						; Power manager handshake acknowledge
+;v2PMreq		EQU 		2 						; Power manager handshake request
+;reserved3		EQU			3						; reserved
+;reserved4		EQU			4						; reserved
+;reserved5		EQU			5						; reserved
+;reserved6		EQU			6						; reserved
+;reserved7		EQU			7						; reserved
+
+;  ======  Slot Interrupt Flags			Address: $50F26002	 =====
+;reserved0		EQU			0						; reserved
+;reserved1		EQU			1						; reserved
+;reserved2		EQU			2						; reserved
+;reserved3		EQU			3						; reserved
+;reserved4		EQU			4						; reserved
+;RvIRQE			EQU 		5 						; slot E interrupt
+;RvIRQLCD		EQU			6						; LCD display VBL interrupt
+;reserved7		EQU			7						; reserved
+
+;  ======  VIA 2 Interrupt Flags		Address: $50F26003	 =====
+;RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt
+;RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
+;reserved2		EQU			2						; reserved
+;RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
+;RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup
+;reserved5		EQU			5						; reserved
+;reserved6		EQU			6						; reserved
+;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt
+
+;  ======  MSC Configuration			Address: $50F26010	 =====
+	IF &TYPE('MSC25MHz') = 'UNDEFINED' THEN ; generated for fun
+MSC25MHz		EQU			0						; 1 = 25MHz system, 0 = 33MHz system
+	ENDIF ; generated for fun
+	IF &TYPE('MSCEconoBit') = 'UNDEFINED' THEN ; generated for fun
+MSCEconoBit		EQU			1						; 1 = econo-mode enabled (switches to 16MHz)
+	ENDIF ; generated for fun
+	IF &TYPE('MSCFastROM') = 'UNDEFINED' THEN ; generated for fun
+MSCFastROM		EQU			2						; 1 = 100ns ROMs installed, 0 = 120ns ROMs installed
+	ENDIF ; generated for fun
+;reserved3		EQU			3						; reserved
+	IF &TYPE('MSCBank8M') = 'UNDEFINED' THEN ; generated for fun
+MSCBank8M		EQU			4						; 1 = banks 4-7 are 8MB, 0=banks 4-7 are 2MB
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSize0') = 'UNDEFINED' THEN ; generated for fun
+MSCSize0		EQU			5						; RAM size bit
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSize1') = 'UNDEFINED' THEN ; generated for fun
+MSCSize1		EQU			6						; RAM size bit
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSize2') = 'UNDEFINED' THEN ; generated for fun
+MSCSize2		EQU			7						; RAM size bit
+	ENDIF ; generated for fun
+
+;  ======  Slot Interrupt Enables		Address: $50F26012	 =====
+;reserved0		EQU			0						; reserved
+;reserved1		EQU			1						; reserved
+;reserved2		EQU			2						; reserved
+;reserved3		EQU			3						; reserved
+;reserved4		EQU			4						; reserved
+;RvIRQEEn		EQU 		5 						; slot E interrupt enabled
+;RvIRQLCDEn		EQU			6						; LCD display VBL interrupt enabled
+;RvSetClr		EQU			7						; on READs, always reads 0
+
+;  ======  VIA 2 Interrupt Enables		Address: $50F26013	 =====
+;RvSCSIDRQEn	EQU			0						; 1 = SCSI DRQ interrupt enabled
+;RvAnySlotEn	EQU			1						; 1 = any slot(0-6).IRQ int. enabled
+;reserved2		EQU			2						; reserved
+;RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
+;RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
+;reserved5		EQU			5						; reserved
+;reserved6		EQU			6						; reserved
+;RvSetClr		EQU			7						; on READs, always reads 0
+													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
+													;  			0 = 1-bits in bits 0-6 write 0's
+
+;  ======  Peripherals Clock Control	Address: $50F26021	 =====
+	IF &TYPE('MSCIOClk') = 'UNDEFINED' THEN ; generated for fun
+MSCIOClk		EQU			0						; 1=15.6672MHz I/O clock running, 0=stopped
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSCCClk') = 'UNDEFINED' THEN ; generated for fun
+MSCSCCClk		EQU			1						; 1=3.672MHz SCC clock running, 0=stopped
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSCSIReset') = 'UNDEFINED' THEN ; generated for fun
+MSCSCSIReset	EQU			2						; 1=SCSI reset not asserted, 0=reset asserted (clocks stop)
+	ENDIF ; generated for fun
+	IF &TYPE('MSCLCDReset') = 'UNDEFINED' THEN ; generated for fun
+MSCLCDReset		EQU			3						; 1=LCD reset not asserted, 0=reset asserted (clocks stop)
+	ENDIF ; generated for fun
+;reserved4		EQU			4						; reserved
+;reserved5		EQU			5						; reserved
+;reserved6		EQU			6						; reserved
+;reserved7		EQU			7						; reserved
+
+;  ======  Sound Control				Address: $50F26022	 =====
+	IF &TYPE('MSCSndPower') = 'UNDEFINED' THEN ; generated for fun
+MSCSndPower		EQU			0						; 1=DFAC power on, 0=DFAC power off
+	ENDIF ; generated for fun
+;reserved1		EQU			1						; reserved
+;reserved2		EQU			2						; reserved
+;reserved3		EQU			3						; reserved
+;reserved4		EQU			4						; reserved
+;reserved5		EQU			5						; reserved
+	IF &TYPE('MSCSndBusy') = 'UNDEFINED' THEN ; generated for fun
+MSCSndBusy		EQU			6						; 1=access to FIFO since last access to this register
+	ENDIF ; generated for fun
+	IF &TYPE('MSCSndLatch') = 'UNDEFINED' THEN ; generated for fun
+MSCSndLatch		EQU			7						; 1=DFAC is powered up and initialized
+	ENDIF ; generated for fun
+
+
+	IF &TYPE('MSCDefConfig') = 'UNDEFINED' THEN ; generated for fun
+MSCDefConfig	EQU			(1<<MSC25MHz)|\			; 25MHz system								<H9>
+							(0<<MSCEconoBit)|\		; econo-mode disabled						<H9>
+							(0<<MSCFastROM)|\		; 120ns ROMs installed						<H9>
+							(0<<MSCBank8M)|\		; assume 2MB each in banks 4-7				<H19>
+							(%000<<MSCSize0)		; set 2MB so there's real RAM for BootBeep	<H10>
+	ENDIF ; generated for fun
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; Memory Controllers - Register Definitions and Misc Equates for Memory Controllers.  Included
+; are: FMC, ORWELL, JAWS, Niagra, Ponti, djMEMC, Pratt
+;
+;
+;__________________________________________________________________________________________
+
+
+;---------------------------------------------------
+;  FMC (Fitch Memory Controller) Equates
+;---------------------------------------------------
+
+	IF &TYPE('FMCConfig') = 'UNDEFINED' THEN ; generated for fun
+FMCConfig		equ			$0						; offset to configuration register.  It is a 16
+	ENDIF ; generated for fun
+													; bit wide register with a 1 bit wide data port
+													; on d24, so do byte writes (and rotates) and
+													; let dynamic bus sizing replicate it on d24-31.
+
+	IF &TYPE('FMCLatch') = 'UNDEFINED' THEN ; generated for fun
+FMCLatch		equ			$10						; offset to 'latch config data' register (latches
+	ENDIF ; generated for fun
+													; on a write to here)
+	IF &TYPE('FMCInit') = 'UNDEFINED' THEN ; generated for fun
+FMCInit			EQU			$F3EF					; config reg initial value				<4.5><4.6><4.9><1>
+	ENDIF ; generated for fun
+	IF &TYPE('FMCRPUInit') = 'UNDEFINED' THEN ; generated for fun
+FMCRPUInit		EQU			$F3FF					; config reg initial value (parity)		<1>
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+;  Orwell Memory Controller Equates	<5>
+;---------------------------------------------------
+
+;	Orwell only has one input/output data bit.  So to store or retrieve any configuration register
+;	information, you must read/write a succession of long-word addresses, starting at the addresses
+;	below, with the ONLY valid data bit being {reg}:0.  Valued being read must be assembled one bit
+;	at a time; values being written must be loaded into the config registers 1 bit at a time.  The
+;	new config. register values do not become active until a "latch" register address associated
+;	with the config. register is written.
+;
+;	The below addresses correspond to longword addresses where bit 0 of whatever data register used to
+;	read/write the location will be stored.  The Orwell configuration register is a 34-bit register,
+;	with each bit written to/read by addressing the appropriate longword offset.
+;
+;	The configuration register can be thought of like this:
+;
+;		+---------------------------------------------------------------------------------------------+
+;		| PAR_ODD | PAR_ENB | REFRESH | ROM_SPEED | DRAM_SPEED | CLK_SPEED | BANK_D | BANK_C | BANK_B |
+;		+---------------------------------------------------------------------------------------------+
+;			28        27     26     24 23       21  20       19     18      17   12  11    6  5      0
+;
+;																												<T6>
+;		+---------------------------------------------------------------------+									<T6>
+;		|    RAS    | Optional WRITE | Optional Read  | Optional Read  | Page |									<T6>
+;		| Precharge |   wait state   | 2nd wait state | 1st wait state | Mode |									<T6>
+;		+---------------------------------------------------------------------+									<T6>
+;			 33            32                31               30          29									<T6>
+
+;			***		Register Offsets	***
+
+	IF &TYPE('OrCfgRegAddr') = 'UNDEFINED' THEN ; generated for fun
+OrCfgRegAddr		EQU			0						; starting offset of config reg. bits
+	ENDIF ; generated for fun
+	IF &TYPE('OrCfgRegSize') = 'UNDEFINED' THEN ; generated for fun
+OrCfgRegSize		EQU			34						; number of bits in the configuration register				<T6>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrBankFieldSize') = 'UNDEFINED' THEN ; generated for fun
+OrBankFieldSize		EQU			6						; each bank config. reg. field is 6 bits wide
+	ENDIF ; generated for fun
+	IF &TYPE('OrBankBCfgAddr') = 'UNDEFINED' THEN ; generated for fun
+OrBankBCfgAddr		EQU			OrCfgRegAddr			; starting offset of BankB(5:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrBankCCfgAddr') = 'UNDEFINED' THEN ; generated for fun
+OrBankCCfgAddr		EQU			OrBankBCfgAddr+(4*OrBankFieldSize); starting offset of BankC(5:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrBankDCfgAddr') = 'UNDEFINED' THEN ; generated for fun
+OrBankDCfgAddr		EQU			OrBankCCfgAddr+(4*OrBankFieldSize); starting offset of BankD(5:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrClkSpeedAddr') = 'UNDEFINED' THEN ; generated for fun
+OrClkSpeedAddr		EQU			OrBankDCfgAddr+(4*OrBankFieldSize); starting address of Clock_Speed
+	ENDIF ; generated for fun
+														; ... Clock_Speed is 1 bit (0=25MHz)
+	IF &TYPE('OrDRAMSpeedAddr') = 'UNDEFINED' THEN ; generated for fun
+OrDRAMSpeedAddr		EQU			OrClkSpeedAddr+4		; starting address of DRAM Speed(1:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrDRAMFieldSize') = 'UNDEFINED' THEN ; generated for fun
+OrDRAMFieldSize		EQU			2						; DRAM speed config reg. field is 2 bits wide
+	ENDIF ; generated for fun
+	IF &TYPE('OrROMSpeedAddr') = 'UNDEFINED' THEN ; generated for fun
+OrROMSpeedAddr		EQU			OrDRAMSpeedAddr+(4*OrDRAMFieldSize); starting address of ROM Speed(2:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrROMFieldSize') = 'UNDEFINED' THEN ; generated for fun
+OrROMFieldSize		EQU			3						; ROM speed config reg. field is 3 bits wide
+	ENDIF ; generated for fun
+	IF &TYPE('OrRefreshAddr') = 'UNDEFINED' THEN ; generated for fun
+OrRefreshAddr		EQU			OrROMSpeedAddr+(4*OrROMFieldSize); starting address of Refresh Rate(2:0)
+	ENDIF ; generated for fun
+	IF &TYPE('OrRefreshSize') = 'UNDEFINED' THEN ; generated for fun
+OrRefreshSize		EQU			3						; Refresh speed config reg. field is 3 bits wide
+	ENDIF ; generated for fun
+	IF &TYPE('OrParityEnbAddr') = 'UNDEFINED' THEN ; generated for fun
+OrParityEnbAddr		EQU			OrRefreshAddr+(4*OrRefreshSize); starting address of parity enable/disable
+	ENDIF ; generated for fun
+														; ... Parity_Enable is 1 bit (0=parity OFF)
+	IF &TYPE('OrParityTypAddr') = 'UNDEFINED' THEN ; generated for fun
+OrParityTypAddr		EQU			OrParityEnbAddr+4		; starting address of parity type (even/odd)
+	ENDIF ; generated for fun
+														; ... Parity_Type is 1 bit (0=parity EVEN)
+	IF &TYPE('OrPageMode') = 'UNDEFINED' THEN ; generated for fun
+OrPageMode			EQU			OrParityTypAddr+4		;															<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrWaitRead1') = 'UNDEFINED' THEN ; generated for fun
+OrWaitRead1			EQU			OrPageMode+4			;															<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrWaitRead2') = 'UNDEFINED' THEN ; generated for fun
+OrWaitRead2			EQU			OrWaitRead1+4			;															<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrWaitWrite1') = 'UNDEFINED' THEN ; generated for fun
+OrWaitWrite1		EQU			OrWaitRead2+4			;															<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrRASPrecharge') = 'UNDEFINED' THEN ; generated for fun
+OrRASPrecharge		EQU			OrWaitWrite1+4			;															<T6>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrLatchOffset') = 'UNDEFINED' THEN ; generated for fun
+OrLatchOffset		EQU			$A0						; offset from start of config reg. where latches live		<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrwellLatches') = 'UNDEFINED' THEN ; generated for fun
+OrwellLatches		EQU			OrCfgRegAddr+OrLatchOffset; starting address of Latch Addresses						<T6>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrLoadBanks') = 'UNDEFINED' THEN ; generated for fun
+OrLoadBanks			EQU			OrwellLatches			; Load Bank Config Reg. Latch address						<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadSpeeds') = 'UNDEFINED' THEN ; generated for fun
+OrLoadSpeeds		EQU			OrLoadBanks+4			; Load Clock, DRAM and ROM Speeds Latch address
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadRefresh') = 'UNDEFINED' THEN ; generated for fun
+OrLoadRefresh		EQU			OrLoadSpeeds+4			; Load Refresh interval Latch address
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadParity') = 'UNDEFINED' THEN ; generated for fun
+OrLoadParity		EQU			OrLoadRefresh+4			; Load Parity enable/disable and type Latch address
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrLoadMode') = 'UNDEFINED' THEN ; generated for fun
+OrLoadMode			EQU			OrLoadParity+4			; Load Page Mode On/Off address								<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadWaitStates') = 'UNDEFINED' THEN ; generated for fun
+OrLoadWaitStates	EQU			OrLoadMode+4			; Load Read/Write extra waitstates address					<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('OrLoadPrecharge') = 'UNDEFINED' THEN ; generated for fun
+OrLoadPrecharge		EQU			OrLoadWaitStates+4		; Load RAS precharge address								<T6>
+	ENDIF ; generated for fun
+
+	IF &TYPE('OrParityStatus') = 'UNDEFINED' THEN ; generated for fun
+OrParityStatus		EQU			$100					; A0-BC = LS 8 bits, C0-DC   = LM 8 bits					<T6>
+	ENDIF ; generated for fun
+														; E0-FC = HM 8 bits, 100-11C = MS 8 bits
+	IF &TYPE('OrParErrInByte0') = 'UNDEFINED' THEN ; generated for fun
+OrParErrInByte0		EQU			$180					; =1 if parity error occurred in byte 0
+	ENDIF ; generated for fun
+	IF &TYPE('OrParErrInByte1') = 'UNDEFINED' THEN ; generated for fun
+OrParErrInByte1		EQU			$184					; =1 if parity error occurred in byte 1
+	ENDIF ; generated for fun
+	IF &TYPE('OrParityError') = 'UNDEFINED' THEN ; generated for fun
+OrParityError		EQU			$188					; =1 if parity error occurred (period)
+	ENDIF ; generated for fun
+
+;			***		Initializing Values at Bootup Time		***
+
+	IF &TYPE('ORINITBankB') = 'UNDEFINED' THEN ; generated for fun
+ORINITBankB			EQU			$10						; 10=Bank B at 64MB
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITBankC') = 'UNDEFINED' THEN ; generated for fun
+ORINITBankC			EQU			$20						; 20=Bank C at 128MB
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITBankD') = 'UNDEFINED' THEN ; generated for fun
+ORINITBankD			EQU			$30						; 30=Bank D at 192MB
+	ENDIF ; generated for fun
+
+	IF &TYPE('ORINITClock25') = 'UNDEFINED' THEN ; generated for fun
+ORINITClock25		EQU			1						; 1=25MHz, 0=33MHz											<T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITClock33') = 'UNDEFINED' THEN ; generated for fun
+ORINITClock33		EQU			0						;															<T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITDRAMSpeed') = 'UNDEFINED' THEN ; generated for fun
+ORINITDRAMSpeed		EQU			1						; 0=100ns, 1=80ns, 2=60ns							<10>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITROMSpeed25') = 'UNDEFINED' THEN ; generated for fun
+ORINITROMSpeed25	EQU			2						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITROMSpeed33') = 'UNDEFINED' THEN ; generated for fun
+ORINITROMSpeed33	EQU			4						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITREFRESH25') = 'UNDEFINED' THEN ; generated for fun
+ORINITREFRESH25		EQU			2						; 0=25MHz 7.8µsec,  1=33MHz, 7.8µsec				<21>	<T12>
+	ENDIF ; generated for fun
+														; 2=25MHz 15.6µsec, 3=33MHz 15.6µsec				<21>	<T12>
+	IF &TYPE('ORINITREFRESH33') = 'UNDEFINED' THEN ; generated for fun
+ORINITREFRESH33		EQU			3						;													<21>	<T12>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITParity') = 'UNDEFINED' THEN ; generated for fun
+ORINITParity		EQU			0						; 0=parity OFF, 1=parity ON
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITParType') = 'UNDEFINED' THEN ; generated for fun
+ORINITParType		EQU			1						; 0=even, 1=odd
+	ENDIF ; generated for fun
+
+;	Additional (programmable) wait states for reads and writes
+
+	IF &TYPE('ORINITPageMode') = 'UNDEFINED' THEN ; generated for fun
+ORINITPageMode		EQU			0						; 0=off, 1=on												<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITWaitRd1') = 'UNDEFINED' THEN ; generated for fun
+ORINITWaitRd1		EQU			0						; 0=off, 1=on (unless Rd2 = 1, in which case it is interpreted as off)<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITWaitRd2') = 'UNDEFINED' THEN ; generated for fun
+ORINITWaitRd2		EQU			0						; 0=off, 1=on (unless Rd1 = 1, in which case it is interpreted as off)<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITWaitWr1') = 'UNDEFINED' THEN ; generated for fun
+ORINITWaitWr1		EQU			0						; 0=off, 1=on												<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITRAS25') = 'UNDEFINED' THEN ; generated for fun
+ORINITRAS25			EQU			0						; 0=2 cycles, 1=3 cycles 									<T6>
+	ENDIF ; generated for fun
+	IF &TYPE('ORINITRAS33') = 'UNDEFINED' THEN ; generated for fun
+ORINITRAS33			EQU			1						;															<T12>
+	ENDIF ; generated for fun
+
+;	These are 32-bit constants that hold all but 2 bits of the initial defaults we									  .
+;	would want to jam into the Orwell configuration register.  These are arranged									  .
+;	in order the register is memory-mapped to facilitate the code that sticks them									  .
+;	in the register.  There are two bits that don't fit in a 32-bit constant, the									  .
+;	optional -OrWaitWrite1- and the not-so-optional -OrRASPrecharge-.  Those values									  .
+;	are used and initialized separately.																			  .
+
+	IF &TYPE('ORWELL_INIT25') = 'UNDEFINED' THEN ; generated for fun
+ORWELL_INIT25		EQU			\						;															<T6><T12>
+								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
+								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
+								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
+								(ORINITParType<<28)|\	; initial parity even/odd value
+								(ORINITParity<<27)|\	; initial parity on/off value
+								(ORINITREFRESH25<<24)|\	; initial refresh rate value								<T12>
+								(ORINITROMSpeed25<<21)|\; initial ROM speed value									<T12>
+								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
+								(ORINITClock25<<18)|\	; initial clock speed value									<T12>
+								(ORINITBankD<<12)|\		; initial Bank D starting address value
+								(ORINITBankC<<6)|\		; initial Bank C starting address value
+								(ORINITBankB)			; initial Bank B starting address value
+	ENDIF ; generated for fun
+	IF &TYPE('ORWELL_INIT33') = 'UNDEFINED' THEN ; generated for fun
+ORWELL_INIT33		EQU			\						;															<T6><T12> thru next <T12>
+								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
+								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
+								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
+								(ORINITParType<<28)|\	; initial parity even/odd value
+								(ORINITParity<<27)|\	; initial parity on/off value
+								(ORINITREFRESH33<<24)|\	; initial refresh rate value
+								(ORINITROMSpeed33<<21)|\; initial ROM speed value
+								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
+								(ORINITClock33<<18)|\	; initial clock speed value
+								(ORINITBankD<<12)|\		; initial Bank D starting address value
+								(ORINITBankC<<6)|\		; initial Bank C starting address value
+								(ORINITBankB)			; initial Bank B starting address value						<T12>
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; JAWS Memory Controller Equates
+;---------------------------------------------------
+
+	IF &TYPE('JAWSRAMWaitS') = 'UNDEFINED' THEN ; generated for fun
+JAWSRAMWaitS	EQU			$00000					; RAM wait state control register offset
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSEconoMode') = 'UNDEFINED' THEN ; generated for fun
+JAWSEconoMode	EQU			$04000					; Econo-Mode register offset									<21> HJR
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSROMWaitS') = 'UNDEFINED' THEN ; generated for fun
+JAWSROMWaitS	EQU			$06000					; ROM wait state control register offset
+	ENDIF ; generated for fun
+
+	IF &TYPE('JAWSMemConfigA') = 'UNDEFINED' THEN ; generated for fun
+JAWSMemConfigA	EQU			$10000					; Contiguous memory (knitting) registers
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSMemConfigB') = 'UNDEFINED' THEN ; generated for fun
+JAWSMemConfigB	EQU			$12000					; Contiguous memory (knitting) registers
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSMemConfigC') = 'UNDEFINED' THEN ; generated for fun
+JAWSMemConfigC	EQU			$14000					; Contiguous memory (knitting) registers
+	ENDIF ; generated for fun
+
+	IF &TYPE('JAWSPowerCycle') = 'UNDEFINED' THEN ; generated for fun
+JAWSPowerCycle	EQU			$20000					; CPU power off control register
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSSetCPUClock') = 'UNDEFINED' THEN ; generated for fun
+JAWSSetCPUClock	EQU			$22000					; Controls the CPU clock frequency
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSPCBLevel') = 'UNDEFINED' THEN ; generated for fun
+JAWSPCBLevel	EQU			$30000					; Selects between SCC and SCC/SCSI combo
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSLockRAM') = 'UNDEFINED' THEN ; generated for fun
+JAWSLockRAM		EQU			$32000					; Puts RAM in self refresh state
+	ENDIF ; generated for fun
+	IF &TYPE('JAWSGetCPUClock') = 'UNDEFINED' THEN ; generated for fun
+JAWSGetCPUClock	EQU			$34000					; Returns the CPU clock frequency
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; Niagra Memory Controller Equates
+;---------------------------------------------------
+
+	IF &TYPE('NiagraVidCntCtr') = 'UNDEFINED' THEN ; generated for fun
+NiagraVidCntCtr	EQU			$02000					; Video count options 									<21> HJR
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraGUR') = 'UNDEFINED' THEN ; generated for fun
+NiagraGUR		EQU			$16000					; General Utility Registers (ponti register access)<SM4> rb
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraVidAcc1') = 'UNDEFINED' THEN ; generated for fun
+NiagraVidAcc1	EQU			$22000					; Video Accesses thru 64
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraVidAcc2') = 'UNDEFINED' THEN ; generated for fun
+NiagraVidAcc2	EQU			$24000					; Video Accesses thru 512
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraVidAcc3') = 'UNDEFINED' THEN ; generated for fun
+NiagraVidAcc3	EQU			$26000					; Video Accesses thru 2K
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraFlashEnbl') = 'UNDEFINED' THEN ; generated for fun
+NiagraFlashEnbl	EQU			$30000					; Enable flash from Niagra
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraFPUAcc') = 'UNDEFINED' THEN ; generated for fun
+NiagraFPUAcc	EQU			$34000					; FPU access detected
+	ENDIF ; generated for fun
+	IF &TYPE('NiagraSpeedReg') = 'UNDEFINED' THEN ; generated for fun
+NiagraSpeedReg	EQU			$36000					; Returns the CPU clock frequency
+	ENDIF ; generated for fun
+
+;---------------------------------------------------								<SM4> rb, start
+; Ponti Register Equates  (NiagraGUR register space + offset
+;---------------------------------------------------
+
+	IF &TYPE('PontiSPIMdmCtl') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIMdmCtl		EQU			$000
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndCtl') = 'UNDEFINED' THEN ; generated for fun
+PontiSndCtl			EQU			$400
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSPISftReg') = 'UNDEFINED' THEN ; generated for fun
+PontiSPISftReg		EQU			$800
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpSftCtl') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpSftCtl		EQU			$C00
+	ENDIF ; generated for fun
+
+; Ponti PontiSPIMdmCtl bit definitions
+	IF &TYPE('PontiSPIMdmId') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIMdmId		EQU			0				; (1 = SPI modem connected)
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSPIAck') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIAck			EQU			2				; (1 = ack idle)
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSPIReq') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIReq			EQU			3				; (1 = req idle)
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSPIIrq') = 'UNDEFINED' THEN ; generated for fun
+PontiSPIIrq			EQU			4				; (1 = interrupting)
+	ENDIF ; generated for fun
+
+; Ponti PontiSoundCtl bit definitions
+	IF &TYPE('PontiSndSPIIrqMsk') = 'UNDEFINED' THEN ; generated for fun
+PontiSndSPIIrqMsk	EQU			0				; (1 = mask int)			- irq mask for PontiSPIIrq
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndIntMic') = 'UNDEFINED' THEN ; generated for fun
+PontiSndIntMic		EQU			1				; (1 = using internal mic)	- flag to check which mike is used	<H22>
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndLatchClr') = 'UNDEFINED' THEN ; generated for fun
+PontiSndLatchClr	EQU			2				; (pulse high to clear)		- line directly to latch
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndLatchData') = 'UNDEFINED' THEN ; generated for fun
+PontiSndLatchData	EQU			3				; (1 = snd ckt used)		- output value of the sound latch
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndPWMOff') = 'UNDEFINED' THEN ; generated for fun
+PontiSndPWMOff		EQU			4				; (1 = PWM off)				- ultimate off to remove "pop"
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndPwrOn') = 'UNDEFINED' THEN ; generated for fun
+PontiSndPwrOn		EQU			5				; (1 = power snd ckt)		- sw equal of latch output
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndMux0') = 'UNDEFINED' THEN ; generated for fun
+PontiSndMux0		EQU			6				; (1 = ???)
+	ENDIF ; generated for fun
+	IF &TYPE('PontiSndMux1') = 'UNDEFINED' THEN ; generated for fun
+PontiSndMux1		EQU			7				; (1 = modem sound {regardless of Mux0})
+	ENDIF ; generated for fun
+
+; Ponti PontiLmpSftCtl bit definitions
+	IF &TYPE('PontiLmpOff') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpOff			EQU			0				; (1 = backlight on) 		- turn on the backlight tube
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpHWCtl') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpHWCtl		EQU			1				; (1 = Hardware control) 	- if set, hardware control loop
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpMux0') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpMux0		EQU			2				; (1 = 1/2 pot) 			- 1/2 scale pot reduction
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpMux1') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpMux1		EQU			3				; (1 = 1/4 pot) 			- 1/4 scale pot reduction
+	ENDIF ; generated for fun
+	IF &TYPE('PontiLmpSPIDir') = 'UNDEFINED' THEN ; generated for fun
+PontiLmpSPIDir		EQU			4				; (1 = shift out) 			- direction of shift register
+	ENDIF ; generated for fun
+												;									<SM4> rb, end
+;-------------------------------------																		<H21> thru next <H21>
+;	djMEMC memory controller equates
+;-------------------------------------
+
+;	This hard-coded I/O address is in here because there is no more room in the
+;	Universal tables to hold this information.
+
+	IF &TYPE('MEMCAddr') = 'UNDEFINED' THEN ; generated for fun
+MEMCAddr			EQU		$50F0E000				; same for both Wombat + WLCD memory maps
+	ENDIF ; generated for fun
+
+	IF &TYPE('MEMCRegisterStart') = 'UNDEFINED' THEN ; generated for fun
+MEMCRegisterStart	EQU		0
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCIntleaveEnable') = 'UNDEFINED' THEN ; generated for fun
+MEMCIntleaveEnable	EQU		MEMCRegisterStart		; DRAM interleave enable reg.
+	ENDIF ; generated for fun
+	IF &TYPE('dj_OneBufferedBusBit') = 'UNDEFINED' THEN ; generated for fun
+dj_OneBufferedBusBit EQU	5
+	ENDIF ; generated for fun
+;	djMEMC supports up to a maximum of 10 (TEN) DRAM banks
+	IF &TYPE('dj_MaxBanks') = 'UNDEFINED' THEN ; generated for fun
+dj_MaxBanks			EQU		10						;														<H22>
+	ENDIF ; generated for fun
+
+	IF &TYPE('MEMCDRAMCfg0') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg0		EQU		MEMCIntleaveEnable+4	; Bank 0 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg1') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg1		EQU		MEMCDRAMCfg0+4			; Bank 1 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg2') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg2		EQU		MEMCDRAMCfg1+4			; Bank 2 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg3') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg3		EQU		MEMCDRAMCfg2+4			; Bank 3 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg4') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg4		EQU		MEMCDRAMCfg3+4			; Bank 4 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg5') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg5		EQU		MEMCDRAMCfg4+4			; Bank 5 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg6') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg6		EQU		MEMCDRAMCfg5+4			; Bank 6 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg7') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg7		EQU		MEMCDRAMCfg6+4			; Bank 7 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg8') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg8		EQU		MEMCDRAMCfg7+4			; Bank 8 cfg reg
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCDRAMCfg9') = 'UNDEFINED' THEN ; generated for fun
+MEMCDRAMCfg9		EQU		MEMCDRAMCfg8+4			; Bank 9 cfg reg
+	ENDIF ; generated for fun
+
+	IF &TYPE('MEMCmemTop') = 'UNDEFINED' THEN ; generated for fun
+MEMCmemTop			EQU		MEMCDRAMCfg9+4			; Top of stitched RAM
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCconfig') = 'UNDEFINED' THEN ; generated for fun
+MEMCconfig			EQU		MEMCmemTop+4			; "Multiple bit DRAM/ROM configuration register"
+	ENDIF ; generated for fun
+	IF &TYPE('MEMCRefresh') = 'UNDEFINED' THEN ; generated for fun
+MEMCRefresh			EQU		MEMCconfig+4			; DRAM refresh rate register
+	ENDIF ; generated for fun
+
+
+;__________________________________________________________________________________________
+;
+;
+; Interrupt Vector Definitions and Masks
+;
+;
+;__________________________________________________________________________________________
+
+
+
+;---------------------------------------------------
+; Interrupt Masks
+;---------------------------------------------------
+
+	IF &TYPE('hiIntMask') = 'UNDEFINED' THEN ; generated for fun
+hiIntMask 		EQU 		$0700					; programmer switch only
+	ENDIF ; generated for fun
+	IF &TYPE('pwrOffEnbl') = 'UNDEFINED' THEN ; generated for fun
+pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('sccIntMask') = 'UNDEFINED' THEN ; generated for fun
+sccIntMask		EQU 		$0400					; SCC interrupt level
+	ENDIF ; generated for fun
+	IF &TYPE('sccEnblMask') = 'UNDEFINED' THEN ; generated for fun
+sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('slotIntMask') = 'UNDEFINED' THEN ; generated for fun
+slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
+	ENDIF ; generated for fun
+	IF &TYPE('viaIntMask') = 'UNDEFINED' THEN ; generated for fun
+viaIntMask		EQU 		$0100					; VIA1 interrupt level
+	ENDIF ; generated for fun
+	IF &TYPE('loIntMask') = 'UNDEFINED' THEN ; generated for fun
+loIntMask 		EQU 		$0100
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Hardware Base Addresses
+;---------------------------------------------------
+
+	IF &TYPE('WrOffs') = 'UNDEFINED' THEN ; generated for fun
+WrOffs			EQU			0						; SCSI write addrs are same as read base
+	ENDIF ; generated for fun
+	IF &TYPE('MskIOP1') = 'UNDEFINED' THEN ; generated for fun
+MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
+	ENDIF ; generated for fun
+	IF &TYPE('MskVIA1') = 'UNDEFINED' THEN ; generated for fun
+MskVIA1			EQU			1						; VIA 1 is level 1
+	ENDIF ; generated for fun
+	IF &TYPE('MskADB') = 'UNDEFINED' THEN ; generated for fun
+MskADB			EQU			1						; ADB is level 1
+	ENDIF ; generated for fun
+	IF &TYPE('Msk60Hz') = 'UNDEFINED' THEN ; generated for fun
+Msk60Hz			EQU			1						; 60 Hz is level 1
+	ENDIF ; generated for fun
+	IF &TYPE('MskSCSI') = 'UNDEFINED' THEN ; generated for fun
+MskSCSI			EQU			2						; SCSI is level 2
+	ENDIF ; generated for fun
+	IF &TYPE('MskSound') = 'UNDEFINED' THEN ; generated for fun
+MskSound		EQU			2						; sound is level 2						<4.5>
+	ENDIF ; generated for fun
+	IF &TYPE('MskSlots') = 'UNDEFINED' THEN ; generated for fun
+MskSlots		EQU			2						; slots are level 2 interrupts
+	ENDIF ; generated for fun
+	IF &TYPE('MskRTC') = 'UNDEFINED' THEN ; generated for fun
+MskRTC			EQU			3						; RTC is level 3
+	ENDIF ; generated for fun
+	IF &TYPE('MskIOP0') = 'UNDEFINED' THEN ; generated for fun
+MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
+	ENDIF ; generated for fun
+	IF &TYPE('MskPwrOff') = 'UNDEFINED' THEN ; generated for fun
+MskPwrOff		EQU			6						; Poweroff button is level 6
+	ENDIF ; generated for fun
+	IF &TYPE('MskNMI') = 'UNDEFINED' THEN ; generated for fun
+MskNMI			EQU			7						; NMI switch is level 7
+	ENDIF ; generated for fun
+
+
+; ---------------------------------------------------------------------------------------------------	<T8>
+;		Bit definitions for the Cache Control Register (CACR) on various CPUs							<T8>
+; ---------------------------------------------------------------------------------------------------	<T8>
+;
+;	020 CACR:		(from MC68020 User's Manual, 3rd Ed.  pg. 6-3)										<T8>
+;			+------------------------------------------------+											<T8>
+;			|  0  ..............  0 |  C  |  CE  |  F  |  E  |											<T8>
+;			+------------------------------------------------+											<T8>
+;			  31                  4    3      2     1     0												<T8>
+;
+;				C   =  Clear Cache																		<T8>
+;				CE  =  Clear Entry																		<T8>
+;				F   =  Freeze Cache																		<T8>
+;				E   =  Enable (Inst.) Cache																<T8>
+;
+;
+;	030 CACR:		(from MC68030 User's Manual, 2nd Ed.  pg 6-15)										<T8>
+;			+------------------------------------------------------------------------------------+		<T8>
+;			|  0  ...  0  | WA | DBE | CD | CED | FD | ED | 0 | 0 | 0 | IBE | CI | CEI | FI | EI |		<T8>
+;			+------------------------------------------------------------------------------------+		<T8>
+;			 31       14    13    12   11    10    9    8   7   6   5    4    3     2    1     0		<T8>
+;
+;				WA  =	Write Allocate																	<T8>
+;				DBE =	Data Burst Allocate																<T8>
+;				CD	=	Clear Data Cache																<T8>
+;				CED	=	Clear Entry in Data Cache														<T8>
+;				FD	=	Freeze Data Cache																<T8>
+;				ED	=	Enable Data Cache																<T8>
+;				IBE	=	Instruction Burst Enable														<T8>
+;				CI	=	Clear Instruction Cache															<T8>
+;				CEI	=	Clear Entry in Instruction Cache												<T8>
+;				FI	=	Freeze Instruction Cache														<T8>
+;				EI	=	Enable Instruction Cache														<T8>
+;
+;
+;	040 CACR:		(from MC68040 User's Manual, 1st Ed.,  pg. 7-19)									<T8>
+;			+-------------------------------------+														<T8>
+;			|  DE  |  0 ... 0  |  IE  |  0 ... 0  |														<T8>
+;			+-------------------------------------+														<T8>
+;			   31    30     16    15    14     0														<T8>
+;
+;				DE	=	Enable Data Cache																<T8>
+;				IE	=	Enable Instruction Cache														<T8>
+;
+
+;	MC68040 CACR bits of note:
+
+	IF &TYPE('CACR_IE_040') = 'UNDEFINED' THEN ; generated for fun
+CACR_IE_040				EQU		15				; bit # of instruction cache enable/disable on 040s		<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_DE_040') = 'UNDEFINED' THEN ; generated for fun
+CACR_DE_040				EQU		31				; bit # of data cache enable/disable on 040s			<T8>
+	ENDIF ; generated for fun
+
+;	MC68020 and MC68030 CACR bits of note:
+
+	IF &TYPE('CACR_EI_020_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_EI_020_030			EQU		0				; bit # of inst. cache enable/disable on 020/030s		<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_FI_020_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_FI_020_030			EQU		1				; bit # of inst. cache freeze on 020/030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_CEI_020_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_CEI_020_030		EQU		2				; bit # of inst. cache flush entry on 020/030s			<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_CI_020_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_CI_020_030			EQU		3				; bit # of inst. cache flush on 020/030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_IBE_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_IBE_030			EQU		4				; bit # of data cache burst enable on 030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_ED_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_ED_030				EQU		8				; bit # of data cache enable/disable on 030s			<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_FD_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_FD_030				EQU		9				; bit # of data cache freeze on 030s					<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_CED_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_CED_030			EQU		10				; bit # of data cache flush entry on 030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_CD_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_CD_030				EQU		11				; bit # of data cache flush on 030s						<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_DBE_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_DBE_030			EQU		12				; bit # of data cache burst enable on 030s				<T8>
+	ENDIF ; generated for fun
+	IF &TYPE('CACR_WA_030') = 'UNDEFINED' THEN ; generated for fun
+CACR_WA_030				EQU		13				; bit # of write allocate enable on 030s				<T8>
+	ENDIF ; generated for fun
+
+;__________________________________________________________________________________________
+;
+;
+; Miscellaneous Equates - Look Here If You Can't Find It Anywhere Else.
+;
+;
+;__________________________________________________________________________________________
+
+
+
+	IF &TYPE('Machine') = 'UNDEFINED' THEN ; generated for fun
+Machine   		EQU 		7						; new Machine number for patches			<18>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; System Software Information
+;---------------------------------------------------
+
+	IF &TYPE('numOsTrap') = 'UNDEFINED' THEN ; generated for fun
+numOsTrap 		EQU 		256   					; number of os traps
+	ENDIF ; generated for fun
+	IF &TYPE('ToolTable') = 'UNDEFINED' THEN ; generated for fun
+ToolTable 		EQU 		$0E00 					; start of toolbox trap table
+	ENDIF ; generated for fun
+	IF &TYPE('numTbTrap') = 'UNDEFINED' THEN ; generated for fun
+numTbTrap 		EQU 		1024   					; number of toolbox traps
+	ENDIF ; generated for fun
+	IF &TYPE('numTrapMask') = 'UNDEFINED' THEN ; generated for fun
+numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
+	ENDIF ; generated for fun
+	IF &TYPE('JMemMgr24') = 'UNDEFINED' THEN ; generated for fun
+JMemMgr24		EQU			$1E00					; jump vector start for 24 bit Memory Manager 		<v1.9>
+	ENDIF ; generated for fun
+	IF &TYPE('JMemMgr32') = 'UNDEFINED' THEN ; generated for fun
+JMemMgr32		EQU			$1F00					; jump vector start for 32 bit Memory Manager 		<v1.9>
+	ENDIF ; generated for fun
+	IF &TYPE('HeapStart') = 'UNDEFINED' THEN ; generated for fun
+HeapStart 		EQU 		$2800 					; Low mem is now 10k bytes							<SM13>
+	ENDIF ; generated for fun
+	IF &TYPE('defSysHeap') = 'UNDEFINED' THEN ; generated for fun
+defSysHeap		EQU 		$18000    				; Default size of the system heap
+	ENDIF ; generated for fun
+	IF &TYPE('nDfltStackSize') = 'UNDEFINED' THEN ; generated for fun
+nDfltStackSize	EQU 		$6000 					; Default stack size
+	ENDIF ; generated for fun
+
+**** maybe not so temporary to allow things to build ****									<3.5>
+	IF &TYPE('oneSecConst') = 'UNDEFINED' THEN ; generated for fun
+oneSecConst   	EQU 		8 						; gets converted to $80000 for onesec constant<3.5>
+	ENDIF ; generated for fun
+	IF BlackBirdDebug THEN
+	IF &TYPE('ROMStart') = 'UNDEFINED' THEN ; generated for fun
+ROMStart  		EQU 		$40000000 				; ••PN BlackBirdstarting address of final ROM code	<3.5>
+	ENDIF ; generated for fun
+	ELSE
+	IF &TYPE('ROMStart') = 'UNDEFINED' THEN ; generated for fun
+ROMStart  		EQU 		$40800000 				; starting address of final ROM code	<3.5>
+	ENDIF ; generated for fun
+	ENDIF
+	IF &TYPE('snd2MemTop') = 'UNDEFINED' THEN ; generated for fun
+snd2MemTop		EQU 		$300  					; SoundLow to Memtop
+	ENDIF ; generated for fun
+	IF &TYPE('pwm2MemTop') = 'UNDEFINED' THEN ; generated for fun
+pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
+	ENDIF ; generated for fun
+	IF &TYPE('bufWorldSize') = 'UNDEFINED' THEN ; generated for fun
+bufWorldSize  	EQU 		8192		   			; total size of the BufPtr world		<H16>
+	ENDIF ; generated for fun
+
+;---------------------------------------------------								<SM4> rb, start
+;  Sound parameters																			<P4>
+;---------------------------------------------------
+	IF &TYPE('sampleSize') = 'UNDEFINED' THEN ; generated for fun
+sampleSize		equ			4				; number of bytes per sample
+	ENDIF ; generated for fun
+	IF &TYPE('bufferSize') = 'UNDEFINED' THEN ; generated for fun
+bufferSize		equ			960				; number of samples per buffer
+	ENDIF ; generated for fun
+	IF &TYPE('sampleRate') = 'UNDEFINED' THEN ; generated for fun
+sampleRate		equ			24 * 1024		; 24KHz sample rate
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+;  PSC Hardware Defs
+;---------------------------------------------------
+
+; === Hardware Base Addresses ===
+	IF &TYPE('PSCBase') = 'UNDEFINED' THEN ; generated for fun
+PSCBase			equ			$50f31000		; Base address of the PSC
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+;  PSC Sound Register Offsets
+;---------------------------------------------------
+	IF &TYPE('sndComCtl') = 'UNDEFINED' THEN ; generated for fun
+sndComCtl		equ			$200			; [word] sound and communications control
+	ENDIF ; generated for fun
+	IF &TYPE('singerCtl') = 'UNDEFINED' THEN ; generated for fun
+singerCtl		equ			$204			; [long] singer sound CODEC control
+	ENDIF ; generated for fun
+	IF &TYPE('singerStat') = 'UNDEFINED' THEN ; generated for fun
+singerStat		equ			$208			; [long] singer sound CODEC status  (read only)
+	ENDIF ; generated for fun
+	IF &TYPE('sndPhase') = 'UNDEFINED' THEN ; generated for fun
+sndPhase		equ			$20c			; [long] sound subsystem phase  (read only)
+	ENDIF ; generated for fun
+	IF &TYPE('sndInBase') = 'UNDEFINED' THEN ; generated for fun
+sndInBase		equ			$210			; [long] sound input double-buffer base address
+	ENDIF ; generated for fun
+	IF &TYPE('sndOutBase') = 'UNDEFINED' THEN ; generated for fun
+sndOutBase		equ			$214			; [long] sound output double buffer base address
+	ENDIF ; generated for fun
+	IF &TYPE('sndSize') = 'UNDEFINED' THEN ; generated for fun
+sndSize			equ			$218			; [word] sound input and output buffer size
+	ENDIF ; generated for fun
+	IF &TYPE('dspOverRun') = 'UNDEFINED' THEN ; generated for fun
+dspOverRun		equ			$21C			; [byte] DSP overrun status register.
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+;  PSC Sound Register Bit Definitions
+;---------------------------------------------------
+; === sndComCtl register ===
+	IF &TYPE('pSubFrmInSel') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmInSel	equ			0				; singer sound CODEC input subframe select
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmInSel1') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmInSel1	equ			0				; singer sound CODEC input subframe select, lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmInSel2') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmInSel2	equ			1				; singer sound CODEC input subframe select, msbit
+	ENDIF ; generated for fun
+
+	IF &TYPE('pSubFrmOutSel') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel	equ			2				; singer sound CODEC output subframe select
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmOutSel1') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel1	equ			2				; singer sound CODEC output subframe select, lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmOutSel2') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel2	equ			3				; singer sound CODEC output subframe select
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmOutSel3') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel3	equ			4				; singer sound CODEC output subframe select
+	ENDIF ; generated for fun
+	IF &TYPE('pSubFrmOutSel4') = 'UNDEFINED' THEN ; generated for fun
+pSubFrmOutSel4	equ			5				; singer sound CODEC output subframe select, msbit
+	ENDIF ; generated for fun
+
+	IF &TYPE('pFrmIntEn') = 'UNDEFINED' THEN ; generated for fun
+pFrmIntEn		equ			6				; frame interrupt enable
+	ENDIF ; generated for fun
+	IF &TYPE('pSndInEn') = 'UNDEFINED' THEN ; generated for fun
+pSndInEn		equ			7				; sound input DMA enable
+	ENDIF ; generated for fun
+	IF &TYPE('pSndOutEn') = 'UNDEFINED' THEN ; generated for fun
+pSndOutEn		equ			8				; sound output DMA enable
+	ENDIF ; generated for fun
+
+	IF &TYPE('pSndRate') = 'UNDEFINED' THEN ; generated for fun
+pSndRate		equ			9				; singer sound CODEC sampling rate control
+	ENDIF ; generated for fun
+	IF &TYPE('pSndRate1') = 'UNDEFINED' THEN ; generated for fun
+pSndRate1		equ			9				; singer sound CODEC sampling rate control, lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pSndRate2') = 'UNDEFINED' THEN ; generated for fun
+pSndRate2		equ			10				; singer sound CODEC sampling rate control, msbit
+	ENDIF ; generated for fun
+
+	IF &TYPE('pComRate') = 'UNDEFINED' THEN ; generated for fun
+pComRate		equ			11				; communications CODEC sampling rate contrl
+	ENDIF ; generated for fun
+	IF &TYPE('pComRate1') = 'UNDEFINED' THEN ; generated for fun
+pComRate1		equ			11				; communications CODEC sampling rate contrl, lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pComRate2') = 'UNDEFINED' THEN ; generated for fun
+pComRate2		equ			12				; communications CODEC sampling rate contrl, msbit
+	ENDIF ; generated for fun
+;				equ			13				; unused
+;				equ			14				; unused
+;				equ			15				; unused
+
+
+	IF &TYPE('sndComCtlInit') = 'UNDEFINED' THEN ; generated for fun
+sndComCtlInit 	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
+							(0<<pSubFrmOutSel)|\	; Ouput subframe zero selected
+							(0<<pFrmIntEn)|\		; frame interrupts disabled
+							(0<<pSndInEn)|\			; sound input disabled
+							(0<<pSndOutEn)|\		; sound output disabled
+							(0<<pSndRate)|\			; 24KHz sampling rate selected
+							(0<<pComRate)			; communications CODEC, we just don't care
+	ENDIF ; generated for fun
+
+	IF &TYPE('soundOutEnable') = 'UNDEFINED' THEN ; generated for fun
+soundOutEnable	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
+							(1<<pSubFrmOutSel)|\	; Ouput subframe zero selected
+							(0<<pFrmIntEn)|\		; frame interrupts enabled
+							(0<<pSndInEn)|\			; sound input disabled
+							(1<<pSndOutEn)|\		; sound output disabled
+							(0<<pSndRate)|\			; 24KHz sampling rate selected
+							(0<<pComRate)			; communications CODEC, we just don't care
+	ENDIF ; generated for fun
+
+
+
+; === singerCtl register ===
+	IF &TYPE('pOutputPort') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort	equ			0					; set digital output port
+	ENDIF ; generated for fun
+	IF &TYPE('pOutputPort1') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort1	equ			0				; set digital output port, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pOutputPort2') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort2	equ			1				; set digital output port
+	ENDIF ; generated for fun
+	IF &TYPE('pOutputPort3') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort3	equ			2				; set digital output port
+	ENDIF ; generated for fun
+	IF &TYPE('pOutputPort4') = 'UNDEFINED' THEN ; generated for fun
+pOutputPort4	equ			3				; set digital output port, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pRightAtten') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten		equ			4				; right ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pRightAtten1') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten1	equ			4				; right ouput attenutaion, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pRightAtten2') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten2	equ			5				; right ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pRightAtten3') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten3	equ			6				; right ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pRightAtten4') = 'UNDEFINED' THEN ; generated for fun
+pRightAtten4	equ			7				; right ouput attenutaion, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pLeftAtten') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten		equ			8				; Left ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftAtten1') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten1		equ			8				; Left ouput attenutaion, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftAtten2') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten2		equ			9				; Left ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftAtten3') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten3		equ			10				; Left ouput attenutaion
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftAtten4') = 'UNDEFINED' THEN ; generated for fun
+pLeftAtten4		equ			11				; Left ouput attenutaion, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pRightGain') = 'UNDEFINED' THEN ; generated for fun
+pRightGain		equ			12				; right input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pRightGain1') = 'UNDEFINED' THEN ; generated for fun
+pRightGain1		equ			12				; right input gain, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pRightGain2') = 'UNDEFINED' THEN ; generated for fun
+pRightGain2		equ			13				; right input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pRightGain3') = 'UNDEFINED' THEN ; generated for fun
+pRightGain3		equ			14				; right input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pRightGain4') = 'UNDEFINED' THEN ; generated for fun
+pRightGain4		equ			15				; right input gain, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pLeftGain') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain		equ			16				; left input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftGain1') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain1		equ			16				; left input gain, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftGain2') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain2		equ			17				; left input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftGain3') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain3		equ			18				; left input gain
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftGain4') = 'UNDEFINED' THEN ; generated for fun
+pLeftGain4		equ			19				; left input gain, msb
+	ENDIF ; generated for fun
+
+	IF &TYPE('pRightInMux') = 'UNDEFINED' THEN ; generated for fun
+pRightInMux		equ			20				; right input mux
+	ENDIF ; generated for fun
+	IF &TYPE('pLeftInMux') = 'UNDEFINED' THEN ; generated for fun
+pLeftInMux		equ			21				; left input mux
+	ENDIF ; generated for fun
+	IF &TYPE('pMute') = 'UNDEFINED' THEN ; generated for fun
+pMute			equ			22				; mute bit
+	ENDIF ; generated for fun
+	IF &TYPE('pExpCtl') = 'UNDEFINED' THEN ; generated for fun
+pExpCtl			equ			23				; expand bit for control
+	ENDIF ; generated for fun
+;				equ			24				; unused
+;				equ			25				; unused
+;				equ			26				; unused
+;				equ			27				; unused
+;				equ			28				; unused
+;				equ			29				; unused
+;				equ			30				; unused
+;				equ			31				; unused
+
+	IF &TYPE('singerCtlInit') = 'UNDEFINED' THEN ; generated for fun
+singerCtlInit	equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
+							(0<<pRightAtten)|\		; right output attenuation set to zero
+							(0<<pLeftAtten)|\		; left output attenuation set to zero
+							(%0101<<pRightGain)|\	; right input gain set to middle
+							(%0101<<pLeftGain)|\	; left input gain set to middle
+							(0<<pRightInMux)|\		; input muxes irrelevant
+							(0<<pLeftInMux)|\		;
+							(1<<pMute)|\			; mute ON
+							(0<<pExpCtl)			; no expand
+	ENDIF ; generated for fun
+
+	IF &TYPE('unMute') = 'UNDEFINED' THEN ; generated for fun
+unMute			equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
+							(0<<pRightAtten)|\		; right output attenuation set to zero
+							(0<<pLeftAtten)|\		; left output attenuation set to zero
+							(%0101<<pRightGain)|\	; right input gain set to middle
+							(%0101<<pLeftGain)|\	; left input gain set to middle
+							(0<<pRightInMux)|\		; input muxes irrelevant
+							(0<<pLeftInMux)|\		;
+							(0<<pMute)|\			; mute OFF
+							(0<<pExpCtl)			; no expand
+	ENDIF ; generated for fun
+
+
+
+; === singerStat register ===
+	IF &TYPE('pInputPort1') = 'UNDEFINED' THEN ; generated for fun
+pInputPort1		equ			0				; set digital Input port, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pInputPort2') = 'UNDEFINED' THEN ; generated for fun
+pInputPort2		equ			1				; set digital Input port
+	ENDIF ; generated for fun
+	IF &TYPE('pInputPort3') = 'UNDEFINED' THEN ; generated for fun
+pInputPort3		equ			2				; set digital Input port
+	ENDIF ; generated for fun
+	IF &TYPE('pInputPort4') = 'UNDEFINED' THEN ; generated for fun
+pInputPort4		equ			3				; set digital Input port, msb
+	ENDIF ; generated for fun
+;				equ			4				; unused
+;				equ			5				; unused
+;				equ			6				; unused
+;				equ			7				; unused
+;				equ			8				; unused
+;				equ			9				; unused
+;				equ			10				; unused
+;				equ			11				; unused
+	IF &TYPE('pRevNum1') = 'UNDEFINED' THEN ; generated for fun
+pRevNum1		equ			12				; revision number, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pRevNum2') = 'UNDEFINED' THEN ; generated for fun
+pRevNum2		equ			13				; revision number
+	ENDIF ; generated for fun
+	IF &TYPE('pRevNum3') = 'UNDEFINED' THEN ; generated for fun
+pRevNum3		equ			14				; revision number
+	ENDIF ; generated for fun
+	IF &TYPE('pRevNum4') = 'UNDEFINED' THEN ; generated for fun
+pRevNum4		equ			15				; revision number, msb
+	ENDIF ; generated for fun
+	IF &TYPE('pSingerStatus1') = 'UNDEFINED' THEN ; generated for fun
+pSingerStatus1	equ			16				; status bits, lsb
+	ENDIF ; generated for fun
+	IF &TYPE('pSingerStatus2') = 'UNDEFINED' THEN ; generated for fun
+pSingerStatus2	equ			17				; status bits
+	ENDIF ; generated for fun
+	IF &TYPE('pSingerStatus3') = 'UNDEFINED' THEN ; generated for fun
+pSingerStatus3	equ			18				; status bits
+	ENDIF ; generated for fun
+	IF &TYPE('pSingerStatus4') = 'UNDEFINED' THEN ; generated for fun
+pSingerStatus4	equ			19				; status bits, msb
+	ENDIF ; generated for fun
+	IF &TYPE('pOFRight') = 'UNDEFINED' THEN ; generated for fun
+pOFRight		equ			20				; right channel overflow
+	ENDIF ; generated for fun
+	IF &TYPE('pOFLeft') = 'UNDEFINED' THEN ; generated for fun
+pOFLeft			equ			21				; left channel overflow
+	ENDIF ; generated for fun
+	IF &TYPE('pValidData') = 'UNDEFINED' THEN ; generated for fun
+pValidData		equ			22				; valid sound data
+	ENDIF ; generated for fun
+	IF &TYPE('pExpStat') = 'UNDEFINED' THEN ; generated for fun
+pExpStat		equ			23				; expand bit for status
+	ENDIF ; generated for fun
+;				equ			24				; unused
+;				equ			25				; unused
+;				equ			26				; unused
+;				equ			27				; unused
+;				equ			28				; unused
+;				equ			29				; unused
+;				equ			30				; unused
+;				equ			31				; unused
+
+
+; === sound phase register ===
+	IF &TYPE('pPreScaleLSB') = 'UNDEFINED' THEN ; generated for fun
+pPreScaleLSB	equ			0				; pre-scaler lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pReScaleMSB') = 'UNDEFINED' THEN ; generated for fun
+pReScaleMSB		equ			5				; pre-Scaler msbit
+	ENDIF ; generated for fun
+	IF &TYPE('pOffsetLSB') = 'UNDEFINED' THEN ; generated for fun
+pOffsetLSB		equ			6				; sample offset lsbit
+	ENDIF ; generated for fun
+	IF &TYPE('pOffsetMSB') = 'UNDEFINED' THEN ; generated for fun
+pOffsetMSB		equ			17				; sample offset msbit
+	ENDIF ; generated for fun
+;				equ			18				; unused
+;				equ			19				; unused
+;				equ			20				; unused
+;				equ			21				; unused
+;				equ			22				; unused
+;				equ			23				; unused
+;				equ			24				; unused
+;				equ			25				; unused
+;				equ			26				; unused
+;				equ			27				; unused
+;				equ			28				; unused
+;				equ			29				; unused
+;				equ			30				; unused
+;				equ			31				; unused
+
+	IF &TYPE('phaseOffsetMsk') = 'UNDEFINED' THEN ; generated for fun
+phaseOffsetMsk	equ			$003FFFC0		;										<SM4> rb, end
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; PSC DSP Register Bit Definitions						<SM10> ejb
+;---------------------------------------------------
+
+; === dspOverrun register ===
+	IF &TYPE('pdspReset') = 'UNDEFINED' THEN ; generated for fun
+pdspReset		equ			0				; when set places the dsp in reset state
+	ENDIF ; generated for fun
+	IF &TYPE('pdspResetEn') = 'UNDEFINED' THEN ; generated for fun
+pdspResetEn		equ			1				; when cleared disables the dspReset bit
+	ENDIF ; generated for fun
+	IF &TYPE('pdspFrameOvr') = 'UNDEFINED' THEN ; generated for fun
+pdspFrameOvr	equ			2				; when set indicates cat2 frame overrun on the dsp
+	ENDIF ; generated for fun
+;				equ			3				; unused
+;				equ			4				; unused
+;				equ			5				; unused
+;				equ			6				; unused
+	IF &TYPE('pdspSet') = 'UNDEFINED' THEN ; generated for fun
+pdspSet			equ			7				; "0" clears, "1" sets for any bit field [0:6] containing a "1"
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; ???
+;---------------------------------------------------
+
+	IF &TYPE('seRegs') = 'UNDEFINED' THEN ; generated for fun
+seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
+	ENDIF ; generated for fun
+
+;---------------------------------------------------
+; Hardware configuration bits.
+;---------------------------------------------------
+
+	IF &TYPE('hwCbSCSI') = 'UNDEFINED' THEN ; generated for fun
+hwCbSCSI  		EQU 		15        				; SCSI port present
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbClock') = 'UNDEFINED' THEN ; generated for fun
+hwCbClock 		EQU 		14        				; New clock chip present
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbExPRAM') = 'UNDEFINED' THEN ; generated for fun
+hwCbExPRAM		EQU 		13        				; Extra Parameter Ram valid.
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbFPU') = 'UNDEFINED' THEN ; generated for fun
+hwCbFPU   		EQU 		12        				; FPU chip present.
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbMMU') = 'UNDEFINED' THEN ; generated for fun
+hwCbMMU   		EQU 		11        				; Some kind of MMU present (see MMUType for what kind).
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbADB') = 'UNDEFINED' THEN ; generated for fun
+hwCbADB   		EQU 		10        				; Apple Desktop Bus present.
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbAUX') = 'UNDEFINED' THEN ; generated for fun
+hwCbAUX			EQU			9						; Running A/UX					<2.8>
+	ENDIF ; generated for fun
+	IF &TYPE('hwCbPwrMgr') = 'UNDEFINED' THEN ; generated for fun
+hwCbPwrMgr		EQU			8						; Power Manager present			<2.8>
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmSCSI') = 'UNDEFINED' THEN ; generated for fun
+hwCmSCSI  		EQU 		(1 << hwCbSCSI)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmClock') = 'UNDEFINED' THEN ; generated for fun
+hwCmClock 		EQU 		(1 << hwCbClock)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmExPRAM') = 'UNDEFINED' THEN ; generated for fun
+hwCmExPRAM		EQU 		(1 << hwCbExPRAM)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmFPU') = 'UNDEFINED' THEN ; generated for fun
+hwCmFPU   		EQU 		(1 << hwCbFPU)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmMMU') = 'UNDEFINED' THEN ; generated for fun
+hwCmMMU   		EQU 		(1 << hwCbMMU)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmADB') = 'UNDEFINED' THEN ; generated for fun
+hwCmADB   		EQU 		(1 << hwCbADB)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmAUX') = 'UNDEFINED' THEN ; generated for fun
+hwCmAUX			EQU			(1 << hwCbAUX)
+	ENDIF ; generated for fun
+	IF &TYPE('hwCmPwrMgr') = 'UNDEFINED' THEN ; generated for fun
+hwCmPwrMgr		EQU			(1 << hwCbPwrMgr)
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; HcMac Clock Change Addresses
+;---------------------------------------------------
+
+	IF &TYPE('Clock16M') = 'UNDEFINED' THEN ; generated for fun
+Clock16M  		EQU 		$FE0000   				; Go to sixteen megahertz clock throughput
+	ENDIF ; generated for fun
+	IF &TYPE('Clock1M') = 'UNDEFINED' THEN ; generated for fun
+Clock1M   		EQU 		$FE0002   				; Go to one megahertz clock throughput (adds 64 wait states)
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; SCC Clock Rates, Baud Rate Constants
+;---------------------------------------------------
+
+	IF &TYPE('nuMacClock') = 'UNDEFINED' THEN ; generated for fun
+nuMacClock		EQU 		36864
+	ENDIF ; generated for fun
+	IF &TYPE('nuMacConst') = 'UNDEFINED' THEN ; generated for fun
+nuMacConst		EQU 		115200
+	ENDIF ; generated for fun
+
+	IF &TYPE('macClock') = 'UNDEFINED' THEN ; generated for fun
+macClock  		EQU 		36707 					; in Hz * 100
+	ENDIF ; generated for fun
+	IF &TYPE('macConst') = 'UNDEFINED' THEN ; generated for fun
+macConst  		EQU 		114709    				; in Hz/32
+	ENDIF ; generated for fun
+
+	IF &TYPE('hcMacClock') = 'UNDEFINED' THEN ; generated for fun
+hcMacClock		EQU 		36720 					; SCC clock rates
+	ENDIF ; generated for fun
+	IF &TYPE('hcMacConst') = 'UNDEFINED' THEN ; generated for fun
+hcMacConst		EQU 		114750
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Deep Shit Rectangle info
+;---------------------------------------------------
+
+	IF &TYPE('dsRectTL') = 'UNDEFINED' THEN ; generated for fun
+dsRectTL  		EQU 		(64<<16)+32       		; top left = 64,32
+	ENDIF ; generated for fun
+	IF &TYPE('dsRectBR') = 'UNDEFINED' THEN ; generated for fun
+dsRectBR  		EQU 		(190<<16)+480     		; bottom right = 190,480
+	ENDIF ; generated for fun
+	IF &TYPE('dsRectHei') = 'UNDEFINED' THEN ; generated for fun
+dsRectHei 		EQU 		(DSrectBR**$FFFF0000)-(DSrectTL**$FFFF0000)>>16
+	ENDIF ; generated for fun
+	IF &TYPE('dsRectLen') = 'UNDEFINED' THEN ; generated for fun
+dsRectLen 		EQU 		(DSrectBR**$FFFF)-(DSrectTL**$FFFF)
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; System Error Equates
+;---------------------------------------------------
+
+	IF &TYPE('seVars') = 'UNDEFINED' THEN ; generated for fun
+seVars			EQU 		seRegs        			; start of system error data space (wrap city)
+	ENDIF ; generated for fun
+	IF &TYPE('seVSize') = 'UNDEFINED' THEN ; generated for fun
+seVSize   		EQU 		128       				; # of bytes in space
+	ENDIF ; generated for fun
+	IF &TYPE('seD0') = 'UNDEFINED' THEN ; generated for fun
+seD0  			EQU 		seVars        			; loc of saved reg D0
+	ENDIF ; generated for fun
+	IF &TYPE('seA0') = 'UNDEFINED' THEN ; generated for fun
+seA0  			EQU 		seD0+32       			; loc of saved reg A0
+	ENDIF ; generated for fun
+	IF &TYPE('seA7') = 'UNDEFINED' THEN ; generated for fun
+seA7  			EQU 		seA0+28       			; loc of saved reg A7
+	ENDIF ; generated for fun
+	IF &TYPE('sePC') = 'UNDEFINED' THEN ; generated for fun
+sePC  			EQU 		seA7+4        			; loc of saved PC
+	ENDIF ; generated for fun
+	IF &TYPE('seSR') = 'UNDEFINED' THEN ; generated for fun
+seSR  			EQU 		sePC+4        			; loc of saved SR
+	ENDIF ; generated for fun
+	IF &TYPE('seAccess') = 'UNDEFINED' THEN ; generated for fun
+seAccess  		EQU 		seSR+2        			; PC address during bus/address error
+	ENDIF ; generated for fun
+	IF &TYPE('seCmdSize') = 'UNDEFINED' THEN ; generated for fun
+seCmdSize 		EQU 		seAccess+4    			; # of bytes of parameters passed in _debugger call
+	ENDIF ; generated for fun
+	IF &TYPE('se000BE') = 'UNDEFINED' THEN ; generated for fun
+se000BE   		EQU 		seCmdSize+2       		; 8 bytes of bus error info for 68000
+	ENDIF ; generated for fun
+	IF &TYPE('seLastVar') = 'UNDEFINED' THEN ; generated for fun
+seLastVar 		EQU 		se000BE+8     			; last var in System Error data space
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; ROM based debugger nub
+;---------------------------------------------------
+
+	IF &TYPE('rdPort') = 'UNDEFINED' THEN ; generated for fun
+rdPort			EQU 		seLastVar     			; Number of port currently in use (0 => no link, 1 => A, 2 => B)
+	ENDIF ; generated for fun
+	IF &TYPE('rdCode') = 'UNDEFINED' THEN ; generated for fun
+rdCode			EQU 		rdPort+2      			; Ptr to code download buffer.
+	ENDIF ; generated for fun
+	IF &TYPE('rdAtrap') = 'UNDEFINED' THEN ; generated for fun
+rdAtrap   		EQU 		rdCode+4      			; Saved Rom Atrap handler
+	ENDIF ; generated for fun
+	IF &TYPE('rdLowTrap') = 'UNDEFINED' THEN ; generated for fun
+rdLowTrap 		EQU 		rdAtrap+4     			; low value for trap handling
+	ENDIF ; generated for fun
+	IF &TYPE('rdHiTrap') = 'UNDEFINED' THEN ; generated for fun
+rdHiTrap  		EQU 		rdLowTrap+2       		; high value for trap handling
+	ENDIF ; generated for fun
+	IF &TYPE('rdResult') = 'UNDEFINED' THEN ; generated for fun
+rdResult  		EQU 		rdHiTrap+2    			; result of executing down-loaded code, etc. (16 bytes)
+	ENDIF ; generated for fun
+	IF &TYPE('rdEnd') = 'UNDEFINED' THEN ; generated for fun
+rdEnd 			EQU 		rdResult+16       		; end of vars
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Microbug
+;---------------------------------------------------
+
+; NOTE: Keep mbDotAddr immediately before mBlocAddr
+
+	IF &TYPE('mbBufSize') = 'UNDEFINED' THEN ; generated for fun
+mbBufSize 		EQU 		34
+	ENDIF ; generated for fun
+	IF &TYPE('mbBuffer') = 'UNDEFINED' THEN ; generated for fun
+mbBuffer  		EQU 		seLastVar     			; buffer for input
+	ENDIF ; generated for fun
+	IF &TYPE('mbSign') = 'UNDEFINED' THEN ; generated for fun
+mbSign			EQU 		mbBuffer+mbBufSize    	; ST => negative sign during conversion
+	ENDIF ; generated for fun
+	IF &TYPE('mbDotAddr') = 'UNDEFINED' THEN ; generated for fun
+mbDotAddr 		EQU 		mbSign+2      			; saved address
+	ENDIF ; generated for fun
+	IF &TYPE('mBlocAddr') = 'UNDEFINED' THEN ; generated for fun
+mBlocAddr 		EQU 		mbDotAddr+4       		; saved location
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Alternate ROM vectors
+;---------------------------------------------------
+
+	IF &TYPE('DiagROM') = 'UNDEFINED' THEN ; generated for fun
+DiagROM   		EQU 		$F80000   				; Alternate ROM - initial vector
+	ENDIF ; generated for fun
+	IF &TYPE('DiagROM1') = 'UNDEFINED' THEN ; generated for fun
+DiagROM1  		EQU 		$F80080   				; Alternate ROM - memory sizing vector
+	ENDIF ; generated for fun
+	IF &TYPE('DiagROM2') = 'UNDEFINED' THEN ; generated for fun
+DiagROM2  		EQU 		$F80088   				; Alternate ROM - init I/O vector
+	ENDIF ; generated for fun
+
+
+;---------------------------------------------------
+; Timing constants
+;---------------------------------------------------
+
+	IF &TYPE('VIAClockHz') = 'UNDEFINED' THEN ; generated for fun
+VIAClockHz		EQU			783360					; VIA clock rate is 783360 Hz.		<2.8>
+	ENDIF ; generated for fun
+	IF &TYPE('nTicks') = 'UNDEFINED' THEN ; generated for fun
+nTicks			EQU 		VIAClockHz/1000   		; VIA timer ticks per msec
+	ENDIF ; generated for fun
+	IF &TYPE('oneSecTicks') = 'UNDEFINED' THEN ; generated for fun
+oneSecTicks   	EQU 		60    					; ticks, of course
+	ENDIF ; generated for fun
+				IF &TYPE('__SysEqu__') = 'UNDEFINED' THEN
+	IF &TYPE('TimeSCSIDB') = 'UNDEFINED' THEN ; generated for fun
+TimeSCSIDB		EQU			$0B24					; DBRAs & SCSI access per millisecond <1.9>
+	ENDIF ; generated for fun
+				ENDIF
+
+	IF &TYPE('ramChk') = 'UNDEFINED' THEN ; generated for fun
+ramChk			EQU 		1024      				; Amount of memory tested for stack.
+	ENDIF ; generated for fun
+
+
+
+;__________________________________________________________________________________________
+;
+;
+; ROM Header RECORD Definition
+;
+;
+;__________________________________________________________________________________________
+
+
+;---------------------------------------------------
+; Romulator ROM location bits and TestFor Macro
+;---------------------------------------------------
+
+	IF &TYPE('locValid1') = 'UNDEFINED' THEN ; generated for fun
+locValid1		EQU			7						; this must be 1
+	ENDIF ; generated for fun
+	IF &TYPE('locValid2') = 'UNDEFINED' THEN ; generated for fun
+locValid2		EQU			6						; this must be 0
+	ENDIF ; generated for fun
+	IF &TYPE('inEmulatorBit') = 'UNDEFINED' THEN ; generated for fun
+inEmulatorBit	EQU			1						; running in emulator
+	ENDIF ; generated for fun
+	IF &TYPE('inRamBit') = 'UNDEFINED' THEN ; generated for fun
+inRamBit		EQU			0						; running in ram
+	ENDIF ; generated for fun
+
+
diff --git a/Internal/Asm/PowerPrivEqu.a b/Internal/Asm/PowerPrivEqu.a
--- a/Internal/Asm/PowerPrivEqu.a
+++ b/Internal/Asm/PowerPrivEqu.a
@@ -1032,6 +1032,7 @@ BootDevTicks	EQU			2*60*60			; Wait for boot device before sleep, in ticks.
 ;	Power Manager Power Voltages
 DefHysteresis	EQU			20				; default to 200mv
 DefLowWarn		EQU			585-512			; default low battery warning level
+NEWCUTOFF		EQU			560
 DefCutoff		EQU			560-512			; default dead battery warning level
 PMGRWARNLEVEL	EQU			585				; set low power level
 PGMRWAKELEVEL	EQU			609				; set hysteresis for 6.09(max allowed) volts for wake
diff --git a/Internal/Asm/ResourceMgrPriv.a b/Internal/Asm/ResourceMgrPriv.a
--- a/Internal/Asm/ResourceMgrPriv.a
+++ b/Internal/Asm/ResourceMgrPriv.a
@@ -8,8 +8,6 @@
 ;	Change History (most recent first):
 ;
 ;	   <SM9>	 5/27/93	SAM		Added definition for mapForceSysHeap.
-;	   <SM8>	 3/31/93	SAM		Changed kDeanBit from 2 (which was conflicting with
-;									systemEnabledBit) to bit 1.
 ;	   <SM7>	 12/4/92	RB		Added kFakeResourceOverrideMapRefNum
 ;	   <SM6>	 7/27/92	FM		Add elements to the ResourceMgr stack frame for use in StdEntry
 ;									and StdExit to implement resource overrides.
@@ -317,10 +315,10 @@ reSize			EQU 	rHndl+4 		; resource entry size
 ;
 ; Stack frame definition
 
-ioStkFrame		EQU		-ioHQElSize		; stack frame is ioHQElSize long
+ioStkFrame		EQU		-ioHQElSize+2	; stack frame is ioHQElSize long
 rMgrStack		EQU		ioStkFrame		; Resource mgr stack frame = IOStkFrame
 
-kDeanBit		equ		1						; <SM8><53> This bit in BrianBits will mark whether or not this call to CheckLoad allocates the master pointer
+kDeanBit		equ		2						; <53> This bit in BrianBits will mark whether or not this call to CheckLoad allocates the master pointer
 kBrianBits		equ		$B20					; <53> We never define this in an interface file
 
 kInitialEntryCount	equ	30						; Make space for 30 resources at first
diff --git a/Internal/Asm/SysPrivateEqu.a b/Internal/Asm/SysPrivateEqu.a
--- a/Internal/Asm/SysPrivateEqu.a
+++ b/Internal/Asm/SysPrivateEqu.a
@@ -8,63 +8,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM30>	 1/14/94	ged		Added the jSWModemSoundVector field to the ExpandMemRec to
-;									support software modem sound using various modems.
-;	  <SM29>	11/11/93	fau		<aek>		Added pointer to Expansion Bus Manager Globals. Bumped
-;									version to	132.
-;	  <SM29>	10/31/93	aek		Added pointer to Expansion Bus Manager Globals. Bumped version to
-;									132.
-;	  <SM28>	10/29/93	pdw		Moved intRegs and intRegsSize from InterruptHandlers.a into this
-;									file to show that they are used elsewhere as well
-;									(SCSIMgr4pt3:HALc96Routines.a).
-;	  <SM27>	 9/12/93	SAM		Changed emFigmentGlobals to emHeapUtilsGlobals which is more
-;									accurate.
-;	  <SM26>	 9/11/93	SAM		Added emFigmentGlobals (new memory manager).  Bumped emVersion
-;									to 131 to reflect the first post cyclone expandmem change.
-;	  <SM25>	  6/7/93	CSS		Add expandmem to stash the control handle during thumb dragging.
-;									Plus rollin from Reality:
-;		<85>	 5/20/93	KWR		Added emSpeechRecognitionGlobals and bumped the version number
-;		<84>	 5/20/93	PKE		Delete names for obsolete fields emNumer, emDenom (they are now
-;									unused).
-;	  <SM24>	05/19/93	HY		Added emIDEGlobals and updated emCurVersion.
-;	  <SM23>	 4/22/93	CSS		Remove ";" from emButtonIntGlobals.
-;	  <SM22>	 4/22/93	CSS		Change emFFSwapMMU to emButtomIntGlobals per expandmempriv.h.
-;									Also, update from Reality. Reality Comments follow:
-;		<81>	 3/29/93	DTY		Added emAuxiliaryWindowHashTable and
-;									emAuxiliaryControlHashTable.
-;		<80>	 3/26/93	YK		Add emHasMultiScript.  This flag will be true if non-Roman
-;									script system is installed, but still be zero until the Procee
-;									Mgr is initialized.  Most of the code for multi lingual support
-;									can be skipped by checking this value.
-;		<79>	 3/25/93	DTY		Add field to store PixMapHandle used for drawing defproc
-;									gadgets.
-;		<78>	 3/18/93	SES		Steven Swenson - added a longword to ExpandMemRec for the
-;									globals for the Internal Modem Manager.
-;		<77>	 3/11/93	ngk		Rename emUsed2 to emWindowMgrFlags
-;		<76>	 3/10/93	GMA		General synch with SuperMario and Ludwig. Adding in Reno info.
-;	  <SM21>	 3/10/93	GS		Getting in touch with Reality...
-;		<75>	  3/7/93	DTY		Add Tinge Manager information.
-;		<74>	 2/25/93	IH		Change type of emDisplayManagerGlobals from Handle to Ptr.
-;		<73>	 2/23/93	ngk		Add emTranslationMgrGlobals
-;		<72>	 2/23/93	IH		Add emDisplayMgrGlobals and Get/Set macros
-;		<71>	12/22/92	YK		Added emLanguagePackGlobals in the first long of two in the
-;									emUnused3 spot.
-;	  <SM20>	 2/20/93	SAM		Added emDMADispGlobs for DMA Manager/Dispatcher globals.
-;	  <SM19>	 1/27/93	PN		Add emStartTicks extended memory global for "startticks" in
-;									ListMgrPack
-;		<SM1>	12/09/92	HI		Added emIsDragging field to be used as a flag to determine
-;									whether OSEventAvail was called from DragTheRgn or not. The
-;									flag is set by DragTheRgn only. OSEventAvail uses this flag
-;									to bypass the HelpMgr patch code if called from DragTheRgn.
-;									(Hoon Im)
-;		<70>	10/27/92	JMF		Added emButtonManagerGlobals in the emUnused1 spot and added
-;									emSerialManagerGlobals in the first long of three in the 
-;									emUnused3 spot.
-;		<69>	10/15/92	aen		Change 'fndr' names to 'emFndr'
-;		<68>	10/14/92	gs		Steal a long word from emUnused1 for FSCommon Library.
-;		<67>	10/14/92	aen		Added fndrDeskRgn, fndrDeskRgnTracking, fndrDeskRgnChange, and bumped
-;									the version number to 0x129 for Bungee Finder support of UltraDesk
-;									(Andy Nicholas).
 ;		<66>	 10/8/92	KST		emUnused4 is now used by WS II printing stuff.
 ;		<65>	 7/21/92	bbm		Add emNetBootGlobals for Network Booting and Appletalk stuff.
 ;									(see Steve Roth)
@@ -204,11 +147,6 @@ envEclipse		EQU			18
 ; *********************************************************
 
 
-IntRegs		reg		a0-a3/d0-d3			; registers saved by all interrupt handlers
-IntRegsSize	equ		8*4					; size of IntRegs in bytes - must change if IntRegs changes!
-										; if this changes, then you must update HALc96Routines.a to handle
-										; both old and new cases.
-
 ;___________________________________________________________________________
 ;
 ; Extended Low Memory area available on all machines
@@ -336,8 +274,8 @@ emItlSysCachePtr	ds.l		1					; pointer to system itl cache				<7><20>
 emScriptMapPtr		ds.l		1					; pointer to script mapping/sorting data	<8>
 emLangMapPtr		ds.l		1					; pointer to language mapping/sorting data	<8>
 
-					ds.l		1					; was emNumer (obsolete), now unused		<11><84>
-					ds.l		1					; was emDenom (obsolete), now unused		<11><84>
+emNumer				ds.l		1					; used for scaling hi-level QD routines
+emDenom				ds.l		1					; used for scaling hi-level QD routines
 emIconCluts			ds.l		1					; Ptr to global icon info				<13>
 emScriptAppGlobals	ds.l		1					; Handle to application-specific script globals	<16><20><21>
 emAppleEventsGlobal	ds.l		1					; Apple Events/Apple Scripts global pointer (not switched) <22>
@@ -388,7 +326,7 @@ emPrintingGlobals			ds.l	1				; Tsunami Printing Manager non-swapped printing gl
 
 emCursorGlobals				ds.l	1				; Ptr to CursorDev globals								<46>
 
-emButtonIntGlobals			ds.l	1				; Ptr to Button Interrupt globals. previously Ptr to "real" SwapMMUMode routine	<SM22> CSS				
+emFFSwapMMUMode				ds.l	1				; Ptr to "real" SwapMMUMode routine
 
 emAppleTalkInactiveOnBoot	ds.w	1				; True if AppleTalk was inactive on boot				<48>
 
@@ -398,49 +336,11 @@ emLowMemoryPrintingGlobals	ds.l	1				; Handle to globals used by LowMemoryPrinti
 
 emNetBootGlobals			ds.l	1				; Handle to globals used by emNetBootGlobals for Network Booting and Appletalk stuff.	<65>
 
-emFndrDeskRgn				ds.l	1				; Handle to region maintained by Bungee Finder if fndrDeskRgnTracking is true <67> <69>
-
-emFndrDeskRgnTracking		ds.w	1				; If true, the Bungee Finder will keep an up-to-date region handle in fndrDeskRgn of the icons on the desktop <67> <69>
-
-emFndrDeskRgnChange			ds.w	1				; Always incremented by the Bungee Finder for every change made to the desktop <67> <69>
-
-emDisplayManagerGlobals		ds.l	1				; Pointer to globals used by Display Manager
-
-emTranslationMgrGlobals		ds.l	1				; Pointer to globals used by Translation Manager (Macintosh Easy Open)	<73>
-
-emTingeInfo					ds.l	1				; Handle to color information kept by the Tinge Manager
-
-emIsDragging				ds.b	1				; Set within DragTheRgn and cleared before exiting; if true, HelpMgr
-emIsDraggingSlop			ds.b	3				; patch in OSEventAvail is bypassed.		<SM1>
-
-emRenoGlobals				ds.l	1				; Ptr to Reno Globals						<LW2>
-
-emDMADispatchGlobals		ds.l	1				; DMA dispatch globals ptr					<SM20>
-
-emInternalModemMgrGlobals	ds.l	1				; Internal modem manager globals 			<78>
-
-emGadgetPixMap				ds.l	1				; PixMapHandle used by defprocs to draw gadgets
-
-emAuxiliaryWindowHashTable	ds.l	1				; Pointer to auxiliary window record hash table
-emAuxiliaryControlHashTable	ds.l	1				; Pointer to auxiliary control record hash table
-
-emIDEGlobals				ds.l	1				; IDE driver globals						<SM24>
-
-emSpeechRecognitionGlobals	ds.l	1				; Speech Recognition Globals				<85><KWR>
-
-emControlHandle				ds.l	1				; control handle used in _DragTheRgn when the thumb is being dragged so we can send a draw thumb outline message. <SM25> CSS
-
-emHeapUtilsGlobals			ds.l	1				; Heap Utilities globals
-
-emExpansionBusGlobals		ds.l	1				; Pointer to Expansion Bus Manager Globals
-
-jSWModemSoundVector			ds.l	1				; Vector to control routine for software modem sound
-
 ; NOTE: When adding new fields here, be sure to update the high-level language header files as well
 ; (currently {CInternal}ExpandMemPriv.h is the one)
 ; Be sure to update the Reality sources when you change this file (and the version number)
 
-emCurVersion		EQU			$0133				; version 
+emCurVersion		EQU			$0128				; version 
 
 emRecSize			equ			*					; size for this version
 size				equ			*
diff --git a/Internal/Asm/UniversalEqu.a b/Internal/Asm/UniversalEqu.a
--- a/Internal/Asm/UniversalEqu.a
+++ b/Internal/Asm/UniversalEqu.a
@@ -222,6 +222,9 @@
 	IF &TYPE('__INCLUDINGUNIVERSALEQU__') = 'UNDEFINED' THEN
 __INCLUDINGUNIVERSALEQU__	SET	1
 
+	INCLUDE		'HardwareEqu.a'
+	INCLUDE		'HardwarePrivateEqu.a'
+
 ; This record is used in MMUTables.a and in SizeMem.a
 
 DecoderKinds	record	0,increment
diff --git a/Internal/Asm/egretequ.a b/Internal/Asm/egretequ.a
--- a/Internal/Asm/egretequ.a
+++ b/Internal/Asm/egretequ.a
@@ -270,10 +270,7 @@ WrHangTout		equ		$1E				; set hang threshold
 RdHangTout		equ		$1F				; get hang threshold
 SetDefDFAC		equ		$20				; Set Default DFAC String 									<T2>
 EnDisPDM		equ		$21				; Enable/Disable PowerDown Message							<T2>
-RdWrIIC			equ		$22				; Read or Write IIC (I sqared C)							<SM3>[rbm]<3>
-WakeUpMode		equ		$23				; Enable/Disable WakeUpMode									<P1>
-TimerTickle		equ		$24				; ShutDown Timer Tickle										<P1>
-MaxPseudoCmd	equ		TimerTickle		; largest possible pseudo command number					<P1>
+MaxPseudoCmd	equ		EnDisPDM		; largest possible pseudo command number					<P1>
 
 ;
 ;__________________________________________________________________________________________________
diff --git a/Libs/InterfaceSrcs/piMAIN.a b/Libs/InterfaceSrcs/piMAIN.a
--- a/Libs/InterfaceSrcs/piMAIN.a
+++ b/Libs/InterfaceSrcs/piMAIN.a
@@ -12,9 +12,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM3>	 1/29/93	RB		Do not move the SCCLockout value to the status register, always
-;									do an ORI.W with it so that NuKernel works and the stack is not
-;									changed.
 ;	   <SM2>	10/28/92	SWC		Changed INCLUDEs to a LOAD of StandardEqu.d.
 ;		 <3>	 7/24/91	MH		also: MPPRefNum, ATPRefNum as per <2> below
 ;		 <2>	 7/24/91	MH		Added conditional wrapper(s) to prevent duplication of public
@@ -384,7 +381,7 @@ RemoveHdlBlks
 			LEA		 ListEl1,A1	  ; Address of List Head
 @00
 			MOVE  	SR,-(SP) 	  ; Save old interrupt state
-			ORI.W  	#SCCLockOut,SR	 ; Disable interrupts			<SM2> rb
+			MOVE.W  #SCCLockOut,SR	 ; Disable interrupts
 			MOVE.L	(A1),A0		 ; First Handle to Free
 			MOVE.L	(A0),A2		 ; Address of Block Text
 			MOVE.L	A0,D0		 ; Is List Empty?
@@ -521,7 +518,7 @@ UnlockAndLinkHdl	PROC
 			MOVE.L	(A0),A1		 ; A1 -> memory block
 
 			MOVE  	SR,-(SP) 	  ; turning off interrupts
-			ORI.W  	#SCCLockOut,SR	;						<SM2> rb
+			MOVE.W 	#SCCLockOut,SR
 
 			MOVE.L	ListEl1,(A1)		; get first element ptr
 			LEA	 	ListEl1,A1	  ; address of variable
diff --git a/LinkedPatches/LinkedPatchLoader.a b/LinkedPatches/LinkedPatchLoader.a
--- a/LinkedPatches/LinkedPatchLoader.a
+++ b/LinkedPatches/LinkedPatchLoader.a
@@ -305,9 +305,6 @@
 		include 'LinkedPatchMacros.a'
 		print pop
 
-_GetTrapWordAddress						opword	$A546				; *** move into Traps.a
-_SetTrapWordAddress						opword	$A447				; *** move into Traps.a
-
 dsLinkedPatchReferenceTooFar			equ		97					; *** move into SysErr.a
 
 k32BitCQDTrap							equ		$AB03				; trap number for 32-bit QuickDraw
diff --git a/OS/ADBMgr/ADBMgrPatch.a b/OS/ADBMgr/ADBMgrPatch.a
--- a/OS/ADBMgr/ADBMgrPatch.a
+++ b/OS/ADBMgr/ADBMgrPatch.a
@@ -9,7 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 11/9/93	KW		added some eieioSTP macros.  Only active for CygnusX1 ROM
 ;		<13>	 2/12/92	JSM		Moved this file to ADBMgr folder, keeping all the old revisions.
 ;		<12>	 10/4/91	JSM		Change PsychoticFarmerOrLater conditionals to TheFuture.
 ;		<11>	 9/22/91	DTY		Change PsychoticFarmerAndLater to PsychoticFarmerOrLater.
@@ -164,9 +163,7 @@ InitADB		InstallProc	(SE,II,notAUX)
 			
 			movea.l	VIA,a1				; point to the VIA1 registers
 @wait		
-		eieioSTP
 			move.b	vBufB(a1),d0
-		eieioSTP
 			andi.b	#(1<<vFDesk2)|\
 					(1<<vFDesk1),d0		; look at state bits
 			cmpi.b	#(1<<vFDesk2)|\
@@ -174,9 +171,7 @@ InitADB		InstallProc	(SE,II,notAUX)
 			bne.s	@wait				; no, keep waiting...
 
 			ori.w	#NoIntMask,sr		; mask out interrupts							<1.2>
-		eieioSTP
 			move.b	vSR(a1),d0			; empty shift reg
-		eieioSTP
 
 			MOVE.L	ADBBase,A3			; point to ADB private data structures
 			
@@ -637,18 +632,9 @@ StartReqVIA
 
 			pea		RunADBRequest		; somthing in queue, run after a short delay
 			move.w	TimeViaDB,d0		; get 1ms VIA loop time constant
-
-	IF forSTP601 THENB
-		;•••• STP ••• eric -- let's double it??
-			lsr.w	#2,d0				; 1ms/8 = 125µs
-	ELSE
-
 			lsr.w	#4,d0				; 1ms/16 = 62.5µs
-	ENDIF
 @delay		
-		eieioSTP
 			btst.b	#0,vBufB(a1)		; timing base on BTST loop, we don't care
-		eieioSTP
 			dbra	d0,@delay			; wait at least 50µs for state change to occur
 @idle		bclr.b	#fDBBusy,FDBAuFlag(a3)	; allow explicit cmds to interrupt auto polling
 			rts							; if not, just let auto polling continue
@@ -712,45 +698,32 @@ StartReqVIA
 
 	if TheFuture then					;												<9>
 
-		eieioSTP
 			move.b	vBufB(a1),d1		; get current state								<8>
-		eieioSTP
 			andi.b	#(1<<vFDesk2)+\
 					(1<<vFDesk1),d1		;												<8>
 			cmpi.b	#(1<<vFDesk2)+\
 					(1<<vFDesk1),d1		; are we in state 3?							<8>
 			bne.s	@sendCont			; no, procede as usual							<8>
-		eieioSTP
 			btst.b	#vFDBInt,vBufB(a1)	; yes, test the FDBInt~ status					<8>
-		eieioSTP
 			beq.s	@sendExit			; asserted, xcvr already clocking autopoll data,<8>
 										; exit (wait for autopoll to complete)			<8>
 	endif								;												<9>
 	
 @sendCont	
-		eieioSTP
 			ori.b	#$1C,vACR(a1)		; set SR to shift-out with ext clk
-		eieioSTP
 			move.b	d3,vSR(a1) 			; load shift reg with cmd, start shifting
-		eieioSTP
 			move.b	d3,fDBCmd(a3)		; save the command
-		eieioSTP
 			andi.b	#-1-(1<<vFDesk2)-\
 					(1<<vFDesk1),vBufB(a1)	; force state bits to zero
-		eieioSTP
 @sendExit	move.l	(sp)+,ShiftIntResume(a3); save resume address
 			move.w	d0,sr				; restore interrupt mask
 			rts							; return to callers caller, wait for interrupt
 
 
 @waitForInput
-		eieioSTP
 			bclr.b	#4,vACR(a1)			; change to shift-in mode
-		eieioSTP
 			tst.b	vSR(a1) 			; empty shift reg to start shifting
-		eieioSTP
 			eor.b	d1,vBufB(a1)		; change the state
-		eieioSTP
 			move.l	(sp)+,ShiftIntResume(a3)	; save resume address
 			rts							; return to callers caller, wait for interrupt
 
@@ -760,12 +733,9 @@ StartReqVIA
 			moveq.l	#1,d0				; zero extend the index
 			add.b	(a0),d0				; get, and increment the index
 			move.b	d0,(a0)				; update the index
-		eieioSTP
 			move.b	vSR(a1),(a0,d0.w)	; save the new byte in the buffer
-		eieioSTP
 			eori.b	#(1<<vFDesk1)|\
 					(1<<vFDesk2),vBufB(a1)	; alternate between state 1 and state 2
-		eieioSTP
 			move.l	(sp)+,ShiftIntResume(a3)	; save resume address
 			rts							; return to callers caller, wait for interrupt
 
@@ -812,14 +782,10 @@ StartReqVIA
 			moveq.l	#(1<<vFDesk1)|\
 					(1<<vFDesk2),d1		; alternate between state 1 and state 2
 @sendByte	movea.l	ListenBuffPtr(a3),a0; get the buffer pointer
-		eieioSTP
 			move.b	(a0)+,vSR(a1)		; send the byte
-		eieioSTP
 			move.l	a0,ListenBuffPtr(a3); update the buffer pointer
 			subq.b	#1,fDBCnt(a3)		; decrement the send count
-		eieioSTP
 			eor.b	d1,vBufB(a1)		; change the state
-		eieioSTP
 			move.l	(sp)+,ShiftIntResume(a3)	; save resume address
 			rts							; return to callers caller, wait for interrupt
 			
@@ -836,9 +802,7 @@ StartReqVIA
 FDBShiftInt
 			movea.l	ADBBase,a3			; point to ADB globals in low memory
 			movea.l	ShiftIntResume(a3),a0	; get address to resume at
-		eieioSTP
 			btst.b	#vFDBInt,vBufB(a1)	; test the FDBInt~ status
-		eieioSTP
 			jmp		(a0)				; resume async processing
 			
 			Title	'KbdADB - ADB Manager  -  ReqDoneVIA'
@@ -1041,9 +1005,7 @@ GE1			jsrROM	GEmptyAddr			; get empty address space, D0 gets address (GEmptyAddr
 ;   more device in original address, we want to move the device back to 
 ;   original address.
 
-		eieioSTP
 			tst.b	(a0)				; did the device return data
-		eieioSTP
 			beq.S	@1					; no, branch 
 ; no timeout indication, 
 			bsr.s	CopyEntry			; copy entry into device table
@@ -1151,9 +1113,7 @@ GNextAddr
 
 MouseDrvr
 			lea		1(a0),a1			; skip over length byte, free up A0
-		eieioSTP
 			move.b	(a1)+,d2			; get first data byte (button, ∆ Vert)
-		eieioSTP
 
 ;	Update the mouse button state
 
@@ -1197,9 +1157,7 @@ MouseDrvr
 
 ;	Update the mouse horizontal position
 
-		eieioSTP
 			move.b	(a1),d2				; get the ∆ Horiz (low 7 bits)
-		eieioSTP
 		 	add.b	d2,d2				; shift high bit of ∆ into sign
 			beq.s	@horizDone			; if no change, nothing to update
 			asr.b	#1,d2				; shift ∆ back, sign extended
diff --git a/OS/Gestalt/GestaltExtensions.a b/OS/Gestalt/GestaltExtensions.a
--- a/OS/Gestalt/GestaltExtensions.a
+++ b/OS/Gestalt/GestaltExtensions.a
@@ -10,8 +10,6 @@
 ;	Change History (most recent first):
 ;
 ;	  <SM10>	  6/7/93	wc		(Really BT)Fix a stupid bug of mine.
-;	   <SM9>	  6/6/93	BT		Add gestaltRISCV0ResMgrPatches to 'bugy' bits if rom is built
-;									with this option.
 ;	   <SM8>	  6/3/93	SAM		Updating the list of machine icons from the Gibbly project.
 ;	   <SM7>	 5/10/93	CSS		For 'bugy' return that the gestaltmtCheckFix has been fixed in
 ;									SuperMario. Also, update the support of bugy to include bits
@@ -94,6 +92,7 @@
 				INCLUDE 	'GestaltPrivateEqu.a'
 				INCLUDE		'SysPrivateEqu.a'
 				INCLUDE		'InternalOnlyEqu.a'
+				INCLUDE		'LinkedPatchMacros.a'
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 ; Record that describes stack frame for Gestalt functions
@@ -110,41 +109,168 @@ error				DS.W	1
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 
 
-NewGestaltSelectors		Proc	Export
-				WITH	ExpandMemRec, GestaltGlobals
-UnimplementedTrapNumber	EQU	$A89F
-PowerOffTrapNumber		EQU	$A05B
-
+Newbugz		InstallProc		(Plus,SE,II,Portable,IIci)
 				IMPORT		getBugFixes						; <24>
-				lea			getBugFixes,a0					; <24>
+				leaResident	getBugFixes,a0					; <24>
 				move.l		#gestaltBugFixAttrs,d0			; <24>
 				_NewGestalt
+				RTS
 				
-				IMPORT		getBugFixesTwo					; <SM6> CSS
-				lea			getBugFixesTwo,a0				; <SM6> CSS
-				move.l		#gestaltBugFixAttrsTwo,d0		; <SM6> CSS
-				_NewGestalt
-
+Newmicn		InstallProc		(Plus,SE,II,Portable,IIci)
 				IMPORT		getMachineIcon
-				lea			getMachineIcon,A0				; address of gestaltMachineIcon patch
+				leaResident	getMachineIcon,A0				; address of gestaltMachineIcon patch
 				MOVE.L		#gestaltMachineIcon,D0			; selector to add						
 				_NewGestalt
+				RTS
 								
+Newostt		InstallProc		(Plus,SE,II,Portable,IIci)
+				IMPORT		getOSTable
+				leaResident	getOSTable, a0
+				move.l		#gestaltOSTable, d0
+				_NewGestalt
+				RTS
+
+Newtbtt		InstallProc		(Plus,SE,II,Portable,IIci)
+				IMPORT		getToolboxTable
+				leaResident	getToolboxTable, a0
+				move.l		#gestaltToolboxTable, d0
+				_NewGestalt
+				RTS
+
+Newxttt		InstallProc		(Plus,SE,II,Portable,IIci)
+				IMPORT		getExtToolboxTable
+				leaResident	getExtToolboxTable, a0
+				move.l		#gestaltExtToolboxTable, d0
+				_NewGestalt
+				RTS
+
+Newrsrc		InstallProc		(Plus,SE,II,Portable,IIci)
 				IMPORT		getResourceAttrs				;												<20>
-				lea			getResourceAttrs, a0			;												<20>
+				leaResident	getResourceAttrs, a0			;												<20>
 				move.l		#gestaltResourceMgrAttr, d0		; resource manager attributes					<20>
 				_NewGestalt									;												<20>
+				RTS
 				
+Newqdrw		InstallProc		(Plus,SE,II,Portable,IIci)
+				IMPORT		CQDFeatures
+				leaResident	CQDFeatures, a0
+				move.l		#gestaltQuickdrawFeatures, d0
+				_NewGestalt
+				RTS
+
+Replacefs	InstallProc		(Plus,SE,II,Portable,IIci)
+				IMPORT		getFSAttr
+				leaResident	getFSAttr, a0
+				move.l		#gestaltFSAttr, d0
+				_ReplaceGestalt
 				RTS
 				
+Replacehdwr	InstallProc		(Plus,SE,II,Portable,IIci)
+				WITH	ExpandMemRec, GestaltGlobals
+UnimplementedTrapNumber	EQU	$A89F
+PowerOffTrapNumber		EQU	$5B
+
+				IMPORT		HasSoftPowerOff, hdwrOrigAddr, hdwrNewBits
+
+				leaResident	HasSoftPowerOff, a0				; Replace 'hdwr' selector with shim
+				move.l		#gestaltHardwareAttr, d0
+				_ReplaceGestalt
+				tst.w		d0
+				bne.s		@return
+				lea			hdwrOrigAddr, a1				; shim JSRs to original routine
+				move.l		a0, (a1)
+
+				move.w		#UnimplementedTrapNumber, d0	; Check for PowerOff selector
+				_GetTrapAddress
+				move.l		a0,a1
+				moveq		#PowerOffTrapNumber, d0
+				_GetTrapAddress ,newOS
+				cmp.l		a0, a1
+				beq.s		@return
+
+				move.l		ExpandMem, a0					; Check for machines known to lack soft power
+				move.l		emGestalt(a0), a0
+				cmp.w		#gestaltMacSE30, machType(a0)
+				beq.s		@return
+				cmp.w		#gestaltMacLC, machType(a0)
+				beq.s		@return
+				cmp.w		#gestaltMacLCII, machType(a0)
+				beq.s		@return
+				cmp.w		#gestaltMacClassic, machType(a0)
+				beq.s		@return
+
+				lea			hdwrNewBits, a0					; Set soft-power bit in the shim routine
+				move.l		#1<<gestaltHasSoftPowerOff, (a0)
+
+@return			rts
+
 				ENDWITH
 				ENDPROC
 
-;This get rolled into GestaltFunction.a 				
-;CQDFeatures		InstallProc	(II,IIci)
 	
+qdrwBitsSet1	InstallProc		(Plus,SE,Portable)
+				IMPORT		qdrwBits
+				lea			qdrwBits, a0
+				move.l		#(1<<gestaltHasGrayishTextOr), (a0)
+				rts
+
+
+qdrwBitsSet2	InstallProc		(II,IIci)
+				IMPORT		qdrwBits
+				lea			qdrwBits, a0
+				move.l		#(1<<gestaltHasColor)|(1<<gestaltHasDeepGWorlds)|(1<<gestaltHasDirectPixMaps)|(1<<gestaltHasGrayishTextOr), (a0)
+				rts
+
+
 ; these will get stripped out if nobody refers to them, so they are not conditionalized
 				
+************************************************************************
+*	OS trap table base
+************************************************************************
+
+getOSTable		Proc	Entry
+				move.l	#$00000400, d0			; this is the same on all machines
+
+				import	stdResult
+				lea		stdResult,a0
+				jmp		(a0)
+				EndProc
+
+************************************************************************
+*	Toolbox trap table base
+************************************************************************
+
+getToolboxTable		Proc	Entry
+				move.l	RomBase, a0				; get base of the rom... duh...
+				cmp.w	#$0075, ROMHeader.MachineNumber(a0)	; are we on a MacPlus?
+				bne.s	@notPlus
+				move.l	#$00000C00, d0			; this is only different on MacPlus
+				bra.s	@stdResult
+@notPlus
+				move.l	#$00000E00, d0			; this is where it goes on everything else
+@stdResult
+				import	stdResult
+				lea		stdResult,a0
+				jmp		(a0)
+
+************************************************************************
+*	Extended Toolbox trap table base
+************************************************************************
+getExtToolboxTable		Proc	Entry
+				move.l	RomBase, a0				; get base of the rom... duh...
+				cmp.w	#$0075, ROMHeader.MachineNumber(a0) ; are we on a MacPlus?
+				beq.s	@plusOrSE				; yes, return the table base address
+				cmp.w	#$0276, ROMHeader.MachineNumber(a0)	; are we on an SE?
+				beq.s	@plusOrSE				; yes, return the table base address
+				import	stdUnknown
+				lea		stdUnknown,a0
+				jmp		(a0)
+@plusOrSE
+				move.l	XToolTable, d0			; get the table base from the vector...
+				import	stdResult
+				lea		stdResult,a0
+				jmp		(a0)
+
 ************************************************************************
 *	<24> Bug fixes
 ************************************************************************
@@ -160,11 +286,10 @@ getBugFixes		Proc	Entry
 						(1<<gestaltSCSIFix)						|	\
 						(1<<gestaltKeyboardFix)					|	\
 						(1<<gestaltTrueTypeFix)					|	\						<25>
-						(1<<gestaltFixedMicroseconds)			|	\						<SM2>
 						(1<<gestaltSaveLastSPExtra)				|	\
 						(1<<gestaltDietPatches)					|	\						<26>
-						(0<<gestaltBackgroundPrintingPatch)		|	\
-						(0<<gestaltNoPreferredAlertPatch)		|	\
+						(1<<gestaltBackgroundPrintingPatch)		|	\
+						(1<<gestaltNoPreferredAlertPatch)		|	\
 						(1<<gestaltAllocPtrPatches)				|	\
 						(1<<gestaltEPPCConnectionTableFix)		|	\
 						(1<<gestaltDAHandlerPatch)				|	\
@@ -175,7 +300,11 @@ getBugFixes		Proc	Entry
 						(1<<gestaltPMSegmentTweaks)				|	\
 						(1<<gestaltWDEFZeroFix)					|	\
 						(1<<gestaltPACKSixFix)					|	\
-						(1<<gestaltMtCheckFix)					\							<SM7> CSS
+						(1<<gestaltResolveFileIDRefFix)			|	\
+						(1<<gestaltDisappearingFolderFix)		|	\
+						(1<<gestaltPowerBookSerialFix)			|	\
+						(1<<gestaltPowerBookSleepQFix)			|	\
+						(1<<gestaltPowerBookFloppyEjectFix)		\
 						, d0
 				
 				import	stdResult
@@ -183,42 +312,6 @@ getBugFixes		Proc	Entry
 				jmp		(a0)
 				EndProc
 				
-************************************************************************
-*	<SM6> More Bug fixes
-************************************************************************
-
-getBugFixesTwo		Proc	Entry
-		IF hasRISCV0ResMgrPatches THEN
-			 	move.l	#											\
-						(1<<gestaltEgretSCCFix)					|	\
-						(1<<gestaltEgretRdTimeFix)				|	\
-						(1<<gestaltEgretIRQPatch)				|	\
-						(1<<gestaltEgretTickHandlerFix)			|	\
-						(1<<gestaltSCSIFastAckFix)				|	\
-						(1<<gestaltPowerOffDelayFix)			|	\
-						(1<<gestaltGetIndResourceSysMapHandleFix) |	\
-						(1<<gestaltMoveHHiExtraStackSpace)		|	\
-						(1<<gestaltRISCV0ResMgrPatches)				\						<SM9> BT
-						, d0
-		ELSE
-			 	move.l	#											\
-						(1<<gestaltEgretSCCFix)					|	\
-						(1<<gestaltEgretRdTimeFix)				|	\
-						(1<<gestaltEgretIRQPatch)				|	\
-						(1<<gestaltEgretTickHandlerFix)			|	\
-						(1<<gestaltSCSIFastAckFix)				|	\
-						(1<<gestaltPowerOffDelayFix)			|	\
-						(1<<gestaltGetIndResourceSysMapHandleFix) |	\
-						(1<<gestaltMoveHHiExtraStackSpace)		|	\
-						(0<<gestaltRISCV0ResMgrPatches)				\						<SM9> BT
-						, d0
-		ENDIF
-				
-				import	stdResult
-				lea		stdResult,a0
-				jmp		(a0)
-				EndProc
-
 ************************************************************************
 *	Machine Icon
 ************************************************************************
@@ -256,81 +349,34 @@ MachineIconTable
 				dc.w	-16508					; (18) Asahi								<2>
 				dc.w	-16505					; (19) Tim LC
 				dc.w	-16504					; (20) Eclipse33/Zydeco						<2>
-				dc.w	-16503					; (21) Vail25 								<7>
-				dc.w	-16482					; (22) Carnation33 							<1>
-				dc.w	-16508					; (23) DBLight25							<1>
-				dc.w	-16454					; (24) Wombat 25/Lego						<14>
-				dc.w	-16482					; (25) Columbia								<3>
-				dc.w	-16508					; (26) DBLite33								<3>
-				dc.w	-16505					; (27) Dartanian							<3>
-				dc.w	-16505					; (28) DartanianLC							<3>
-				dc.w	-16456					; (29) Wombat 33Mhz/fridge					<3><14>
-				dc.w	-16454					; (30) Wombat 33/Lego						<3><14>
+				dc.w	3						; (21) Vail25 								<7>
+				dc.w	3						; (22) Carnation33 							<1>
+				dc.w	3						; (23) DBLight25							<1>
+				dc.w	3						; (24) Wombat 25/Lego						<14>
+				dc.w	3						; (25) Columbia								<3>
+				dc.w	3						; (26) DBLite33								<3>
+				dc.w	3						; (27) Dartanian							<3>
+				dc.w	3						; (28) DartanianLC							<3>
+				dc.w	3						; (29) Wombat 33Mhz/fridge					<3><14>
+				dc.w	3						; (30) Wombat 33/Lego						<3><14>
 				dc.w	-16503					; (31) FosterFarms							<3>
-				dc.w	-16508					; (32) Ansel (DBLite TFT)					<23>
+				dc.w	3						; (32) Ansel (DBLite TFT)					<23>
 				dc.w	3						; (33) db20									<3><11>
 				dc.w	3						; (34) Vail 16								<9><11>
 				dc.w	3						; (35) Carnation 25							<9><11>
 				dc.w	3						; (36) Carnation 16							<9><11>
-				dc.w	-16610					; (37) Cyclone33 (Fridge)					<24>
-				dc.w	-16454					; (38) Brazil16 in Lego						<10><14>
-				dc.w	-16454					; (39) Brazil32 in Lego						<10><14>
+				dc.w	3						; (37) Cyclone33 (Fridge)					<24>
+				dc.w	3						; (38) Brazil16 in Lego						<10><14>
+				dc.w	3						; (39) Brazil32 in Lego						<10><14>
 				dc.w	3						; (40) Brazil16 in Fridgidaire	(Killed)	<10><14>
 				dc.w	3						; (41) Brazil32 in Fridgidaire	(Killed)	<10><14>
-				dc.w	-16454					; (42) Brazil32c in Lego					<10><14>
-				dc.w	-16568					; (43) BoxSlice								<9><11>
-				dc.w	-16505					; (44) Monet								<21>
-				dc.w	-16454					; (45) Wombat 40/Lego						<9><11><14><18>
-				dc.w	-16455					; (46) WLCD 20Mhz/QFC						<9><11>
-				dc.w	-16455					; (47) WLCD 25 Mhz/QFC						<9><11>
+				dc.w	3						; (42) Brazil32c in Lego					<10><14>
+				dc.w	3						; (43) BoxSlice								<9><11>
+				dc.w	3						; (44) Monet								<21>
+				dc.w	3						; (45) Wombat 40/Lego						<9><11><14><18>
+				dc.w	3						; (46) WLCD 20Mhz/QFC						<9><11>
+				dc.w	3						; (47) WLCD 25 Mhz/QFC						<9><11>
 				dc.w	-16505					; (48) PowerBook 145 (same as 140/170)		<9>
-				dc.w	3						; (49) Brazil 32c in Fridgidaire			<10><14>
-				dc.w	-16749					; (50) Hook									<11>
-				dc.w	-16455					; (51) WLCD Consumer #1/QFC					<11>
-				dc.w	-16454					; (52) Wombat 20 Mhz/Lego					<11><14>
-				dc.w	-16456					; (53) Wombat 40 Mhz/Fridge					<11><14>
-				dc.w	-16455					; (54) Tempest25 (QFC)						<24>
-				dc.w	-17000					; (55) Box PDm/RiscQuadra					<11><16>
-				dc.w	-16503					; (56) Vail33								<35>
-				dc.w	-16455					; (57) WLCD33								<35>
-				dc.w	-17000					; (58) PDM66F								<19>
-				dc.w	-17000					; (59) PDM80F								<19>
-				dc.w	-17000					; (60) PDM100F								<19>
-				dc.w	-16504					; (61) TesseractL							<19>
-				dc.w	-16504					; (62) TesseractF							<19>
-				dc.w	-16504					; (63) TesseractC							<19>
-				dc.w	-16503					; (64) 930									<19>
-				dc.w	-16505					; (65) Hokusai								<21>
-				dc.w	-16505					; (66) BlackBird							<24>
-				dc.w	-16505					; (67) BlackBirdLC							<24>
-				dc.w	-17000					; (68) PDM evt1 WLCD						<24>
-				dc.w	-17000					; (69) PDM50 WLCD							<24>
-				dc.w	-16508					; (70) Escher25								<25>
-				dc.w	-16508					; (71) Escher33								<25>
-				dc.w	-16610					; (72) Cyclone40 (cyclone)					<24>
-				dc.w	-16455					; (73) Tempest33 (QFC)						<24>
-				dc.w	-16749					; (74) Hook33 (Hook)						<25>
-				dc.w	-16568					; (75) Slice25 (Slice)						<25>
-				dc.w	-17000					; (76) RISCWombat							<25>
-				dc.w	-16568					; (77) Slice33								<25>
-				dc.w	-16505					; (78) Norad								<28>
-				dc.w	-16508					; (79) BudMan								<28>
-				dc.w	-16503					; (80) primus20								<28>
-				dc.w	-16749					; (81) optimus20							<28>
-				dc.w	-16749					; (82) PeterPan								<28>
-				dc.w	-16503					; (83) Primus25								<28>
-				dc.w	-16503					; (84) primus33								<28>
-				dc.w	-16749					; (85) optimus25							<28>
-				dc.w	-16749					; (86) optimus33							<28>
-				dc.w	-16503					; (87) aladdin20							<28>
-				dc.w	-16503					; (88) aladdin25							<28>
-				dc.w	-16503					; (89) aladdin33							<28>
-				dc.w	-16455					; (90) Malcolm25 (QFC)						<35>
-				dc.w	-16455					; (91) Malcolm33 (QFC)						<35>
-				dc.w	-16568					; (92) Slimus25	(sliceBox)					<35>
-				dc.w	-16568					; (93) Slice33 (sliceBox)					<35>
-				dc.w	-17000					; (94) PDM 66 evt2-> (WLCD)					<36>
-				dc.w	-17000					; (95) PDM 80 evt2-> (WLCD)					<36>
 MachineIconTableEnd
 
 numMachineIcons	equ		(MachineIconTableEnd-MachineIconTable)/2
@@ -352,15 +398,13 @@ getMachineIcon
 				_Gestalt						;											<5>
 				move.l	a0,d0					; put machineType in d0 (only lsw is used)	<5>
 				
-				andi.w	#$FFFF,d0				; make sure only a word is valid			<SM4> rb
 				cmp.w	#numMachineIcons,d0		; do we have a table entry?
 				blo.s	@gotTableEntry
 				clr.w	d0						; no entry, use the first one in the table
 @gotTableEntry
 				add.w	d0,d0					; advance to offset in table
-				lea		MachineIconTable,a0		; get table in a0							<SM4> rb
-				adda.l	d0,a0					; add offset to tyable entry				<SM4> rb
-				move.w	(a0),d0					; get icon resource id						<SM4> rb
+				lea		MachineIconTable,a0		; get table in a0
+				move.w	(a0,d0.w),d0			; get icon resource id
 
 				import	stdResult				;											<5>
 				lea		stdResult,a0			; get address of result routine				<5>
@@ -369,6 +413,22 @@ getMachineIcon
 				endproc	
 
 				
+************************************************************************
+*	Extended File System dispatching flags
+************************************************************************
+
+getFSAttr		Proc	Entry
+				moveq	#0, d0
+			 	move.w	#										\
+						(1<<gestaltFullExtFSDispatching)	|	\
+						(1<<gestaltHasFSSpecCalls)			|	\
+						(0<<gestaltHasFileSystemManager)		\
+						, d0
+				import	stdResult
+				lea		stdResult,a0
+				jmp		(a0)
+
+
 ************************************************************************
 *	Resource manager flags
 ************************************************************************
@@ -388,6 +448,58 @@ getResourceAttrs	proc	entry															;<20>
 				
 
 
+************************************************************************
+*	Quickdraw feature flags
+************************************************************************
+
+CQDFeatures		Proc	Entry
+				EXPORT	qdrwBits
+
+				dc.w	$203C					; MOVE.L #x, d0
+qdrwBits
+				dc.l	$12345678
+
+				import	stdResult
+				lea		stdResult,a0
+				jmp		(a0)
+ 
+
+************************************************************************
+*	New thing with the hdwr selector (yuck!)
+************************************************************************
+
+HasSoftPowerOff		Proc	Entry
+				EXPORT	hdwrOrigAddr, hdwrNewBits
+
+				clr.w	-(sp)
+				move.l	10(sp), -(sp)
+				move.l	10(sp), -(sp)
+
+				dc.w	$4EB9					; JSR to absolute pointer
+hdwrOrigAddr
+				dc.l	$40800000
+
+				move.w	(sp)+, d1
+				beq.s	@nojank
+				move.w	d1, 12(sp)
+
+				import	stdExit
+				lea		stdExit, a0
+				jmp		(a0)
+
+@nojank
+				move.l	4(sp), a0
+				move.l	(a0), d0
+				dc.w	$0080					; OR.L #xxxxxxxx, D0
+hdwrNewBits
+				dc.l	0
+
+				import	stdResult
+				lea		stdResult,a0
+				jmp		(a0)
+
+
+
 ************************************************************************
 *   Common Gestalt Function Return Code
 ************************************************************************
diff --git a/OS/Gestalt/GestaltFunction.a b/OS/Gestalt/GestaltFunction.a
--- a/OS/Gestalt/GestaltFunction.a
+++ b/OS/Gestalt/GestaltFunction.a
@@ -9,109 +9,8 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM49>	11/19/93	chp		When testing for hasEnhancedLTalk, always use ProductInfo flags.
-;									Remove Cyclone/Tempest boxFlag checks.
-;	  <SM48>	 11/8/93	SAM		Roll in <MC4> from mc900ftjesus.
-;	   <MC4>	 11/8/93	SAM		Updated TestForEmu to correctly adjust the logical RAM size when
-;									an EDisk is present.
-;	  <SM47>	10/28/93	SAM		Roll in <MC3> from mc900ftjesus.
-;	   <MC3>	10/28/93	SAM		Changed getNativeCPUType to put the PowerPC cpus in the $100
-;									range.
-;	  <SM46>	10/10/93	SAM		Roll in <MC2> from mc900ftjesus.
-;	   <MC2>	10/10/93	SAM		Added a universal check for hasEnhancedLTalk in gestaltHardware.
-;	  <SM45>	 8/12/93	BG		Converted references to gestaltCyclone40 to gestaltQuadra840AV.
-;	  <SM44>	  8/7/93	SAM		Removed temporary fix to LRAM size made in <SM41>.
-;	  <SM43>	  8/4/93	JDR		Integrate Sound Manager 3.0 project.
-;	  <SM42>	 7/20/93	SAM		Added a macro for setting the assembler machine directive to the
-;									appropriate thing (based on the build time flag "CPU").
-;	  <SM41>	 6/29/93	SAM		Removed all references to gEDiskSize cuz its not needed.  The
-;									lram value is updated to include the Edisk at initalization (as
-;									it was in 7.0.1).  This still doesnt cover the case of VM
-;									loading after gestalt (a gibbly fix for PDM is a temporary
-;									solution).  Cyclone this is broken in  your ROM.
-;	  <SM40>	 6/14/93	SAM		Added a test for the hasHardPower bit in Universal info so we no
-;									longer have to use boxflags for the shutdown dialog crap.
-;	  <SM39>	 6/14/93	kc		Roll in Ludwig.
-;	  <SM38>	  6/3/93	SAM		Updated that stupid list of boxflags in hassoftpoweroff to
-;									reflect the new PDM boxflags.
-;	  <SM37>	 5/21/93	CSS		Set bits in gestaltFontAttr to indicate settings for double byte
-;									support.
-;	  <SM36>	 4/23/93	SAM		Added the temporary PDMEvt2 boxflag to the brain-dead list of
-;									boxflag based cmp/bne for hassoftpoweroff.
-;	  <SM35>	 4/11/93	chp		Added a selector to return the HAL type for the runtime CPU.
-;									This just returns an encoded resource ID from ProductInfo. Also
-;									added the AppleTalk interrupt level selector from Cyclone.
-;	  <SM34>	  4/8/93	KW		changed gestaltids for cyclone/tempest products when determining
-;									if enhanced localtalk is present.
-;	  <SM33>	  4/8/93	CSS		Use gestalt global for edisk size as the boot globals get hosed
-;									by VM.
-;	  <SM32>	  4/5/93	jb		Added TestFor AwacsExists in GetSoundHardware.
-;	  <SM31>	 3/30/93	CSS		Add EDisk size to logical RAM size in gestaltLogicalRAMSize.
-;									Before SuperMario, VM was inited before Gestalt. Now this has
-;									changed. The Gestalt expandmem var realTop(An) used to be fixed
-;									by Gestalt by taking VM version of RealMemTop and adding the
-;									Edisk size. Because of how thing are in SuperMario, VM doesn't
-;									get to affect realTop(An), therefore rather than returning that
-;									variable, we return RealMemTop (which is the one that VM
-;									changed). However, for About this Macintosh… to work correctly
-;									(and show the RAM disk as part of the System Software), we need
-;									to add the RAM disk size whenever we return RealMemTop.
-;	  <SM30>	 2/20/93	SAM		Updated all the EMMU stuff.  MMU page size, emulator present,
-;									sys architecture, all updated.  Fixed up the Universal ROM
-;									check.
-;	  <SM29>	02/10/93	HY		Remove <SM26> change.  We no longer need the gestaltNoAppleTalk bit.
-;	  <SM28>	  2/5/93	SAM		Added support for Emulated page size.
-;	  <SM27>	  2/5/93	SAM		Updated the System architecture selector to use universal info.
-;	  <SM26>	01/11/93	HY		Added code into getMisc for setting gestaltNoAtlkSupport bit.
-;									If this bit is set then this machines DOESN'T support AppleTalk.
-;	  <SM25>	 1/10/93	RC		Soft Power Off now works correctly for PDM
-;	  <SM24>	12/13/92	SAM		Added gestaltNativeCPUtype and gestaltSysArchitecture.  Restored
-;									universal code in the hdwr selector.  Cleaned things up.
-;	  <SM23>	 12/4/92	fau		Added gestaltTempest33 to soft-power off.  Added all
-;									Cyclone-type machines to say they have enhanced localtalk --
-;									this should not be box-flag based.  I'll get to it soon.
-;	  <SM22>	11/13/92	mal		Added MACE Ethernet to hardware attributes gestalt.
-;	  <SM21>	11/11/92	RB		The Mac LC II does not have Soft Power Off.
-;	  <SM20>	11/11/92	fau		Changed soundhardware to check for the 'DSPExists' feature flag.
-;									This means that a DSP is installed and used for sound.  Made
-;									tempest not have a soft power off flag.
-;	  <SM19>	 11/9/92	fau		Made gestaltSoundHardware return 'dsp ' for a Tempest.  Rolled
-;									back change in <SM18> so the Text-to-speech guys fix it.
-;	  <SM18>	 11/6/92	FU		Made Cyclone/Tempest return ASC for hardware attributes -- will
-;									back this as soon as a name-revision is done.  This will work
-;									around a Text-to-speech bug.
-;	  <SM17>	 11/3/92	RB		(Murali) Under SM, return RealMemTop instead of the cached
-;									realTop in the gestalt globals. Gestalt was loaded before VM
-;									did, and so realMemTop may have changed by VM, so always use the
-;									real thing.
-;	  <SM16>	10/27/92	fau		Forgot to change a label to actually execute the
-;									enhancedlocaltalk code.
-;	  <SM15>	10/27/92	fau		Added a gestaltHasEnhancedLtalk check to hardwareAttr to enable
-;									the bit on Cyclone and Tempest.
-;	  <SM14>	  9/3/92	PN		Nuke the check for IIci because this is SuperMario.
-;	  <SM13>	 8/20/92	CS		Fix another problem with BootGlobs changing to StartGlobals per
-;									roll-in from Reality.
-;	  <SM12>	 8/17/92	CCH		Change getHardwareAttr to not use OrwellExists bit since it was
-;									removed.
-;	  <SM11>	 7/24/92	RLM		change GetEDiskSize, now uses BootGlobs, this removes the
-;									requirement to have drivres installed before Gestalt
-;	   <SM10>	 7/20/92	CSS		Names of the sound hardware attributes have changed because they were moved
-;									from GestaltEqu.a to GestaltEquPriv.a by JDR.
-;	   <SM9>	 7/14/92	RB		Added a function to return the gestaltSoundHardware attributes.
-;	   <SM8>	  7/1/92	RB		Added the selectors for the gestalt script manager attributes.
-;									The script Mgr function for gestalt is in ScripMgrExtensions.a
 ;	   <SM5>	 5/19/92	CS		Integrated changes from Reality: 
 ;									<42> 4/9/92 JSM #1026795,<DTY>: gestaltSerialAttr should be the same for a Mac 
-;									LC II as a Mac LC.
-;	   <SM4>	 4/30/92	SES		Rolled in a fix of the parity check routine from PatchIIciROM.a.
-;									Removed check for bootglobs - all ROMs now have bootglobs, so no
-;									need to check.
-;	   <SM3>	 4/28/92	PN		Fix OutlineFont Gestalt so that getFontMgrAtr returns the
-;									correct result
-;	   <SM2>	 4/22/92	PN		Roll in hasSoftPowerOff to hardware attribute.  Add GetOSTable,
-;									GetToolboxTable, GetExtToolboxTable, GetFSAttr into ROM build.
-;									Roll in GetQDFeatures and GestaltFontMgrAttr from
-;									GestaltPatches.a and BassPatches.a.
 ;		<41>	 12/4/91	csd		#1016451: Added support for Scruffy. If Scruffy is running, we
 ;									need to set 32-bit capable flag for the
 ;									gestaltAddressingModeAttr selector.
@@ -291,24 +190,10 @@
 				include	'InternalOnlyEqu.a'
 				INCLUDE	'EDiskEqu.a'
 				INCLUDE	'BootEqu.a'
+				INCLUDE	'Devices.a'
 
 				PRINT	ON
 
-				MACRO
-				SETMACHINE
-		IF CPU = 020 THEN
-				MACHINE		MC68020
-		ELSEIF CPU = 030 THEN
-				MACHINE		MC68030
-		ELSEIF CPU = 040 THEN
-				MACHINE		MC68040
-		ELSE
-				AERROR		'Unknown CPU type'
-		ENDIF
-				ENDM
-	
-				SETMACHINE
-				
 ;;; Gestalt private equates
 GestaltTrapID			EQU			$A1AD		; Gestalt trap number
 NewGestaltTrapID		EQU			$A3AD		; newGestalt trap number
@@ -453,7 +338,8 @@ error				DS.W	1
 *	System Version
 ************************************************************************
 
-getSysVersion	clr.l	d0						; clear result register						<2.9>
+getSysVersion	move.l	4(sp),a0
+				clr.l	d0						; clear result register						<2.9>
 				Move.w	SysVersion,d0			; save system version in lsw of result
 				bra		stdResult				; save result and exit						<2.9>
 
@@ -462,7 +348,8 @@ getSysVersion	clr.l	d0						; clear result register						<2.9>
 *	ROM Version
 ************************************************************************
 
-getRomVersion	Move.l	RomBase,A1				; get base of ROM
+getRomVersion	move.l	4(sp),a0
+				Move.l	RomBase,A1				; get base of ROM
 				clr.l	d0						; clear result register						<2.9>
 				move.w	RomVersionOffset(a1),d0 ; put version in lsw of result
 				bra		stdResult				; save result and exit						<2.9>
@@ -501,45 +388,6 @@ getProcessor	moveq.l	#0,d0					; clear d0
 				bra		stdResult				; save result and exit						<2.9>
 
 
-************************************************************************					<SM24><SM30>
-*	System Architecture
-************************************************************************
-
-getSysArchitecture								; If we're running (68k code) and Emu is installed
-												; for now, assume Architecture is PPC.
-				MOVE.L	ExpandMem,A1			; find out where expandMem is
-				MOVE.L	emGestalt(A1),A1		; get global ptr
-				TST.B	Emu68k(A1)				; Do the globals say we have an emulator?	<SM29>
-				BEQ.S	@MC68k					; -> Nope, ol' slow boy.					<SM29>
-
-@PowerPC		MOVEQ	#gestaltPowerPC,D0		; Emulator is running.  Signal PowerPC architecture
-				BRA		stdResult				; -> Return
-@MC68k			MOVEQ	#gestalt68k,D0			; Emu is off.  Assume 68k
-				BRA		stdResult				; -> Return
-												
-IsEmuInstalled	TestFor	has68kEmulator
-				RTS								; On Exit z set = PowerPC, clear = 68k
-			
-
-************************************************************************					<SM24>
-*	Native Processor Type
-************************************************************************
-
-getNativeCPUtype
-				MOVE.L	ExpandMem,A1			; find out where expandMem is
-				MOVE.L	emGestalt(A1),A1		; get global ptr
-				TST.B	Emu68k(A1)				; Do the globals say we have an emulator?	<SM30>
-				BEQ.S	@MC68k					; -> Nope, ol' slow boy.					<SM30>
-				
-				MOVEQ.L	#0,D0					; Clear out D0
-				MOVE.B	nativeCPU(A1),D0		; Get the PowerPC processor type			<SM30>
-				ADD.W	#$100,D0				; Bump the PowerPC CPU type into the $100 range <MC3>
-				
-				BRA		stdResult				; -> Return
-@MC68k			MOVE.B	CPUFlag,D0				; Return CPU flag							<MC3>
-				BRA		stdResult
-
-				
 ************************************************************************
 *	Keyboard Type
 *	Note:	To add new keyboards, simply add types to table before EOT.
@@ -612,17 +460,26 @@ getParityStatus	Move.l	ExpandMem,A1			; find out where expandMem is
 ************************************************************************
 
 getMisc			clr.l	d3						; clear result
-		IF not forROM THEN
-				move.l	ROMBase,A0						; Get ROMBase										<SM23>
-				lea		universalROMs,A1				; Point to the table of Clean/Univeral ROM Sigs
-				move.w	(A1)+,D1						; Get a ROM id (list is null terminated)
-				beq.s	@checkMemCtrlr					; -> End of table means not universal (huh)
-				cmp.w	D1,ROMHeader.MachineNumber(A0)	; Check a table entry
-				beq.s	@userDelay						; -> Yep, set the hasBootGLobs ROM bit				<SM23>			
-		ENDIF
-				bset	#gestaltBootGlobals,d3			; we have boot globals
+				move.l	ROMBase,A0						; Get ROMBase
+				move.w	ROMHeader.MachineNumber(A0),D1
+				lea		bootGlobROMs,A0					; Point to the table of bootGlobbed ROM Sigs
+@cleanROMloop	cmp.w	(a0)+,d1
+				beq.s	@hasBootGlobs
+				tst.w	(a0)
+				bne.s	@cleanROMloop
+				bra.s	@noBootGlobs
+@hasBootGlobs	bset	#gestaltBootGlobals,d3			; we have boot globals
+@noBootGlobs
 
-@userDelay		bset	#gestaltScrollingThrottle,d3	; <SM3>								<17>
+				move.w	#UnimplementedTrap,d0
+				_GetTrapAddress ,newTool
+				move.l	a0,d2
+				move.l	#UserDelayTrap,d0
+				_GetTrapAddress ,newTool
+				cmp.l	a0,d2
+				beq.s	@noUserDelay
+@userDelay		bset	#gestaltScrollingThrottle,d3
+@noUserDelay
 
 @squareMenus	move.b	NTSC,d0					; get a copy of the NTSC byte				<17>
 				andi.b	#$0F,d0					; only look at bottom nibble				<17>
@@ -632,8 +489,10 @@ getMisc			clr.l	d3						; clear result
 @next			move.l	d3,d0					; put result into d0						<17>
 				bra		stdResult				; save result and exit
 
-; <SM4><SES> 
-; Removed ROM version compare - all ROMs now have bootglobs
+; ROMs that have bootglobs
+bootGlobROMs
+				dc.w	$067C					; IIci ROM
+				dc.w	0						; eot
 
 
 ************************************************************************
@@ -665,28 +524,21 @@ getPageSize
 
 @1
 				cmpi.b	#2,CPUFlag				; are we on at least an 020?
-				blo		@noPages				; oh well, no page size						<2.9>
+				blt		@noPages				; oh well, no page size						<2.9>
 				cmpi.b	#PMMU851,MMUType		; do we have some kind of real mmu?
-				blo.s	@normalSize				; nope, use default page size
+				blt.s	@normalSize				; nope, use default page size
 				Move.l	ExpandMem,A0			; find out where expandMem is
 				Move.l	emGestalt(A0),A0		; get global ptr
 
-				tst.b	emu68k(A0)				; Do the globals say we have a 68k Emulator? <SM30>
-				bne.s	@GetEmuPageSize			; -> Yes, get the saved page size			 <SM30>
-
 				lea		myScratch(A0),a0		; get address of scratch area
 				pmove	tc,(a0)					; get a copy of the TC
 				bfextu	(a0){8,4},d1			; get # addr bits for pageSize				<2.8>
 				bset	d1,d0					; get our pagesize							<2.8>
 				bra.s	@saveResult				; done!
 
-@GetEmuPageSize	Move.l	nativePageSize(A0),D0	; Grab the NanoKernel's page size			<SM30>
-				bra.s	@saveResult				; save result and exit						<SM28>
-				
 @normalSize		Move.l	#DefaultPageSize,D0		; use default pagesize
 @saveResult		bra		stdResult				; save result and exit						<2.9>
 
-				SETMACHINE						;									<SM42>
 		ENDIF									; 											<2.9>
 
 @noPages
@@ -744,7 +596,6 @@ smallROM		move.l	#$20000,d0				; for Mac Plus and 512ke (puny)				<3.3>
 romKnows		move.l	ROMHeader.RomSize(a0),d0	; get size of the ROM					<3.3>
 machExit		bra		stdResult				; save result and exit						<2.9>
 
-		IF  ForRom THEN						;<SM2> <PN>											<22>
 ************************************************************************
 *	OS trap table base
 ************************************************************************
@@ -794,32 +645,6 @@ getFSAttr										;											<26>
 				bra		stdResult				;											<26>
 												;											<26>
 ************************************************************************
-*	Quickdraw feature flags																	;<14>
-************************************************************************
-
-getQuickdrawFeatures		
-				moveq	#0, d0					; <SM2> <PN>											<26>
-				move.l	#										\ ; <SM2> <PN>							;<14>
-						(1<<gestaltHasColor)				|	\ ; <SM2> <PN>							;<14>
-						(1<<gestaltHasDeepGWorlds)			|	\ ; <SM2> <PN>							;<14>
-						(1<<gestaltHasDirectPixMaps)		|	\ ; <SM2> <PN>							;<14>
-						(1<<gestaltHasGrayishTextOr)			\ ; <SM2> <PN>							;<14>
-						, d0									  ; <SM2> <PN>
-				bra		stdResult				;<SM2> <PN>											<26>
- 
-************************************************************************
-*	FontManager Attribute																;<14>
-************************************************************************
-			IF hasSplineFonts THEN		
-getFontMgrAttr		
-				move.l	   #(1 << gestaltOutlineFonts) 		|	\
-					 		(1 << gestaltPartialFonts) 		|	\
-					 		(1 << gestaltDiskCachedFonts)		\
-							, d0 ;<SM37> CSS
-				bra		stdResult				;<SM2> <PN>											<26>
-			ENDIF
- 		ENDIF	; IF  ForRom																<22>
-************************************************************************
 *	QD Version
 ************************************************************************
 
@@ -951,8 +776,7 @@ cleanROM		move.b	SystemInfo,d0			; get status byte into d1				<2.9>
 				bra		stdResult				; save result and exit					<2.9>
 
 universalROMs
-cleanROMs		dc.w	$077D					; SuperMario ROM 						<PN>
-				dc.w	$067C					; IIci ROM 								<PN>
+cleanROMs		dc.w	$067C					; IIci ROM 								<PN>
 				dc.w	0						; eot									<3.1>
 
 
@@ -987,24 +811,6 @@ VMInfo			clr.l	d0						; VM installs itself, otherwise off		<3.3>
 				bra		stdResult				; save result and exit					<2.9>
 
 
-************************************************************************
-*	Sound Hardware
-************************************************************************
-
-GetSoundHardware
-				move.l	#gestaltASCSnd,d0		; default is Apple Sound Chip						<SM9> rb <SM10> CSS <SM19> <SM20> fau
-
-				TestFor	AwacsExists				; Do we have an Awacs audio codec?
-				beq		@check4dsp				; nope, try DSP
-				move.l	#gestaltAwacsSnd, d0	; yep, so return the appropriate thing	
-				bra		stdResult
-
-@check4dsp		TestFor	DSPExists				; Are we using the DSP for sound 
-				beq		stdResult				; Nope
-				move.l	#gestaltDSPSnd,d0		; set the DSP type									
-				bra		stdResult				; and exit											
-				
-				
 ************************************************************************
 *   Notification Manager																<9>
 ************************************************************************
@@ -1036,21 +842,6 @@ getSerialAttr
 						(1<<gestaltHasGPIbToDCDb),d0	; 	GPIb connected to DCDb
 @toStdResult	bra		stdResult
 
-************************************************************************
-*   Serial HAL Type (universal ROM only)
-************************************************************************
-
-getSerialHALType
-				moveq	#0,d0					; clear result
-
-				TestFor	SerialDMA
-				beq		stdUnknown				; hardware does not use SerialDMA so HAL type is not valid
-
-				move.l	#ProductInfo.SHALMask,d0
-				and.l	UnivROMFlags1,d0		; get HAL type from universal info
-				lsr.l	#2,d0					; right justify
-				bra		stdResult
-
 ************************************************************************
 *   get slot info																		<2.9>
 ************************************************************************
@@ -1093,16 +884,14 @@ getSlotInfo
 *************************************************************************
 
 getHardwareAttr
-		IF  ForROM THEN									;<SM2> <PN>
 				movea.l	ExpandMem,a0					; get ptr to expandmem rec
 				movea.l	emGestalt(a0),a0				; get gestalt global ptr
 				cmpi.w	#gestaltMacIIci,machType(a0)	; must use tables for pre Mac IIci machines
-				blo		getMachSpecific					; if so, don't use this routine
+				blt		getMachSpecific					; if so, don't use this routine
 				cmpi.w	#gestaltMacClassic,machType(a0)	; no universal tables on XO either		<3.3>
 				beq		getMachSpecific					;										<3.3>
 				cmpi.w	#gestaltPowerBook100,machType(a0); no universal tables on Asahi either 	<6><40>
 				beq		getMachSpecific					;										<6>
-		ENDIF											;
 
 				clr.l	d0						; clear result
 				lea		AttrTable,a0			; get gestalt->universal mapping table
@@ -1135,55 +924,12 @@ getHardwareAttr
 												;Roll in NewGestaltSelectors from GestaltPatches.a <SM2> <PN>
 @HasSoftPowerOff
 														; Check for HardPower/SoftPower supplies (please dont use boxflag) <SM39>
-			IF forROM THEN
-				TestFor	hasHardPowerOff					; See if this power supply is cheap, stupid and manual!		<SM39>
-				bne.s	@noSoftPowerOff					; -> Has a cheap power switch.								<SM39>
-			ELSE										;															<SM39>
-				
-				movea.l	ExpandMem,a0					; get ptr to expandmem rec <SM2> <PN>
-				movea.l	emGestalt(a0),a0				; get gestalt global ptr <SM2> <PN>
-
-				cmpi.w	#gestaltMacSE30,machType(a0)	; if this is an SE/30, we don’t have soft power-off <SM2> <PN>
-				beq.s	@noSoftPowerOff
-				cmpi.w	#gestaltMacLC,machType(a0)		; if this is an LC, we don’t have soft power-off <SM2> <PN>
-				beq.s	@noSoftPowerOff
-				cmpi.w	#gestaltMacLCII,machType(a0)	; if this is an LC II, we don’t have soft power-off <SM26> rb
-				beq.s	@noSoftPowerOff
-				cmpi.w	#boxClassicII,machType(a0)		; if this is an Apollo, we don’t have soft power-off <5><22> <SM2> <PN>
-				beq.s	@noSoftPowerOff					; <SM2> <PN>
-				cmpi.w	#gestaltTempest25,machType(a0)	; if this is a Tempest, we don’t have soft power-off <SM20> fau
-				beq.s	@noSoftPowerOff					; <SM20> fau
-				cmpi.w	#gestaltTempest33,machType(a0)	; if this is a Tempest, we don’t have soft power-off <SM23> fau
-				beq.s	@noSoftPowerOff					; <SM23> fau
-			ENDIF										;															<SM39>
-				move.l	#gestaltHasSoftPowerOff,d1		;  Get the Gestalt bit for SoftpowerOff
+				move.l	RomBase,a0
+				cmp.w	#$67C,ROMHeader.MachineNumber(a0)
+				bne.s	@noSoftPowerOff
+				move.l	#gestaltHasUniversalROM,d1		;  Get the Gestalt bit for SoftpowerOff
 				bset	d1,d0							;  Say we gots SoftPowerOff
 @noSoftPowerOff
-
-@IsUniversal	
-			IF not forROM THEN
-				bsr.s	IsROMUniversal					; See if this ROM is universal						<SM29>
-				beq.s	@checkMemCtrlr					; -> Nope, skip it									<SM29>
-			ENDIF
-@HasUniv		move.l	#gestaltHasUniversalROM,d1		;   Get the Gestalt bit for Univ					<6>
-				bset	d1,d0							;  Say we gots a Universal ROM!						<6>
-
-@checkMemCtrlr	move.l	UnivInfoPtr,a0					; Get pointer to ProductInfo record					<SM11>
-				cmp.b	#DecoderKinds.OrwellDecoder,DecoderKind(a0)	; Do we have an orwell?
-				bne.s	@EnhLtalk						; IF we have an Orwell THEN
-				bset	#gestaltHasOrwell,d0			;	set the corresponding Gestalt bit
-
-@EnhLtalk		TestFor	hasEnhancedLTalk				; Do we have CURIO LocalTalk enhancements?
-				beq.b	@checkMACE						; 	no, check next feature
-				bset	#gestaltHasEnhancedLtalk,d0		; That’s a big 10-4.
-
-@checkMACE		TestFor	MACEExists						; do we have MACE Ethernet Controller?
-				beq.s	@hardwareExit					; no, exit
-				bset	#gestaltHasMace,d0
-
-*				bra.s	@hardwareExit
-
-@hardwareExit	
 				bra		stdResult						; return the result in d0
 
 
@@ -1204,6 +950,7 @@ AttrTable		dc.b	gestaltHasVIA1,VIA1Exists
 				dc.b	gestaltHasOSS,OSSExists
 				dc.b	gestaltHasFMC,FMCExists
 				dc.b	gestaltHasRPU,RPUExists
+				dc.b	gestaltHasOrwell,OrwellExists
 				dc.b	gestaltHasJaws,JAWSExists										;<2>
 				dc.b	gestaltHasSonic,SonicExists										;<2>
 				dc.b	gestaltHasSCSI961,SCSI96_1Exists								;<2>
@@ -1213,51 +960,11 @@ AttrTable		dc.b	gestaltHasVIA1,VIA1Exists
 				ENDWITH
 
 
-************************************************************************				<SM30>
-*   Universal ROM check
-************************************************************************
-IsROMUniversal
-			IF NOT forROM THEN
-				move.l	A1,-(SP)						; Save A1
-				move.l	ROMBase,A0						; Get ROMBase
-				lea		universalROMs,A1				; Point to the table of Clean/Univeral ROM Sigs
-@UnivLupe		move.w	(A1)+,D1						; Get a ROM id (list is null terminated)
-				beq.s	@done							; -> End of table means not universal (huh)
-				cmp.w	D1,ROMHeader.MachineNumber(A0)	; Check a table entry
-				bne.s	@UnivLupe						; -> Nope, keep looping
-			ELSE
-				moveq	#1,D1							; Yes, set D0
-@Done			movem.l	(SP)+,A1						; Restore A1
-				rts
-			
-			ENDIF
-
-
-************************************************************************
-
-************************************************************************
-*	AppleTalk Interrupt Disable Level
-*		- for new machines to supply AppleTalk with the appropriate 
-* 		interrupt mask, so AppleTalk doesn't default to disabling Level 4
-*		and below interrupts ($2400).
-*		- initially needed for Cyclone/Tempest
-*		
-************************************************************************
-
-GetAtlkIntLevel
-				TestFor	MACEExists				; Do we have a MACE Ethernet Controller? 
-				Beq		stdUnknown				; no, give an error	
-				TestFor	PSCExists				; Do we have a PSC DMA/Interrupt Controller? 
-				Beq		stdUnknown				; no, give an error	
-				Move.l	#$2,d0					; return interrupt mask level 2									
-				Bra		stdResult				; and exit											
-				
-
 ************************************************************************
 *   machine-specific selectors
 ************************************************************************
 
-		IF ( ForRom) THEN					;										<2.9>
+		IF (1 OR ForRom) THEN					;										<2.9>
 getMachSpecific	lea		Selectors,a0			; get address of selector table
 				clr.l	d1						; use d1 as second index
 
@@ -1572,18 +1279,14 @@ addLoop			tst.l		(a3,d3)					; end of table?
 ; Initialize gestalt global values
 ;------
 
-initGlobals		bsr.s		TestForEmu				; Test for a 68k emulator.  Update globals if so.	<SM30>
-				bne.s		@MachineType			; -> (hasEmu) Everything is setup.					<SM30>
-
-				move.l		MemTop,D2				; Get the current Logical RAM size					<5>
+initGlobals		move.l		MemTop,D2				; Get the current Logical RAM size					<5>
 				bsr.s		GetEDiskSize			; Get the EDisk size in bytes in D0					<5>
 				add.l		D0,D2					; add it to the LRAM size.							<5>
 @SaveLRAM		move.l		D2,realTop(a2)			; Save Logical RAM size								<2.9>
 		
-			IF NOT forROM THEN
-				bsr.s		IsROMUniversal			; Is this a 32 bit clean ROM?						<SM29>
-				beq.s		@not32bitClean			; -> Nope.  Use Memtop for Log & Phys				<1>
-			ENDIF
+				move.l		RomBase,A0				; Check the ROM
+				cmp.w		#$67C,8(A0)				; Is this a 32 bit clean (i.e. IIci) ROM?
+				bne.s		@not32bitClean			; -> Nope.  Use Memtop for Log & Phys
 				move.l		RealMemTop,D2			; On IIci ROM get Logical from RealMem				<11>
 				add.l		D0,D2					; Add in size of RAM disk to logical				<11>
 				move.l		D2,realTop(a2)			; Save the adjusted Logical size					<11>
@@ -1592,13 +1295,15 @@ initGlobals		bsr.s		TestForEmu				; Test for a 68k emulator.  Update globals if
 @not32bitClean	move.l		MemTop,memSize(a2)		; save Physical memory size
 
 @CheckForVM		move.l		VMGlobals,D0			; Get the Ptr to VM's globals						<6>
+				beq.s		@MachineType			; -> No VM											<6>
 				bmi.s		@MachineType			; -> No VM											<6>
 
 				move.l		D0,A1					; Get VM globals Ptr								<6>		
 		
 			IF NOT forROM THEN
-				bsr.s		IsROMUniversal			; Is this a 32 bit clean ROM?						<SM29>
-				bne.s		@GetLogical				; -> Yes The Phys size is already correct			<6>
+				move.l		RomBase,A0				; Check the ROM
+				cmp.w		#$67C,8(A0)				; Is this a 32 bit clean (i.e. IIci) ROM?
+				beq.s		@GetLogical				; -> Yes The Phys size is already correct			<6>
 
 				moveq		#-5,D0					; GetPhysicalBytes
 				_MemoryDispatch						; Ask VM how much Physical RAM is in the machine
@@ -1629,77 +1334,60 @@ initGlobals		bsr.s		TestForEmu				; Test for a 68k emulator.  Update globals if
 
 ;---------------------------------------------------
 ; GetEDiskSize
-; uses the value stored in BootGlobs record
-;  at bgRamDiskSize
 ;
 ; Exit:
 ;	D0 - Size in bytes
 ;---------------------------------------------------
-				WITH 		StartGlobals			;										<SM11> RLM <SM13> CSS				
-GetEDiskSize	move.l	BootGlobPtr,a0				; get ptr to boot globals at top of RAM <SM11> RLM
-				move.l	sgRamDiskSize(a0), D0		; size of ram disk, if any				<SM11> RLM						
-				rts									; 										<SM11> RLM				
-				ENDWITH								; (BootGlobs) 							<SM11> RLM
-
-
-
-;__________________________________________________________________________________________	<SM30> SAM
-; TestForEmu
-;
-; Tests for the existence of a 68k emulator.  Implies a PowerPC architecture.  Get the
-; CPU id from the 60x processor and save it in Gestalt's globals.  Update Gestalt's
-; logical and physical RAM size globals if Emu is running.
-;
-; Entry:
-;	A2 - 	Ptr to Gestalt's Globals
-; Exit:
-;	D0 - 	Clear if no Emulator.  Nothing else touched.
-;			Set if emulator installed, GestaltGlobals.realTop/memSize/pageSize updated
-;———————————————————————————————————————————————————————————————————————————————————————————
-			With	NKSystemInfo, ProcessorInfo
-TestForEmu	MOVE.L	Line1111,-(SP)					; Save the F-Line vector
-			PEA		@Continue						; Push the addr of our routine
-			MOVE.L	(SP)+,Line1111					; Update the vector
-			MOVE.L	SP,D1							; Save the Stack Ptr case we take an F-Line
-			MOVEQ	#0,D0							; Clear the "has and emulator" flag
-			NOP										; Sync the pipeline
-
-			_RiscCoprocessorNop						; Either do nothing, or skip the next instructon
-			MOVEQ	#1,D0							; Set the "has a 68k emulator" flag
-
-@Continue	MOVE.L	D1,SP							; Restore the SP (trash the exception frame if we made one)
-			MOVE.L	(SP)+,Line1111					; Restore the Vector
-			NOP										; See above
-
-			MOVE.B	D0,emu68k(A2)					; Save the Result in Gestalt's globals
-			BEQ.S	@Done							; -> No, emu.  No data page.			
-				
-			MOVE.L	ProcessorInfoPtr,A3				; Point to the NanoKernel's Processor Info record
-
-			MOVE.L	PageSize(A3),nativePageSize(A2)	; Save the native page size in Gestalt's globals
-			MOVE.W	ProcessorVersionReg(A3),D1		; Get the PowerPC CPU version
-			MOVE.B	D1,nativeCPU(A2)				; Save the native CPU type
-			
-			MOVE.L	NKSystemInfoPtr,A3				; Point to the NanoKernel's System Info record
-			
-			MOVE.L	PhysicalMemorySize(A3),D3		; Get the Physical Memory Size
-			MOVE.L	D3,memSize(A2)					; Save it in Gestalt's globals
-			TST.L	VMGlobals						; Is VM on?
-			BMI.S	@noVM							; -> Nope
-
-			MOVEQ	#-6,D0							; GetLogicalSize
-			_MemoryDispatch							; Ask VM how much logical RAM we have
-	
-			SUB.L	UsableMemorySize(A3),D3			; Calc ram allocated by the NanoKernel
-			ADD.L	D0,D3							; Add that to VM's logical size.
-				
-@noVM		MOVE.L	D3,realTop(A2)					; Save the Logical RAM size
-@Done		RTS
-			
-			EndWith
-			
-				IMPORT		GESTALTSCRIPTMGR		; <SM8> rb
-				IMPORT		GetSoundAttributes		; found in SndLowLevel.a
+GetEDiskSize
+				movem.l	a1/a2/d2,-(sp)
+				move.l	RomBase,a0
+				cmp.w	#$37A,ROMHeader.MachineNumber(a0) ; Portable
+				beq.s	@returnZero
+
+				lea		DrvQHdr+QHead-QLink,a0
+@dqloop			move.l	(a0),d0
+				beq.s	@returnZero
+				move.l	d0,a0
+
+				move.w	dQDrive(a0),d1
+				move.w	dQRefNum(a0),d0
+				move.w	d0,d2
+				add.w	#1,d0
+				neg.w	d0
+				asl.w	#2,d0
+				move.l	UTableBase,a1
+				move.l	(a1,d0),a1
+				move.l	(a1),a1
+				btst	#dRAMBased,dCtlFlags+1(a1)
+				beq.s	@romBased
+				move.l	(a1),a1
+@romBased		move.l	(a1),a1
+				lea		drvrName(a1),a1
+				lea		@dotEDisk,a2
+				clr.l	d0
+				move.b	(a2),d0
+@cmploop		cmp.b	(a2)+,(a1)+
+				bne.s	@dqloop
+				dbra	d0,@cmploop
+
+				lea		-CntrlParam.size(sp),sp
+				move.l	sp,a0
+				clr.l	CntrlParam.ioCompletion(a0)
+				clr.w	CntrlParam.ioVRefNum(a0)
+				move.w	d2,CntrlParam.ioCRefNum(a0)
+				move.w	d1,CntrlParam.ioVRefNum(a0)
+				move.w	#drvSizeCode,CntrlParam.csCode(a0)
+				_Status	,immed
+				move.l	CntrlParam.csParam(a0),d0
+				lea		CntrlParam.size(sp),sp
+				bra.s	@return
+
+@returnZero		clr.l	d0
+@return			movem.l	(sp)+,a1/a2/d2
+				rts
+
+				STRING	AsIs
+@dotEDisk		dc.b	6, '.EDisk', 0
 
 ;-----
 ;	Table of built-in Gestalt selectors
@@ -1734,24 +1422,10 @@ SelectorTable	Selector	gestaltMachineType,			getMachineType			; machine type
 				Selector	gestaltMiscAttr,			getMisc					; misc attributes
 				Selector	gestaltNotificationMgrAttr,	notification			; nmgr attributes
 				Selector	gestaltSerialAttr,			getSerialAttr			; serial attributes
-				Selector	gestaltSerialHALType,		getSerialHALType		; serial HAL resource ID
-		IF  ForRom THEN														; <PN> <SM2>
-				Selector	gestaltOSTable,				getOSTable				; base of the OS trap table <PN> <SM2>
-				Selector	gestaltToolboxTable,		getToolboxTable			; base of the toolbox trap table <PN> <SM2>
-				Selector	gestaltExtToolboxTable,		getExtToolboxTable		; base of the ext. toolbox trap table <PN> <SM2>
-				Selector	gestaltFSAttr,				getFSAttr				; return file system attributes <PN> <SM2>
-				Selector	gestaltQuickdrawFeatures,	getQuickdrawFeatures	; return ColorQuickdrawfeatures <PN> <SM2> 
-			IF hasSplineFonts THEN		
-				Selector	gestaltFontMgrAttr,			getFontMgrAttr			; return true if outline fonts <PN> <SM2> 
-			ENDIF
-				Selector	gestaltScriptMgrVersion,	GESTALTSCRIPTMGR    	; Script Manager version number	 <SM8> rb
-				Selector	gestaltScriptCount,			GESTALTSCRIPTMGR		; Script Manger count of scripts <SM8> rb
-				Selector	gestaltSoundAttr,			GetSoundAttributes		; get the sound attributes
-				Selector	gestaltSoundHardware,		GetSoundHardware		; get the sound harwdware chip type <SM9> rb
-				Selector	gestaltAtlkIntLevel,		GetAtlkIntLevel			; get cpu's desired appletalk interrupt mask level
-		ENDIF																	; <22>
-				Selector	gestaltSysArchitecture,		getSysArchitecture		; System Architecture			<SM24>
-				Selector	gestaltNativeCPUtype,		getNativeCPUtype		; Native Processor Type			<SM24>
+				Selector	gestaltOSTable,				getOSTable				; base of the OS trap table
+				Selector	gestaltToolboxTable,		getToolboxTable			; base of the toolbox trap table
+				Selector	gestaltExtToolboxTable,		getExtToolboxTable		; base of the ext. toolbox trap table
+				Selector	gestaltFSAttr,				getFSAttr				; return file system attributes
 				Selector	13,							Internal				; special
 				Selector	7,							Internal				; special
 				Selector	0,							0						; EOT
@@ -1860,7 +1534,7 @@ findMMUType
 				Move.l	ExpandMem,A0			; find out where expandMem is
 				Move.l	emGestalt(A0),A0		; get global ptr
 				Cmp.w	#gestaltMacSE,machType(A0)	; should we bother to find out?
-				Blo.s	@noMMU					; nothing before SE can have one (yes)
+				Blt.s	@noMMU					; nothing before SE can have one (yes)
 		ENDIF
 
 		IF hasMMU or (not ForRom) THEN			;
@@ -1869,7 +1543,7 @@ findMMUType
 				cmp.b	#HMMU,d0				; is it an AMU?
 				beq.s	@MMUDone				; then we're done
 				cmp.b	#PMMU851,d0				; then make sure there is one at all
-				Blo.s	@noMMU					; no mmu
+				Blt.s	@noMMU					; no mmu
 				Subq	#1,D0					; convert to right format
 				Bra.s	@MMUDone				; go return result
 		ENDIF									;
@@ -1954,13 +1628,13 @@ findParityStatus
 				st.b	(a1)					; write wrong parity mode
 				clr.b	(a3,d2.w)				; write one SIMM with bad parity
 				
-				st.b	rpuReset(a1)			; sync up RPU serial line				<SM4><SES>
-				clr.b	(a1)					; write good parity mode				<SM4><SES>
-
 				tst.l	(a3)					; parity error if it's a parity SIMM
 				nop								; wait for an interrupt
 				nop
 				
+				st.b	rpuReset(a1)			; sync up RPU serial line
+				clr.b	(a1)					; write good parity mode
+
 				move.l	d1,(a3)					; restore contents of longword
 				move	#$2000,sr				; turn interrupts back on
 				move.l	d4,AutoInt7				; restore NMI vector
diff --git a/OS/Gestalt/GestaltLookup.c b/OS/Gestalt/GestaltLookup.c
--- a/OS/Gestalt/GestaltLookup.c
+++ b/OS/Gestalt/GestaltLookup.c
@@ -10,7 +10,6 @@
 	Change History (most recent first):
 
 	   <SM5>	11/10/93	fau		Removed ulong typedef since it's now in Types.h.
-	   <SM4>	 5/18/93	RC		perfomance/bug fix changed a > to >> in FindLong
 	   <SM3>	  4/8/93	CSS		Use GestaltPrivateEqu.h, and remove definitions in this file.
 		<11>	10/28/92	DTY		Use Get/Set macros to access ExpandMem.
 		<10>	12/13/90	SAM		Making Gestalt check for a nil proc ptr on _NewGestalt calls.
@@ -247,7 +246,7 @@ findLong(ulong selector, int* index)
 	min = 0;
 	max = GestaltPtr->slotsUsed-1;
 	do {
-		i = min + ((max - min) >> 1);		/* get middle of range */
+		i = min + ((max - min) > 1);		/* get middle of range */
 		if (tablePtr[i][0] > selector)		/* are we too high? (is that possible?) */
 			max = i;
 		else if (tablePtr[i][0] < selector)	/* are we too low? */
diff --git a/OS/HFS/Cache/DiskCache.a b/OS/HFS/Cache/DiskCache.a
--- a/OS/HFS/Cache/DiskCache.a
+++ b/OS/HFS/Cache/DiskCache.a
@@ -10,19 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	11/23/93	rab		In the previous checkin a !forROM conditional was added to
-;									FlushCache to strip out a check for the Mac+ ROM. Unforutnately
-;									the conditional was added a few lines too soon and eliminated
-;									all of the logic which decided if the cache should be flushed
-;									based on CacheFlag and noFlushBit. The result was that the cache
-;									always flushed which causes a performance hit. Moved the
-;									conditional and added a bra fcExit so things will work like they
-;									used to.
-;	   <SM3>	11/18/92	RB		Made some changes forROM so that we have the disk cache code in
-;									ROM and not installed as a patch from the system file. This code
-;									is now installed as the cache from ROM, but we do not prevent
-;									the file system cache from being installed (yet), so we will let
-;									this cache do cleanup.
 ;		<24>	 12/3/91	KST		Clean up the equates. Remove cbHqAge and use cbHqDevNum
 ;									consistently.
 ;		<23>	  7/9/91	JSM		Remove obsolete SysVers conditionals, turn off a label unless
@@ -367,7 +354,7 @@ ktDebugCache	equ		0
 ktDebugHash	equ		0
 		endif
 
-RAMCache	PROC	EXPORT			;												<SM3> rb
+			MAIN
 
 ; The following absolute addresses are needed to patch problems in the version 75 ROM:
 
@@ -376,11 +363,6 @@ FlMDBCall	EQU		$402DD8			; ROM75 FlushMDB return address (used for patch)
 
 ;_______________________________________;
 ;
-; If we are compiling forROM, this code is simply part of the ROM code and not a	<SM3> rb
-; resource installed by a patch.													<SM3> rb
-;
-; Otherwise:																		<SM3> rb
-;
 ; The following code is made into
 ;	a separate resource of type CACH.
 ;	It is loaded by the CacheLoad (PTCH 0 in 7.0 world)
@@ -390,13 +372,10 @@ FlMDBCall	EQU		$402DD8			; ROM75 FlushMDB return address (used for patch)
 
 CacheStart
 	
-	IF NOT forROM THEN					;											<SM3> rb
-	
 			BRA		 CacheInstall		;										<06Dec85>
 			DC.L	('CACH')			; CACH resource 						<06Dec85>
 			DC.W	1					; res is 1								<06Dec85>
 			DC.W	3					; <17Apr90> version 3					<17Apr90>
-	ENDIF								;											<SM3> rb
 	
 ;_________________________________________________________________________________
 ;
@@ -453,17 +432,12 @@ fcFile		MOVEA.L FCBSPtr,A1			; A1 = FCB ptr
 			BNE.S	@1					; br if so (go flush)
 			BTST	#noFlushBit,FHFlags(A4) ; avoid intermediate flushes?		<08Dec85>
 			BEQ.S	@1					; br if not (go flush)					<08Dec85>
-			bra.s	fcExit				; exit if so (skip flush)				<SM4>
 
-	IF NOT forROM THEN					; We don't need MacPlus ROM check		<SM3> rb <SM4>
 			MOVE.L	ROMBase,A3			;<11Dec86> make sure we have the correct ROM
 			CMP.W	#$0075,8(A3)		;<11Dec86>
 			BNE.S	fcExit				;<11Dec86> exit if not
 			CMP.L	#FReadCall,$28(A6)	; FileRead flush before verify? 		<08Dec85>
 			BNE.S	fcExit				; exit if not (skip flush)				<08Dec85>
-	ELSE								;										<SM3> rb
-			; if FlushFlag is 0, then if this file is control file skip flushing
-	ENDIF								;										<SM3> rb
 	
 @1			BSR 	FlushFCache 		; flush the A4 cache
 			BRA.S	fcExitTrash 		; trash and exit						<28Sep89>
@@ -925,8 +899,6 @@ RelBlock
 			MOVE.L	(SP)+,-(A6) 		; save return address on A6 stack
 			MOVE.L	A4,-(A6)			; save registers
 
-	IF NOT forROM THEN					; Not for the new ROMs					<SM3> rb
-	
 ; The next nine lines patch a bug in ROM 75 (FlushMDB never cleared dirty bits
 ;  on control file FCBs . . .)
 
@@ -940,7 +912,6 @@ RelBlock
 			BCLR	#FCBModBit,FCBMdRByt(A3,D0) ; clear the dirty flag
 			MOVE.W	VCBCTRef(A2),D0 	; Get catalog file refNum
 			BCLR	#FCBModBit,FCBMdRByt(A3,D0) ; clear the dirty flag
-	ENDIF								;										<SM3> rb
 
 @4			
 										; now we have pointer to data buffer	<23Apr90>
@@ -2553,8 +2524,6 @@ StrFreeQCnt DC.B	'Cache: Free Q Cnt Bad'
 StrTotalCnt DC.B	'Cache: Total Cnt Bad'
 			ENDIF
 
-	IF NOT forROM THEN					;										<SM3> rb
-	
 CutBack
 			_SetHandleSize				; adjust our size
 
@@ -2566,8 +2535,6 @@ CutBack
 			RTS
 EndResident
 
-	ENDIF								;										<SM3> rb
-	
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;; Code after this point will be discarded !!
 
@@ -2648,7 +2615,6 @@ verifyCacheSize
 ;						physical memory that Ramcache can allocate. The max size
 ;						is calculated based on memory CDEV and may be changed later.
 ;_________________________________________________________________________________
-			EXPORT	CacheInstall		;											<SM3> rb
 CacheInstall
 
 										; assume A0/A1 to be free
@@ -2736,18 +2702,12 @@ CacheInstall
 
 			BSR		SyncFSCall			; <02Dec86> synchronize with fs and call below
 	
-	IF NOT forROM THEN					;										<SM3> rb
-	
 			LEA		CacheStart,A0		; get beginning of resident code
 			LEA		EndResident,A1		; get end of resident code
 			SUB.L	A0,A1				; calculate size
 			_RecoverHandle				; recover handle to code (pointed to by A0)
 			MOVE.L	A1,D0				; put size in D0 for SetHandleSize
 			BRA		CutBack				; and slice away.
-			
-	ELSE								;	we are the ROM, this is no patch	<SM3> rb
-			RTS							;										<SM3> rb
-	ENDIF								;										<SM3> rb
 
 ; The following code is executed while the file system is in a suspended state.
 ; Input:	A0.L = ptr(cachevar)
diff --git a/OS/HFS/Extensions/BTPScan.a b/OS/HFS/Extensions/BTPScan.a
--- a/OS/HFS/Extensions/BTPScan.a
+++ b/OS/HFS/Extensions/BTPScan.a
@@ -7,8 +7,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM1>	 4/15/92	kc		Removed the "ROM" prefix from the RomBind routines.
-;									• Pre-SuperMario comments follow •
 ;		<13>	 9/13/91	JSM		Cleanup header.
 ;		<12>	 3/11/91	dnf		dba, #83780: Remove HFS stack overflow check from BTPScan, which
 ;									isn’t the right place for such a check. Also, this was left over
@@ -215,7 +213,7 @@ GetMultNodes:	proc
 	MOVE.L		D2, fcbCrPs(A3)						; put our current pos back into fcb
 	
 @RdTop:
-	jsrRom		CACHERDIP   						; go do the read
+	jsrRom		ROMCACHERDIP						; go do the read
 @1:	BNE.S		@Exit
 	ADD.L		D6, D5								; advance current file position
 	ADD.L		D6, ioActCount(A0)					; and tally up bytes read
@@ -348,7 +346,7 @@ ValidateNode:		proc
 		
 		MOVE.L		A4, D2						; save PSR around ChkNode
 		MOVEA.L		PSR.btcbPtr(A4), A4			; A4 = ptr(BTCB)
-		jsrRom		CHKNODE   					; is this node valid?
+		jsrRom		ROMCHKNODE					; is this node valid?
 		MOVEA.L		D2, A4						; restore PSR
 		BNE.S		@more						; not valid, get another node
 
@@ -447,7 +445,7 @@ BTGetPhys:		proc
 	MOVE.W		PSR.curRec(A4), D1			; D1 = record we want
 	ADDQ.W		#1, PSR.curRec(A4)			; advance to next record for next time	<8>
 	MOVEA.L		PSR.btcbPtr(A4), A4			; A4 = ptr(BTCB)
-	jsrRom		LOCREC   
+	jsrRom		ROMLOCREC
 @1: MOVEA.L		(A6)+, A4					; restore PSR ptr
 @Exit:
 	MOVE.L		(A6)+, -(A7)				; restore return address
diff --git a/OS/HFS/Extensions/BTreeMgr/BTreeFuncs.a b/OS/HFS/Extensions/BTreeMgr/BTreeFuncs.a
--- a/OS/HFS/Extensions/BTreeMgr/BTreeFuncs.a
+++ b/OS/HFS/Extensions/BTreeMgr/BTreeFuncs.a
@@ -18,7 +18,6 @@
 ;									we change the header node. And make sure that the file has write
 ;									permission. Previous fix did not work with a BTfile opened with
 ;									read only permission.
-;	   <SM2>	10/22/92	CSS		Change some branch short instructions to word branches.
 ;	   <SM1>	 4/1/92		kc		Changed the name prefex used to distinguish
 ;									 routines used by the external B-Tree manager
 ;									from the versions used by the File System.	
@@ -521,8 +520,7 @@ GNMLoop		CMP.W	D1,D3				; same FCB?
 			MOVE.L	FCBBTCBptr(A1,D1),D0; D0 = ptr(BTCB)?					<12Jan92 #39>
 			BNE.S	BOpened				; found it							<12Jan92 #39>
 
-GtNxtMatch	ADD.W	FSFCBLen,D1			; go to next FCB				<03Feb87><SM1>
-			CMP.W	(A1),D1 			; reached the end yet?					 <SM1>
+GtNxtMatch	jsrROM	ROMGTNXTFCB			; go to next FCB				<03Feb87>
 			BCS.S	GNMLoop 			; loop thru them all
 
 		;; This is the first time open
@@ -619,8 +617,7 @@ xBTClose	BCLR	#btAsyncBit,D1 		; sync only
 			BNE.S	@NxtMatch			;									<28Mar90>
 			CMP.L	FCBVPtr(A1,D1),A3	; on the same volume?				<28Mar90>
 			BEQ.S	@BCOpened			; found it							<28Mar90>
-@NxtMatch	ADD.W	FSFCBLen,D1			; go to next FCB				    <SM1>
-			CMP.W	(A1),D1 			; reached the end yet?				<SM1>
+@NxtMatch	jsrROM	ROMGTNXTFCB			; go to next FCB
 			BCS.S	@BCLoop 			; loop thru them all				<28Mar90>
 
 		IF btDebug THEN					; no match ??!!						<28Mar90>
@@ -871,7 +868,7 @@ xBTGetRec	BSR		ExtBTQueue
 			CMP.L	BTCWcount(A4),D1	; validate it
 			BEQ.S	@GetRec2			; OK
 			MOVE.L	BTCWcount(A4),ioBTHint1(A3)	; return current Wcount
-			BRA 	GetExit				; invalid marker <SM2> CSS 
+			BRA.S	GetExit				; invalid marker
 @2
 			MOVE.L	btcFNode(A4),D2		; user wants to read the 1st record
 @GetRec2	MOVE.L	D2,btcNodeM(A4)		; get record in this node, (change the node marker)
@@ -1077,8 +1074,7 @@ xBTCleanUp
 			MOVE	cbPBufULen(A2),D4		; D4=ext. FCB unit size
 			LEA		fcbPBufData(A2),A2		; A2=ext. fcb array
 			MOVE	FSFCBLen,D5				; D5=FCB len
-			MOVE.L	FCBSPtr,A1				; A1=FCB ptr			<SM1>
-			MOVEQ	#2,D1					; D1=FCB index			<SM1>
+			jsrROM	ROMGT1STFCB				; A1=FCB ptrm, D1=FCB index
 			
 ; First close all the open files belong to this process:
 ; A1=FCBptr, A2=Ext. FCBptr, D1.W=RefNum, D2=id2, D3.W=loop index, D4.W=ext FCBlen,
diff --git a/OS/HFS/Extensions/BTreeMgr/BTreeSvcs.a b/OS/HFS/Extensions/BTreeMgr/BTreeSvcs.a
--- a/OS/HFS/Extensions/BTreeMgr/BTreeSvcs.a
+++ b/OS/HFS/Extensions/BTreeMgr/BTreeSvcs.a
@@ -1217,6 +1217,13 @@ BSExit1
 
 
 
+UnknownFunction
+			MOVE.L	$74C,-(SP)
+			RTS
+
+
+
+
 ;__________________________________________________________________________________
 ;
 ; Routine:		ExtBTUpdate
diff --git a/OS/HFS/Extensions/CatSearch.a b/OS/HFS/Extensions/CatSearch.a
--- a/OS/HFS/Extensions/CatSearch.a
+++ b/OS/HFS/Extensions/CatSearch.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM1>	 4/15/92	kc		Removed the "ROM" prefix from the RomBind routines.
-;									• Pre-SuperMario comments follow •
 ;		<19>	 9/13/91	JSM		Cleanup header.
 ;		<18>	 2/25/91	dnf		dho, #83584: Change the name of maskNotFileNames to
 ;									maskNotSearchInfo2, since that what it really does. Update the
@@ -872,7 +870,7 @@ CheckCSPB		proc	export
 ;__________________________________________________________________________________
 CMCatSearch:	proc	export
 
-	jsrRom		FSQUEUE   					; queue up the request
+	jsrRom		ROMFSQUEUE					; queue up the request
 	SUBA.W		#CSSR.size, A6				; allocate a CSSR on A6 					moved here <1.3>
 	CLR.B		CSSR.flags(A6)				; clear the flags							moved here <1.3>
 	MOVEA.L 	A6, A3						; move CSSR ptr to a safe register				<12>
@@ -881,7 +879,7 @@ CMCatSearch:	proc	export
 	move.l		ioSearchTime(a5), d0		; get max search time (time mgr count)			<12>
 	bsr 		StartTimer					; start a timer, if needed, right away			<12>
 
-	jsrRom		DTRMV3   					; find vol using ioNamePtr & ioVRefNum (D023/A234 trashed)
+	jsrRom		ROMDTRMV3					; find vol using ioNamePtr & ioVRefNum (D023/A234 trashed)
 	MOVEA.L 	A6, A3						; reload pointer to CSSR (doesn’t hurt CCs)		<12>
 	BNE 		@Exit						; (DtrmV3 puts VCBPtr in A2)
 	MOVE.W		vcbSigWord(A2), D0			; Check out the volume signature
@@ -891,7 +889,7 @@ CMCatSearch:	proc	export
 	BRA 		@Exit						; and cruise
 
 @ItsHFS:
-	jsrRom		EXTOFFLINCK   				; Is this volume on-line and one of ours?				<1.2>
+	jsrRom		ROMEXTOFFLINCK				; Is this volume on-line and one of ours?				<1.2>
 	BEQ.S		@VolumeIsCool				; Keep going if so										<1.2>
 	BRA 		@Exit						; Go home if not (with extFSErr or volOffLinErr in D0)	<1.2>
 
@@ -1007,7 +1005,7 @@ CMCatSearch:	proc	export
 @notBufferOnStack:
 	ADDA.W		#CSSR.size, A6				; deallocate CSSR
 	suba.l		a3, a3						; clear WDCB pointer for external file systems		<17>
-	jmpRom		CMDDONE   
+	jmpRom		ROMCMDDONE
 
 	_CSDebugRts 'CMCatSearch', 0
 	endproc
diff --git a/OS/HFS/Extensions/DTDBMgr.a b/OS/HFS/Extensions/DTDBMgr.a
--- a/OS/HFS/Extensions/DTDBMgr.a
+++ b/OS/HFS/Extensions/DTDBMgr.a
@@ -10,15 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	  6/9/93	pdw		Changed register saving from interruptRegs to pascalRegs in
-;									completionRoutine because it is supposed to be using this
-;									convention.
-;	   <SM3>	10/27/92	CSS		Changed some word bsrs to bigjsrs.
-;	   <SM2>	10/27/92	CSS		Changed short branch to word branch.
-;	   <SM1>	 4/1/92		kc		Copied the routines DesktopCloseDownProc, CheckDesktopSupport and  DTDBMgrInit
-;									from FileMgrPatches.a. Removed the "ROM" prefix from the RomBind routines.
-
-;									• Pre-SuperMario comments follow •
 ;		<32>	 9/13/91	JSM		Cleanup header.
 ;		<31>	 5/23/91	dba		MPW 3.2 assembler no longer supports local labels for records
 ;		<30>	 3/28/91	dnf		ewa, #SetFileAttribsIsntAsyncSafe: The SetFileAttribs subroutine
@@ -212,7 +203,6 @@
 			include		'MFPrivate.a'
 			include		'HardwarePrivateEqu.a'
 			include		'Folders.a'
-			include		'InternalOnlyEqu.a'				; <SM3> CSS
 			print		pop
 
 			BLANKS ON
@@ -258,213 +248,6 @@ DTKeyDescriptor:	proc
 			proc
 			_DTDebugRts	'DTDBQueueManager', 0
 			endproc
-;________________________________________________________________________________	<SM1>
-; <36>
-; Routine:		DesktopCloseDownProc
-;
-; Inputs 		param block to _Unmount
-;
-; Outputs:		(none)
-;
-; Function:		Close the desktop database on _Unmount calls
-;
-;________________________________________________________________________________
-; Rolled into TFS.a for SuperMario <SM1> FM
-; Called by UnMountVol in TFSVol.a
-
-DesktopCloseDownProc Proc Export
-			import		FindDTVol
-@regs		reg			a0/a1/a3/d0/d1					;										<43>
-
-			movem.l		@regs, -(sp)
-
-			movea.l		a0,a3							; save the user's pb					<42>
-
-;	d0 - pascal length byte of string															<43>
-;	d1 - size of string allocated on stack														<43>
-
-			moveq.l		#0,d1							; assume no string on stack				<43>
-			move.l		ioNamePtr(a3),d0				; d0 = caller’s name ptr				<43>
-			beq.s		@noName							; bail on nil							<43>
-			movea.l		d0,a0							; get ready to copy						<43>
-			moveq.l		#0,d0							; clear high bytes						<43>
-			move.b		(a0),d0							; d0 = string length					<43>
-			beq.s		@noName							; bail on zero length (d0.l has nil)	<43>
-
-			move.b		d0,d1							; d1 = copy of string length byte		<43>
-			addq.b		#2,d1							; add length byte and rounding fodder	<43>
-			bclr.l		#0,d1							; make it even							<43>
-			suba.w		d1,sp							; allocate a string of the right length	<43>
-			movea.l		sp,a1							; point to it							<43>
-
-@1:			move.b		(a0)+,(a1)+						;										<43>
-			dbra		d0,@1							; copy string length+1 bytes			<43>
-
-			move.l		sp,d0							; point to it again						<43>
-
-@noName:
-			suba.w		#ioHVQElSize,sp					; get a pb								<42>
-			movea.l		sp,a0							; point to it							<42>
-			move.w		ioVRefNum(a3),ioVRefNum(a0)		; copy caller's vRefNum					<42>
-			move.l		d0,ioNamePtr(a0)				; our version of the caller's name		<42>
-			move.w		#-1,ioVolIndex(a0)				; by name&vRef, please					<42>
-			_GetVolInfo									;										<42>
-			bne.s		@done							;										<42>
-
-			move.w		ioVRefNum(a0), d0				; grab the volume that's going away
-			bsr			FindDTVol						; try to find a DTDBQElt for this volume
-			bne.s		@done							; no work to do if the DTDB is closed
-			sub.w		#ioDTQElSize, sp				; allocate a DT param block
-			movea.l		sp, a0
-			move.w		DTDBQElt.DTRefNum(a3), ioRefNum(a0)	; stash the DTRefNum for this volume
-			_DTCloseDown
-			add.w		#ioDTQElSize, sp				; deallocate the param block
-
-@done:
-			adda.w		#ioHVQElSize,sp					; deallocate the pb						<42>
-			adda.w		d1,sp							; deallocate the string					<43>
-			movem.l		(sp)+, @regs
-			rts
-			endproc
-;__________________________________________________________________________________
-;
-; Allocate the DTDBMgr's globals block
-;
-; FSVars has been allocated by btree patches.  
-;__________________________________________________________________________________	<SM1>
-DTDBMgrInit			proc	export
-					export	QMInit
-
-		move.l			#DTGlobals.size, d0			; we need this much space for DT manager
-		_NewPtr			sys, clear
-		bne				@fail						; no? Run away.
-		move.l			FSVarsPtr, a1				; a1 = ptr(FSVars block)
-		move.l			a0, FSVars.DTDBMgr(a1)		; stuff ourselves into our slot in FSVars
-		rts
-
-@fail
-		moveq.l			#dsMemFullErr, d0			; sys heap is full, so punt
-		_SysError
-
-; Allocate the Queue Manager's globals block
-QMInit			
-
-; Allocate a block big enough of all of the Queue Manager's needs:
-;	Queue manager globals
-;	Desktop manager QMRec
-;	Compatibility layer QMRec
-;	Desktop manager stack
-;	Compatibility layer stack
-
-		move.l			#QMGlobals.size+QMRec.size*2+DTStackSize+clStackSize, d0
-		_NewPtr			sys, clear
-		bne.s			@fail						; fail if we can't get memory
-
-		move.l			FSVarsPtr, a1				; a1 = ptr(FSVars block)
-		move.l			a0, FSVars.QMgr(a1)			; leave a pointer to globals in FSVars
-		move.l			a0, a1						; a1 = ptr(FSVars.QMgr)
-		adda.l			#QMGlobals.size, a0			; skip over globals
-		move.l			a0, QMGlobals.DTQueuePtr(a1); stuff pointer to DTMgr's QMRec
-		adda.l			#QMRec.size, a0				; skip over DTMgr's QMRec
-		move.l			a0, QMGlobals.CLQueuePtr(a1); stuff pointer to Comp Layer's QMRec
-
-		adda.l			#QMRec.size+DTStackSize, a0		; skip over QMRec and Stack
-		move.l			QMGlobals.DTQueuePtr(a1), a1	; a1 = ptr(DTMgr's QMRec)
-		move.l			a0, QMRec.stackBase(a1)			; store stack address (stack grows down)
-		move.w			#desktopQType, QMRec.qType(a1)	; set queue type/refnum
-
-		adda.l			#CLStackSize, a0				; skip to end of CLStack
-		move.l			FSVarsPtr, a1					; a1 = ptr(FSVars)
-		move.l			FSVars.QMgr(a1), a1				; a1 = ptr(QM globals)
-		move.l			QMGlobals.CLQueuePtr(a1), a1	; a1 = ptr(Comp Layer's QMRec)
-		move.l			a0, QMRec.stackBase(a1)			; store stack address (stack grows down)
-		move.w			#fsCompatQType, QMRec.qType(a1)		; set queue type/refnum
-
-		rts
-
-@fail:
-		moveq.l			#dsMemFullErr, d0			; sys heap is full, so punt
-		_SysError
-		endproc
-
-; <SM1> FM needed for GetVolParms
-;________________________________________________________________________________	<SM1>
-;
-; Routine:		CheckDesktopSupport													
-;
-; Input:		a2 - pointer to local volume's vcb
-; Output:		zero flag clear if we support the desktop on this volume
-;				zero flag set if we don't
-;
-; Function: 	Indicate whether a volume can support the desktop manager calls
-;
-; Only call this on local hfs volumes
-;
-; The rule:		A local volume gets desktop support if it is either
-;					1) non-ejectable
-;					2) ejectable but bigger than DTMinVolSize
-;
-; AlkBlkSiz is stored as a long and used as a word throughout HFS
-;________________________________________________________________________________
-CDSRegs			reg			d0/d1/a1
-CheckDesktopSupport	proc	export	
-
-			movem.l	CDSRegs, -(sp)
-
-;
-; Is this an MFS volume?
-;
-			cmp.w	#SigWord,vcbSigWord(a2)	; is this an MFS volume?
-			beq.s	@NoSupport			; yes, so use the exciting resource file technique
-;
-; Is this volume bigger than DTMinVolSize?
-;
-			move.w	vcbNmBlks(a2), d0	; d0 = # of allocation blocks on this volume
-			move.w	vcbAlBlkSiz+2(a2), d1	; d1 = allocation block size
-										; AlkBlkSiz is used as a word throughout HFS
-			mulu.w	d1, d0				; d0 = # bytes on this volume
-			cmp.l	#DTMinVolSize, d0	; is this a big volume?
-			bhs.s	@SupportsDT			; then we always support the DTDB
-;
-; It's not a big volume, but check and see if the volume is ejectable
-;
-			move.l	DrvQHdr+qHead, a1	; a1 = ptr (1st drive in Drive Queue)
-
-			move.w	vcbDrvNum(a2), d0	; d0 = drive number for this volume (if online)
-			bne.s	@SearchDrvQ			; if it's online, we can go straight to the search
-
-			move.w	vcbDRefNum(a2), d1	; d1 = + or - DrvNum (since we know we're not online)
-			cmp.w	d0, d1				; = means volume is ejected
-			beq.s	@NoSupport			; which means it gets no DT support
-			move.w	d1, d0				; d0 now = -DrvNum (since we know it's offline)
-			neg.w	d0					; d0 now = DrvNum, so we can search the drive Q
-;
-; We now have the drive number in d0, and we know that the drive is not big enough to
-; automatically get DT support.  We need to see if it is ejectable, and if it is a small
-; non-ejectable volume (say, a ramdisk) we support it.
-;
-@SearchDrvQ:
-			cmp.w	dQDrive(a1), d0		; is this the dQ entry we want?
-			beq.s	@GotDQ
-			move.l	qLink(a1), d1		; get the next dQ entry (test for zero)
-			movea.l	d1, a1				; move to an A reg where we can use it
-			bne.s	@SearchDrvQ			; and keep going if there is one
-			move.w	#nsvErr, d0			; if we have a real vcb, we should find a dQ entry
-			bra.s	@NoSupport			; but if we ever don't, let's return 'no support'
-
-@GotDQ:
-			cmp.b	#8, -3(a1)			; drive queue entry flag bytes => 8 (signed) are non-ejectable <19><51>
-			blt.s	@NoSupport			; we don't support DT on small ejectable volumes
-
-@SupportsDT:
-			moveq.l	#1, d0				; clear the zero flag
-			bra.s	@CDSExit
-
-@NoSupport:
-			moveq.l	#0, d0				; set the zero flag
-@CDSExit:	movem.l	(sp)+, CDSRegs
-			rts
-			endproc
 ;________________________________________________________________________________
 ;
 ; Routine:		BottleNeckIO
@@ -499,9 +282,7 @@ BottleNeckIO		proc	export
 	move.l			a0, FSVars.dtOwnCall(a1); leave a bread crumb for FileShare <17>
 
 	moveq.l			#desktopQType, d2		; our queue type/refnum
-	move.l			a4,-(sp)				; save a4 <SM3> CSS
-	bigjsr			GetQMRecPtr,a4			; a1 = ptr(QMRec) <SM3> CSS
-	move.l			(sp)+,a4				; recover a4 <SM3> CSS
+	bsr				GetQMRecPtr
 	move.l			a6, QMRec.curStack(a1)	; save current alt stack pointer
 	; •• do high water mark checking here
 
@@ -530,25 +311,19 @@ BottleNeckIO		proc	export
 
 completionRoutine:
 	moveq.l			#desktopQType, d2		; our queue type/refnum
-	MACHINE			mc68020
-	move.l			a4,-(sp)				; save a4 <SM3> CSS
-	bigjsr			GetQMRecPtr,a4			; a1 = ptr(QMRec) <SM3> CSS
-	move.l			(sp)+,a4				; recover a4 <SM3> CSS
+	bsr				GetQMRecPtr
 	move.l			a6, -(sp)				; save a6 for a sec
 	movea.l			QMRec.curStack(a1), a6	; get our a6 back
 	bset.b			#0, hasContinued(a6)	; mark that we've been back
 	movea.l			(sp)+, a6				; restore a6
 	beq.s			anRTSInstruction		; if we haven't returned from the trap, rts to driver
 
-	movem.l			pascalRegs, -(sp)		; save all regs that pascal callers need saved	<SM4>pdw
-	pea				restorePascalRegs		; and get in the chain to restore them later	<SM4>pdw
+	movem.l			interruptRegs, -(sp)	; save all regs that callers need saved
+	pea				restoreInterruptRegs	; and get in the chain to restore them later
 
 contDeskThread:
 	moveq.l			#desktopQType, d2		; our queue type/refnum
-	MACHINE			mc68020
-	move.l			a4,-(sp)				; save a4 <SM3> CSS
-	bigjsr			GetQMRecPtr,a4			; a1 = ptr(QMRec) <SM3> CSS
-	move.l			(sp)+,a4				; recover a4 <SM3> CSS
+	bsr				GetQMRecPtr
 	movea.l			QMRec.curStack(a1), a6	; restore alt stack pointer
 	adda.w			#Lsize, a6				; clear off the locals
 	movem.l			(a6)+, BottleNeckRegs	; restore desktop thread registers
@@ -563,8 +338,8 @@ contAppThread:
 											; continue without saving registers
 	rts										; return async time to application
 
-restorePascalRegs:							;												<SM4>pdw
-	movem.l			(sp)+, pascalRegs		; restore the regs that we saved last time through
+restoreInterruptRegs:
+	movem.l			(sp)+, interruptRegs	; restore the regs that we saved last time through
 	rts										; back to the app thread
 
 	_DTDebugTail	'Completion',0
@@ -760,7 +535,7 @@ DTDone:	proc
 ;
 ;________________________________________________________________________________
 DTVolExtFSCheck:	proc
-		jsrROM	DTRMV3   						; Excuse me, Mr. FS, please find us a volume
+		jsrROM	ROMDTRMV3						; Excuse me, Mr. FS, please find us a volume
 		bne.s	@LocalErr						; early trouble is a sign to leave
 
 		tst.w	vcbFSID(a2)						; is this a local volume?
@@ -775,10 +550,10 @@ DTVolExtFSCheck:	proc
 		bne.s	@ExternalExit					; if not, just let'em have the call
 
 @GrabAnFCB:
-		jsrROM	GT1STFCB   						; get (A1,D1) pointing to first FCB
+		jsrROM	ROMGT1STFCB						; get (A1,D1) pointing to first FCB
 @1		tst.l	FCBFlNm(a1,d1)					; FCB unused?
 		beq.s	@GotFCB							; br if so
-		jsrROM	GTNXTFCB   						; get next one until we run out
+		jsrROM	ROMGTNXTFCB						; get next one until we run out
 		bcs.s	@1
 
 		moveq.l	#TMFOErr,d0 					; too many files open
@@ -793,7 +568,7 @@ DTVolExtFSCheck:	proc
 
 @LocalErr:
 		tst.l	(sp)+							; discard the return address to DTMgr caller
-		jmpROM	CMDDONE   						; leave through the file system
+		jmpROM	ROMCMDDONE						; leave through the file system
 
 @LocalVolume:
 		move.l	FSVarsPtr, a3					; a3 = ptr(file system global area)
@@ -840,7 +615,7 @@ DTRfnExtFSCheck:	proc
 
 @LocalErr:
 		tst.l	(sp)+							; discard the return address to DTMgr caller
-		jmpROM	CMDDONE   						; leave through the file system
+		jmpROM	ROMCMDDONE						; leave through the file system
 
 @LocalVolume:
 		rts										; this call is for us
@@ -1313,7 +1088,7 @@ FindDTRegs	reg			d4/a0/a2/a3
 	move.w	d3,ioVRefNum(a0)			; vRef of volume to look at
 	clr.w	ioVolIndex(a0)				; no indexing; use VRef only
 	go_HGetVInfo
-	bne 	Error						; punt on errors <SM2> CSS
+	bne.s	Error						; punt on errors
 	
 	move.w	bigPB+ioVAtrb(a6), d0		; get the volume attributes
 	btst.l	#15, d0						; software locked?
@@ -1800,7 +1575,7 @@ SetFileAttribs:	proc
 ;				False = were just created
 ;________________________________________________________________________________
 DTOpenInform:		proc export
-				jsrROM		FSQUEUESYNC   		; just to check for external file systems
+				jsrROM		ROMFSQUEUESYNC		; just to check for external file systems
 				bsr			DTVolExtFSCheck		; find the right volume and hope it's ours
 				bsr			DeskMgrQueue
 				bsr			RealOpenDT			; d1 true/false for dtExisted
@@ -1823,7 +1598,7 @@ DTOpenInform:		proc export
 ;				open for the specified volume, return its refNum.
 ;________________________________________________________________________________
 DTGetPath:		proc export
-				jsrROM		FSQUEUESYNC   		; just to check for external file systems
+				jsrROM		ROMFSQUEUESYNC		; just to check for external file systems
 				bsr			DTVolExtFSCheck		; find the right volume and hope it's ours
 				bsr			DeskMgrQueue
 				bsr			RealOpenDT
@@ -1878,7 +1653,7 @@ LSize			equ			*-bigPB
 				endr
 
 @DTCloseDownRegs	reg			a0-a4/d1-d2
-	jsrROM		FSQUEUESYNC   					; just to check for external file systems
+	jsrROM		ROMFSQUEUESYNC					; just to check for external file systems
 	bsr			DTRfnExtFSCheck					; find the right volume and hope it's ours
 	bsr			DeskMgrQueue
 
@@ -1924,7 +1699,7 @@ DTAddIcon:		proc export
 	StandardLocals	AddIconLocals, IconDRec		; normal locals w/icon sized data rec
 
 @AddIconRegs		reg		a0-a4/d1-d2	; set of regs to save around AddIcon
-	jsrROM	FSQUEUE   					; just to check for external file systems
+	jsrROM	ROMFSQUEUE					; just to check for external file systems
 	bsr		DTRfnExtFSCheck				; find the right volume and hope it's ours
 	bsr 	DeskMgrQueue 				; Wait our turn.
 
@@ -2051,7 +1826,7 @@ DTGetIcon:	proc export
 	StandardLocals	GetIconLocals, IconDRec
 
 @GetIconRegs		reg		a0-a4/d1-d2				; set of regs to save around AddIcon
-	jsrROM	FSQUEUE   								; just to check for external file systems
+	jsrROM	ROMFSQUEUE								; just to check for external file systems
 	bsr		DTRfnExtFSCheck							; find the right volume and hope it's ours
 	bsr 	DeskMgrQueue 							; Wait our turn.
 
@@ -2122,7 +1897,7 @@ DTGetIconInfo:	proc export
 	StandardLocals	GetIconInfoLocals, IconDRec
 
 @GetIconInfoRegs		reg		a0-a4/d1-d2					; set of regs to save around this call
-	jsrROM	FSQUEUE   					; just to check for external file systems
+	jsrROM	ROMFSQUEUE					; just to check for external file systems
 	bsr		DTRfnExtFSCheck				; find the right volume and hope it's ours
 	bsr 	DeskMgrQueue 				; Wait our turn
 
@@ -2472,7 +2247,7 @@ AddAPPLCallback:	proc
 DTAddAPPL:		proc export
 
 @AddAPPLRegs		reg		a0-a4/d1-d2			; set of regs to save around this call
-	jsrROM	FSQUEUE   							; just to check for external file systems
+	jsrROM	ROMFSQUEUE							; just to check for external file systems
 	bsr		DTRfnExtFSCheck						; find the right volume and hope it's ours
 	bsr		DeskMgrQueue 						; Wait our turn
 
@@ -2696,7 +2471,7 @@ RemoveAPPLCallback:	proc
 DTRemoveAPPL:		proc export
 @RemoveAPPLRegs		reg			a0-a4/d1-d2
 
-	jsrROM	FSQUEUE   							; just to check for external file systems
+	jsrROM	ROMFSQUEUE							; just to check for external file systems
 	bsr		DTRfnExtFSCheck						; find the right volume and hope it's ours
 	bsr		DeskMgrQueue						; wait our turn
 
@@ -2792,7 +2567,7 @@ DTGetAPPL:		proc export
 	StandardLocals	GetAPPLLocals, APPLRec
 
 @GetAPPLRegs		reg		a0-a4/d1-d2		; set of regs to save around GetAPPL
-	jsrROM	FSQUEUE   						; just to check for external file systems
+	jsrROM	ROMFSQUEUE						; just to check for external file systems
 	bsr		DTRfnExtFSCheck					; find the right volume and hope it's ours
 	bsr 	DeskMgrQueue 					; Wait our turn
 
@@ -2881,7 +2656,7 @@ DTSetComment:		proc export
 	StandardLocals	SetCommentLocals, CommentRec
 
 @SetCommentRegs		reg		a0-a4/d1-d2		; set of regs to save around SetComment
-	jsrROM	FSQUEUE   						; just to check for external file systems
+	jsrROM	ROMFSQUEUE						; just to check for external file systems
 	bsr		DTRfnExtFSCheck					; find the right volume and hope it's ours
 	bsr	 	DeskMgrQueue 					; Wait our turn
 
@@ -2945,7 +2720,7 @@ DTGetComment:		proc export
 	StandardLocals	GetCommentLocals, CommentRec
 
 @GetCommentRegs		reg		a0-a4/d1-d2			; set of regs to save around GetComment
-	jsrROM	FSQUEUE   						; just to check for external file systems
+	jsrROM	ROMFSQUEUE						; just to check for external file systems
 	bsr		DTRfnExtFSCheck					; find the right volume and hope it's ours
 	bsr 	DeskMgrQueue 					; Wait our turn
 
@@ -3008,7 +2783,7 @@ DTRemoveComment:		proc export
 	StandardLocals	RemoveCommentLocals, 0		; we only need a pb and a key here. Zero Data
 
 @RemoveCommentRegs		reg		a0-a4/d1-d2			; set of regs to save around RmvCmt
-	jsrROM	FSQUEUE   						; just to check for external file systems
+	jsrROM	ROMFSQUEUE						; just to check for external file systems
 	bsr		DTRfnExtFSCheck					; find the right volume and hope it's ours
 	bsr 	DeskMgrQueue 					; Wait our turn
 
@@ -3056,7 +2831,7 @@ LSize		equ			*-bigPB
 			endr
 
 @DTFlushRegs	reg		a0/a3-a4
-	jsrROM		FSQUEUE   					; just to check for external file systems
+	jsrROM		ROMFSQUEUE					; just to check for external file systems
 	bsr			DTRfnExtFSCheck				; find the right volume and hope it's ours
 	bsr			DeskMgrQueue				; wait our turn
 
@@ -3108,7 +2883,7 @@ LSize		equ			*-bigPB
 			endr
 
 @DTResetRegs	reg		a0-a4/d1-d2
-	jsrROM		FSQUEUE   					; just to check for external file systems
+	jsrROM		ROMFSQUEUE					; just to check for external file systems
 	bsr			DTRfnExtFSCheck				; find the right volume and hope it's ours
 	bsr			DeskMgrQueue				; wait our turn
 
@@ -3224,7 +2999,7 @@ LSize		equ			*-bigPB
 
 @DTDeleteRegs	reg		a0-a4/d1-d2
 
-	jsrROM		FSQUEUE   					; just to check for external file systems
+	jsrROM		ROMFSQUEUE					; just to check for external file systems
 	bsr			DTVolExtFSCheck				; find the right volume and hope it's ours
 	bsr			DeskMgrQueue				; wait our turn
 
@@ -3299,7 +3074,7 @@ LSize		equ			*-bigPB
 			endr
 
 @DTGetInfoRegs	reg		a0-a4/d1-d2
-	jsrROM		FSQUEUE   					; just to check for external file systems
+	jsrROM		ROMFSQUEUE					; just to check for external file systems
 	bsr			DTRfnExtFSCheck				; find the right volume and hope it's ours
 	bsr			DeskMgrQueue				; wait our turn
 
diff --git a/OS/HFS/Extensions/ExternalMakeFSSpec.a b/OS/HFS/Extensions/ExternalMakeFSSpec.a
--- a/OS/HFS/Extensions/ExternalMakeFSSpec.a
+++ b/OS/HFS/Extensions/ExternalMakeFSSpec.a
@@ -16,10 +16,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM3>	  6/9/93	pdw		Changed register saving from interruptRegs to pascalRegs in
-;									myCompletionRoutine because it can be called from pascal (as it
-;									is when FileShare is running).  Fixes a FileShare crash that
-;									appears when doing async I/O.
 ;		 <4>	 9/13/91	JSM		Cleanup header.
 ;		 <3>	 3/17/91	dnf		ppd, #dnf-0013: Use the result code from ioResult(a0) instead of
 ;									from d0 to be extra-clean on async calls.
@@ -115,8 +111,8 @@ myCompletionRoutine:
 	movea.l			(sp)+, a6				; restore a6			
 	beq.s			anRTSInstruction		; if we haven't returned from the trap, rts to driver
 
-	movem.l			pascalRegs, -(sp)		; save all regs that pascal callers need saved	<LW2>pdw
-	pea				restorePascalRegs		; and get in the chain to restore them later	<LW2>pdw
+	movem.l			interruptRegs, -(sp)	; save all regs that pascal callers need saved
+	pea				restoreInterruptRegs	; and get in the chain to restore them later
 				
 myContCompatThread:
 	move.w			#fsCompatQType, d2		; our queue type/refnum
@@ -136,8 +132,8 @@ myContAppThread:
 											; continue without saving registers
 	rts										; return async time to application
 
-restorePascalRegs:							;												<LW2>pdw
-	movem.l			(sp)+, pascalRegs		; restore the regs that we saved last time through
+restoreInterruptRegs:
+	movem.l			(sp)+, interruptRegs	; restore the regs that we saved last time through
 	rts										; back to the app thread
 	endproc
 
diff --git a/OS/HFS/Extensions/FileIDs.a b/OS/HFS/Extensions/FileIDs.a
--- a/OS/HFS/Extensions/FileIDs.a
+++ b/OS/HFS/Extensions/FileIDs.a
@@ -18,8 +18,6 @@
 ;									<14> 4/4/92	gs Fixed bug# 1021960 : BNE.S should be to @Exit1, NOT @Exit after
 ;									the JSRs to DtrmV3 and ExtOffLinCk. 'bugz' bit
 ;									gestaltResolveFileIDRefFix should be set when this is fixed.
-;	   <SM1>	 4/15/92	kc		Removed the "ROM" prefix from the RomBind routines.
-;									• Pre-SuperMario comments follow •
 ;		<13>	 9/13/91	JSM		Cleanup header.
 ;		<12>	 4/16/91	KST		bb and dnf, #KSCT20: Fixing a bug in ExchangeFile which leaves
 ;									cache buffers in an inconsistent state.
@@ -115,30 +113,30 @@ FileIDs		PROC	EXPORT
 ;_______________________________________________________________________
 
 CreateFileIDRef:
-			jsrROM  FSQUEUE   			; first wait our turn
+			jsrROM  ROMFSQUEUE			; first wait our turn
 
-			jsrROM 	FNDFILNAME   		; parse pathname(IN: A0=prmblk OUT: D0=err D2.L=namLen D6=dirID
+			jsrROM 	ROMFNDFILNAME		; parse pathname(IN: A0=prmblk OUT: D0=err D2.L=namLen D6=dirID
 										;  D7=cathint A1=volBuffer A2=vcb A3=WDCB A4=cname A5=fileDirEntry)
 			BNE.S	@Exit
 
-			jsrROM	EXTOFFLINCK   		; is the volume online and used by us (not ExtFS)? (IN: A2=vcb OUT: D0=err)
+			jsrROM	ROMEXTOFFLINCK		; is the volume online and used by us (not ExtFS)? (IN: A2=vcb OUT: D0=err)
 			BNE.S	@Exit
 
-			jsrROM	TFSVCBTST   		; it better be an HFS volume (IN: A2=vcb)
+			jsrROM	ROMTFSVCBTST		; it better be an HFS volume (IN: A2=vcb)
 			BNE.S	@NotHFSErr
 
 			MOVEA.L A0, A3				; sure paramblock ptr for later
-			jsrROM 	PUSHCNAME   		; Put name on A6 stack (IN: A4=name D2.W=len OUT: A0=name D2=len)
+			jsrROM 	ROMPUSHCNAME		; Put name on A6 stack (IN: A4=name D2.W=len OUT: A0=name D2=len)
 			MOVE.W	D2,-(A6)			; Save rounded source name length
 
-			jsrROM	CVFLGS   			; is the volume writable? (IN: A2=vcb OUT: D0=err)
+			jsrROM	ROMCVFLGS			; is the volume writable? (IN: A2=vcb OUT: D0=err)
 			BEQ.S	@DoCreate
 
 			MOVE.W	D0, D7				; save the error
 			MOVE.L	D6, D0				; dirID or parent dirID
 			JSR		FIDGetID			; get the ID (IN: A0=cname D0=dirID A2=vcb OUT: D0=err D1=fthd)
 			MOVE.W	(A6)+,D2			; Recover rounded source length
-			jsrROM 	POPCNAME   			; Remove dest. name string (IN: A6=string D2=rndLen OUT: D2=len)
+			jsrROM 	ROMPOPCNAME			; Remove dest. name string (IN: A6=string D2=rndLen OUT: D2=len)
 			MOVE.L	D1, ioFileID(A3) 	; set the fileID back in the paramblock ptr
 			TST.W	D0
 			BEQ.S	@existsErr			; the fileID exists on the locked volume
@@ -150,7 +148,7 @@ CreateFileIDRef:
 @DoCreate	MOVE.L	D6, D0				; dirID or parent dirID
 			JSR		FIDCreateID			; and do it (IN: A0=cname D0=dirID A2=vcb OUT: D0=err D1=fthd)
 			MOVE.W	(A6)+,D2			; Recover rounded source length
-			jsrROM 	POPCNAME   			; Remove dest. name string (IN: A6=string D2=rndLen OUT: D2=len)
+			jsrROM 	ROMPOPCNAME			; Remove dest. name string (IN: A6=string D2=rndLen OUT: D2=len)
 			MOVE.L	D1, ioFileID(A3) 	; set the fileID back in the paramblock ptr
 			TST.W	D0
 			BEQ.S	@Exit				; no errors, get out
@@ -169,7 +167,7 @@ CreateFileIDRef:
 			BRA.S	@Exit
 @NotHFSErr	MOVEQ	#wrgVolTypErr, D0
 
-@Exit		jmpROM	CMDDONE   				; will also put the D0 result in ioResult(A0)
+@Exit		jmpROM	ROMCMDDONE				; will also put the D0 result in ioResult(A0)
 
 
 ;_______________________________________________________________________
@@ -188,17 +186,17 @@ CreateFileIDRef:
 
 DeleteFileIDRef:
 
-			jsrROM 	FSQUEUE   			; first wait our turn
+			jsrROM 	ROMFSQUEUE			; first wait our turn
 
-			jsrROM 	DTRMV3   			; get the vcb by vrefnum or name(IN: A0=prmblk OUT:A2=vcb D0=err)
+			jsrROM 	ROMDTRMV3			; get the vcb by vrefnum or name(IN: A0=prmblk OUT:A2=vcb D0=err)
 			BNE.S	@Exit				;   D2=nameLen? D3=volName? A3=WDCB A4=pathName)
 
-			jsrROM	CVFLGS   			; is the volume writable? (IN: A2=vcb OUT: D0=err)
+			jsrROM	ROMCVFLGS			; is the volume writable? (IN: A2=vcb OUT: D0=err)
 			BNE.S	@Exit
-			jsrROM	EXTOFFLINCK   		; is the volume online and used by us (notExtFS)? (IN: A2=vcb OUT: D0=err)
+			jsrROM	ROMEXTOFFLINCK		; is the volume online and used by us (notExtFS)? (IN: A2=vcb OUT: D0=err)
 			BNE.S	@Exit
 
-			jsrROM	TFSVCBTST   		; it better be an HFS volume (IN: A2=vcb)
+			jsrROM	ROMTFSVCBTST		; it better be an HFS volume (IN: A2=vcb)
 			BNE.S	@NotHFSErr
 
 			MOVE.L	ioFileID(A0), D0	; file id
@@ -219,7 +217,7 @@ DeleteFileIDRef:
 			BRA.S	@Exit
 @NotHFSErr	MOVEQ	#wrgVolTypErr, D0
 
-@Exit		jmpROM	CMDDONE   			; will also put the D0 result in ioResult(A0)
+@Exit		jmpROM	ROMCMDDONE			; will also put the D0 result in ioResult(A0)
 
 ;_______________________________________________________________________
 ;
@@ -237,14 +235,14 @@ DeleteFileIDRef:
 
 ResolveFileIDRef:
 
-			jsrROM 	FSQUEUE   			; first wait our turn
+			jsrROM 	ROMFSQUEUE			; first wait our turn
 
-			jsrROM 	DTRMV3   			; get the vcb by vrefnum or name (IN: A0=prmblk OUT:A2=vcb D0=err)
+			jsrROM 	ROMDTRMV3			; get the vcb by vrefnum or name (IN: A0=prmblk OUT:A2=vcb D0=err)
 			BNE.S	@Exit1				; <SM2> CSS   D2=nameLen? D3=volName? A3=WDCB A4=pathName?)
-			jsrROM	EXTOFFLINCK   		; is the volume online and used by us (notExtFS)? (IN: A2=vcb OUT: D0=err)
+			jsrROM	ROMEXTOFFLINCK		; is the volume online and used by us (notExtFS)? (IN: A2=vcb OUT: D0=err)
 			BNE.S	@Exit1				; <SM2> CSS
 
-			jsrROM	TFSVCBTST   		; it better be an HFS volume (IN: A2=vcb)
+			jsrROM	ROMTFSVCBTST		; it better be an HFS volume (IN: A2=vcb)
 			BNE.S	@NotHFSErr
 
 			MOVEA.L	A0, A3				; save paramblock ptr for later
@@ -265,7 +263,7 @@ ResolveFileIDRef:
 			BRA		@Exit1
 
 @Exit		MOVE.L	D1, ioSrcDirID(A3)	; put it back in paramblock
-@Exit1		jmpROM	CMDDONE   			; will also put the D0 result in ioResult(A0)
+@Exit1		jmpROM	ROMCMDDONE			; will also put the D0 result in ioResult(A0)
 
 ;_______________________________________________________________________
 ;
@@ -289,9 +287,9 @@ PBHExchangeFiles:
 ;	A2 = vcb, A3 = destName, A4 = cmvars/scratch, A5 = srcName
 ;	D2 = srcCatHint, D3 = destCatHint, D4 = destFileNum, D5 = srcFileNum, D6 = destDirID, D7 = srcDirID
 
-			jsrROM 	FSQUEUE   			; first wait our turn
+			jsrROM 	ROMFSQUEUE			; first wait our turn
 
-			jsrROM 	FNDFILNAME   		; parse pathname(IN: A0=prmblk OUT: D0=err D2.L=namLen D6=dirID
+			jsrROM 	ROMFNDFILNAME		; parse pathname(IN: A0=prmblk OUT: D0=err D2.L=namLen D6=dirID
 			BNE		@Exit				;  D7=cathint A1=volBuffer A2=vcb A3=WDCB A4=cname A5=fileDirEntry)
 			MOVE.L	D6, D1				; save src dirID for later
 			MOVE.L	D2, D5				; save the rounded source name length for later
@@ -302,7 +300,7 @@ PBHExchangeFiles:
 			move.l	ioSrcDirID(a0), -(a6)		; save caller's ioSrcDirID value		<bb/dnf 8>
 			MOVE.L	ioDestNamePtr(A0), ioFileName(A0)
 			MOVE.L	ioDestDirID(A0), ioSrcDirID(A0)
-			jsrROM 	FNDFILNAME   		; parse pathname(IN: A0=prmblk OUT: D0=err D2.L=namLen D6=dirID
+			jsrROM 	ROMFNDFILNAME		; parse pathname(IN: A0=prmblk OUT: D0=err D2.L=namLen D6=dirID
 										;  D7=cathint A1=volBuffer A2=vcb A3=WDCB A4=cname A5=fileDirEntry)
 			move.l	(a6)+, ioSrcDirID(a0)		; restore caller's ioSrcDirID value		<bb/dnf 8>
 			move.l	(a6)+, ioFileName(a0)		; restore caller's ioFileName value		<dd/dnf 8>
@@ -314,22 +312,22 @@ PBHExchangeFiles:
 			CMP.L	A2, A3				; better be the same volumes if specified by pathnames
 			BNE		@difVolErr
 
-			jsrROM	CVFLGS   			; is the volume writable? (IN: A2=vcb OUT: D0=err)
+			jsrROM	ROMCVFLGS			; is the volume writable? (IN: A2=vcb OUT: D0=err)
 			BNE		@PopAndErr			; no ->
-			jsrROM	EXTOFFLINCK   		; is the volume online and used by us (notExtFS)? (IN: A2=vcb OUT: D0=err)
+			jsrROM	ROMEXTOFFLINCK		; is the volume online and used by us (notExtFS)? (IN: A2=vcb OUT: D0=err)
 			BNE		@PopAndErr
-			jsrROM	TFSVCBTST   		; and it better be an HFS volume (IN: A2=vcb)
+			jsrROM	ROMTFSVCBTST		; and it better be an HFS volume (IN: A2=vcb)
 			BNE		@NotHFSErr
 
 ; set up the names properly
 
 			MOVE.L	(A6)+, A5			; get the src name off the A6 stack before it changes
-			jsrROM  PUSHCNAME   		; Put dest name on A6 stack (IN: A4=name D2.W=len OUT: A0=name D2=len)
+			jsrROM  ROMPUSHCNAME		; Put dest name on A6 stack (IN: A4=name D2.W=len OUT: A0=name D2=len)
 			MOVE.L	A0, A3				; save the dest name
 			MOVE.L	A5, A4				; get the src name
 			MOVE.L	D2,-(A6)			; Save dest rounded name length
 			MOVE.L	D5, D2				; get the src name length
-			jsrROM 	PUSHCNAME   		; Put src name on A6 stack (IN: A4=name D2.W=len OUT: A0=name D2=len)
+			jsrROM 	ROMPUSHCNAME		; Put src name on A6 stack (IN: A4=name D2.W=len OUT: A0=name D2=len)
 			MOVE.L	D2,-(A6)			; Save rounded name length
 
 ; grab the File ID numbers to use later for fcb searching on open files
@@ -340,7 +338,7 @@ PBHExchangeFiles:
 			MOVEA.L	A0, A5				; keep the src name
 			MOVE.L	D7,	D0			    ; set the src dir ID
 			MOVEQ	#0, D2				; no cat hint
-			jsrROM	LOCCREC   			; search the catalog (IN: A2=vcb A4=cmvars A0=name D0=dirID D2=catHInt
+			jsrROM	ROMLOCCREC			; search the catalog (IN: A2=vcb A4=cmvars A0=name D0=dirID D2=catHInt
 			BNE		@ExchErr			;   OUT: D0=err D1=size D2=catHint A0=ckr A1=cdr)
 			MOVE.L	D2, D4				; save the src cat hint
 		    MOVE.L	filFlNum(A1), D5	; save src file ID
@@ -348,7 +346,7 @@ PBHExchangeFiles:
 			MOVEA.L	A3, A0				; set the dest name
 			MOVE.L	D6, D0				; set the dest dir ID
 			MOVEQ	#0, D2				; no cat hint
-			jsrROM	LOCCREC   			; search the catalog (IN: A2=vcb A4=cmvars A0=name D0=dirID D2=catHInt
+			jsrROM	ROMLOCCREC			; search the catalog (IN: A2=vcb A4=cmvars A0=name D0=dirID D2=catHInt
 			BNE		@ExchErr			;   OUT: D0=err D1=size D2=catHint A0=ckr A1=cdr)
 			MOVE.L	D2, D3				; save the dest cat hint
 
@@ -370,7 +368,7 @@ PBHExchangeFiles:
 
 ; FINE TUNING: Flag if either file is open. THEN after FidExchangeFiles, if none, skip fcb walking.
 
-			jsrROM	GT1STFCB   			; get the first fcb (uses A1, D1)
+			jsrROM	ROMGT1STFCB			; get the first fcb (uses A1, D1)
 @loop		CMP.L	fcbVPtr(A1, D1), A2	; better be correct volume
 			BNE.S	@nxtFCB
 			CMP.L	fcbFlNm(A1, D1), D5
@@ -390,10 +388,10 @@ PBHExchangeFiles:
 										; update the file number in the buffer header after the exchange
 			MOVE.L	VCBBufAdr(A2), A1
 			ST		CacheFlag		 	; really flush
-			jsrROM	FLUSHCACHE   		; release the buffers to free buffer pool
+			jsrROM	ROMFLUSHCACHE		; release the buffers to free buffer pool
 			movem.L	(a6)+, a1/d1		; restore refnum and FCBSPtr after flush	<dnf 5>
 
-@nxtFCB		jsrROM	GTNXTFCB   
+@nxtFCB		jsrROM	ROMGTNXTFCB
 			BCS.S	@loop 				; loop thru them all
 
 ; we are almost ready to roll...FINALLY!...
@@ -419,7 +417,7 @@ PBHExchangeFiles:
 
 ; exchange fcb info (file number, file name, and file parID only!)
 
-			jsrROM	GT1STFCB   			; get the first fcb (uses A1, D1)
+			jsrROM	ROMGT1STFCB			; get the first fcb (uses A1, D1)
 @loop1		CMP.L	fcbVPtr(A1, D1), A2	; better be correct volume
 			BNE.S	@nxtFCB1
 			CMP.L	fcbFlNm(A1, D1), D5
@@ -455,7 +453,7 @@ PBHExchangeFiles:
 			MOVEA.L A4, A1				; Restore A1
 
 
-@nxtFCB1	jsrROM	GTNXTFCB   
+@nxtFCB1	jsrROM	ROMGTNXTFCB
 			BCS.S	@loop1 				; loop thru them all
 
 			BRA.S	@PopAndExit
@@ -480,11 +478,11 @@ PBHExchangeFiles:
 
 @PopAndExit	ADD		#lenCMVars, A6		; get the temp storage back needed by LocCRec
 			MOVE.L	(A6)+,D2			; Recover rounded length
-			jsrROM 	POPCNAME   			; Remove src name string (IN: A6=string D2=rndLen OUT: D2=len)
+			jsrROM 	ROMPOPCNAME			; Remove src name string (IN: A6=string D2=rndLen OUT: D2=len)
 			MOVE.L	(A6)+,D2			; Recover rounded length
-			jsrROM 	POPCNAME   			; Remove dest name string (IN: A6=string D2=rndLen OUT: D2=len)
+			jsrROM 	ROMPOPCNAME			; Remove dest name string (IN: A6=string D2=rndLen OUT: D2=len)
 
-@Exit		jmpROM	CMDDONE   			; will also put the D0 result in ioResult(A0)
+@Exit		jmpROM	ROMCMDDONE			; will also put the D0 result in ioResult(A0)
 
 
 
diff --git a/OS/HFS/Extensions/FileIDsSvcs.a b/OS/HFS/Extensions/FileIDsSvcs.a
--- a/OS/HFS/Extensions/FileIDsSvcs.a
+++ b/OS/HFS/Extensions/FileIDsSvcs.a
@@ -15,8 +15,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM1>	 4/15/92	kc		Removed the "ROM" prefix from the RomBind routines.
-;									• Pre-SuperMario comments follow •
 ;		<13>	 9/13/91	JSM		Cleanup header.
 ;		<12>	 3/30/91	KST		bb, #83912: Fixing a bug in ExchangeFile which uses a signed
 ;									branch on an unsigned comparison (in CheckExtents).
@@ -141,14 +139,14 @@ FIDCreateID:
 			MOVEM.L	FIDCrRegs, -(A6)	; save registers
 			MOVE.L	D0,D6				; save the par ID
 			MOVEA.L	A0,A3				; save the cname ptr
-			jsrROM 	CMSETUP   			; set up key storage pointed to by A4
+			jsrROM 	ROMCMSETUP			; set up key storage pointed to by A4
 			MOVEQ	#0,D5				; clear fileID, in case we return early due to errors
 			CLR.L	VCBDirIDM(A2)		; invalidate current DirID marker
 ;				
 ; locate the file record
 ;
 			MOVEQ 	#0,D2				; no catalog hint
-			jsrROM 	LOCCREC   			
+			jsrROM 	ROMLOCCREC			
 			BNE		@CrExit				; it's not there, just exit with what's in D0
 			CMPI.B	#cdrFilRec, cdrType(A1); better be a file (type=2)
 			BNE.S	@CrNotAFileErr
@@ -161,7 +159,7 @@ FIDCreateID:
 			MOVE.L	D0,D5				; keep fileID for later
 			SUBA.L	A0,A0				; use NULL for fthread key name
 			LEA 	ckrOff(A4), A1		; use this storage for the fthread key
-			jsrROM 	BUILDKEY   			; fill in the key
+			jsrROM 	ROMBUILDKEY			; fill in the key
 ;
 ; and do the data of the file thread 
 ;			
@@ -176,7 +174,7 @@ FIDCreateID:
 			
 			MOVEA.L	A3, A0				; the cname ptr
 			LEA		thdCName(A1), A1
-			jsrROM 	UPDCNAME   			
+			jsrROM 	ROMUPDCNAME			
 ;
 ; Insert the file thread in the catalog btree
 ;
@@ -184,7 +182,7 @@ FIDCreateID:
 			MOVE.W	#lenthd, D1			
 			LEA		cdrOff(A4), A1
 			LEA		ckrOff(A4), A0
-			jsrROM 	BTINSERT   
+			jsrROM 	ROMBTINSERT
 			BNE.S	@CrBTErr			; could be disk full, so stop
 ;
 ; finally, turn on thread flag in file CNode. Too bad, gotta find it again
@@ -192,16 +190,16 @@ FIDCreateID:
 			MOVE.L	D4, D2				; use saved cat hint
 			MOVE.L	D6, D0				; dirID or parent dirID
 			MOVEA.L	A3, A0				; CName pointer
-			jsrROM 	LOCCREC   			; we know it's there
+			jsrROM 	ROMLOCCREC			; we know it's there
 			BSET	#fThreadFlag,FilFlags(A1); set the flag
 			
 			MOVE.W	VCBCtRef(A2),D0		; refnum of catalog file
-			jsrROM 	BTUPDATE   			
+			jsrROM 	ROMBTUPDATE			
 			BNE.S	@CRExit				; if there was an error, catalog could be shot!
 ;
 ; get it out to disk 
 ;
-			jsrROm	CMFLUSH   			; flush the catalog
+			jsrROm	ROMCMFLUSH			; flush the catalog
 			BRA.S	@CrExit
 ;
 ; handle errors			
@@ -217,7 +215,7 @@ FIDCreateID:
 			MOVE.L	D5,D0				; file number								<11Jan91 #10>
 			SUBA.L	A0,A0				; no Cname									<11Jan91 #10>
 			MOVEQ	#0,D2				; no hint									<11Jan91 #10>
-			jsrROM	LOCCREC   			; locate thread record						<11Jan91 #10>
+			jsrROM	ROMLOCCREC			; locate thread record						<11Jan91 #10>
 			BNE.S	@7					; bad time for error						<11Jan91 #10>
 		
 			CMP.B	#cdrfThdRec,cdrType(A1) ; file thread type?						<11Jan91 #10>
@@ -247,9 +245,9 @@ FIDCreateID:
 @5			TST.W	D3					; have we changed the file?					<11Jan91 #10>
 			BNE.S	@7					; no										<11Jan91 #10>
 @6			MOVE.W	VCBCtRef(A2),D0		; refnum of catalog file (input = D0/D2)	<11Jan91 #10>
-			jsrROM 	BTUPDATE   			; mark the node (D2) dirty					<11Jan91 #10>
+			jsrROM 	ROMBTUPDATE			; mark the node (D2) dirty					<11Jan91 #10>
 			BNE.S	@CrExit				; bad time for error						<11Jan91 #10>
-			jsrROm	CMFLUSH   			; flush the catalog	(input = A2)			<11Jan91 #10>
+			jsrROm	ROMCMFLUSH			; flush the catalog	(input = A2)			<11Jan91 #10>
 			BNE.S	@CrExit				; bad time for error						<11Jan91 #10>
 
 @7			MOVE.W	#CMExists,D0		; Translate error "CMExists = cnode already there"
@@ -270,7 +268,7 @@ FIDCreateID:
 ;			A3 = user's file name
 ; Output:	BEQ if 2 names are the same
 			LEA		thdCName(A1), A1
-			jsrROM 	UPDCNAME   	
+			jsrROM 	ROMUPDCNAME	
 
 
 ;_________________________________________________________________________________
@@ -299,7 +297,7 @@ FIDDeleteID:
 ;
 			MOVE.L	(SP)+,-(A6)			; save return address on A6 stack
 			MOVEM.L	FIDDelRegs,-(A6)	; save registers
-			jsrROM  CMSETUP   			; set up key storage pointed to by A4
+			jsrROM  ROMCMSETUP			; set up key storage pointed to by A4
 			MOVE.L	D0, D5				; save fileID
 			MOVEQ	#0, D7				; save error in here, if CNode for file is missing
 			CLR.L	VCBDirIDM(A2)		; invalidate current DirID marker
@@ -308,7 +306,7 @@ FIDDeleteID:
 ;
 			MOVEQ 	#0, D2				; no catalog hint
 			SUBA.L	A0, A0				; use NULL for fthread key. 
-			jsrROM 	LOCCREC   			
+			jsrROM 	ROMLOCCREC			
 			BNE.S	@DlNoThdErr			; it's not there
 			CMPI.B	#cdrFThdRec, cdrType(A1); better be a file
 			BNE.S   @DlNotAFileErr
@@ -318,7 +316,7 @@ FIDDeleteID:
 			MOVEQ	#0, D2				; no catalog hint 
 			MOVE.L	thdParID(A1), D0	; get file's dir id from fthread data
 			LEA		thdCName(A1), A0	; and it's name
-			jsrROM 	LOCCREC   	
+			jsrROM 	ROMLOCCREC	
 			BEQ.S	@DlUnsetFlg
 			MOVE.W	D0, D7				; need to return the error later
 			BNE.S	@DlDelThd			; whoops, it's not there...well, delete the thread
@@ -329,7 +327,7 @@ FIDDeleteID:
 ;
 @DlUnsetFlg	BCLR	#fThreadFlag,FilFlags(A1) 
 			MOVE.W	VCBCtRef(A2), D0	; refnum of catalog file
-			jsrROM 	BTUPDATE   			; tell the btree
+			jsrROM 	ROMBTUPDATE			; tell the btree
 			BNE.S	@DlExit				; if there's an error, the catalog could be shot!
 ;
 ; Delete the file thread in the catalog btree
@@ -337,17 +335,17 @@ FIDDeleteID:
 @DlDelThd	MOVE.L  D5, D0				; file id
 			SUBA.L	A0,A0				; use NULL for fthread key			
 			LEA		ckrOff(A4), A1 		; use this storage for fthread key
-			jsrROM 	BUILDKEY   			; fill in the key
+			jsrROM 	ROMBUILDKEY			; fill in the key
 			
 			LEA		ckrOff(A4), A0 	; get the storage again
 			MOVE.W	VCBCtRef(A2), D0	; refnum of catalog file
-			jsrROM 	BTDELETE   			; delete file thread
+			jsrROM 	ROMBTDELETE			; delete file thread
 			BNE.S	@DlExit				; we know it exists, so must be IOError...
 										; ...Oh well, leave the cnode's fthread flag off.					
 ;
 ; get it out to disk. 
 ;
-			jsrROM 	CMFLUSH   			; flush the catalog
+			jsrROM 	ROMCMFLUSH			; flush the catalog
 			MOVE.W	D7, D0				; should be clear, unless file CNode was missing
 			BRA.S	@DlExit
 ;
@@ -397,14 +395,14 @@ FIDGetID:
 ;
 			MOVE.L	(SP)+,-(A6)			; save return address on A6 stack
 			MOVEM.L	FIDGtRegs, -(A6)	; save registers
-			jsrROM 	CMSETUP   			; set up key storage pointed to by A4
+			jsrROM 	ROMCMSETUP			; set up key storage pointed to by A4
 			MOVEQ	#0,	D5				; clear fileID, in case we return early due to errors
 			CLR.L	VCBDirIDM(A2)		; invalidate current DirID marker
 ;				
 ; locate the file record
 ;
 			MOVEQ 	#0, D2				; no catalog hint
-			jsrROM 	LOCCREC   			
+			jsrROM 	ROMLOCCREC			
 			BNE		@GtExit				; it's not there, just exit with what's in D0
 			CMPI.B	#cdrFilRec, cdrType(A1); better be a file
 			BNE.S	@GtNotAFileErr
@@ -462,7 +460,7 @@ FIDResolveID:
 			MOVE.L	(SP)+,-(A6)			; save return address on A6 stack
 			MOVEM.L	FIDResRegs,-(A6)	; save registers
 			MOVE.L	D0,D3				; save fileID
-			jsrROM 	CMSETUP   			; set up key record and data storage
+			jsrROM 	ROMCMSETUP			; set up key record and data storage
 			MOVEA.L A0, A3				; save cName ptr
 			CLR.L	VCBDirIDM(A2)		; invalidate current DirID marker
 ;					
@@ -470,7 +468,7 @@ FIDResolveID:
 ;
 		;;	MOVEQ 	#0, D2				; no catalog hint					<23Aug90>
 			SUBA.L	A0, A0				; use NULL for file name. 
-			jsrROM 	LOCCREC   			
+			jsrROM 	ROMLOCCREC			
 			BNE.S	@RsExit				; it's not there, pass error on up
 			CMPI.B	#cdrFThdRec, cdrType(A1); better be a file
 			BNE.S   @RsNotAFileErr
@@ -480,7 +478,7 @@ FIDResolveID:
 			LEA		thdCName(A1), A0	; and it's name
 			MOVEM.L	D0/D2/A0,-(A6)		; save dirID/hint/name				<23Aug90>
 			MOVEQ 	#0, D2				; no catalog hint					<23Aug90>
-			jsrROM 	LOCCREC   			; does the file exist?				<23Aug90>
+			jsrROM 	ROMLOCCREC			; does the file exist?				<23Aug90>
 			MOVEM.L	(A6)+,D1/D2/A0		; restore dirID/hint/name			<23Aug90>
 			BNE.S	@dangling			; it's not there					<23Aug90>
 
@@ -489,7 +487,7 @@ FIDResolveID:
 			BNE.S	@dangling			; it's not							<21Sep90>
 		
 			MOVEA.L A3, A1				; the cname ptr
-			jsrROM 	UPDCNAME   		
+			jsrROM 	ROMUPDCNAME		
 			MOVEQ	#0, D0				; to be safe
 ;
 ; cleanup and exit
@@ -509,19 +507,19 @@ FIDResolveID:
 @dangling
 		;; This is a dangling fID, if the volume is writable,				<24Aug90>
 		;; then delete the thread record in the catalog btree.				<23Aug90>
-		;	jsrROM	CVFLGS   			; is VOL writable? (IN: A2=vcb)		<24Aug90>
+		;	jsrROM	ROMCVFLGS			; is VOL writable? (IN: A2=vcb)		<24Aug90>
 		;	BNE.S	@2					; no, don't bother with delete		<24Aug90>
 			
 		;	MOVE.L  D3,D0				; file id							<23Aug90>
 		;	SUBA.L	A0,A0				; use NULL for fthread key			<23Aug90>
 		;	LEA		ckrOff(A4), A1 		; use this storage for fthread key	<23Aug90>
-		;	jsrROM 	BUILDKEY   			; fill in the key					<23Aug90>
+		;	jsrROM 	ROMBUILDKEY			; fill in the key					<23Aug90>
 			
 		;	LEA		ckrOff(A4),A0 		; get the storage again				<23Aug90>
 		;	MOVE.W	VCBCtRef(A2),D0		; refnum of catalog file			<23Aug90>
-		;	jsrROM 	BTDELETE   			; delete file thread				<23Aug90>
+		;	jsrROM 	ROMBTDELETE			; delete file thread				<23Aug90>
 		;	BNE.S	@2					; this must be IOError or VolLocked	<23Aug90>
-		;	jsrROM 	CMFLUSH   			; flush the catalog					<23Aug90>
+		;	jsrROM 	ROMCMFLUSH			; flush the catalog					<23Aug90>
 
 		;; Now we just return an error, we don't delete the Fid.			<21Sep90>
 @2			MOVE.W	#badFidErr,D0		; treat it as fidNotFound error		<21Sep90>
@@ -577,7 +575,7 @@ FIDExchangeFiles:
 ; locate the source file, test for extents in extent file, and copy the cat record for later
 ;
 			CLR.W	extFlgsOff(A4)		; assume no extents in extents file
-			jsrROM 	LOCCREC   			; A0, D0, D2 already set up from input
+			jsrROM 	ROMLOCCREC			; A0, D0, D2 already set up from input
 			BNE		@ExExit				; either CNode not there or io error
 			CMPI.B	#cdrFilRec, cdrType(A1); better be a file
 			BNE		@ExNotAFileErr
@@ -608,7 +606,7 @@ FIDExchangeFiles:
 			MOVE.L	D7, D2				; catalog hint
 			MOVE.L	destDIDOff(A4), D0	; it's dir id
 			MOVEA.L	A3, A0				; it's name
-			jsrROM 	LOCCREC   			; keep the cat hint in D2 for the BTUpdate later
+			jsrROM 	ROMLOCCREC			; keep the cat hint in D2 for the BTUpdate later
 			BNE		@ExExit				; either CNode not there or io error (callee knows it's there!)
 			CMPI.B	#cdrFilRec, cdrType(A1); better be a file
 			BNE		@ExNotAFileErr
@@ -689,14 +687,14 @@ FIDExchangeFiles:
 @ExGetOut	MOVE.L	D6, D2				; catalog hint
 			MOVEA.L	A5,A0				; it's name
 			MOVE.L	srcDIDOff(A4), D0	; it's dir id
-			jsrROM 	LOCCREC   				
+			jsrROM 	ROMLOCCREC				
 			BNE		@ExBusted	 
 			
 			LEA		destCNode(A4), A0 	; from saved dest (A0) to memory src (A1)
 			BSR		CopyCNodeInfo
 			
 			MOVE.W	VCBCtRef(A2), D0
-			jsrROM 	BTUPDATE   			; tell the btree
+			jsrROM 	ROMBTUPDATE			; tell the btree
 			BNE		@ExExit				; if there's an error, the catalog could be shot!
 
 ;
@@ -705,14 +703,14 @@ FIDExchangeFiles:
 			MOVE.L	D7, D2				; catalog hint
 			MOVEA.L	A3, A0				; it's name
 			MOVE.L	destDIDOff(A4), D0	; it's dir id
-			jsrROM 	LOCCREC   			; keep cat hint in D2 for the BTUpdate later
+			jsrROM 	ROMLOCCREC			; keep cat hint in D2 for the BTUpdate later
 			BNE		@ExBusted
 			
 			LEA		srcCNode(A4), A0 	; from saved src (A0) to memory dest (A1)
 			BSR		CopyCNodeInfo
 			
 			MOVE.W	VCBCtRef(A2), D0
-			jsrROM	BTUPDATE   			; tell the btree
+			jsrROM	ROMBTUPDATE			; tell the btree
 			BNE		@ExExit				; if there's an error, the catalog could be shot!
 			BRA.S   @ExFinishUp
 			
@@ -757,8 +755,8 @@ FIDExchangeFiles:
 ; STEP 5: ALL DONE....ALMOST...
 ;
 @ExFinishErr	
-			jsrROM	CMFLUSH   			; flush the catalog
-			jsrROM 	XFFLUSH   			; flush the extent file (unneeded for common case, but it's cheap)			
+			jsrROM	ROMCMFLUSH			; flush the catalog
+			jsrROM 	ROMXFFLUSH			; flush the extent file (unneeded for common case, but it's cheap)			
 			MOVE.W	#dskFulErr, D0		; well, report the original error even if the flushes croaked.
 			BRA.S	@ExExit
 @ExNotAFileErr
@@ -771,8 +769,8 @@ FIDExchangeFiles:
 ;
 @ExFinishUp
 			MOVEQ	#0, D0				; no errors....yet...
-			jsrROM 	CMFLUSH   			; flush the catalog
-			jsrROM 	XFFLUSH   			; flush the extent file (unneeded for common case, but it's cheap)	
+			jsrROM 	ROMCMFLUSH			; flush the catalog
+			jsrROM 	ROMXFFLUSH			; flush the extent file (unneeded for common case, but it's cheap)	
 @ExExit		ADD 	#lenFIDSwapVars,A6	; de-allocate memory for CM vars
 			MOVEM.L (A6)+, FIDExchRegs	; restore regs
 
@@ -932,18 +930,18 @@ DeleteExts:
 @DXNxtDelete 
 			MOVEQ	#0, D2				; no hint (after BTDelete)			<09Aug90>
 			MOVE.W	VCBXTRef(A2), D0	; extents file refnum
-			jsrROM 	BTSEARCH   			; search BTree for extent record
+			jsrROM 	ROMBTSEARCH			; search BTree for extent record
 			CMP.W	#BTNotFound, D0
 			BNE.S	@DXExit				; has to be an ioerror!
 			MOVEQ	#0,	D1				; get what it's pointing at
 			MOVE.W	VCBXTRef(A2), D0	; extents file refnum
-			jsrROM	BTGETRECORD   		; this is the first record we want for this file
+			jsrROM	ROMBTGETRECORD		; this is the first record we want for this file
 			BNE.S	@DXBtErr
 			CMP.L	xkrFNum(A0), D6
 			BNE.S	@DXExit				; Yippie!!! We're done!
 			
 			MOVE.W	VCBXTRef(A2), D0	; extent file's refnum
-			jsrROM 	BTDELETE   			; and delete from btree (AO has key)
+			jsrROM 	ROMBTDELETE			; and delete from btree (AO has key)
 			BNE.S	@DXExit
 			
 			LEA		tempKeyOff(A4), A0	; look again
@@ -1010,7 +1008,7 @@ extSize		EQU		lenxkr+lenxdr
 
 @MvNextBatch MOVE.W	VCBXTRef(A2), D0	; extents file refnum
 			MOVEQ	#0, D2				; no hint
-			jsrROM	BTSEARCH   			; search BTree for extent record. 
+			jsrROM	ROMBTSEARCH			; search BTree for extent record. 
 			CMP.W	#BtNotFound, D0		; it won't exist the first time thru the loop
 			BEQ.S	@MvGoOn
 			TST.W	D0
@@ -1022,7 +1020,7 @@ extSize		EQU		lenxkr+lenxdr
 			LEA		extOff(A4), A3 		; extent ptr
 			
 @MvNextRec	MOVE.W	VCBXTRef(A2), D0	; extents file refnum
-			jsrROM	BTGETRECORD   		; this is the first record we want for this file
+			jsrROM	ROMBTGETRECORD		; this is the first record we want for this file
 			CMP.W	#BtNotFound, D0		; if xkrFNum(A0) is cleared on this error, then this test is bogus!
 			BEQ.S	@MvNoMoreExts
 			TST.W	D0
@@ -1050,7 +1048,7 @@ extSize		EQU		lenxkr+lenxdr
 			MOVEQ	#lenxdr, D1			; data length 
 @2			MOVE.L	D7, xkrFNum(A0)		; change only the id in the key to dest ID
 			MOVE.W	VCBXTRef(A2), D0	; extent file's refnum
-			jsrROM 	BTINSERT    		; insert in btree
+			jsrROM 	ROMBTINSERT 		; insert in btree
 			BNE.S	@MvBTInsertErr
 			ADDA.W	#extSize, A0
 			ADDA.W	#extSize, A1
diff --git a/OS/HFS/Extensions/MakeFSSpec.a b/OS/HFS/Extensions/MakeFSSpec.a
--- a/OS/HFS/Extensions/MakeFSSpec.a
+++ b/OS/HFS/Extensions/MakeFSSpec.a
@@ -9,11 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 11/7/93	pdw		ConsultCatalog was assuming totally synchronous behavior (i.e.
-;									it was using the A7 stack instead of A6).  Changed register
-;									saving and return address handling to use HFS stack.
-;	   <SM1>	 4/15/92	kc		Removed the "ROM" prefix from the RomBind routines.
-;									• Pre-SuperMario comments follow •
 ;		<12>	  1/6/91	dnf		(fjs) Add code to check for terminating ::'s on pathname
 ;									parsing.
 ;		<11>	 9/22/90	dnf		Add ExtOffLinCheck
@@ -106,8 +101,7 @@ CopyCName:		proc
 ConsultCatalog:	proc
 ConsultCatalogRegs	reg		d2/a0/a1/a4
 
-	move.l		(SP)+,-(A6) 			; save return address on A6 stack		<SM2> pdw
-	movem.l		ConsultCatalogRegs,-(A6)	;									<SM2> pdw
+	movem.l		ConsultCatalogRegs,-(sp)
 	lea.l		FSSpec.name(a3), a0		; a0 = ptr(CName)
 	tst.b		(a0)					; zero length name?
 	bne.s		@NotZeroLength
@@ -116,7 +110,7 @@ ConsultCatalogRegs	reg		d2/a0/a1/a4
 @NotZeroLength:	
 	move.l		FSSpec.parID(a3), d0	; move parID to input reg for GetCN
 	move.l		d7, d2					; move catalog hint to input reg for CMGetCN
-	jsrROM		CMGETCN   				; go consult with the expert
+	jsrROM		ROMCMGETCN				; go consult with the expert
 	bne.s		@Exit					; errors are good cause to leave
 	
 	move.l		ckrParID(a0), FSSpec.parID(a3)	; set parID for directory name case
@@ -128,9 +122,8 @@ ConsultCatalogRegs	reg		d2/a0/a1/a4
 	
 @Exit:
 	move.l		d2, d7					; restore catalog hint
-	movem.l		(A6)+, ConsultCatalogRegs	;									<SM2> pdw
-	move.l		(A6)+,-(SP) 			; Restore the return address			<SM2> pdw
 	tst.w		d0						; set condition codes
+	movem.l		(sp)+, ConsultCatalogRegs
 	rts
 	endproc
 	
@@ -193,20 +186,20 @@ ConsultCatalogRegs	reg		d2/a0/a1/a4
 ;_______________________________________________________________________
 MakeFSSpec:	proc		export
 
-	jsrROM		FSQUEUE   
+	jsrROM		ROMFSQUEUE
 
-	jsrROM		DTRMV3   				; get at least the volume
+	jsrROM		ROMDTRMV3				; get at least the volume
 	bne			@Exit
 
 	moveq.l		#wrgVolTypErr, d0		; assume the worst
-	jsrROM		TFSVCBTST   			; split HFS/MFS volumes
+	jsrROM		ROMTFSVCBTST			; split HFS/MFS volumes
 	bne			@Exit					; go handle MFS in the compatibility layer
 
 	moveq.l		#0, d6					; no input dirID
 	move.l		d6, d7					; no catalog hint
 	
 	bset.b		#SkipPMSP,HFSFlags		; Don't bother with PMSP for this operation
-	jsrROM		FNDFILNAME   			; parse things up
+	jsrROM		ROMFNDFILNAME			; parse things up
 
 ; After FndFilName, registers are:
 ;	a2 - vcb ptr
@@ -322,7 +315,7 @@ MakeFSSpec:	proc		export
 	clr.l		(a1)+					; clear the volume & high word of directory
 	clr.l		(a1)+					; clear the directory & length byte of string
 @1:
-	jmpROM		CMDDONE   
+	jmpROM		ROMCMDDONE
 
 	endproc
 	end
diff --git a/OS/HFS/FileMgrHooks.a b/OS/HFS/FileMgrHooks.a
--- a/OS/HFS/FileMgrHooks.a
+++ b/OS/HFS/FileMgrHooks.a
@@ -704,7 +704,7 @@ ProcessMgrExists	proc	export
 
 TagFileWithPSN
 ; Open traps can be (and are!) called before Process Mgr is init'd
-			bsr		ProcessMgrExists	; is Process Mgr ready?
+			;bsr		ProcessMgrExists	; is Process Mgr ready?
 			bne.s	@CantRecord			; Process Mgr is not ready yet
 
 ; find the current PSN
diff --git a/OS/HFS/FileMgrPatches.a b/OS/HFS/FileMgrPatches.a
--- a/OS/HFS/FileMgrPatches.a
+++ b/OS/HFS/FileMgrPatches.a
@@ -7,9 +7,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM1>	 4/15/92	kc		Removed the "ROM" prefix from the RomBind routines.
-;									Added comments to all of the patches that were rolled in.
-;									• Pre-SuperMario comments follow •
 ;		<56>	 3/18/92	gs		rolled in Disappearing Folder Fix from Presto (patch to CMSetup)
 ;									Pete said it was Okay. No, Really, he did!
 ;		<55>	11/25/91	DTY		Make a new call, GetParallelFCBFromRefNum, and give it selector
@@ -274,48 +271,48 @@ BuildHFS70Init	default		0
 
 romAfterExtFSHook	ROMBind (Plus,$029f2), (SE,$04434), (II,$07edc), (IIci,$0f0e0), (Portable, $096e0)
 romBTFlush		ROMBind	(Plus,$068c2), (SE,$08398), (II,$0be5c), (IIci,$13242), (Portable, $0d802)
-BUILDKEY   		ROMBind	(Plus,$065d8), (SE,$080a0), (II,$0BB64), (IIci,$12f40), (Portable, $0d50a)
-BTDELETE   		ROMBind	(Plus,$0671c), (SE,$081e6), (II,$0bcaa), (IIci,$13090), (Portable, $0d650)
-BTGETRECORD   	ROMBind	(Plus,$06928), (SE,$083fc), (II,$0bec0), (IIci,$132A6), (Portable, $0d866)
-BTINSERT   		ROMBind	(Plus,$069ea), (SE,$084b4), (II,$0bf78), (IIci,$1335E), (Portable, $0d91e)
-BTSEARCH   		ROMBind	(Plus,$06d4a), (SE,$0880c), (II,$0c2d0), (IIci,$136B6), (Portable, $0dc76)
-BTUPDATE   		ROMBind	(Plus,$06dd6), (SE,$08896), (II,$0c35a), (IIci,$13740), (Portable, $0dd00)
-CACHERDIP   	ROMBind	(Plus,$07b2a), (SE,$0967e), (II,$0d13e), (IIci,$1459C), (Portable, $0eb44)
+ROMBUILDKEY		ROMBind	(Plus,$065d8), (SE,$080a0), (II,$0BB64), (IIci,$12f40), (Portable, $0d50a)
+ROMBTDELETE		ROMBind	(Plus,$0671c), (SE,$081e6), (II,$0bcaa), (IIci,$13090), (Portable, $0d650)
+ROMBTGETRECORD	ROMBind	(Plus,$06928), (SE,$083fc), (II,$0bec0), (IIci,$132A6), (Portable, $0d866)
+ROMBTINSERT		ROMBind	(Plus,$069ea), (SE,$084b4), (II,$0bf78), (IIci,$1335E), (Portable, $0d91e)
+ROMBTSEARCH		ROMBind	(Plus,$06d4a), (SE,$0880c), (II,$0c2d0), (IIci,$136B6), (Portable, $0dc76)
+ROMBTUPDATE		ROMBind	(Plus,$06dd6), (SE,$08896), (II,$0c35a), (IIci,$13740), (Portable, $0dd00)
+ROMCACHERDIP	ROMBind	(Plus,$07b2a), (SE,$0967e), (II,$0d13e), (IIci,$1459C), (Portable, $0eb44)
 romChgMFlLock	ROMBind	(Plus,$046de), (SE,$06812), (II,$0a2e8), (IIci,$11694), (Portable, $0bc7c)
-CHKNODE   		ROMBind	(Plus,$072c2), (SE,$08e22), (II,$0c8e6), (IIci,$13D42), (Portable, $0e2ec)
+ROMCHKNODE		ROMBind	(Plus,$072c2), (SE,$08e22), (II,$0c8e6), (IIci,$13D42), (Portable, $0e2ec)
 romCkExtFS		ROMBind	(Plus,$03638), (SE,$050be), (II,$08b80), (IIci,$0fefa), (Portable, $0a4e2)
 romCkFilMod		ROMBind	(Plus,$0497a), (SE,$06420), (II,$09eec), (IIci,$11298), (Portable, $0b880)
-CMDDONE   		ROMBind	(Plus,$0295e), (SE,$043a0), (II,$07e48), (IIci,$0f04c), (Portable, $0964c)
-CMFLUSH   		ROMBind	(Plus,$06606), (SE,$080ce), (II,$0BB92), (IIci,$12f6e), (Portable, $0d538)
-CMGETCN   		ROMBind	(Plus,$06238), (SE,$07d04), (II,$0b7c8), (IIci,$12ba2), (Portable, $0d16e)
-CMSETUP   		ROMBind	(Plus,$065a0), (SE,$08068), (II,$0bb2c), (IIci,$12f06), (Portable, $0d4d2)
+ROMCMDDONE		ROMBind	(Plus,$0295e), (SE,$043a0), (II,$07e48), (IIci,$0f04c), (Portable, $0964c)
+ROMCMFLUSH		ROMBind	(Plus,$06606), (SE,$080ce), (II,$0BB92), (IIci,$12f6e), (Portable, $0d538)
+ROMCMGETCN		ROMBind	(Plus,$06238), (SE,$07d04), (II,$0b7c8), (IIci,$12ba2), (Portable, $0d16e)
+ROMCMSETUP		ROMBind	(Plus,$065a0), (SE,$08068), (II,$0bb2c), (IIci,$12f06), (Portable, $0d4d2)
 romCMUpdateCN	ROMBind	(Plus,$0656c), (SE,$08036), (II,$0bafa), (IIci,$12ed4), (Portable, $0d4a0)
-CVFLGS   		ROMBind	(Plus,$03a76), (SE,$05502), (II,$08FCA), (IIci,$10344), (Portable, $0a92c)
+ROMCVFLGS		ROMBind	(Plus,$03a76), (SE,$05502), (II,$08FCA), (IIci,$10344), (Portable, $0a92c)
 romDtrmV1		ROMBind	(Plus,$03650), (SE,$050e2), (II,$08ba4), (IIci,$0ff1e), (Portable, $0a50c)
-DTRMV3   		ROMBind	(Plus,$03642), (SE,$050ce), (II,$08b90), (IIci,$0ff0a), (Portable, $0a4f8)
-EXTOFFLINCK   	ROMBind	(Plus,$04aba), (SE,$06560), (II,$0A02C), (IIci,$113d8), (Portable, $0b9c0)
+ROMDTRMV3		ROMBind	(Plus,$03642), (SE,$050ce), (II,$08b90), (IIci,$0ff0a), (Portable, $0a4f8)
+ROMEXTOFFLINCK	ROMBind	(Plus,$04aba), (SE,$06560), (II,$0A02C), (IIci,$113d8), (Portable, $0b9c0)
 romFindDrive	ROMBind	(Plus,$03414), (SE,$04e9A), (II,$08956), (IIci,$0FC6C), (Portable, $0A258)
-FNDFILNAME   	ROMBind	(Plus,$04990), (SE,$06436), (II,$09f02), (IIci,$112ae), (Portable, $0b896)
+ROMFNDFILNAME	ROMBind	(Plus,$04990), (SE,$06436), (II,$09f02), (IIci,$112ae), (Portable, $0b896)
 romFSAsync		ROMBind	(Plus,$02912), (SE,$04354), (II,$07dfc), (IIci,$0f000), (Portable, $09600)
-FSQUEUESYNC   	ROMBind	(Plus,$028a6), (SE,$042e8), (II,$07d90), (IIci,$0ef94), (Portable, $09594)
-FSQUEUE   		ROMBind	(Plus,$028aa), (SE,$042ec), (II,$07d94), (IIci,$0ef98), (Portable, $09598)
+ROMFSQUEUESYNC	ROMBind	(Plus,$028a6), (SE,$042e8), (II,$07d90), (IIci,$0ef94), (Portable, $09594)
+ROMFSQUEUE		ROMBind	(Plus,$028aa), (SE,$042ec), (II,$07d94), (IIci,$0ef98), (Portable, $09598)
 romGt1stMatch	ROMBind	(Plus,$04002), (SE,$05a9c), (II,$0955c), (IIci,$108d6), (Portable, $0aebe)
 romLocCNode		ROMBind	(Plus,$06678), (SE,$0813e), (II,$0BC02), (IIci,$12FDE), (Portable, $0d5a8)
-LOCCREC   		ROMBind	(Plus,$06698), (SE,$0815e), (II,$0bc22), (IIci,$12FFE), (Portable, $0d5c8)
-LOCREC   		ROMBind	(Plus,$07538), (SE,$0908c), (II,$0cb50), (IIci,$13FAC), (Portable, $0e556)
+ROMLOCCREC		ROMBind	(Plus,$06698), (SE,$0815e), (II,$0bc22), (IIci,$12FFE), (Portable, $0d5c8)
+ROMLOCREC		ROMBind	(Plus,$07538), (SE,$0908c), (II,$0cb50), (IIci,$13FAC), (Portable, $0e556)
 romMarkVCB		ROMBind	(Plus,$02d1e), (SE,$04766), (II,$0820e), (IIci,$0F524), (Portable, $09b10)
 romMarkVCBTime	ROMBind	(Plus,$02d20), (SE,$04768), (II,$08210), (IIci,$0F526), (Portable, $09b12)
-POPCNAME   		ROMBind	(Plus,$04288), (SE,$05d28), (II,$097EA), (IIci,$10b96), (Portable, $0b17e)
-PUSHCNAME   	ROMBind	(Plus,$04258), (SE,$05cf8), (II,$097BA), (IIci,$10b66), (Portable, $0b14e)
+ROMPOPCNAME		ROMBind	(Plus,$04288), (SE,$05d28), (II,$097EA), (IIci,$10b96), (Portable, $0b17e)
+ROMPUSHCNAME	ROMBind	(Plus,$04258), (SE,$05cf8), (II,$097BA), (IIci,$10b66), (Portable, $0b14e)
 romRfnCall		ROMBind	(Plus,$05352), (SE,$06e04), (II,$0a8c8), (IIci,$11C86), (Portable, $0c26e)
-TFSVCBTST   	ROMBind	(Plus,$04ec6), (SE,$06968), (II,$0a43e), (IIci,$117ea), (Portable, $0bdd2)
-UPDCNAME   		ROMBind	(Plus,$066c2), (SE,$0818c), (II,$0BC50), (IIci,$1302C), (Portable, $0d5f6)
+ROMTFSVCBTST	ROMBind	(Plus,$04ec6), (SE,$06968), (II,$0a43e), (IIci,$117ea), (Portable, $0bdd2)
+ROMUPDCNAME		ROMBind	(Plus,$066c2), (SE,$0818c), (II,$0BC50), (IIci,$1302C), (Portable, $0d5f6)
 romUpdRtCnts	ROMBind	(Plus,$065be), (SE,$08086), (II,$0BB4A), (IIci,$12f24), (Portable, $0d4f0)
 romUpdVCnts		ROMBind	(Plus,$065ae), (SE,$08076), (II,$0BB3A), (IIci,$12f14), (Portable, $0d4e0)
-XFFLUSH   		ROMBind	(Plus,$05ed0), (SE,$0799a), (II,$0B45E), (IIci,$1282a), (Portable, $0ce04)
-GT1STFCB   		ROMBind	(Plus,$03ff2), (SE,$05a8c), (II,$0954c), (IIci,$108c6), (Portable, $0aeae)
-GTNXTFCB   		ROMBind	(Plus,$03ffa), (SE,$05a94), (II,$09554), (IIci,$108ce), (Portable, $0aeb6)
-FLUSHCACHE   	ROMBind	(Plus,$076c6), (SE,$0921a), (II,$0ccdc), (IIci,$1413a), (Portable, $0e6e2)
+ROMXFFLUSH		ROMBind	(Plus,$05ed0), (SE,$0799a), (II,$0B45E), (IIci,$1282a), (Portable, $0ce04)
+ROMGT1STFCB		ROMBind	(Plus,$03ff2), (SE,$05a8c), (II,$0954c), (IIci,$108c6), (Portable, $0aeae)
+ROMGTNXTFCB		ROMBind	(Plus,$03ffa), (SE,$05a94), (II,$09554), (IIci,$108ce), (Portable, $0aeb6)
+ROMFLUSHCACHE	ROMBind	(Plus,$076c6), (SE,$0921a), (II,$0ccdc), (IIci,$1413a), (Portable, $0e6e2)
 
 ; The following addresses are needed for ROM B*Tree writecount patch:			<2.3 kst>
 romBuildIRec	ROMBind	(Plus,$072a0), (SE,$08E00), (II,$0C8C4), (IIci,$13D20), (Portable,$0E2CA)
@@ -581,8 +578,8 @@ A60DispTbl:	proc
 ;________________________________________________________________________________
 ; This routine was rolled into into the file TFS.a.						<SM1>
 VolumeCall:	proc
-			jsrROM	FSQUEUE   			; Patiently wait our turn
-            jsrROM	DTRMV3              ; Determine the volume being referred to
+			jsrROM	ROMFSQUEUE			; Patiently wait our turn
+            jsrROM	ROMDTRMV3           ; Determine the volume being referred to
 			bne		ToCmdDone			; Punt at the slightest hint of trouble
 
 			move.l	a2,ReqstVol         ; Point to the volume being referred to
@@ -602,7 +599,7 @@ VolumeCall:	proc
 			entry	RefNumCall
 RefNumCall:
 			import	RefNumCheck
-			jsrROM	FSQUEUE   			; chill in line
+			jsrROM	ROMFSQUEUE			; chill in line
             move.w  ioRefNum(a0),d0		; Pick up the refNum
             jsr		RefNumCheck			; Check the refNum supplied
             bne		ToCmdDone			; Punt at first hint of trouble
@@ -629,7 +626,7 @@ RefNumCall:
 ; This routine was rolled into into the file TFS.a.						<SM1>
 			entry	UnknownCall
 UnknownCall:
-			jsrROM	FSQUEUE   			; Wait our turn
+			jsrROM	ROMFSQUEUE			; Wait our turn
 ; <REALLY Fudge ReqsVol here later...>
 			movea.l	VCBQHdr+qHead, a2	; Pick up pointer to first VCB
 			move.l	a2, ReqstVol		; Point someplace semi-innocuous
@@ -649,8 +646,8 @@ UnknownCall:
 			entry	OpenCall
 OpenCall:
 			import	OpenAttemptHook
-			jsrROM	FSQUEUE   			; Wait our turn
-            jsrROM  DTRMV3              ; Determine the volume being referred to
+			jsrROM	ROMFSQUEUE			; Wait our turn
+            jsrROM  ROMDTRMV3           ; Determine the volume being referred to
             bne.s	ToCmdDone			; Punt at the slightest hint of trouble
 
 			move.l	a2,ReqstVol         ; Point to the volume being referred to
@@ -658,10 +655,10 @@ OpenCall:
 			beq.s	ParamErrExit		; It's an unknown trap for a local volume
 
 			bsr		OpenAttemptHook		; let ourselves know we're trying				<38>
-			jsrROM	GT1STFCB   			; get (A1,D1) pointing to first FCB
+			jsrROM	ROMGT1STFCB			; get (A1,D1) pointing to first FCB
 @1			tst.l	FCBFlNm(a1,d1)		; FCB unused
 			beq.s	@90					; br if so
-			jsrROM	GTNXTFCB   			; get next one until we run out
+			jsrROM	ROMGTNXTFCB			; get next one until we run out
 			bcs.s	@1
 
 			moveq.l	#TMFOErr,d0 		; too many files open
@@ -678,7 +675,7 @@ ParamErrExit:
 			moveq.l	#paramErr, d0		; It's an unknown trap for a local volume
 
 ToCmdDone:
-			jmpROM	CMDDONE             ; And call it a day.
+			jmpROM	ROMCMDDONE          ; And call it a day.
 
 			endproc
 
@@ -771,17 +768,17 @@ OpenDF:		proc
 SetFilLock:	proc	export
 			export	RstFilLock
 
-			JSRRom 	FSQUEUE    			; wait our turn
+			JSRRom 	ROMFSQUEUE 			; wait our turn
 			ST		FLckUnlck			; want to lock it
 			BRA.S	SRFLck
 
 RstFilLock:
-			jsrROM 	FSQUEUE   
+			jsrROM 	ROMFSQUEUE
 			CLR.B	FLckUnlck
 
 SRFLck		jsrROM 	romCkFilMod			; look for file and see if we can mod it
 										; (doesn't return on errors)
-			JSRROM 	TFSVCBTST   		; Are we dealing with a TFS volume? 	<01Oct85>
+			JSRROM 	ROMTFSVCBTST		; Are we dealing with a TFS volume? 	<01Oct85>
 			BNEROM 	romChgMFlLock		; Nope - do it the old fashioned way
 			MOVEQ	#FNFErr,D0			; Expect the worst
 			CMP.B	#cdrFilRec,cdrType(A5) ; Is this a file entry?
@@ -804,7 +801,7 @@ SRFLXit1	MOVE.L	D7,D2				; Get a hold of the catalog hint
 			BRA.S	SRFLXit3			; If EQ, we're all set.
 
 SRFLXit2	MOVEQ	#0,D0
-SRFLXit3	jmpROM 	CMDDONE   
+SRFLXit3	jmpROM 	ROMCMDDONE
 
 			endproc
 
@@ -823,7 +820,7 @@ GetParallelFCBFromRefnum	proc	export
 			import	ParallelFCBFromRefnum
 			import	RefNumCheck
 			
-			jsrROM 	FSQUEUE    			; wait our turn
+			jsrROM 	ROMFSQUEUE 			; wait our turn
 			
 			move.w	ioRefNum(a0),d0		; Get the file reference number
 			move.w	d0,d1				; Keep a copy in another register
@@ -835,7 +832,7 @@ GetParallelFCBFromRefnum	proc	export
 			move.l	a1,ioFDirIndex(a0)	; Return the pointer in ioMisc
 			moveq	#noErr,d0			; No error
 @exitGetParallelFCB
-			jmpROM	CMDDONE   			; outa here
+			jmpROM	ROMCMDDONE			; outa here
 			endproc
 
 ;________________________________________________________________________________
@@ -907,6 +904,8 @@ ClosePatch		PatchProc _Close
 			movem.l	@ClosePatchRegs,-(sp)		; save regs we use
 			movea.l	sp,a2						; for safe, quick stack pointer restore
 
+			bra.s	@DoClosePop
+
 ; check the refnum for validity. and locate the parallel FCB array element
 			move.w	ioRefNum(a0),d0				; get refnum being closed
 			bsr		RefNumCheck					; is it legit?
@@ -1063,7 +1062,7 @@ AccumulateDiskSwitchRectIntoUpdateRect comefrompatchproc _SetPort, DSExit
 ; Here we fix case 1 - rename of a volume. Fixed at the head of Rename:
 ; This patch was rolled into TFSDIR2.a											<SM1>
 FixVolumeRenames	PatchProc	_Rename
-		jsrROM	FSQUEUE    			; what a queue command!
+		jsrROM	ROMFSQUEUE 			; what a queue command!
 
 		move.l	ioNewName(a0),d2	; check out the new name
 		jsrROM	DtrmV2				; find what volume the new name is on
@@ -1079,7 +1078,7 @@ FixVolumeRenames	PatchProc	_Rename
 
 RNmVol:
 		cmp.w	#nsvErr,d0			; make sure it's no-such-vol error
-		bneROM	CMDDONE   
+		bneROM	ROMCMDDONE
 		tst.w	d2					; name length should be zero
 		bne.s	BadNewNam
 RNmVol1:
@@ -1088,25 +1087,25 @@ RNmVol1:
 		jmpROM	RNmVol1				; go let'em do it like they used to
 
 		tst.w   d3			        ; Volume name must have been specified
-		beqROM  CMDDONE   
-		jsrROM	DTRMV3   			; Check source volume
-		bneROM  CMDDONE   			; Punt if no such thing
-		jsrROM  CVFLGS   			; Can it be modified?
-		bneROM  CMDDONE   			; Nope - punt now.
-		jsrROM	TFSVCBTST   		; Is it a  TFS volume?
+		beqROM  ROMCMDDONE
+		jsrROM	ROMDTRMV3			; Check source volume
+		bneROM  ROMCMDDONE			; Punt if no such thing
+		jsrROM  ROMCVFLGS			; Can it be modified?
+		bneROM  ROMCMDDONE			; Nope - punt now.
+		jsrROM	ROMTFSVCBTST		; Is it a  TFS volume?
 		beq.s	@checkExtFS			; Yes - make sure it's not ext. FS
 		tst.w   vcbDrvNum(a2)       ; Volume on-line?
-		beqROM  CMDDONE   			; No - just forget it
+		beqROM  ROMCMDDONE			; No - just forget it
 		jmpROM  RNMVol@70			; Yes - go and rename it
 
 @checkExtFS:
-		jsrROM	EXTOFFLINCK         ; Our file system, on-line volume?
-        bneROM  CMDDONE      	    ; If not, get out now
+		jsrROM	ROMEXTOFFLINCK      ; Our file system, on-line volume?
+        bneROM  ROMCMDDONE   	    ; If not, get out now
 		jmpROM	RNMVol@70	        ; Otherwise, same as ever
 
 BadNewNam:
 		moveq.l	#bdNamErr,d0		; get the error code
-		jmpROM	CMDDONE   			; outa here
+		jmpROM	ROMCMDDONE			; outa here
 
 		endproc
 
@@ -1115,12 +1114,12 @@ BadNewNam:
 ; bugs where we formerly didn’t rename the root directory and allowed a '' name.
 
 SetVolInfoPatch	proc
-		jsrROM 	FSQUEUE   			; Wait our turn
+		jsrROM 	ROMFSQUEUE			; Wait our turn
 		jsrROM	romDtrmV1			; Determine volume by drvnum/refnum
 		bne		SVIDone				; Punt on errors
-		jsrROM	CVFLGS   			; Check if volume can be modified
+		jsrROM	ROMCVFLGS			; Check if volume can be modified
 		bne		SVIDone	 			; Give up easily
-		jsrROM	EXTOFFLINCK    		; Check if volume is on-line, non ext. FS
+		jsrROM	ROMEXTOFFLINCK 		; Check if volume is on-line, non ext. FS
 		bne		SVIDone	 			; Be a wimp - give up now.
 
 		move.l	ioVNPtr(a0),d2		; New name specified?
@@ -1166,7 +1165,7 @@ SetUserFields:
 
 		move.l	ioVNPtr(a0), d1				; grab ptr to caller's name
 
-		jsrROM	TFSVCBTST   				; Is it a  TFS volume?
+		jsrROM	ROMTFSVCBTST				; Is it a  TFS volume?
 		bne.s	@skipHFS					; br if not - MFS VCBs don't have this info
 		move.l	ioVClpSiz(a0),vcbClpSiz(a2) ; Volume clump size
 		move.l	ioVBkup(a0),vcbVolBkup(a2)	; Last backup date
@@ -1187,7 +1186,7 @@ SetUserFields:
 		move.b	d0, (a1)+					; jam our length byte
 		_BlockMove							; change the name
 
-		jsrROM  TFSVCBTST   				; Are we dealing with an MFS volume?
+		jsrROM  ROMTFSVCBTST				; Are we dealing with an MFS volume?
 		bne.s	@skipRootRename				; if so, no root to rename
 
 ; rename the root
@@ -1204,7 +1203,7 @@ SetUserFields:
 		moveq.l	#noErr,d0					; All went well...
 
 SVIDone:
-		jmpROM	CMDDONE   
+		jmpROM	ROMCMDDONE
 		endproc
 
 ;__________________________________________________________________________________
@@ -1301,12 +1300,12 @@ myCMSetUp	PatchProc		jCMSetup,(Plus,SE,II,IIci,Portable)
 @BugOut		; clean up A6 & A7 stacks and jump back to rom
 			addq.w	#4,A7									; remove return addr to Rename
 			move.l	(A6)+,D2								; recover rounded string length
-			jsrRom	POPCNAME   								; remove name from A6 stack
+			jsrRom	ROMPOPCNAME								; remove name from A6 stack
 			
 @RNmExit 	cmp.w	#BTExists,D0							; B*-Tree error?
 			bne.s	@FinalExit
 			moveq	#dupFNErr,D0							; If entry exists, give better error code
-@FinalExit	jmpRom	CMDDONE   								; and now back to our regularly scheduled broadcast...
+@FinalExit	jmpRom	ROMCMDDONE								; and now back to our regularly scheduled broadcast...
 
 
 ; CMSvcs calls "MarkVCBTime", which only set the mod time but doesn't mark VCB dirty.
@@ -1521,7 +1520,7 @@ dirCreateTrapWord	equ		selectDirCreate
 			suba.l	a0, a0				; go after the parent
 			move.l	(a6)+,d0			; retrieve target parent directory
 
-			jsrROM	LOCCREC   
+			jsrROM	ROMLOCCREC
 			bne.s	@dirNotFound
 			cmpi.b	#cdrThdRec,cdrType(a1) 	; is it a directory thread?
 			beq.s	@fileNotFound		; yes, so it was just the leaf that was missing
@@ -1664,7 +1663,7 @@ OpenAttemptHook:	proc
 ; This patch was rolled into TFSDIR1.a
 PreflightFileOpen	proc
 
-			jsrROM	FSQUEUE   						; serialize things
+			jsrROM	ROMFSQUEUE						; serialize things
 			bsr		OpenAttemptHook					; tell'em we're trying
 			ST		RegRsrc 						; open regular part of file		<39>
 			jmpROM	FOpen1
@@ -1685,7 +1684,7 @@ PreflightFileOpen	proc
 ; This patch was rolled into TFSDIR1.a
 PreflightOpenRF		PatchProc	_OpenRF
 
-			jsrROM	FSQUEUE   						; serialize things
+			jsrROM	ROMFSQUEUE						; serialize things
 			bsr		OpenAttemptHook					; tell'em we're trying
 			clr.b	RegRsrc 						; open resource part of file	<39>
 			jmpROM	FOpen1
@@ -1733,7 +1732,7 @@ PreflightOpenRF		PatchProc	_OpenRF
 AllocateFCBs	proc
 			import	MoreFCBs
 
-			jsrROM 	FSQUEUE    					; wait our turn
+			jsrROM 	ROMFSQUEUE 					; wait our turn
 
 			moveq.l	#-1,d0						; more FCBs than we'll ever have
 			bsr		CountFCBs					; count all of them
@@ -1757,7 +1756,7 @@ AllocateFCBs	proc
 			move.w	d3,d2						; otherwise, just grow as much as we can
 
 @grow:
-			bsr		MoreFCBs					; try to get the FCBs
+			jsr		MoreFCBs					; try to get the FCBs
 			beq.s	@gotSome					; leave with a smile
 
 			asr.w	#1,d2						; try to get half that many
@@ -1778,7 +1777,7 @@ AllocateFCBs	proc
 			beq.s	@noFCBsAvailable			; if none are left, report the problem
 			moveq.l	#noErr,d0					; if some are left, we're happy
 
-@exit:		jmpROM 	CMDDONE   
+@exit:		jmpROM 	ROMCMDDONE
 
 @noFCBsAvailable:
 			moveq.l	#tmfoErr,d0
@@ -1945,7 +1944,7 @@ FixDtrmV3:	PatchProc		jDtrmV3,(II,IIci,Portable)
 ; This patch was rolled into TFSVOL.a
 MountVolFor1991	PatchProc   _MountVol
 
-			jsrROM	FSQUEUESYNC   
+			jsrROM	ROMFSQUEUESYNC
 
 			movea.l	a0, a5					; save caller's pb
 			move.w	ioDrvNum(a5), d2		; where FindDrive likes it
@@ -2030,7 +2029,7 @@ Remount:
 			move.w	d2,vcbDrvNum(a2)		; drive number
 			move.w	d1,vcbDRefNum(a2)		; driver RefNum
 
-			jsrROM	TFSVCBTST   			; remounted a TFS volume?						<32>
+			jsrROM	ROMTFSVCBTST			; remounted a TFS volume?						<32>
 			bne.s	NoErrExit				; Nope - don't mess with the MDB				<33>
 			btst.b	#vcbWrProt,vcbAtrb+1(a2); Is volume write protected?					<32>
 			bne.s	NoErrExit				; If so, don't try to flush the MDB				<33>
@@ -2053,7 +2052,7 @@ EarlyExit:
 			btst.b	#fsNoAllocate, FSVars.fsFlags(a1)
 			beqROM	OldMtVolAfterFSQueue	; join the ROM (BTW, skipping the _Offline heroics)
 @1:
-			jmpROM	CMDDONE   
+			jmpROM	ROMCMDDONE
 			endproc
 
 ;_______________________________________________________________________
@@ -2076,18 +2075,18 @@ EarlyExit:
 ; These patches were rolled into TFSVOL.a
 NoCloseOnOffline	PatchProc	_Offline
 			import	OfflineEjectCommon
-			jsrROM	FSQUEUESYNC    			; wait until all current calls are done
+			jsrROM	ROMFSQUEUESYNC 			; wait until all current calls are done
 			st		NoEject 				; -1 = send offline but don't eject
 			jmp 	OfflineEjectCommon		; share code with Eject
 			endproc
 
 NoCloseOnEject		PatchProc	_Eject
 			export	OfflineEjectCommon
-			jsrROM	FSQUEUESYNC    			; wait until all current calls are done
+			jsrROM	ROMFSQUEUESYNC 			; wait until all current calls are done
 			clr.b	NoEject 				; 0 = offline + eject
 
 OfflineEjectCommon
-			jsrROM	DTRMV3   				; check name, drive number, etc.
+			jsrROM	ROMDTRMV3				; check name, drive number, etc.
 			bne.s	ejectNotMounted			; br if drive not mounted (why flush?)
 			jsrROM	romCkExtFS 				; see if it's for an external fs
 			bne.s	EjectDone				; exit if so
@@ -2103,7 +2102,7 @@ ejectDrvNum:
 			beqROM 	EjectIt 				; OK, OK; it's going already...
 
 ejectDone:
-			jmpROM	CMDDONE    				; we're done . . .
+			jmpROM	ROMCMDDONE 				; we're done . . .
 
 ejectMounted:
 			lea.l	vcbDrvNum(a2),a1		; point into VCB at drive number
@@ -2138,13 +2137,13 @@ ejectOnLine:
 @5:			st		FlushOnly				; only flushing (don't close . . .)
 			jsrROM	FlushVFiles 			; flush all files on this volume
 
-			jsrROM	TFSVCBTST   				; Are we dealing with a TFS volume?
+			jsrROM	ROMTFSVCBTST				; Are we dealing with a TFS volume?
 			bneROM	OfflineEjectCallsMFSFlush	; Nope, so join ROM to do MFS right
 
 ; note that the following line is the opposite of the ROM code.  We only want to flush
 ; these files, since _Unmount will close them later.  However, we do want to mark the
 ; vcb consistent as it goes offline.
-			jsrROM	CVFLGS   				; Is volume write protected?					<31>
+			jsrROM	ROMCVFLGS				; Is volume write protected?					<31>
 			bne.s	@1						; If so, don't try to mark it dirty				<31>
 			bset.b	#vcbAtVOK,vcbAtrb(a2)	; Indicate vol was unmounted ok					<31>
 			jsrROM 	MarkVCBDirty			; mark VCB dirty so it will be written			<31>
@@ -2240,15 +2239,15 @@ DesktopCloseDownProc:	proc
 ;_______________________________________________________________________
 UnmountForTheNineties:	PatchProc	_UnMountVol
 
-			bsr		DesktopCloseDownProc	; go take care of the desktop database <36>
+			jsr		DesktopCloseDownProc	; go take care of the desktop database <36>
 
 ; The desktop file hack should no longer be necessary for the 7.0 version of the AppleShare client.
 IncludeAppleShareDesktopHack	equ		0
 
-			jsrROM	FSQUEUESYNC   			; Get in sync...
+			jsrROM	ROMFSQUEUESYNC			; Get in sync...
 			clr.b	FlushOnly				; Setup same as UnmountVol
-			jsrROM	DTRMV3   				; Call DtrmV3 to do setup stuff
-			bneROM	CMDDONE   				; and split on errors
+			jsrROM	ROMDTRMV3				; Call DtrmV3 to do setup stuff
+			bneROM	ROMCMDDONE				; and split on errors
 
 			moveq	#0,d0					; Initialize result code
 			btst	#HFSBit,ioTrap(a0)		; Unconditional unmount?
@@ -2292,19 +2291,19 @@ IncludeAppleShareDesktopHack	equ		0
 @5
 			movem.l	(sp)+,a1/d1/d2			; Restore regs
 			tst.w	d0						; Were files open?
-			bneROM	CMDDONE   				; and quit on errors
+			bneROM	ROMCMDDONE				; and quit on errors
 
 FlUnMnt:
 			jsrROM	romCkExtFS 				; see if it's for an external fs
-			bneROM	CMDDONE   				; and split on errors
+			bneROM	ROMCMDDONE				; and split on errors
 
 			jsrROM	FlushVFiles 			; flush all files on this volume
-			bneROM	CMDDONE   				; and split on errors
+			bneROM	ROMCMDDONE				; and split on errors
 
 ; All files on this volume are flushed now.  Update the volume information as
 ; appropriate, depending on the file structure:
 
-			jsrROM 	TFSVCBTST   			; is this a TFS volume?
+			jsrROM 	ROMTFSVCBTST			; is this a TFS volume?
 			beq.s	@1						; br if so
 			jmpROM	FlUnMntAfterMFSCheck	; the ROM has is right for MFS volumes
 
@@ -2342,7 +2341,7 @@ BackInFlUnMnt:
 			moveq.l	#noErr,d0				; no error
 
 FlVolExit
-			jmpROM	CMDDONE   
+			jmpROM	ROMCMDDONE
 			endproc
 
 
@@ -3029,7 +3028,7 @@ ProcessMgrExists	proc	export
 
 TagFileWithPSN
 ; Open traps can be (and are!) called before Process Mgr is init'd
-			bsr		ProcessMgrExists	; is Process Mgr ready?
+			jsr		ProcessMgrExists	; is Process Mgr ready?
 			bne.s	@CantRecord			; Process Mgr is not ready yet
 
 ; find the current PSN
@@ -3089,7 +3088,7 @@ FSCleanupRegs		REG		A2-A3/D2-D6
 			MOVE	cbPBufULen(A2),D4		; D4=ext. FCB unit size
 			LEA		fcbPBufData(A2),A2		; A2=ext. fcb array
 			MOVE	FSFCBLen,D5				; D5=FCB len
-			jsrROM	GT1STFCB   				; A1=FCB, D1=1st RefNum
+			jsrROM	ROMGT1STFCB				; A1=FCB, D1=1st RefNum
 
 ; First close all the open files belong to this process:
 ;	A1=FCBptr, A2=Ext. FCBptr, D1.W=RefNum, D2=id2, D3.W=loop index,
@@ -3187,8 +3186,8 @@ clearPB		MOVEA.L	A0,A3				; A3=A0=iopb
 ;_______________________________________________________________________________________
 ; This patch was rolled into TFSVOL.a
 OpenWDPatch	Proc	export
-			jsrROM 	FSQUEUE    			; Wait for our turn to come
-			jsrROM 	FNDFILNAME   		; Look for the indicated directory
+			jsrROM 	ROMFSQUEUE 			; Wait for our turn to come
+			jsrROM 	ROMFNDFILNAME		; Look for the indicated directory
 			BEQ.S	@1					; Br if found
 			CMP.W	#BdNamErr,D0		; Was it a bad filename?				<21Sep85>
 			BNE.S	opnWDExit			; If not, there's no more hope          <21Sep85>
@@ -3211,7 +3210,7 @@ OpenWDPatch	Proc	export
 @2			MOVE.W	VCBVRefNum(A2),ioVRefNum(A0) ; Return the VRefNum as WDRfn	<21Sep85>
 
 opnWDOK 	MOVEQ	#0,D0				; Call it a success 					<21Sep85>
-opnWDExit	jmpROM 	CMDDONE    			; we're finished . . .
+opnWDExit	jmpROM 	ROMCMDDONE 			; we're finished . . .
 
 ; Look for a matching working directory, starting with the third (the first two are
 ; reserved to hold the system-wide volume and directory defaults).
@@ -3228,7 +3227,7 @@ PickWDCB:
 			ADDA	D3,A3				; A3 = 2nd WDCB
 			MOVEQ	#0,D4				; ID1= 0
 			MOVEQ	#0,D5				; ID2= 0 (no serial ID)
-			BSR		ProcessMgrExists	; check Process Mgr ready?
+			JSR		ProcessMgrExists	; check Process Mgr ready?
 			BNE.S	@nomf				; no, don't bother with serial ID
 		;; Process Mgr is available, we are open for business
 			SUBA.L	A5,A5				; A5=0 if MultiFinder is ready			<06Aug90>
@@ -4018,7 +4017,7 @@ DontTruncateMultiForks	ComeFromPatchProc	$A0DB,,(Plus,SE,II,Portable,IIci)	;	<11
 			MOVE.L	FCBFlNm(A1,D3.W),D2		; D2.L = our file number				<11Dec90 #17>
 			move.b	fcbMdRByt(a1,d3.w),d4	; d4.b = our fork's misc info			<44>
 
-			jsrROM	GT1STFCB   				; get (A1,D1) pointing to first FCB		<11Dec90 #17>
+			jsrROM	ROMGT1STFCB				; get (A1,D1) pointing to first FCB		<11Dec90 #17>
 @1			CMP.W	D1,D3					; same FCB?								<11Dec90 #17>
 			BEQ.S	@3						; skip ourself if it is					<11Dec90 #17>
 			CMP.L	FCBFlNm(A1,D1),D2		; file numbers match?					<11Dec90 #17>
@@ -4029,7 +4028,7 @@ DontTruncateMultiForks	ComeFromPatchProc	$A0DB,,(Plus,SE,II,Portable,IIci)	;	<11
 			eor.b	d4,d0					; see how it compares against ours		<44>
 			btst.l	#fcbRscBit,d0			; are we the same?						<44>
 			beq.s	@7						; if so, then there's another open path	<44>
-@3			jsrROM	GTNXTFCB   				; get next one until we run out			<11Dec90 #17>
+@3			jsrROM	ROMGTNXTFCB				; get next one until we run out			<11Dec90 #17>
 			BCS.S	@1						; continue if more						<11Dec90 #17>
 
 ; No second open path found, so do the truncate
@@ -4741,7 +4740,7 @@ BDUpdDepth
 
 			MOVEQ	 #0,D1				; locate key and data for 1st record <10Oct85>
 			MOVEA.L  A3,A1				;
-			jsrRom 	 LOCREC    			; ... in node				  <10Oct85>
+			jsrRom 	 ROMLOCREC 			; ... in node				  <10Oct85>
 			MOVE.L	 (A1),BTCRoot(A4)	; new root = child node 	  <10Oct85>
 ;
 ; release the previous root node
@@ -4814,7 +4813,7 @@ BDExit1
 ; rolled into TFS.a for SuperMario <SM1> FM
 
 CDSRegs			reg			d0/d1/a1
-CheckDesktopSupport:		proc
+CheckDesktopSupport:		proc	export
 
 			movem.l	CDSRegs, -(sp)
 
@@ -4905,13 +4904,13 @@ GetVolParms:		proc export
 @GetVolRegs			reg			d2/d3/a1-a4
 
 			bclr	#asyncTrpBit, ioTrap(a0)	; force synchronous  (wrong.  See note, above)
-			jsrRom 	FSQUEUE    					; Patiently wait our turn in line
+			jsrRom 	ROMFSQUEUE 					; Patiently wait our turn in line
 			movem.l	@GetVolRegs, -(a6)			; save regs on FS stack
 			suba.w	@VolParmsBufferSize, a6		; allocate a GetVolParms buffer on the stack
 ;
 ; Find the VCB in question:
 ;
-			jsrRom	DTRMV3   					; find vol using ioNamePtr & ioVRefNum (D023/A234 trashed)
+			jsrRom	ROMDTRMV3					; find vol using ioNamePtr & ioVRefNum (D023/A234 trashed)
 			bne.s	@GetVolParmsExit			; (DtrmV3 puts VCBPtr in A2)
 
 			tst.w	vcbFSID(a2) 				; Check: external file system?  (•• TFSVCBTst?)
@@ -4961,7 +4960,7 @@ GetVolParms:		proc export
 
 @GetVolParmsExit:
 			movem.l	(a6)+, @GetVolRegs			; restore regs
-			jmpROM	CMDDONE   					; Go home
+			jmpROM	ROMCMDDONE					; Go home
 
 ; This buffer contains the appropriate values for local HFS volumes.
 @HFSVolParmsBuffer:
@@ -5057,7 +5056,7 @@ WriteCountInit
 			MOVE.L	VCBQHdr+QHead,D0	; search the VCB queue
 			BEQ.S	wcEndq				; br if end of queue reached
 CkVol:		MOVE.L	D0,A2				; next VCB pointer
-			jsrRom	TFSVCBTST   			; is this a HFS volume?
+			jsrRom	ROMTFSVCBTST			; is this a HFS volume?
 			BNE.S	@6					; No, don't bother
 			TST		vcbFSID(A2)			; internal HFS? (do we need to test this?)
 			BNE.S	@6					; No, don't bother
@@ -5121,7 +5120,7 @@ GrowFileSystemStack:
 
 			moveq.l	#0,d0						; use selector 0
 			move.w	#$a060,d1					; and pretend we're trap _HFSDispatch
-			jsrROM	FSQUEUE   					; and sync up with the file system
+			jsrROM	ROMFSQUEUE					; and sync up with the file system
 
 ; first we use the old equate to get the pointer block's base address
 			move.l	HFSStkTop,a0				; current stack top
@@ -5136,7 +5135,7 @@ GrowFileSystemStack:
 			move.l	a0,HFSStkTop				; Store pointer in lo-mem
 
 			moveq.l	#noErr,d0					; success!
-			jmpROM	CMDDONE   
+			jmpROM	ROMCMDDONE
 
 @bail:
 			moveq.l		#dsMemFullErr, d0		; sys heap is full, so punt
@@ -5237,7 +5236,7 @@ InstallVectors	PROC	export
 			leaResident	vAfterFSQHook, a0	; get addr just past call to fsQueueHook (in fsQueueHook patch)
 			move.l	a0, ExpandMemRec.jAfterFSQHook(a1)
 
-			leaROM	CMDDONE   , a0			; get addr of CmdDone (still in ROM)
+			leaROM	ROMCMDDONE, a0			; get addr of CmdDone (still in ROM)
 			move.l	a0, ExpandMemRec.jCmdDone(a1)
 			leaResident	fsGeneralWakeUp, a0	; get addr of general purpose File System kickstart
 			move.l	a0, ExpandMemRec.jDispatchNext(a1)
diff --git a/OS/HFS/TFS.a b/OS/HFS/TFS.a
--- a/OS/HFS/TFS.a
+++ b/OS/HFS/TFS.a
@@ -365,7 +365,7 @@ TurboFS 	PROC	EXPORT
 
 			Export	UNLOCKRNG,LOCKRNG,READWDCB,SETUPDEF,SETUPWDCB,SETPMSP,FSCONTROL
 			Export	ALLOCATEFCBS,DOFSCLEANUP,GTNXTMATCH,GT1STMATCH,GETVOLPARMS
-			Export	FLUSHVFILES,FCLOSE,REFNUMCHECK,PUSHCNAME,CVFLGS,POPCNAME
+			Export	FLUSHVFILES,FCLOSE,PUSHCNAME,CVFLGS,POPCNAME
 			Export	ExtOffLinCk,FNDFILNAME,DTRMV3,GT1STFCB,GTNXTFCB,FSQUEUE
 
 			EXPORT	vDoEject			;									<C150/09sep86>
@@ -477,7 +477,7 @@ VolumeCall:
 RefNumCall:
 			jsr		FSQueue				; chill in line
 			move.w  ioRefNum(a0),d0		; Pick up the refNum
-			jsr		RefNumCheck			; Check the refNum supplied
+			;jsr		RefNumCheck			; Check the refNum supplied
 			bne		CmdDone				; Punt at first hint of trouble
 
 			movea.l FCBsPtr,a1			; Point to the FCB table
@@ -555,46 +555,6 @@ FSControl:
 			MOVEQ	#0,D0				; Indicate success
 			BRA 	CmdDone 			; And call it a day
 
-;________________________________________________________________________________
-;
-; Routine:      RefNumCheck
-;
-; Function:     Check the refNum supplied to make sure it's a real file RefNum.
-;
-; Inputs:		d0 = refnum
-; Output:       d0 = error code, RfNumErr or noErr
-;
-; Note:
-;	This routine is called by the desktop manager and the UnTagFCB _Close patch.
-;________________________________________________________________________________
-; This routine was rolled into into the file TFS.a.						<SM1>
-RefNumCheckRegs		reg	a1/d1
-			entry	RefNumCheck
-RefNumCheck
-			movem.l	RefNumCheckRegs, -(sp)
-			moveq.l	#0, d1				; clear high word
-			move.w	d0, d1				; make a copy of the refnum
-			bmi.s	@RefNumErrExit		; no negative refnums
-
-			divu	FSFCBLen,d1			; Divide by the FCB size
-            swap	d1					; Get remainder in low word
-            subq.w	#2,d1				; Is the remainder 2?
-            bne.s	@RefNumErrExit		; If not, no way this could be a refnum
-
-			move.l	FCBSPtr, a1			; point to length word of FCB array
-			cmp.w	(a1), d0			; check against size of FCB array
-			bgt.s	@RefNumErrExit		; Too high?  Too bad.
-
-			moveq.l	#noErr, d0			; No pwobwem!
-			bra.s	@Exit
-
-@RefNumErrExit:
-			moveq.l	#RfNumErr,d0		; Indicate a bad refNum
-@Exit:
-			movem.l	(sp)+, RefNumCheckRegs
-			tst.w	d0					; Set condition codes
-            rts
-
 ;_______________________________________________________________________
 ;
 ; Routine:		FSQueueSync
@@ -1345,7 +1305,7 @@ InitFS		TST.W	FSFCBLen					; are we in already?
 			MOVE.W	D1,(A0) 					; Store length of WDCB array			<11Apr85>
 			MOVE.L	A0,WDCBsPtr 				; Store pointer in lomem				<11Apr85>
 
-			BigLEA	WDCBSwOS,A2					; point to offset to the WDCB entry		<1.2>
+			;BigLEA	WDCBSwOS,A2					; point to offset to the WDCB entry		<1.2>
 			MOVE.W	(A2),A2						; Get the offset to the WDCB entry		<1.2>
 			ADD.L	SwitcherTPtr,A2 			; Index into Switcher Table				<1.2>
 			MOVE.L	A0,(A2) 					; Fill in entry for WDCB switch 		<A271><27Oct86><1.2>
@@ -1364,7 +1324,7 @@ InitFS		TST.W	FSFCBLen					; are we in already?
 			_NewPtr ,SYS,CLEAR					; Allocate space for it 				<18Aug85>
 			BNE		FSInitErr					; Punt on errors						<18Aug85>
 
-			BigLEA	PMSPSwOS,A2					; point to offset to the PMSP entry		<C152><1.2>
+			;BigLEA	PMSPSwOS,A2					; point to offset to the PMSP entry		<C152><1.2>
 			MOVE.W	(A2),A2						; Get the offset to the PMSP entry		<C152><1.2>
 			ADD.L	SwitcherTPtr,A2 			; Index into Switcher Table				<C152><1.2>
 			MOVE.L	A0,(A2) 					; Fill in entry for PMSP hook switch	<A271><27Oct86><1.2>
@@ -1607,7 +1567,7 @@ AllocateFCBs
 			move.w	d3,d2						; otherwise, just grow as much as we can
 
 @grow:
-			bsr		MoreFCBs					; try to get the FCBs
+			jsr		MoreFCBs					; try to get the FCBs
 			beq.s	@gotSome					; leave with a smile
 
 			asr.w	#1,d2						; try to get half that many
@@ -1908,7 +1868,7 @@ GetVolParms:
 @notMFS:
 			_BlockMove
 
-			bsr		CheckDesktopSupport			; returns zero clear if support, set if none
+			jsr		CheckDesktopSupport			; returns zero clear if support, set if none
 			beq.s	@NoDTSupport				; z set means no support
 
 			move.l	vmAttrib(a6), d0			; get the attributes word
diff --git a/OS/HFS/TFSDIR1.a b/OS/HFS/TFSDIR1.a
--- a/OS/HFS/TFSDIR1.a
+++ b/OS/HFS/TFSDIR1.a
@@ -105,7 +105,7 @@ GetParallelFCBFromRefnum
 			
 			move.w	ioRefNum(a0),d0		; Get the file reference number
 			move.w	d0,d1				; Keep a copy in another register
-			bsr		RefNumCheck			; Make sure the reference number is valid
+			;bsr		RefNumCheck			; Make sure the reference number is valid
 			bmi.s	@exitGetParallelFCB	; Bad reference number
 			
 			move.w	d1,d0				; Get the copy
diff --git a/OS/HFS/TFSRFN1.a b/OS/HFS/TFSRFN1.a
--- a/OS/HFS/TFSRFN1.a
+++ b/OS/HFS/TFSRFN1.a
@@ -350,7 +350,7 @@ FRdEOFXit	MOVEQ	#EOFErr,D0			; then we must have hit end of file . . .
 
 FRdExit0	MOVE.L	D5,FCBCrPs(A1,D1)	; update current position in FCB
 			MOVE.L	D5,IOPosOffset(A0)	; always return current pos
-FRdExit1	BSR.L	CacheFlush			; <SM3> CSS
+FRdExit1	;BSR.L	CacheFlush			; <SM3> CSS
 			BRA 	CmdDone 			; bye now . . .
 
 ; reading while looking for end of line characters . . . do it a block at a time
@@ -474,7 +474,7 @@ FileWrite:
 			RTS 						; go there								
 vFileWrite:								; 'vectored' FileWrite routine
 
-			BSR.L	CacheFlush			; flush the chip caches so data is in memory. <SM3> CSS
+			;BSR.L	CacheFlush			; flush the chip caches so data is in memory. <SM3> CSS
 			BSR 	FSQueue 			; don't do the call until time.
 			BSR 	TstMod				; test if we may modify this file.
 			BNE.S	FWrExit1			; br if not.
diff --git a/OS/HFS/TFSRFN2.a b/OS/HFS/TFSRFN2.a
--- a/OS/HFS/TFSRFN2.a
+++ b/OS/HFS/TFSRFN2.a
@@ -182,7 +182,7 @@ ClosePatchRegs	reg		a0-a2/d0-d1
 
 ; check the refnum for validity. and locate the parallel FCB array element
 			move.w	ioRefNum(a0),d0				; get refnum being closed
-			bsr		RefNumCheck					; is it legit?
+			;bsr		RefNumCheck					; is it legit?
 			bne.s	DoClosePop					; if not, let the real trap deal with it
 			move.w	ioRefNum(a0),d0				; get refnum being closed
 			bsr		ParallelFCBFromRefnum		; a1 = address of parallel FCB element
diff --git a/OS/HFS/TFSVOL.a b/OS/HFS/TFSVOL.a
--- a/OS/HFS/TFSVOL.a
+++ b/OS/HFS/TFSVOL.a
@@ -1356,8 +1356,8 @@ ejectMark	CLR.W	(A1)+				; zero drive number to mark it offline/ejected
 			MOVE.L	A2,A0				; VCB queue element 						<29Aug85>
 			LEA 	VCBQHdr,A1			; VCB queue header							<29Aug85>
 
-			BSR.L 	DequeueTrap			; DeQueue then EnQueue to force VCB to		<29Aug85><v1.4>
-			BSR.L 	EnQueueTrap			;  the end for round-robin offline scheme	<29Aug85><v1.4>
+			;BSR.L 	DequeueTrap			; DeQueue then EnQueue to force VCB to		<29Aug85><v1.4>
+			;BSR.L 	EnQueueTrap			;  the end for round-robin offline scheme	<29Aug85><v1.4>
 			
 			TST.B	NoEject 			; Was this a real _Offline call?			<28Oct85>
 			BMI		ejectDone			; Yes - offline br to command done			<29Aug85>
@@ -1417,7 +1417,7 @@ UnMountVolTrap:
 ; and extents files. Since _Offline now no longer does this, we must make sure
 ; that UnMountVol always does.
 
-			bsr		DesktopCloseDownProc	; <SM1> FM go take care of the desktop database <36>
+			;bsr		DesktopCloseDownProc	; <SM1> FM go take care of the desktop database <36>
 
 			bsr.s	FSQueueSync				; Get in sync...					<04Nov87>
 			clr.b	FlushOnly				; Setup same as UnmountVol			<04Nov87>
@@ -2568,7 +2568,7 @@ PickWDCB:
 			ADDA	D3,A3				; A3 = 2nd WDCB
 			MOVEQ	#0,D4				; ID1= 0
 			MOVEQ	#0,D5				; ID2= 0 (no serial ID)
-			BSR		ProcessMgrExists	; check Process Mgr ready?
+			;BSR		ProcessMgrExists	; check Process Mgr ready?
 			BNE.S	@nomf				; no, don't bother with serial ID
 		;; Process Mgr is available, we are open for business
 			SUBA.L	A5,A5				; A5=0 if MultiFinder is ready			<06Aug90>
diff --git a/OS/HwPriv.a b/OS/HwPriv.a
--- a/OS/HwPriv.a
+++ b/OS/HwPriv.a
@@ -315,43 +315,124 @@ HwVecSize		EQU	2
 ;
 ;----------
 
-HWPriv		PROC	EXPORT							; KISS (Keep it simple and easy to patch)
-
-			bra.b	HWPrivSwitch
-
-			ALIGN	8
-Vects												;table of offsets to selector routines
-			HwPrivSelector	SwapICache				; 0		SwapICache
-			HwPrivSelector	FlushICache				; 1		FlushICache
-			HwPrivSelector	SwapDCache				; 2		SwapDCache
-			HwPrivSelector	FlushDCache				; 3		FlushDCache
-			HwPrivSelector	EnableExtCache			; 4		EnableExtCache
-			HwPrivSelector	DisableExtCache			; 5		DisableExtCache
-			HwPrivSelector	FlushExtCache			; 6		FlushExtCache
-			HwPrivSelector	SwapSerialClock			; 7		SwapSerialClock
-			HwPrivSelector	ProtectEDisk			; 8		Protect/Unprotect EDisk
-			HwPrivSelector	FlushCRange				; 9		FlushCRange
-			HwPrivSelector	WaitForSCSIDevs			; 10	WaitForSCSIDevs
-			HwPrivSelector	ReturnErr				; 11	Unused
-			HwPrivSelector	SlotBlockXferCtl		; 12 - enable block xfers to a slot
-			HwPrivSelector	GetENetID				; 13 - Get Ethernet ID from serial ROM
-LastVec
-
-			ALIGN	8
-HWPrivSwitch
-			cmpi.w	#(LastVec-Vects)/HwVecSize,d0	; check if selector in range
-			bhs		ReturnErr						; abort if it’s not a valid selector
-			move.w	Vects(d0*HwVecSize),d0			; get offset to selector’s routine
-			jmp		Vects(d0)						; go to the routine
-
-			ENDPROC
-
-
-ReturnErr	PROC	ENTRY
-
-			move.l	#hwParamErr,d0					; abort: return error code
+HwPrivTable		PROC	EXPORT
+			dcImportResident	SwapICache
+			dcImportResident	FlushICache
+			dcImportResident	SwapDCache
+			dcImportResident	FlushDCache
+			dcImportResident	EnableExtCache
+			dcImportResident	DisableExtCache
+			dcImportResident	FlushExtCache
+			dcImportResident	SwapSerialClock
+			dc.l				0
+			dcImportResident	FlushICache
+			dcImportResident	WaitForSCSIDevs
+
+
+HwPrivTableAlt		PROC	EXPORT
+			dc.l				0
+			dc.l				0
+			dc.l				0
+			dc.l				0
+			dc.l				0
+			dc.l				0
+			dc.l				0
+			dcImportResident	SwapSerialClock
+			dc.l				0
+			dc.l				0
+			dc.l				0
+
+
+
+InitPlusSEPortable		InstallProc		(Plus,SE,Portable)		; <29>
+			cmp.b	#cpu68020,CpuFlag
+			blo.s	@exit
+			cmp.b	#cpu68030,CpuFlag
+			bhi.s	@exit
+
+			leaResident		HwPrivCodeEditLocation,a0
+			move.w	#10,d2
+			move.w	d2,2(a0)
+			leaResident		HwPrivTable,a2
+			IMPORT	R012C
+			jsr		R012C
+@exit
+			rts
+
+
+
+InitIIIIci		InstallProc		(II,IIci,notTERROR)				; <5>
+			leaResident		HwPrivCodeEditLocation,a0
+			move.w	#10,d2
+			move.w	d2,2(a0)
+			leaResident		HwPrivTable,a2
+			IMPORT	R012C
+			jsr		R012C
+			rts
+
+
+
+InitIIci		InstallProc		(IIci,hasTERROR)					; <5>
+			leaResident		HwPrivCodeEditLocation,a0
+			move.w	#10,d2
+			move.w	d2,2(a0)
+			leaResident		HwPrivTableAlt,a2
+			IMPORT	R012C
+			jsr		R012C
+			rts
+
+
+
+R012C		PROC	EXPORT
+			move.w	#$A198,d0
+			_GetOSTrapAddress
+			move.l	a2,a1
+
+@lup		move.l	(a2)+,d1
+			beq.s	@exit
+@reenter	dbra	d2,@lup
+
+			move.l	ExpandMem,a0
+			move.l	a1,ExpandMemRec.emHwPrivTable(a0)
 			rts
 
+@exit		move.l	a0,-4(a2)
+			bra.s	@reenter
+
+
+R0132		PROC	EXPORT
+
+
+
+HWPriv		PatchProc	_HWPriv,(Plus,SE,II,Portable,IIci)
+			IMPORT	SwapSerialClock
+
+			cmp.b	#cpu68020,CpuFlag
+			blo.s	trySwapSerialClock
+
+			EXPORT	HwPrivCodeEditLocation
+HwPrivCodeEditLocation
+			cmp.w	#0,d0
+			bhi.s	@jmprom
+
+			lea		-4(sp),sp
+			move.l	a0,-(sp)
+			move.l	ExpandMem,a0
+			move.l	ExpandMemRec.emHwPrivTable(a0),a0
+			move.l	(a0,d0.w*4),4(sp)
+			move.l	(sp)+,a0
+			rts
+
+@jmprom		jmp		$ACBDADFB
+
+ReturnErr	move.l	#hwParamErr,d0
+			rts
+trySwapSerialClock
+			cmp.w	#7,d0
+			bne.s	ReturnErr
+
+			jmp		SwapSerialClock
+
 			ENDPROC
 
 
@@ -376,20 +457,18 @@ ReturnErr	PROC	ENTRY
 
 SwapICache	PROC	EXPORT
 
-			TestFor	has68kEmulator				;	are we on a PPC-based machine?
-			bnz.b	@EmuFake
-
 			cmp.b	#cpu68040,CpuFlag			;	are we on an 040-based machine?
-			bhs.s	@handle040
+			bge.s	@handle040
 
 @handle030
 			movec	CACR,d0						;	get current cache state
 			bfextu	d0{31:1},d1					;	get cache enable bit into LSbit of d1
 			bclr	#CACR_EI_020_030,d0			;	assume we're disabling (clear enable flag)
 			move.l	a0,d2						;	see what we want to do
-			beq.s	@SetCACR					;	if we want to turn it on
+			beq.s	@dontTurnOn					;	if we want to turn it on
 			ori.b	#((1<<CACR_EI_020_030)|\	;		set enable,
 					(1<<CACR_CI_020_030)),d0	;		flush I-Cache flags
+@dontTurnOn
 			bra.s	@SetCACR					;   	go set the desired cache state
 
 @handle040
@@ -398,7 +477,9 @@ SwapICache	PROC	EXPORT
 			bclr	#CACR_IE_040,d0				;	assume we're disabling
 			move.l	a0,d2						;	are we enabling the I-Cache?
 			beq.s	@SetCACR					;	NO  ... go turn in OFF
-			jsr		([jCacheFlush])				;		invalidate both caches
+			MACHINE	MC68040						;
+			cpusha	ic
+			MACHINE	MC68030						;
 			bset	#CACR_IE_040,d0				;		set IE=1 to enable I-Cache
 
 @SetCACR
@@ -407,10 +488,6 @@ SwapICache	PROC	EXPORT
 			moveq	#noErr,d0					;	signal all's well
 			rts
 
-@EmuFake	lea		1,a0						;	do nothing and report that caches were enabled
-			moveq	#noErr,d0
-			rts
-
 			ENDPROC
 
 
@@ -430,9 +507,15 @@ SwapICache	PROC	EXPORT
 
 FlushICache	PROC	EXPORT
 
-			TestFor	has68kEmulator
-			bnz.b	@Coherent
+			cmp.b	#cpu68040,CpuFlag			;	are we on an 040-based machine?
+			bge.s	@handle040
 
+			movec	CACR,d0						;	get current cache state
+			bset	#CACR_CI_020_030,d0			;	set enable flag
+			movec	d0,CACR						;	set cache state
+			bra.s	@Coherent
+
+@handle040
 			jsr		([jCacheFlush])			; invalidate both caches
 
 @Coherent
@@ -463,33 +546,31 @@ FlushICache	PROC	EXPORT
 
 SwapDCache	PROC	EXPORT
 
-			TestFor	has68kEmulator				;	are we on a PPC-based machine?
-			bnz.b	@EmuFake
-
 			cmp.b	#cpu68040,CpuFlag			;	are we on an 040-based machine?
-			bhs.s	@handle040
+			bge.s	@handle040
 
 @handle030
 			movec	CACR,d0						;	get current cache state
 			bfextu	d0{23:1},d1					;	get cache enable bit into LSbit of d1.l
 			bclr	#CACR_ED_030,d0				;	assume we're disabling (clear enable flag)
 			move.l	a0,d2						;	see what we want to do
-			beq.s	@SetCACR					;	if we want to turn it on
+			beq.s	@dontTurnOn					;	if we want to turn it on
 			ori.w	#((1<<CACR_ED_030)|\		;		set enable,
 					(1<<CACR_CD_030)),d0		;		flush D-Cache flags
+@dontTurnOn
 			bra.s	@SetCACR					;   	set cache to the desired state
 
 @handle040
 			movec	CACR,d0						;	get current D-Cache state
 			bfextu	d0{0:1},d1					;	put cache enable bit into LSbit of d1.l
-			bset	#CACR_DE_040,d0				;	assume we're enabling
+			bclr	#CACR_DE_040,d0				;	assume we're enabling
 			move.l	a0,d2						;	check what we are really doing
-			bne.s	@SetCACR					;	if we are disabling the caches
+			beq.s	@SetCACR					;	if we are disabling the caches
 			MACHINE	MC68040						;
 			nop									;     required by D43B CPUSHA DC errata item
 			cpusha	dc							;	  push dirty D-Cache data items to memory
 			MACHINE	MC68030						;
-			bclr	#CACR_DE_040,d0				;	  set DE=0 to disable D-Cache
+			bset	#CACR_DE_040,d0				;	  set DE=0 to disable D-Cache
 
 @SetCACR
 			move.l	d1,a0						;	save the previous D-Cache state
@@ -497,10 +578,6 @@ SwapDCache	PROC	EXPORT
 			moveq	#noErr,d0					;	signal all's well
 			rts
 
-@EmuFake	lea		1,a0						;	do nothing and report that caches were enabled
-			moveq	#noErr,d0
-			rts
-
 			ENDPROC
 
 
@@ -516,11 +593,8 @@ SwapDCache	PROC	EXPORT
 
 FlushDCache	PROC	EXPORT
 
-			TestFor	has68kEmulator				;	are we on a PPC-based machine?
-			bnz.b	@flushDCacheExit
-
 			cmp.b	#cpu68040,CpuFlag			;	are we on an 040-based machine?
-			bhs.s	@handle040
+			bge.s	@handle040
 
 @handle030
 			movec	CACR,d0						;	get current cache state
@@ -553,22 +627,13 @@ FlushDCache	PROC	EXPORT
 
 EnableExtCache	PROC	EXPORT
 
-			tst.l	DockingGlobals				; have traps been initialized yet?
-			beq.s	@noDockMgr					;  -> nope, just blow it all off
-			subq	#4,sp						; make room for result
-			move.l	#dockCacheControl,-(sp)		; cache control selector
-			move.l	#dockCacheOn,-(sp)			; indicate the cache should be turned on
-			_DockingDispatch
-			addq	#4,sp						; remove the result (assume success)
-
-		IF hasMDU THEN
-			bra.s	@extCacheDone
-@noDockMgr
+			move.w	sr,-(sp)					; save int mask
+			ori.w	#HiIntMask,sr				; disable all interrupts
 
 			movea.l	UnivInfoPtr,a0				; point to the product info
 			cmpi.b	#DecoderKinds.MDUDecoder,\
 					ProductInfo.DecoderKind(a0)	; see if we have an MDU
-			bne.s	@noMDU						; if not, nothing to enable
+			bne.s	@flushDone					; if not, nothing to enable
 
 ; enable the external MDU cache as follows:
 ; Toggle the RvCFlush bit 1 - 0 - 1, to flush the cache
@@ -579,9 +644,6 @@ EnableExtCache	PROC	EXPORT
 			movea.l	VIA2RBV,a0					; get the VIA2 or RBV base address
 			lea		vBufB|RvDataB(a0),a0		; point to the cache register
 
-			move.w	sr,-(sp)					; save int mask
-			ori.w	#HiIntMask,sr				; disable all interrupts
-
 			moveq.l	#~(1<<RvCFlush),d0			; mask to clear flush bit (active low)
 			and.b	(a0),d0						; get the register, clear flush
 			btst.l	#RvCDis,d0					; test the cache disable bit (active high)
@@ -598,11 +660,6 @@ EnableExtCache	PROC	EXPORT
 @flushDone	move.w	(sp)+,sr					; restore int mask
 @noMDU
 
-		ELSE
-@noDockMgr
-
-		ENDIF
-
 @extCacheDone
 			moveq	#noErr,d0					; signal all's well
 			rts
@@ -622,18 +679,6 @@ EnableExtCache	PROC	EXPORT
 
 DisableExtCache	PROC	EXPORT
 
-			tst.l	DockingGlobals				; have traps been initialized yet?
-			beq.s	@noDockMgr					;  -> nope, just blow it all off
-			subq	#4, sp						; make room for result
-			move.l	#dockCacheControl, -(sp)	; cache control selector
-			move.l	#dockCacheOff, -(sp)		; indicate the cache should be turned on
-			_DockingDispatch
-			addq	#4,sp						; remove the result (assume success)
-
-		IF hasMDU THEN
-			bra.s	@extCacheDone
-@noDockMgr
-
 			movea.l	UnivInfoPtr,a0				; point to the product info
 			cmpi.b	#DecoderKinds.MDUDecoder,\
 					ProductInfo.DecoderKind(a0)	; see if we have an MDU
@@ -644,11 +689,6 @@ DisableExtCache	PROC	EXPORT
 			ori.b	#(1<<RvCDis),(a0)			; disable cache
 @noMDU
 
-		ELSE
-@noDockMgr
-
-		ENDIF
-
 @extCacheDone
 			moveq	#noErr,d0					; signal all's well
 			rts
@@ -676,6 +716,97 @@ FlushExtCache	PROC	EXPORT
 				ENDPROC
 
 
+;----------
+;
+;   WaitForSCSIDevs (_HWPriv Selector 10)
+;
+;	On Entry:
+;	-> A0[7-0]		= bit map of SCSI IDs to wait for
+;	-> A0[23-16]	= bit map of SCSI IDs to search for
+;
+;	On Exit:
+;	<- A0			= result (0=found wait_for drives, -1=didn't find them)
+;
+;	Register Usage:
+;	D0 = temp
+;	D1 = bitmap of devices to wait for
+;	D2 = bitmap of devices to search for
+;	D3 = OS Type (for SCSILoad)
+;	D4 = Ticks at timeout
+;
+;----------
+
+WaitForSCSIDevs	PROC	EXPORT
+
+SCSILoad		RomBind	(Plus,$7d40),(SE,$404c),(II,$7ad4),(Portable,$7316),(IIci,$71f0)
+
+trashedRegs		REG		D2-D4
+
+DefaultTimeOut	EQU		20					; Number of seconds timeout if PRAM is pristine
+PollDelay		EQU		15					; Delay (in ticks) between SCSILoads
+
+			movem.l	trashedRegs, -(sp)		; save registers that we're going to trash
+
+; Get bitmap parameters into D1 and D2
+			move.l	A0, D1					; D1 = bitmap of devices to wait for
+			move.l	D1, D2					;
+			swap	D2						; D2 = bitmap of devices to search for
+			or.b	D1, D2					; make sure that we search for the drive(s)
+											; that we are waiting for
+
+; SCSILoad expects OS type in high word of D3
+			subq.w	#2, sp					; Make room for parameters.
+			move.l	sp, A0					; Point to the parameter block.
+			_GetOSDefault					; Get info about the default device.
+											; leave OS results on stack for a second
+
+; Get PRAM time out value and convert it to ticks and keep in D4
+			_GetTimeOut						; Get the timeout parameter.
+			bne.s	@UseGivenTime			; Branch if not using default.
+			moveq.l	#DefaultTimeOut, D0		; Use default timeout.
+@UseGivenTime
+			mulu	#60, D0					; Convert timeout to ticks.
+			move.l	D0, D4					; Save timeout in our final reg.
+
+			move.w	(sp)+, D3				; Get OS type off of stack
+			swap	D3						; put in high word (where SCSILoad expects it)
+
+; SCSILoad polling loop -------
+
+@TopO_TheLoop
+			move.l	D2, D0					; Try to load drivers for the "search" disks
+			jsrROM	SCSILoad
+
+			move.b	SCSIDrvrs, D0
+			and.b	D1, D0					; look only at bits we are waiting for
+			cmp.b	D1, D0					; if all are 1 then
+			beq.s	@goodexit				; we got what we were waiting for - exit
+
+; Check for timeout, wait for PollDelay more ticks, check timeout again, then do the SCSILoad again
+			move.l	Ticks, D0
+			cmp.l	D4, D0					; is current ticks higher than our time_out ticks?
+			bhi		@fldexit				; yes - timed out, exit
+
+			add.l	#PollDelay, D0			; wait till Ticks+PollDelay before polling
+@1			cmp.l	Ticks, D0				; if polldelay timeout is higher than current ticks,
+			bhi		@1						; then loop
+
+			cmp.l	D4, D0					; is current ticks higher than our time_out ticks?
+			blo		@TopO_TheLoop			; no - repeat SCSILoad
+											; yes - timed out, exit
+@fldexit
+			move.w	#-1, A0
+			bra.s	@exit
+
+@goodexit
+			sub.l	A0, A0
+@exit
+			movem.l	(sp)+, trashedRegs		; restore registers that we trashed
+			rts
+
+			ENDPROC
+
+
 ;----------
 ;
 ;   SwapSerialClock (_HWPriv Selector 7)
@@ -708,14 +839,15 @@ SwapSerialClock	PROC	EXPORT
 			move.l	a0,d1							; d1 will hold the return value
 			move.l	d1,d2
 			swap	d2								; d2 = <external clk value>.w <scc>.b <port>.b
-			tst.w	d2								; check SCC and port number
-			bne		ReturnErr						; only port A supported
 
 			TestFor	SCCIOPExists
-			beq.w	@BuiltinSCC						; no IOP hardware
+			beq.s	@BuiltinSCC						; no IOP hardware
 			btst.b	#0,SCCIOPFlag					; are we in bypass mode ?
 			beq		@Done							; no, so can't make the call, so exit
 
+			cmp.w	#1,d2
+			bhs.s	@Done
+
 ;	Call SCC IOP kernel to set the external clock mode.
 
 			WITH	IOPRequestInfo, SCCCtlMsg, SCCCtlReply
@@ -723,7 +855,8 @@ SwapSerialClock	PROC	EXPORT
 @IOPSCC
 			suba.w	#irReqInfoSize+SCCCtlMsgSize,sp	; SP = ptr to request msg
 
-			lea		irIOPNumber(sp),a0
+			movea.l	sp,a0
+			lea		irIOPNumber(a0),a0
 			move.b	#SCCIOPNum,(a0)+				; set iop number
 			assert	irRequestKind=(irIOPNumber+1)
 			move.b	#irSendXmtMessage,(a0)+			; a send xmit message kind
@@ -769,21 +902,20 @@ SwapSerialClock	PROC	EXPORT
 			TestFor	VIA1Exists
 			beq.s	@Done							; no via - nothing to do now
 
-			tst.w	d1								; get state to set from low word
-			snz		d2								; set or clear D2.B accordingly
+			tst.w	d2
+			bne.s	@Done
+
+			moveq	#0,d0
 
 			movea.l	VIA,a1
-			clr.w	d1
-			btst	#vSync,vBufA(a1)				; test current value
-			snz		d1								; set or clear D1.B accordingly
-
-			eor.b	d1,d2							; setting already the same as old ?
-			beq.s	@FixResult						; already set to correct state - done
+			move.b	vBufA(a1),d1
+			and.b	#8,d1
+			lsr.b	#3,d1
+			swap	d2
+			cmp.b	d2,d1
+			beq.s	@Done
 			bchg	#vSync,vBufA(a1)				; change the clock setting
 
-@FixResult	neg.b	d1
-			moveq	#noErr,d0						; set good error return
-
 ;	Done - return the old external clock state.
 ;	To do: This does not return valid information in the IOP case!
 ;	To do: This does not return valid information when VIA1 is missing!
@@ -933,100 +1065,6 @@ FlushCRange
 			ENDPROC
 
 
-;----------
-;
-;   WaitForSCSIDevs (_HWPriv Selector 10)
-;
-;	On Entry:
-;	-> A0[7-0]		= bit map of SCSI IDs to wait for
-;	-> A0[23-16]	= bit map of SCSI IDs to search for
-;
-;	On Exit:
-;	<- A0			= result (0=found wait_for drives, -1=didn't find them)
-;
-;	Register Usage:
-;	D0 = temp
-;	D1 = bitmap of devices to wait for
-;	D2 = bitmap of devices to search for
-;	D3 = OS Type (for SCSILoad)
-;	D4 = Ticks at timeout
-;
-;----------
-
-WaitForSCSIDevs	PROC	EXPORT
-
-				IMPORT	SCSILoad
-
-trashedRegs		REG		D2-D4/D6
-
-DefaultTimeOut	EQU		20					; Number of seconds timeout if PRAM is pristine
-PollDelay		EQU		15					; Delay (in ticks) between SCSILoads
-
-			movem.l	trashedRegs, -(sp)		; save registers that we're going to trash
-
-; Get bitmap parameters into D1 and D2
-			move.l	A0, D1					; D1 = bitmap of devices to wait for
-			move.l	D1, D2					;
-			swap	D2						; D2 = bitmap of devices to search for
-			or.b	D1, D2					; make sure that we search for the drive(s)
-											; that we are waiting for
-
-; SCSILoad expects OS type in high word of D3
-			subq.w	#2, sp					; Make room for parameters.
-			move.l	sp, A0					; Point to the parameter block.
-			_GetOSDefault					; Get info about the default device.
-											; leave OS results on stack for a second
-
-; Get PRAM time out value and convert it to ticks and keep in D4
-			_GetTimeOut						; Get the timeout parameter.
-			bne.s	@UseGivenTime			; Branch if not using default.
-			moveq.l	#DefaultTimeOut, D0		; Use default timeout.
-@UseGivenTime
-			mulu	#60, D0					; Convert timeout to ticks.
-			move.l	D0, D4					; Save timeout in our final reg.
-
-			move.w	(sp)+, D3				; Get OS type off of stack
-			swap	D3						; put in high word (where SCSILoad expects it)
-
-			moveq.l	#0, D6
-			bset	#31, D6					; tell drivers not to munge the blasted heap
-
-; SCSILoad polling loop -------
-
-@TopO_TheLoop
-			move.l	D2, D0					; Try to load drivers for the "search" disks
-			bsr.l	SCSILoad
-
-			move.b	SCSIDrvrs, D0
-			and.b	D1, D0					; look only at bits we are waiting for
-			cmp.b	D1, D0					; if all are 1 then
-			beq.s	@goodexit				; we got what we were waiting for - exit
-
-; Check for timeout, wait for PollDelay more ticks, check timeout again, then do the SCSILoad again
-			move.l	Ticks, D0
-			cmp.l	D4, D0					; is current ticks higher than our time_out ticks?
-			bhi		@fldexit				; yes - timed out, exit
-
-			add.l	#PollDelay, D0			; wait till Ticks+PollDelay before polling
-@1			cmp.l	Ticks, D0				; if polldelay timeout is higher than current ticks,
-			bhi		@1						; then loop
-
-			cmp.l	D4, D0					; is current ticks higher than our time_out ticks?
-			blo		@TopO_TheLoop			; no - repeat SCSILoad
-											; yes - timed out, exit
-@fldexit
-			move.w	#-1, A0
-			bra.s	@exit
-
-@goodexit
-			move.w	#0, A0
-@exit
-			movem.l	(sp)+, trashedRegs		; restore registers that we trashed
-			rts
-
-			ENDPROC
-
-
 ;----------
 ;
 ;   SlotBlockXferCtl (_HWPriv Selector 12)
@@ -1097,18 +1135,18 @@ SlotBlockXferCtl	PROC	EXPORT
 			BTst 	#8, D1					; Turn blk xfer on or off?
 			Bne.s	@Bon
 
-			moveq	#BARTBurstRegOff, d0
+;			moveq	#BARTBurstRegOff, d0
 			mulu.l	d2, d0
-			adda.l	#BARTBurstReg,a1
+;			adda.l	#BARTBurstReg,a1
 			suba.l	d0, a1
-			bclr.b	#BARTBurstBit, (A1)		; turn off block xfers for slot # in D2
+;			bclr.b	#BARTBurstBit, (A1)		; turn off block xfers for slot # in D2
 			Bra.s	@done
 
-@Bon		moveq	#BARTBurstRegOff, d0
+@Bon;		moveq	#BARTBurstRegOff, d0
 			mulu.l	d2, d0
-			adda.l	#BARTBurstReg,a1
+;			adda.l	#BARTBurstReg,a1
 			suba.l	d0, a1
-			bset.b	#BARTBurstBit, (A1)		; turn on block xfers for slot # in D2
+;			bset.b	#BARTBurstBit, (A1)		; turn on block xfers for slot # in D2
 
 @done		MoveQ	#noErr,D0				; signal all's well
 
@@ -1149,7 +1187,7 @@ GetENetID	PROC	EXPORT
 
 			WITH 	PMgrRec, PmgrPrimitivesRec
 
-		IF hasPratt THEN
+		IF 0 then;hasPratt THEN
 			TestFor	PrattExists				; 	do we have a Pratt?
 			beq.s	@exit					; 	no, so exit
 
@@ -2154,7 +2192,7 @@ MMUSetCacheMode		Proc	Export
 			bra.s	@exit
 @enableCaching
 			clr.l	d1						; clear 68040 mask								<T7>
-			bfextu	CacheFlags{31-bCopybackMode:1},d1	; get current cache mode			<T7>
+;			bfextu	CacheFlags{31-bCopybackMode:1},d1	; get current cache mode			<T7>
 			lsl.l	#@cm0bit,d1				; make a mask for a 68040 page descriptor		<T7>
 			or.l	(a0),d1					; get page descriptor (forces copyback on 040)
 			bclr.l	#@cacheBit,d1			; enable caching
diff --git a/OS/InterruptHandlers.a b/OS/InterruptHandlers.a
--- a/OS/InterruptHandlers.a
+++ b/OS/InterruptHandlers.a
@@ -465,6 +465,11 @@
 
 ;	interrupt setup primitives record
 
+IntRegs		reg		a0-a3/d0-d3			; registers saved by all interrupt handlers
+IntRegsSize	equ		8*4					; size of IntRegs in bytes - must change if IntRegs changes!
+										; if this changes, then you must update HALc96Routines.a to handle
+										; both old and new cases.
+
 InterruptPrims	RECORD	{intInitPostProc},INCREMENT
 flags			DS.W	1							; miscellaneous flags
 count			DS.W	1							; number of entries in the table
diff --git a/OS/Keyboard/Kbd.r b/OS/Keyboard/Kbd.r
--- a/OS/Keyboard/Kbd.r
+++ b/OS/Keyboard/Kbd.r
@@ -1679,263 +1679,6 @@ resource 'KCHR' (0, USname, KCHRAttributes) {											/*<11>*/
 			}
 		}
 	};
-
-// Norsi (Apple Adjustable) keypad     						<17>  10/22/92  JMF
-
-	resource 'KCAP' ($0E) {
-		{60, 125, 220, 365},
-		{12, 42, 36, 198},
-		{
-			{ {21, 21} }, {
-				noMask, $7A, 50, 10;	/* F1 */
-				noMask, $78, 0, 20;		/* F2 */
-				noMask, $63, 0, 20;		/* F3 */
-				noMask, $76, 20, -40;	/* F4 */
-				noMask, $60, 0, 20;		/* F5 */
-				noMask, $61, 0, 20;		/* F6 */
-				noMask, $62, 20, -40;	/* F7 */
-				noMask, $64, 0, 20;		/* F8 */
-				noMask, $65, 0, 20;		/* F9 */
-				noMask, $6D, 20, -40;	/* F10 */
-				noMask, $67, 0, 20;		/* F11 */
-				noMask, $6F, 0, 20;		/* F12 */
-				noMask, $69, 20, -40;	/* F13 */
-				noMask, $6B, 0, 20;		/* F14 */
-				noMask, $71, 0, 20;		/* F15 */
-				noMask, $72, -80, 30;	/* help */
-				noMask, $73, 0, 20;		/* home */
-				noMask, $74, 0, 20;		/* page up */
-				noMask, $79, 20, 0;		/* page down */
-				noMask, $77, 0, -20;	/* end */
-				noMask, $75, 0, -20;	/* delete */
-				noMask, $7E, 40, 20;	/* up arrow */
-				noMask, $7B, 20, -20;	/* left arrow */
-				noMask, $7D, 0, 20;		/* down arrow */
-				noMask, $7C, 0, 20;		/* right arrow */
-				noMask, $41, 0, 70;		/* . */
-				noMask, $55, -20, 0;	/* 3 */
-				noMask, $54, 0, -20;	/* 2 */
-				noMask, $53, 0, -20;	/* 1 */
-				noMask, $56, -20, 0;	/* 4 */
-				noMask, $57, 0, 20;		/* 5 */
-				noMask, $58, 0, 20;		/* 6 */
-				noMask, $45, 0, 20;		/* + */
-				noMask, $4E, -20, 0;	/* - */
-				noMask, $5C, 0, -20;	/* 9 */
-				noMask, $5B, 0, -20;	/* 8 */
-				noMask, $59, 0, -20;	/* 7 */
-				noMask, $47, -20, 0;	/* clear */
-				noMask, $51, 0, 20;		/* = */
-				noMask, $4B, 0, 20;		/* / */
-				noMask, $43, 0, 20;		/* * */
-			};
-
-			{ {21, 41} }, {
-				noMask, $52, 130, 150;	/* 0 */
-			};
-
-			{ {41, 21} }, {
-				noMask, $4C, 110, 210;	/* enter */
-			};
-		}
-	};
-
-
-
-// Domestic Norsi (Apple Adjustable) keyboard     				<17>  10/22/92  JMF
-
-	resource 'KCAP' ($10) {
-		{60, 45, 240, 435},
-		{12, 42, 36, 348},
-		{
-			{ {21, 21} }, {
-				noMask, $35, 50, 10;	/* escape */
-				noMask, $12, 0, 70;		/* 1 ! */
-				noMask, $13, 0, 20;		/* 2 @ */
-				noMask, $14, 0, 20;		/* 3 # */
-				noMask, $15, 0, 20;		/* 4 $ */
-				noMask, $17, 0, 20;		/* 5 % */
-				noMask, $16, 0, 40;		/* 6 ^ */
-				noMask, $1A, 0, 20;		/* 7 & */
-				noMask, $1C, 0, 20;		/* 8 * */
-				noMask, $19, 0, 20;		/* 9 ( */
-				noMask, $1D, 0, 20;		/* 0 ) */
-				noMask, $1B, 0, 20;		/* - _ */
-				noMask, $18, 0, 20;		/* = + */
-				noMask, $1E, 20, 10;	/* ] } */
-				noMask, $21, 0, -20;	/* [ { */
-				noMask, $23, 0, -20;	/* P */
-				noMask, $1F, 0, -20;	/* O */
-				noMask, $22, 0, -20;	/* I */
-				noMask, $20, 0, -20;	/* U */
-				noMask, $10, 0, -20;	/* Y */
-				noMask, $11, 0, -40;	/* T */
-				noMask, $0F, 0, -20;	/* R */
-				noMask, $0E, 0, -20;	/* E */
-				noMask, $0D, 0, -20;	/* W */
-				noMask, $0C, 0, -20;	/* Q */
-				noMask, $00, 20, 5;		/* A */
-				noMask, $01, 0, 20;		/* S */
-				noMask, $02, 0, 20;		/* D */
-				noMask, $03, 0, 20;		/* F */
-				noMask, $05, 0, 20;		/* G */
-				noMask, $04, 0, 40;		/* H */
-				noMask, $26, 0, 20;		/* J */
-				noMask, $28, 0, 20;		/* K */
-				noMask, $25, 0, 20;		/* L */
-				noMask, $29, 0, 20;		/* ; : */
-				noMask, $27, 0, 20;		/* ' " */
-				noMask, $7E, 20, 45;	/* up arrow */
-				noMask, $2C, 0, -55;	/* / ? */
-				noMask, $2F, 0, -20;	/* . > */
-				noMask, $2B, 0, -20;	/* , < */
-				noMask, $2E, 0, -20;	/* M */
-				noMask, $2D, 0, -20;	/* N */
-				noMask, $0B, 0, -40;	/* B */
-				noMask, $09, 0, -20;	/* V */
-				noMask, $08, 0, -20;	/* C */
-				noMask, $07, 0, -20;	/* X */
-				noMask, $06, 0, -20;	/* Z */
-				noMask, $7B, 20, 215;	/* left arrow */
-				noMask, $7C, 0, 20;		/* right arrow */
-				noMask, $7D, 0, 20;		/* down arrow */
-			};
-
-			{ {21, 26} }, {
-				noMask, $3A, 130, 80;	/* option */
-				noMask, $37, 0, 215;	/* right command */
-			};
-
-			{ {21, 31} }, {
-				noMask, $32, 50, 50;	/* ` ~ */
-				noMask, $3B, 80, 0;		/* control */
-				noMask, $37, 0, 55;		/* left command */
-				noMask, $2A, -60, 245;	/* \ | */
-			};
-
-			{ {21, 36} }, {
-				noMask, $38, 110, 325;	/* right shift */
-			};
-			
-			{ {21, 41} }, {
-				noMask, $30, 70, 50;	/* tab */
-				noMask, $33, -20, 290;	/* backspace */
-			};
-			
-			{ {21, 46} }, {
-				noMask, $39, 90, 50;	/* caps lock */
-				noMask, $24, 0, 285;	/* return */
-			};
-
-			{ {21, 56} }, {
-				noMask, $38, 110, 50;	/* left shift */
-			};
-
-			{ {31, 141} }, {
-				noMask, $31, 140, 145	/* space */
-			};
-
-		}
-	};
-
-
-
-// ISO Norsi (Apple Adjustable) keyboard     				<17>  10/22/92  JMF
-
-	resource 'KCAP' ($11) {
-		{60, 45, 240, 435},
-		{12, 42, 36, 348},
-		{
-			{ {21, 21} }, {
-				noMask, $35, 50, 10;	/* escape */
-				noMask, $12, 0, 70;		/* 1 ! */
-				noMask, $13, 0, 20;		/* 2 @ */
-				noMask, $14, 0, 20;		/* 3 # */
-				noMask, $15, 0, 20;		/* 4 $ */
-				noMask, $17, 0, 20;		/* 5 % */
-				noMask, $16, 0, 40;		/* 6 ^ */
-				noMask, $1A, 0, 20;		/* 7 & */
-				noMask, $1C, 0, 20;		/* 8 * */
-				noMask, $19, 0, 20;		/* 9 ( */
-				noMask, $1D, 0, 20;		/* 0 ) */
-				noMask, $1B, 0, 20;		/* - _ */
-				noMask, $18, 0, 20;		/* = + */
-				noMask, $1E, 20, 10;	/* ] } */
-				noMask, $21, 0, -20;	/* [ { */
-				noMask, $23, 0, -20;	/* P */
-				noMask, $1F, 0, -20;	/* O */
-				noMask, $22, 0, -20;	/* I */
-				noMask, $20, 0, -20;	/* U */
-				noMask, $10, 0, -20;	/* Y */
-				noMask, $11, 0, -40;	/* T */
-				noMask, $0F, 0, -20;	/* R */
-				noMask, $0E, 0, -20;	/* E */
-				noMask, $0D, 0, -20;	/* W */
-				noMask, $0C, 0, -20;	/* Q */
-				noMask, $00, 20, 5;		/* A */
-				noMask, $01, 0, 20;		/* S */
-				noMask, $02, 0, 20;		/* D */
-				noMask, $03, 0, 20;		/* F */
-				noMask, $05, 0, 20;		/* G */
-				noMask, $04, 0, 40;		/* H */
-				noMask, $26, 0, 20;		/* J */
-				noMask, $28, 0, 20;		/* K */
-				noMask, $25, 0, 20;		/* L */
-				noMask, $29, 0, 20;		/* ; : */
-				noMask, $27, 0, 20;		/* ' " */
-				noMask, $2A, 0, 20;		/* \ | */
-				noMask, $7E, 20, 25;	/* up arrow */
-				noMask, $2C, 0, -55;	/* / ? */
-				noMask, $2F, 0, -20;	/* . > */
-				noMask, $2B, 0, -20;	/* , < */
-				noMask, $2E, 0, -20;	/* M */
-				noMask, $2D, 0, -20;	/* N */
-				noMask, $0B, 0, -40;	/* B */
-				noMask, $09, 0, -20;	/* V */
-				noMask, $08, 0, -20;	/* C */
-				noMask, $07, 0, -20;	/* X */
-				noMask, $06, 0, -20;	/* Z */
-				noMask, $32, 0, -20;	/* ` ~ */
-				noMask, $7B, 20, 235;	/* left arrow */
-				noMask, $7C, 0, 20;		/* right arrow */
-				noMask, $7D, 0, 20;		/* down arrow */
-			};
-
-			{ {21, 26} }, {
-				noMask, $3A, 130, 80;	/* option */
-				noMask, $37, 0, 215;	/* right command */
-			};
-
-			{ {21, 31} }, {
-				noMask, $0A, 50, 50;	/* ISO */
-				noMask, $3B, 80, 0;		/* control */
-				noMask, $37, 0, 55;		/* left command */
-			};
-
-			{ {21, 36} }, {
-				noMask, $38, 110, 50;	/* left shift */
-				noMask, $38, 0, 275;	/* right shift */
-			};
-			
-			{ {21, 41} }, {
-				noMask, $30, 70, 50;	/* tab */
-				noMask, $33, -20, 290;	/* backspace */
-			};
-			
-			{ {21, 46} }, {
-				noMask, $39, 90, 50;	/* caps lock */
-			};
-
-			{ {31, 141} }, {
-				noMask, $31, 140, 145	/* space */
-			};
-
-			{ {21, 31}; {41, 5} }, {
-				noMask, $24, 70, 350;	/* return */
-			};
-
-		}
-	};
 	
 #endif
 
diff --git a/OS/Keyboard/KbdInstall.a b/OS/Keyboard/KbdInstall.a
--- a/OS/Keyboard/KbdInstall.a
+++ b/OS/Keyboard/KbdInstall.a
@@ -16,10 +16,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<4>	 	10/22/92	JMF		Added changes so that the modifiers of the last KEYBOARD
-;									pressed are the modifiers that the Norsi KEYPAD uses,
-;									since the KEYPAD has no modifier keys of its own.
-;		<3>		10/22/92	JMF		Incorporated ROM keyboard Driver into ADBS Resource ID=2.
 ;		<2>		12/28/89	dba		Used MAIN instead of PROC to get dead code stripping.
 ;	  <1.1>	 	 8/28/89	SES		Removed references to nFiles.
 ;	  <1.0>		11/16/88	CCH		Added to EASE.
@@ -83,10 +79,6 @@ keypadNorsi	EQU		$0E					; Handler ID for Norsi ergonomic keypad
 
 KbdInst		MAIN	EXPORT
 
-			BRA.S	@Start				; Branch around version number
-			
-			DC.W	$0001				; Version number
-			
 @Start		MOVEM.L	D3-D7/A2-A4, -(SP)	; Save the registers
 			LINK	A6, #KISize			; Save space on stack
 
@@ -96,10 +88,9 @@ KbdInst		MAIN	EXPORT
 			_GetADBInfo
 
 			ADDQ.L	#2, SP				; Discard OrigAddr and DeviceType
-			MOVE.L	4(SP), A0			; Put the data address in A0
-			MOVE.L	A0, D0				; See if it is a real address
-			BEQ.S	@AllocBuf			; Skip DisposPtr, if no buffer allocated yet
-			_DisposPtr					; Dispose of data allocated by the ROM
+			MOVE.L	4(SP), A1			; Put the data address in A1
+			MOVE.L	A1, D0				; See if it is a real address
+			BNE.S	KCHRLoad			; Buffer already allocated by ROM
 
 @AllocBuf	MOVE.L	#KbdDSize, D0		; Amount of space needed for new keyboard drvr data
 			_NewPtr	,SYS,CLEAR			; Get a pointer
@@ -180,8 +171,6 @@ GotKMAP
 
 			MOVE.W	D2, D0				; ADB Address
 			MOVE.L	A1, 4(SP)			; Replace the data address
-			LEA		KbdDrvr, A0			
-			MOVE.L	A0, (SP)
 			MOVE.L	SP, A0				; Pointer to two addresses
 			_SetADBInfo
 
@@ -208,350 +197,14 @@ Done
 			UNLK	A6					;							
 			MOVEM.L	(SP)+, D3-D7/A2-A4	; Restore the registers		
 
+			LEA		KbdInst,A0
+			_RecoverHandle
+			_DisposeHandle
+
 			RTS							; End KbdInst
 
 
 
-;_________________________________________________________________________________________
-;
-; Routine:		KbdDrvr 
-; Arguments:	D0.B	ADB Command
-;				A0.L	ADB Buffer address
-;				A1.L	ADB Completion Routine Address (= KbdServ)
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function:		Reads buffer and posts keyboard events as appropriate.
-; Side Effects:	Trashes A0, A1, D0, D1, D2, D3
-;
-;_________________________________________________________________________________________
-
-KbdDrvr		MOVE.L	A2, D3				; See if A2 actually contains a pointer
-			BEQ		KbdDone				; If not, can't go on.
-
-			MOVE.L	A0, A1				; Save A0 in A1
-			LSR.W	#4, D0				; Shift ADB Address down to low nibble
-			MOVEQ	#$F, D1				; Mask for ADB Address
-			AND.L	D1, D0				; D0 now contains ADB Address
-			MOVE.L	D0, D3				; Save it in D3
-			LEA		-10(SP), SP			; Build parameter block on stack
-			MOVE.L	SP, A0				; Point to it
-			_GetADBInfo
-
-			ROR.L	#8, D3				; Rotate ADB Address to high byte
-			MOVE.W	(SP)+, D3			; Put Device Type, Orig Addr in low word
-			ADDQ.L	#8, SP				; Clear off the rest of the stack
-			SWAP	D3					; D3 is now Device Type;Orig Addr;ADB Addr;Unused
-
-			MOVE.B	1(A1), D0			; Get first stroke
-			MOVE.B	2(A1), -(SP)		; Save second one on stack
-			BSR.S	KeyIn
-			MOVE.B	(SP)+, D0			; Get second stroke
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		KeyIn
-; Arguments:	D0.B	Raw Keycode
-;				D3.L	Device Type, Orig Addr, ADB Addr, Unused
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function		Translates keycode and posts event as appropriate.
-; Side Effects:	Trashes A0, A1, D0, D1, D2, D3
-; Called From:	KbdDrvr twice, (1 BSR, 1 fall-through)
-;
-;_________________________________________________________________________________________
-
-KeyIn		CMP.B	#$FF, D0			; Is it not a key?
-			BEQ 	KbdDone				; Skip if so
-
-			CLR.W	KeyLast				; Stop repeating
-			CLR.W	HiKeyLast			; Stop repeating
-
-			MOVEQ	#$7F, D1			; Mask = 01111111 binary
-			AND.B	D0, D1				; Clear all but low 7 bits
-
-			MOVE.L	KMAPPtr(A2), A1		; Get KMAP table address
-			MOVE.B	KMstart(A1, D1), D3	; Get device independent keycode
-			BPL.S	NoExcept			; Handle normally if high bit clear
-
-	; An exception has been indicated.  Find the correct entry in the exception
-	; table and handle as appropriate.
-			BCLR	#7, D3				; Clear the high bit
-			LEA		KMnumEx(A1), A0		; Get to the beginning of the exceptions
-			MOVE.W	(A0)+, D2			; Number of entries in table
-			BEQ.S	NoExcept			; Skip if none
-			SUBQ.W	#1, D2				; Turn it into a zero-based count
-
-ExLoop
-			CMP.B	(A0)+, D0			; See if this is the one
-			BEQ		FoundEx				; Skip if so
-			MOVE.B	1(A0), D1			; Get the string length
-			LEA		2(A0, D1), A0		; Point to the next entry
-			DBRA	D2, ExLoop			; Go around again
-
-NoExcept
-			MOVEQ	#0, D2				; Clear out D2
-			MOVE.B	D3, D2				; Copy virtual keycode to D2
-			LSR.W	#3, D2				; Divide by 8 for byte offset
-
-			TST.B	D0					; Up or down key?
-			BMI.S	KeyUp				; Skip around if key up
-			BSET	D3, KeyBits(A2, D2)	; Set it for key down
-			BRA.S	Hammer
-KeyUp
-			BCLR	D3, KeyBits(A2, D2)	; Clear it for key up
-			BSET	#7, D3				; Remember key up for raw key.
-
- ;* Begin Norsi Keypad changes (keypad uses modifiers from last keyboard pressed) 04/21/92* 
-Hammer		MOVE.L	D3, D0				; Get Device Type, Orig Addr, ADB Addr, keycode
-			ROL.L	#8, D0				; Rotate Device Type into low byte
-			CMP.B	#keypadNorsi, D0	; Is this a Norsi ergonomic KEYPAD?
-			BNE.S	HammerKeyMap		; If not, go update the keymap
-			MOVE.W	KeyMap+6, D0		; Modifier bits of last pressed keyboard  
-			AND.W	#$807F,D0			; Mask off non-modifier bits
-			MOVE.W	KeyBits+6(A2), D1	; Get Norsi KEYPAD's pseudo modifier bits
-			AND.W	#$7F80,D1			; Mask off KEYPAD's old modifier bits
-			OR.W	D0, D1				; Replace KEYPAD's modifier bits with the modifier
-			MOVE.W	D1, KeyBits+6(A2)	;  bits from the last pressed keyboard
- ;* End Norsi Keypad changes (keypad uses modifiers from last keyboard pressed) 04/21/92* 
-			
-HammerKeyMap			
-			MOVEM.L	KeyBits(A2), D0-D2/A0	; Get current devices map of key pressed or not
-			MOVEM.L	D0-D2/A0, KeyMap		; Hammer this devices map into global keymap
-			MOVE.L	D3, D0					; Bits 15-8 contain ADB address
-			LSR.L	#8, D0					; Put it in the low byte
-			MOVE.B	D0, KbdLast				; Stuff it down
-			SWAP	D0						; Now get DeviceType
-			MOVE.B	D0, KbdType				; Update KbdType to show last one used
-	
-	; The next two instructions build the byte of modifier flags from the
-	; global key state information.  This works because the modifier flags
-	; exist in bits $37 to $3E, which appear in the following manner:
-	; Byte	|			6			|			7			|
-	; Bit	|37 36 35 34 33 32 31 30|3F 3E 3D 3C 3B 3A 39 38|
-	;		|^^						|	^^ ^^ ^^ ^^ ^^ ^^ ^^|
-			MOVE.W	KeyBits+6(A2), D0	; Get modifier word
-			ROL.W	#1, D0				; Rotate in command key
-
-			SUBQ.L	#4, SP				; Make room for result
-			MOVE.L	KCHRPtr(A2), -(SP)	; Push address of KCHR resource
-			MOVE.W	D3, -(SP)			; Push keycode (w/o modifiers)
-			MOVE.B	D0, (SP)			; Put modifiers where they belong
-			PEA		DeadKey(A2)			; Push address of dead key state
-			_KeyTrans
-
-			MOVE.W	(SP)+, D0			; Get the high word first
-			BEQ.S	NextWord			; Skip if null
-			BSR.S	PostIt				; Otherwise post the event
-NextWord
-			MOVE.W	(SP)+, D0			; Get the other word
-			BEQ.S	KbdDone				; If null, we're done
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		PostIt
-; Arguments:	D0.W	ASCII Code
-;				D3.W	ADB Address in high byte and raw keycode in low byte
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function		Posts the keyboard event as appropriate.
-; Side Effects:	Trashes A0, D0, D1
-; Called From:	KeyIn twice, (1 BSR, 1 fall-through)
-;
-;_________________________________________________________________________________________
-
-PostIt		ROR.W	#8, D0				; Swap ASCII high and low byte (xxLH)
-			SWAP	D0					; Move to high word (LHxx)
-			MOVE.W	D3, D0				; Move in ADB address and raw keycode (LHFR)
-			ROL.L	#8, D0				; Rotate around (HFRL)
-
-			TST.B	D3					; Key up or down?
-			BMI.S	PostKeyUp			; Skip if key up
-			MOVE.L	Ticks, D1
-			MOVE.L	D1, KeyTime			; Mark the time for auto repeat
-			MOVE.L	D1, KeyRepTime
-			MOVE.W	D0, KeyLast			; Save event message
-			SWAP	D0
-			MOVE.W	D0, HiKeyLast		; Save high word too
-			SWAP	D0
-			MOVE	#KeyDwnEvt, A0		; Get event number
-			_PostEvent					; Post it
-KbdDone
-			RTS							; And leave
-PostKeyUp
-			MOVE	#KeyUpEvt, A0		; Get event number
-			BCLR	#15, D0				; Clear the up/down bit in the raw keycode
-			_PostEvent					; Post it
-			RTS							; End KbdDrvr
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		FoundEx
-; Arguments:	A0.L	Pointer to exception data
-;				A2.L	Pointer to private data area
-;				D3.W	Virtual keycode
-; Output:		None
-; Function		An exception exists for this particular keystroke.  Process it 
-;				appropriately.
-; Side Effects:	Trashes A0, D0, D1, D2
-; Called From:	KeyIn twice, (1 BSR, 1 fall-through)
-;
-;_________________________________________________________________________________________
-FoundEx
-			MOVE.B	(A0)+, D1			; Get the operand
-			BPL.S	@notXORKey			; Skip if not
-
-			MOVEQ	#0, D2				; Clear out D2
-			MOVE.B	D3, D2				; Copy virtual keycode to D2
-			LSR.W	#3, D2				; Divide by 8 for byte offset
-			BTST	D3, KeyBits(A2, D2)	; Get current key state
-			SEQ		D0					; Invert and put in D0
-
-@notXORKey
-			MOVEQ	#$F, D2				; Prepare mask for ADB op
-			AND.B	D1, D2				; D2 is ADB op w/o net address
-			BEQ.S	KbdDone				; If ADB op = 0 (Bus Reset), ignore key
-
-			TST.B	KNoADBOp(A2)		; See if we should even do this
-			BNE		NoExcept			; Skip if not
-			MOVEM.L	D0/A1, -(SP)		; Save D0 & A1
-			MOVE.L	A0, -(SP)			; Data address = mask
-			CMP.B	#TalkCmd, D2		; Is it a talk command?
-			BGE.S	@kbdTalk			; Skip if so
-			PEA		KbdBufFree			; Completion routine = KbdBufFree
-			BRA.S	@kbdBufAlloc
-@kbdTalk
-			PEA		KbdListen			; Completion Routine = KbdListen
-
-@kbdBufAlloc
-			LEA		KNumBufs(A2), A1	; Point to the number of available buffers
-			MOVE.B	(A1)+, D1			; Get the number of buffers
-			BEQ.S	@kNoBufAvail		; Skip if none available
-			SUBQ.W	#1, D1				; Turn it into a zero based count
-@kBufLoop
-			TST.B	(A1)+				; Is the buffer busy?
-			BEQ.S	@kGotABuf			; No, Go use it
-			LEA		KBufLen-1(A1), A1	; Point to the next one
-			DBRA	D1, @kBufLoop		; Go around again
-			BRA.S	@kNoBufAvail		; It's a loss
-
-@kGotABuf
-			MOVE.B	D0, -1(A1)			; Store the up/down state in the busy info
-			BSET	#1, -1(A1)			; Make sure it shows up as busy
-			MOVE.L	A1, -(SP)			; Buffer Address
-
-			MOVE.B	(A0), D1			; Get length of source string
-			CMP.B	#8, D1				; Greater than 8?
-			BLS.S	@kStrCopyLoop		; If not, no problem
-			MOVEQ	#8, D1				; Copy only the first 8 to avoid trashing mem
-@kStrCopyLoop
-			MOVE.B	(A0)+, (A1)+		; Start copying the string
-			DBRA	D1, @kStrCopyLoop	; Repeat D1+1 times
-
-			MOVE.W	D3, D0				; Get the FDB Address
-			CLR.B	D0					; Clear out the low byte
-			LSR.W	#4, D0				; Shift it down to form high nibble of ADB Command
-			OR.B	D2, D0				; Include low op nibble
-			MOVE.L	SP, A0				; Point to parameter block
-			_ADBOp						; Pray that everything is OK
-			BNE.S	@kOpFailed			; Branch if not
-			ADDQ.L	#4, SP				; Pop Buffer Address
-@kNoBufAvail
-			ADDQ.L	#8, SP				; Pop Completion and Data Address
-			MOVEM.L	(SP)+, D0/A1		; Restore D0 & A1
-			BRA		NoExcept			; Finish dealing with the keystroke
-
-@kOpFailed
-			MOVE.L	(SP)+, A1			; Get the buffer address
-			CLR.B	-1(A1)				; Mark it as not busy
-			BRA.S	@kNoBufAvail		; End FoundEx
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		KbdListen
-; Arguments:	D0.B	ADB Command
-;				D1.L	DeviceType, OrigAddr, ADBAddr, Unused (byte order)
-;				A0.L	ADB Buffer Address
-;				A1.L	ADB Completion Routine Address (= KbdListen)
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function:		Sets or clears bits in mask pointed to by A2 in buffer pointed
-;				to by A0.  Used to alter values of registers in ADB devices.
-; Side Effects:	Trashes A0, A1, A2, D0, D1, D2
-;
-;_________________________________________________________________________________________
-
-KbdListen	MOVE.L	A0, A1				; Copy A0 into A1
-			MOVEQ	#0, D1				; Clear out D1
-			MOVE.B	(A1)+, D1			; Get length of buffer
-			MOVE.B	(A2)+, D2			; Get length of mask
-			CMP.B	D2, D1				; Is mask length smaller?
-			BLS.S	@notSmall			; Skip if not
-			MOVE.B	D2, D1				; Use the mask length instead
-@notSmall
-; (A2) is a mask for (A0), 0 meaning don't change, 1 meaning clear or set
-; depending upon the value of -1(A0).
-			TST.B	-1(A0)				; PL = clear, MI = set
-			BPL.S	@endClrLoop
-			BRA.S	@endSetLoop
-
-@setLoop
-			MOVE.B	(A2)+, D2			; Get the mask byte
-			OR.B	D2, (A1)+			; Set the correct bits
-@endSetLoop
-			DBRA	D1, @setLoop		; Go around again
-			BRA.S	@kLoopDone
-
-@clrLoop
-			MOVE.B	(A2)+, D2			; Get the mask byte
-			NOT.B	D2					; Invert it
-			AND.B	D2, (A1)+			; Clear the correct bits
-@endClrLoop
-			DBRA	D1, @clrLoop		; Go around again
-
-@kLoopDone
-			CLR.L	-(SP)				; No data address needed
-			PEA		KbdBufFree			; Completion routine = KbdBufFree
-			MOVE.L	A0, -(SP)			; Use the buffer one more time
-			MOVE.L	SP, A0				; Point to parameter block
-			BCLR	#2, D0				; Turn the talk into a listen command
-			_ADBOp
-			BNE.S	@kLSuccess			; Branch on success
-
-			MOVE.L	(SP), A0			; Get the buffer address
-			CLR.B	-1(A0)				; Mark it as not busy
-@kLSuccess
-			LEA		12(SP), SP			; Pop the parameter block
-			RTS							; End KbdListen
-
-
-
-;_________________________________________________________________________________________
-;
-; Routine:		KbdBufFree
-; Arguments:	D0.B	ADB Command
-;				D1.L	DeviceType, OrigAddr, ADBAddr, Unused (byte order)
-;				A0.L	ADB Buffer Address
-;				A1.L	ADB Completion Routine Address (= KbdListen)
-;				A2.L	Pointer to private data area
-; Output:		None
-; Function:		Marks the buffer pointed to by A0 as free.
-; Side Effects:	None
-;
-;_________________________________________________________________________________________
-
-KbdBufFree	CLR.B	-1(A0)		; Mark buffer free
-			RTS					; End KbdBufFree
-
-
-
 ;_________________________________________________________________________________________
 ;_________________________________________________________________________________________
 ;_________________________________________________________________________________________
diff --git a/OS/MMU/MMUPatches.a b/OS/MMU/MMUPatches.a
--- a/OS/MMU/MMUPatches.a
+++ b/OS/MMU/MMUPatches.a
@@ -41,8 +41,8 @@ DontDoMuchSwappingOfTheMMUMode PatchProc _SwapMMUMode,(Plus,SE,Portable)
 			machine	mc68020
 
 			ROMs II,hasHMMU,notAUX
-			MakePatch SwapHMMU,jSwapMMU
 			MakePatch SwapHMMU,_SwapMMUMode
+			MakePatch SwapHMMU,jSwapMMU
 
 ;   SwapHMMU - switches HMMU between 24 & 32 bit modes.
 ;
diff --git a/OS/MemoryMgr/MemoryMgrPatches.a b/OS/MemoryMgr/MemoryMgrPatches.a
--- a/OS/MemoryMgr/MemoryMgrPatches.a
+++ b/OS/MemoryMgr/MemoryMgrPatches.a
@@ -9,11 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	 6/14/93	kc		Roll in Ludwig.
-;	   <LW2>	 5/11/93	chp		MoveHLow was depending on the CCR to indicate error conditions
-;									reported by _RecoverHandle. This weirdass trap only returns its
-;									result in MemErr, so insert an explicit test to avoid crashing
-;									in the subsequent _HGetState. Partial fix for RADAR #1081681.
 ;		<17>	  6/8/92	JSM		In TheFuture, use emResrvMemSemaphore from ExpandMem in the
 ;									ResrvMemGrowSystemHeap patch instead of defining the semaphore
 ;									in code space here.
@@ -672,7 +667,6 @@ MakeBlocksNonPurgeable
 		move.l	a3,a0							;set up pointer to block
 		_RecoverHandle							;if this fails, then this block is
 												;orphaned, and we can move it at will
-		tst.w	MemErr							;(RecoverHandle result in MemErr only!)			<LW2>
 		bmi.s	@pastFreeSpaceChecks			;
 
 	;if already locked, we don’t need to change its state
diff --git a/OS/PPC/PPCBrowser.c b/OS/PPC/PPCBrowser.c
--- a/OS/PPC/PPCBrowser.c
+++ b/OS/PPC/PPCBrowser.c
@@ -11,10 +11,7 @@
 
 	Change History (most recent first):
 
-	   <SM2>	11/18/92	GMA		Set RomMapInsert to mapTrue before caliing GetResource on 'ppcc'
-									-5856. we are trying to move these resources into ROM
-									eventually.
-		<36>	 10/2/90	JAL		Changed all occurances of GetMyZone to PPCGetMyZone because of conflict 
+SM2		<36>	 10/2/90	JAL		Changed all occurances of GetMyZone to PPCGetMyZone because of conflict 
 									with new AppleTalk Phase II.  Screwed up version <35>.
 		<34>	 9/21/90	JSM		Update to use new "real" PPCToolbox.h (I checked, it generates
 									exactly the same object code as the last revision.)
@@ -265,7 +262,6 @@ MyPPCBrowser(const Str255 prompt, const Str255 applListLabel, Boolean defaultSpe
 	globs->thePortInfo = thePortInfo;
 	
 	/* get NBP and PPC parameters from configuration resource */
-	ROMMapInsert = mapTrue;								// <SM2> <GMA>
 	h = GetResource(BrowseConfigType, BrowseConfigID);
 	if (h)
 	{
diff --git a/OS/PPC/PPCDsp.c b/OS/PPC/PPCDsp.c
new file mode 100644
--- /dev/null
+++ b/OS/PPC/PPCDsp.c
@@ -0,0 +1,485 @@
+#ifndef __TYPES__
+#include <Types.h>
+#endif
+
+#ifndef __FILES__
+#include <Files.h>
+#endif
+
+#ifndef __MEMORY__
+#include <Memory.h>
+#endif
+
+#ifndef __ERRORS__
+#include <Errors.h>
+#endif
+
+#ifndef __RESOURCES__
+#include <Resources.h>
+#endif
+
+#ifndef __TOOLUTILS__
+#include <ToolUtils.h>
+#endif
+
+#ifndef __OSUTILS__
+#include <OSUtils.h>
+#endif
+
+#ifndef __DEVICES__
+#include <Devices.h>
+#endif
+
+#ifndef __POWER__
+#include <Power.h>
+#endif
+
+#include <BTEqu.h>
+#include "UserGroup.h"
+
+#ifndef __APPLETALK__
+#include <AppleTalk.h>
+#endif
+
+#ifndef __ADSP__
+#include "ADSP.h"
+#endif
+
+#ifndef __PPCTOOLBOX__
+#include <PPCToolBox.h>
+#endif
+
+#ifndef __STDDEF__
+#include <StdDef.h>
+#endif
+
+#include "PPCCommon.h"
+
+
+OSErr OpenADSPDriver(short *refNum) //26cc4
+{
+// ROM:00126CC4                 link    a6,#0
+// ROM:00126CC8                 subq.l  #2,sp
+// ROM:00126CCA                 pea     unk_126CDC
+// ROM:00126CCE                 move.l  8(a6),-(sp)
+// ROM:00126CD2                 ori.b   #$D7,d0
+// ROM:00126CD6                 move.w  (sp)+,d0
+// ROM:00126CD8                 unlk    a6
+// ROM:00126CDA                 rts
+	return OpenDriver("\p.DSP", refNum);
+}
+
+OSErr CreateConnectionListener(Ptr ccbPtr, //8
+							   DSPParamBlock *dsp, //c
+							   unsigned short dspDrvrRef, //10
+							   unsigned char  socket, //12
+							   Boolean  async, //14
+							   ProcPtr  compRoutine) //16 //26ce2
+{
+// ROM:00126CE2
+// ROM:00126CE2                 link    a6,#0
+// ROM:00126CE6                 movem.l a3-a4,-(sp)
+// ROM:00126CEA                 movea.l $C(a6),a3
+// ROM:00126CEE                 lea     $22(a3),a4
+// ROM:00126CF2                 move.w  $12(a6),$18(a3)
+// ROM:00126CF8                 move.w  #$FB,$1A(a3)
+// ROM:00126CFE                 move.l  $1C(a6),$C(a3)
+// ROM:00126D04                 move.l  8(a6),(a4)
+// ROM:00126D08                 moveq   #0,d0
+// ROM:00126D0A                 move.l  d0,4(a4)
+// ROM:00126D0E                 clr.w   8(a4)
+// ROM:00126D12                 clr.w   $E(a4)
+// ROM:00126D16                 move.l  d0,$A(a4)
+// ROM:00126D1A                 move.l  d0,$10(a4)
+// ROM:00126D1E                 move.l  d0,$14(a4)
+// ROM:00126D22                 move.b  $17(a6),$18(a4)
+// ROM:00126D28                 move.l  a3,-(sp)
+// ROM:00126D2A                 subq.l  #2,sp
+// ROM:00126D2C                 move.l  a3,-(sp)
+// ROM:00126D2E                 move.b  $1B(a6),-(sp)
+// ROM:00126D32                 ori.b   #$DF,d5
+// ROM:00126D36                 move.w  (sp)+,d0
+// ROM:00126D38                 ext.l   d0
+// ROM:00126D3A                 move.l  d0,-(sp)
+// ROM:00126D3C                 ori.b   #$20,d0         ; jsr DMFix
+// ROM:00126D40                 movem.l -8(a6),a3-a4
+// ROM:00126D46                 unlk    a6
+// ROM:00126D48                 rts
+	struct TRinitParams *params = &(dsp->u.initParams);
+
+	dsp->ioCRefNum = dspDrvrRef;
+	dsp->csCode = dspCLInit;
+	dsp->ioCompletion = compRoutine;
+
+	params->ccbPtr = ccbPtr;
+	params->userRoutine = NULL;
+	params->sendQSize = 0;
+	params->recvQSize = 0;
+	params->sendQueue = NULL;
+	params->recvQueue = NULL;
+	params->attnPtr = NULL;
+	params->localSocket = socket;
+
+	return DMFix(PBControl(dsp, async), dsp);
+}
+
+OSErr ListenConnectionRequest(DSPParamBlock *dsp,
+							  Boolean async,
+							  ProcPtr compRoutine) //26d4a
+{
+// ROM:00126D4A                 link    a6,#0
+// ROM:00126D4E                 movem.l a3-a4,-(sp)
+// ROM:00126D52                 movea.l 8(a6),a4
+// ROM:00126D56                 lea     $22(a4),a3
+// ROM:00126D5A                 move.w  #$F9,$1A(a4)
+// ROM:00126D60                 move.l  $10(a6),$C(a4)
+// ROM:00126D66                 clr.b   $A(a3)
+// ROM:00126D6A                 clr.w   8(a3)
+// ROM:00126D6E                 clr.b   $B(a3)
+// ROM:00126D72                 move.l  a4,-(sp)
+// ROM:00126D74                 subq.l  #2,sp
+// ROM:00126D76                 move.l  a4,-(sp)
+// ROM:00126D78                 move.b  $F(a6),-(sp)
+// ROM:00126D7C                 ori.b   #$DF,d5
+// ROM:00126D80                 move.w  (sp)+,d0
+// ROM:00126D82                 ext.l   d0
+// ROM:00126D84                 move.l  d0,-(sp)
+// ROM:00126D86                 ori.b   #$20,d0
+// ROM:00126D8A                 movem.l -8(a6),a3-a4
+// ROM:00126D90                 unlk    a6
+// ROM:00126D92                 rts
+	struct TRopenParams *params = &(dsp->u.openParams);
+
+	dsp->csCode = dspCLListen;
+	dsp->ioCompletion = compRoutine;
+
+	params->filterAddress.aNode = 0;
+	params->filterAddress.aNet = 0;
+	params->filterAddress.aSocket = 0;
+
+	return DMFix(PBControl(dsp, async), dsp);
+}
+
+
+void RejectConnectionRequest(DSPParamBlock *dsp, Boolean async, ProcPtr compRoutine) //26d94
+{
+// ROM:00126D94                 link    a6,#0
+// ROM:00126D98                 move.l  a4,-(sp)
+// ROM:00126D9A                 movea.l 8(a6),a4
+// ROM:00126D9E                 move.l  $10(a6),$C(a4)
+// ROM:00126DA4                 move.w  #$F8,$1A(a4)
+// ROM:00126DAA                 move.l  a4,-(sp)
+// ROM:00126DAC                 subq.l  #2,sp
+// ROM:00126DAE                 move.l  a4,-(sp)
+// ROM:00126DB0                 move.b  $F(a6),-(sp)
+// ROM:00126DB4                 ori.b   #$DF,d5
+// ROM:00126DB8                 move.w  (sp)+,d0
+// ROM:00126DBA                 ext.l   d0
+// ROM:00126DBC                 move.l  d0,-(sp)
+// ROM:00126DBE                 ori.b   #$20,d0
+// ROM:00126DC2                 movea.l -4(a6),a4
+// ROM:00126DC6                 unlk    a6
+// ROM:00126DC8                 rts
+	dsp->ioCompletion = compRoutine;
+	dsp->csCode = dspCLDeny;
+
+	DMFix(PBControl(dsp, async), dsp);
+}
+
+OSErr RemoveConnectionListener(unsigned char abortFlag,
+						  	   Boolean        async,
+						  	   ProcPtr        compRoutine,
+				          	   DSPParamBlock  *dsp) //26dca
+{
+// ROM:00126DCA                 link    a6,#0
+// ROM:00126DCE                 movem.l a3-a4,-(sp)
+// ROM:00126DD2                 movea.l $14(a6),a4
+// ROM:00126DD6                 lea     $22(a4),a3
+// ROM:00126DDA                 move.w  #$FA,$1A(a4)
+// ROM:00126DE0                 move.l  $10(a6),$C(a4)
+// ROM:00126DE6                 move.b  $B(a6),(a3)
+// ROM:00126DEA                 move.l  a4,-(sp)
+// ROM:00126DEC                 subq.l  #2,sp
+// ROM:00126DEE                 move.l  a4,-(sp)
+// ROM:00126DF0                 move.b  $F(a6),-(sp)
+// ROM:00126DF4                 ori.b   #$DF,d5
+// ROM:00126DF8                 move.w  (sp)+,d0
+// ROM:00126DFA                 ext.l   d0
+// ROM:00126DFC                 move.l  d0,-(sp)
+// ROM:00126DFE                 ori.b   #$20,d0
+// ROM:00126E02                 movem.l -8(a6),a3-a4
+// ROM:00126E08                 unlk    a6
+// ROM:00126E0A                 rts
+	struct TRcloseParams *params = &(dsp->u.closeParams);
+
+	dsp->csCode = dspCLRemove;
+	dsp->ioCompletion = compRoutine;
+
+	params->abort = abortFlag;
+
+	return DMFix(PBControl(dsp, async), dsp);
+}
+
+OSErr CreateConnectionEnd(TRCCB *ccbPtr,
+						  ProcPtr userRoutine,
+						  unsigned short   sendQSize,
+						  unsigned char    *sendQ,
+                  		  unsigned short   recvQSize,
+						  unsigned char    *recvQ,
+						  unsigned char    *attnPtr,
+						  unsigned char    socket,
+						  short            drvrRef,
+             			  Boolean          async,
+						  ProcPtr          compRoutine,
+						  DSPParamBlock    *dsp) //26e0c
+{
+// ROM:00126E0C                 link    a6,#0
+// ROM:00126E10                 movem.l a3-a4,-(sp)
+// ROM:00126E14                 movea.l $34(a6),a3
+// ROM:00126E18                 lea     $22(a3),a4
+// ROM:00126E1C                 move.w  $2A(a6),$18(a3)
+// ROM:00126E22                 move.w  #$FF,$1A(a3)
+// ROM:00126E28                 move.l  $30(a6),$C(a3)
+// ROM:00126E2E                 move.l  8(a6),(a4)
+// ROM:00126E32                 move.l  $C(a6),4(a4)
+// ROM:00126E38                 move.w  $12(a6),8(a4)
+// ROM:00126E3E                 move.w  $1A(a6),$E(a4)
+// ROM:00126E44                 move.l  $14(a6),$A(a4)
+// ROM:00126E4A                 move.l  $1C(a6),$10(a4)
+// ROM:00126E50                 move.l  $20(a6),$14(a4)
+// ROM:00126E56                 move.b  $27(a6),$18(a4)
+// ROM:00126E5C                 move.l  a3,-(sp)
+// ROM:00126E5E                 subq.l  #2,sp
+// ROM:00126E60                 move.l  a3,-(sp)
+// ROM:00126E62                 move.b  $2F(a6),-(sp)
+// ROM:00126E66                 ori.b   #$DF,d5
+// ROM:00126E6A                 move.w  (sp)+,d0
+// ROM:00126E6C                 ext.l   d0
+// ROM:00126E6E                 move.l  d0,-(sp)
+// ROM:00126E70                 ori.b   #$20,d0
+// ROM:00126E74                 movem.l -8(a6),a3-a4
+// ROM:00126E7A                 unlk    a6
+// ROM:00126E7C                 rts
+	struct TRinitParams *params = &(dsp->u.initParams);
+
+	dsp->ioCRefNum = drvrRef;
+	dsp->csCode = dspInit;
+	dsp->ioCompletion = compRoutine;
+
+	params->ccbPtr = ccbPtr;
+	params->userRoutine = userRoutine;
+	params->sendQSize = sendQSize;
+	params->recvQSize = recvQSize;
+	params->sendQueue = sendQ;
+	params->recvQueue = recvQ;
+	params->attnPtr = attnPtr;
+	params->localSocket = socket;
+
+	return DMFix(PBControl(dsp, async), dsp);
+}
+
+OSErr OpenConnectionEnd(unsigned short remoteCid,
+				        AddrBlock      *remoteAddr,
+						AddrBlock      *filterAddr,
+						unsigned long  sendSeq,
+						unsigned short sendWindow,
+						unsigned long  attnSendSeq,
+						unsigned char  ocMode,
+						Boolean        async,
+						ProcPtr        compRoutine,
+						DSPParamBlock  *dsp) //26e7e
+{
+	PPCGlobalParamsPtr ppcglobPtr = getGlobal();
+	struct PPCConfigInfo *myptr = &(ppcglobPtr->configData);
+
+	struct TRopenParams *params = &(dsp->u.openParams);
+
+	dsp->csCode = dspOpen;
+	dsp->ioCompletion = compRoutine;
+
+	params->remoteAddress.aNet = remoteAddr->aNet;
+	params->remoteAddress.aNode = remoteAddr->aNode;
+	params->remoteAddress.aSocket = remoteAddr->aSocket;
+	params->filterAddress.aNet = filterAddr->aNet;
+	params->filterAddress.aNode = filterAddr->aNode;
+	params->filterAddress.aSocket = filterAddr->aSocket;
+	params->ocMode = ocMode;
+	params->sendSeq = sendSeq;
+	params->sendWindow = sendWindow;
+	params->attnSendSeq = attnSendSeq;
+	params->remoteCID = remoteCid;
+	params->ocInterval = myptr->adspTimeout;
+	params->ocMaximum = myptr->adspRetries;
+
+	return DMFix(PBControl(dsp, async), dsp);
+
+// ROM:00126E7E                 link    a6,#-4
+// ROM:00126E82                 movem.l a3-a4,-(sp)
+// ROM:00126E86                 movea.l $2C(a6),a3
+// ROM:00126E8A                 ori.w   #$9406,a1 // getGlobal
+// ROM:00126E8E                 movea.l d0,a4
+// ROM:00126E90                 lea     $CC(a4),a0
+// ROM:00126E94                 move.l  a0,-4(a6)
+// ROM:00126E98                 lea     $22(a3),a4
+
+// ROM:00126E9C                 move.w  #$FD,$1A(a3)
+// ROM:00126EA2                 move.l  $28(a6),$C(a3)
+
+// ROM:00126EA8                 movea.l $C(a6),a0
+// ROM:00126EAC                 move.w  (a0),4(a4)
+// ROM:00126EB0                 movea.l $C(a6),a0
+// ROM:00126EB4                 move.b  2(a0),6(a4)
+// ROM:00126EBA                 movea.l $C(a6),a0
+// ROM:00126EBE                 move.b  3(a0),7(a4)
+
+// ROM:00126EC4                 movea.l $10(a6),a0
+// ROM:00126EC8                 move.w  (a0),8(a4)
+// ROM:00126ECC                 movea.l $10(a6),a0
+// ROM:00126ED0                 move.b  2(a0),$A(a4)
+// ROM:00126ED6                 movea.l $10(a6),a0
+// ROM:00126EDA                 move.b  3(a0),$B(a4)
+
+// ROM:00126EE0                 move.b  $23(a6),$1E(a4)
+// ROM:00126EE6                 move.l  $14(a6),$C(a4)
+// ROM:00126EEC                 move.w  $1A(a6),$10(a4)
+// ROM:00126EF2                 move.l  $1C(a6),$16(a4)
+// ROM:00126EF8                 move.w  $A(a6),2(a4)
+
+// ROM:00126EFE                 movea.l -4(a6),a0
+// ROM:00126F02                 move.b  8(a0),$1F(a4) adspTimeout
+// ROM:00126F08                 movea.l -4(a6),a0
+// ROM:00126F0C                 move.b  9(a0),$20(a4) adspRetries
+
+// ROM:00126F12                 move.l  a3,-(sp)
+// ROM:00126F14                 subq.l  #2,sp
+// ROM:00126F16                 move.l  a3,-(sp)
+// ROM:00126F18                 move.b  $27(a6),-(sp)
+// ROM:00126F1C                 ori.b   #$DF,d5
+// ROM:00126F20                 move.w  (sp)+,d0
+// ROM:00126F22                 ext.l   d0
+// ROM:00126F24                 move.l  d0,-(sp)
+// ROM:00126F26                 ori.b   #$20,d0
+// ROM:00126F2A                 movem.l -$C(a6),a3-a4
+// ROM:00126F30                 unlk    a6
+// ROM:00126F32                 rts
+}
+
+OSErr RemoveConnectionEnd(unsigned char abortFlag,
+						  Boolean        async,
+						  ProcPtr        compRoutine,
+				          DSPParamBlock  *dsp) //26f34
+{
+	struct TRcloseParams *params = &(dsp->u.closeParams);
+
+	dsp->csCode = dspRemove;
+	dsp->ioCompletion = compRoutine;
+
+	params->abort = abortFlag;
+
+	return DMFix(PBControl(dsp, async), dsp);
+// ROM:00126F34                 link    a6,#0
+// ROM:00126F38                 movem.l a3-a4,-(sp)
+// ROM:00126F3C                 movea.l $14(a6),a4
+// ROM:00126F40                 lea     $22(a4),a3
+// ROM:00126F44                 move.w  #$FE,$1A(a4) dspRemove
+// ROM:00126F4A                 move.l  $10(a6),$C(a4)
+// ROM:00126F50                 move.b  $B(a6),(a3)
+// ROM:00126F54                 move.l  a4,-(sp)
+// ROM:00126F56                 subq.l  #2,sp
+// ROM:00126F58                 move.l  a4,-(sp)
+// ROM:00126F5A                 move.b  $F(a6),-(sp)
+// ROM:00126F5E                 ori.b   #$DF,d5
+// ROM:00126F62                 move.w  (sp)+,d0
+// ROM:00126F64                 ext.l   d0
+// ROM:00126F66                 move.l  d0,-(sp)
+// ROM:00126F68                 ori.b   #$20,d0
+// ROM:00126F6C                 movem.l -8(a6),a3-a4
+// ROM:00126F72                 unlk    a6
+// ROM:00126F74                 rts
+}
+
+
+OSErr WriteToConnection(unsigned short reqCount,
+						unsigned char  *dataPtr,
+						unsigned char  eom,
+						unsigned char  flush,
+						Boolean        async,
+						ProcPtr        compRoutine,
+						DSPParamBlock  *dsp) //26f76
+{
+	struct TRioParams *params = &(dsp->u.ioParams);
+
+	dsp->csCode = dspWrite;
+	dsp->ioCompletion = compRoutine;
+
+	params->reqCount = reqCount;
+	params->dataPtr = dataPtr;
+	params->eom = eom;
+	params->flush = flush;
+
+	return DMFix(PBControl(dsp, async), dsp);
+// ROM:00126F76                 link    a6,#0
+// ROM:00126F7A                 movem.l a3-a4,-(sp)
+// ROM:00126F7E                 movea.l $20(a6),a4
+// ROM:00126F82                 lea     $22(a4),a3
+// ROM:00126F86                 move.w  #$F5,$1A(a4)
+// ROM:00126F8C                 move.l  $1C(a6),$C(a4)
+
+// ROM:00126F92                 move.w  $A(a6),(a3)
+// ROM:00126F96                 move.l  $C(a6),4(a3)
+// ROM:00126F9C                 move.b  $13(a6),8(a3)
+// ROM:00126FA2                 move.b  $17(a6),9(a3)
+
+// ROM:00126FA8                 move.l  a4,-(sp)
+// ROM:00126FAA                 subq.l  #2,sp
+// ROM:00126FAC                 move.l  a4,-(sp)
+// ROM:00126FAE                 move.b  $1B(a6),-(sp)
+// ROM:00126FB2                 ori.b   #$DF,d5
+// ROM:00126FB6                 move.w  (sp)+,d0
+// ROM:00126FB8                 ext.l   d0
+// ROM:00126FBA                 move.l  d0,-(sp)
+// ROM:00126FBC                 ori.b   #$20,d0
+// ROM:00126FC0                 movem.l -8(a6),a3-a4
+// ROM:00126FC6                 unlk    a6
+// ROM:00126FC8                 rts
+}
+
+OSErr ReadFromConnection(unsigned short reqCount,
+						 unsigned char  *dataPtr,
+						 Boolean        async,
+						 ProcPtr        compRoutine,
+						 DSPParamBlock  *dsp) //26fca
+{
+	struct TRioParams *params = &(dsp->u.ioParams);
+
+	dsp->csCode = dspRead;
+	dsp->ioCompletion = compRoutine;
+
+	params->reqCount = reqCount;
+	params->dataPtr = dataPtr;
+
+	return DMFix(PBControl(dsp, async), dsp);
+// ROM:00126FCA                 link    a6,#0
+// ROM:00126FCE                 movem.l a3-a4,-(sp)
+// ROM:00126FD2                 movea.l $18(a6),a4
+// ROM:00126FD6                 lea     $22(a4),a3
+
+// ROM:00126FDA                 move.w  #$F6,$1A(a4)
+// ROM:00126FE0                 move.l  $14(a6),$C(a4)
+
+// ROM:00126FE6                 move.w  $A(a6),(a3)
+// ROM:00126FEA                 move.l  $C(a6),4(a3)
+
+// ROM:00126FF0                 move.l  a4,-(sp)
+// ROM:00126FF2                 subq.l  #2,sp
+// ROM:00126FF4                 move.l  a4,-(sp)
+// ROM:00126FF6                 move.b  $13(a6),-(sp)
+// ROM:00126FFA                 ori.b   #$DF,d5
+// ROM:00126FFE                 move.w  (sp)+,d0
+// ROM:00127000                 ext.l   d0
+// ROM:00127002                 move.l  d0,-(sp)
+// ROM:00127004                 ori.b   #$20,d0
+// ROM:00127008                 movem.l -8(a6),a3-a4
+// ROM:0012700E                 unlk    a6
+// ROM:00127010                 rts
+}
diff --git a/OS/PPC/PPCDsp.c.idump b/OS/PPC/PPCDsp.c.idump
new file mode 100644
--- /dev/null
+++ b/OS/PPC/PPCDsp.c.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/OS/PPC/PPCLoader.c b/OS/PPC/PPCLoader.c
--- a/OS/PPC/PPCLoader.c
+++ b/OS/PPC/PPCLoader.c
@@ -9,9 +9,6 @@
 
 	   <SM6>	  3/9/93	PN		Remove ReQueueInformPB,Insert, Push,InitQueue, TraverseQueue
 									which is no longer used
-	   <SM5>	11/18/92	GMA		Set RomMapInsert to mapTrue before calling GetResource on 'ppci'
-									-16409. we are trying to move these PACK9 resources into ROM
-									eventually.
 		<25>	 4/14/92	BBM		<JSM>: Remove unfinished PPC code that is under the contitional
 									“TheFutute”, and remove the conditional “CubeE” since that is
 									reality. Remove conditionals, since all they do is confuse.
@@ -66,8 +63,6 @@
 #include <Resources.h>						// for mapTrue
 #include <String.h>							// for memset definition
 
-#define	ROMMapInsert	(* (short*) 0xB9E)	// <SM5><GMA>
-
 /*---------------------------------------------------------------------------------------------------
 	Prototypes of functions used only in this file.
 ---------------------------------------------------------------------------------------------------*/
@@ -95,7 +90,6 @@ void ppcLoader (void)
 	{
 		memset(globPtr,0,sizeof(PPCGlobalParams));	// Clear our globals.
 		
-		ROMMapInsert = mapTrue;						// <SM5><GMA>
 		if (( configHdl = GetResource ( 'ppci', -16409)) == NULL)
 			return;
 		configPtr = (PPCConfigInfo *)(*configHdl);
diff --git a/OS/PowerMgr/PowerMgrPatches.a b/OS/PowerMgr/PowerMgrPatches.a
--- a/OS/PowerMgr/PowerMgrPatches.a
+++ b/OS/PowerMgr/PowerMgrPatches.a
@@ -145,6 +145,970 @@ ROMPmgrOp			ROMBind	(IIci,$888ec)
 SlpQInstall			ROMBind (IIci,$8976C)
 SlpQRemove			ROMBind (IIci,$89784)
 SetSupervisorMode	ROMBind (IIci,$89474)
+SomeSleepProc		ROMBind (Portable,$4628)
+
+
+
+Burninate		InstallProc		(Portable)
+				WITH	PmgrRec,pmCommandRec,SleepqRec
+
+				leaResident	WakeQRec,A0
+				leaResident	SCCWakeFix,A1
+
+				MOVE.L	A1,SleepqProc(A0)
+				MOVE.W	#slpQType,SleepqType(A0)
+				CLR.W	SleepqFlags(A0)
+				_SlpQInstall
+
+				LEA		-20(SP),SP
+				MOVE.L	SP,A0
+				MOVE.L	#$10077,D0			; Portable: SleepFlags
+				_ReadXPRam
+				MOVE.B	(A0),D1
+				AND.B	#(1<<RingWakeup)|(1<<TimerWakeup),D1
+				BEQ		@neitherWakeup
+
+				; Set up a PMgr record for rewriting an identical timer value
+				LEA		pmData(SP),A1
+				MOVE.L	A1,pmRBuffer(SP)
+				MOVE.L	A1,pmSBuffer(SP)
+
+				BTST	#TimerWakeup,D1
+				BEQ.S	@noTimerWakeup
+				MOVE.W	#0,pmLength(SP)
+				MOVE.W	#timerRead,pmCommand(SP)
+				MOVE.L	SP,A0
+				_PmgrOp
+				MOVE.W	#4,pmLength(SP)
+				MOVE.W	#timerSet,pmCommand(SP)
+				MOVE.L	SP,A0
+				_PmgrOp
+@noTimerWakeup
+
+				BTST	#RingWakeup,D1
+				BEQ.S	@noRingWakeup
+				MOVE.W	#0,pmLength(SP)
+				MOVE.W	#modemRead,pmCommand(SP)
+				MOVE.L	SP,A0
+				_PmgrOp
+				AND.B	#(1<<ModemPwr)|(1<<ModemAorB)|(1<<RingWakeEnable),(A1)
+				OR.B	#1<<RingWakeEnable,(A1)
+				MOVE.W	#1,pmLength(SP)
+				MOVE.W	#modemSet,pmCommand(SP)
+				MOVE.L	SP,A0
+				_PmgrOp
+@noRingWakeup
+@neitherWakeup
+				LEA		20(SP),SP
+
+
+			movea.l	PmgrBase,a2					; get power mgr globals
+
+
+;PatchBatWatchVBL	
+			lea		BatVBLTask(a2),a0			; get pointer to vbl queue element
+			_VRemove							; remove it from the queue
+			leaResident	BatWatch,a1
+			move.l	a1,vblAddr(a0)
+			move.w	#1,vblCount(a0)				; enable vbl element
+			_Vinstall
+
+
+			MOVE.L	#AccessBase,A0
+			CMP.B	#$AD,(A0)
+			BEQ.S	@noDo
+;PatchSndVBL
+			lea		SwVBLTask(a2),a0			; a0 = ptr to SndWatch VBL queue blk
+			_VRemove							; remove it from the queue
+			leaResident	SndWatch,a1				; a1 = addr of SndWatch resident code
+			move.l	a1,vblAddr(a0)
+			move.w	#1,vblCount(a0)				; enable vbl element
+			_Vinstall
+@noDo
+
+
+; The Power Mgr can compare the current cursor to the watch
+				CLR.L	-(SP)
+				MOVE.L	#'CURS',-(SP)
+				MOVE.W	#4,-(SP)
+				_GetResource
+				MOVE.L	(SP)+,A0
+				MOVE.L	(A0),D0
+				_StripAddress
+				MOVE.L	D0,RAMwatchPtr(A2)
+
+				CLR.L	-(SP)
+				MOVE.L	#'CURS',-(SP)
+				MOVE.W	#4,-(SP)
+				MOVE.W	#MapTrue,ROMMapInsert
+				_GetResource
+				MOVE.L	(SP)+,A0
+				MOVE.L	(A0),D0
+				_StripAddress
+				MOVE.L	D0,ROMwatchPtr(A2)
+
+
+				RTS
+
+
+
+portaPmgrOp		PatchProc	_PmgrOp,(Portable)
+				WITH	PmgrRec,pmCommandRec,SleepqRec
+
+				AND.W	#$600,D1		; extra bits as below...
+				BEQ.S	PmgrOpTrap
+				MOVEM.L	D3/D4,-(SP)
+				CMP.W	#$400,D1
+				BEQ.S	@jsrOld			; IdleUpdate/IdleState
+				BLO.S	@jsrOld
+				; what remains is _SerialPower
+				BTST	#7,D0			; test bOff bit
+				BEQ		SerialPowerTrap
+@jsrOld
+				jsrOld
+				MOVEM.L	(SP)+,D3/D4
+				RTS
+
+
+PmgrOpTrap
+				CMP.W	#pMgrADB,pmCommand(A0)
+				BNE		DoPmgrOp
+				CMP.W	#9,pmLength(A0)
+				BLS		DoPmgrOp
+				MOVE.W	#pMgrADBoff,pmCommand(A0)
+				MOVE.W	#0,pmLength(A0)
+				BSR		DoPmgrOp
+
+				LEA		pmRBuffer(A0),A1
+				MOVE.L	A1,pmSBuffer(A0)
+				MOVE.B	5(A1),D0
+				OR.B	#2,D0
+				MOVE.B	D0,5(A1)
+				MOVE.B	6(A1),D0
+				MOVE.B	D0,2(A1)
+
+				SUB.W	#1,D0
+				MOVE.W	D0,D3
+@rloop			MOVE.B	7(A1,D3),-(SP)
+				DBRA	D3,@rloop
+
+				ADD.W	#7,A1
+@wloop			MOVE.B	(SP)+,(A1,D0)
+				DBRA	D0,@wloop	
+
+				LEA		pmRBuffer(A0),A1
+				MOVE.L	10(A1),D3
+				MOVE.W	#15,12(A1)
+				LEA		12(A1),A1
+				MOVE.L	A1,pmSBuffer(A0)
+				MOVE.W	#writePmgrRAM,pmCommand(A0)
+				MOVE.W	#3,pmLength(A0)
+				BSR		DoPmgrOp
+
+				LEA		pmRBuffer(A0),A1
+				MOVE.L	D3,10(A1)
+				MOVE.L	4(A1),D3
+				MOVE.W	#9,6(A1)
+				LEA		6(A1),A1
+				MOVE.L	A1,pmSBuffer(A0)
+				MOVE.W	#writePmgrRAM,pmCommand(A0)
+				MOVE.W	#8,pmLength(A0)
+				BSR		DoPmgrOp
+
+				LEA		pmRBuffer(A0),A1
+				MOVE.L	D3,4(A1)
+				MOVE.W	#3,(A1)
+				MOVE.L	A1,pmSBuffer(A0)
+				MOVE.W	#writePmgrRAM,pmCommand(A0)
+				MOVE.W	#8,pmLength(A0)
+				BSR		DoPmgrOp
+
+				RTS
+
+
+SerialPowerTrap
+				MOVE.W	D0,D1
+				CLR.L	D2
+				CLR.L	D3
+				CLR.L	D4
+				LEA		-pmBlkSize(SP),SP
+				LEA		pmData(SP),A0
+				MOVE.L	A0,pmRBuffer(SP)
+				MOVE.L	A0,pmSBuffer(SP)
+				BCLR	#0,D1
+				BNE.S	@bail
+				MOVE.W	#modemRead,pmCommand(SP)
+				MOVE.W	#0,pmLength(SP)
+				MOVE.L	SP,A0
+				BSR.S	DoPmgrOp
+
+				MOVE.B	pmData(A0),D3
+				BTST	#3,D3
+				BEQ.S	@bail
+				MOVE.L	#$10077,D0
+				_ReadXPRam
+				BTST	#UseIntrnlModem,(A0)
+				BNE.S	@bail
+				MOVE.B	D3,D0
+				AND.B	#2,D0
+				LSL.B	#1,D0
+				CMP.B	D0,D1
+				BEQ.S	@othercase
+@bail
+				OR.B	#$90,D2
+				MOVEQ	#0,D3
+@othercase
+				MOVE.W	#powerCntl,pmCommand(SP)
+				MOVE.W	#1,pmLength(SP)
+				MOVE.B	#$C0,pmData(SP)
+				MOVE.L	SP,A0
+				BSR.S	DoPmgrOp
+
+				MOVEQ	#8,D0
+				MOVE.L	D0,A0
+				_Delay
+
+				OR.B	#$82,D2
+				MOVE.W	#powerCntl,pmCommand(SP)
+				MOVE.W	#1,2(SP)
+				MOVE.B	D2,pmData(SP)
+				MOVE.L	SP,A0
+				BSR.S	DoPmgrOp
+
+				TST.B	D3
+				BEQ.S	@bail2
+				MOVE.B	#$88,pmData(SP)
+				MOVE.W	#1,pmLength(SP)
+				MOVE.W	#powerCntl,pmCommand(SP)
+				MOVE.L	SP,A0
+				BSR.S	DoPmgrOp
+@bail2
+				LEA		pmBlkSize(SP),SP
+				MOVEM.L	(SP)+,D3/D4
+				MOVEQ	#0,D0
+				RTS
+
+
+DoPmgrOp
+				MOVEM.L	A0-A6/D1-D7,-(SP)
+				MOVE.W	SR,D5
+				MOVE.L	VIA,A1
+				MOVE.B	vIER(A1),D4
+				MOVE.B	D4,-(SP)
+
+				AND.B	#1<<ifCB1,D4
+				MOVE.B	#1<<ifCB1,vIER(A1)
+
+				SUB.L	#2,SP
+				MOVE.L	PmgrBase,A2
+				CMP.W	#$FFFF,A2
+				BEQ.S	@noGlobals
+				MOVE.B	SaveSpeedo(A2),D3
+				MOVE.W	D3,(SP)
+				MOVE.B	#$10,SaveSpeedo(A2)
+@noGlobals
+
+				TST.W	Clock16M
+				SUB		#48,SP
+				MOVE.L	SP,A3
+				MOVE.L	SCCRd,A6
+				ADD.L	#6,A6
+				LEA		(A1),A5
+				MOVE.B	#$FF,vDIRA(A1)		; all to inputs?
+				MOVE.B	vBufA(A1),D2
+				SWAP	D2
+
+				MOVEQ	#7,D3
+@bigloop
+				CLR.B	vDIRA(A1)
+				MOVE.W	TimeVIADB,D2
+				LSL.W	#2,D2
+@timeloop
+				BTST	#1,vBufB(A1)
+				BEQ.S	@bitNotSet
+				MOVE.B	vBufA(A1),D0
+				CMP.B	#$FF,D0
+				BEQ.S	@exitloop
+@bitNotSet
+				DBRA	D2,@timeloop
+				MOVE.L	#pmBusyErr,D0
+				BRA		@beatIt
+@exitloop
+
+				OR.W	#$700,SR
+				TST.W	Clock16M
+				MOVE.B	vBufB(A1),D6
+				SWAP	D6
+				MOVE.B	vDIRB(A1),D6
+				BCLR	#7,vDIRB(A1)
+				LEA		1(A0),A2
+				MOVEQ	#$40,D2
+				BSR		pmSend
+				BEQ		@notsure
+
+				MOVE.L	A3,PollStack
+				CMP.L	PollStack,SP
+				BEQ.S	@equalsPollStack
+				MOVE.L	A3,D7
+				MOVEM.L	A0-A4/D0-D6,(A3)
+				MOVE.L	PollProc,D2
+				BEQ.S	@noPollProc
+				NOP
+				NOP
+				PEA		@noPollProc
+				MOVE.L	D2,-(SP)
+				RTS
+@noPollProc
+				MOVE.L	D7,A3
+				MOVEM.L	(A3),A0-A4/D0-D6
+@equalsPollStack
+				MOVE.B	D6,vDIRB(A1)
+				SWAP	D6
+				MOVE.B	D6,vBufB(A1)
+				MOVEQ	#$40,D2
+				MOVE.W	D5,SR
+
+				DBRA	D2,*
+				DBRA	D3,@bigloop
+
+				BRA.S	@beatIt
+@notsure
+				MOVEQ	#0,D1
+				LEA		3(A0),A2
+				MOVE.B	(A2),D1
+				BSR		pmOther
+				BNE.S	@beatIt
+				SUB.W	#1,D1
+				BMI.S	@mi
+				MOVE.L	4(A0),A2
+@loop2
+				BSR		pmOther
+				BNE.S	@beatIt
+				DBRA	D1,@loop2
+
+@mi
+				MOVE.B	1(A0),D0
+				BTST	#3,D0
+				BEQ.S	@noFail
+				MOVE.L	A0,A2
+				ADD.L	#1,A2
+				MOVE.W	TimeVIADB,D2
+@timeloop2
+				BTST	#1,(A1)
+				BEQ.S	@testresult
+				MOVE.B	(A5),(A5)
+				BMI.S	@withinloop
+				NOP
+				MOVE.B	(A6),-(SP)
+@withinloop
+				DBRA	D2,@timeloop2
+
+				MOVE.L	#pmReplyTOErr,D0
+				BRA.S	@beatIt
+@testresult
+				CLR.L	(A0)
+				BSR		pmUnsure
+				BNE.S	@beatIt
+
+				ADD.L	#1,A2
+				BSR.W	pmUnsure
+				BNE.S	@beatIt
+
+				MOVE.W	2(A0),D1
+				MOVE.L	8(A0),A2
+
+				SUB.W	#1,D1
+				BMI.S	@noFail
+@loop3
+				BSR		pmUnsure
+				BNE.S	@beatIt
+				DBRA	D1,@loop3
+@noFail
+				MOVEQ	#0,D0
+@beatIt
+				MOVE.B	#$FF,vDIRA(A1)
+				SWAP	D2
+				MOVE.B	D2,vBufA(A1)
+				CLR.B	vDIRA(A1)
+				MOVE.L	D0,D4
+				MOVE.L	A3,PollStack
+				CMP.L	PollStack,SP
+				BEQ.S	@dontReturn
+				MOVE.L	PollProc,D2
+				BEQ.S	@dontReturn
+				NOP
+				NOP
+				PEA		@dontReturn
+				MOVE.L	D2,-(SP)
+				RTS
+@dontReturn
+				MOVE.L	PollStack,SP
+				ADD.L	#$30,SP
+				MOVE.L	D4,D0
+				MOVE.L	VIA,A1
+				MOVE.B	D6,vDIRB(A1)
+				SWAP	D6
+				MOVE.B	D6,vBufB(A1)
+
+				MOVE.L	PmgrBase,A2
+				CMP.W	#$FFFF,A2
+				BEQ.S	@noPmgrGlobs
+				MOVE.W	(SP),D3
+				MOVE.B	D3,SaveSpeedo(A2)
+				CMP.B	#$10,D3
+				BEQ.S	@noPmgrGlobs
+				TST.W	Clock1M
+@noPmgrGlobs
+				ADD.L	#2,SP
+				MOVE.B	(SP)+,D4
+				MOVE.B	D4,vIER(A1)
+				MOVE.W	D5,SR
+				MOVEM.L	(SP)+,A0-A6/D1-D7
+				TST.W	D0
+				RTS
+
+
+pmOther
+				MOVE.W	#$400,D2
+pmSend
+				MOVEQ	#0,D0
+				MOVE.L	(SP)+,A4
+				MOVE.B	#$FF,vDIRA(A1)
+				MOVE.B	(A2)+,vBufA(A1)
+				BCLR	#0,vBufB(A1)
+@someloop
+				BTST	#1,vBufB(A1)
+				BEQ.S	@trySomethingElse
+				MOVE.B	(A5),(A5)
+				BMI.S	@mi
+				NOP
+				MOVE.B	(A6),-(SP)
+@mi
+				DBRA	D2,@someloop
+				MOVE.L	#pmSendStartErr,D0
+				BRA.S	pmCommonReturn
+@trySomethingElse
+				MOVEQ	#$40,D2
+				BSET	#0,vBufB(A1)
+@otherloop
+				BTST	#1,vBufB(A1)
+				BNE.S	pmCommonReturn
+				MOVE.B	(A5),(A5)
+				BMI.S	@mi2
+				NOP
+				MOVE.B	(A6),-(SP)
+@mi2
+				DBRA	D2,@otherloop
+				MOVE.L	#pmSendEndErr,D0
+pmCommonReturn
+				BSET	#0,vBufB(A1)
+				CLR.B	vDIRA(A1)
+				TST.L	D0
+				JMP		(A4)
+
+
+pmUnsure
+				MOVEQ	#0,D0
+				MOVE.L	(SP)+,A4
+				MOVE.B	#0,vDIRA(A1)
+				MOVEQ	#$40,D2
+@someloop
+				BTST	#1,vBufB(A1)
+				BEQ.S	@trySomethingElse
+				MOVE.B	(A5),(A5)
+				BMI.S	@mi
+				NOP
+				MOVE.B	(A6),-(SP)
+@mi
+				DBRA	D2,@someloop
+				MOVE.L	#pmRecvStartErr,D0
+				BRA.S	pmCommonReturn
+@trySomethingElse
+				MOVEQ	#$40,D2
+				BCLR	#0,vBufB(A1)
+				MOVE.B	vBufA(A1),(A2)+
+@otherloop
+				BTST	#1,vBufB(A1)
+				BNE.S	pmCommonReturn
+				MOVE.B	(A5),(A5)
+				BMI.S	@mi2
+				NOP
+				MOVE.B	(A6),-(SP)
+@mi2
+				DBRA	D2,@otherloop
+				MOVE.L	#pmRecvEndErr,D0
+				BRA.S	pmCommonReturn
+
+
+
+portaSleep		PatchProc	_Sleep,(Portable)
+				WITH	PmgrRec,pmCommandRec,SleepqRec
+				IMPORT	DoQueueStack
+;________________________________________________________________________________________
+;
+;	GoToSleep, WakeUp, SleepQInstall, SleepQRemove 
+;
+;	Enter	: D1 = trap word
+;			  D0 = Sleep type
+;
+;	Exit	: All regs unchanged
+;
+;	SlpQInstall adds a sleep queue entry into the sleep queue.
+;
+;	SlpQRemove deletes a sleep queue entry from the sleep queue.
+;
+;	GoToSleep is called by the event manager when it determines that
+;	there is no work being done. Drivers are called to save their state,
+;	then the PMGR is ordered to put the system to sleep. When a waking
+;	event occurs, the PMGR powers up the system. The reset code jumps to
+;	WakeUp if the sleep flag is set. WakeUp restores the system hardware
+;	state, reloads the 68000 regs, and returns to the calling routine.
+;________________________________________________________________________________________
+
+GoToSleep	BTST	#9,D1					; $A28A
+			BNE		SlpQInstall
+			BTST	#10,D1					; $A48A
+			BNE		SlpQRemove
+***			BRA		@Sleep					; $A08A
+@Sleep		
+			MOVE.W	SR,-(SP)
+			MOVEM.L	A0-A6/D1-D7,-(SP)
+			MOVE.W	D0,D2
+
+			MOVE.L	PMgrBase,A0				; Get Power Manager Base Pointer
+			BSET	#InSleep,PmgrFlags(A0)	; test and set sleep semaphore
+			BNE.S	Exit					; if in sleep, exit! don't re-enter
+
+@checkAuto	CMP.B	#SleepRequest,D0		; auto sleep request
+			BEQ.S	@validselector
+
+@checkDnd	CMP.B	#SleepDemand,D0			; User sleep, from finder or command key
+			BEQ.S	@validselector
+			
+@checkNow	CMP.B	#SleepNow,D0			; Critical low power sleep
+			BNE.S	AbortSleep
+
+@validselector
+			BCLR	#AvoidNetDiag,\
+						PmgrFlags(A0) 		; tst/clear the avoid bit
+			BNE.S	@traverse				; if bit was set, skip dialog
+
+			MOVE.L	SleepNetHook(A0),D3		; 	IF SleepNetHook present THEN
+			BEQ.S	@closeAT				;
+			MOVEA.L	D3,A1					;		Get pointer
+			JSR		(A1)					; 		Call Hook
+			BNE.S	AbortSleep
+			BRA.S	@traverse
+@closeAT									; ENDIF
+			BSR.W	CheckAppleTalk			; Close AppleTalk
+			BNE.S	AbortSleep				; Branch if close denied
+			
+@traverse	MOVE.W	D2,D0					; Restore D0
+			CMP.W	#SleepNow,D0			; If passing sleepnow to sleepq then change it 
+			BNE.S	@doQ					; to a sleep demand
+			MOVEQ	#SleepDemand,D0			; sleepNow -> sleepDemand
+
+@doQ		BSR.W	DoQueueStack			; Walk the queue
+			BNE.S	AbortSleep				; Ok to goto sleep ?  Nope.  Get out!
+			BSR.W	CloseAppleTalk			; Else shut down atalk
+			BCLR	#InSleep,PmgrFlags(A0)	; clr the sleep indicator
+			jmpROM	SomeSleepProc
+
+AbortSleep	BCLR	#InSleep,PmgrFlags(A0)	; Clear the sleep indicator
+Exit		MOVE.W	D2,D0					; Restore sleep type to D0
+			MOVEM.L	(SP)+,A0-A6/D1-D7
+			MOVE.W	(SP)+,SR
+			RTS								; Return to caller
+
+;———————————————————————————————————————————————————————————————————————
+;
+; SlpQInstall/SlpQRemove - Installs/Removes entries in the sleep queue.
+;
+; Enrty:	A0 = SlpQRec (pointer)
+;
+; Exit:		D0 = Result code (word)
+;———————————————————————————————————————————————————————————————————————
+
+SlpQInstall		
+			CMP.W	#slpQType,SleepqType(A0)
+			BNE.S	SlpQErr
+			
+			MOVE.L	PmgrBase,A1
+			LEA		SleepQHdr(A1),A1
+			_Enqueue
+			RTS
+
+SlpQErr		MOVEQ	#SlpTypeErr,D0
+			RTS
+
+SlpQRemove	CMP.W	#slpQType,SleepqType(A0)
+			BNE.S	SlpQErr
+			
+			MOVE.L	PmgrBase,A1
+			LEA		SleepQHdr(A1),A1
+			_Dequeue
+			RTS			
+
+
+;________________________________________________________________________________________
+;
+;	CheckAppleTalk - checks AppleTalk drivers depending on the sleep
+;	level, what is open, and what the user OK's.
+;
+;________________________________________________________________________________________
+
+				STRING	PASCAL
+CheckAppleTalk	
+			MOVEM.L	A0-A3/D1-D2,-(SP)		; Try to close AppleTalk and warn user of this			<v1.4>
+			SUB.W	#ioQElSize,SP			; Allocate IO stack frame
+			MOVE.L	SP,A3					; Save this place
+			
+			MOVE.L	PmgrBase,A2				;
+			MOVEQ	#$0F,D1					; Lower nibble indicates ATalk in use
+			AND.B	PortBUse,D1
+			CMP.B	#1,D1
+			BNE		@okexit					; Do exit if no Atalk
+		
+			MOVE.W	D0,D1					; Case on request, demand, and now sleeps
+			CMP.B	#SleepRequest,D0		; Request case
+			BNE.S	@dmndcase
+
+
+;________________________________________________________________________________________
+; Request sleep (time out) case. If plugged in or chooser bit set or server mounted then sleep
+; denied, else ok.
+;________________________________________________________________________________________
+
+@reqcase	BTST	#noATChg,ChooserBits	; If magic chooser bit set then no sleep
+			BEQ		@done
+			
+			BTST	#HasCharger,Charger(A2)	; If plugged in then no sleep
+			BNE		@done
+			
+			BTST	#XPPLoadedBit,PortBUse	; Test for XPP in use
+			BNE.S	@reqcase1				; Branch if so
+
+			MOVE.B	#ClosedMPP,WakeWarn(A2)	; Set flag for wake up warning (MPP closed)
+			BRA		@okexit					; Bye now
+			
+@reqcase1	BSR		XPPCheck				; Try to close XPP
+			BNE		@done					; Branch if not
+			
+			MOVE.B	#ClosedXPP,WakeWarn(A2)	; Set flag for wake up warning (XPP closed)
+			BRA		@okexit
+
+;________________________________________________________________________________________
+; Demand sleep (Finder - Battery DA) case. User warned of different conditions and given the choice
+; to sleep or not.
+;________________________________________________________________________________________
+
+@dmndcase	CMP.B	#SleepDemand,D0			; Demand case
+			BNE.S	@nowcase
+			
+			BTST	#noATChg,ChooserBits	; If no magic chooser bit then branch
+			BNE.S	@dmndcase1
+
+; Magic chooser bit is set so give the user the big bad warning. 
+
+			BSR.W	HarshWarn				; Warn user of impending doom
+			BNE		@done					; No sleep if user is scared off
+			
+			MOVE.B	#ClearedChsr,WakeWarn(A2)	; Set flag for wake up warning	(magic bit cleared)
+			BSET	#noATChg,ChooserBits	; Clear magic chooser bit
+			BRA		@okexit
+		
+; Only MPP is open so give the user the wimpy warning.
+
+@dmndcase1	BTST	#XPPLoadedBit,PortBUse	; Test for XPP in use
+			BNZ.S	@dmndcase2				; Branch if so
+			
+			BSR.W	WimpyWarn				; Warn user of possible problems
+			BNE.S	@done					; Branch if chickened out
+
+			MOVE.B	#ClosedMPP,WakeWarn(A2)	; Set flag for wake up warning (MPP closed)
+			BRA.S	@okexit					; We're cool
+
+; XPP is open and a server may be mounted. If no server then give the wimpy warning, else
+; give a stronger one.
+
+@dmndcase2	BSR		XPPCheck				; Try to close XPP
+			BNE.S	@dmndcase3				; Branch if not able
+
+			BSR.W	WimpyWarn				; Warn user of possible problems
+			BNE.S	@done					; Branch if chickened out
+
+			MOVE.B	#ClosedXPP,WakeWarn(A2)	; Set flag for wake up warning (XPP closed)
+			BRA.S	@okexit					; We're cool
+
+; Server is mounted so give the strong warning.
+
+@dmndcase3	BSR.W	StrongWarn				; Be firm but gentle
+			BNE.S	@done					; Talked him out of it
+			
+			MOVE.B	#ClosedSvr,WakeWarn(A2)	; Set flag for wake up warning (server lost)
+			BRA.S	@okexit					; It was rough but we're fine
+
+;________________________________________________________________________________________
+; Now sleep (Low power) case. Close any and all but select the right wake up warning.
+;________________________________________________________________________________________
+
+@nowcase	MOVE.B	#ClearedChsr,WakeWarn(A2)	; Set flag for wake up warning	(magic bit cleared)
+			BSET	#noATChg,ChooserBits	; Clear magic chooser bit
+			BEQ.S	@nowcase4				; Branch if bit was active
+
+			MOVE.B	#ClosedMPP,WakeWarn(A2)	; Set flag for wake up warning (MPP closed)
+			BTST	#XPPLoadedBit,PortBUse	; Test for XPP in use
+			BNZ.S	@nowcase4				; Branch if so
+			
+			MOVE.B	#ClosedXPP,WakeWarn(A2)	; Set flag for wake up warning (XPP closed)
+			BSR		XPPCheck				; Try to close XPP
+			BEQ.S	@nowcase4				; Branch if did
+
+			MOVE.B	#ClosedSvr,WakeWarn(A2)	; Set flag for wake up warning (server lost)
+		
+@nowcase4
+@okexit		MOVEQ	#0,D0
+
+@done		ADD.W	#ioQElSize,SP			; Release stack frame
+			MOVEM.L	(SP)+,A0-A3/D1-D2
+			TST.W	D0
+			RTS
+
+
+;________________________________________________________________________________________
+;
+;	91/02/13 - AG
+;
+;	Close appletalk drivers if necessary
+;
+;________________________________________________________________________________________
+CloseAppleTalk	
+			MOVEM.L	A0-A3/D1-D2,-(SP)		; Try to close AppleTalk and warn user of this			<v1.4>
+			SUB.W	#ioQElSize,SP			; Allocate IO stack frame
+			MOVE.L	SP,A3					; Save this place
+			
+			MOVE.L	PmgrBase,A2				;
+			MOVEQ	#$0F,D1					; Lower nibble indicates ATalk in use
+			AND.B	PortBUse,D1
+			CMP.B	#1,D1
+			BNE		@Closedone				; Do exit if no Atalk
+			jsrROM	AllClose				; Shutdown everything
+
+@Closedone	ADD.W	#ioQElSize,SP			; Release stack frame
+			MOVEM.L	(SP)+,A0-A3/D1-D2
+			TST.W	D0
+			RTS
+
+;———————————————————————————————————————————————————————————————————————
+; CloseATalk support routines.
+;———————————————————————————————————————————————————————————————————————
+
+StrongWarn	MOVE.W	#-16386,D0
+			BRA.S	Warn
+			
+WimpyWarn	MOVE.W	#-16387,D0
+			BRA.S	Warn
+			
+HarshWarn	MOVE.W	#-16388,D0
+
+Warn		CLR.W	-(SP)					; Send the warning
+			MOVE.W	D0,-(SP)		
+			CLR.L	-(SP)
+			_Alert
+			MOVE.W	(SP)+,D0				; D0 non-zero if canceled
+			SUBQ.W	#1,D0					; <t31> 1 is sleep button
+			RTS
+
+			
+;———————————————————————————————————————————————————————————————————————
+;
+;	XPPCheck - this is a routine checks to see if any servers are mounted.
+;		D0 will return the error from the close.  if no error, no servers!
+;		to restore the world, reopen the driver after.
+;
+;	input
+;		a3	pointer to pb
+;
+;	output
+;		d0	result 
+;			== 0	no servers mounted
+;			!= 0	servers mounted
+;
+;	Usage
+;		a0	pointer to pb
+;		a1	pointer to driver name
+;		a3	pointer to pb
+;
+;———————————————————————————————————————————————————————————————————————
+XPPCheck	MOVE.L	a3,a0						; Get pb pointer
+
+			MOVE.W	#~xppUnitNum,ioRefNum(A0)	;
+			_Close								; Close XPP
+
+			MOVE.L	d0,-(sp)					; save result
+			LEA		#'.XPP',a1					; Get XPP refnum
+			MOVE.L	a1,ioVNPtr(a0)				; load pointer to driver
+			MOVE.B	#fsCurPerm,ioPermssn(a0)	; set permission
+			_Open								; get refnum
+			MOVE.L	(sp)+,d0					; restore result
+
+			TST.W	d0							; test close result
+			RTS									; Sucess returned in status
+
+
+portaSysTask	PatchProc	_SystemTask,(Portable)
+			WITH	PmgrRec
+
+			jsrOld
+			MOVE.L	PmgrBase,A1
+			TST.B	MBState
+			BNE.S	@clicked
+@idleUpdate
+			_IdleUpdate
+			RTS
+@clicked
+			TST.B	watchCrsr(A1)
+			BNE.S	@idleUpdate
+			RTS
+
+
+;________________________________________________________________________________________
+;
+;	91/02/13 - AG
+;
+; 	DoQueueStack - this routine is called to traverse the sleep queue.  if
+;		the sleep type is "now", "demand", or "WakeUp", the queue will only
+;		be run once. otherwise, the queue will be run twice. once to check if
+;		its ok to sleep, if ok, the sleep type is changed to "demand" and the 
+;		queue is rerun.  if not ok, then the sleep type is change to "Unlock"
+;		and the queue is rerun,  Each proc is passed its queue entry in A0.
+;
+;	input	
+;		d0	sleep type
+;		a0	ptr to pmgrglobals
+;
+;	output
+;		d0	
+;			== 0	ok to sleep
+;			!= 0	queue rejected auto sleep
+;
+;	usage
+;	d	d0	sleep type/result
+;	 	a0	pointer to first element/ ptr to pmgrglobals
+;
+;———————————————————————————————————————————————————————————————————————
+
+DoQueueStack	PROC	EXPORT
+			WITH	PmgrRec,pmCommandRec,SleepqRec
+
+			MOVEM.L	A0/D1,-(SP)				; save pmgrglobals ptr
+			MOVE.L	SlpQHead(A0),A0			; Get ptr to first element
+		
+			CMP.W	#SleepRequest,D0		; is it auto sleep ?
+			BNE.S	@runTheQueue			; if no, just run the queue
+		
+@testTheQueue	
+			BSR.s	Handle_Element			; ask queue about auto sleep
+			BNE.s	@undosleepreq			; if error returned, undo sleep
+			MOVEQ	#SleepDemand,D0			; ... else set to sleep demand
+
+@runTheQueue	
+			BSR.S	Handle_Element			; handle element
+			CLR.L	D0						; return no error
+
+@exit		MOVEM.L	(SP)+,A0/D1				; restore pmgrglobals ptr
+			RTS
+
+@undosleepreq	
+			MOVEQ	#SleepUnlock,D0			; Since sleep denied, set to unsleep
+			BSR.S	Handle_Element			; handle element
+			MOVEQ	#SleepUnlock,D0			; return non zero result
+			BRA.S	@exit
+		
+
+;———————————————————————————————————————————————————————————————————————
+;
+;	Handle Element - this is a routine which is used to execute a queue element.  if the
+;		element pointer is null, the routine exits and returns 0 in d0.  if the element
+;		pointer is not null, then the routine will do two thing:
+;			1)	handle the next element recursively
+;			2)	execute the current element's sleep proc
+;		the queue will essentially be traversed in post fixed order
+;
+;	input
+;		a0	pointer to queue element
+;		d0	sleep type 
+;
+;	output
+;		d0	result 		
+;			== 0	ok to sleep
+;			!= 0	sleep rejected
+;
+;	Usage
+;	 	a0	pointer to element
+;	d	a1	pointer to sleep proc
+;	d	d0	sleep type/result
+;	d	d1	saved sleep type/ condition code check
+;
+;———————————————————————————————————————————————————————————————————————
+ProcRegs	REG		a0-a6/d1-d7
+
+Handle_Element	
+			MOVE.L	a0,d1						; test element pointer
+			BEQ.S	@noelement					; if invalid element ptr, exit with d0 clear
+			MOVE.L	d0,d1						; save a copy of type in d1
+			
+@validelement	
+			MOVEM.L	a0/d1,-(sp)					; save element pointer and type
+			MOVE.L	SleepqLink(a0),a0			; pass in pointer to next element
+			BSR.S	Handle_Element				; handle the next element in queue
+			MOVEM.L	(sp)+,a0/d1					; restore pointer and type
+			CMP.W	#1,D1
+			BNE.S	@callproc
+			TST.W	D0
+			BNE.S	@exit						; if result != zero, exit
+			
+@callproc		
+			MOVE.L	d1,d0						; restore type to d0
+			MOVEM.L	ProcRegs,-(sp)				; save the world before calling proc				<15> ag
+			MOVE.L	SleepqProc(a0),a1			; get a pointer to the proc
+			JSR		(a1)						; call sleep proc
+			MOVEM.L	(sp)+,ProcRegs				; restore the world
+
+			TST.L	d0							; set condition codes on result
+			RTS
+			
+@noelement	moveq	#0,d0						; clear result
+@exit		RTS									; exit
+
+
+portaPowerOff	PatchProc	_PowerOff,(Portable)
+			MOVE.W	#60,A0
+			_Delay
+
+			SUB		#4,SP						; clear pmData
+			MOVE.L	SP,A0
+			CLR.L	(A0)
+			MOVEQ	#0,D1
+			MOVEQ	#pMgrADBoff,D0
+			MOVE.L	A0,-(SP)					; pmRBuffer -> pmData
+			MOVE.L	A0,-(SP)					; pmSBuffer -> pmData
+			MOVE.W	D1,-(SP)					; pmLength = 0
+			MOVE.W	D0,-(SP)					; pmCommand = pMgrADBoff
+			MOVE.L	SP,A0
+			_PmgrOp
+			LEA		8(SP),SP					; fix the stack, preserving A0 (why?)
+			MOVE.L	(SP)+,A0
+			ADD		#4,SP
+
+			_HideCursor
+
+			CLR.L	WarmStart
+
+			MOVE.W	#SleepNow,D0
+			_Sleep
+
+			RTS
 
 
 pollProcRegs	reg		d0-d6/a0-a4
@@ -212,9 +1176,7 @@ SndWatch	PROC
 			jsrROM	PMGRrecv
 			MOVE.B	(A0),D2					; Get sound state
 			BTST	#1,D2
-			; (SKH) BEQ.S	@Clearlatch				; Branch if latch is set
-			bra.s	@noSound
-			
+			BEQ.S	@Clearlatch				; Branch if latch is set			
 			_IdleUpdate						; update activity indicator
 									
 @Clearlatch	MOVE.B	#sndOnclrLtch,(A0)		; Turn on sound power and clear the latch
@@ -364,6 +1326,354 @@ BatWatchOut	LEA		BatVBLTask(A2),A0		; Get pointer to vbl task
 
 
 
+portaInstallWake	InstallProc		(Portable)
+			MOVE.L		PmgrBase,A1
+			leaResident	portaWakeUp,A2
+			MOVE.L		A2,PmgrRec.WakeVector(A1)
+			RTS
+
+
+
+portaWakeUp	PROC	EXPORT
+			WITH	PmgrRec
+
+			MOVE.L	#wmStConst,WarmStart
+			MOVE.L	SndBase-4,SP
+			MOVE.W	#6,RAMconfigBase
+
+			MOVE.L	PmgrBase,A2
+			CLR.B	Level4Cnt(A2)
+			MOVE.B	#$FF,LastLevel(A2)
+			CLR.L	BatQ(A2)
+			CLR.L	BatQ+4(A2)
+			MOVE.B	#8,BatQIndex(A2)
+
+			MOVE.L	ASCBase,A0
+			LEA		$808(A0),A0				; unknown offset?!
+			MOVEQ	#6,D0
+@ascResLoop	MOVE.B	(SP)+,-(A0)
+			DBRA	D0,@ascResLoop
+			TST.B	ascFifoInt(A0)
+
+			MOVE.L	VIA,A0
+			MOVEM.W	(SP)+,D0-D5
+			MOVE.B	D0,vBufB(A0)
+			MOVE.B	D1,vDIRB(A0)
+			MOVE.B	D2,vBufA(A0)
+			MOVE.B	D3,vIER(A0)
+			MOVE.B	D4,vACR(A0)
+			MOVE.B	D5,vPCR(A0)
+			MOVE.B	vT2CH(A0),vT2CH(A0)
+			MOVE.B	vT1CH(A0),vT1CH(A0)
+
+			MOVE.L	(SP)+,ResetPC
+
+			jsrROM	InitSCSI				; Init the SCSI chip
+
+			LEA		Time,A0					; Restore Time
+			MOVEQ	#timeRead,D0
+			jsrROM	PMGRrecv
+
+			jsrROM	KbdReset				; clear the keyboard maps
+
+			MOVEM.L	(SP)+,D1-D7/A0-A6
+			SUB		#56,SP
+			MOVE.W	56(SP),SR
+
+			BSR		SCSIDiskWakeAlert		; check if a disk mode cable is plugged in
+			BSR.S	MPPOpen					; Open the driver since elements in the queue might need some MPP services
+			MOVEQ	#SleepWakeUp,D0			; Go through wake queue
+			jsrROM	DoQueue					; Run through the queue in proper order
+
+			_CountADBs
+			CMP.B	#2,D0
+			BLE.S	@noReInit
+			_ADBReInit
+@noReInit
+
+			MOVEQ	#0,D0
+			MOVEM.L	(SP)+,D1-D7/A0-A6
+			ADD.L	#2,SP
+			RTS
+
+
+;———————————————————————————————————————————————————————————————————————
+;
+;	MPPOpen - routine to open the MPP driver.  If the driver is not necessary, the open
+;			will fail, so just try to open the driver blindly
+;
+;	input
+;		none
+;
+;	output
+;		none
+;
+;	usage
+;		a0 - pointer to iopb
+;		a1 - pointer to driver name
+;
+;———————————————————————————————————————————————————————————————————————
+
+MPPOpen		MOVEM.L	A0-A3/D1-D2,-(SP)
+			SUB.L	#ioQElSize,SP			; Allocate IO stack frame
+			MOVEA.L	SP,A0					; Save this place
+			
+			LEA		#'.MPP',A1				; Get MPP refnum
+			MOVE.L	A1,ioVNPtr(A0)
+			MOVE.B	#fsCurPerm,ioPermssn(A0)
+			_Open
+
+			LEA		ioQElSize(SP),SP		; Release stack frame
+			MOVEM.L	(SP)+,A0-A3/D1-D2
+			RTS
+
+
+;———————————————————————————————————————————————————————————————————————
+;
+;	SCSIDiskWakeAlert - Checks if the SCSI Disk Mode cable is plugged in when
+;			we wake up. If it is, put up a DeepShit window with a message.
+;
+;———————————————————————————————————————————————————————————————————————
+
+SCSIDiskWakeAlert
+			MOVE.L	SP,D3
+
+			MOVE.L	ROMBase,A0
+			CMP.B	#$11,ROMHeader.ROMRelease(A0)
+			BNE.W	@return
+			BSR		TestForDiskMode
+			BNE		@return
+
+;	save the pixels that will be clobbered by the DS alert
+
+			CLR.L	D4
+			CLR.L	D5
+			TST.B	QDExist
+			BNZ.S	@savedErrBoxPixels
+
+			MOVE.L	GrafGlobals(A5),A0
+			MOVE.L	thePort(A0),D4
+			MOVE.L	#bitmapRec+448*126/8,D0	; bitmap rec + 8bit data
+			_NewPtr
+			TST.W	D0
+			BNE.S	@savedErrBoxPixels
+
+			MOVE.L	A0,D5					; this is the dest bitmap, saved...
+			PEA		bitmapRec(A0)			; set baseAddr to the guts of the buffer
+			MOVE.L	(SP)+,(A0)+
+			MOVE.W	#56,(A0)+				; set rowBytes
+			MOVE.L	#$00000000,(A0)+		; topLeft
+			MOVE.L	#$007E01C0,(A0)+		; botRight
+			SUBA	#$74,SP
+			MOVE.L	SP,A6
+			jsrROM	AllocFakeRgns
+			MOVE.L	SP,-(SP)
+			_InitPort
+			MOVE.L	GrafGlobals(A5),A0
+			MOVE.L	A6,thePort(A0)
+
+			PEA		screenBits(A0)			; srcBits = the screen
+			MOVE.L	D5,-(SP)				; dstBits = our new allocated bitmap
+			BCLR	#7,DSAlertRect 			; SECRETFLAG = 0
+			PEA		DSAlertRect				; srcRect = rect where error box goes
+			MOVE.L	D5,A0
+			PEA		bounds(A0)				; dstRect = our entire allocated bitmap
+			CLR.W	-(SP)					; mode = 0
+			CLR.L	-(SP)					; maskRgn = nil
+			_CopyBits
+			BSET	#7,DSAlertRect			; SECRETFLAG = 1
+@savedErrBoxPixels
+
+;	put the alert on the screen and wait until the cable is removed...
+
+			MOVE.W	#dsSCSIWarn,D0			; put up the DeepShit alert
+			_SysError
+
+@NotGone	MOVEA.L	VIA,A0
+			MOVEQ	#3,D1
+@OuterLoop	MOVE.W	#$7FFF,D0
+@InnerLoop	TST.B	(A0)					; throttle the loop with a VIA access
+			DBRA	D0,@InnerLoop
+			DBRA	D1,@OuterLoop
+
+			BSR		TestForDiskMode			; is the disk mode cable still attached?
+			BEQ.S	@NotGone				; -> yep, keep waiting
+
+;	they finally removed the cable, so clean everything up...
+
+			TST.L	D5
+			BEQ.S	@useGNE
+			MOVE.L	D5,-(SP)				; srcBits = our bitmap
+			MOVE.L	GrafGlobals(A5),A0
+			MOVE.L	A6,thePort(A0)
+			PEA		screenBits(A0)			; dstBits = the screen
+			MOVE.L	D5,A0
+			PEA		bounds(A0)				; srcRect = our entire allocated bitmap
+			BCLR	#7,DSAlertRect			; SECRETFLAG = 0
+			PEA		DSAlertRect				; dstRect = rect where error box goes
+			CLR.W	-(SP)					; mode = 0
+			CLR.L	-(SP)					; maskRgn = nil
+			_CopyBits
+			BSET	#7,DSAlertRect			; SECRETFLAG = 1
+
+			MOVE.L	D5,A0
+			_DisposePtr
+			ADDA	#$74,SP
+			BRA.S	@reSetPort
+@useGNE
+			CLR.B	DSWndUpdate 			; flag GNE to remove the alert
+			TST.L	D4
+			BEQ.S	@return
+@reSetPort
+			MOVE.L	D4,-(SP)
+			_SetPort
+@return
+			RTS
+
+
+;———————————————————————————————————————————————————————————————————————
+;
+;	TestForDiskMode - checks if we're setup for SCSI Disk Mode
+;
+;	input
+;		none
+;
+;	output
+;		CCR	-	BEQ if the SCSI DiskMode cable is attached
+;
+;———————————————————————————————————————————————————————————————————————
+
+TestForDiskMode
+			MOVE.L	#$00EE01<<8,-(SP)		; populate pmData
+			MOVE.L	SP,-(SP)				; pmRBuffer -> pmData
+			MOVE.L	(SP),-(SP)				; pmSBuffer -> pmData
+			MOVE.W	#3,-(SP)				; pmLength
+			MOVE.W	#readPmgrRAM,-(SP)		; pmCommand
+			MOVE.L	SP,A0
+			_PmgrOp
+			MOVE.L	pmCommandRec.pmData(SP),D0
+			BTST	#29,D0
+			LEA		pmCommandRec.pmBlkSize(SP),SP
+			RTS
+
+
+portaInitializeStrings	InstallProc		(Portable)
+;___________________________________________________________________________________
+; Routine:	InitializeStrings
+;
+; Inputs:	none
+;
+; Outputs:	none
+;
+; Destroys:	d0-d3,a0-a2
+;
+;___________________________________________________________________________________
+
+InitializeStrings
+
+SignatureReg	equ			$FC0200				; address of backlight signature
+SignatureAruba	equ			$A5					; signature for aruba backlight
+SignatureUpgrd	equ			$A3					; signature for upgrade backlight
+SignatureAsahi	equ			$AD					; signature for asahi backlight
+
+LPsicnNum		EQU		-16386					; Small battery icon
+LPstr0Num		EQU		-16386					; no backlight
+LPstr0NumBL		EQU		-16511
+LPstr1NumBL		EQU		-16512
+LPstr2NumBL		EQU		-16516					; Added new one for Andy <r9> HJR
+LPstr3NumBL		EQU		-16513
+
+BatstrWarn0		EQU		-16514					; <t5> new bad battery strings
+BatstrWarn1		EQU		-16515
+
+				WITH	PmgrRec
+
+				MOVE.L	PmgrBase,A2
+				MOVE.L	#'SICN',D1
+
+				MOVE.W	#LPsicnNum,D2
+				BSR		GetDetachRes			; Get the battery icon
+				BEQ.S	@getstrings
+				MOVE.L	A1,lpSICNHndl(A2)		; Save the handle locally
+
+@getstrings		MOVE.L	#SignatureReg,A0
+				CMP.B	#SignatureAruba,(A0)
+				BEQ.S	@dimmable
+				CMP.B	#SignatureUpgrd,(A0)
+				BEQ.S	@dimmable
+				CMP.B	#SignatureAsahi,(A0)
+				BEQ.S	@dimmable
+
+				MOVEQ	#3,D4					; strings for non-backlit screen
+				MOVE.W	#LPstr0Num,D2
+				MOVEQ	#lpSTR0Ptr,D3
+@loop			BSR		LoadString
+				SUB.W	#1,D2
+				ADD.L	#4,D3
+				DBRA	D4,@loop
+				BRA		@return
+
+@dimmable
+				move.w	#LPstr0NumBL,D2			; get first warning string
+				move.l	#lpSTR0Ptr,D3
+				bsr		LoadString
+
+				move.w	#LPstr1NumBL,D2			; get 25% warning string
+				move.l	#lpSTR2Ptr,D3
+				bsr		LoadString
+
+				move.w	#LPstr3NumBL,D2			; get 10 second warning
+				move.l	#lpSTR3Ptr,D3
+				bsr.s	LoadString
+
+@return			rts
+
+;------------------------------------------------------------------------------------------
+;
+;	LoadString - used to load a low power string into the power manager globals
+;
+;	input	
+;		a2 - pointer to powermgr
+;		d2 - string resource id
+;		d3 - offset of string pointer in powermanager
+;
+;	output	
+;		none
+;
+;	usage	
+;	d	d1 - resource type
+;		d2 - string resource id
+;		d3 - offset of string pointer in powermanager
+;	d	a1 - handle to string
+;		a2 - pointer to powermgr
+;------------------------------------------------------------------------------------------
+
+LoadString		move.l	#'STR ',d1			; set to string resource type
+				bsr.s	GetDetachRes		; get and detach string resource
+				beq.s	@exit				; if no string, exit
+				move.l	(a1),(a2,d3)		; else install pointer in pmgr globals
+@exit			rts							; done
+
+; Gets and detaches a resource.
+; Parameters:
+;	D1	Resource Type
+;	D2	Resource ID
+; Returns:
+;	A1	Handle to resource
+; Registers:
+;	D0/A0 destroyed
+
+GetDetachRes
+				SUBQ.L	#4, SP			; For return address
+				MOVE.L	D1, -(SP)		; Resource type
+				MOVE.W	D2, -(SP)		; Resource ID
+				_GetResource
+				MOVE.L	(SP), A1		; Get resource handle to return
+				_DetachResource
+				MOVE.L	A1,D0			; Set result code
+				RTS
+
+
 ;===================================================================================		<r9> thru next <r9> djw
 ;	PowerMiscPatches  -  collection of all the Terror patches
 ;
@@ -373,7 +1683,7 @@ BatWatchOut	LEA		BatVBLTask(A2),A0		; Get pointer to vbl task
 
 			machine	mc68030
 
-InstallPowerMgrPatches	PROC EXPORT
+InstallPowerMgrPatches	InstallProc		(IIci,hasTerror,hasPwrMgr)
 
 			bsr		ResetSoftwareCutoff					; reset the power mgr's shutdown level
 			bsr		InitializeStrings					; init all warning and alert strings
@@ -704,6 +2014,7 @@ PatchPmgrOp
 ;_________________________________________________________________________________________
 
 SleepPtch	PROC
+			IMPORT	DoQueueStack
 			WITH	PmgrRec
 
 			BTST	#9,D1						; $A28A
@@ -1101,8 +2412,7 @@ NewSndWatch
 			move.w	#SoundRead,d0			; PMGR command, get sound state
 			jsrROM	PMGRrecv
 			move.b	(a0),d2					; Get sound state
-			; (SKH) beq.s	@noSound		; branch if no sound activity
-			bra.s	@noSound				; SKH - Never power down sound.
+			beq.s	@noSound				; branch if no sound activity
 
 			btst.l	#1,d2
 			bne.s	@sndActive				; the latch is set
diff --git a/OS/SCSIMgr/SCSILinkPatch.a b/OS/SCSIMgr/SCSILinkPatch.a
--- a/OS/SCSIMgr/SCSILinkPatch.a
+++ b/OS/SCSIMgr/SCSILinkPatch.a
@@ -493,6 +493,7 @@ SCSIBusyCommon
 ;
 ; 	In SuperMario, this is part of SCSIGlobals.
 
+	export SCSIBusyVector
 FreeHookPending	dc.l	0					; location of pending free-hook flag
 SCSIBusyVector	dc.l	0
 
@@ -544,7 +545,7 @@ TransFlagTbl
 				dc.b	0											; 13	SCSIMsgOut
 
 
-			Endp							; end SCSIDispatchCommon
+			Endp							; end 				∂
 
 
 ;_______________________________________________________________________________________	<2> djw
diff --git a/OS/SCSIMgr/SCSIMgr96.a b/OS/SCSIMgr/SCSIMgr96.a
--- a/OS/SCSIMgr/SCSIMgr96.a
+++ b/OS/SCSIMgr/SCSIMgr96.a
@@ -10,12 +10,7 @@
 ;	Change History (most recent first):
 ;
 ;	  <SM11>	 9/13/93	SAM		Removed a redundant definition of Translate24to32.
-;	  <SM10>	 1/26/93	SAM		Put in a PDMDebug only mod to CyclePhases to drop into macsbug
-;									when it gets called.  Only call HwPriv's FlushRangeCodeCache at
-;									the end of data xfer calls only on 040s running VM.
 ;	   <SM9>	 11/3/92	SWC		Changed SCSIEqu.a->SCSI.a.
-;	   <SM8>	10/18/92	CCH		Added nop's to support non-serial IO space, and conditionals to
-;									use byte accesses to the DREQ register.
 ;		 <4>	 5/22/92	DTY		#1029009 <jab>: Modified DREQ bit testing from global (setup in
 ;									SCSIInit96).
 ;		 <3>	  5/1/92	JSM		Don’t use isUniversal conditional, which was always commented
@@ -108,7 +103,6 @@ SCSI96		PROC		EXPORT
 
 			WITH	scsiPB, scsiPrivPB
 			WITH	scsiGlobalRecord, dcInstr
-VMGlobals	EQU		$0B78				; Pointer to VM's globals (yeah, yeah, had to do it)			<SM10> SAM
 
 ;==========================================================================
 
@@ -622,12 +616,6 @@ dataCommon_96
 
 
 @data_end
-			cmpi.b	#cpu68040,CPUFlag			; Do we have an 040?							<SM10>
-			bne.s	@TheRealExit				; -> No.  No MOVE16.  No Problem.
-			cmpi.l	#-1,VMGlobals				; VM running?
-			beq.s	@TheRealExit				; -> No, no VM, no problem
-			
-
 ;--- Flush the cache line that contains location 8 (because of MOVE16 bug)						<3> thru next <3>
 
 			movem.l	D0-D2, -(sp)
@@ -639,7 +627,6 @@ dataCommon_96
 
 ;--- exit and return result
 
-@TheRealExit
 			move.w	d0, 12(a6)					; return the result
 			moveq.l	#4, d0						; stack cleanup
 			bra.w 	StdExit
@@ -673,9 +660,6 @@ DoSCSIComplete_96
 			bne.w	@phaseErr					; 
 @inPhase										; we should be in status phase.
 			move.b	#cCmdComp, rCMD(a3)			; load cmd complete code
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			jsr		WaitForSCSIIntrp			; Wait for intrp w/ timeout
 												;    on exit d5 = rF0S|rINT|0|rSTA
 			beq.w	@noStatus					; Branch if timedout
@@ -695,9 +679,6 @@ DoSCSIComplete_96
 ;			;bne.s	@cmdErr																		<T8> from last <T8>
 
 			move.b	#cMsgAcep, rCMD(a3)			; load msg accepted code which de-asserts *ACK
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			jsr		WaitForSCSIIntrp			; Wait for intrp w/ timeout
 												;    on exit d5 = rFOS|rINT|0|rSTA
 			beq.w	@badAcpt					; Branch if timedout
@@ -835,9 +816,6 @@ Select_96
 ; Set up chip for select process (flush FIFO, init dest ID)
 			move.b	d0, rDID(a3) 					; load select bus ID w/ target ID
 			move.b	#cFlshFFO, rCMD(a3)				; Flush FIFO, make sure it's empty
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 
 			btst.l	#16, d0							; is this a Sel w/Atn?
 			bne.s	@withAtn
@@ -847,9 +825,6 @@ Select_96
 			move.b	zeroReg, rXCM(a3)				; tell chip that we will be sending 1
 			move.b	#1, rXCL(a3)					; DMA byte (in command phase)
 			move.b	#cDMASelWOAtn, rCMD(a3)			; issue Select w/o Atn cmd
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			bset.b	#NeedCmdSent, G_State96(a4)		; flag=expect to see a COMMAND phase next			<T9>
 			bra.s	@2
 
@@ -858,9 +833,6 @@ Select_96
 			move.b	zeroReg, rXCM(a3)				; tell chip that we will be sending 2
 			move.b	#1, rXCL(a3)					; DMA bytes (1 in msg_out, 1 in command) 
 			move.b	#cDMASelWAtn, rCMD(a3)			; issue Select w/ Atn cmd
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			bset.b	#NeedMsgOut, G_State96(a4)		; flag=expect to see a MESSAGE_OUT phase next		<T9>
 @2			
 			bset.b	#SelInProg, G_State96(a4)		; set flag->select is in prog, expect intrpt	<T8><T9>
@@ -899,11 +871,7 @@ Select_96
 ;———————————————————
 @waitLoop
 	; Check for a REQ from the target (within valid phase)
-		IF forPDMDebug THEN						;								<SM8>
-			move.b	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ELSE
 			move.l	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ENDIF
 			move.b	G_bitDREQ(a4),d0				; load DREQ bit position	<4> jab
 			btst.l	d0, d5							; DREQ ?					<4> jab
 			bne.s	@gotDREQ						; yes: then we have a REQ for Msg_Out or Cmd byte
@@ -1016,9 +984,6 @@ SendCMD_96
 @btmLoadFIFO									;														<T9>
 			dbra	d2, @loadFIFO				;	 last byte in order to satisfy the c96's DMA		<T2>
 												;	 circuitry & get us that intrp.						<T2>
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 	
 			btst.b	#NeedCmdSent, G_State96(a4)	; were we expecting a command phase here?			<2> thru next <2>
 			beq.s	@skipDMA
@@ -1039,9 +1004,6 @@ SendCMD_96
 			and.b	rSTA(a3), d1				; get phase bits before sending last byte			<2> from prev <2>
 
 			move.b	(a2)+, rDMA(a3)				; Use psuedo DMA to load last byte						<T2>
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 
 			bclr.b	#NeedCmdSent,G_State96(a4)	; no longer need command sent and,						<T9>
 			bset.b	#FCIntPend,G_State96(a4)	; now we can expect a FunctionCmplt interrupt			<T9>
@@ -1059,9 +1021,6 @@ SendCMD_96
 			moveq.l #noErr, d0					; no error												<T9>
 @cmdExit										; At this point, we're out of cmd phase
 			and.b	#$FF-SlowCableMode,rCF1(a3)	; turn-off Slow cable mode								<T9>
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			tst.w	d0							;
 			rts
 
@@ -1095,9 +1054,6 @@ SendCMD_96
 			bclr.b	#NeedMsgOut, G_State96(a4)		; and Message_Out  							<Taa>
 			bclr.b	#NeedCmdSent, G_State96(a4)		; and Command expected flags				<Taa>
 			move.b	#cFlshFFO, rCMD(a3)				; flush the FIFO of unused Command bytes			
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 @phaseErr
 			moveq.l #scPhaseErr, d0				; phase error											<T5>
 			move.l	#scsiCmd, d6				; load proc ID											<T5>
@@ -1132,9 +1088,6 @@ GetMsg_96
 			bne.s	@phaseErr					; 
 			
 			move.b	#cIOXfer, rCMD(a3)			; load Transfer cmd byte in CMD regr
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			jsr		WaitForSCSIIntrp			; Wait for intrp w/ timeout						<T3>
 												;    on exit d5 = xxxx|rSQS|rSTA|rINT
 			beq.s	@timedOut					; Branch if timedout
@@ -1142,9 +1095,6 @@ GetMsg_96
 			move.b	rFFO(a3), d2				; xfer fifo msg byte into d2 w/ *ACK still asserted
 												; now, unconditionally accept the message byte
 			move.b	#cMsgAcep, rCMD(a3)			; load msg accepted code which de-asserts *ACK
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			jsr		WaitForSCSIIntrp			; Wait for intrp w/ timeout						<T3>		
 												;    on exit d5 = rFOS|rINT|0|rSTA
 			beq.s	@timedOut					; Branch if timedout
@@ -1204,9 +1154,6 @@ SendMsg_96
 @inPhase	; We probably got here from Select w/ATN which means
 			; ATN is deasserted prior to transfer of msg byte
 			move.b	d2, rFFO(a3)				; xfer msg byte	
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			bclr.b	#NeedMsgOut,G_State96(a4)	; did we send a Select w/ATN?
 			beq.s	@needXfer					; no - just split
 			bset.b	#NeedCmdSent,G_State96(a4)	; yes - we took care of MsgOut, now we need to send command
@@ -1294,23 +1241,18 @@ CyclePhase_96									; (accessed thru jvCyclePhase)
 			btst.b	#scBusy, G_State(a4)		; check if SCSIMgr is active					<T2>
 			beq.s	@xferErr					;  bra. if not
 			
-	IF forPDMDebug THEN							; Till Jimmy stops ignoring DREQ...				<SM10>
-			PEA		@FuckedUpStr
-			_DebugStr
-	ENDIF
-			
 @checkNextPhase									;											<T9> to next <T9>
 			moveq.l	#iPhaseMsk, d0				; load mask bits for phase value
 			and.b	rSTA(a3), d0				; get phase bits
 
-		;	cmp		#iDataOut, d0				; 
-			beq.s	@inDataPhase				; 
-			
 			cmp		#iDataIn, d0				; 
 			beq.s	@inDataPhase				; 
 			
+			cmp		#iDataOut, d0				; 
+			beq.s	@inDataPhase				; 
+			
 			cmp		#iCommand, d0				; 
-			beq		@shoveCommand				; 
+			beq.s	@shoveCommand				; 
 			
 			cmp		#iMsgOut, d0				; 
 			beq.w	@shoveMsgOut					; 
@@ -1328,12 +1270,6 @@ CyclePhase_96									; (accessed thru jvCyclePhase)
 			clr.l	d0							; no recovery
 			rts			
 
-	IF forPDMDebug THEN
-			STRING	PASCAL
-@FuckedUpStr DC.W	'SCSIMgr is in CyclePhases.  Bitbucketting Data...'
-			STRING	ASIS
-	ENDIF
-
 ; If data phase, check if we have been transferring with psuedo-DMA, if so, continue.
 @inDataPhase
 			move.b	rCMD(a3), d1				; what was our most recent command?
@@ -1360,9 +1296,6 @@ CyclePhase_96									; (accessed thru jvCyclePhase)
 ; Dump out data_out bytes until we've gone into another phase		
 @shoveDataOut
 			move.b	#$EE, rFFO(a3)				; load filler byte into FIFO 
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			jsr		Xfer1Byte					; xfer 1 byte and wait for intrp w/o timeout
 												;    on exit d5 = rFOS|rINT|0|rSTA
 			bne.s	@xferErr						; bra. on xfer error
@@ -1374,9 +1307,6 @@ CyclePhase_96									; (accessed thru jvCyclePhase)
 			bclr.b	#NeedCmdSent, G_State96(a4)	; did we expect this?
 			beq.s	@nonDMA						; no - bra, do xfer using FIFO	
 			move.b	#$EE, rDMA(a3)				; yes - use DMA (since chip is waiting for it)
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			bset.b	#FCIntPend,G_State96(a4)	; we took care of cmd, now expect FC interrupt	
 			jsr		WaitForSCSIIntrp
 			beq.s	@timedOut					; bra if timedout
@@ -1386,9 +1316,6 @@ CyclePhase_96									; (accessed thru jvCyclePhase)
 			bra.s	@2							; trying again is as good as anything else
 @nonDMA
 			move.b	#$EE, rFFO(a3)				; load filler byte into FIFO 
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			jsr		Xfer1Byte					; xfer 1 byte and wait for intrp w/o timeout
 			bne.s	@xferErr						; bra. on xfer error
 @2
@@ -1398,9 +1325,6 @@ CyclePhase_96									; (accessed thru jvCyclePhase)
 ; Dump out message_out bytes until we've gone into another phase		
 @shoveMsgOut			
 			move.b	#$08, rFFO(a3)				; load filler byte into FIFO (NOP message)
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			bclr.b	#NeedMsgOut, G_State96(a4)	; did we expect this?
 			beq.s	@needXferCmd				; no - branch	
 			bset.b	#NeedCmdSent,G_State96(a4)	; yes - taking care of MsgOut, now we need cmd
@@ -1418,9 +1342,6 @@ CyclePhase_96									; (accessed thru jvCyclePhase)
 			bne.s	@xferErr					; bra. on xfer error
 			move.b	rFFO(a3), d0				; just empty the FIFO
 			move.b	#cMsgAcep, rCMD(a3)			; load msg accepted code which de-asserts ACK
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			jsr		WaitForSCSIIntrp			; Wait for intrp w/ timeout
 												;    on exit d5 = rFOS|rINT|0|rSTA
 			bra.s	@checkNextPhase
@@ -1449,11 +1370,7 @@ CyclePhase_96									; (accessed thru jvCyclePhase)
 @pDMAread
 			btst.b	#bINT, rSTA(a3)				; poll for intrp hopefully from TC zero
 			bne.s	@readAll					; bra. if we got one
-		IF forPDMDebug THEN						;								<SM8>
-			move.b	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ELSE
 			move.l	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ENDIF
 			move.b	G_bitDREQ(a4),d0			; load DREQ bit position		<4> jab
 			btst.l	d0, d5						; DREQ ?						<4> jab
 			beq.s	@pDMAread					; bra. if inactive
@@ -1470,18 +1387,11 @@ CyclePhase_96									; (accessed thru jvCyclePhase)
 @pDMAwrite
 			btst.b	#bINT, rSTA(a3)				; poll for intrp hopefully from TC zero
 			bne.s	@writeAll					; bra. if we filled all data
-		IF forPDMDebug THEN						;								<SM8>
-			move.b	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ELSE
 			move.l	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ENDIF
 			move.b	G_bitDREQ(a4),d0			; load DREQ bit position		<4> jab
 			btst.l	d0, d5						; DREQ ?						<4> jab
 			beq.s	@pDMAwrite					; bra. if inactive
 			move.w	#$EEEE, rDMA(a3)			; load filler data into FIFO
-		if nonSerializedIO Then
-			nop									; Force write to complete.		<SM8>
-		endif
 			bra.s	@pDMAwrite
 @writeAll										; Intrp will occur when REQ is asserted for the next phase
 			jsr		WaitForIntNoTime			; Expecting an intrp, clear it when occurs
@@ -1534,11 +1444,7 @@ TestForDREQ
 			jsr		SwapMMU						;  (sets up d0 with previous mode)
 
 			move.l	G_SCSIDREQ(a4), a0			; G_SCSIDREQ contains DREQ regr address
-		IF forPDMDebug THEN						;								<SM8>
-			move.b	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ELSE
 			move.l	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ENDIF
 
 			jsr		SwapMMU						; return to previous mode (in d0)
 
diff --git a/OS/SCSIMgr/SCSIMgrHW96.a b/OS/SCSIMgr/SCSIMgrHW96.a
--- a/OS/SCSIMgr/SCSIMgrHW96.a
+++ b/OS/SCSIMgr/SCSIMgrHW96.a
@@ -15,17 +15,8 @@
 ;	  <SM13>	  2/5/93	CSS		Horror rollin. Export some entry points for the BIOS ROM SCSI
 ;		<H5>	  9/6/92	jab		Exported some entry points for the BIOS ROM SCSI Mgr to use.
 ;									mgr.
-;	  <SM12>	 1/26/93	SAM		Added various NOPs after the xferCount reg gets loaded before a
-;									xferInfo cmd is sent for NonSerializedIO machines.  Added not
-;									forROM conditionals around all 24-bit/swapmmu code in here just
-;									for grins.  Crippled all fast read/write routins for PDM only to
-;									not be fast (ie to use the slow FIFO xfer routines till Jimmy
-;									fixes his shit.)
 ;	  <SM11>	12/23/92	RC		Added Support for Smurf on Wombat
 ;	  <SM10>	12/11/92	SAM		Removed PDM bring-up hacks.
-;	   <SM9>	 12/3/92	fau		Changed the use of DAFBExists to check for the
-;									Spike/Eclipse/Zydeco/RiscQuadra box flag.  Those registers on
-;									DAFB are only needed on those machines.
 ;	   <SM8>	 11/3/92	SWC		Changed SCSIEqu.a->SCSI.a.
 ;	   <SM7>	10/18/92	CCH		Added nop's to support non-serial IO space, conditionals to use
 ;									byte accesses to the DREQ register, and a hack to bypass
@@ -165,63 +156,27 @@ SCSIHW96	PROC		EXPORT
 InitHW_SCSI96
 
 			move.b	#cRstSChp, rCMD(a3)			; Reset the Chip (not the bus)
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM12>
-		endif
 			move.b	#cNOP, rCMD(a3)				; C96 NOP required after HW or SW reset
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO
 			
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM12>
-		endif
 			move.b	#initCF1, rCF1(a3)			; load init config. value which affects:
 												;	busID, SCSI reset reporting & parity checking
 												
 			move.b	#initCF2, rCF2(a3)			; load init config. value
 			
 			move.b	#initCF3, rCF3(a3)			; load init config. value
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			
 ;	Check whether or not we're 25 or 33MHz and set SCSI bus speed values appropriately			<T6> thru next <T6>
 
 			TestFor	VIA2Exists					; see if we should check 25/33MHz VIA2 bit
-			beq		@dontChk					; if there's not a VIA2, don't do it.
+			beq.s	@dontChk					; if there's not a VIA2, don't do it.
+			TestFor	DAFBExists
+			beq.s	@dontChk
 
-;  	Change to check for BoxFlags for Spike/Eclipse/Zydeco, instead of DAFBExists, since this
-;   special stuff only applies to those 3 machines.												<SM9>
-
-			move.l	UnivInfoPtr,A0				; get pointer to universal table					
-			cmp.b	#BoxQuadra700,ProductInfo.ProductKind(A0)	; check for a Spike	
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco
-			cmp.b	#BoxQuadra900,ProductInfo.ProductKind(A0)	; check for a Eclipse	
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco
-			cmp.b	#BoxQuadra950,ProductInfo.ProductKind(A0)	; check for a Zydeco	
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco
-		IF forSmurf THEN
-			cmp.b	#boxRiscQuadra700,ProductInfo.ProductKind(A0)	; check for a RISC Spike	<SM15>				
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco		<SM15>
-			cmp.b	#boxRiscQuadra900,ProductInfo.ProductKind(A0)	; check for a RISC Quadra900<SM15>
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco		<SM15>
-			cmp.b	#boxRiscQuadra950,ProductInfo.ProductKind(A0)	; check for a RISC Quadra950<SM15>				
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco		<SM15>
-			cmp.b	#boxRiscCentris610,ProductInfo.ProductKind(A0)	; check for a RISC Centris610<SM15>					
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco		<SM15>
-			cmp.b	#boxRiscCentris650,ProductInfo.ProductKind(A0)	; check for a RISC Centris650<SM15>					
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco		<SM15>
-			cmp.b	#boxRiscQuadra800,ProductInfo.ProductKind(A0)	; check for a RISC Quadra800<SM15>					
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco		<SM15>
-			cmp.b	#boxRiscQuadra610,ProductInfo.ProductKind(A0)	; check for a RISC Quadra610<SM16>					
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco		<SM16>
-			cmp.b	#boxRiscQuadra650,ProductInfo.ProductKind(A0)	; check for a RISC Quadra650<SM16>					
-			beq.s	@DoSpikeEclipseZydeco		; Special setup for Spike/Eclipse/Zydeco		<SM16>
-		ENDIF									; for Smurf
-			bra.s	@dontChk					; only Spike/Eclipse have a VIA2 and DAFB
-
-@DoSpikeEclipseZydeco							;												<SM9>
+			move.l	a0,-(sp)
 			move.l	VIA2,a0						; and get VIA2 so that we can check the speed bit
 			move.b	vBufB(a0),d0				; read PBx values for 25/33MHz checks
+			move.l	(sp)+,a0
 			btst	#v2Speed,d0					; are we 25 MHz or 33 Mhz?
 			beq.s	@25MHz						; IF Speed == 33MHz THEN
 			move.l	#tsc_cf_stg_33,(a4)			;     setup DAFB SCSI config register.
@@ -245,20 +200,6 @@ InitHW_SCSI96
 			move.l	UnivInfoPtr,A0				; get pointer to universal table					<T9>
 			cmp.b	#boxQuadra700,ProductInfo.ProductKind(A0)	; check for a Spike					<T9><2>
 			beq.s	@ForSpike					; (note - BoxFlag is not defined yet!)				<T9>
-		IF forSmurf THEN
-			cmp.b	#boxRiscQuadra700,ProductInfo.ProductKind(A0)	; check for a RISC Quadra700	<SM15>	
-			beq.s	@ForSpike					; (note - BoxFlag is not defined yet!)				<SM15>
-			cmp.b	#boxRiscCentris610,ProductInfo.ProductKind(A0)	; check for a RISC Centris610	<SM15>
-			beq.s	@ForSpike					; (note - BoxFlag is not defined yet!) 				<SM15>
-			cmp.b	#boxRiscCentris650,ProductInfo.ProductKind(A0)	; check for a RISC Centris650	<SM15>
-			beq.s	@ForSpike					; (note - BoxFlag is not defined yet!) 				<SM15>
-			cmp.b	#boxRiscQuadra800,ProductInfo.ProductKind(A0)	; check for a RISC Quadra800	<SM15>
-			beq.s	@ForSpike					; (note - BoxFlag is not defined yet!) 				<SM15>
-			cmp.b	#boxRiscQuadra610,ProductInfo.ProductKind(A0)	; check for a RISC Quadra610	<SM16>					
-			beq.s	@ForSpike					;													<SM16>
-			cmp.b	#boxRiscQuadra650,ProductInfo.ProductKind(A0)	; check for a RISC Quadra650	<SM16>					
-			beq.s	@ForSpike					; 													<SM16>
-		ENDIF									; for Smurf
 
 ;	Check for difference between 25 and 33MHz Eclipse machines:										<T6>
 
@@ -288,21 +229,11 @@ InitHW_SCSI96
 			move.b	#ccf20to25MHz, rCKF(a3)		; load clock conversion factor (CCF) value
 			move.b	#SelTO25Mhz, rSTO(a3)		; load select/reselect timeout value
 @1
-
-		IF forPDMDebug THEN						; SAM (someone shouyld fix that shit above!)		<SM12>
-			move.b	#ccf15to20MHz, rCKF(a3)		; load clock conversion factor (CCF) value
-			move.b	#SelTO16Mhz, rSTO(a3)		; load select/reselect timeout value
-			nop
-		ENDIF
-
 			move.b	#initOp, rSYO(a3)			; select syn or async operation; if sync then
 												;   sync offset value must be nonzero
 												; Set synch xfer period and offset if using
 												;	synch data xfer
 @4
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			move.b	rINT(a3), d0				; read & clear rFOS, rSTA & rINT into throwaway		<T6>
 			rts
 
@@ -400,6 +331,13 @@ linkSize		EQU	*
 		
 Transfer_96:
 			link	a6, #linkSize				; allocate local storage
+
+			moveq.l	#5,d0
+			cmp.b	#cpu68040,CPUFlag
+			bne.s	@not040
+			moveq.l	#1,d0
+@not040
+
 			move.l	#0, BusErrAddr(a6)			; init so first bus err is seen as a new one
 
 			moveq.l	#noErr, d0					; assume no error
@@ -409,17 +347,12 @@ Transfer_96:
 			movem.l a1-a5/d2-d6, -(sp)			; save registers
 
 			movea.l	a3,a1						; point to serialized chip image
-		IF NOT forPDMDebug THEN
 			adda.l	#nonSerlzdDisp,a1			; point to non-serialized chip image
-		ENDIF
 
 			bsr		HandleSelInProg				; handle unfinished select command
 			bne.w	@phaseErr					; if it is stuck, we are not in data phase
 
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO									<T8>
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 
 ;			move.l	BusErrVct, D0				; compare old vector (at 8)						<2> <3>removed
 ;			cmp.l	jvBusErr(a4), D0			; with my vector								<2> <3>
@@ -477,9 +410,6 @@ Transfer_96:
 
 OneByteRead										;														<T2> thru next <T2>
 			move.b	#cIOXfer, rCMD(a3)			; load IO transfer cmd & begin xfers
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			jsr.w	WaitForIntNoTime			; Wait for intrp w/o timeout
 												;    on exit d5 = rFOS|rINT|0|rSTA
 			bne.s	xferErr						; bra. on xfer error
@@ -493,13 +423,7 @@ OneByteRead										;														<T2> thru next <T2>
 
 OneByteWrite
 			move.b	(a2)+, rFFO(a3)				; preload the FIFO
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			move.b	#cIOXfer, rCMD(a3)			; load IO transfer cmd & begin xfers
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM12>
-		endif
 			jsr.w	WaitForIntNoTime			; Wait for intrp w/o timeout
 												;    on exit d5 = rFOS|rINT|0|rSTA
 			bne.s	xferErr						; bra. on xfer error
@@ -521,9 +445,6 @@ errExit
 			jsr		Error						; call Error proc - for debug
 			clr.l	d1							; no bytes transferred
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			rts									;													<T4>
 
 
@@ -552,9 +473,6 @@ errExit
 
 Xfer1Byte
 			move.b	#cIOXfer, rCMD(a3)			; load IO transfer cmd & begin xfers
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			jsr.w	WaitForIntNoTime			; Wait for intrp w/o timeout
 												;    on exit d5 = rFOS|rINT|0|rSTA
 			rts									; IF z=1 then good xfer...
@@ -629,9 +547,6 @@ SlowRead_96
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO										<T8>
 			move.b	#0, rXCM(a3)				; rXCM = 0, clear most-sig. byte count
 			move.b	#$10, rXCL(a3)				; rXCL = 16 bytes, least-sig. byte value
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			and.l	#$F, d2						; d2 = remainder word count after 16-byte moves
 @read16			
 			moveq.l	#iPhaseMsk, d5				; load mask bits for phase value
@@ -662,11 +577,7 @@ SlowRead_96
 			; REQ be active in order to get DREQ.  This is why we must wait for the 17th REQ from
 			; the target--and it must remain active--before we proceed with the 16-byte transfer.
 @4
-		IF forPDMDebug THEN						;								<SM7>
-			move.b	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ELSE
 			move.l	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ENDIF
 			move.b	G_bitDREQ(a4),d0			; load DREQ bit position		<5> jab
 			btst.l	d0, d5						; DREQ ?						<5> jab
 			beq.s	@1							; loop until asserted
@@ -708,9 +619,6 @@ SlowRead_96
 			cmpi.b	#iDataIn, d5				; data-in phase bits = 001
 			bne.s	@phaseErr					; bra. on phase err
 			move.b	#cIOXfer, rCMD(a3)			; load IO transfer cmd & begin xfers
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 @3
 			btst.b	#bINT, rSTA(a3)				; check for c96 INTRP
 			beq.s	@3							; loop until we get an intrp
@@ -737,11 +645,7 @@ SlowRead_96
 @btmLeftovers
 			dbra	d0,@topLeftovers
 @removeDREQ
-		IF forPDMDebug THEN						;								<SM7>
-			move.b	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ELSE
 			move.l	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ENDIF
 			move.b	G_bitDREQ(a4),d0			; load DREQ bit position		<5> jab
 			btst.l	d0, d5						; DREQ ?						<5> jab
 			beq.s	@5							; if no DREQ, skip dummy rDMA access
@@ -779,9 +683,6 @@ SlowRead_96
 			move.l	#scsiRead, d6				; load proc ID
 			jsr		Error						; call Error proc - for debug
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO
-		if nonSerializedIO Then
-			nop									; Force write to complete.			<SM7>
-		endif
 			rts									; 									<T5>
 			
 
@@ -834,7 +735,7 @@ SlowWrite_96
 			move.l	d2, d6						; d6 = number 64KB block to perform
 			swap	d6							; upper word of d6 = lower word of d2
 			andi.l	#$0000FFFF, d2				; mask out upper word
-			beq		@2							; if 0 then we have $10000 (64K) bytes to xfer
+			beq.s	@2							; if 0 then we have $10000 (64K) bytes to xfer
 @next64KB
 			moveq.l	#iPhaseMsk, d3				; load mask bits for phase value
 			and.b	rSTA(a3), d3				; are we still in data-out phase?
@@ -846,9 +747,6 @@ SlowWrite_96
 			move.b	d4, rXCL(a3)				; TC regr (least-sig. byte) <- d4.b 
 			lsr.l	#8, d4						; get upper byte of low word
 			move.b	d4, rXCM(a3)				; TC regr (most-sig. byte) <- d4.b
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM12>
-		endif
 			move.b	#cDMAXfer, rCMD(a3)			; load DMA transfer cmd & begin xfers
 			nop									; squoosh pipeline								<T8>
 												;   DREQ* should be active at this time
@@ -890,9 +788,6 @@ SlowWrite_96
 			beq.s	@noResidual					;
 @residual			
 			move.b	(a2)+, rDMA(a3)				; xfer residual byte							<T8>
-		if nonSerializedIO Then
-			nop									; Force write to complete.						<SM7>
-		endif
 @noResidual			 
 			bsr.w	WaitForIntNoTime			; Wait for intrp w/o timeout
 												;    on exit d5 = rFOS|rINT|0|rSTA
@@ -937,9 +832,6 @@ SlowWrite_96
 			move.l	#scsiWrite, d6				; load proc ID
 			jsr		Error						; call Error proc - for debug
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO											<T4>
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			rts									; 
 
 
@@ -979,20 +871,10 @@ SlowWrite_96
 ;  7) Transfer residual byte if there is one
 
 FastWrite_96
-		IF forPDMDebug THEN						; <SM12> Jimmy, Jimmy, Jimmy....
-			cmp.b	#$44,$CB3					; PDM evt1?
-			bne.s	@fast						; -> Nope, its ok to do fast
-			bra		SlowWrite_96
-@fast
-		ENDIF
-	
 			bsr		HandleSelInProg				; handle unfinished select command
 			bne.w	@phaseErr					; if it is stuck, we are not in data phase
 @doWrite
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO										<T8>
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			moveq.l	#iPhaseMsk, d0				;
 			and.b	rSTA(a3), d0				; are we in data-out phase?
 			bne.w	phaseErr1					; data-out phase bits = 0, bra. on phase err			<T4> thru next <T4>
@@ -1013,14 +895,8 @@ FastWrite_96
 			move.b	d4, rXCL(a3)				; TC regr (least-sig. byte) <- d4.b 
 			lsr.l	#8, d4						; get upper byte of low word
 			move.b	d4, rXCM(a3)				; TC regr (most-sig. byte) <- d4.b						
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM12>
-		endif
 			move.b	#cDMAXfer, rCMD(a3)			; load DMA transfer cmd & begin xfers
 												;   DREQ* should be active at this time
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			move.w	d2, d4						; d4 = copy of transfer count
 			lsr.w	#5, d4						; divide xfer count by 32 
 			ror.l	#1, d2						; xfer byte count to word & remember odd byte
@@ -1056,9 +932,6 @@ FastWrite_96
 			beq.s	@noResidual					;
 @residual			
 			move.b	(a2)+, rDMA(a3)				; xfer residual byte					<T8>
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 @noResidual			 
 			bsr.w	WaitForIntNoTime			; Wait for intrp w/o timeout
 												;    on exit d5 = rFOS|rINT|0|rSTA
@@ -1074,9 +947,6 @@ FastWrite_96
 @misAligned										;
 			subq.l	#1, d2						; adjust for transfer count calc
 			move.b	(a2)+, rFFO(a3)				; ...preload fifo with odd byte			<T4> thru next <T4>
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			bra.w	@next64KB					; now we're word aligned
 @phaseErr
 			moveq.l	#scPhaseErr, d0				; return a phase error
@@ -1100,9 +970,6 @@ FastWrite_96
 			move.l	#scsiWBlind, d6				; load proc ID
 			jsr		Error						; call Error proc - for debug
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO							<T4>
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			rts									; 
 
 
@@ -1142,19 +1009,10 @@ FastWrite_96
 ;  7) Transfer residual byte if there is one
 
 FastRead_96
-		IF forPDMDebug THEN						; <SM12> Jimmy, Jimmy, Jimmy....
-			cmp.b	#$44,$CB3					; PDM evt1?
-			bne.s	@fast						; -> Nope, its ok to do fast
-			bra		SlowRead_96
-@fast
-		ENDIF
 			bsr		HandleSelInProg				; handle unfinished select command
 			bne.w	@phaseErr					; if it is stuck, we are not in data phase
 @doRead
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO										<T8>
-		if nonSerializedIO Then
-			nop									; Force write to complete.							<SM7>
-		endif
 			moveq.l	#iPhaseMsk, d0				; load mask for phase bits								<T4> thru next <T4>
 			and.b	rSTA(a3), d0				; are we in data-in phase?
 			cmpi.b	#iDataIn, d0				; data-in phase bits = 001
@@ -1174,9 +1032,6 @@ FastRead_96
 			move.b	d4, rXCM(a3)				; TC regr (most-sig. byte) <- d4.b						<T4>
 			move.b	#cDMAXfer, rCMD(a3)			; load DMA transfer cmd & begin xfers
 												;   DREQ* should be active at this time
-		if nonSerializedIO Then
-			nop									; Force write to complete.							<SM7>
-		endif
 ;			move.l	a2, d5						;
 ;			btst.l	#0, d5						; check if input buffer is on word boundary
 ;			bne.s	@misAligned
@@ -1257,9 +1112,6 @@ FastRead_96
 			move.l	#scsiRBlind, d6				; load proc ID
 			jsr		Error						; call Error proc - for debug
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO										<T4>
-		if nonSerializedIO Then
-			nop									; Force write to complete.							<SM7>
-		endif
 			rts									;
 
 
@@ -1303,9 +1155,6 @@ ResetBus_96
 												; disable all intrps
 			move.b	#cRstSBus, rCMD(a3)			; load reset scsi bus cmd							<T3>
 												; re-enable all intrps
-		if nonSerializedIO Then
-			nop									; Force write to complete.							<SM7>
-		endif
 			rts	
 
 
@@ -1378,9 +1227,6 @@ HandleSelInProg
 @wtForFC
 			bsr.w	WaitForIntNoTime
 			move.b	#cFlshFFO, rCMD(a3)				; Flush FIFO							<3>
-		if nonSerializedIO Then
-			nop									; Force write to complete.					<SM7>
-		endif
 			moveq.l	#0, d0
 			bra.s	@gotInt
 
@@ -1420,11 +1266,7 @@ Wt4DREQorInt
 			jsr		SwapMMU						; do it, puts previous mode in D0
 
 			move.l	G_SCSIDREQ(a4), a0			; G_SCSIDREQ contains DREQ regr address
-		IF forPDMDebug THEN						;								<SM7>
-			move.b	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ELSE
 			move.l	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ENDIF
 
 		; out of 32-bit mode (return to previous mode - already in D0)
 			jsr		SwapMMU						; do it, call _SwapMMUMode jump vector
@@ -1538,9 +1380,6 @@ WaitForSCSIIntrp
 ;  7) Transfer residual byte if there is one
 
 FastComp_96
-		IF forPDMDebug THEN						; <SM12> Jimmy, Jimmy, Jimmy....
-			bra		SlowComp_96
-		ENDIF
 			bsr		HandleSelInProg				; handle unfinished select command
 			bne.w	@phaseErr					; if it is stuck, we are not in data phase
 @doRead
@@ -1564,9 +1403,6 @@ FastComp_96
 			move.b	d4, rXCM(a3)				; TC regr (most-sig. byte) <- d4.b
 			move.b	#cDMAXfer, rCMD(a3)			; load DMA transfer cmd & begin xfers
 												;   DREQ* should be active at this time
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 
 			ror.l	#1, d2						; xfer byte count to word & remember odd byte
 			subq.w	#1, d2						; adjust for DBRA
@@ -1614,9 +1450,6 @@ FastComp_96
 			move.l	#scsiRBlind+$F0, d6			; load proc ID, Fast compare
 			jsr		Error						; call Error proc - for debug
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			rts									; 
 			
 
@@ -1690,9 +1523,6 @@ SlowComp_96
 			and.l	#$F, d2						; d2 = remainder word count after 16-byte moves
 @read16			
 			move.b	#cDMAXfer, rCMD(a3)			; load DMA transfer cmd & start loading FIFO
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 @1												;   currently loaded transfer count is used/reused
 			btst.b	#bINT, rSTA(a3)				; poll for unexpected intrp while waiting
 			bne.s	@prematureEnd				; ... maybe disconnected, phase changed, etc.
@@ -1705,11 +1535,7 @@ SlowComp_96
 			; REQ be active in order to get DREQ.  This is why we must wait for the 17th REQ from
 			; the target--and it must remain active--before we proceed with the 16-byte transfer.
 
-		IF forPDMDebug THEN						;								<SM7>
-			move.b	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ELSE
 			move.l	(a0), d5					; read DAFB regr (a0=DAFB register addr)
-		ENDIF
 			move.b	G_bitDREQ(a4),d0			; load DREQ bit position		<5> jab
 			btst.l	d0, d5						; DREQ ?						<5> jab
 			beq.s	@1							; loop until asserted
@@ -1740,9 +1566,6 @@ SlowComp_96
 			cmpi.b	#iDataIn, d5				; data-in phase bits = 001
 			bne.s	@phaseErr					; bra. on phase err
 			move.b	#cIOXfer, rCMD(a3)			; load IO transfer cmd & begin xfers
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 @3
 			btst.b	#bINT, rSTA(a3)				; check for c96 INTRP
 			beq.s	@3							; loop until we get an intrp
@@ -1788,9 +1611,6 @@ SlowComp_96
 			move.l	#scsiRead+$F0, d6			; load proc ID, Slow compare
 			jsr		Error						; call Error proc - for debug
 			move.b	#cFlshFFO, rCMD(a3)			; Flush FIFO
-		if nonSerializedIO Then
-			nop									; Force write to complete.				<SM7>
-		endif
 			rts									; 										<T5>
 			
 
diff --git a/OS/SCSIMgr/SCSIMgrInit96.a b/OS/SCSIMgr/SCSIMgrInit96.a
--- a/OS/SCSIMgr/SCSIMgrInit96.a
+++ b/OS/SCSIMgr/SCSIMgrInit96.a
@@ -14,7 +14,6 @@
 ;	  <SM11>	01-11-93	jmp		Updated various BoxFlag names.
 ;	  <SM10>	12/23/92	RC		Added Support for Smurf on Wombat
 ;	   <SM9>	 11/3/92	SWC		Changed SCSIEqu.a->SCSI.a.
-;	   <SM8>	10/18/92	CCH		Added support to use new DREQ location in PDM.
 ;	   <SM7>	  8/9/92	CCH		Modified boxflag check for Quadras to include RISC Quadras.
 ;		 <4>	 5/22/92	DTY		#1029009 <jab>: Added support for Wombat DREQ testing.
 ;		 <3>	  5/1/92	JSM		Whoops, rolled in the fix from SuperMario incorrectly in the
@@ -57,7 +56,7 @@
 										;	don't print includes
 
 			LOAD		'StandardEqu.d'			; from StandardEqu.a and for building ROMs
-			INCLUDE		'HardwareEqu.a'			;													<T2>
+			INCLUDE		'HardwarePrivateEqu.a'			;													<T2>
 			INCLUDE		'SCSI.a'
 			INCLUDE 	'SCSIPriv.a'
 			INCLUDE		'UniversalEqu.a'		; for TestFor										<T2>
@@ -193,13 +192,7 @@ InitMgr_SCSI96
 
 			clr.b	G_bitDREQ(a4)					; initialize bit position of DREQ regr			<H4> thru to next <H4> jab
 
-			TestFor	HMCDecoder						; are we PDM ?									<SM8>
-			beq.s	@notPDM
-			move.b	#bDREQ_PDM,G_bitDREQ(a4)		; setup bit location of DREQ check
-			move.l	#SCSI0_DREQ_PDM,pdma5380(a4)	; setup DREQ location	
-			bra.s	@chk2Bus						;												<SM8>
-
-@notPDM		cmpi.b	#boxQuadra700,BoxFlag			; are we a Quadra 700?
+			cmpi.b	#boxQuadra700,BoxFlag			; are we a Quadra 700?
 			beq.s	@wereQuadra						; yes ... set our DREQ location
 
 			cmpi.b	#boxQuadra900,BoxFlag			; are we a Quadra 900?
diff --git a/OS/SCSIMgr/SCSIMgrInitPSC.a b/OS/SCSIMgr/SCSIMgrInitPSC.a
--- a/OS/SCSIMgr/SCSIMgrInitPSC.a
+++ b/OS/SCSIMgr/SCSIMgrInitPSC.a
@@ -56,6 +56,7 @@
 			INCLUDE 	'SCSIPriv.a'
 			INCLUDE		'UniversalEqu.a'		; for TestFor										<T2>
 			INCLUDE		'SCSIEqu96.a'
+			INCLUDE		'LinkedPatchMacros.a'
 
 			PRINT		ON				; do send subsequent lines to the listing files
 
diff --git a/OS/SlotMgr/SlotMgr.a b/OS/SlotMgr/SlotMgr.a
--- a/OS/SlotMgr/SlotMgr.a
+++ b/OS/SlotMgr/SlotMgr.a
@@ -19,7 +19,6 @@
 ;	  <SM11>	11/18/92	kc		Import GetDriverPatch to fix problem introduced by last checkin.
 ;	  <SM10>	11/17/92	kc		Add "IF NOT LC930 THEN" around GetDriverPatch to facilitate dead
 ;									code stripping for the LC930 build.
-;	   <SM9>	10/22/92	CSS		Change some branch short instructions to branches.
 ;	   <SM8>	09-24-92	jmp		Fixed a bug in the GetDevIndex utility where a register was
 ;									being trashed.
 ;	   <SM7>	 6/30/92	kc		Roll in Horror, comments follow:
@@ -391,14 +390,14 @@ GetcString	Proc	Export
 			move.b	spSlot(a0),-(sp)				; save the slot
 
 			_sFindStruct							; get the ptr to the string
-			bne 	@Done							; <SM9> CSS
+			bne.s	@Done
 			movea.l	spsPointer(a0),a3				; a3 = ptr to the string
 
 ;  Calculate the step register
 
 			bset.b	#fConsecBytes,spFlags(a0)		; calc for consecutive bytes
 			_sCalcStep
-			bne 	@Done							; <SM9> CSS 
+			bne.s	@Done
 			move.l	spResult(a0),d1					; d1 = step register
 
 ;	Loop and count all the chars in the string so we know how big a block to allocate. 
@@ -866,8 +865,6 @@ FindDevBase	Proc	Export
 			bne.s	@Major							; minor base offset not found
 			move.l	spResult(a0),d1					; d1 = minor base offset
 			and.l	#$00ffffff,d1					; max offset in minor slot space
-			tst.b	spSlot(a0)						; getting base addr for slot zero ?				<H2>
-			beq.s	@SlotZero
 			bra.s	@FormSmall						; form a 1Mb or 16Mb ptr
 
 ;	No minor base - try to get the major base offset
@@ -877,8 +874,6 @@ FindDevBase	Proc	Export
 			bne.s	@Done							; major base offset not found - error
 			move.l	spResult(a0),d1					; d1 = major base offset
 			and.l	#$0fffffff,d1					; max offset in major slot space
-			tst.b	spSlot(a0)						; getting base addr for slot zero ?				<H2>
-			beq.s	@SlotZero
 
 ;	Form a major base pointer (256Mb space) : d2 = slot number
 
@@ -928,9 +923,6 @@ FindDevBase	Proc	Export
 			movea.l	(sp)+,a1						;										<1.8>
 			rts
 
-@SlotZero	Bsr.l	FindDevBaseSlot0				; Jump to our SlotZero utility.					<H2>
-			Bra.s	@RtnBase						; And exit.
-
 
 ;=========================================================================================
 ;	smAdvanced
@@ -1417,7 +1409,7 @@ EndDynLoad														;							<1.8>
 				
 ;  Get a pointer to the sResource list and find the driver directory.
 StatLoadDrvr	_sRsrcInfo										;Get a pointer to the sResource list.	<C468>
-				BNE 	SError2								; <SM9> CSS 
+				BNE.S	SError2
 				MOVE.B	#sRsrcDrvrDir,spId(ParamBlk$a0)		;Find the driver directory.
 				_sFindStruct
 				BNE.S	SError2
@@ -1454,6 +1446,7 @@ LoadDrvr		MOVE.B	#sMacOS68020,spId(ParamBlk$a0)			;Load a MacOS 68020 driver.
 																;  GOTO SError1.						<C600>
 				MOVE.L	DrvrHand$a,spResult(ParamBlk$a0)		;Put handle to the driver in spResult.	<C600>
 				JSR		([jCacheFlush])							; flush the caches  <18> rb
+				MOVEQ	#0,d0
 				BRA.S	EndStatLoad								;GOTO end.								<C600>
 				
 ;  ERRORS
@@ -1483,15 +1476,6 @@ EndStatLoad		RTS
 ;	Patch out Drivers for any Apple Cards that need it.
 
 BeginGetSlotDrvr
-			IF NOT LC930 THEN
-				Import	GetDriverPatch
-				Bsr		GetDriverPatch						; If GetDriverPatch returns a 
-				Tst.b	D0									;	result >= 0, don’t execute
-				Bge.s	ExitGetSlotDrvr						; Patched, so just return.
-			ENDIF
-;	This is the original entry-point. It is called by GetDevIndex
-				Export	OrigGetSlotDrvr
-OrigGetSlotDrvr
 				MOVEM.L	A2-A3,-(SP)								;Save registers		<C783>
 				MOVE.L	ParamBlk$a0,spBlkPtr$a					;Save spBlkPtr
 				MOVE.B	spId(ParamBlk$a0),SavedId$d				;Save Id.
@@ -1550,7 +1534,7 @@ GetDriverPatch		Proc	Export
 ;
 			Bsr		GetDevIndex							; Get the card/device index into D0.
 			Move.l	D0,D3								; If the device index is negative, then
-			Bmi 	@done								; driver doesn’t need patching.<SM9> CSS	
+			Bmi.s	@done								; driver doesn’t need patching.
 
 ; Next, check to see that we’re pointing to the sResource that has the driver or
 ;	driver loader in it (i.e., we don’t want to be opening the driver multiple
@@ -1646,7 +1630,7 @@ GetDriverPatch		Proc	Export
 			Macro										; Macro for jumping directly int
 			_GetSlotDriver								;	GetSlotDrvr (acting like trap dispatcher).								
 			Movem.l	A1/D1-D2,-(Sp)						; Save registers (A0 i/o, D0 is result).
-			Bsr.l	OrigGetSlotDrvr						; Make call.					<T8>
+;			jsr	OrigGetSlotDrvr						; Make call.					<T8>
 			Tst.w	D0									; Act like Slot Manager for result.
 			Movem.l	(Sp)+,A1/D1-D2						; Restore registers.
 			EndMacro									;
@@ -1728,28 +1712,28 @@ GetDevIndex
 			
 			Export	JsrTbl
 
-DevTbl		Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwTFB,0	 ; TFB  Entry									<11>
-			Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwJMFB,0 ; JMFB Entry									<11>
-			Dc.w	0									
+DevTbl		;Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwTFB,0	 ; TFB  Entry									<11>
+			;Dc.w	CatDisplay,TypVideo,DrSwApple,DrHwJMFB,0 ; JMFB Entry									<11>
+			;Dc.w	0									
 					
 			Align	4
 			
-LoadTbl		Dc.l	TFBDrvr-LoadTbl						; Start of TFB driver code.	
-			Dc.l	TFBDrvrSize-LoadTbl					; Length.
-			Dc.b	sRsrcDrvrDir						; TFB’s have an sRsrcDrvrDir.
-			Dc.b	0									; TFB’s are singly deviced.
-			Dc.b	0,0									; Padding.											<11>
+LoadTbl		;Dc.l	TFBDrvr-LoadTbl						; Start of TFB driver code.	
+			;Dc.l	TFBDrvrSize-LoadTbl					; Length.
+			;Dc.b	sRsrcDrvrDir						; TFB’s have an sRsrcDrvrDir.
+			;Dc.b	0									; TFB’s are singly deviced.
+			;Dc.b	0,0									; Padding.											<11>
 			
-			Dc.l	JMFBDrvr-LoadTbl					; Start of 4•8/8•24 driver code.
-			Dc.l	JMFBDrvrSize-LoadTbl				; Length.
-			Dc.b	sRsrcDrvrDir						; 4•8/8•24’s have an sRsrcDrvrDir.
-			Dc.b	0									; 4•8/8•24’s are singly deviced.
-			Dc.b	0,0									; Padding.
+			;Dc.l	JMFBDrvr-LoadTbl					; Start of 4•8/8•24 driver code.
+			;Dc.l	JMFBDrvrSize-LoadTbl				; Length.
+			;Dc.b	sRsrcDrvrDir						; 4•8/8•24’s have an sRsrcDrvrDir.
+			;Dc.b	0									; 4•8/8•24’s are singly deviced.
+			;Dc.b	0,0									; Padding.
 			
 			Align	4
 			
-JsrTbl		Dc.l	TFBPrimaryInit-JsrTbl				; TFBPrimaryInit
-			Dc.l	JMFBPrimaryInit-JsrTbl				; 4•8/8•24 PrimaryInit
+JsrTbl		;Dc.l	TFBPrimaryInit-JsrTbl				; TFBPrimaryInit
+			;Dc.l	JMFBPrimaryInit-JsrTbl				; 4•8/8•24 PrimaryInit
 
 
 ;=========================================================================================
@@ -1804,28 +1788,13 @@ CommonPRAM
 			CLR.W	D3
 			MOVE.L	D0,D1						; D1 = indicates which routine executing
 			MOVE.B	spSlot(A0),D3				; D3 = slot number with high byte clear
-			BNE.S	@CheckRange					; not slot zero
-
-; <SM2> rb, Start
-;	Check for slot zero and convert slot number to relative slot to index into PRAM.  On		<1.2>
-;	RBV machines, slot zero steals the PRAM from one of the 9-$E slots.  The slot mgr			<1.2>
-;	is only assigned enough PRAM for 6 slots.													<1.2>
-		
-			WITH 	VideoInfo					; <SM3> rb
-			movea.l	UnivInfoPtr,a1					; point to the ProductInfo record			<1.9>
-			adda.l	ProductInfo.VideoInfoPtr(a1),a1	; point to the VideoInfo record				<1.9>
-			move.b	VideoInfo.SlotNumberAlias(a1),d3; get the alias for slot zero PRAM			<1.9>
-
-@CheckRange										; not slot zero
-			MOVEA.L	spParamData(A0),A1			; A1 = ptr to buf to read to or write from		<1.9>
-
 ;	Check range for internal slots with PRAM on the motherboard
 
 			MOVE.W	#smSlotOOBErr,D0			; assume error
 			CMP.B	#sLastSlot,D3
 			BHI.S	@Done						; slot number out of range
 			CMP.B	#FirstPRAMSlot,D3			; a motherboard slot?
-			bge.s	@InternalPRAM				; good slot - get PRAM, <SM2> rb, End
+			bge.s	@InternalPRAM				; good slot - get PRAM
 
 ;	Slot number is in the expansion chassis range.  If an expansion chassis is present,		<1.5>
 ;	call a vendor routine, to handle PRAM requests.
@@ -1838,6 +1807,7 @@ CommonPRAM
 ;	Setup parameters to read or write PRAM from motherboard
 
 @InternalPRAM
+			MOVE.L	$18(A0),A1
 			SUB.B	#FirstPRAMSlot,D3			; convert slot to relative index
 			MULU.W	#SizesPRAMRec,D3			; index to PRAM record for slot
 			ADD.W	#SMPRAMTop,D3				; add offset to slot manager PRAM 
@@ -1963,48 +1933,46 @@ GetsRsrcPtr
 PtrToSlot	Proc	Export
 			With	spBlock
 
-			movem.l	d1-d2,-(sp)						; <SM2> rb
+			movem.l	d1/a1,-(sp)
 
-;  Verify a good sPointer
-													; <SM2> rb, Start
-			MOVE	#smsPointerNil,D0				; assume nil ptr - set error status
+;	Fail on nil pointer
+
+			CLR.B	spSlot(A0)
+
+			MOVE	#smSlotOOBErr,D0				; assume nil ptr - set error status
 			MOVE.L	spsPointer(A0),D1				; D1 = sPointer
 			BEQ.S	@Done							; nil pointer - error
 
+;	Test for slot 0 (host)
+
+			CMP.L	RealMemTop,D1					; inside RAM = slot 0
+			BLS.S	@OK
+
+			MOVE.L	ROMBase,A1						; inside ROM (256k) = slot 0
+			CMP.L	A1,D1
+			BLO.S	@NotInRom
+			ADD.L	#$40000,A1
+			CMP.L	A1,D1
+			BLS.S	@OK
+@NotInRom
+
 ;  Determine the slot
 
-			clr.b	d1								; clear low byte of pointer				<2.1>
-			ROL.L	#4,D1							; determine if major or minor space
-			CMP.B	#$0F,D1							; minor space?
-			BEQ.S	@minor							; minor slot space
-
-;	Super slot space - if the high nibble is the same as ROMBase, then this is an access to
-;	the host ROM's declaration data (or ram).  Translate it into slot 0.
-
-			MOVE.B	ROMBase,D2						; D2 = high byte of ROMBase
-			lsr.b	#4,d2							; shift high nib to low nibble			<2.1>
-			CMP.B	D2,D1							; same?
-			BHI.S	@FoundSlot						; must be other super slot space
-			
-;	Pointer is to ram or rom.  Translate it to slot 0.
-			
-			MOVEQ	#0,D1							; access to host ROM - translate to slot 0
-			BRA.S	@FoundSlot
-
-@minor		clr.b	d1								; sxxxxx0F to sxxxxx00					<2.1>
-			ROL.L	#4,D1							; minor space - reg D1 = xxxxx00s
-
-@FoundSlot	MOVE.W	#smSlotOOBErr,D0				; assume out of bounds
+			ROL.L	#4,D1
+			CLR.B	D1
+			ROL.L	#4,D1
+			BEQ.S	@Done
 			CMP.B	#sLastSlot,D1					; good slot number?
 			BHI.S	@Done							; must be slot $0F which is bad
 
 			MOVE.B	D1,spSlot(A0)					; return slot number
-			MOVEQ	#0,D0							; set good return
-			
+		
+@OK			MOVEQ	#0,D0							; set good return
+
 @Done		TST		D0								; set condition codes
-			movem.l	(sp)+,d1-d2
+			movem.l	(sp)+,d1/a1
 			RTS										; done - PtrToSlot
-			ENDP									; <SM2> rb, End
+			ENDP
 
 ;_______________________________________________________________________________________
 ;	ReadFHeader  -  copy a declaration ROM's format header block
@@ -2553,13 +2521,8 @@ DeleteSRTRec
 
 ;	Last SRT block is empty - free the block.  Traverse SRT to end to nil the link ptr.
 
-@Free		MOVE.B	mmu32Bit,-(SP)				; save current mmu state <SM2> rb
-			MOVE.B	#false32b,D0				; <SM2> rb
-			_SwapMMUMode						; switch to 24 bit mode <SM2> rb
-			MOVEA.L	A2,A0						; A0 = ptr to last SRT blk
+@Free		MOVEA.L	A2,A0						; A0 = ptr to last SRT blk
 			_DisposPtr							; free the block
-			MOVE.B	(SP)+,D0					; recover status <SM2> rb
-			_SwapMMUMode						; restore mmu state <SM2> rb
 			MOVEA.L	sRsrcTblPtr,A1				; get ptr to beginning of SRT
 @Loop1		ADDA.W	#srtBlkSize,A1				; inc to end of blk
 			CMPA.L	srtNext(A1),A2				; found end of link ?
@@ -2793,11 +2756,14 @@ pInitEntry
 
 ;	If there is a valid reference number, then find the DCE and calculate the dCtlDevBase	<1.5>
 
-			MOVEQ	#0,D0							; set a good return					<SM2> rb
-			MOVE.W	spRefNum(A0),D1					; get ref num						<SM2> rb
-			BEQ.S	@Done							; no ref num - done					<SM2> rb
-			BSR.S	MapUnit							; return reg A2 = ptr to DCE		<SM2> rb
-			BNE.S	@Error							; some error with ref num or DCE	<SM2> rb
+			MOVEQ	#0,D0							; set a good return
+			MOVE.W	spRefNum(A0),D1					; get ref num
+			BEQ.S	@Done							; no ref num - done
+			MOVE.W	#rfNumErr,D0					; set a bad return
+			NOT.W	D1								; test for valid ref number
+			BMI.S	@Error							; invalid - error
+			MOVE.L	([UTableBase],D1.W*4),A2		; DCE handle
+			MOVE.L	(A2),A2							; dereference handle
 
 ;	Read a 24 or 32 bit base address from the sResource										<2.0>
 
@@ -2824,41 +2790,8 @@ pInitEntry
 			MOVEM.L	(SP)+,D1/A2						; restore regs
 			TST.W	D0								; set CCR
 			RTS
-; <SM2> rb, from Zydeco...I give you MapUnit !
-;_______________________________________________________________________________________	<1.5>
-;	MapUnit  -  map a reference number to a pointer to a DCE
-;
-;	Given a driver reference number, get the pointer to it's DCE
-;
-;	Input	: reg D1 = reference number
-;
-;	Output	: reg A2 = ptr to DCE
-;				  D0 = status, 0=ok		CCR reflects status
-;
 
-MapUnit
-			MOVE.W	#rfNumErr,D0		; setup bad ref num error return
-		 	NOT.W	D1					; bitwise complement to get unitnum
-			BMI.S	@Done
-			CMP.W	UnitNtryCnt,D1		; is it in range ?
-			BGE.S	@Done	 			; skip if it's not
 
-			ASL.W	#2,D1				; multiply by four
-			MOVE.L	UTableBase,A2		; get address of unit table
-			MOVE.L	0(A2,D1.W),D1		; add in the offset
-			BEQ.S	@Done 				; branch if there is no driver installed
-
-			MOVE.L	D1,A2				; DCE handle
-			MOVE.L	(A2),D1 			; dereference handle
-			BEQ.S	@SysErr				; DCE should never be purged - call sys error
-			MOVE.L	D1,A2				; pointer to Device Control Entry
-			MOVEQ	#0,D0				; init good return
-
-@Done		TST.W	D0
-			RTS
-
-@SysErr		MOVEQ	#dsIOCoreErr,D0 	; deep shit IOCore error
-			_SysError					; invoke deep shit
 
 ;_______________________________________________________________________________________	<2.0>
 ;	pAllocSRTBlk  -  allocate and initialize an SRT block
@@ -3523,521 +3456,6 @@ pRestoreBus
 
 			ENDWITH									; { stackframe,slotGlobals }			<5>
 
-
-;____________________________________________________________________________
-;
-;  Routine:		p040BusException
-;
-;  Inputs:		a2	-	address to return to from exception when a bus error occurs
-;
-;  Outputs:		ccr set to value in reg d0
-;
-;  Function:	nubus bus error exception handler for 68040-based machines
-;
-;____________________________________________________________________________
-				Export	p040BusException
-p040BusException						;									
-
-;	The 040 Special Status Word (SSW) is different than the 020/030 one.  It looks like	
-;																						
-;		+---------------------------------------------------------------------+			
-;		| CP | CU | CT | CM | MA | ATC | LK | RW | X |  SIZE  |  TT  |   TM   |			
-;		+---------------------------------------------------------------------+			
-;		  15   14   13   12   11   10    9    8    7   6    5  4   3  2      0			
-;																						
-;																						
-;			CP		=	Continuation - Floating Pt. Post Exception Pending				
-;			CU		=	Continuation - Unimplemented Floating Pt. Instruction Exception	
-;			CT		=	Continuation - Trace Exception Pending							
-;			CM		=	Continuation - MOVEM Instruction Execution Pending				
-;			MA		=	Misaligned Access												
-;			ATC		=	ATC Fault														
-;			LK		=	Locked Transfer													
-;			RW		=	Read/Write (1=Read)												
-;			X		=	Undefined														
-;			SIZE	=	Transfer Size													
-;			TT		=	Transfer Type													
-;			TM		=	Transfer Modifier												
-
-aeStackFrame	RECORD		0						; 040 Access Stack Frame				
-savereg			DS.L		1						; space to save working register (D0)
-aeSR			DS.W		1						; status register					
-aePC			DS.L		1						; program counter					
-aeType			DS.B		1						; type of exception stack frame		
-less			DS.B		1						; filling (vector offset)			
-aeEffAddr		DS.L		1						; effective address					
-aeSSW			DS.W		1						; special status word				
-aeWBnS			DS.W		3						; WriteBack #n Status				
-aeFA			DS.L		1						; fault address						
-aeWB3Addr		DS.L		1						; WriteBack 3 Address				
-aeWB3Data		DS.L		1						; WriteBack 3 Data					
-aeWB2Addr		DS.L		1						; WriteBack 2 Address				
-aeWB2Data		DS.L		1						; WriteBack 2 Data					
-aeWB1Addr		DS.L		1						; WriteBack 1 Address				
-aeWB1Data		DS.L		1						; WriteBack 1 Data/Push Data LW0	
-aePD1			DS.L		1						; Push Data LW 1					
-aePD2			DS.L		1						; Push Data LW 2					
-aePD3			DS.L		1						; Push Data LW 3					
-				ENDR
-
-aeXFrameSize	EQU		$3C							; size of an Access Error stack frame	
-aeXFrameType	EQU		$07							; access error exception frame type		
-
-
-			WITH	aeStackFrame,slotGlobals		;									
-
-;	Verify that this is a faulted NuBus read data cycle									
-
-			move.l	d0,-(SP)						; save working register				
-			move.w	aeSSW(SP),d0					; retrieve SSW						
-			andi.w	#$0518,d0						; mask off only ATC, RW, TT			
-			cmp.w	#$0100,d0						; should be ATC=0, RW=1, TT=0		
-			bne.s	@RealBusEx						; can't handle these case - pass it on
-			move.b	aeType(SP),d0					; get format of stack frame			
-			lsr.b	#4,d0							; look at high nibble				
-			cmp.b	#aeXFrameType,d0				; access error exception frame?		
-			bne.s	@RealBusEx						; NO  ... use sys. access error handler
-			move.b	aeFA(SP),d0						; get high byte of fault address	
-			cmp.b	#majorSpace,d0					; in super slot space ($60-$E0)?	
-			blo.s	@RealBusEx						; not in slot address space			
-			cmp.b	#$FF,d0							; in minor slot space range?		
-			beq.s	@RealBusEx						; not in minor slot space			
-			cmp.b	#$F0,d0							; in minor slot space range?		
-			beq.s	@RealBusEx						; not in minor space $F1 - $FE		
-
-;	Have verified that a NuBus read data access caused the bus error.  Pop the exception
-;	stack frame and jump to the error return address in register a2.
-;
-;	***	I don't think this will work correctly.  Given that you could have other exceptions
-;	***	of a lesser priority pending, and could possibly have pending writebacks as well,
-;	***	does this code need to look to complete those writebacks, stuff A2 into aePC(SP)
-;	*** and do an RTE?  Or can we legally/safely stuff A2 into aePC(SP)?				
-
-;			move.l	(sp)+,d0						; restore reg d0					
-;			adda.w	#aeXFrameSize,sp				; pop the exception stack frame		
-;			jmp		(a2)							; take the error return address		
-
-			move.l	a2,aePC(SP)						; (re-)set the PC to where we want to go
-			move.l	(sp)+,d0						; restore reg d0						
-			rte										; return, catching any pending exceptions
-
-;	The bus exception was not caused by a read to NuBus - pass the exception to the
-;	real bus exception handler.
-
-@RealBusEx	MOVE.L	(SP)+,D0						; restore reg D0
-			MOVE.L	([sInfoPtr],sysBusExcptn),-(SP)	; put saved bus exception vector on stack
-			RTS										; jump to bus exception vector
-
-			ENDWITH									; { aeStackFrame,slotGlobals }		
-
-;_______________________________________________________________________________________	<h7> djw
-;	AddCard	-	add a card to the slot manager data structures
-;
-;	There is a stub entrypoint for this routine in the file slotInfo.a which does a long
-;	branch here.  The stub routine is needed for the slot manager's jump table offset
-;	limitation.
-;
-;	Add a card to the slot manager's data structures and run it's primaryInit.  If the
-;	card's current status is not empty, then the slot is rejected as not valid.  Memory
-;	is allocated, so this routine should not be run at interrupt time.
-;
-;	Input	:	a0 = ptr to spBlock
-;	Output	:	none
-;
-;	spBlock	:	-> spSlot			slot number (slot 0 is not valid)
-;
-			Export	AddCard
-			with	spBlock,sInfoRecord,seBlock
-AddCard
-@regs		reg		d1/a0/a2
-			movem.l	@regs,-(sp)
-
-;	If the current slot status is not empty, then the slot may not be re-initialized
-
-			_sFindsInfoRecPtr					; get ptr to sInfoRecord
-			bne		@Done						; slot not valid - done
-			movea.l	spResult(a0),a2				; a2 = ptr to sInfoRecord
-			move.w	#smSlotOOBErr,d0			; assume bad slot
-			cmp.w	#smEmptySlot,		\		; check for empty slot
-					siInitStatusA(a2)
-			bne.s	@Done						; only empty slots are valid
-
-;	Execute the slot manager initialization again on this slot
-
-			slotjsr	initSDeclMgr				; initialize a slot's sInfoRecord
-			slotjsr	sInitSRsrcTable				; initialize the slot resource table (SRT)
-			slotjsr	sInitPRAMRecs				; initialize a slot's PRAM
-
-			clr.b	spFlags(a0)					; clear flag bit to assume cold start
-			cmp.l	#WmStConst,WarmStart		; check low mem for warm start value
-			bne.s	@continue					; cold start
-			bset.b	#fWarmStart,spFlags(a0)		; warm start
-
-@continue
-			move.w	sr,-(sp)
-			ori.w	#HiIntMask,sr				; disable ints for primary init
-			slotjsr	sPrimaryInit				; execute the primaryInit
-			move.w	(sp)+,sr					; restore ints
-
-;	Execute the secondaryInit record														<h12> thru next <h12>
-
-			lea		-seBlockSize(sp),sp			; alloc seBlock
-			movea.l	sp,a2						; a2 = ptr to seBlock
-			move.l	a2,spsExecPBlk(a0)			; set ptr in spblock to sExec blk
-			move.b	#BoardId,sesRsrcId(a2)		; indicates exec code is from board sResource
-			slotjsr	sDoSecondary				; jump thru the vector
-			lea		seBlockSize(sp),sp			; dealloc seBlock							<h12> from last <h12>
-
-@Done
-			movem.l	(sp)+,@regs
-			rts
-			endwith
-
-
-;_______________________________________________________________________________________	<h7> djw
-;	RemoveCard	-	Remove a card from the slot manager
-;
-;	This routine will remove a card from the system by:
-;
-;		1.	Delete all sRsrc's from the SRT for that slot
-;		2.	Delete sInfoRecord and set to empty status
-;		3.	If there is a driver attached to the slot, attempt to close the driver
-;		4.	Remove any slot interrupt queue elements for the slot
-;
-;	Input	:	a0 = ptr to spBlock
-;	Output	:	none
-;
-;	spBlock	:	-> spSlot			slot number (slot 0 is not valid)
-;
-			Export	RemoveCard
-			with	spBlock,SlotIntQElement,slotIntGlobals,srrBlock,sInfoRecord
-
-RemoveCard
-@regs		reg		d1-d3/a1-a2
-			movem.l	@regs,-(sp)
-			lea		-ioQElSize(sp),sp					; alloc iopb
-			movea.l	sp,a2								;									<H14><SM13>
-			clr.l	ioCompletion(a2)					; no completion routine
-			moveq.l	#0,d1
-			move.b	spSlot(a0),d1						; d1 = slot number
-
-;	Loop through SRT deleting all sResources for this slot.
-
-@LoopAgain
-			movea.l	sRsrcTblPtr,a1						; get ptr to beginning of SRT
-			suba.w	#SRTRecSize,a1						; pre-decrement pointer
-@Loop
-			adda.w	#SRTRecSize,a1						; inc to next srrBlock
-			clr.l	spParamData(a0)						; ignore input flags because…
-			bset.b	#fall,spParamData+3(a0)				; …we need to find both enabled and disabled sRsrc's
-			slotjsr	sGetSRTEntry						; get next entry - rtn in ptr in a1
-			bne.s	@noMore								; found all sRsrc's
-			slotjsr	SrToSpBlock							; fill spBlock with srrBlock info
-			cmp.b	spSlot(a0),d1						; is this the slot we are looking at?
-			bne.s	@Loop								; not right slot - continue looking
-
-;	If there is a driver associated with this slot, attempt to close it
-
-			tst.w	spRefNum(a0)						; is there a valid refnum?
-			bpl.s	@remove								; not a refnum
-			move.w	spRefnum(a0),ioRefnum(a2)			; set refnum to close
-			move.l	a0,-(sp)							; save ptr to spBlock
-			movea.l	a2,a0								; a0 = ptr to iopb
-			_Close										; close driver
-			movea.l	(sp)+,a0							; restore a0 = ptr to spBlock
-			
-;	Delete the sRsrc from SRT
-
-@remove
-			slotjsr	sDeleteSRTRec						; delete the found sRsrc
-			bra.s	@LoopAgain							; find and delete all sRsrc's
-
-;	Delete the sInfoRecord
-
-@noMore
-			lea		([sInfoPtr],(4*TotalSlots)	\
-					+(sInfoNewSize*2)),a1				; get ptr to empty sInfo record
-			move.l	a1,([sInfoPtr],d1.w*4)				; set slot to point to empty record
-
-;	Clear the slot interrupt queue for this slot
-;	****	WARNING		****	WARNING		****
-;	This code is very implementation specific.  If slot interrupt table structure
-;	changes, this code will not work.  Also, this routine leaks memory because
-;	it does not free the slot int queue elements
-
-			lea		([SlotQDT],d1.w*4,slotIntQHeads-SQLink),a1	; get address of queue header
-			clr.l	SQLink(a1)									; zero queue link
-
-;	Done
-
-@Done
-			lea		ioQElSize(sp),sp					; de-alloc iopb
-			movem.l	(sp)+,@regs
-			rts
-
-			endwith
-
-;_______________________________________________________________________________________	<h7> djw
-;	CheckSlot	-	check if a card has changed
-;
-;	Check whether a slot's status has changed.  There are 3 slot state changes to
-;	consider:
-;
-;		1.	empty		-->		occupied
-;		2.	occupied	-->		empty
-;		3.	occupied	-->		occupied
-;
-;	If a slot goes from empty to occupied, or occupied to empty, return status that
-;	the slot's state has changed.  If a slot was previously occupied and is still
-;	occupied, then read the board id from the card and match it to the board id in
-;	PRAM.  If they are not the same, then the previous card was removed, and a new
-;	card is now in it's place.
-;
-;	Input	:	a0 = ptr to spBlock
-;
-;	Output	:	d0 = 0 if no change, non-zero if change
-;
-;	spBlock	:	-> spSlot			slot number (slot 0 is not valid)
-;
-			Export	CheckSlot
-			Import	VerifySlot
-			with	spBlock,sInfoRecord
-
-CheckSlot
-@regs		reg		d1-d3/a1-a4
-			movem.l	@regs,-(sp)
-			moveq.l	#0,d3							; set d3 = change status flag
-
-;	get ptr to slot's sInfoRecord so we can check its previous state
-
-			_sFindsInfoRecPtr						; get ptr to sInfoRecord
-			bne		@Return							; slot not valid - no change
-			movea.l	spResult(a0),a4					; a4 = ptr to sInfoRecord
-
-;	If a slot is disabled or reserved, then it is invalid
-
-			cmp.w	#smDisabledSlot,		\		; check for disabled slot
-					siInitStatusA(a4)
-			beq		@Return							; disabled slots not valid
-			cmp.w	#smReservedSlot,		\		; check for reserved slot
-					siInitStatusA(a4)
-			beq		@Return							; reserved slots not valid
-
-			moveq.l	#0,d1							; zero reg
-			move.b	spSlot(a0),d1					; d1 = slot number
-
-;	Save the current sInfoRecord for the slot
-
-			lea		-sInfoNewSize(sp),sp			; alloc temp sInfoRecord
-			move.w	d3,siInitStatusA(sp)			; clear status field
-			move.b	d3,siState(sp)					; clear state variable
-			move.w	siTOConst(a4),siTOConst(sp)		; set bus error retry cnt (not used)
-			move.b	d1,siSlot(sp)					; set slot number
-			move.l	d3,siROMAddr(sp)				; clear ROM address
-			movea.l	sp,a1							; a1 = ptr to temp sInfoRecord
-			move.l	a1,([sInfoPtr],d1.w*4)			; set new temp sInfoRecord ptr for slot
-
-;	Determine whether the slot is empty or occupied
-
-			moveq.l	#-1,d0
-			bfins	d1,d0{4,4}						; inset slot number to get $fsffffff
-			movea.l	d0,a3							; a3 = minor space nubus addr for slot
-			lea		@Empty,a2						; a2 = addr to go if bus error occurs
-			slotjsr	InstallBus						; replace bus excptn, 32 bit mode
-			move.b	(a3),d0							; NUBUS READ - read byte from minor space
-			slotjsr	RestoreBus						; restore mmu state and bus exception vector
-			move.l	a3,siROMAddr(sp)				; set ROM address
-			bra.s	@Verify							; slot is occupied - verify the decl rom
-
-;	If the slot is still empty and was previously empty, then we are done
-
-@Empty
-			slotjsr	RestoreBus						; get here if empty slot
-			move.w	#smEmptySlot,siInitStatusA(a1)	; set empty status
-			bra.s	@CheckError						; check if same as previous status
-
-;	Verify the format header  -  a0 = ptr to spblock, a1 = ptr to sInfoRecord
-
-@Verify
-			bsr.l	VerifySlot						; verify the config rom format
-			tst.w	siInitStatusA(a1)				; is the slot status ok?
-			bne.s	@CheckError						; bad or empty slot - check previous status
-
-;	Config ROM verifies ok - walk through all the sResources looking for the board sResource
-
-			bsr		GetBoardID						; find the board sRsrc and board id
-			beq.s	@Changed						; no board id - a bad card
-
-;	Compare with pram board id.  If sRsrc board id is different, then there is
-;	a different card in the slot.
-
-			move.w	d0,d2							; d2 = board id for new card
-			lea		-8(sp),sp						; alloc pram buffer
-			move.l	sp,spResult(a0)					; pass ptr to pram buffer
-			slotjsr	sReadPRAMRec					; read the current slot pram
-			bne.s	@Changed						; something wrong - change the card
-
-			cmp.w	(sp),d2							; are board id's the same?
-			lea		8(sp),sp						; de-alloc buffer
-			beq.s	@Done							; same board id's - return no change
-			bra.s	@Changed
-
-;	Some error - if same as previously, then mark as unchanged
-
-@CheckError
-			move.w	siInitStatusA(a4),d0				; get previous status
-			cmp.w	siInitStatusA(a1),d0				; same error?
-			beq.s	@Done								; same board id's - no change
-
-;	The card has changed
-
-@Changed
-			moveq.l	#-1,d3							; return error to indicate card changed
-
-;	Done
-
-@Done
-			lea		sInfoNewSize(sp),sp				; free temp sInfoRecord
-			move.l	a4,([sInfoPtr],d1.w*4)			; restore original sInfoRecord
-
-@Return
-			move.l	d3,d0							; return change status
-			movem.l	(sp)+,@regs
-			rts
-
-
-;_______________________________________________________________________________________	<h7> djw
-;	GetBoardID	-	Find and return board id
-;
-;	Find the board sResource and return the board id for the given slot.  This
-;	routine walks through the sResource data structures on the card, not using
-;	the SRT.
-;
-;	Input	:	a0 = ptr to spBlock
-;				a1 = ptr to sInfoRecord
-;	Output	:	d0 = board id or zero		ccr reflects status
-;
-;	spBlock	:	-> spSlot			slot number (slot 0 is not valid)
-;
-
-GetBoardID
-@regs		reg		d1-d4/a1-a2
-			movem.l	@regs,-(sp)
-			moveq.l	#0,d4							; d4 = board id value to return
-
-;	Calculate the step value for this slot so we can step through the sRsrc dir
-
-			move.l	siDirPtr(a1),spsPointer(a0)			; set ptr field to get step value for
-			move.b	siCPUByteLanes(a1),spByteLanes(a0)	; set byte lanes field
-			bset.b	#fConsecBytes,spFlags(a0)			; set flag for step value for bytes
-			_sCalcStep
-			bne		@Done
-
-;	For every entry in the sResource directory, read the sResource type to find the
-;	board sResource.  Also check for ascending order for the sResources in case there
-;	is no $ff at the end.
-
-			move.l	spResult(a0),spParamData(a0)	; set step value for reading bytes
-			move.l	siDirPtr(a1),d2					; set d2 = ptr to current dir entry
-			moveq.l	#0,d1							; zero last id read
-
-@Loop		move.l	d2,spsPointer(a0)				; set spsPointer to addr of id to read in dir
-			slotjsr	Read4Bytes						; read <id><offset> - inc spsPointer to next long
-			bne.s	@Done							; an error - stop searching
-			move.l	spsPointer(a0),d2				; get d2 = ptr to next id to read
-
-;	Check for acsending order in sResource directory id's
-
-			move.b	spResult(a0),d3					; get high byte to get <id> field
-			cmp.b	#$ff,d3							; end of list ?
-			beq.s	@Done							; done - board sResource is not found
-			cmp.b	d1,d3							; is new id greater than last id ?
-			bls.s	@Done							; id's out of order - not found
-			move.b	d3,d1							; set reg d1 = last id read
-
-;	Get a pointer to the sResource id found
-
-			move.l	siDirPtr(a1),spsPointer(a0)		; point to directory
-			move.b	d1,spId(a0)						; find the sRsrc id just read from the dir
-			_sFindStruct
-			bne.s	@Done							; some error
-
-;	With the spsPointer field now pointing to the sRsrc, read the type field
-
-			movea.l	spsPointer(a0),a2				; save ptr to sRsrc
-
-			move.b	#sRsrcType,spId(a0)				; get ptr to type field
-			_sFindStruct
-			bne.s	@Done							; error - no sRsrc type field found
-			lea		-8(sp),sp						; alloc sRsrc_type buffer
-			move.l	sp,spResult(a0)					; set buffer ptr
-			move.l	#8,spSize(a0)					; set size to read
-			_sReadStruct
-			bne.s	@Done							; @@@@Remember to dealloc stack@@@@can't read it - error
-
-			move.l	(sp)+,d0						; get category and type fields
-			move.l	(sp)+,d3						; get drvrSW and drvrHW fields
-			cmp.l	#(catBoard<<16)+typBoard,d0		; board type?
-			bne.s	@Loop							; not found - continue search
-			tst.l	d3								; drvrSW and drvrHW fields should be zero
-			bne.s	@Loop							; not found - continue search
-
-;	At this point, we have found the board sResource.  Read the board id
-
-			move.l	a2,spsPointer(a0)				; restore ptr to sRsrc
-			move.b	#Boardid,spId(a0)				; read board id field from board sRsrc
-			_sReadWord
-			bne.s	@Done							; some error - no board id
-			move.w	spResult+2(a0),d4				; d4 = board id for new card
-
-;	Done
-
-@Done
-			move.w	d4,d0							; return board id or zero
-			movem.l	(sp)+,@regs
-			rts
-
-			endwith
-
-;____________________________________________________________________________								<H8>
-;
-; FindDevBaseSlot0 (called from FindDevBase).
-;
-;	Entry:		a0 points to spBlock.
-;	 			d1 is the major/minorbase offset.
-;
-;	Exit:		a0 points to spBlock.
-;				d2 is the DevBase.
-;
-;	Trashes:	A1/D0-D1.
-;____________________________________________________________________________
-
-			Export	FindDevBaseSlot0
-
-			With	SpBlock
-
-FindDevBaseSlot0
-			
-			movea.l	UnivInfoPtr,a1					; point to the ProductInfo record
-			adda.l	ProductInfo.VideoInfoPtr(a1),a1	; point to the VideoInfo record
-			
-			move.b	#sRsrcFlags,spId(a0)			; get flags to determine whether the pointer
-			_sReadWord								; - should be 24 or 32 bit
-			bne.s	@Do24							; no flag field - default to 24 bit space
-			
-			move.w	spResult+2(a0),d0				; get value of spFlags
-			btst.l	#f32BitMode,D0					; see if 32- or 24-bit base address
-			beq.s	@Do24							; branch if 24-bit base address	
-				
-			Add.l	VideoInfo.VRAMLogAddr32(a1),d1	; 32bit dev base to alias addr for slot zero
-			Bra.s	@Done
-
-@Do24		Add.l	VideoInfo.VRAMLogAddr24(a1),d1	; 24bit dev base to alias addr for slot zero
-@Done		Move.l	d1,d2							; d2 has what we want
-			Rts		
-			
-			EndWith
-
 			Endp									; must have endp for RAM builds			<djw>
 
 			End
diff --git a/OS/SlotMgr/SlotMgrInit.a b/OS/SlotMgr/SlotMgrInit.a
--- a/OS/SlotMgr/SlotMgrInit.a
+++ b/OS/SlotMgr/SlotMgrInit.a
@@ -13,73 +13,8 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM15>	 9/12/93	pdw		Removed a push,SwapMMU,pop sequence.
-;	  <SM14>	  9/1/93	SKH		Fixed a bug where only LastSDMSelts were being allocated in the dispatch
-;									table.
-;	  <SM13>	  8/4/93	GMR		RC: Added code to enable slave block transfers for BART machines
-;									(PDM,CF).
-;	  <SM12>	 6/14/93	kc		Roll in Ludwig.
-;	   <LW2>	 3/24/93	mal		Added EnableBlockXfer after PrimaryInit for each slot.
-;									EnableBlockXfer sets bits in a MUNI register if slot has block
-;									xfer sRsrcs indicating it supports block xfers.
-;	  <SM11>	11/17/92	kc		Add "IF NOT LC930 THEN" around patchPrimaryInit to facilitate
-;									dead code stripping for the LC930 build.
-;	   <SM10>	10/14/92	CSS		Change some branch short instructions to branches.
-;	   <SM9>	09-24-92	jmp		Added a pRAM-based mechanism for skipping BootBug altogether if
-;									it is installed.
-;	   <SM8>	08-27-92	jmp		Added support for Brigent, Inc.’s BootBug  card.
-;	   <SM7>	 6/30/92	kc		Roll in Horror, comments follow:
-;	                              	• From SlotMgr.a
-;	    <H5>				djw		Add new selector for DoSecondaryInit.
-;									• From SlotMgrPatch.a
-;	   <H11>				djw		Added DoSecondaryInit routine.
-;	   <SM6>	 5/16/92	kc		Roll in Horror changes. Comments follow:
-;                                   Note: This is going to take some work for the system build but
-;									it is likely to change so we might want to hold off awhile.
-;									• From SlotMgr.a
-;		<H3>	 3/18/92	djw		Add new calls to support docking code - AddCard, RemoveCard,
-;									CheckSlot, and GetSRTEntry.
-;		<H2>	  3/5/92	djw		Replaced InitSlotMgr, InitsRsrcTable, InitPRAMRecs, and
-;									Primary_Init entries in the table with new routines.
-;									• From SlotMgrPatch.a
-;		<H5>	02/05/92	jmp		Unfortunately, I put some tables in the middle of this file
-;									that, in Cyclone, will get bigger.  So, I moved them from the
-;									middle of the file into the pad space.  Also, I generalized the
-;									routine that decides whether a DeclROM’s PrimaryInit/Driver
-;									should be patched by not stopping once I found the version I was
-;									looking for (e.g., in case we need to patch out versions 1, 2,
-;									and 3 of the 8•24 card).
-;		<H2>	10/22/91	SAM/jmp	Discontinued patching out the JMFB PrimaryInit & Driver on the
-;									Bungee (1.1) version of the 4•8/8•24 Card ROM.  From Zydeco-TERROR ROM.
-;		<T6>	 2/25/91	jmp		Added code to check version number of the driver before doing
-;									PrimaryInit and GetDriver patches.
-;		<T3>	11/19/90	jmp		Added in patches for PrimaryInit and GetDriver.
-;									• From SlotInfo.a
-;		<H5>	 3/18/92	djw		Add stub entry points for new docking support routines -
-;									StubAddCard and StubRemoveCard
-;		<H4>	  3/6/92	SWC		We thank Dave for <H3> (getting it working in under 25 tries…),
-;									and move the Docking Manager initialization to StartSDeclMgr
-;									just before running the primary inits so that we can decided
-;									whether or not to install the built-in LCD driver when DBLite
-;									(etc.) is inside a docking station and thus the LCD screen is
-;									not useable.
-;		<H3>	  3/5/92	djw		Rewrote slot manager initialization code (major routines from
-;									beginning of file to SecondaryInit) to facilitate new code for
-;									DBLite docking station.  The major change was to modify the
-;									routines to execute their functions for a single slot instead of
-;									for every slot.
-;		<H2>	10/29/91	jmp		Added a patch to the VerifySlot routine for supporting super
-;									sRsrc directories in Slot $0.
-;	   <SM5>	  5/5/92	JSM		Roll-in changes from Reality:
-;									<17>	  5/4/92	JSM		The checks for isUniversal in this file should just be forROM.
-;																(Dean really didn’t have to do all that work in <14>).
-;	   <SM4>	 2/21/92	RB		delete rude code which snuck in late at night while no one was
-;									looking…
-;	   <SM3>	 2/12/92	RM		Change BRA.S to BRA.L.
-;	   <SM2>	 2/11/92	RB		Fixed InitPRamRecs. It was not working right on the Quadras due
-;									to a confusing situation caused when using forROM, and NOT
-;									forROM in diferent places of the same routine. I hate
-;									them...conditionals.
+;		<17>	  5/4/92	JSM		The checks for isUniversal in this file should just be forROM.
+;									(Dean really didn’t have to do all that work in <14>).
 ;		<15>	  1/7/92	RB		Rolled in Terror changes.
 ;		<14>	 8/30/91	DTY		Define isUniversal here since it’s no longer defined in
 ;									BBSStartup.
@@ -129,7 +64,6 @@
 			Include	'RomEqu.a'
 			Include	'UniversalEqu.a'
 			Include	'SlotMgrEqu.a'
-			Include	'ComVideoEqu.a'								; <15> rb
 			Print	On
 
 		
@@ -184,18 +118,12 @@
 			IMPORT	pRestoreBus
 			IMPORT	pAllocSRTBlk
 
-			IMPORT	GetSRTEntry							;								<h3> djw
-
 			IMPORT	SlotEmpty				;		<djw>
 			IMPORT	pGetBoard				;		<3>
 
 			IMPORT	SlotManager					;											<3>
 			IMPORT	p040BusException			;											<4>
 
-			EXPORT	InitsInfo,InitPrimary,InitsPram,InitsRsrc,InitsInfo
-			EXPORT	Secondary_Init,StubCheckSlot,StubAddCard,StubRemoveCard,SDMJmpTable
-			EXPORT	DoSecondaryInit
-
   			If (&TYPE('SeparateFile') = 'UNDEFINED') Then	; equ indicating whether we are		<3>
 SeparateFile   	Equ 		0								; ... building for 32bit QD INIT
   			Endif											; ... or as a system patch
@@ -297,7 +225,7 @@ SDMJmpTable	Proc
 			DispatchVector	GetTypesRsrc		;$0C			<1.2>
 			DispatchVector	SlotEmpty			;$0D
 			DispatchVector	SlotEmpty			;$0E
-			DispatchVector	DoSecondaryInit		;$0F			<H5>
+			DispatchVector	SlotEmpty			;$0F
 
 				
 ;    Specialized
@@ -315,21 +243,21 @@ SDMJmpTable	Proc
 			DispatchVector	FindDevBase			;$1B
 			DispatchVector	FindDevBase			;$1C map findbigdevbase to finddevbase		<1.6> 
 			DispatchVector	GetsRsrcPtr			;$1D			<1.3>
-			DispatchVector	StubAddCard			;$1E			<h3> djw
-			DispatchVector	StubRemoveCard		;$1F			<h3> djw
+			DispatchVector	SlotEmpty			;$1E
+			DispatchVector	SlotEmpty			;$1F
 
 
 ;    Advanced  (SDM private routines).
-			DispatchVector	InitsInfo			;$20			<h2> djw
-			DispatchVector	InitPrimary			;$21			<h2> djw
+			DispatchVector	SlotEmpty			;$20
+			DispatchVector	SlotEmpty			;$21
 			DispatchVector	CardChanged			;$22
 			DispatchVector	SlotExec			;$23			
 			DispatchVector	OffsetData			;$24
-			DispatchVector	InitsPram			;$25			<h2> djw
+			DispatchVector	SlotEmpty			;$25
 			DispatchVector	ReadPBSize			;$26
-			DispatchVector	StubCheckSlot		;$27			<h3> djw
+			DispatchVector	SlotEmpty			;$27
 			DispatchVector	CalcStep			;$28
-			DispatchVector	InitsRsrc			;$29			<h2> djw
+			DispatchVector	SlotEmpty			;$29
 			DispatchVector	SearchSRT			;$2A
 			DispatchVector	UpdateSRT			;$2B
 			DispatchVector	CalcsPointer		;$2C
@@ -352,32 +280,8 @@ SDMJmpTable	Proc
 			DispatchVector	pInstallBus			;$3A
 			DispatchVector	pRestoreBus			;$3B
 			DispatchVector	pAllocSRTBlk		;$3C
-			DispatchVector	GetSRTEntry			;$3D			<h3> djw
 
-;=======================================================================================
-;	Re-wrote the following old routines:
-;		StartSDeclMgr
-;		InitSlotMgr
-;		InitsRsrcTable
-;		InitPRAMRecs
-;		Primary_Init
-;
-;	...into these new routines:
-;		StartSDeclMgr
-;		AllocSlot
-;		InitsInfo
-;		InitsRsrc
-;		InitsPram
-;		InitPrimary
-;
-;	The major rewrite of the slot manager initialization code was to go from each routine
-;	executing a single function for all slot, to routines which would only execute the
-;	function for a given slot.  This change was to facilitate slot manager changes for
-;	DBLite to accomodate their docking module.  The end resulting data structures are
-;	not changed from the previous slot manager version.
-;=======================================================================================
-
-;_______________________________________________________________________________________	<h3> djw
+;_______________________________________________________________________________________
 ;	StartSDeclMgr  -  start the slot manager
 ;
 ;	Initialize the slot manager.  Create the sInfo and the slot resource table.  Load
@@ -388,20 +292,12 @@ SDMJmpTable	Proc
 ;	Output	: d0 = status
 ;
 
-			Proc
-			Export	StartSDeclMgr
-			Import	InitJmpTbl, InitDocking
+InitSlotMgr	Proc	Export
 			with	spBlock,sInfoRecord,FHeaderRec,slotGlobals,seBlock
 
-StartSDeclMgr
-			sub.w	#spBlockSize,sp				; allocate spBlock
-			movea.l	sp,a0						; setup a0 = ptr to spBlock
+			movem.l	d1/a1/a2,-(sp)
 				
-			jsr		InitJmpTbl					; create the slot manager's dispatch table
-			bne		@Done				
-				
-			bsr		AllocSlot					; allocate all the slot manager data structures
-			bne		@Done
+			bsr		Subroutine
 
 ;	For all the slots, determine its status, verify its format record, log its
 ;	sResources, initialize the PRAM for the slot.
@@ -409,110 +305,62 @@ StartSDeclMgr
 			moveq.l	#sLastSlot,d1				; d1 = slot loop counter from last slot
 @Loop
 			move.b	d1,spSlot(a0)				; set slot number
-			bsr		InitsInfo					; initialize the sInfo table
-			bsr		InitsRsrc					; initialize the slot resource table (SRT)
-			bsr		InitsPram					; initial a slot's PRAM
-			dbra	d1,@Loop
+			_sFindsInfoRecPtr					; get ptr to sInfoRecord
+			movea.l	spResult(a0),a1				; a1 = ptr to sInfoRecord
+			tst.w	siInitStatusA(a1)			; is the slot status ok?
+			bmi.s	@SlotDone					; bad slot - done
 
-;	Initialize the Docking Manager so built-in video and docking cards can use its facilities
+			bsr		VerifySlot					; verify the config rom format
 
-			BSR.L	InitDocking					; initialize the Docking Manager			<H4>
+@SlotDone	dbra	d1,@Loop
 
-;	Set up the warm/cold start flag for later.												<SM8>
+			movem.l	(sp)+,d1/a1/a2
+			rts
 
-			Moveq.l	#0,D2						; D2 = flag for cold start.
-			Cmpi.l	#WmStConst,WarmStart		; Check low mem for warm start value.
-			Bne.s	@Continue					; Cold start.
-			Bset.l	#fWarmStart,D2				; Warm start.
-
-@Continue
-
-;	Determine if there’s a BootBug card installed or not.  If one is installed,
-;	execute it first.  Otherwise, just run the normal sequence.
-
-			Clr.b	-(Sp)						; Initialize our “savedSlot” space.
-			
-			Clr.b	spSlot(A0)					; Start with Slot $0.
-			Clr.b	spID(A0)					; Begin search with ID 0.
-			Clr.b	spExtDev(A0)				; No external device(s).
-			Clr.b	spTBMask(A0)				; No mask in search.
-			Move.w	#CatProto,spCategory(A0)	; Look for:  Proto,
-			Move.w	#TypDebugger,spCType(A0)	;			 Debugger,
-			Move.w	#DrSwMacsBug,spDrvrSW(A0)	;			 MacsBug,
-			Move.w	#DrHwBootBug,spDrvrHW(A0)	;			 BootBug.
-			Clr.l	spParamData(A0)				; Clear the flags field.
-			Ori.b	#(1<<fNext),spParamData+3(A0) ; Search for the 1st one.
-			_GetTypeSRsrc						; If we don’t find a BootBug card
-			Bne.s	@DoZeroFirst				;	then just run the normal sequence.
-			Move.b	spSlot(A0),(Sp)				; Remember which slot has BootBug in it.
-			
-			Move.l	A0,-(Sp)					; Save SpBlockPtr.										<H15>
-			Subq	#4,Sp						; Make a pRAM buffer on the stack.
-			Move.l	Sp,A0						; Point to it.
-			Move.l	#$000400FC,D0				; Set up to read 4 bytes starting at $FC.
-			_ReadXPRAM							; Read ’em.
-			Move.l	(Sp)+,D0					; Get the result, release buffer.
-			Move.l	(Sp)+,A0					; Restore SpBlockPtr.
-			Cmpi.l	#'Skip',D0					; If the BootBug skip signature is set,
-			Beq.s	@DoZeroFirst				;	then skip it.
-			
-;	Now, go execute all the PrimaryInits as usual, except run the BootBug PrimaryInit
-;	first.
-
-			Move.b	D2,spFlags(A0)				; Set flag for warm or cold start.
-			Bsr		InitPrimary					; Execute the PrimaryInit.
-
-@DoZeroFirst
-			Clr.b	spSlot(A0)					; Set slot 0.
-			Move.b	D2,spFlags(A0)				; Set flag for warm or cold start.
-			Bsr		InitPrimary					; Execute the PrimaryInit.
-
-			Moveq.l	#sLastSlot,D1				; D1 = slot loop counter from last slot.
-@Loop1
-			Move.b	D1,spSlot(A0)				; Set the Slot number.
-			Cmp.b	(Sp),D1						; If this is the BootBug slot,
-			Beq.s	@Skip						;	then skip it this time.
-			
-			Move.b	D2,spFlags(A0)				; Set flag for warm or cold start.
-			Bsr		InitPrimary					; Execute the PrimaryInit.
-
-			Bsr		EnableBlockXfer				; Enable block xfer, if this slot is capable	<LW2>
-			
-@Skip		Subq.b	#1,D1
-			Bne.s	@Loop1						; Continue for all slots.
-
-			Tst.b	(Sp)+						; Free up “savedSlot” space.
-@Done
-			Add.w	#spBlockSize,Sp				; Free SpBlock.
-			Moveq.l	#noErr,D0					; Return noErr.
-			Rts									;											<SM8>
-
-
-;_______________________________________________________________________________________	<h3> djw
-;	AllocSlot  -  allocate slot manager data structures
-;
-;	Allocate the slot manager globals, the sInfo table, the sInfoRecords for disabled
-;	and reserved slots, and the first block of sRsrcRecords for the SRT.
-;
-;	Input	: a0 = ptr to spBlock
-;	Output	: d0 = status	ccr reflects status
-;
-
-AllocSlot
-@regs		reg		a0-a1
+Subroutine
+@regs		reg		d1-d2/a0-a3
 			movem.l	@regs,-(sp)						; save registers
 
+;	Enumerate all the slots
+;		d0 = number of slots found
+;		sp points to array of index/-1 words
+
+			move.l	sp,SInfoPtr					; create a fake SlotMgr global block for InstallBus
+			sub.w	#slotGlobalSize,sp
+
+			move.l	#minorLast,a1				; explore the standard slot space ($Fn......)
+			move.l	#TotalSlots-1,d1
+			move.l	#0,d0
+
+			lea		@BusError,a2				; switch to 32-bit mode, and jump to a2 on bus error
+			slotjsr	InstallBus
+
+@NextSlot
+			sub.l	#2,sp
+			move.b	(a1),d2
+			add.w	#1,d0
+			move.w	d0,(sp)
+			bra.s	@NoBusError
+@BusError
+			move.w	#-1,(sp)
+@NoBusError
+			sub.l	#minorStep,a1
+			sub.w	#1,d1
+			bne.s	@NextSlot
+
+			slotjsr	RestoreBus					; undo InstallBus
+
 ;	Allocate the necessary memory as one contiguous block
 
-			move.l	#(slotGlobalSize			\	; size of globals
-					+(4*TotalSlots)				\	; size of sInfor vector table
-					+(3*sInfoNewSize)			\	; size of 3 sInfoRecords (disabled,reserved,empty)
-					),d0							; d0 = number of bytes to alloc
+			mulu.w	#sInfoNewSize,d0				; size of N sInfoRecords
+			add.l	#(slotGlobalSize			\	; size of globals
+					+(4*TotalSlots)+48			\	; size of sInfor vector table ?????
+					),d0
 			_NewPtr	,sys,clear						; alloc block
-			bne.s	@Done							; some error - done
 
 			adda.w	#slotGlobalSize,a0				; globals are at a negative offset from sInfo tbl
 			move.l	a0,sInfoPtr						; set ptr to sInfo table
+			move.l	a0,a1
 
 ;	There are three special sInfoRecords which we are setting up.  These records are shared by
 ;	all slots which have a disabled, reserved, or empty status.  The records are shared because
@@ -521,117 +369,37 @@ AllocSlot
 ;	followed by the empty.
 
 			lea		4*TotalSlots(a0),a0				; inc a0 past sInfoTable to disable sInfoRecord
-			move.w	#smDisabledSlot,			\
+			move.w	#smEmptySlot,				\
 					siInitStatusA(a0)				; set slot status to disabled
 			lea		sInfoNewSize(a0),a0				; inc a0 to reserved sInfoRecord
-			move.w	#smReservedSlot,			\
-					siInitStatusA(a0)				; set slot status to reserved
-			lea		sInfoNewSize(a0),a0				; inc a0 to empty sInfoRecord
-			move.w	#smEmptySlot,				\
-					siInitStatusA(a0)				; set slot status to reserved
 
-;	Allocate the first SRT block.
+			move.l	#$40000,d0
+			sub.l	#1,d0
+			add.l	RomBase,d0
+			move.l	d0,siROMAddr(a0)
+			move.w	#1,siTOConst(a0)
 
-			slotjsr	AllocSRTBlk					; return a1 = ptr to blk
-			move.l	a1,sRsrcTblPtr				; save ptr in low mem
-			move.l	a1,([sInfoPtr],lastSRTPtr)	; set ptr to last entry in SRT
+			move.l	a0,(a1) ; ?????
 
-@Done
-			tst.w	d0							; return err in ccr
-			movem.l	(sp)+,@regs
-			rts
-
-
-;_______________________________________________________________________________________	<h3> djw
-;	InitsInfo  -  init a slot's sinfoRecord
-;
-;	Check the NuBus info in the universal tables to see if the given slot is enabled.
-;	If so, then scan the slot to determine whether it is occupied or empty.  If occupied,
-;	then verify the declaration ROM.
-;
-;	Input	:	a0 = ptr to spBlock
-;	Output	:	none
-;
-;	spBlock	:	-> spSlot			slot number
-			Export InitsInfo
-InitsInfo
-@regs		reg		d1/a0-a3
-			movem.l	@regs,-(sp)
-
-			moveq.l	#0,d1
-			move.b	spSlot(a0),d1						; d1 = slot number in question
-			movea.l	sInfoPtr,a1							; a1 = ptr to beginning of sInfoTable
-			
-;	Check if the slot is enabled in the universal tables.  The two currently defined
-;	states are enabled (no bit set), disabled (do no scan), and reserved (hack for VM
-;	to disable VM from looking into slot's address space.  Previously, VM ignored
-;	the disabled error).
-
-			movea.l	a1,a3
-			lea		4*TotalSlots(a3),a3					; a3 = ptr to disabled sInfoRecord
-			move.l	a3,(a1,d1.w*4)						; set slot pointing to disabled record
-
-			with NuBusInfo
-			movea.l	UnivInfoPtr,a2		
-			adda.l	ProductInfo.NuBusInfoPtr(a2),a2		; a2 = ptr to universal slot info tbl
-			btst.b	#slotDisabled,(a2,d1.w)				; test if slot is disabled
-			bne		@Done
-			lea		sInfoNewSize(a3),a3					; a3 = ptr to reserved record
-			move.l	a3,(a1,d1.w*4)						; set slot pointing to reserved record
-			btst.b	#slotReserved,(a2,d1.w)				; test if the slot is reserved
-			bne 	@Done								; <SM10> CSS
-			endwith
-
-;	The slot is enabled for use.  Initially, set the slot to point to the empty sInfoRecord.
-
-			lea		sInfoNewSize(a3),a3					; a3 = ptr to empty record
-			move.l	a3,(a1,d1.w*4)						; set slot pointing to empty record
-
-;	If this is slot zero, then special case the declaration ROM address
-
-			tst.b	d1									; slot 0 ?
-			bne.s	@doRead								; not slot 0
-			movea.l	RomBase,a3							; get base of rom
-			adda.l	ROMHeader.RomSize(a3),a3			; a3 = addr of end of ROM
-			suba.l	#1,a3								; adjust to last byte in ROM
-			bra.s	@Verify								; verify slot 0
-
-;	Do a nubus read to see if the slot is occupied.  If it is, then when we
-;	read, we will not get a bus error.
-
-@doRead
-			moveq.l	#-1,d0
-			bfins	d1,d0{4,4}						; inset slot number to get $fsffffff
-			movea.l	d0,a3							; a3 = minor space nubus addr for slot
-			lea		@Empty,a2						; a2 = addr to go if bus error occurs
-			slotjsr	InstallBus						; replace bus excptn, 32 bit mode
-			move.b	(a3),d0							; NUBUS READ - read byte from minor space
-			slotjsr	RestoreBus						; restore mmu state and bus exception vector
-			bra.s	@Verify							; slot is occupied - verify config rom
-@Empty
-			slotjsr	RestoreBus						; restore mmu state and bus exception vector
-			bra.s	@Done
-
-
-;	The slot is not empty.  Allocate an sInfoRecord for it and verify the card.
-;	a0 = ptr to spBlock, a1 = ptr to sInfoTable, a3 = ptr to top of config rom
-
-@Verify
+			move.w	#1,d0
+@Loop
 			movea.l	a0,a2							; save ptr to spBlock
-			move.l	#sInfoNewSize,d0				; size of sInfoRecord
-			_NewPtr	,sys,clear
-			bne.s	@Done							; err - leave pointing to empty record
-			move.l	a0,(a1,d1.w*4)					; set ptr in sInfo vector table
-			movea.l	a0,a1							; a1 = ptr to sInfoRecord for this slot
-			movea.l	a2,a0							; restore a0 = ptr to spBlock
+			move.w	(sp)+,d1						; pop word from
+			muls.w	#sInfoNewSize,d1				; size of sInfoRecord
+			add.l	d1,a2
+			move.l	a2,(a1,d0.w*4)					; set ptr in sInfo vector table
 
-			move.w	#retryCnt,siTOConst(a1)			; set default bus error retry cnt (not used)
-			move.b	d1,siSlot(a1)					; set slot number
-			move.l	a3,siROMAddr(a1)				; set ROM address
+			move.w	#retryCnt,siTOConst(a2)			; set default bus error retry cnt (not used)
+			move.b	d0,siSlot(a2)					; set slot number
 
-			bsr.s	VerifySlot						; verify the config rom format
+			not.l	siROMAddr(a2)					; set ROM address ???
+			bfins	d0,siROMAddr(a2){4,4}			; inset slot number to get $fsffffff
 
-@Done
+			add.w	#1,d0
+			cmp.w	#sLastSlot,d0
+			ble.s	@Loop
+
+			add.w	#slotGlobalSize,sp				; pop fake globals
 			movem.l	(sp)+,@regs
 			rts
 
@@ -667,8 +435,8 @@ VerifySlot
 			MOVE.L	A2,spResult(A0)			; pass A2 = addr to put format header
 			moveq	#3,d1					; start with byte lane 3						<2.0>
 
-@Loop		BSR		GetByteLane				; get a valid byte lane - return byte lane value in D1
-			BNE		VerifySlotDone			; error - no valid byte lane
+@Loop		BSR.S	GetByteLane				; get a valid byte lane - return byte lane value in D1
+			BNE.S	VerifySlotDone			; error - no valid byte lane
 			_sReadFHeader					; read the format header from the declaration ROM
 			BNE.S	@EndLoop				; some error - try another byte lane			<1.7>
 			
@@ -689,75 +457,10 @@ VerifySlot
 @EndLoop	sub.l	#1,siROMAddr(a1)		; decrement ROM ptr to next byte lane			<1.7>
 			DBRA	D1,@Loop
 			move.w	#smBLFieldBad,d0		; error - could not find a valid byte lane
-			BRA		VerifySlotDone
+
+			BRA.S	VerifySlotDone
 								
-;	Get the pointer to the sResource directory from the declaration ROM and store
-;	it in the sInfo record for future use.  The directory is at an offset from the
-;	directory offset field in the format header.
-			EndWith ; FHeaderRec
-			With XFHeaderRec
-@GoodRom	
-VerifySlotPatch
-
-			Tst.b	spSlot(A0)								; If we’re not looking at slot 0, then 
-			Bne		@StdHeader								; 	just assume a standard header.
-			
-			Move.l	siROMAddr(A1),spsPointer(A0)			; Set ptr to top of ROM.
-			Move.l	#-(fhXBlockSize)+1,spOffsetData(A0)		; Set offset to beginning of extended header.
-			Move.b	siCPUByteLanes(A1),spByteLanes(A0)		; Set byte lanes field.
-			_sCalcsPointer									; Get pointer to extended header.
-			Bne		@StdHeader								; If failed, just try standard header.
-
-@SaveRegs	Reg		A3-A4									; Define some work register.	
-			Movem.l	@SaveRegs,-(Sp)							; Save them.
-			Suba.l	#XFHdrExtraSize,Sp						; Allocate space for extended part of FHeaderRec.
-			Move.l	Sp,A3									; Point to it.
-			Suba.l	#seBlockSize,Sp							; Allocate space for sExec block.
-			Move.l	Sp,A4									; Point to it.
-			
-			Move.l	A3,spResult(A0)							; Point to buffer for extra part of format block.
-			Move.l	#XFHdrExtraSize,spSize(A0)				; Number of bytes to copy.
-			_sReadStruct									; Read extended part of header.
-			Bne.s	@FallBack								; If failed, just try the standard header.
-			
-			Cmpi.l	#TestPattern,fhXSTstPat(A3)				; If the (extended) test pattern doesn’t exist,
-			Bne.s	@FallBack								;	just try the standard header.
-			
-			Move.b	fhFormat(A2),D0							; Get the format ID of the header.
-			Cmp.b	fhXSuperInit(A3),D0						; If not using an appropriately ID’d SuperInit,
-			Bne.s	@FallBack								;	just try the standard header.
-			
-			Move.b	spSlot(A0),seSlot(A4)					; Copy the slot number.
-			Move.b	fhXSuperInit(A3),sesRsrcId(A4)			; Copy the sRsrc/format ID of the SuperInit.
-			Move.b	fhXSuperInit(A3),spID(A0)				; Make sure sExec calls the right SuperInit.
-			Move.l	A4,spsExecPBlk(A0)						; Point to the sExec param block.
-			_SExec											; Call SuperInit.
-			Bne.s	@FallBack								; If failed, just try the standard header.
-			
-			Tst.b	seStatus(A4)							; If upper byte of seStatus is non-zero (a failure),
-			Bne.s	@FallBack								;	just try the standard header.
-			
-			Move.l	siROMAddr(A1),spsPointer(A0)			; Point back to the top of ROM.
-			Move.l	fhXSDirOffset(A3),spOffsetData(A0)		; Load super directory offset.
-			Clr.b	spOffsetData(A0)						; Strip psuedo-spID byte.
-			Add.l	#XOffsetToDir,spOffsetData(A0)			; Negative offset.
-			Move.b	siCPUByteLanes(A1),spByteLanes(A0)		; Set byte-lanes field.
-			_sCalcsPointer									; Get ptr to start of super sRsrc directory.
-			Bne.s	@FallBack								; If failed, just try standard header.
-
-			Move.b	seStatus+1(A4),spID(A0)					; Get the id of the super sRsrc directory.
-			_sFindStruct									; Look for it.
-			Bne.s	@FallBack								; If failed, try standard header.
-			
-			Move.l	spsPointer(A0),siDirPtr(A1)				; Set ptr to sRsrc dir in sInfo record.
-			Adda.l	#XFHdrExtraSize+seBlockSize,Sp			; Restore stack.
-			Movem.l	(Sp)+,@SaveRegs							; Restore work registers.
-			Bra.s	VerifySlotDone
-			
-@FallBack	Adda.l	#XFHdrExtraSize+seBlockSize,Sp			; Restore stack.
-			Movem.l	(Sp)+,@SaveRegs							; Restore work registers.
-
-@StdHeader	MOVE.L	siROMAddr(A1),spsPointer(A0)			; set ptr to slot declaration ROM
+@GoodRom	MOVE.L	siROMAddr(A1),spsPointer(A0)			; set ptr to slot declaration ROM
 			MOVE.L	fhDirOffset(A2),spOffsetData(A0)		; get dir offset from format blk image
 			add.l	#OffsetToDir,spOffsetData(a0)			; negative offset to directory field <2.0>
 			_sCalcsPointer									; calc ptr to directory
@@ -957,8 +660,8 @@ VerifyCRC
 			RTS										; end - VerifyCRC
 
 
-;_______________________________________________________________________________________	<h3> djw
-;	InitsRsrc  -  initialize the slot resource table
+;_______________________________________________________________________________________
+;	InitsRsrcTable  -  initialize the slot resource table
 ;
 ;	Loop through the given slot's sRsrc directory and add all the sRsrcs to the
 ;	SRT.  The SRT is actually made up of fixed sized blocks linked together.  A
@@ -971,75 +674,105 @@ VerifyCRC
 ;
 ;	spBlock	:	-> spSlot			slot number
 
-			Export	InitsRsrc
-			with	srrBlock,srtLink
+InitsRsrcTable	Proc	Export
+			with	spBlock,sInfoRecord,FHeaderRec,slotGlobals,seBlock,srrBlock,srtLink
 			
-InitsRsrc
-@regs		reg		d1-d3/a1-a2
+@regs		reg		a1-a2
 			movem.l	@regs,-(sp)
 
+			slotjsr	AllocSRTBlk
+
+			move.l	a1,SRsrcTblPtr
+
+			clr.b	spSlot(a0)					; clear fields used by _InsertSRTRec
+			clr.w	spIOReserved(a0)
+			clr.w	spRefNum(a0)
+			clr.b	spExtDev(a0)
+			clr.b	spHwDev(a0)
+
 ;	Check the slot's status
-
+@NextSlot
 			_sFindsInfoRecPtr					; get ptr to sInfoRecord
-			bne.s	@Done						; slot not valid - done
 			movea.l	spResult(a0),a2				; a2 = ptr to sInfoRecord
 			tst.w	siInitStatusA(a2)			; is the slot status ok?
-			bmi.s	@Done						; bad slot - done
+			bmi.s	@BadSlot					; bad slot - done
+			bsr		@InitTheResourceTable
+@BadSlot
+			add.b	#1,spSlot(a0)
+			cmp.b	#sLastSlot,spSlot(a0)
+			ble.s	@NextSlot
 
+			movem.l	(sp)+,@regs
+			rts
+
+@InitTheResourceTable
+			movem.l	d3-d5/a3,-(sp)
 ;	Calculate the step value for this slot so we can step through the sRsrc dir
 
 			move.l	siDirPtr(a2),spsPointer(a0)			; set ptr field to get step value for
 			move.b	siCPUByteLanes(a2),spByteLanes(a0)	; set byte lanes field
 			bset.b	#fConsecBytes,spFlags(a0)			; set flag for step value for bytes
 			_sCalcStep
-			bne.s	@Done
+			bne		@Done
 			
 ;	Loop through the sResource directory.  Check that the sResource id's are in
 ;	acsending order.  The last entry must have id = $FF.
 ;	d1 = last id read, d2 = ptr to current dir entry, d3 = temp
 
 			move.l	spResult(a0),spParamData(a0)	; set step value for reading bytes
-			move.l	siDirPtr(a2),d2					; set d2 = ptr to current dir entry
-			moveq.l	#0,d1							; zero last id read
+			move.l	siDirPtr(a2),d4					; set d4 = ptr to current dir entry
+			moveq.l	#0,d3							; zero last id read
 
-@Loop		move.l	d2,spsPointer(a0)				; set spsPointer to addr of id to read in dir
+@Loop		move.l	d4,spsPointer(a0)				; set spsPointer to addr of id to read in dir
 			slotjsr	Read4Bytes						; read <id><offset> - inc spsPointer to next long
 			bne.s	@Done							; an error - stop adding SRT entries
-			move.l	spsPointer(a0),d3				; get d3 = ptr to next id to read
-			move.l	d2,spsPointer(a0)				; restore ptr to current dir entry
-			move.l	d3,d2							; setup d2 = ptr to next entry in sRsrc dir
+			move.l	spsPointer(a0),d5				; get d5 = ptr to next id to read
+			move.l	d4,spsPointer(a0)				; restore ptr to current dir entry
+			move.l	d5,d4							; setup d4 = ptr to next entry in sRsrc dir
 
 ;	Check for acsending order in sResource directory id's
 
-			move.b	spResult(a0),d3					; get high byte to get <id> field
-			cmp.b	#$ff,d3							; end of list ?
+			move.b	spResult(a0),d5					; get high byte to get <id> field
+			cmp.b	#$ff,d5							; end of list ?
 			beq.s	@Done							; done - a good return
-			cmp.b	d1,d3							; is new id greater than last id ?
+			cmp.b	d3,d5							; is new id greater than last id ?
 			bls.s	@Done							; id's out of order
-			move.b	d3,d1							; set reg d1 = last id read
+			move.b	d5,d3							; set reg d3 = last id read
 
 ;	Given the sRsrc id, insert a new entry into the SRT
 
 			move.b	d3,spId(a0)						; set sRsrc id to insert
-			clr.l	spsPointer(a0)					; clear fields used by _InsertSRTRec
-			clr.w	spIOReserved(a0)
-			clr.w	spRefNum(a0)
-			clr.b	spExtDev(a0)
-			clr.b	spHwDev(a0)
-			clr.l	spParamData(a0)					; make sure to insert sRsrc as enabled
-			_InsertSRTRec							; insert <slot><id> sRsrc into SRT
-			beq.s	@Loop							; continue inserting sRsrc's
 
+			move.l	spResult(a0),d5
+			and.l	#$FFFFFF,d5
+			move.l	d5,spOffsetData(a0)
+
+			_SCalcSPointer
+			bne.s	@Done
+
+			cmp.w	#-1,(a1)
+			bne.s	@no
+			move.l	a1,a3
+
+			slotjsr	AllocSRTBlk
+			move.l	a1,2(a3)
+
+@no
+			clr.l	$18(a0)
+			slotjsr	InitEntry
+			bne.s	@Done
+			add.w	#1,([sInfoPtr],srtCnt)
+			move.l	a1,([sInfoPtr],lastSRTPtr)
+			add.l	#$18,a1
+			bra		@Loop
 @Done
-			movem.l	(sp)+,@regs
+			movem.l	(sp)+,d3-d5/a3
 			rts
-			
-			endwith
 
 
 
-;_______________________________________________________________________________________	<h3> djw
-;	InitsPRAM  -  initialize slot PRAM
+;_______________________________________________________________________________________
+;	InitPramRecs  -  initialize slot PRAM
 ;
 ;	Each slot is assigned 8 bytes of PRAM: <board id><6 user bytes>.  On boot,
 ;	the <board id> is compared against the card in the slot.  If they are
@@ -1053,35 +786,21 @@ InitsRsrc
 ;
 ;	spBlock	:	-> spSlot			slot number
 
-			Export	InitsPRAM
-InitsPRAM
-@regs		reg		d1-d3/a1-a2
+InitPramRecs	Proc	Export
+			with	spBlock,sInfoRecord,FHeaderRec,slotGlobals,seBlock,srrBlock,srtLink
+
+@regs		reg		d1-d4/a1-a2
 			movem.l	@regs,-(sp)
 			suba.w	#SizesPRAMRec,sp				; alloc slot PRAM buffer
 			movea.l	sp,a1							; a1 = ptr to PRAM buffer
-			clr.l	(a1)							; zero pram buffer (8 bytes)
-			clr.l	4(a1)
+			moveq	#sLastSlot,d1
 
-;	Get the state of this slot.  If the slot is disabled or reserved, then DO NOT ZERO
-;	PRAM.  If the pram has already been initialized, then do not initialize again.
-
-			_sFindsInfoRecPtr						; get ptr to sInfoRecord
-			bne		@Done							; slot invalid - done
-			movea.l	spResult(a0),a2					; a2 = ptr to sInfoRecord
-
-			cmpi.b	#statePRAMInit,siState(a2)		; has PRAM already been initialized ?
-			bge		@Done							; already initialized - done
-			tst.w	siInitStatusA(a2)				; is the slot status ok?
-			beq.s	@readPRAM						; slot ok - read board id from pram
-			cmp.w	#smDisabledSlot,siInitStatusA(a2)	; is slot disabled?
-			beq.s	@Done							; don't touch disabled slot's pram
-			cmp.w	#smReservedSlot,siInitStatusA(a2)	; is slot reserved?
-			beq.s	@Done							; reserved is the same as disabled
-			bra.s	@writePRAM						; slot status is bad - zero pram
+@NextSlot
 
 ;	Read PRAM to get the current board id.
 
-@readPRAM
+			move.b	d1,spSlot(a0)
+			clr.w	(a1)							; zero board ID in pram buffer
 			move.l	a1,spResult(a0)					; pass ptr to read PRAM bytes into
 			_sReadPRAMRec							; return (a1).w = board id
 			move.w	(a1),d3							; d3 = board id from PRAM
@@ -1096,16 +815,22 @@ InitsPRAM
 ;	slot zero, loop through all the board sResource records found, trying to match the
 ;	pram board id.
 
-			moveq.l	#0,d1							; sRsrc id to start looking at (incase of slot 0)
+			moveq.l	#0,d4							; sRsrc id to start looking at (incase of slot 0)
 
 @Loop
-			move.b	d1,spId(a0)						; pass sRsrc id to routine to begin looking from
+			move.b	d4,spId(a0)						; pass sRsrc id to routine to begin looking from
 			slotjsr	GetBoard						; return board sRsrc and sInfo rec ptrs
 			bne.s	@writePRAM						; no board sRsrc - write zero PRAM
 
+			movea.l	spResult(a0),a2					; a2 = ptr to sInfoRecord
+			tst.w	siInitStatusA(a2)				; is the slot status ok?
+			bmi.s	@writePRAM						; slot status is bad - zero pram
+			cmpi.b	#statePRAMInit,siState(a2)		; has PRAM already been initialized ?
+			bge.s	@Done							; already initialized - done
+
 ;	Board sResource is found - read the board id
 
-			move.b	spId(a0),d1						; save spId incase we need to loop (for slot 0)
+			move.b	spId(a0),d4						; save spId incase we need to loop (for slot 0)
 			move.b	#Boardid,spId(A0)				; read board id field from board sRsrc
 			_sReadWord
 			beq.s	@doMatch						; compare with pram board id
@@ -1121,7 +846,7 @@ InitsPRAM
 
 ;	Board id's are different - if this is slot zero, then look for another board sResource
 
-			tst.b	spSlot(a0)						; slot zero ?
+			tst.b	d1								; slot zero ?
 			beq.s	@Loop							; yes - look for another board sResource
 
 ;	Look for a pram init record on the card's config ROM.  If found, use the values to
@@ -1144,13 +869,16 @@ InitsPRAM
 			_InitSlotPRAM							; initialize board id and user PRAM
 
 @Done
+			dbra	d1,@NextSlot
+			moveq	#0,d0
+
 			adda.w	#SizesPRAMRec,sp				; free pram data buffer
 			movem.l	(sp)+,@regs
 			rts
 
 
-;_______________________________________________________________________________________	<h3> djw
-;	InitPrimary		-	execute primaryInit
+;_______________________________________________________________________________________
+;	Primary_Init		-	execute primaryInit
 ;
 ;	Execute primary init code for a slot having a primaryInit record in it's board
 ;	sResource.  Primary inits are passed parameters in an seBlock.Primary inits are
@@ -1166,18 +894,33 @@ InitsPRAM
 ;				sesRsrcId	->	BoardId
 ;				seFlags		->	spFlags
 ;
-			Export	InitPrimary
+			Export	Primary_Init
 
-InitPrimary
-@regs		reg		d1-d3/a1-a3
+Primary_Init
+@regs		reg		d1/a1-a3
 			movem.l	@regs,-(sp)
 			suba.w	#seBlockSize,sp
 			movea.l	sp,a2							; a2 = ptr to sExec param blk
 			move.l	a2,spsExecPBlk(a0)				; set ptr in spblock to sExec blk
 			move.b	#BoardId,sesRsrcId(a2)			; indicates exec code is from board sResource
 
+			moveq	#0,d0							; MMU to 32-bit mode
+			_SwapMMUMode
+			move.b	d0,-(sp)
+
+			move.b	#0,spSlot(a0)
 			bsr.s	doPrimaryInit					; execute the primary init
 
+			moveq	#sLastSlot,d1
+@Loop
+			move.b	d1,spSlot(a0)
+			bsr.s	doPrimaryInit					; execute the primary init
+			subq	#1,d1
+			bnz.s	@Loop
+
+			move.b	(sp)+,d0						; restore MMU
+			_SwapMMUMode
+
 			adda.w	#seBlockSize,sp
 			movem.l	(sp)+,@regs
 			rts
@@ -1215,20 +958,10 @@ doPrimaryInit
 			_sFindStruct
 			bne.s	@Done							; no primary init record - done
 
-			IF NOT LC930 THEN
-
-;	Identify Apple Cards whose PrimaryInit code is faulty, and execute fixed
-;	versions from the CPU ROM.
-			Bsr.s	PatchPrimaryInit					; If PatchPrimaryInit returns a 
-			Tst.b	D0									;	result >= 0, don’t execute
-			Bpl.s	@cleanup							;	normal PrimaryInit.
-			
-			ENDIF
-			
 ;	Load the code and execute the primary init record.
 ;
 			Move.l	A3,spsPointer(A0)					; Restore ptr to board sRsrc.
- 			Move.b	spSlot(A0),seSlot(A2)				; Set slot in sExec blk.
+ 			Move.b	D1,seSlot(A2)						; Set slot in sExec blk.
 			Move.b	spFlags(A0),seFlags(A2)				; Xfer warmstart flag (if present).
  			_sExec										; Execute the code.
 
@@ -1241,172 +974,6 @@ doPrimaryInit
 
 @done		Rts
 
-;____________________________________________________________________________
-;
-; PatchPrimaryInit and support (called from doPrimaryInit).
-;
-;	Entry:		A0		-- points to spBlock.
-;				A1		-- points to sInfoRecord.
-;				A2		-- (after restore from BigJump) points to sExec param blk.
-;				A3		-- points to board sResource.
-;
-;				D1		-- contains spSlot (we use spBlock.spSlot here, though).
-;	
-;	Exit:		A0-A3	-- preserved.
-;				D1		-- preserved.
-;
-;	Purpose:	The purpose of SlotPrimaryInitPatch is to identify Apple
-;				Cards whose PrimaryInit code is faulty, and execute fixed
-;				versions from the CPU ROM.
-;
-;				SlotPrimaryInitPatch is executed from the (non-exported)
-;				routine doPrimayInit in SlotInfo.a.
-;____________________________________________________________________________
-			
-			IF NOT LC930 THEN
-
-			With	seBlock,spBlock
-			Import	GetDevIndex,JsrTbl
-
-PatchPrimaryInit
-
-@saveRegs	Reg		A0-A3/D1/D3							; Define some work and scratch registers,
-			Movem.l	@saveRegs,-(Sp)						; 	and save them on the stack.
-			
-			Move.l	A0,A3								; Save the spBlockPtr for later.
-			
-			Bsr		GetDevIndex							; Get the device/card index into D0.
-			Move.l	D0,D3								; If the device index is negative, then
-			Bmi.s	@done								;	PrimaryInit doesn’t need patching.
-			
-			Lea		JsrTbl,A1							; Point to base of JsrTbl.
-			Lsl.l	#2,D3								; Adjust index.
-			
-			Move.l	A1,A0								; Copy base address.
-			Add.l	D3,A0								; Point to proper entry.
-			Add.l	(A0),A1								; Load A1 with effective address of PrimaryInit.
-			
-			Move.l 	A3,A0								; Restore spBlockPtr.
-			Move.b	spSlot(A0),seSlot(A2)				; Set the right slot number.
-			Move.b	spFlags(A0),seFlags(A2)				; Set the flags.
-			Move.l	A2,A0								; Set A0 to sExecBlkPtr for fake sExec call.
-			Jsr		(A1)								; Execute the PrimaryInit.
-			
-			Move.l	D3,D0								; Return result code.
-			
-@done		Movem.l	(Sp)+,@saveRegs
-			Rts
-
- 			Endwith
-
-			ENDIF
-
-;_______________________________________________________________________________________	<h5> djw
-;	StubCheckSlot	-	check if a slot status has changed
-;
-;	This is a little stub routine for the real CheckSlot routine in the slot manager
-;	overpatch file.  We need this stub because the slot manager jump table in ROM only
-;	has 16 bit offset and the overpatch file is out of range.  We therefore vector to
-;	this stub routine which then jumps to the overpatch file.
-;
-;	Input	: none
-;	Output	: none
-;
-			export	StubCheckSlot
-			import	CheckSlot
-
-StubCheckSlot
-			bra.l	CheckSlot						; go to the real routine
-
-
-;_______________________________________________________________________________________	<h5> djw
-;	StubAddCard	-	add a card to slot manager
-;
-;	This is a little stub routine for the real StubAddCard routine in the slot manager
-;	overpatch file.  We need this stub because the slot manager jump table in ROM only
-;	has 16 bit offset and the overpatch file is out of range.  We therefore vector to
-;	this stub routine which then jumps to the overpatch file.
-;
-;	Input	: none
-;	Output	: none
-;
-			export	StubAddCard
-			import	AddCard
-
-StubAddCard
-			bra.l	AddCard						; go to the real routine
-
-
-;_______________________________________________________________________________________	<h5> djw
-;	StubRemoveCard	-	remove a card from the slot manager
-;
-;	This is a little stub routine for the real CheckSlots routine in the slot manager
-;	overpatch file.  We need this stub because the slot manager jump table in ROM only
-;	has 16 bit offset and the overpatch file is out of range.  We therefore vector to
-;	this stub routine which then jumps to the overpatch file.
-;
-;	Input	: none
-;	Output	: none
-;
-			export	StubRemoveCard
-			import	RemoveCard
-
-StubRemoveCard
-			bra.l	RemoveCard					; go to the real routine
-
-;_______________________________________________________________________________________	start 	<LW2>
-;	EnableBlockXfer		-	find then enable cards capable of support block xfers as a Slave
-;
-;	Input	: a0 = ptr to spBlock
-;	Output	: none
-;
-;	spBlock	:	-> spSlot			slot number
-;				-> spFlags			fWarmStart - if set then a warm start (may be used by primary
-EnableBlockXfer
-			Testfor	BARTExists					; are we on a ColdFusion or PDM
-			bne.s	@goodMach
-			Testfor	MUNIExists					; do we have MUNI Nubus Controller?
-			Beq		@exit						; no, leave
-			
-@goodMach	MoveM.l	A0/D0-D2, -(SP)
-			Clr.b	spID(A0)					; Begin search with ID 0.
-			Clr.b	spExtDev(A0)				; No external device(s).
-			Clr.b	spHwDev(A0)					; No hardware device(s).
-			Clr.b	spTBMask(A0)				; No mask in search.
-			Move.w	#catBoard,spCategory(A0)	; Look for:  Board sRsrc
-			Clr.w	spCType(A0)
-			Clr.w	spDrvrSW(A0)
-			Clr.w	spDrvrHW(A0)
-			Move.l	#(1<<foneslot), spParamData(A0)	; look only in this slot
-			_GetTypeSRsrc						; get slots board sRsrc
-			Bne.s	@done
-			Move.b	#sBlockTransferInfo, spID(A0)
-			_sReadLong							; does slot support block xfers?
-			Bne.s	@done						; no, leave
-			Move.l	spResult(A0), D0			; get sBlockTransferInfo long
-			BTst	#fIsSlave, D0				; handles blk xfer as slave? 
-			Beq.s	@done						; no, leave
-
-			Testfor	BARTExists					; are we on a ColdFusion or PDM
-			beq.s	@muni						; no, must be MUNI
-			BTst	#fSlvXferSz2, D0			; handles blk xfer size of 2?
-			Bne.s	@enable						; yes, go
-			BTst	#fSlvXferSz8, D0			; handles blk xfer size of 8?
-			Bne.s	@enable						; yes, go
-			bra.s	@done						; no, exit
-			
-@muni		BTst	#fSlvXferSz4, D0			; handles blk xfer size of 4?
-			Beq.s	@done						; no, leave
-			
-@enable		MoveQ	#0, D0
-			Move.b	spSlot(A0), D0
-			BSet	#8, D0						; make high word indicate enable blk xfer
-			Move.l	D0, A0
-			_SlotBlockXferCtl			
-
-@done		MoveM.l	(SP)+, A0/D0-D2
-@exit		Rts
-																							;end 	<LW2>
 
 ;_______________________________________________________________________________________
 ;	Secondary_Init	-	secondary initialization
@@ -1457,7 +1024,56 @@ Secondary_Init
 			moveq	#sLastSlot,d1					; start with slot $E					<2.0>
 @Loop
 			move.b	d1,spSlot(a0)
-			bsr.s	DoSecondaryInit					; execute slot secondaryInit code		<h7> djw
+
+			clr.b	spId(a0)						; start looking with id = 0				<4>
+			slotjsr	GetBoard						; get the sInfo and board sRsrc ptrs	<4>
+			bne.s	@Done							; bad slot
+			movea.l	spsPointer(a0),a3				; save ptr to board srsrc
+			movea.l	spResult(a0),a1					; get a1 = ptr to sInfo record
+
+;	Check the status of this slot.  If "temporarily disabled", then enable the slot
+
+			cmpi.b	#stateSInit,siState(a1)			; have we already executed secondary init ?
+			bhs.s	@Done							; yes - skip this slot
+			move.w	siInitStatusA(a1),d0			; get card status
+			bpl.s	@Continue						; status ok
+			cmpi.w	#smInitStatVErr,d0				; is card temporarily disabled ?
+			bne.s	@Done							; no - card is really bad
+			cmpi.w	#svDisabled,siInitStatusV(a1)	; vendor temporarily disabled code ?
+			bgt.s	@Done							; no - a fatal vendor code
+
+			clr.w	siInitStatusA(a1)				; temp disabled - clr err so FindStruct will work
+			bset.b	#fTempEnabled,siStatusFlags(a1)	; make sure temp enabled bit is set
+
+;	Check if the board sResource has a secondary init record
+
+@Continue	move.w	d0,d2							; save status value for siInitStatusA field
+			move.b	#SecondaryInit,spId(a0)			; id to search for
+			_sFindStruct
+			beq.s	@Execute						; secondary init record found
+			move.w	d2,siInitStatusA(a1)			; no secondary init - restore status error
+			bclr.b	#fTempEnabled,siStatusFlags(a1)	; test and clear temp enabled bit
+			beq.s	@Done							; was not set
+			move.w	#smInitStatVErr,siInitStatusA(a1)	; was "temp enabled" - restore error
+			bra.s	@Done							; continue to next slot
+
+;	Load the code and execute the secondary init record
+
+@Execute	move.l	a3,spsPointer(a0)				; restore ptr to board srsrc
+			move.b	d1,seSlot(a2)					; set slot in sExec blk
+			move.b	spFlags(a0),seFlags(a2)			; xfer warmstart flag (if present)
+			_sExec									; execute the code
+
+;	Update the sInfo record status field - vendor status returned in sExec blk
+
+			bclr.b	#fTempEnabled,siStatusFlags(a1)	; clear temp enabled bit
+			move.b	#stateSInit,siState(a1)			; update state variable
+			move.w	seStatus(a2),siInitStatusV(a1)	; update vendor status
+			bpl.s	@Done							; good secondary init status - continue
+			move.w	#smInitStatVErr,siInitStatusA(a1)	; some fatal vendor status returned
+
+@Done
+
 
 @EndLoop	dbra	d1,@Loop						; dec slot count						<2.0>
 			cmpi.b	#sLastSlot,d1					; done ?
@@ -1478,80 +1094,6 @@ Secondary_Init
 			movem.l	(sp)+,d1-d2/a1-a3
 			rts
 
-;_______________________________________________________________________________________	<h11> djw
-;	DoSecondaryInit  	-	find and execute secondaryInit records
-;
-;	Called by Secondary_Init.  For a single slot, find the board sResource and if there
-;	is a secondary init record, execute it.
-;
-;	Input	: reg a0 = ptr to spBlock
-;				  a2 = ptr to sExecBlk
-;	Output	: none
-;
-;   trashes d0/d2-a1/a3.
-;
-;	spBlock	:	-> spSlot			slot number
-;
-			Export	DoSecondaryInit
-
-DoSecondaryInit
-@regs		reg		d0-d2/a1/a3
-			movem.l	@regs,-(sp)
-
-			clr.b	spId(a0)						; start looking with id = 0				<4>
-			slotjsr	GetBoard						; get the sInfo and board sRsrc ptrs	<4>
-			bne.s	@Done							; bad slot
-			movea.l	spsPointer(a0),a3				; save ptr to board srsrc
-			movea.l	spResult(a0),a1					; get a1 = ptr to sInfo record
-
-;	Check the status of this slot.  If "temporarily disabled", then enable the slot
-
-			cmpi.b	#stateSInit,siState(a1)			; have we already executed secondary init ?
-			bhs.s	@Done							; yes - skip this slot
-			move.w	siInitStatusA(a1),d0			; get card status
-			bpl.s	@Continue						; status ok
-			cmpi.w	#smInitStatVErr,d0				; is card temporarily disabled ?
-			bne.s	@Done							; no - card is really bad
-			cmpi.w	#svDisabled,siInitStatusV(a1)	; vendor temporarily disabled code ?
-			bgt.s	@Done							; no - a fatal vendor code
-
-			clr.w	siInitStatusA(a1)				; temp disabled - clr err so FindStruct will work
-			bset.b	#fTempEnabled,siStatusFlags(a1)	; make sure temp enabled bit is set
-
-;	Check if the board sResource has a secondary init record
-
-@Continue	move.w	d0,d2							; save status value for siInitStatusA field
-			move.b	#SecondaryInit,spId(a0)			; id to search for
-			_sFindStruct
-			beq.s	@Execute						; secondary init record found
-			move.w	d2,siInitStatusA(a1)			; no secondary init - restore status error
-			bclr.b	#fTempEnabled,siStatusFlags(a1)	; test and clear temp enabled bit
-			beq.s	@Done							; was not set
-			move.w	#smInitStatVErr,siInitStatusA(a1)	; was "temp enabled" - restore error
-			bra.s	@Done							; continue to next slot
-
-;	Load the code and execute the secondary init record
-
-@Execute	move.l	a3,spsPointer(a0)				; restore ptr to board srsrc
-			move.b	spSlot(a0),seSlot(a2)			; set slot in sExec blk
-			move.b	spFlags(a0),seFlags(a2)			; xfer warmstart flag (if present)
-			_sExec									; execute the code
-
-;	Update the sInfo record status field - vendor status returned in sExec blk
-
-			bclr.b	#fTempEnabled,siStatusFlags(a1)	; clear temp enabled bit
-			move.b	#stateSInit,siState(a1)			; update state variable
-			move.w	seStatus(a2),siInitStatusV(a1)	; update vendor status
-			bpl.s	@Done							; good secondary init status - continue
-			move.w	#smInitStatVErr,siInitStatusA(a1)	; some fatal vendor status returned
-
-@Done
-			movem.l	(sp)+,@regs
-			rts
-			endwith
-
-		If SeparateFile or Not forROM then			;										<8>
-
 ;_______________________________________________________________________________________
 ;	ReConfigVideo  -  select new default video screen
 ;
@@ -1621,8 +1163,6 @@ ROMFROVideo	Equ	$00000b58						; hard offset only applies to Mac II rev A roms	<
 @Done		MOVEQ	#0,D0						; only good returns
 			RTS									; done
 
-		endif									;											<8>
-
 SecondaryEnd
 
 			
diff --git a/OS/SlotMgr/SlotMgrPatch.a b/OS/SlotMgr/SlotMgrPatch.a
--- a/OS/SlotMgr/SlotMgrPatch.a
+++ b/OS/SlotMgr/SlotMgrPatch.a
@@ -440,7 +440,7 @@ SRTMerge
 
 				MACRO						; <1.1>
 				DateStr
-				dc.b	'&SYSDATE'
+				dc.b	'27-Aug-92'
 				ENDM
 
 ;*************************************************************
diff --git a/OS/StartMgr/Boot3.a b/OS/StartMgr/Boot3.a
--- a/OS/StartMgr/Boot3.a
+++ b/OS/StartMgr/Boot3.a
@@ -23,59 +23,7 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM30>	 11/7/93	SAM		Roll in <MC2> from mc900ftjesus.
-;	   <MC2>	 11/7/93	SAM		Sync-in this file with CPUBootcode.a from the gibbly sources.
-;	  <SM29>	 7/21/93	RC		Changed RegisterROMComponent to selector 42 instead of 27
-;	  <SM28>	 7/20/93	SAM		Cleaned up more stuff.  Moved the processmgr 'proc' resource
-;									loading code *way* forward in the boot.  The scod's end up being
-;									the very first resources in the heap. The "Welcome dialog is
-;									displayed after the scods are loaded.  Removed a couple of 24
-;									bit routines.  Redid the old installmgr code (which is now
-;									called InitSys7ToolBox).  See the comment block around that
-;									change for details.  Made QuickTime components not load on
-;									68010s.  Added labels to the ROM header references.
-;	  <SM27>	 6/17/93	rab		Removed the GetGibbly and CanThisGibblyBootThisMachine routines
-;									and the code that calls them. This code was inadvertantly rolled
-;									in during the Ludwig sync up.
-;	  <SM26>	 6/15/93	SAM		Undid change <LW2> for PDM.  We dont need a gibbly to boot
-;									(we're actually turning the ROM you see...)
-;	  <SM25>	 6/14/93	kc		Roll in Ludwig.
-;	  <LW2>		3/25/93		GS		Added GetGibbly and CanthisGibblyBootThisMachine routines to put 
-;									up the proper Alert when booting a 7.1 System without a Gibbly.
-;	  <SM24>	 4/20/93	SAM		Removed a call to _InitFonts, cuz _InitGraf calls it.
-;	  <SM23>	 2/12/93	PN		Add forROM condition for the previous change
-;	  <SM22>	02/11/93	HY		Fix problem in routine DetachAndExecute.  If a particular resource
-;									is not found in either the ROM or system file then you crash. 
-;	  <SM21>	02/10/93	HY		Enable Appletalk on LCR/LC930 again.  Revert <SM18> changes.
-;	  <SM20>	  2/5/93	SAM		Removed the code that was unimplementing MemoryDispatch based on
-;									MMUtype.  Removed the CPU/MMU checks before calling VM.  VM
-;									knows if it can run.
-;	  <SM19>	01/11/93	jmp		Updated various BoxFlag names.
-;	  <SM18>	12/16/92	HY		Disable Appletalk on LCR/LC930.
-;	  <SM17>	 12/7/92	GMA		We now call RegisterRomComponents directly from Boot3 instead of
-;									through the Manager InstallationVector(in ROM). Rom Components
-;									are registered (through ComponentDispatch) after making the
-;									Cyclone Gibbly Resident. This allows the Components in ROM to
-;									use Localized Strings in the Gibbly without referenceing the
-;									gibbly file directly.
-;	  <SM16>	 12/1/92	RB		Added a call to MakeOverrideMap so that the 'rovm' resource is
-;									used to override some system resources.
-;	  <SM15>	11/20/92	GS		Added the EnablePDMsgs for the Quadra 900/950 .  This was
-;									originally in a linked patch routine to avoid a problem with the
-;									KeySw handler early in the boot process.
-;	  <SM14>	11/18/92	RB		Finally, the Disk Cache code is in ROM so we don't need to
-;									install ptch 41 (the only one in SuperMario ROMs) anymore.
-;	  <SM13>	 11/3/92	RB		Use ROMBase to check for VM being in ROM or not, and call
-;									StripAddress on the resource pointer before checkin it, just in
-;									case we are in 24 bit mode.
-;	  <SM12>	 11/3/92	fau		Corrected a dereference in DetachandExecute.
-;	  <SM11>	11/01/92	HY		Conditionalize changes in <SM10> for LC930 because we don't have 
-;									VM in ROM.
-;	  <SM10>	10/30/92	RB		Give VM in ROM a chance to load when this file is being used as
-;									a ROM Gibbly. VM in ROM is newer than the one in the system and
-;									it behaves correctly in SuperMario based ROMs.
 ;	   <SM9>	10/29/92	SWC		Changed ShutdownEqu.a->Shutdown.a.
-;		<SM8>	10/22/92	CSS		Change short branches to word branches.
 ;		<41>	 8/13/92	JDR		Offset to CloseTheFile was out of range in ForTheFuture.
 ;		<40>	 8/13/92	DTY		#1039434 <BBM>: Don’t register components from QuickTime if
 ;									we’re booting on a 68000.
@@ -471,7 +419,7 @@ supportsMFM				equ		1
 			include	'TextServices.a'		; so we have SetTextServiceLanguage					<14>
 			include	'UniversalEqu.a'		; 													<15>
 
-						MACHINE	MC68020		; <SM28>
+						MACHINE	MC68040
 
 
 _AUXDispatch	 		opword	$ABF9		; <24> A/UX’s trap dispatch *** move to Traps.a
@@ -508,19 +456,6 @@ kFileShareCreator		equ		'hhgg'		; <12>
 kAppleShareCreator		equ		'afps'		; <12>
 kDALCreator				equ		'dald'		; <12>
 
-	IF forROM THEN							; <28>
-
-SysVersForROM			equ		$0710		; <28> jam Cube-E system version into SysVersion lowmem for now
-
-kROMVersionPlus			equ		$0075		; <28>
-kROMVersionSE			equ		$0276		; <28>
-kROMVersionII			equ		$0178		; <28>
-kROMVersionPortable		equ		$037A		; <28>
-kROMVersionIIci			equ		$067C		; <28>
-kROMVersionSuperMario	EQU		$077D		; <28>
-
-	ENDIF									; <28>
-
 
 BootCode	MAIN
 
@@ -563,47 +498,22 @@ SetUpStartupScreen
 			bsr 	LoadDSAT				; get the handle
 			move.l	d0,d6					; stash this away to dispose later
 
-;____________________________________________________________________________________
-; Process Manager segment tweaks.
-;
-; Load these 'scod' resource as low as possible in the system heap to reduce
-; system heap fragmentation.
-;
-; Moved this code here so the 'scod's are THE first resources in the heap.  Reduces
-; fragmentation (7/20/93) SAM  					<SM28>
+			_InitFonts						; prepare to draw some text
 
-kProcessManagerSegmentType	equ		'scod'		; Process Manager segment resource type <28>
+			bsr		EraseMyIcon
 
-				subq	#2,sp					; make room in stack for old resfile id	<28>
-				_CurResFile						; Remember the current resource file, in case we’re booting from a gibbly <28>
-				clr.w	-(sp)					; id zero is always the system file		<28>
-				_UseResFile						; Work on the System file				<28>
+; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-				lea		ProcessManagerSegmentTable,a1	; Table of Process Manager segments to load low	<28>
-@loadSegmentLoop								;										<28>
+CheckForPreGibblySystem
 
-				move.w	(a1)+,d1				; Get a segment number					<28>
-				bz.s	DoneWithSegments		; Been there, done that.				<28>
-				subq	#4,sp					; room for handle result				<28>
-				move.l	#kProcessManagerSegmentType,-(sp) ;	push res type				<28>
-				move.w	d1,-(sp)				; push id								<28>
-				_Get1Resource					; Load it in							<28>
-				addq	#4,sp					; We don’t really care about the resource <28>
-				bra.s	@loadSegmentLoop		; go for the next one					<28>
-
-ProcessManagerSegmentTable						;										<28>
-
-				dc.w	$BFAC					; MiscSeg								<28>
-				dc.w	$BFB0					; KernelSeg								<28>
-				dc.w	$BFB2					; EPPCSeg								<28>
-				dc.w	0						; End of table							<28>
-
-DoneWithSegments								;										<28>
-				_UseResFile						; The current resource file is on the stack <28>
-
-
-			bsr		EraseMyIcon					; Erase the happy Mac a little later (after the processmgr loads) <SM28>
+; If there are no Gibblies that can boot this machine according to 'boot' 2,
+; display the System Too Old version.
 
+			btst	#systemEnabledBit,ExtensionsEnabledByte
+			beq.s	@gibblyPresent
+			moveq	#dsOldSystem,d0
+			_SysError
+@gibblyPresent
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
@@ -666,6 +576,7 @@ ShowStartupScreen
 			move.l	(sp),-(sp)
 			clr.w	-(sp)					; srcCopy mode
 			clr.l	-(sp)					; no maskRgn
+			bsr		EraseMyIcon
 			_CopyBits
 
 			lea		bitMapRec(sp),sp		; get rid of our bitMap on the stack
@@ -676,6 +587,7 @@ ShowStartupScreen
 
 ; Now, do the welcome screen.
 
+			bsr		EraseMyIcon
 			moveq	#dsGreeting,d0			; put up the greeting
 			_SysError
 
@@ -686,6 +598,7 @@ ShowStartupScreen
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 UnimplementedTrap	EQU		$9F
 MemoryDispatchTrap	EQU		$5C
+GestaltTrap			EQU		$AD
 
 SetUpCPUFlag
 
@@ -749,14 +662,10 @@ CheckFor040CacheInhibit								; <5> SAM
 
 			_FlushInstructionCache					; Push both caches back to RAM (FlushICache will do both caches)	<10>
 
-			MACHINE	MC68040							; Generate 040 MOVEC instructions...								<SM28>
-
 			MOVEC	CACR,D0							; Get the CAcheControlRegister
 			AND.L	#~((1<<CACR_DE_040)|(1<<CACR_IE_040)),D0	; Create a mask excluding the DE & IE bits
 			MOVEC	D0,CACR							; Clear DE & IE in the CACR (caches are now inhibited)
 
-			MACHINE	MC68020
-			
 			MOVEQ	#0,D0							; Clear D0															<10>
 			MOVE.W	TimeDBRA,D0						; Get TimeDBRA														<10>
 			DIVU.W	#(1000/k040CyclesPerDBRA),D0	; Compute the clock rate based on TimeDBRA & k040CyclesPerDBRA		<10>
@@ -959,7 +868,6 @@ DoWeHaveEnoughRAMToBoot
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-		IF NOT forROM THEN					; <SM28>
 LoadTemporaryStripAddress
 
 ; Patch loading depends on StripAddress, so install a temporary version for the time before loading.
@@ -980,7 +888,6 @@ LoadTemporaryStripAddress
 			_SetTrapAddress newOS			; StripAddress doesn’t exist, use mine as a bootstrap
 			moveq	#1,d5					; <16> Use D5 to mean we patched _StripAddress.  Any number will do…
 @done
-		ENDIF
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 LoadVMAndDebugger
@@ -1016,6 +923,14 @@ ChooseBufPtrLimit							;													<33>
 
 GetBufPtrLimit		equ			-4			; MemoryDispatch selector to get any bufPtr limit
 
+			move	#GestaltTrap,d0			; no ROM Gestalt means no MMU (Plus, SE, II?)
+			_GetTrapAddress newOS
+			move.l	a0,d1
+			move	#UnimplementedTrap,d0
+			_GetTrapAddress newTool
+			cmp.l	a0,d1
+			beq.s	@noVMLimit
+
 			move.l	#gestaltVMAttr,d0		; is VM on?
 			_Gestalt						;
 			tst.w	d0
@@ -1068,7 +983,7 @@ RelocateBootWorld
 
 			move.l	BootGlobals.logicalMemTop(a5), d0		; starting MemTop					<10>
 			cmp.l	BootGlobals.physicalMemTop(a5), d0		; did we add memory?				<10>
-			bls 	LoadUserAlerts							; if not, don’t bother				<10> <SM8> CSS 
+			bls.s	LoadUserAlerts							; if not, don’t bother				<10>
 
 			lsr.l	#1, d0									; new MemTop/2						<10>
 			move.l	d0, a1									; point to the new stack			<10>
@@ -1076,7 +991,7 @@ RelocateBootWorld
 ; fo the stack, so use the logical page size to figure out how many pages to bring in.			<12>
 			move.l	#gestaltLogicalPageSize, d0				; we want the page size				<12>
 			_Gestalt										; VM implements Gestalt				<12>
-			bne 	LoadUserAlerts							; huh? just bail…					<12> <SM8> CSS 
+			bne.s	LoadUserAlerts							; huh? just bail…					<12>
 			move.l	#kBootStackSizeNeeded, d1				; size of stack needed				<12>
 			move.w	a0, d0									; page size							<12>
 			divu	d0, d1									; number of pages we need			<12>
@@ -1115,14 +1030,12 @@ RelocateBootWorld
 			jmp		(sp)									; go to new code location			<10>
 
 FinishMovingBootWorld										;									<10>
-		IF NOT forROM THEN									;									<SM28> SAM
 			tst.w	d5										; <16> Check our _StripAddress semaphore
 			bz.s	@done									; <16> If D5 is not set, we didn’t patch _StripAddress
 
 			moveq	#$55, d0								;									<10>
 			lea 	TemporaryStripAddress, a0				;									<10>
 			_SetTrapAddress newOS							; retarget the interim StripAddress code	<10>
-		ENDIF
 @done														;									<10>
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
@@ -1190,8 +1103,6 @@ ActivateTrackCache
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-	IF NOT forROM THEN						; <SM2> rb <SM14> rb
-
 LoadFileSystemCache
 
 ; This makes assumptions about the RAM cache that are not true of the 6.X cache:
@@ -1216,116 +1127,13 @@ LoadFileSystemCache
 			moveq	#41,d0
 			bsr 	LoadLowerCaseptch
 
-	ENDIF									; <SM2> rb <SM14> rb
-
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-		IF forROM THEN					;											<28>
-
-; In the SuperMario based ROMs, we do not run PTCH(0) or any other patches.  However, we do
-; need some of the functionality from PTCH(0).  So instead we will execute some of the code
-; which is relevant to SuperMario ROMs.  The code in here comes from the file BeforePatches.a
-; which gets compiled into PTCH(0), the Universal patch. (Or used to be-Universal). If the code
-; in this section gets too big, copy this file into a ROMBoot3.a file so that we do not bother
-; the system guys.
-
-; Make sure that ExpandMem is the latest, we leave this here because when the system changes, we
-; will need to recompile this gibbly resource and ship it with the system disks, therefore the
-; ROM will have an outdated version of ExpandMem.  The loading of new vectors from disk will
-; happen around this time, so the code that allocated the ExpandMem has already been executed
-; and there is no point on replacing it with a new vector.  So let's update ExpandMem. <28>
-
-
-			with	ExpandMemRec		;											<28>
-
-			movea.l ExpandMem,a0		; Let's see if we have the latest			<28>
-			move.l	emSize(a0),d0		; current size of ExpandMem record			<28>
-			cmpi.l	#emRecSize,d0		; already allocated new blocks?				<28>
-			bge.s	@noSpandex			; no change nessesary...  				    <28>
-
-; allocate a new block for the newer ExpandMem
-
-			movea.l a0,a1				; save original ExpandMem pointer			<28>
-			move.l	#emRecSize,d0		; allocate correct amount of space			<28>
-			_NewPtr ,SYS,CLEAR			; make pointer for a bigger and better copy	<28>
-			bne 	@ErrorXit			; no memory ? something must be really wrong <28>
-
-; a0 = pointer allocated for new expandMem of emRecSize bytes.
-; copy original bytes of expandMem into my local space.
-
-			move.l	emSize(a1),d0		; current size of ExpandMem record			<28>
-			exg 	a0,a1				; want source in a0							<28>
-			_BlockMove					; <29June89smb>	copy old data				<28>
-			move.w	#emCurVersion,emVersion(a1) ; version number					<28>
-			move.l	#emRecSize,emSize(a1) 	; size									<28>
-			move.l	a1,ExpandMem		; start using new expandMem					<28>
-
-; dispose of original ExpandMem pointer.
-			_DisposPtr					; still in a0 after move 					<28>
-			beq.s	@noSpandex			; exit if everything is ok					<28>
-
-@ErrorXit	_SysError					; <24Aug89smb>								<28>
-
-			endWith						;											<28>
-
-@noSpandex								; skip around when no room
-
-;____________________________________________________________________________________
-; Jam system version number.												<PP149>
-; *** we may not really want to do this in the ROM gibbly, but it doesn’t hurt
-
-			move.w	#SysVersForROM,SysVersion ; jam sys version number				<28>
-
-;____________________________________________________________________________________
-
-; Check to see if AppleTalk is active.  If it is not, set emAppleTalkInactiveOnBoot
-; to true.  Various other parts of the System will look at this global later on to
-; determine whether or not network code should be loaded.
-
-			move.b	SPConfig,d0				;  Get serial port configuration		<28>
-			and.b	#$0f,d0					;  Mask off Port B bits					<28>
-			beq.s	@appleTalkIsActive		;  Yes.  Don’t set emAppleTalkInactiveOnBoot <62>
-			cmp.b	#useATalk,d0			;  Configured for AppleTalk?			<28>
-			beq.s	@appleTalkIsActive		;  Yes.  Don’t set emAppleTalkInactiveOnBoot <28>
-
-			with	ExpandMemRec						; Get the system's globals	<28>
-			move.l	ExpandMem,a0						; 							<28>
-			move.w	#-1,emAppleTalkInactiveOnBoot(a0)	; just do it				<28>
-			EndWith										;							<28>
-
-@appleTalkIsActive										;							<28>
-
-; loop through all the open resource files, and clear the alternate attributes byte
-; then, set it for the system file
-
-SetupResourceFileAttributes					;											<28>
-			move.l	TopMapHndl,a0			;start with the first map					<28>
-@next										;											<28>
-			move.l	a0,d0					;are we done?								<28>
-			bz.s	@done					;											<28>
-			move.l	(a0),a0					;get the map pointer						<28>
-			bclr	#decompressionPasswordBit,mInMemoryAttr(a0)			; clear the flags for this map <28>
-			move.l	mNext(a0),a0			;go on to the next map						<28>
-			bra.s	@next					;											<28>
-@done										;											<28>
-			move.l	SysMapHndl,a0			;get the system map							<28>
-			move.l	(a0),a0					;											<28>
-			bset	#decompressionPasswordBit,mInMemoryAttr(a0)			; allow dcmps here 		<28>
-			bset	#dontCountOrIndexDuplicatesBit,mInMemoryAttr(a0)	; Don’t count duplicate resources in the System file <28>
-			bset	#twoDeepBit,mInMemoryAttr(a0)						; One deep calls on the System file will search two (or more) maps. <28>
-
-
-		ELSE								; not ROM, System version					<28>
-
 LoadPTCHZero
 
-; PTCH(0) does not get executed in SuperMario based ROMs, only in the System.			<28>
-
 			MOVEQ	#0,D0					; load patches for all ROMs
 			BSR 	LoadPTCH
 
-		ENDIF								; IF forROM									<28>
-
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
@@ -1337,9 +1145,6 @@ LoadPTCHZero
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-	IF NOT forROM THEN						; don’t load ROM specfic patches or linked patches	<28>
-											; for SuperMario									<28>
-
 LoadPTCHROMSpecific
 		
 		; *** obsolete, get rid of this eventually
@@ -1394,70 +1199,6 @@ LoadLinkedPatches
 		
 @done
 
-	ENDIF									; IF NOT forROM									<28>
-
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-; Initialize all the System 7.0 Toolbox managers and finalize the VM installation
-; if its enabled.  Rewrote this (7/20/93) <SM28>.  Make Override needs to be called before
-; all the System 7 toolbox init code runs, TEInit after, and finally ROM component registration.	<SM28>
-;
-
-; In the SuperMario ROM, most of the 7.0 initialization routines have been grouped
-; together so that we can call them trough a 1 vector call.  This vector offset from
-; the start of the ROM is guaranteed not to change.  Later on we may want to change
-; this code so it can tell the vector routine which 7.0 Managers to initialize and
-; which ones not to initialize.  As in:  "We totally re-wrote the Sound Manager, so
-; don't bother installing the old one"
-
-	IF forROM THEN
-									; Override sys resources before initing the 7.0 toolbox stuff	<SM28>
-			
-			move.l	SysMapHndl,-(sp); Push the map to override (the System File map)
-			_MakeOverrideMap		; Override resources in the System with those in the 'romv'
-									; ROM resource.
-
-			WITH	ROMHeader
-			CLR.W	CurMap			; Make the System Map the current one
-
-			MOVE.L	ROMBase,A0					; Get base o ROM
-			ADD.L	InitSys7ToolboxOff(A0),A0	; Add in the offset to the routine of Doom
-			JSR		(A0)						; Call the 7.0 Toolbox initialization code	<SM28>
-					
-DoRegisterROMComponents
-			moveq	#42,d0							; Component Search selector for RegisterROMComponents					<70><72>
-
-			_ComponentDispatch						; register the components ('thng' rsrc's) in ROM
-			ENDWITH
-
-	ENDIF
-
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-
-; Load and Execute GoNative Loader
-LoadGoNative
-	
-			lea		KeyMap,A0				; Point to keymap					<76>
-			cmpi.l	#$03000000,(A0)			; Are both S & A down?
-			beq.s	@noLoad					; -> Nope, load as usual
-		;	cmpi.l	#$00200000,4(A0)		; Is N down?
-		;	beq.s	@noLoad					; -> Yes, (NSA) do not load the NTRBs
-			
-@load		move.w	#0,d0					; ID=0
-			move.l	#'gnld',d1				; type='gnld'
-			bsr		DetachAndExecute
-@noLoad
-
-
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-
-; Load and Execute Emulator Accelerations
-LoadEmulatorAccel
-	
-			move.b	#-1,ROMMapInsert
-			move.w	#1,d0					; ID=1
-			move.l	#'GARY',d1				; type='GARY'
-			bsr		DetachAndExecute
-
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 			bsr		RealityCheck			; check for enough memory to continue
@@ -1648,6 +1389,9 @@ LoadSystemComponents						;													<9>
 
 ; Register any components lurking in the system file											<9>
 
+			btst	#extensionsEnabledBit,ExtensionsEnabledByte
+			bz.s	@skipThings
+
 ;pascal long RegisterComponentResourceFile(short resRefNum, short global)						<9>
 			clr.l	-(sp)					; return value										<9>
 			clr.w	-(sp)					; system map fref									<9>
@@ -1655,14 +1399,7 @@ LoadSystemComponents						;													<9>
 			_RegisterComponentResourceFile	;													<9>
 			addq	#4,sp					; ignore result										<9>
 
-;  In the case where a component had a cmpWantsRegisterMessage, it can happen that the component
-;  manager will clone the component and open it in the app heap  (if the sys heap is full).  Unfortunately,
-;  it looks like when that component is closed, the Component Manager globals still thinks that the cloned
-;  component is around.  This will most likely not be true after all the INITs load, since the sys heap 
-;  will grow pushing the app heap up which makes some handles to the "closed" component now invalid.
-;  The following call will make sure to remove any component instances left around in the app heap.
-
-			_CleanUpApplicationComponents	; clean up any components left in the app heap
+@skipThings
 
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
@@ -1735,14 +1472,6 @@ LoadINITFiles
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-;	Enable PowerDown Messages if Caboose is available											<SM15>
-
-			jsr		EnablePDMsgs
-
-;——————————————————————————————————————————————————————————————————————————————————————————————————
-
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-
 ; Now that networks are usable, give script systems a chance to install fonts over the network.	<14>
 
 			subq	#2,sp					; make room for OSErr result
@@ -2227,8 +1956,8 @@ LoadINITFile
 ; <40> QuickTime components should not be registered on 68000 machines, since they all
 ;		assume the 020.
 
-			cmp.b	#cpu68020,CPUFlag		; <40> Are we on a 68000? (you mean, less than an '020 right? <SM28>)
-			blo.s	@skipQuickTimeFix		; <40> If so, don’t register QuickTime’s components
+			cmp.b	#cpu68000,CPUFlag		; <40> Are we on a 68000?
+			beq.s	@skipQuickTimeFix		; <40> If so, don’t register QuickTime’s components
 
 ;pascal long RegisterComponentResourceFile(short resRefNum, short global)				<9>
 			clr.l	-(sp)					; return value								<9>
@@ -2522,7 +2251,6 @@ GetINITResource
 			rts
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
-	IF NOT forROM THEN						; We's never gonna be a II 							<SM28>
 HandleMacIIWith030							; rewrite to simpler, more informed case			<48>
 
 ; Check for a Mac II ROM with a 68030.
@@ -2581,7 +2309,6 @@ HandleMacIIWith030							; rewrite to simpler, more informed case			<48>
 
 @bail
 			rts
-		ENDIF
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 LoadVM
@@ -2592,9 +2319,14 @@ LoadVM
 			btst.b	#hwCbAUX,HWCfgFlags		; are we under A/UX?
 			bnz.s	@noVM
 
-	IF forROM THEN							; we want the newer VM in ROM						<SM10> rb
-			move.w	#mapTrue,ROMMapInsert	; use the ROM if available							<SM10> rb
-	ENDIF									;													<SM10> rb
+			moveq	#cpu68020,d0
+			cmp.b	cpuFlag,d0
+			blt.s	@yesVM
+			bgt.s	@noVM
+			cmp.b	MMUtype,d0
+			bgt.s	@noVM
+@yesVM
+
 			lea		VMName,a0				; put name of VM into CurApPtr						<37>
 			move.l	a0,CurNamePtr			; Put ptr to the VM string							<37>
 			moveq	#42,d0
@@ -2766,47 +2498,12 @@ DetachAndExecute
 ; Patches are called with their handle in D1.L.
 
 	
-	IF forROM THEN							; Special case ROM's VM					<SM10> rb
-			MOVE.L	D1,-(SP)				; save resource type					<SM10> rb
-			MOVE.W	D0,-(SP)				; save resource id						<SM10> rb
-	ENDIF									;										<SM10> rb
-
 			SUBQ	#4,SP					; make room on the stack
 			MOVE.L	d1,-(SP)
 			MOVE.W	d0,-(SP)
 			_GetResource					; get the resource handle
 			MOVE.L	(SP)+,D1				; save the resource handle
-			BNE.S	@GotResource			; did we find the resource?				<SM22> hy
-	IF forROM THEN							; <SM23> 
-			ADDA.L	#6,SP					; clean up stack and get out of here	<SM22> hy
-	ENDIF		
-			BRA.S	@skip					; we didn’t get it, so just go on		<SM22> hy
-	
-@GotResource								; found it								<SM22> hy
-
-	IF forROM THEN							;										<SM10> rb
-			CMP.L	#'ptch',2(SP)			; was this lowercase patch ?			<SM10> rb
-			BNE.S	@NotROM_VM				; if not, keep on						<SM10> rb
-			CMP.W	#42,(SP)				; was it id 42, VM ?					<SM10> rb
-			BNE.S	@NotROM_VM				; if not, don't special case			<SM10> rb
-			
-			MOVE.L	D1,A0					; put ROM's VM res handle in a0			<SM10> rb
-			MOVE.L	A0,-(SP)				; save this handle, potential ROM res	<SM10> rb
-			MOVE.L	(A0),A0					; let's get its pointer					<SM12> rb
-			MOVE.L	A0,D0					; copy resource pointer to D0			<SM10> rb
-			_StripAddress					; if in 24 bit mode, get rid of flags	<SM13> rb
-			MOVE.L	(SP)+,A0				; recover the resource handle			<SM10> rb
-			CMP.L	ROMBase,D0				; is it a ROM resource ?				<SM10> rb <SM13> rb
-			BLT.S	@NotROM_VM				; if not, don't copy to RAM, it's RAM	<SM10> rb
-			_HandToHand						; copy ROM to memory					<SM10> rb
-			MOVE.L	A0,D1					; and set their handle to ptch 42		<SM10> rb
-			_HLock							; make sure it's locked too				<SM10> rb
-			
-@NotROM_VM									;										<SM10> rb
-			ADDA.L	#6,SP					; recover saved type and id				<SM10> rb
-			
-	ENDIF																
-
+			BEQ.S	@skip
 			MOVE.L	D1,-(SP)				; detach it
 			_DetachResource
 			MOVE.L	D1,A0					; get the handle
@@ -3122,7 +2819,6 @@ AdjustBarrier	;																				<38>
 			rts
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
-	IF NOT forROM THEN								; not for us either... <SM28>
 TemporaryStripAddress
 
 ; This is a copy of StripAddress used on the Plus and SE during initialization.
@@ -3130,13 +2826,10 @@ TemporaryStripAddress
 
 			AND.L	Lo3Bytes,D0
 			RTS
-	ENDIF
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 EraseMyIcon
 
-	IF NOT forROM THEN						; <28>
-
 ; Get rid of the happy Macintosh icon.
 ; The ROMs leave this icon on the screen and now that we have taken part of the
 ; boot process away from the ROM we need to erase that icon.  For the old ROMs we
@@ -3169,23 +2862,6 @@ EraseMyIconTable
 			dc.w	kROMVersionIIci,$17DA			; IIci
 			dc.w	0
 
-	ELSE											;							<28>
-
-; SuperMario based ROMs have a vector at the start of the ROM where the			<28>
-; address of the EraseMyIcon routine from ROM is stored. So let's call it.		<28>
-
-			WITH	ROMHeader
-
-			MOVE.L	ROMBase,A0					; Get base o ROM
-			ADD.L	EraseIconOff(A0),A0			; Add in the offset to the Happy Mac erase code
-			JSR		(A0)						; Erase it.						<SM28>
-
-			ENDWITH
-
-			rts
-
-	ENDIF
-
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
 CenterOnMainScreen
@@ -3236,9 +2912,6 @@ CenterOnMainScreen
 
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 
-	IF NOT forROM THEN						; This patch is not needed when building this as	<28>
-											; a gibbly for SuperMario based ROMs.				<28>
-
 CachesOffMFMPatch
 
 			MOVE.L	(SP)+,DskRtnAdr		;Save return address
@@ -3266,54 +2939,6 @@ CachesOffMFMPatch
 
 EndCachesOffMFMPatch EQU	*
 
-	ENDIF									; IF NOT forROM										<28>
-; ——————————————————————————————————————————————————————————————————————————————————————————————————
-
-
-;__________________________________________________________________________________			<<SM15>> thru next <<SM15>>
-;
-;	EnablePDMsgs - Enable Eclipse PowerDown Messages
-;
-;		This causes Caboose PowerDown messages to be sent to Eclipse instead of
-;		having Caboose turn the power off FOR you.  This way, we can unmount volumes
-;		and flush file caches, etc.  The code that does this is initialized in the ROM
-;		but has problems running before the filesystem is initialized.  Hence, it lives
-;		here because this is where the ShutdownMgr finally gets itself established.
-;__________________________________________________________________________________
-
-
-EnablePDMsgs	
-;	Only perform this initialization on machines that have Caboose-style keyswitches			<5>
-;	(i.e.:  Eclipse + Zydeco)																	<5>
-;	AND now (i.e.:  Cyclone and Cyclone LC)														<5><SM13> rb
-;
-			move.l	d0,-(sp)						; save a handy working register				<5>
-			move.l	#KeyswMask,d0					; get isolation mask ready					<5>
-			and.l	UnivROMFlags,d0					; grab keyswitch bits in UnivROMFlags		<5>
-			sub.l	#KeyswCaboose,d0				; and check if we're a Caboose keyswitch	<5>
-			movem.l	(sp)+,d0						; restore D0 (MOVEM doesn't reset CCR)		<5><SM13> rb
-			blt.s	@exit							; IF Caboose-Style Keyswitch THEN			<5><SM13> rb
-;
-;		Enable Caboose/Cuda to send Power Down Messages
-;
-		WITH	EgretPB
-
-			movem.l	d0/a0-a1,-(sp)					;     create some work registers
-			suba.l	#EgretPbSize,sp					;     make room for PB
-			move.l	sp,a0							;     point A0 to parameter block
-			move.w	#(PseudoPkt << 8) \
-					+ EnDisPDM,pbCmdType(a0)		;     Enable PowerDown Messages
-			clr.l	pbParam(a0)						;     clr parm 								<SM6>
-			move.b	#PDMTurnOn,pbParam(a0)			;     Egret powerdown msg enable			<SM6>
-			clr.l	pbCompletion(a0)				;	  No Completion
-			_EgretDispatch
-
-			adda.l	#EgretPbSize,sp					;     discard the parameter block
-			movem.l	(sp)+,d0/a0-a1					;     restore registers
-@exit												; ENDIF
-			rts										; Return to Caller							<SM15>
-		ENDWITH
-
 
 EndOfBootCode
 
diff --git a/OS/TimeMgr/TimeMgr.a b/OS/TimeMgr/TimeMgr.a
--- a/OS/TimeMgr/TimeMgr.a
+++ b/OS/TimeMgr/TimeMgr.a
@@ -481,33 +481,6 @@ MultAndMerge
 											; a0-a2/d1-d2 saved by dispatcher
 __PrimeTime	move.l	d3,-(sp)				; save d3 also
 
-;_______________________________________________________________________
-;
-; start of code from Quicktime patch
-; attempts to keep backlog from becoming very large
-;
-
-			btst.b	#ExtendedTmTaskBit, qType(a0)
-			beq.s	@notExtended
-			lea		3+tmReserved(a0), a1
-			tst.l	tmWakeUp(a0)
-			beq.s	@startNew
-			tst.l	d0
-			beq.s	@checkCount
-@startNew:
-			clr.b	(a1)
-			bra.s	@notExtended
-@checkCount:
-			addq.b	#1, (a1)
-			bpl.s	@notExtended
-			bclr.b	#ExtendedTmTaskBit, qType(a0)
-@notExtended:
-
-;
-; end of code from Quicktime patch
-;
-;_______________________________________________________________________
-
 			tst.l	d0						; see if +msec or -µsec
 			bpl.s	@msec					; µsec are negated, msec pos
 
@@ -676,9 +649,7 @@ ThawTime	move.l	#$0000FFFF>>TickScale,d2; max range (internal form) of VIA timer
 			lea		vT2CH-vT2C(a1),a2		; point to high byte for speed
 
 ; *** Begining of time critical section
-		eieioSTP
 			sub.b	vT2C-vT2C(a1),d3		; see how many ticks of overhead used
-		eieioSTP
 			sub.w	d3,d2					; subtract out overhead ticks
 			bls.s	@Underflow				; if less than 1 tick, fix it up
 
@@ -691,21 +662,14 @@ ThawTime	move.l	#$0000FFFF>>TickScale,d2; max range (internal form) of VIA timer
 ;	guarantee that it will not be counting through zero at the time we load the real
 ;	counter value.  This fixes the "AppleShare server hang problem".
 
-		eieioSTP
 			move.b	d1,vT2CH-vT2CH(a2)		; *** ROCKWELL VIA FIX, DON'T REMOVE ***
-		eieioSTP
 			move.b	d2,vT2C-vT2C(a1)		; setup timer low byte latch
-		eieioSTP
 	if use68020Opcodes then					; 68020 shifting is fast
 			lsr.w	#8,d2					; get high byte of time
-		eieioSTP
 			move.b	d2,vT2CH-vT2CH(a2)		; load high byte of timer, start timer
-		eieioSTP
 	else									; 68000 shifting is slower than memory
 			move.w	d2,-(sp)				; get high byte of time
-		eieioSTP
 			move.b	(sp)+,vT2CH-vT2CH(a2)	; load high byte of timer, start timer
-		eieioSTP
 	endif
 ; *** End of time critical section
 
@@ -749,144 +713,23 @@ ThawTime	move.l	#$0000FFFF>>TickScale,d2; max range (internal form) of VIA timer
 ;_______________________________________________________________________
 
 __MicroSeconds: proc	export					; a0-a2/d1-d2 saved by dispatcher
+			import	FreezeTime
+			import	ThawTime
 
 			with	TimeMgrPrivate
 			
-			movem.l	d3-d5,-(sp)				; save some others as well
-			movea.l	VIA,a1					; get base address of VIA1
-			movea.l	TimeVars,a0				; point to TimeMgrPrivate
-			moveq.l	#0,d1					; d1 := 0
+			move.l	d3,-(sp)
 
-			move.w	sr,-(sp)
-			ori.w	#$0700,sr				; disable interrupts
+			jsr		FreezeTime
 
-			;	First we'll read the VIA timer.  This is complicated by three
-			;	bits of trivia.  First, if an interrupt is pending then reading
-			;	lower eight bits would clear that interrupt so we'll avoid that by
-			;	not reading the actual value in the low eight bits but just using
-			;	zero instead.  In fact, because the interrupt may become pending
-			;	between reading the upper and lower bytes we won't read the
-			;	lower byte if the upper byte is a zero even if no interrupt is yet
-			;	pending.  The second problem is that between reading the upper
-			;	byte and the lower byte, the lower byte could decrement from 00
-			;	to FF which would mean the upper byte value is wrong.  So we'll
-			;	re-read the upper byte after reading the lower byte and if they're
-			;	not equal we'll retry the entire read operation.  Finally, in
-			;	the case where the interrupt is pending we must adjust the value
-			;	to take into account the implied latency.
-			;
-			;	When we're done we'll have a 32-bit signed value in d1 which can
-			;	be combined with CurrentTime to yield the actual time.  Also,
-			;	we'll have the low eight bits from the VIA in d0.
+			move.b	TimerLowSave(a2),d1		; low byte of VIA timer
+			neg.b	d1
+			ror.l	#4,d1
+			move.w	CurrentTime+2(a2),d1	; get low word of current time
+			lea		CurTimeThresh(a2),a1	; point to CurTimeThresh
 
-		eieioSTP
-			move.b	vT2CH(a1),d1			; d1 := MSBs of timer
-		eieioSTP
-			btst.b	#T2IntBit,vIFR(a1)		; is the interrupt pending?
-		eieioSTP
-			beq.s	no_overflow
-
-overflow:	moveq.l	#-1,d1					; force upper bits to ones
-			move.b	d1,d0					; generate fake LSBs
-		eieioSTP
-			move.b	vT2CH(a1),d1			; re-read timer in case of roll-over
-		eieioSTP
-			rol.w	#8,d1					; position MSBs; LSBs become 1's
-			bra.s	done_reading_via
-
-no_overflow:tst.b	d1
-retry:		beq.s	dont_read_lsbs			; don't clear the interrupt
-		eieioSTP
-			move.b	vT2C(a1),d0				; d0 := LSBs of timer
-		eieioSTP
-			move.b	vT2CH(a1),d2			; d2 := MSBs of timer
-		eieioSTP
-			cmp.b	d2,d1					; did the MSBs roll?
-			beq.s	have_both_halves
-			move.b	d2,d1
-			bra.s	retry
-
-dont_read_lsbs:
-			moveq.l	#0,d0					; pretend they're zeros
-
-have_both_halves:
-			lsl.w	#8,d1					; slide the MSBs into position
-			move.b	d0,d1					; insert LSBs
-
-done_reading_via:
-
-			;	So now we have a 32-bit signed value in d1 which indicates
-			;	where time really is with respect to the value in CurrentTime.
-			;	In d0 we have the LSBits of the via timer.  Now we convert
-			;	these values into  microseconds.  This is pretty contorted
-			;	because the unit of VIA ticks is not a rational number.
-
-			moveq.l	#(1<<TickScale)-1,d2	; d2 := virtual tick rounding factor
-			add.l	d2,d1					; round to virtual ticks
-			asr.l	#TickScale,d1			; convert to virtual ticks by discading LSBs
-			move.l	CurrentTime(a0),d2		; d2 := time of next interrupt
-			sub.l	d1,d2					; correct with value in VIA
-
-			lea		HighUSecs(a0),a1		; form pointer for speed
-			move.l	(a1)+,d3				; d3.l := High 32 bits of uSeconds
-			move.w	(a1)+,d4				; d4.w := Next 16 bits of uSeconds
-			move.l	(a1)+,d5				; d5.l := 16 LSBs of uSec and 16 bit fraction
-			swap	d0						; put VIA LSBs in d0.hi
-			move.w	(a1)+,d0				; d0.w := threshold
-
-			move.w	(sp)+,sr				; now we can enable interrupts
-
-			;	Recall that MicroSeconds are maintained internally as an 80 bit
-			;	number with 64 bits of mantissa and 16 bits of fraction.
-			;
-			;	The first part of the conversion is to do a huge division by
-			;	repeated subtraction.  We look at the CurrentTime and the
-			;	Threshold and increment the Threshold by a value X until it
-			;	is greater than the CurrentTime.  Each time we add X to the
-			;	Threshold we add Y to the 80 bit microsecond counter.  X and Y
-			;	have been carefully chosen so that X is as close to 2^12 as
-			;	possible and is such that X * Via_Tick_Units is exactly
-			;	representable in a 32.16 fixed point value.
-			
-check_threshold:
-			cmp.w	d0,d2					; compare CurrentTime to Threshold
-			bmi.s	threshold_ok
-			addi.w	#ThreshInc,d0			; update threshold
-			addi.l	#USecsInc,d5			; update Microseconds
-			bcc.s	check_threshold
-			addq.w	#1,d4					; propagate carry
-			bcc.s	check_threshold
-			addq.l	#1,d3					; propagate carry
-			bra.s	check_threshold
-
-threshold_ok:
-			swap	d4
-			swap	d5
-			move.w	d5,d4					; d3:d4 := 64 bit microseconds count, nearly
-			swap	d5						; d5    := 16 bit fractional part
-
-			;	At this point:
-			;	D0.Hi	=> lower 8 bits of the upper word are the low VIA byte
-			;	D0.Lo	=> Updated Threshold
-			;	D2		=> Updated CurrentTime
-			;	D3.L 	=> 32 high order bits of microseconds counter
-			;	D4.L 	=> 32 low order bits of microseconds counter
-			;	D5.W 	=> 16 bits of microseconds fraction
-
-
-adjust_for_residual:
-
-			;	Now we need to use the remaining part of Threshold and the four
-			;	LSBs of the VIA timer to provide further accuracy.
-
-			move.l	d0,d1					; d1.hi := VIA LSBs
-			swap	d1						; d1.lo := VIA LSBs
-			neg.b	d1						; convert it to be additional time
-			ror.l	#TickScale,d1			; move it into high byte for insertion
-
-			sub.w	d0,d2					; CurrentTime := CurrentTime - CurTimeThresh
-			addi.w	#ThreshInc,d2			; compute additional time
-			move.w	d2,d1					; combine with VIA MSBs
+			sub.w	(a1),d1					; CurrentTime := CurrentTime - CurTimeThresh
+			addi.w	#ThreshInc,d1			; compute additional time
 			rol.l	#TickScale,d1			; convert to un-scaled VIA time
 			mulu.w	#InternalToUs>>16,d1	; convert to microseconds
 		if 32-IntToUsFractBits-TickScale <> 1 then
@@ -894,17 +737,19 @@ adjust_for_residual:
 		else
 			add.l	d1,d1					; align to form 16.16 fixed point result
 		endif
-			add.w	d5,d1					; add in FractUSecs, set ccr.x to carry out
+			add.w	-(a1),d1				; add in FractUSecs, set ccr.x to carry out
+			move.l	-(a1),d0				; LowUSecs
+			move.l	-(a1),a0				; HighUSecs
 			clr.w	d1						; clear out fraction bits
 			swap	d1						; get additional µsecs
-			addx.l	d1,d4					; add additional time to LowUSecs
+			addx.l	d1,d0					; add additional time to LowUSecs
 			subx.l	d1,d1					; -1 if ccr.x = 1, 0 if ccr.x = 0
-			sub.l	d1,d3					; propagate carry into HighUSecs
+			sub.l	d1,a0					; propagate carry into HighUSecs
 
-			movea.l	d3,a0					; put result in result registers
-			move.l	d4,d0
-			movem.l	(sp)+,d3-d5				; restore saved registers
-			rts								; all done											<4>
+			jsr		ThawTime
+
+			move.l	(sp)+,d3
+			rts
 
 			endproc
 
@@ -941,9 +786,7 @@ FreezeTime	proc	export
 			ori.w	#$0700,sr				; disable all interrupts
 	if forROM then
 		if hasPowerMgr then
-		eieioSTP
 			tst.w	Clock16M				; force processor out of idle.
-		eieioSTP
 		endif
 	else
 
@@ -951,9 +794,7 @@ FreezeTime	proc	export
 
 			export	PoundThreeNOPsHereIfNoPowerMgr
 PoundThreeNOPsHereIfNoPowerMgr:
-		eieioSTP
 			tst.w	Clock16M				; force processor out of idle.
-		eieioSTP
 
 	endif
 
@@ -964,13 +805,9 @@ PoundThreeNOPsHereIfNoPowerMgr:
 ;	We also correct for the case where the high byte counted from 00 -> FF, in which
 ;	case the interrupt pending bit may have been incorrect at the time we read it.
 
-		eieioSTP
 			move.b	vT2CH-vT2CH(a1),d2		; get high byte of counter
-		eieioSTP
 			moveq.l	#1<<T2IntBit,d1			; setup mask to check int pending
-		eieioSTP
 			and.b	vIFR-vT2CH(a1),d1		; get interrupt pending bit
-		eieioSTP
 			neg.l	d1						; d1.hi := -1 if int pending, else 0
 	if use68020Opcodes then					; 68020 shifting is fast
 			move.b	d2,d1					; insert timer high byte
@@ -979,31 +816,21 @@ PoundThreeNOPsHereIfNoPowerMgr:
 			move.b	d2,-(sp)				; insert timer high byte
 			move.w	(sp)+,d1				; position it in the right place
 	endif
-		eieioSTP
 			move.b	vT2C-vT2CH(a1),d1		; insert timer low byte
-		eieioSTP
 			sub.b	vT2CH-vT2CH(a1),d2		; see if high byte changed
-		eieioSTP
 			beq.s	@TimeOK					; if not, time is correct
 
 			subx.l	d2,d2					; d2 := -1 if counted through zero
 			or.l	d2,d1					; update sign bits
 	if use68020Opcodes then					; 68020 shifting is fast
-		eieioSTP
 			move.b	vT2CH-vT2CH(a1),d1		; re-read timer high byte
-		eieioSTP
 			lsl.w	#8,d1					; position it in the right place
 	else									; 68000 shifting is slower than memory
-		eieioSTP
 			move.b	vT2CH-vT2CH(a1),-(sp)	; re-read timer high byte
-		eieioSTP
 			move.w	(sp)+,d1				; position it in the right place
 	endif
-		eieioSTP
 			move.b	vT2C-vT2CH(a1),d1		; insert timer low byte
-		eieioSTP
 @TimeOK
-		eieioSTP
 			move.b	d1,TimerLowSave(a2)		; save low byte of VIA timer						<4>
 			moveq.l	#(1<<TickScale)-1,d2	; prepare to round to virtual ticks
 			add.l	d2,d1					; if virtual tick not complete, don't count it
@@ -1101,48 +928,31 @@ InitTimeMgr	proc	export
 			lea		vACR(a4),a4				; point to AUX control reg for speed
 
 			moveq.l	#-$80+(1<<T2IntBit),d1	; enable timer 2 interrupts
-		eieioSTP
 			move.b	d1,vIER-vT2C(a1)		; initialize the interrupt enable bit
-		eieioSTP
 
 			moveq.l	#~(1<<5),d5				; mask to set timer 2 into timed interrupt mode
-		eieioSTP
 			and.b	vACR-vACR(a4),d5		; save old AUX control reg
-		eieioSTP
 			moveq.l	#%00111111,d0			; force timer 1 into one-shot mode
 			and.b	d5,d0					; clear the bits
-		eieioSTP
 			move.b	d0,vACR-vACR(a4)		; setup temporary AUX control reg
-		eieioSTP
 			moveq.l	#0,d3					; setup timer low byte value
 			move.w	sr,d3					; get sr
 			swap	d3						; sr in high word
 
-		eieioSTP
 			move.b	d1,vT1CH-vT1C(a3)		; load and start timer 1
-		eieioSTP
 			move.b	d1,vT2CH-vT2C(a1)		; load and start timer 2
-		eieioSTP
 			move.b	vT2C-vT2C(a1),d0		; get timer 2 low byte
-		eieioSTP
 			sub.b	vT1C-vT1C(a3),d0		; get initial timer skew
-		eieioSTP
 			jsr		ThawTime				; run the critical section, start timer
-		eieioSTP
 			move.b	vT2C-vT2C(a1),d1		; get timer 2 low byte
-		eieioSTP
 			sub.b	vT1C-vT1C(a3),d1		; get final timer skew
-		eieioSTP
 
 			sub.b	d0,d1					; don't count initial skew
 			subi.w	#(($FFFF>>TickScale)<<TickScale),d1	; subtract out loaded timer value
 			move.b	d1,TimerAdjust(a0)		; setup the fudge factor
 
-		eieioSTP
 			move.b	d5,vACR-vACR(a4)		; restore AUX control reg
-		eieioSTP
 			st		vT2CH-vT2C(a1)			; load and start timer 2
-		eieioSTP
 			move.w	(sp)+,sr				; restore interrupt level
 			movem.l	(sp)+,@SavedRegs		; restore the registers
 			rts								; Time Manager is initialized
diff --git a/Patches/BeforePatches.a b/Patches/BeforePatches.a
--- a/Patches/BeforePatches.a
+++ b/Patches/BeforePatches.a
@@ -585,6 +585,7 @@ RAMSysInit	PROC	EXPORT
 
 			move.b	SPConfig,d0				; <26> Get serial port configuration
 			and.b	#$0f,d0					; <26> Mask off Port B bits
+			beq.s	@appleTalkIsActive
 			cmp.b	#useATalk,d0			; <26> Configured for AppleTalk?
 			beq.s	@appleTalkIsActive		; <26> Yes.  Don’t set emAppleTalkInactiveOnBoot
 
diff --git a/Patches/EDiskLocalNamePatch.a b/Patches/EDiskLocalNamePatch.a
new file mode 100644
--- /dev/null
+++ b/Patches/EDiskLocalNamePatch.a
@@ -0,0 +1,49 @@
+			LOAD	'StandardEqu.d'
+			INCLUDE	'SysEqu.a'
+			INCLUDE	'EDiskEqu.a'
+			INCLUDE	'LinkedPatchMacros.a'
+
+
+ROMInternalRAMDiskString		RomBind		(IIci,$E7DAA)
+
+
+EDiskShutdownPtch		InstallProc		(IIci,hasTERROR)
+			lea		DrvQHdr+QHead-QLink,a2
+@dqloop		move.l	(a2),d0
+			beq.s	@return
+			move.l	d0,a2					; follow link
+			move.w	dQRefNum(a2),d0			; calculate unit table offset from refNum
+			add.w	#1,d0
+			neg.w	d0
+			asl.w	#2,d0
+			move.l	UTableBase,a1
+			move.l	(a1,d0),a1
+			move.l	(a1),a1
+			btst	#dRAMBased,DCtlFlags+1(a1)
+			bz.s	@romBased
+			move.l	(a1),a1					; ptr to rom or handle to ram
+@romBased	move.l	(a1),a1
+			lea		drvrName(a1),a1
+			lea		#'.EDisk',a0			; searching for the EDisk drvr
+			clr.l	d0
+			move.b	(a0),d0
+@cmploop	cmp.b	(a0)+,(a1)+
+			bne.s	@dqloop					; not the EDisk
+			dbra	d0,@cmploop
+
+			move.l	EDiskDriveInfo.WhereStringPtr(a2),a1
+			cmpRom	ROMInternalRAMDiskString,a1
+			beq.s	@isEphemeral
+			cmp.l	#$408E7DA0,a1			; nearby location?
+			bne.s	@return
+@isEphemeral
+
+			subq	#4,sp
+			move.w	#-16535,-(sp)			; 'Internal RAM Disk'
+			_GetString
+			move.l	(sp)+,d0
+			beq.s	@return
+			move.l	d0,a1
+			move.l	(a1),EDiskDriveInfo.WhereStringPtr(a2)
+
+@return		rts
diff --git a/Patches/EDiskLocalNamePatch.a.idump b/Patches/EDiskLocalNamePatch.a.idump
new file mode 100644
--- /dev/null
+++ b/Patches/EDiskLocalNamePatch.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Patches/FinalInitialization.a b/Patches/FinalInitialization.a
new file mode 100644
--- /dev/null
+++ b/Patches/FinalInitialization.a
@@ -0,0 +1,80 @@
+			LOAD	'StandardEqu.d'
+			INCLUDE	'SysPrivateEqu.a'
+			INCLUDE	'Slots.a'
+			INCLUDE	'LinkedPatchMacros.a'
+
+
+InitADBDrvr		ROMBind	(SE,$03C9E),(II,$07724),(Portable,$05BEE),(IIci,$0A7B0)
+OpenSlots		ROMBind	(II,$01370),(IIci,$02240)
+
+
+; Pieced together from StartBoot.a:InitSys7Toolbox
+
+
+									MakeInstall	AddFontsToChain,(Plus,SE,II,Portable,IIci)
+
+
+VMFinalInitialization				InstallProc	(Plus,SE,II,Portable,IIci,notAUX)
+	; If VM loaded, we need to call MemoryDispatch with selector (-1) so VM can hold the system heap,
+	; unhold the boot stack, patch the cursor task, and enable user mode.
+
+			MOVE.L	#$5C,D0							; _MemoryDispatch
+			_GetOSTrapAddress
+			MOVE.L	A0,D1
+			MOVE	#$9F,D0							; _Unimplemented
+			_GetToolTrapAddress
+			CMP.L	A0,D1							; Has VM installed itself?
+			BEQ.S	@noVM							; -> No.  No Memory Dispatch
+
+@hasVM		MOVEQ	#-1,D0							; Finish VM initialization selector
+			_MemoryDispatch							; Call VM.
+
+@noVM		RTS										; Return to boot3 (or Gibbly)
+
+	
+ADBSecondaryInitialization			InstallProc	(SE,II,Portable,IIci,notAUX)
+			JMPROM	InitADBDrvr						; Another reinit
+
+
+SlotMgrSecondaryInitializationII	InstallProc	(II,notAUX)
+			IMPORT	Secondary_Init
+
+			SUB.W	#spBlock.spBlockSize,SP			; Make room for a slot parameter block on the stack
+			MOVEA.L	SP,A0							; Point A0 to the record
+			BSET	#fWarmStart,spBlock.spFlags(A0)	; Set warm start flag
+			JSR		Secondary_Init					; Wake everybody up again
+			ADD.W	#spBlock.spBlockSize,SP			; Remove the param block from the stack
+			JMPROM	OpenSlots						; Open all slot drivers...
+
+
+SlotMgrSecondaryInitializationIIci	InstallProc	(IIci,notAUX)
+			SUB.W	#spBlock.spBlockSize,SP			; Make room for a slot parameter block on the stack
+			MOVEA.L	SP,A0							; Point A0 to the record
+			BSET	#fWarmStart,spBlock.spFlags(A0)	; Set warm start flag
+			_SecondaryInit							; Wake everybody up again
+			ADD.W	#spBlock.spBlockSize,SP			; Remove the param block from the stack
+			JMPROM	OpenSlots						; Open all slot drivers...
+
+
+ColorQDSecondaryInitialization		InstallProc	(II,IIci)
+			IMPORT	DavesRandomVideoStuff
+
+			JSR		DavesRandomVideoStuff			; re-do CheckDevices and video driver patching.
+			MOVE.L	(a5),-(sp)						; point to the same globals we are using now
+			_InitGraf								; catch all the new devices
+			_InitPalettes	,autoPop				; me too...
+
+
+SetUpIconCluts						InstallProc	(Plus,SE,II,Portable,IIci)
+			IMPORT	MakeIconData
+
+			MOVE.L	ExpandMem,a0
+			PEA		ExpandMemRec.emIconCluts(a0)
+			JSR		MakeIconData
+			RTS
+
+
+FontMgrSecondaryInitialization		InstallProc	(Plus,SE,II,Portable,IIci)
+			_InitFonts	,autoPop					; Reinit the font manager (in case a new one's just been loaded)
+
+			END
diff --git a/Patches/FinalInitialization.a.idump b/Patches/FinalInitialization.a.idump
new file mode 100644
--- /dev/null
+++ b/Patches/FinalInitialization.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Patches/LoadPatches.a b/Patches/LoadPatches.a
--- a/Patches/LoadPatches.a
+++ b/Patches/LoadPatches.a
@@ -130,20 +130,25 @@ Failed
 
 Copyright
 		string asis
-			dc.b	'© 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991 Apple Computer Inc.',13
+			dc.b	'© 1983-1992 Apple Computer Inc.',13
 			dc.b	'All Rights Reserved.',13
 			dc.b	13
-			dc.b	'Help! Help! We’re being held prisoner in a system software factory!',13
+			dc.b	'Help! Help! We’re still being held prisoner in a system software factory!',13
 			dc.b	13
 			dc.b	'The Blue Meanies',13
 			dc.b	13
-			dc.b	'Darin Adler',13
-			dc.b	'Scott Boyd',13
+			dc.b	'Lew Cirne',13
+			dc.b	'David Collins',13
+			dc.b	'Wayne Correia',13
 			dc.b	'Chris Derossi',13
-			dc.b	'Cynthia Jasper',13
+			dc.b	'Pete Helme',13
+			dc.b	'Fred Huxham',13
+			dc.b	'Don Louv',13
+			dc.b	'Kevin MacDonell',13
 			dc.b	'Brian McGhie',13
 			dc.b	'Greg Marriott',13
-			dc.b	'Beatrice Sochor',13
+			dc.b	'Jeff Miller',13
+			dc.b	'Fred Monroe',13
 			dc.b	'Dean Yu',13
 		align
 
diff --git a/Patches/LoadPatches.a.o b/Patches/LoadPatches.a.o
new file mode 100644
index 0000000000000000000000000000000000000000..4f10510127596de88e39ce791ccd12d413dd9c06
GIT binary patch
literal 468
zcmXAm!EO^V5Qb+%P@@V<sE3LJqLYXt1O*Ukq)M=xZQ9T*fizN;qq~`1TXO7`?M)l0
zXP$yXg*cE4@6kKF12-O_xavsb(bzNpeAYw&jV8b|h;~lrr?bOsI2s?O@hl!rrYFse
zOa1UMM9^rpq8|`!K6!O;Zj66_0MX{Uvscb0|8BqHB>4$DiGZiUcfW5HZ+ij~*e&0M
zn8K4z-1*WT0k*FI!nEhTtDyNJ^mMNu6fL}L{QC44wjX`C{arLGvAL=8&CLdT{rxvD
zd;R`vjH^l!4$QKuJy{&-yvt&xa4JjT9Zt!SUD2Y;*fFW9jrZpn{jr43%TRevQkN)5
zEwHlE869M#MviXnJT1|g!e8)EUhv!-yKXZ!6NHJX2{Ynal4ER47dVhs6HEC@E&`BJ
zQag6W*ZL06T9TX%L>Pc6S>v2!pUKl5&yv{C(gKg`OTm{cH5$jJUa=Ee1&)m8;f9oA
viIqI$`H_&sjx3eo&01-^XCJ93FblsSd#{xlZB2j)d^oS!R@hJUtpWc5SRjrl

literal 0
HcmV?d00001

diff --git a/Patches/LoadPatches.a.o.idump b/Patches/LoadPatches.a.o.idump
new file mode 100644
--- /dev/null
+++ b/Patches/LoadPatches.a.o.idump
@@ -0,0 +1 @@
+OBJ MPS 
\ No newline at end of file
diff --git a/Patches/LowMemoryPrintingPatches.a b/Patches/LowMemoryPrintingPatches.a
new file mode 100644
--- /dev/null
+++ b/Patches/LowMemoryPrintingPatches.a
@@ -0,0 +1,477 @@
+				LOAD	'StandardEqu.d'
+				INCLUDE	'LinkedPatchMacros.a'
+				INCLUDE	'PrintTrapsEqu.a'
+				INCLUDE	'Folders.a'
+				INCLUDE	'FSEqu.a'
+				INCLUDE	'LayerEqu.a'
+				INCLUDE	'Processes.a'
+
+
+Globals			RECORD	0,INCREMENT
+gPrmnModDate	DS.L	1
+gPrmnPrefMem	DS.L	1
+gPrmnVolRefNum	DS.W	1
+gPrmnDirID		DS.L	1
+gPrmnNameHand	DS.L	1
+gDialogHit		DS.W	1
+gFlag			DS.W	1
+GlobalSize		EQU		*
+				ENDR
+
+
+kCancel			EQU		1
+kPrintLater		EQU		2
+kPrintNow		EQU		3
+
+
+
+InstallLowMemoryPrinting		InstallProc		(Plus,SE,II,Portable,IIci)
+				WITH	Globals
+
+				MOVEQ	#22,D0					; create printing global handle
+				_NewHandle	,sys,clear
+				MOVE.L	ExpandMem,A1
+				MOVE.L	A0,ExpandMemRec.emLowMemoryPrintingGlobals(A1)
+				MOVE.L	A0,A2					; save printing globals
+
+				SUBQ	#4,SP
+				MOVE.L	#'STR ',-(SP)
+				MOVE.W	#-16601,-(SP)			; "PrintMonitor"
+				_GetResource					; get it in the system heap
+				MOVE.L	(A2),A0
+				MOVE.L	(SP)+,gPrmnNameHand(A0)
+				RTS
+
+
+LowMemoryPrintingDialogPatch	PatchProc	_GetResource,(Plus,SE,II,Portable,IIci)
+				IMPORT	lowMemPrintDialog
+				WITH	Globals
+
+				MOVE.L	ExpandMem,A0
+				MOVE.L	ExpandMemRec.emLowMemoryPrintingGlobals(A0),A0
+				MOVE.L	(A0),A0
+				TST.B	gFlag(A0)
+				BNE.S	@keepTesting
+@jmpOld			jmpOld
+@keepTesting	CMP.L	#'PREC',6(SP)
+				BNE.S	@jmpOld
+				CMP.W	#127,4(SP)
+				BNE.S	@jmpOld
+
+; PREC 127, call original routine...
+				LEA		10(SP),A0
+				SUBQ	#4,SP
+				MOVE.L	-(A0),-(SP)
+				MOVE.W	-(A0),-(SP)
+				BSR.S	@jmpOld
+				MOVE.L	(SP)+,D0
+				MOVE.L	D0,10(SP)
+				BEQ.S	@tailReturn				; pass through nil
+
+; and tail patch it...
+				MOVE.L	D0,A0
+				MOVE.L	(A0),A0
+				BTST	#7,(A0)
+				BNE.S	@tailReturn				; skip if first bit is set?
+
+				MOVE.L	ExpandMem,A0
+				MOVE.L	ExpandMemRec.emLowMemoryPrintingGlobals(A0),A0
+				_HLock
+				MOVE.L	(A0),A0
+				LEA		gDialogHit(A0),A0
+				TST.W	(A0)
+				BNE.S	@nodo
+				MOVE.W	ResErr,-(SP)
+				MOVE.W	MemErr,-(SP)
+				MOVEM.L	D1/D2/A0/A1,-(SP)
+				MOVE.L	A0,-(SP)
+				JSR		lowMemPrintDialog
+				MOVE.L	ExpandMem,A0
+				MOVE.L	ExpandMemRec.emLowMemoryPrintingGlobals(A0),A0
+				_HUnlock
+				MOVEM.L	(SP)+,D1/D2/A0/A1
+				MOVE.W	(SP)+,MemErr
+				MOVE.W	(SP)+,ResErr
+@nodo
+				CMP.W	#3,(A0)
+				BNE.S	@tailReturn
+				MOVE.L	10(SP),A0
+				MOVE.L	(A0),A0
+				BSET	#7,(A0)
+
+@tailReturn		MOVE.L	(SP)+,A0
+				ADDQ	#6,SP
+				JMP		(A0)
+
+
+NastierPatch	PatchProc	$A8FD,(Plus,SE,II,Portable,IIci)
+				IMPORT	prmtRunning,prmtPrefMem
+				WITH	Globals
+
+				MOVE.L	4(SP),D0
+				CMP.L	#$04000C00,D0
+				BEQ.S	@PrOpenDoc
+				CMP.L	#$08000484,D0
+				BEQ.S	@PrClosDoc
+
+@jmpOld			jmpOld
+
+@PrClosDoc		LEA		12(SP),A0
+				MOVE.L	-(A0),-(SP)
+				MOVE.L	-(A0),-(SP)
+				BSR.S	@jmpOld
+
+				MOVE.L	ExpandMem,A0
+				MOVE.L	ExpandMemRec.emLowMemoryPrintingGlobals(A0),A0
+				MOVE.L	(A0),A0
+				CLR.B	gFlag(A0)
+
+				MOVE.L	(SP)+,A0
+				ADDQ	#8,SP
+				JMP		(A0)
+
+@PrOpenDoc		MOVE.L	ExpandMem,A0
+				MOVE.L	ExpandMemRec.emLowMemoryPrintingGlobals(A0),A0
+				MOVE.L	(A0),A0
+				CLR.W	gDialogHit(A0)
+	
+				SUBQ	#2,SP
+				JSR		prmtRunning
+				TST.B	(SP)+
+				BNE.S	@jmpOld
+
+				MOVE.L	D3,-(SP)
+				SUBQ	#4,SP
+				JSR		prmtPrefMem
+				MOVE.L	(SP)+,D3
+				BEQ.S	@cannotBackground
+				BMI.S	@cleanupgo
+
+				SUBQ	#4,SP
+				_TempFreeMem
+				MOVE.L	(SP)+,D1
+				SUB.L	#20*1024,D1
+				CMP.L	D3,D1
+				BGE.S	@cleanupgo
+
+@cannotBackground
+				MOVE.L	(SP)+,D3
+
+				MOVE.L	ExpandMem,A0
+				MOVE.L	ExpandMemRec.emLowMemoryPrintingGlobals(A0),A0
+				MOVE.L	(A0),A0
+				MOVE.B	#1,gFlag(A0)
+
+				LEA		20(SP),A0
+				SUBQ	#4,SP
+				MOVE.L	-(A0),-(SP)
+				MOVE.L	-(A0),-(SP)
+				MOVE.L	-(A0),-(SP)
+				MOVE.L	-(A0),-(SP)
+				BSR.S	@jmpOld
+				MOVE.L	(SP)+,20(SP)
+
+				MOVE.L	ExpandMem,A0
+				MOVE.L	ExpandMemRec.emLowMemoryPrintingGlobals(A0),A0
+				MOVE.L	(A0),A0
+				CMP.W	#kCancel,gDialogHit(A0)
+				BNE.S	@noErr
+				MOVE.W	#128,-(SP)
+				_PrSetError
+@noErr
+				MOVE.L	(SP)+,A0
+				LEA		16(SP),SP
+				JMP		(A0)
+
+@cleanupgo		MOVE.L	(SP)+,D3
+				BRA.W	@jmpOld
+
+
+
+; Return a long, equal to the PrintMonitor's preferred memory partition
+; Error if negative
+prmtPrefMem		PROC	EXPORT
+				WITH	Globals,HParamBlockRec,HFileParam
+
+prmtPrefMemFrm	RECORD	{A6Link},DECREMENT
+result			DS.L	1
+return			DS.L	1
+A6Link			DS.L	1
+HFQEl			DS.B	ioHFQElSiz
+prmonRefNum		DS.W	1
+LocalSize		EQU		*
+				ENDR
+				WITH	prmtPrefMemFrm
+
+				LINK	A6,#LocalSize
+				MOVE.L	A2,-(SP)
+				CLR.L	result(A6)
+
+				MOVE.L	ExpandMem,A0
+				MOVE.L	ExpandMemRec.emLowMemoryPrintingGlobals(A0),A0
+				_HLock
+				MOVE.L	(A0),A2
+				TST.L	gPrmnDirID(A2)
+				BNE.S	@gotExtn
+
+				SUB.L	#2,SP
+				MOVE.W	#kOnSystemDisk,-(SP)
+				MOVE.L	#kExtensionFolderType,-(SP)
+				CLR.W	-(SP) ; do not create
+				PEA		gPrmnVolRefNum(A2)
+				PEA		gPrmnDirID(A2)
+				MOVEQ	#0,D0
+				_AliasDispatch ; FindFolder
+				MOVE.W	(SP)+,D0
+				BNE		@return
+@gotExtn
+
+				LEA		HFQEl(A6),A0
+				MOVEQ	#ioHFQElSiz/2-1,D0
+@clearLoop		CLR.W	(A0)+
+				DBRA	D0,@clearLoop
+
+				LEA		HFQEl(A6),A0
+				MOVE.L	gPrmnNameHand(A2),A1
+				MOVE.L	(A1),ioNamePtr(A0)
+				MOVE.W	gPrmnVolRefNum(A2),ioVRefNum(A0)
+				CLR.W	ioFDirIndex(A0)
+				MOVE.L	gPrmnDirID(A2),ioDirID(A0)
+				_GetCatInfo
+				BEQ.S	@gotPrintMon
+				MOVE.L	D0,result(A6)
+				BRA.S	@return
+@gotPrintMon
+
+				TST.L	gPrmnModDate(A2)
+				BEQ.S	@globWasZero
+				MOVE.L	gPrmnModDate(A2),D0
+				CMP.L	ioFlMdDat(A0),D0
+				BNE.S	@globWasZero
+				MOVE.L	gPrmnPrefMem(A2),result(A6)
+				BRA.S	@return
+@globWasZero
+				MOVE.L	ioFlMdDat(A0),gPrmnModDate(A2)
+
+				SUB.L	#2,SP
+				MOVE.W	gPrmnVolRefNum(A2),-(SP)
+				MOVE.L	gPrmnDirID(A2),-(SP)
+				MOVE.L	gPrmnNameHand(A2),A1
+				MOVE.L	(A1),-(SP)
+				MOVE.B	#1,-(SP)
+				_HOpenResFile
+				MOVE.W	(SP)+,prmonRefNum(A6)
+				BMI.S	@return
+
+				SUB.L	#4,SP
+				MOVE.L	#'SIZE',-(SP)
+				MOVE.W	#0,-(SP)
+				_Get1Resource
+				MOVE.L	(SP)+,D0
+				BNE.S	@gotSizeRes
+				SUB.L	#4,SP
+				MOVE.L	#'SIZE',-(SP)
+				MOVE.W	#-1,-(SP)
+				_Get1Resource
+				MOVE.L	(SP)+,D0
+				BEQ.S	@closeAndReturn
+@gotSizeRes
+
+				MOVE.L	D0,A0
+				MOVE.L	(A0),A0
+				MOVE.L	2(A0),D0
+				MOVE.L	D0,result(A6)
+				MOVE.L	D0,gPrmnPrefMem(A2)
+
+@closeAndReturn
+				MOVE.W	prmonRefNum(A6),-(SP)
+				_CloseResFile
+@return
+				MOVE.L	ExpandMem,A0
+				MOVE.L	ExpandMemRec.emLowMemoryPrintingGlobals(A0),A0
+				_HUnlock
+				MOVE.L	(SP)+,A2
+				UNLK	A6
+				RTS
+
+
+; Return a bool, true if the PrintMonitor is running
+prmtRunning		PROC	EXPORT
+				WITH	Globals
+
+prmtRunningFrm	RECORD	{A6Link},DECREMENT
+result			DS.W	1
+return			DS.L	1
+A6Link			DS.L	1
+psn				DS		ProcessSerialNumber
+procInfo		DS		ProcessInfoRec
+LocalSize		EQU		*
+				ENDR
+				WITH	prmtRunningFrm
+
+				LINK	A6,#LocalSize
+
+				MOVEQ	#0,D0
+				MOVE.L	D0,psn.highLongOfPSN(A6)
+				MOVE.L	D0,psn.lowLongOfPSN(A6)
+				MOVEQ	#ProcessInfoRec.size,D1
+				MOVE.L	D1,procInfo.processInfoLength(A6)
+				MOVE.L	D0,procInfo.processName(A6)
+				MOVE.L	D0,procInfo.processAppSpec(A6)
+				BRA.S	@nextProcess
+
+@getProcessInfo	SUB.L	#2,SP
+				PEA		psn(A6)
+				PEA		procInfo(A6)
+				_GetProcessInformation
+				TST.W	(SP)+
+				BNE.S	@nextProcess
+				CMP.L	#'prmt',procInfo.processSignature(A6)
+				BNE.S	@nextProcess
+				MOVE.B	#1,result(A6)
+				BRA.S	@return						; Print Monitor 'prmt' running
+
+@nextProcess	SUB.L	#2,SP
+				PEA		psn(A6)
+				_GetNextProcess
+				TST.W	(SP)+
+				BEQ.S	@getProcessInfo
+
+				CLR.B	result(A6)					; not running
+@return			UNLK	A6
+				RTS
+
+
+; Dialog: "Your document will be printed in the background when more memory is available"
+; Takes one argument: a pointer to a word
+; The pointed-to word is set to the hit item: 1 = Cancel, 2 = Print Later, 3 = Print Now
+lowMemPrintDialog		PROC	EXPORT
+				IMPORT	HandToHand
+				WITH	Globals
+
+lowMemPrintDialogFrm	RECORD	{A6Link},DECREMENT
+result			DS.L	1
+return			DS.L	1
+A6Link			DS.L	1
+oldZone			DS.L	1
+newDitlHand		DS.L	1
+itemHit			DS.W	1
+LocalSize		EQU		*
+savedRegs		DS.L	3
+				ENDR
+				WITH	lowMemPrintDialogFrm
+
+@regs			REG		D7/A3/A4
+
+				LINK	A6,#LocalSize
+				MOVEM.L	@regs,-(SP)
+
+				_GetZone
+				MOVE.L	A0,oldZone(A6)
+				MOVE.L	SysZone,A0
+				_SetZone
+
+				SUB.L	#4,SP
+				MOVE.L	#'DITL',-(SP)
+				MOVE.W	#-16601,-(SP)
+				_GetResource
+				MOVE.L	(SP)+,A4
+
+				SUB.L	#2,SP
+				_ResError
+				TST.W	(SP)+
+				BNE		@return
+
+				SUB.L	#4,SP
+				MOVE.L	#'RECT',-(SP)
+				MOVE.W	#-16601,-(SP)
+				_GetResource
+				MOVE.L	(SP)+,A3
+
+				SUB.L	#2,SP
+				_ResError
+				TST.W	(SP)+
+				BNE		@return
+
+				MOVE.L	A4,newDitlHand(A6)
+
+				SUB.L	#2,SP
+				PEA		newDitlHand(A6)
+				JSR		HandToHand
+				TST.W	(SP)+
+				BEQ.S	@ditlCopied
+				MOVE.L	oldZone(A6),A0
+				_SetZone
+				BRA		@return
+@ditlCopied
+
+				MOVE.L	A3,A0						; the dialog rect
+				_HLock
+
+				SUB.L	#4,SP
+				MOVEQ	#0,D0
+				MOVE.L	D0,-(SP)					; wStorage = nil
+				MOVE.L	(A3),-(SP)					; boundsRect
+				MOVE.L	D0,-(SP)					; title = nil
+				MOVEQ	#0,D1
+				MOVE.B	D1,-(SP)					; visible = false
+				MOVEQ	#1,D0
+				MOVE.W	D0,-(SP)					; procID = 1
+				MOVEQ	#-1,D0
+				MOVE.L	D0,-(SP)					; behind = -1
+				MOVE.B	D1,-(SP)					; goAwayFlag = false
+				MOVEQ	#0,D0
+				MOVE.L	D0,-(SP)					; refCon = 0
+				MOVE.L	newDitlHand(A6),-(SP)		; itmLstHndl = newDitlHand
+				_NewDialog
+				MOVE.L	(SP)+,A4
+
+				SUB.L	#2,SP
+				MOVE.L	A4,-(SP)
+				MOVEQ	#3,D0
+				MOVE.W	D0,-(SP)
+				_SetDialogDefaultItem
+				MOVE.W	(SP)+,D7
+
+				SUB.L	#2,SP
+				MOVE.L	A4,-(SP)
+				MOVEQ	#1,D0
+				MOVE.W	D0,-(SP)
+				_SetDialogCancelItem
+				MOVE.W	(SP)+,D7
+
+				MOVE.L	A4,-(SP)					; whichWindow = our dialog
+				MOVEQ	#lcMainScreen,D0
+				MOVE.B	D0,-(SP)					; where = lcMainScreen
+				MOVEQ	#hcCenter,D1
+				MOVE.B	D1,-(SP)					; horizontalControl = hcCenter
+				MOVEQ	#vcAlertCenter,D0
+				MOVE.B	D0,-(SP)					; verticalControl = vcAlertCenter
+				_AutoPositionWindow
+
+				_InitCursor
+
+				MOVE.L	A4,-(SP)
+				_ShowWindow
+
+				MOVEQ	#0,D0
+				MOVE.L	D0,-(SP)					; filterProc = nil
+				PEA		itemHit(A6)
+				_ModalDialog
+
+				MOVE.L	A4,-(SP)
+				_DisposeDialog
+
+				MOVE.L	A3,A0						; the dialog rect
+				_HUnlock
+
+				MOVE.L	oldZone(A6),A0
+				_SetZone
+
+				MOVE.L	result(A6),A0
+				MOVE.W	itemHit(A6),(A0)
+
+@return			MOVEM.L	savedRegs(A6),@regs
+				UNLK	A6
+				MOVE.L	(SP)+,(SP)
+				RTS
diff --git a/Patches/LowMemoryPrintingPatches.a.idump b/Patches/LowMemoryPrintingPatches.a.idump
new file mode 100644
--- /dev/null
+++ b/Patches/LowMemoryPrintingPatches.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Patches/MiscPatches.a b/Patches/MiscPatches.a
--- a/Patches/MiscPatches.a
+++ b/Patches/MiscPatches.a
@@ -16,7 +16,6 @@
 ;	Change History (most recent first):
 ;
 ;	   <SM8>	 11/3/92	SWC		Changed SlotEqu.a->Slots.a and removed INCLUDE of Traps.a.
-;	   <SM7>	  9/3/92	PN		Nuke the check for IIci because this is SuperMario.
 ;	   <SM6>	 7/14/92	PN		Use the real name for PPCTrap
 ;	   <SM5>	 5/20/92	TN		Moved entry points for Packs 8 ,9, 11, 13, 15 to new files in
 ;									the folder with the corresponding Pack sources.
@@ -137,6 +136,11 @@
 			LOAD	'StandardEqu.d'
 			INCLUDE 'LinkedPatchMacros.a'
 			INCLUDE	'BTreeEqu.a'
+			include 'Dictionary.a'
+			include 'Processes.a'
+			include 'TSMPrivate.a'
+			include 'SysEqu.a'
+			include 'SysPrivateEqu.a'
 			include 'MMUEqu.a'
 			include 'BootEqu.a'
 			include 'HardwareEqu.a'
@@ -243,7 +247,9 @@ SynchIdleTimeProc	PatchProc	_SynchIdleTime
 				_PPC											; PPC trap <PN>
 
 				WITH	PMgrRec,PowerDispRec					;
-				BRA.S	@Done									; <PN> branch always because we are SM ROM
+				MOVE.L	ROMBase,A0								; check for IIci
+				CMP.W	#$67C,8(A0)
+				BNE.S	@Done
 				Testfor	hwCbPwrMgr								; do we have a power manager?
 				BEQ.S	@Done									; no power cycling
 				MOVE.L	PMgrBase,A0								; Get the Power Manager Globals
@@ -338,6 +344,31 @@ CleanupApp		PatchProc	_CleanupApplication
 @noEditionMgr				
 		ENDIF
 		
+				;
+				; Clean up Text Services Manager
+				;
+				SUBQ	#8,SP								; make space for PSN
+				CLR.W	-(SP)								; clear space to return OSErr
+				PEA		2(SP)								; push PSN buf ptr
+				_GetCurrentProcess
+				TST.W	(SP)+
+				BNE.S	@noKillTSM
+
+				CLR.W	-(SP)								; room for result
+				PEA		2(SP)								; PSN
+				MOVE.W	#0,-(SP)							; flag = false
+				_InlineAware
+				TST.B	(SP)+
+				BEQ.S	@noKillTSM
+
+				CLR.W	-(SP)
+				MOVE.W	#kMsgKillTSMApp,-(SP)
+				PEA		4(SP)
+				_InformTSM
+				TST.W	(SP)+
+@noKillTSM
+				ADDQ	#8,SP								; clean up PSN on stack
+
 				;
 				; Clean up Compoents and Component insetances belong to this app.
 				;
@@ -444,6 +475,58 @@ get70MgrAttr	PROC
 ;
 ;___________________________________________________________________________________
 
+Pack8Patch		PatchProc	_Pack8
+
+				MOVE.L	App2Packs,A0
+				MOVE.L	ExpandMem,A1
+				LEA		ExpandMemRec.emPack8Globals(A1),A1
+				_ProcHelper
+
+
+Pack9Patch		PatchProc	_Pack9
+
+				MOVE.L	App2Packs+4,A0
+				MOVE.L	ExpandMem,A1
+				LEA		ExpandMemRec.emPack9Globals(A1),A1
+				_ProcHelper
+
+
+Pack11Patch		PatchProc	_Pack11
+
+				MOVE.L	App2Packs+12,A0
+				MOVE.L	ExpandMem,A1
+				LEA		ExpandMemRec.emPack11Globals(A1),A1
+				_ProcHelper
+
+
+Pack13Patch		PatchProc	_Pack13
+
+				TST.B	D0
+				BEQ.S	@lala
+				MOVE.L	ExpandMem,A0
+				TST.L	ExpandMemRec.emSnarfGlobals(A0)
+				BEQ.S	@noSnarf
+@lala			MOVE.L	App2Packs+20,A0
+				MOVE.L	ExpandMem,A1
+				LEA		ExpandMemRec.emPack13Globals(A1),A1
+				_ProcHelper
+
+@noSnarf		MOVE.L	(SP)+,A0
+				LSR.W	#8,D0
+				LSL.W	#1,D0
+				ADD.W	D0,SP
+				MOVE.W	#rcDBPackNotInited,(SP)
+				JMP		(A0)
+
+
+Pack15Patch		PatchProc	_Pack15
+
+				MOVE.L	App2Packs+28,A0
+				MOVE.L	ExpandMem,A1
+				LEA		ExpandMemRec.emPack15Globals(A1),A1
+				_ProcHelper
+
+
 ;___________________________________________________________________________________
 ;
 ;			dimg entry - Dictionary Manager
diff --git a/Patches/PatchIIROM.a b/Patches/PatchIIROM.a
--- a/Patches/PatchIIROM.a
+++ b/Patches/PatchIIROM.a
@@ -6982,6 +6982,7 @@ InitSlotStuff
 
 
 ;Copy the tickCounts into the new structures
+			move.l	#-1,SlotVBLQ
 			moveq	#sNumSlots-1,d1				; move sNumSlots queue headers
 			lea		([SlotQDT],\				; point to ticks for last slot
 					slotVBLInfos+slotTickCount-\
diff --git a/Patches/PatchIIciROM.a b/Patches/PatchIIciROM.a
--- a/Patches/PatchIIciROM.a
+++ b/Patches/PatchIIciROM.a
@@ -596,7 +596,6 @@ Scripts604		EQU		0						;<4.7><08/21/89 pke>
 			Include		'ScriptPriv.a'			;
 			INCLUDE		'GestaltEqu.a'			;
 			INCLUDE		'GestaltPrivateEqu.a'	;
-			INCLUDE		'TextEditPriv.a'		; <1/16/90smb> <16>
 			INCLUDE		'PackMacs.a'			;
 			INCLUDE		'InternalMacros.a'		; <54>
 
@@ -1491,6 +1490,8 @@ gestaltSerial	PROC	EXPORT
 				movea.l	emGestalt(a0),a0				; get gestalt global ptr
 				moveq.l #0,d0							; assume no GPI connections
 				cmpi.w	#gestaltMacLC,machType(a0)		; <107> use real machine name now...
+				beq.s	@noGPI
+				cmpi.w	#gestaltMacLCII,machType(a0)
 				beq.s	@noGPI
 														; IIci and IIsi have GPI connected
 				moveq.l	#(1<<gestaltHasGPIaToDCDa)|\	;	GPIa connected to DCDa
@@ -6359,10 +6360,22 @@ ROMBusErrRecovery	EQU		$00008a6c			; recovery delay routine in ROM				<29>
 			cmp.l	SCSIHsk,d0					; was it a SCSI chip access ?
 			beq.s	@start						; if so, start processing the bus error
 
+			movem.l	d1/a4,-(sp)
+			move.l	SCSIGlobals,a4
+			move.l	SCSI2Base,d1
+			bz.s	@noScsi2
+			cmp.l	scsiGlobalRecord.hhsk5380_2(a4),d0
+			beq.s	@matches
+@noScsi2
+			movem.l	(sp)+,d1/a4
+
 			move.l	(sp)+,d0					; restore d0
 			move.l	OldBusErrVct(a6),-(sp)		; put old bus error handler addr on stack	<end>
 			rts									; jump to old handler, assuming it'll RTE	<29>
 
+@matches
+			movem.l	(sp)+,d1/a4
+
 @start
 
 			subq.w	#1,BusErrCount(a6)			; retry until we get tired
@@ -8047,6 +8060,18 @@ FixUpLooP	move.l		(A0)+, D1
 ;=========================================================================================
 
 
+;————————————————————————————————————————————————————————————————————————————
+; Distinguish LCII from the LC using ROM version
+;
+			cmp.b	#boxMacLC,BoxFlag
+			bne.s	@notLCII
+			move.l	RomBase,a0
+			cmp.b	#$19,ROMHeader.ROMRelease(a0)
+			bne.s	@notLCII
+			move.b	#boxMacLCII,BoxFlag
+@notLCII
+
+
 ;————————————————————————————————————————————————————————————————————————————	GGD <8.4>
 ;	Fix _StripAddress to not check the MMStartMode bit of MMFlags at runtime,
 ;	because the memory manager changes that bit when accessing ROM resources,
@@ -8090,7 +8115,11 @@ FixStripAddress
 			BTST.L	#hwCbPwrMgr,D0						; Do we have a PowerMgr?
 			BEQ.S	@DoneTimLC							; -> No.  This is not a Portable of any kind
 														; We're on a TERROR $67C ROM with a PwrMgr and no FPU.
+			BTST.B	#0,$50FB4000
+			BNZ.S	@jaws25
 			MOVE.B	#boxPowerBook140,boxFlag			; We're on a Tim LC.  Stuff the right boxFlag		<146>			
+			BRA.S	@DoneTimLC
+@jaws25		MOVE.B	#boxPowerBook145,boxFlag
 @DoneTimLC
 
 ;————————————————————————————————————————————————————————————————————————————	<130><131><8><9>
@@ -8148,98 +8177,6 @@ FixStripAddress
 @FixPMLoopEnd	MOVE.L		D2,(A0)+				; stash correct address, bump A0
 				DBRA		D0,@FixPMLoop			; and count down, including zero.	dvb <8.3> end
 
-;__________________________________________________________________________
-;__________________________________________________________________________
-
-FixBackSANE	MOVE.L	#'fpu ',D0			; Gestalt FPU selector
-			_Gestalt					; Do it
-			MOVE.L	A0,D0				; Do we have an FPU?
-			BEQ		@ReallyDone			; -> No, do nothing
-						
-			MOVE.L	ROMBase,A0				; Get ROM base			
-			CMPI.B	#TERRORminorVers,18(A0)	; Is this TERROR 067C ROM?
-			BEQ		@ReallyDone				; -> Yes, leave the ROM SANE enabled!
-			CMPI.B	#ZYDECOminorVers,18(A0)	; Is this Zydeco 067C ROM?
-			BEQ		@ReallyDone				; -> Yes, leave the ROM SANE enabled!
-			
-@DisableSANEinROM
-			MOVE.B	ResLoad,-(SP)			; Save current resLoad state
-			MOVE.W	CurMap,-(SP)			; Save Current Rsrc Map refNum
-			CLR.W	CurMap					; Make the System the current Map (CurMap = 0)
-			
-			SF		ResLoad					; Don't actually read the rsrc
-			CLR.L	-(SP)					; Result
-			MOVE.L	#'PACK',-(SP)			; Type
-			MOVE.W	#4,-(SP)				; Id 4
-			_Get1Resource			
-			MOVE.L	(SP)+,D0				; Did we get it?
-			BEQ		@Done					; -> No, PACK 4 is not on the disk.  Exit Now! (Use the ROM SANE)
-			MOVE.L	D0,-(SP)
-			_ReleaseResource				; Make the System SANE handle go away. (or we'll get it at the _RmveRsrc)
-			
-			SF		ResLoad					; Don't actually read the rsrc
-			CLR.L	-(SP)					; Result
-			MOVE.L	#'PACK',-(SP)			; Type
-			MOVE.W	#5,-(SP)				; Id 5
-			_Get1Resource			
-			MOVE.L	(SP)+,D0				; Did we get it?
-			BEQ		@Done					; -> No, PACK 5 is not on the disk.  Exit Now! (Use the ROM SANE)
-			MOVE.L	D0,-(SP)
-			_ReleaseResource				; Make the System SANE handle go away. (or we'll get it at the _RmveRsrc)
-			
-			ST		RomMapInsert			;  Put the ROM map in first
-			MOVE.W	#1,CurMap				; Make the ROM map current
-			
-			CLR.L	-(SP)					; Result
-			MOVE.L	#'PACK',-(SP)			; Type
-			MOVE.W	#4,-(SP)				; Id 4
-			_Get1Resource			
-			MOVE.L	(SP)+,D0				; Did we get it?
-			BEQ.S	@Try45					; -> No, try 4 five.
-			
-			MOVE.L	D0,-(SP)				; The Handle (save a copy of it)
-			MOVE.L	ROMMapHndl,-(SP)		; Save this
-			MOVE.L	#-1,ROMMapHndl			; To fool SetResAttr into letting use change ROM rsrc attrs
-			
-			MOVE.L	D0,-(SP)				; The Handle (push it. Push it good)
-			MOVE.W	#$50,-(SP)				; A good value (Unprotected)
-			_SetResAttrs
-			MOVE.L	(SP)+,ROMMapHndl
-
-			MOVE.W	#1,CurMap				; Set CurMap to the ROM rsrc map
-			ST		RomMapInsert			; Dont load the rsrc into memory						
-			_RmveResource
-
-@Try45		ST		RomMapInsert			;  Put the ROM map in first
-
-			CLR.L	-(SP)					; Result
-			MOVE.L	#'PACK',-(SP)			; Type
-			MOVE.W	#5,-(SP)				; Id 5
-			_Get1Resource			
-			MOVE.L	(SP)+,D0				; Did we get it?
-			BEQ.S	@Done					; -> No, exit
-			
-			MOVE.L	D0,-(SP)				; The Handle (save a copy of it)
-			MOVE.L	ROMMapHndl,-(SP)		; Save this
-			MOVE.L	#-1,ROMMapHndl			; To fool SetResAttr into letting use change ROM rsrc attrs
-
-			MOVE.L	D0,-(SP)				; The Handle (push it. Push it good)
-			MOVE.W	#$50,-(SP)				; A good value (Unprotected)
-			_SetResAttrs
-			MOVE.L	(SP)+,ROMMapHndl
-			
-			MOVE.W	#1,CurMap				; Set CurMap to the ROM rsrc map
-			ST		RomMapInsert			; Dont load the rsrc into memory						
-			_RmveResource
-
-@Done		MOVE.W	(SP)+,CurMap			; Restore the current res map
-			MOVE.B	(SP)+,resLoad			; Restore ResLoad
-@ReallyDone		
-;__________________________________________________________________________
-;__________________________________________________________________________
-
-
-
 ;____________________________________________________________________________		<2> RMP
 ;	This patch is used to fix a problem in the MPW Shell on Eclipse.  See above.
 
@@ -8694,6 +8631,11 @@ FixQDColors										;								<4.7>
 			CMP.B		#ClockEgret,D0					; Is bit 5 on?
 			BNE.S		@EndOfEgretOnly					; -> Nope, skip this install code
 
+			AND.L		#EgretFWMask,D0
+			BZ.S		@EndOfEgretOnly
+			CMP.L		#Cuda,D0
+			BGE.S		@EndOfEgretOnly
+
 ;----------------------------------------------------------------------------------------------------
 ; 	This patch bypasses the physical read of egret when reading the time. The time is automatically
 ;	updated in the background, therefore the low mem global always reflects the acurate time.
diff --git a/Patches/ProcessManagerSegmentTweaks.a b/Patches/ProcessManagerSegmentTweaks.a
--- a/Patches/ProcessManagerSegmentTweaks.a
+++ b/Patches/ProcessManagerSegmentTweaks.a
@@ -34,21 +34,11 @@ LoadProcessManagerSegmentsLowerInSysHeap	InstallProc	(Plus,SE,II,IIci,Portable)
 				_CurResFile						; Remember the current resource file
 				clr.w	-(sp)
 				_UseResFile						; Work on the System file
-				move.b	ResLoad,-(sp)			; Save current resource load state
 				
 				lea		ProcessManagerSegmentTable,a4	; Table of Process Manager segments to load low
 @loadLoop
 				move.w	(a4)+,d7				; Get the segment number
 				bz.s	@doneWithSegments		; Did ’em all
-				sf		ResLoad					; Don’t load in resources
-				subq	#8,sp					; Space for _SizeResource result too
-				move.l	#kProcessManagerSegmentType,-(sp)
-				move.w	d7,-(sp)
-				_Get1Resource
-				_SizeRsrc						; Find out how big it is
-				move.l	(sp)+,d0				; Get the size
-				_ResrvMem ,Sys					; Make some space low in the heap
-				st		ResLoad					; Load it in for real now
 				subq	#4,sp
 				move.l	#kProcessManagerSegmentType,-(sp)
 				move.w	d7,-(sp)
@@ -57,7 +47,6 @@ LoadProcessManagerSegmentsLowerInSysHeap	InstallProc	(Plus,SE,II,IIci,Portable)
 				bra.s	@loadLoop
 				
 @doneWithSegments
-				move.b	(sp)+,ResLoad			; Restore resource load state
 				_UseResFile						; The current resource file is on the stack
 				rts
 
@@ -66,5 +55,7 @@ ProcessManagerSegmentTable
 				dc.w	$BFB0					; KernelSeg
 				dc.w	$BFB2					; EPPCSeg
 				dc.w	0						; End of table
+
+
 				EndProc
 				End
\ No newline at end of file
diff --git a/Patches/VideoPatch.a b/Patches/VideoPatch.a
--- a/Patches/VideoPatch.a
+++ b/Patches/VideoPatch.a
@@ -474,14 +474,16 @@ ROMMinVer		Equ		$12								; Offset from ROMBase to RAM Major version word.
 				Beq.s	StartDAFB						;	then start doing DAFB stuff.
 				Cmp.b	#boxQuadra900,D0				; If this is an Eclipse,					<7>
 				Beq.s	StartDAFB						;	then start doing DAFB stuff.
-				Cmp.b	#boxZydeco,D0					; If this is a Zydeco (Eclipse 33),
+				Cmp.b	#boxQuadra950,D0				; If this is a Zydeco (Eclipse 33),
 				Beq.s	StartDAFB						;	then start doing DAFB stuff.
 				Bra		AllDone							; Otherwise, just go home.
 
 StartDAFB		
 				Move.l	A3,A0							; Get spBlock ptr into A0.
 				Clr.b	spSlot(A0)						; We only care about Slot $0.
+				Clr.b	spId(A0)
 				Clr.b	spExtDev(A0)					; (No external device.)
+				Clr.b	spTBMask(A0)
 				Move.w	#catDisplay,spCategory(A0)		; Look for:	Display,
 				Move.w	#typVideo,spCType(A0)			;  			Video,
 				Move.w	#drSwApple,spDrvrSW(A0)			;  			Apple,
@@ -970,6 +972,7 @@ StartJMFB
 				Move.b	D3,spSlot(A0)					; Set the slot number to search in.
 				Clr.b	spId(A0)						; Begin at id 0.
 				Clr.b	spExtDev(A0)					; No external device.
+				Clr.b	spTBMask(A0)
 				Move.w	#catDisplay,spCategory(A0)		; Look for:	Display,
 				Move.w	#typVideo,spCType(A0)			;  			Video,
 				Move.w	#drSwApple,spDrvrSW(A0)			;  			Apple,
diff --git a/ProcessMgr/DAHandler.a b/ProcessMgr/DAHandler.a
--- a/ProcessMgr/DAHandler.a
+++ b/ProcessMgr/DAHandler.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		 <5>	 9/29/92	DRF		Put back the END that got deleted in <4>
-;		 <4>	 9/25/92	DRF		Get rid of MyGestalt
 ;		 <2>	  1/3/91	fjs		(DFH) pass edit function keys to DAHandler
 ;		 <0>	 x/xx/86	PYG		New Today.
 ;
@@ -172,4 +170,22 @@ GSHSDone
 				
 				ENDPROC
 
+
+
+				SEG			'Init'
+
+;---------------------------------------------------------------------------------------
+; "MyGestalt", resurrected, because it survived through to 7.1.1
+
+MYGESTALT		PROC		EXPORT
+
+				MOVE.L		8(SP),D0
+				_Gestalt
+				MOVE.L		4(SP),A1
+				MOVE.L		A0,(A1)
+				MOVE.L		(SP)+,A0
+				LEA.L		8(SP),SP
+				MOVE.W		D0,(SP)
+				JMP			(A0)
+
 				END
diff --git a/ProcessMgr/DAHandler.c b/ProcessMgr/DAHandler.c
--- a/ProcessMgr/DAHandler.c
+++ b/ProcessMgr/DAHandler.c
@@ -9,8 +9,6 @@
 
 	Change History (most recent first):
 	 
-	  <SM18>	 7/21/93	joe		Back out <SM17>.
-		<16>	 9/25/92	DRF		Get rid of MyGestalt
 		<15>	 4/10/92	JSM		Undo revision 14, we fixed the problem someplace else.
 		<14>	  4/4/92	DTY		#1019369,<FM>: For each desk accessory, remember the current
 									keyboard state, and the keyboard state after the driver has been
@@ -70,7 +68,6 @@
 #include <osutils.h>
 #include <segload.h>
 #include <diskinit.h>
-#include <sound.h>
 #include <GestaltEqu.h>
 #include <Palettes.h>
 #include <Icons.h>
@@ -392,7 +389,7 @@ main(void)
 	// <12> Now that DAHandler is up and running, it’s Init and %A5Init segments can be
 	//		unloaded.
 	
-	UnloadSeg((Ptr) StartupCode);			// <12> Unload Init
+	UnloadSeg((Ptr) MyGestalt);				// <12> Unload Init
 	UnloadSeg((Ptr) _DataInit);				// <12> Unload %A5Init
 	
 	/* The event loop */
@@ -509,7 +506,7 @@ InitConfig(void)
 	Colorized = false;
 	Has32BitQD = false;
 	
-	if (Gestalt(gestaltQuickdrawVersion,&qdInfo) == noErr)
+	if (MyGestalt(gestaltQuickdrawVersion,&qdInfo) == noErr)
 		{
 		qdInfo &= 0xFFFF;
 		Colorized = (qdInfo >= gestalt8BitQD);
diff --git a/ProcessMgr/DeskMgrPatches.c b/ProcessMgr/DeskMgrPatches.c
--- a/ProcessMgr/DeskMgrPatches.c
+++ b/ProcessMgr/DeskMgrPatches.c
@@ -65,7 +65,6 @@
 #include <files.h>
 #include <segload.h>
 #include <devices.h>
-#include <sound.h>
 #include <MFPrivate.h>
 #include <MenuMgrPriv.h>
 #include <ResourceMgrPriv.h>
diff --git a/ProcessMgr/Eppc.c b/ProcessMgr/Eppc.c
--- a/ProcessMgr/Eppc.c
+++ b/ProcessMgr/Eppc.c
@@ -11,8 +11,6 @@
 	Change History (most recent first):
 	 
 		<26>	 5/29/92	DCL		Included Script.h. GetEnvirons moved for the New Inside Mac.
-		<25>	11/25/91	DTY		Add #include <MemoryMgrPriv.h> to get interface for MoveHLow in
-									its new home.
 		<24>	11/21/91	DTY		Rolling in the 7•Up version of findFreeSessionRecord that
 									allocates the session record low in the System Heap instead of
 									in the middle of the temporary heap. This is conditionalized for
@@ -206,7 +204,9 @@
 #include <Errors.h>
 #include <MFPrivate.h>
 #include <Memory.h>
-#include <MemoryMgrPriv.h>
+#pragma parameter MoveHLow(__A0)
+pascal void MoveHLow(Handle h)
+ = 0xA09D; 
 #include <PPCToolBox.h>
 #include <AppleEventsInternal.h>
 #include <Errors.h>
diff --git a/ProcessMgr/Glue.h b/ProcessMgr/Glue.h
--- a/ProcessMgr/Glue.h
+++ b/ProcessMgr/Glue.h
@@ -150,4 +150,6 @@ debugger(StringPtr message)
 /*	_Debugger
  */
  
+pascal OSErr MyGestalt(OSType selector,long *response);
+
 #endif __GLUE__
diff --git a/ProcessMgr/ProcessMgr.make.idump b/ProcessMgr/ProcessMgr.make.idump
new file mode 100644
--- /dev/null
+++ b/ProcessMgr/ProcessMgr.make.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/ProcessMgr/ProcessMgrMisc.a b/ProcessMgr/ProcessMgrMisc.a
--- a/ProcessMgr/ProcessMgrMisc.a
+++ b/ProcessMgr/ProcessMgrMisc.a
@@ -10,12 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<19>	11/25/92	DRF		Add a conditional patch inside a_hfsdispatch to save and restore
-;									A2 across calls the the real _HFSDispatch. This is a temporary
-;									fix until the PowerPC trap glue follows the proper register
-;									saving conventions. Code is conditionalized under “PsychicTV”
-;									and will be removed at the earliest possibility.
-;		<18>	 9/25/92	DRF		Get rid of MyGestalt, since inline glue exists
 ;		<17>	 3/30/92	DTY		#1025416,<DDG>: Add gestaltSkiaGlobalsSwitched to the list of
 ;									attributes for gestaltOSAttr.
 ;		<16>	11/25/91	DTY		Call GetParallelFCBFromRefNum in the _OpenRF patch to nail the
@@ -898,16 +892,7 @@ DoOldCall
 				lea		patchtraps, a5					; get patch array address
 				move.l	(a5,d2.w),a5					; get old routine
 				exg.l	a1,a5							; restore a5, a1 <- old trap
-
-	if	(PsychicTV) then
-				move.l	a2,-(sp)						; <19>
-	endif
 				jsr		(a1)							; call old trap
-
-	if	(PsychicTV) then
-				move.l	(sp)+,a2						; <19>
-	endif
-
 				move.l	(sp)+,MemTop					; restore memtop
 				rts										; and return to it
 
@@ -1759,4 +1744,21 @@ MNGSaveRegs		REG			d0-d1/a0-a2					; working registers
 		
 				ENDPROC
 
+
+				SEG			'INIT'
+
+;---------------------------------------------------------------------------------------
+; "MyGestalt", resurrected, because it survived through to 7.1.1
+
+MYGESTALT		PROC		EXPORT
+
+				MOVE.L		8(SP),D0
+				_Gestalt
+				MOVE.L		4(SP),A1
+				MOVE.L		A0,(A1)
+				MOVE.L		(SP)+,A0
+				LEA.L		8(SP),SP
+				MOVE.W		D0,(SP)
+				JMP			(A0)
+
 				END
diff --git a/ProcessMgr/Processes.c b/ProcessMgr/Processes.c
--- a/ProcessMgr/Processes.c
+++ b/ProcessMgr/Processes.c
@@ -742,7 +742,9 @@ CreateProcess(InternalLaunchPBPtr pParams, PEntryPtr pNewProc, PEntryPtr pLaunch
 	BlockMove(pCode0->jt, (Ptr)currenta5 + pCode0->jtoffset, pCode0->jtsize);
 
 	/* Now that things are set up, we can release segment 0 */
+#if PsychicTV
 	if (SAVESEGHANDLE != nil)
+#endif
 		ReleaseResource(SAVESEGHANDLE);
 
 	/* Try to set APPLLIMIT to ssize below current stack.  We get an error if this
diff --git a/ProcessMgr/Startup.c b/ProcessMgr/Startup.c
--- a/ProcessMgr/Startup.c
+++ b/ProcessMgr/Startup.c
@@ -9,9 +9,6 @@
 
 	Change History (most recent first):
 
-	  <SM28>	 7/21/93	joe		Back out <SM27>.
-		<27>	10/28/92	DTY		Use new Get/Set macros to access ExpandMem.
-		<26>	 9/25/92	DRF		Get rid of MyGestalt, since inline glue exists
 		<25>	 8/26/92	DTY		Change ModSquad’s funky conditional to use #ifdefs like everyone
 									else.
 		<24>	 8/26/92	DTY		Roll in latest changes for A/UX.
@@ -511,35 +508,35 @@ InitConfig(void)
 #endif HAS_AUX_PROCESSMGR
 
 	/* Check processor addressing mode */
-	if (Gestalt(gestaltAddressingModeAttr,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltAddressingModeAttr,&gestaltResult) == noErr)
 		In32BitMode = ((gestaltResult & (1 << gestalt32BitAddressing)) != 0);
 
 	/* Check QuickDraw version */
-	if (Gestalt(gestaltQuickdrawVersion,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltQuickdrawVersion,&gestaltResult) == noErr)
 		Colorized = ((gestaltResult & 0xFFFF) >= gestalt8BitQD);
 
 	/* Does this machine have an FPU? */
-	if (Gestalt(gestaltFPUType,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltFPUType,&gestaltResult) == noErr)
 		MachineHasFPU = (gestaltResult != gestaltNoFPU);
 
 	/* Does this machine have an older style keyboard (without an escape key)? */
-	if (Gestalt(gestaltKeyboardType,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltKeyboardType,&gestaltResult) == noErr)
 		MachineHasMacPlusKbd = (gestaltResult <= gestaltMacPlusKbd);
 
-	if (Gestalt(gestaltGraphicsVersion,&gestaltResult) == noErr)
+	if (MyGestalt(gestaltGraphicsVersion,&gestaltResult) == noErr)
 		skiaExists = true;
 	else
 		skiaExists = false;
 		
 #ifdef MODSQUAD
 	/* Check whether drag manager is installed. */
-	if (Gestalt(gestaltDragMgrVersion, &gestaltResult) == noErr)
+	if (MyGestalt(gestaltDragMgrVersion, &gestaltResult) == noErr)
 		gDragMgrIsAvailable = true;
 #endif
 
 #ifdef HAS_AUX_PROCESSMGR
 	/* Check whether we're running under AUX. */
-	if (Gestalt(gestaltAUXVersion, &gestaltResult) == noErr	&& AUX_EnableCoffLaunch())
+	if (MyGestalt(gestaltAUXVersion, &gestaltResult) == noErr	&& AUX_EnableCoffLaunch())
 		AUXIsPresent = true;
 #endif HAS_AUX_PROCESSMGR
 	}
diff --git a/ProcessMgr/Switch.a b/ProcessMgr/Switch.a
--- a/ProcessMgr/Switch.a
+++ b/ProcessMgr/Switch.a
@@ -9,17 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		 <8>	10/28/92	DTY		It turns out that going through the trap dispatcher is really
-;									expensive, so go back to calling the BlockMove routine directly.
-;									However, set up D1 with the BlockMoveData trap word so that the
-;									cache doesn’t get flushed.  Add a conditional compile so that
-;									_BlockMove is used when building PsychicTV, so the emulator can
-;									still catch BlockMove.
-;		 <7>	10/27/92	DTY		Call BlockMoveData through the dispatcher instead of calling the
-;									BlockMove routine directly.  This gets us two wins:  1)  If we
-;									run under Gary’s emulator, BlockMove is done natively.  2)  On
-;									68K machines, the cache won’t get flushed because we call
-;									BlockMoveData.
 ;		 <6>	 3/22/91	DFH		csd,#85216: Don’t disable interrupts while neutralizing VBL
 ;									tasks, because it leaves interrupts off too long. Instead, set
 ;									the inVBL bit to keep the vertical retrace code from messing
@@ -264,7 +253,7 @@ saveInfo
 				movea.l	saveArea(a1),a1					; get the handle
 				movea.l	(a1),a1							; (destination) get pointer heap block
 				movea.l	sp,a0							; (source) get pointer to stacked info
-				_BlockMoveData							; copy the data
+				_BlockMove								; copy the data
 
 ; cleanup up and leave
 leaveNow
@@ -287,8 +276,8 @@ dummyvbl		PROC	EXPORT
 ; save_lmemtab.  Copy the switchable lomem into a safe area.
 save_lmemtab	PROC	EXPORT
 				IMPORT	(switchTabPtr, blockTrapAddr):DATA
-SaveRegs		REG		a2-a4/d1-d2
-SaveRegSize		EQU		5*4
+SaveRegs		REG		a2-a4/d2
+SaveRegSize		EQU		4*4
 
 				movem.l	SaveRegs,-(sp)					; save work registers
 				move.l	SaveRegSize+4(sp),a4			; get pointer to PCB storage
@@ -339,21 +328,11 @@ SaveOneLoop
 				bra.s	SaveAllLoop						; now get next entry
 
 ; call _BlockMove, since it's faster for larger chunks
-;
-; <8> Going through the trap dispatcher is more expensive than I thought.  Go back
-;	to calling the BlockMove routine directly.  However, set up D1 so that the caches
-;	still don’t get flushed.  We still want to call the trap for PsychicTV however, so
-;	that the emulator can do it’s native BlockMove.
 
 UseBlockMove		
 				move.l	a4,a1							; a1 = destination
 				add.l	d0,a4							; update our storage address
-	if not(PsychicTV) then
-				move.w	#$A22E,d1						; <8>
 				jsr		(a3)
-	else
-				_BlockMove								; <8>
-	endif
 				
 				bra.s	SaveAllLoop						; now get next entry
 
@@ -368,8 +347,8 @@ AllSaved
 ; restore_lmemtab.  Copy the saved switchable lomem back into lomem.
 restore_lmemtab	PROC	EXPORT
 				IMPORT	(switchTabPtr, blockTrapAddr):DATA
-SaveRegs		REG		a2-a4/d1-d2
-SaveRegSize		EQU		5*4
+SaveRegs		REG		a2-a4/d2
+SaveRegSize		EQU		4*4
 
 				movem.l	SaveRegs,-(sp)					; save work registers
 				move.l	SaveRegSize+4(sp),a4			; get pointer to PCB storage
@@ -419,22 +398,11 @@ RestoreOneLoop
 				bra.s	RestoreAllLoop					; now get next entry
 		
 ; call _BlockMove, since it's faster for larger chunks
-;
-; <8> Going through the trap dispatcher is more expensive than I thought.  Go back
-;	to calling the BlockMove routine directly.  However, set up D1 so that the caches
-;	still don’t get flushed.  We still want to call the trap for PsychicTV however, so
-;	that the emulator can do it’s native BlockMove.
-;
 
 UseBlockMove		
 				move.l	a4,a0							; setup source pointer for blockmove
 				add		d0,a4							; and increment pointer by count
-	if not(PsychicTV) then
-				move.w	#$A22E,d1						; <8>
 				jsr		(a3)
-	else
-				_BlockMove								; <8>
-	endif
 				
 				bra.s	RestoreAllLoop					; now get next entry
 		
diff --git a/ProcessMgr/Switch.c b/ProcessMgr/Switch.c
--- a/ProcessMgr/Switch.c
+++ b/ProcessMgr/Switch.c
@@ -10,7 +10,6 @@
 	Change History (most recent first):
 	 
 		<22>	10/28/92	DTY		Use new Get/Set macros to access ExpandMem.
-		<21>	10/27/92	DTY		Change BlockMoves to BlockMoveData.
 		<20>	 9/11/92	DRF		Take out “while(FSBUSY);” in “TheFuture” to allow for faster
 									switching.
 		<19>	 8/26/92	DTY		Roll in latest changes for A/UX.
@@ -374,7 +373,7 @@ save_lomem(PEntryPtr pp)
 	pc->appllimit = APPLLIMIT;
 	pc->applzone = APPLZONE;
 	pc->currenta5 = (unsigned long)CURRENTA5;
-	BlockMoveData(CURAPNAME, &pc->curapname, *((unsigned char *)CURAPNAME) + 1);
+	BlockMove(CURAPNAME, &pc->curapname, *((unsigned char *)CURAPNAME) + 1);
 	pc->curlayer = GetCurLayer();
 	pc->topmaphandle = TOPMAPHANDLE;
 	pc->curmap = CURMAP;
@@ -439,7 +438,7 @@ restore_lomem(PEntryPtr pp, Boolean shouldRestoreVolatile)
 	 */
 	APPLLIMIT = pc->appllimit;
 	CURRENTA5 = pc->currenta5;
-	BlockMoveData(&pc->curapname, CURAPNAME, Length(&(pc->curapname)) + 1);
+	BlockMove(&pc->curapname, CURAPNAME, Length(&(pc->curapname)) + 1);
 	SetCurLayer(pc->curlayer);
 	TOPMAPHANDLE = pc->topmaphandle;
 	CURMAP = pc->curmap;
diff --git a/ProcessMgr/WindowMgrPatches.c b/ProcessMgr/WindowMgrPatches.c
--- a/ProcessMgr/WindowMgrPatches.c
+++ b/ProcessMgr/WindowMgrPatches.c
@@ -9,11 +9,6 @@
 
 	Change History (most recent first):
 
-		 <7>	11/15/92	JDR		Changed QuickDraw.h to not use the dangerous pattern, which
-									defines a pattern as a struct. This code was calling BlockMove
-									to copy the 8 byte pattern, but patterns are structs so Pattern
-									= Pattern works fine. I fixed the includes a bit too, and the
-									dependencies were wrong by the way so I fixed them as well.
 		 <6>	 5/19/92	YK		#1030028: Remove <4> and <5> since SWM is not an application
 									now.    Roll back to <3>.
 		 <5>	 1/14/92	YK		Added checking code for TSM. Removed the include statement that
@@ -26,6 +21,7 @@
 
 */
 
+#define dangerousPattern
 #include <QuickDraw.h>
 #include <Windows.h>
 #include <Resources.h>
@@ -71,7 +67,7 @@ c_initwindows(void)
 		DSWNDUPDATE |= ((char)0x80);
 
 		SetPort(WMGRPORT);
-		DESKPATTERN = **GetPattern(deskPatID);
+		BlockMove(*GetPattern(deskPatID), &DESKPATTERN, sizeof(Pattern));
 		ShowCursor();
 
 		olda5 = ProcessMgrA5SimpleSetup();
diff --git a/QuickDraw/BitBlt.a b/QuickDraw/BitBlt.a
--- a/QuickDraw/BitBlt.a
+++ b/QuickDraw/BitBlt.a
@@ -10,14 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	 12/2/92	kc		Roll in CopyBits changes from QuickDrawPatches.a in Reality
-;	   <R24>	 10/2/92	SAH		Fixed a word alignment bug in the fast bSetup0 and bSetup8
-;									patches (word alignment would cause the Move16 code to fail).
-;									Also added a check in the bSetup8 patch to make sure that the
-;									left edge quadlong alignment would remain constant across
-;									scanlines.
-;	   <R23>	 10/1/92	SAH		Brought in fast bSetup8 patch for 040 machines that uses
-;									Move16's.
 ;	   <R20>	 4/10/92	SAH		Moved in the working fast bSetup0 patch for 68040 machines from
 ;									QDIIciPatchROM.a.
 ;	   <SM4>	 7/30/92	chp		Moved a short branch inside the conditional generated by <SM3>
@@ -1045,7 +1037,7 @@ LLast0	MOVE.L	D5,D1			;copy last mask
 ;-------------------------------------------------------
 bSETUP0
 
-OFFSET		EQU		38
+OFFSET		EQU		36
 
 		MOVE	SRCBUMP(A6),D6		;get srcwid into a register
 		MOVE	A3,D7				;put dstwid into a more useful register
@@ -1059,18 +1051,6 @@ OFFSET		EQU		38
 		CMP		#8,D2				;are at least 8 longs being moved?
 		BLT.S	@normal				;no, use normal case
 
-	; <02OCT92 SAH>		<24>
-	; we need to make sure that everything is long aligned. If srcPtr, dstPtr, srcWid or dstWid
-	; are word aligned, we need to go slow...
-
-		move.w	a4,d0				;get copy of src address				<02OCT92 SAH>		<24>
-		move.w	a5,d3				;get copy of dst address				<02OCT92 SAH>		<24>
-		or.w	d3,d0				;or in with src address					<02OCT92 SAH>		<24>
-		or.w	d6,d0				;or in srcWid							<02OCT92 SAH>		<24>
-		or.w	d7,d0				;or in dstWid							<02OCT92 SAH>		<24>
-		and.w	#3,d0				;and all four with long align mask		<02OCT92 SAH>		<24>
-		bne.s	@normal				;if any one is word aligned, go slow	<02OCT92 SAH>		<24>
-
 		MOVE	D2,D3				;are srcwid and dstwid both quadlong multiples?
 		LSL		#2,D3				;	((srcwid + (longs*4)) | (dstwid + (longs*4))) & 0x000F == 0)
 		MOVE	D6,D0
@@ -1154,7 +1134,6 @@ OFFSET		EQU		38
 		SUBQ.L	#1,D5				;++rightmask
 		MOVE.L	HEIGHT(A6),D1		;(put height into high word)
 		MOVE	D3,D1				;(set up initial quadblocks count)
-		nop							;finish any write in pipeline (may not need this one)
 		JMP		(A0)
 
 		MACRO						;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
@@ -1170,14 +1149,12 @@ OFFSET		EQU		38
 		AND.L	D4,D0				;splice src and dst together through leftmask
 		EOR.L	D2,D0				;
 		MOVE.L	D0,(A5)+			;save result to dst
-		nop							;finish any write in pipeline
 		JMP		(A1)				;go copy partial or full quadlong blocks
 
 		MOVE.L	(A4)+,(A5)+			;copy partial left quadlong block
 		MOVE.L	(A4)+,(A5)+
 		MOVE.L	(A4)+,(A5)+
-@left	nop							;finish any write in pipeline
-		JMP		(A2)				;go copy quadlong blocks
+@left	JMP		(A2)				;go copy quadlong blocks
 
 @mv256	myMOVE16			;MOVE16	(A4)+,(A5)+			;copy 32 longs
 		myMOVE16			;MOVE16	(A4)+,(A5)+
@@ -1225,7 +1202,6 @@ OFFSET		EQU		38
 		SUBQ	#1,D1				;decrement linecount
 		BEQ		GoHome				;leave if zero
 		SWAP	D1					;swap linecount out of low word
-		nop							;finish any write in pipeline
 		JMP		(A0)				;go do another line
 		
 		MOVE.L	(A4)+,(A5)+			;copy partial right quadlong block
@@ -1238,7 +1214,6 @@ OFFSET		EQU		38
 		SUBQ	#1,D1				;decrement linecount
 		BEQ.S	GoHome				;leave if zero
 		SWAP	D1					;swap linecount out of low word
-		nop							;finish any write in pipeline
 		JMP		(A0)				;go do another line
 
 		IF @right - @rmask - OFFSET THEN
@@ -1766,42 +1741,6 @@ bSETUP8		TST.B	alphaMode(A6)			;drawing in alpha mode?
 ; <13>	End of alpha channel changes
 
 @bSETUP8
-;
-;	<02OCT92 SAH>		<24>
-;	We first need to check if we can go fast. There are several conditions for this:
-;	1. At least 16 longs are being moved (otherwise slow case is faster)
-;	2. The destination address is long aligned (we cannot handle word aligned addresses).
-;	3. hBump is a long multiple (same reason as 3).
-;	4. The dst maintains the same quadlong phase across all scanlines
-;	5. The pattern is constant.
-;
-
-			cmp.w	#16,d2			; must have at least 16 to make fast case worthwhile (cond 1)
-			blt.s	@slowCase		; less, so go slow
-			
-			cmp.b	#cpu68040,cpuFlag	;is this an '040 or greater machine?
-			blt.s	@slowCase		; less, so go slow
-	
-			move.w	a5,d0			; get copy of dst address (cond 2 and 3)			<02OCT92 SAH>		<24>
-			move.w	a3,d3			; get copy of hBump									<02OCT92 SAH>		<24>
-			or.w	d3,d0			; or it in											<02OCT92 SAH>		<24>
-			and.w	#3,d0			; check if hBump and dst address are long aligned	<02OCT92 SAH>		<24>
-			bne.s	@slowCase		; either one is word aligned, so go slow			<02OCT92 SAH>		<24>
-			
-			move.w	a3,d3			; get a copy of the hBump (cond 4)					<02OCT92 SAH>		<24>
-			move.w	d2,d0			; get the number of longs to write					<02OCT92 SAH>		<24>
-			addq.w	#1,d0			; make it a one based count							<02OCT92 SAH>		<24>
-			lsl.w	#2,d0			; make it bytes										<02OCT92 SAH>		<24>
-			add.w	d0,d3			; add the number of bytes to write					<02OCT92 SAH>		<24>
-			and.w	#$f,d3			; is the quadlong phase the same?					<02OCT92 SAH>		<24>
-			bne.s	@slowCase		; no, so go slow									<02OCT92 SAH>		<24>
-
-			move.l	expat(a6),a0	; get start of expanded pattern (cond 5)
-			move.l	(a0),d4			; get first pattern long (d4 not used yet)
-			moveq	#15,d0			; get count
-@0			cmp.l	(a0)+,d4		; compare
-			dbne	d0,@0			; continue if still equal
-			beq		fastBSETUP8		; if == 0, then pattern is solid and we can go fast
 			
 @slowCase	move.w	d2,d3			; get count of longwords to move
 			move.l	d1,d4			; get copy of firstMask
@@ -1879,126 +1818,7 @@ bSETUP8		TST.B	alphaMode(A6)			;drawing in alpha mode?
 			add.w	d7,d7			; shift the pattern index
 			dbeq	d2,@rowLoop		; loop through all source rows
 			dbne	d2,@resetPat	; reset pattern and loop
-			bra.s	GoHome			; then quit
-
-;
-;	<25SEP92 SAH> Fast pattern case for constant patterns. Can only be installed on 040
-;	machines when VM is off.
-;
-;-------------------------------------------------------
-;		a0 = left block		d0 = scratch
-;		a1 = middle block	d1 = scratch
-;		a2 = right block	d2 = scratch
-;		a3 = middle src		d3 = blockCount
-;		a4 = hBump			d4 = firstMask
-;		a5 = dstPtr			d5 = lastMask
-;		a6 = locals			d6 = pattern data
-;		a7 = sp				d7 = stack offset / rowCount
-;-------------------------------------------------------
-			
-
-; macro for MOVE16	(A3)+,(A5)+	
-		MACRO						;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
-		aMOVE16						;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
-		DC.L $F623D000				;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
-		ENDM						;*** REMOVE WHEN ASSEMBLER KNOWS ABOUT MOVE16
-
-fastBSETUP8	move.w	a3,a4			; put hBump in more consistant register
-			move.w	d2,d3			; get count of longwords to move
-			subq.w	#1,d3			; make one based count of number of middle longs
-			move.l	d1,d4			; get copy of firstMask
-			movea.l	expat(a6),a3	; get ptr to pattern table
-			move.l	(a3),d6			; get source long from pattern
-		
-		; find offset for left edge alignment
-			moveq	#0,d2			; init left count to zero
-			lea		@left,a0		; get end of left edge table
-			moveq	#4,d0			; figure out the number of left longs 4 - ((a5 + 4) & 0xf)
-			add.w	a5,d0			; (a5 + 4)
-			and.w	#$f,d0			; & 0xf
-			lsr.w	#2,d0			; convert to longs
-			beq.s	@leftAligned	; left is already aligned
-			moveq	#4,d1			;
-			sub.w	d0,d1			; 4 - ...
-			sub.w	d1,d3			; subtract the longs we do on the left edge
-			neg.w	d1				; we want to look backwards
-			lea		(a0,d1*2),a0	; get offset
-@leftAligned
-		
-		; find offset for right edge alignment
-			lea		@right,a2		; get end of right edge table
-			moveq	#3,d2			; get a mask for right edge count
-			and.w	d3,d2			; get the odd longs
-			neg.w	d2				; offset backwards
-			lea		(a2,d2.w*2),a2	; get start of blit
-		
-		; now figure out how much to move in the middle
-			lea		@blockLoopEnd,a1	; assume we have nothing to do
-			lsr.w	#2,d3			; each move16 moves 4 longs
-			moveq	#$3,d0			; get mask for first time through (each loop does 4 move16's)
-			and.w	d3,d0			; and find the number to do
-			neg.w	d0				; negate the count
-			lea		(a1,d0.w*4),a1	; offset back into table
-			lsr.w	#2,d3			; convert remaining longs to groups of four
-		
-		; now create our stack buffer for move16
-			move.w	sp,d0			; get copy of stack
-			and.w	#$f,d0			; get quadlong mask
-			add.w	#64,d0			; add 64 bytes for base table
-			move.w	d0,d7			; save how much we subtracted...
-			swap	d7				;	 in high word of d7
-			sub.w	d0,sp			; subtract room on stack
-			moveq	#7,d0			; we want to write 16 longs (we do two at a time)
-			move.l	sp,a3			; get start of table
-@0			move.l	d6,(a3)+		; fill table
-			move.l	d6,(a3)+		; fill table
-			dbra	d0,@0
-			
-			move.w	Height(a6),d7	; get row count
-			subq.w	#1,d7			; zero based for DBRA
-
-@rowLoop	move.w	d3,d2			; setup block loop counter (for move16)
-			move.l	sp,a3			; restore block base
-			move.l	(a5),d1			; get a long of dst
-			move.l	d6,d0			; get a long of src
-			eor.l	d1,d0			; 
-			and.l	d4,d0			; mask first long
-			eor.l	d1,d0			;
-			move.l	d0,(a5)+		; put result to dest
-			jmp		(a0)			; jumpt to start of left edge
-			
-			move.l	d6,(a5)+		; long 1
-			move.l	d6,(a5)+		; long 2
-			move.l	d6,(a5)+		; long 3
-@left		nop						; clear pipeline
-			jmp		(a1)			; jump into middle block
-			
-@blockLoop	aMOVE16		;	move16	(a3)+,(a5)+		; move 16 longs
-			aMOVE16		;	move16	(a3)+,(a5)+		; move 12 longs
-			aMOVE16		;	move16	(a3)+,(a5)+		; move 8 longs
-			aMOVE16		;	move16	(a3)+,(a5)+		; move 4 longs
-@blockLoopEnd
-			move.l	sp,a3			; restore block base
-			dbra	d2,@blockLoop	; move remaining blocks of 16 longs
-
-			jmp		(a2)			; jump into right edge block
-			
-			move.l	d6,(a5)+		; long 1
-			move.l	d6,(a5)+		; long 2
-			move.l	d6,(a5)+		; long 3
-@right			
-			move.l	d6,d0			; get a long of src
-			move.l	(a5),d1			; get a long of dst
-			eor.l	d1,d0			;
-			and.l	d5,d0			; splice with mask
-			eor.l	d1,d0			;
-			move.l	d0,(a5)+		; put result to dest
-
-			adda.w	a4,a5			; update dest address
-			dbra	d7,@rowLoop		; loop through all source rows
-			swap	d7				; get stack offset back
-			add.w	d7,sp			; restore stack
-			rts						; then quit
+			bra		GoHome			; then quit
 
 	ALIGN	Alignment
 
@@ -4334,11 +4154,8 @@ bTransparent
 ; rolled in SMC’s changes from QDciPatchROM.a <sm 6/9/92>stb
 
 		lea		@RealbTransparent1,a1		;										<26SEP90 SMC> <10>
-		tst.l	(sp)			;is bump amount negative?							<14AUG90 KON>
-		bmi.s	@1				;													<14AUG90 KON>
-		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?						<08Oct90 SMC> <72>
-		BEQ		bTransparent8				;										<08Oct90 SMC> <72>
-		BRA.S	@RealbTransparent1			;										<08Oct90 SMC> <72>
+		tst.w	(sp)			;is bump amount negative?							<14AUG90 KON>
+		bpl.s	@RealbTransparent1;													<14AUG90 KON>
 	@1:	sub.l	(SP),D6			;bump src right OR left by 1 pixel first time only	<14AUG90 KON>
 		lea		@RealbTransparent,a1	;remember correct entry point for remaining scans	<14AUG90 KON>
 @RealbTransparent
diff --git a/QuickDraw/BitMaps.a b/QuickDraw/BitMaps.a
--- a/QuickDraw/BitMaps.a
+++ b/QuickDraw/BitMaps.a
@@ -119,7 +119,7 @@ StdBits PROC 	EXPORT
 
 		EXPORT	BitsDevLoop
 		IMPORT	PutPicByte,PutPicWord,PutPicRgn,PutPicData,PutPicOp,SectRect,CopyMask
-		IMPORT	StretchBits,PackBits,BitsToPix,PutPicTable,PutPMData,PortToMap,BitsToMap,SHFTTBL
+		IMPORT	StretchBits,BitsToPix,PutPicTable,PutPMData,PortToMap,BitsToMap,SHFTTBL
 
 	ELSE
 	
diff --git a/QuickDraw/CCrsrCore.a b/QuickDraw/CCrsrCore.a
--- a/QuickDraw/CCrsrCore.a
+++ b/QuickDraw/CCrsrCore.a
@@ -12,9 +12,6 @@
 ;
 ;	   <SM6>	 9/12/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM5>	  2/4/93	CSS		Update from Horror:
-;		<H3>	 7/13/92	djw		<GED> Overpatched DrawCursor, EraseCursor and SetCrsrData,
-;									vectorizing them to allow access later.
 ;	   <SM4>	 6/11/92	stb		<sm 6/9/92>stb Add comments from QDciPatchROM.a to ShowCursor,
 ;									SetCCursor
 ;	   <SM3>	 5/16/92	kc		Add forRom conditionals around last change.
@@ -549,19 +546,18 @@ HideCursor
 		;Fall into EraseCursor
 
 ;________________________________________________________________________
-;	<SM5> CSS Horror vectorized this vector.  We are supporting this to be
-;   compatible with Horror.
-;	EraseCursor calls a vectorized version of the routine via lomem.
-;	EraseCursor is vectorized to gain access to low level cursor blit routines.
-;	(NOTE: Vector is initialized in StartInit.a to routine named VEraseCursor.)
-
 ; EraseCursor is much like HideCursor, but doesn't decrement the CrsrState	<dvb 19sep88>
 
+			IMPORT	UNBLITCURSOR
 EraseCursor
-		move.l	EraseCrsrVector,-(sp)			;<SM5> CSS
-		rts										;jump to the vectored routine <SM5> CSS
-DoneHid	CLR.B	CRSRBUSY						;CHANGE COMPLETE
-		RTS
+			MOVE.B	#1,CRSRBUSY 					;MARK CHANGE IN PROGRESS
+			TST.B	CRSRVIS 						;IS CURSOR VISIBLE?
+			BEQ.S	DoneHid							;NO, DON'T TRY TO REMOVE IT
+			
+			BSR		UNBLITCURSOR					;Zap Pixels
+
+DoneHid		CLR.B	CRSRBUSY						;CHANGE COMPLETE
+			RTS
 
 
 ;_______________________________________________________________________
@@ -607,20 +603,24 @@ ShowCursor
 		;fall into DrawCursor
 
 ;________________________________________________________________________
-;	<SM5> CSS Horror vectorized this vector.  We are supporting this to be
-;   compatible with Horror.
-;   DrawCursor calls a vectorized version of the routine via lomem.
-;	DrawCursor is vectorized to gain access to low level cursor blit routines.
-;	(NOTE: Vector is initialized in StartInit.a to routine named VDrawCursor.)
-
 ; DrawCursor is much like ShowCursor, but doesn't increment the CrsrState	<dvb 19sep88>
 
+			IMPORT	BLITCURSOR
 DrawCursor
-		move.l	DrawCrsrVector,-(sp)			; <SM5> CSS
-		rts										;jump to the vectored routine <SM5> CSS
+			MOVE.B	#1,CRSRBUSY 					;MARK CHANGE IN PROGRESS
+		
+			TST		CRSRSTATE
+			BMI.S	DoneSho							;QUIT IF STILL HIDDEN
+			CLR 	CRSRSTATE						;DON'T LET CRSRSTATE GET > 0
+			TST.B	CRSRVIS 						;IS CURSOR ALREADY VISIBLE?
+			BNE.S	DoneSho							;YES, DON'T TRY TO REDRAW
+			TST.B	CrsrObscure						;Skip if obscured
+			BNE.S	DoneSho
 
-DoneSho	CLR.B	CRSRBUSY						;CHANGE COMPLETE
-		RTS
+			BSR		BLITCURSOR						;Do the real work: put pixels up
+
+DoneSho		CLR.B	CRSRBUSY						;CHANGE COMPLETE
+			RTS
 
 ;_______________________________________________________________________
 ;
@@ -908,8 +908,6 @@ SetCrsrData		PROC	EXPORT
 ;  This routine is called to initialize low-memory locations
 ;  to the necessary values for the grafDevice pointer in A1.
 ;
-				IMPORT	SetCrsrDelay			;<SM5> CSS
-				bsr.l	SetCrsrDelay			;<SM5> CSS
 				MOVE.L	CRSRPTR,A0				;get handle to cursor data
 				MOVE.L	(A0),A0					;get pointer to cursor data
 
diff --git a/QuickDraw/CQD.a b/QuickDraw/CQD.a
--- a/QuickDraw/CQD.a
+++ b/QuickDraw/CQD.a
@@ -7,12 +7,8 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	  2/4/93	CSS		Horror rollin: include CrsrDevEqu.a to get :DrawCrsrVector and
-;									EraseCrsrVector.
 ;	   <SM4>	10/28/92	SWC		Replaced obsolete INCLUDEd filenames with their replacements.
 ;	   <SM3>	 6/12/92	stb		move Arith8Blt.a a bit closer to BitBlt.a
-;	   <SM2>	 4/16/92	PN		Include the SysPrivateEqu (SplineFont globals) files for ROM
-;									build
 ;		 <9>	 7/10/91	JSM		Remove obsolete SysVers conditional.
 ;		 <8>	 6/12/91	LN		Removed #includes for private interfaces from public interfaces.
 ;									Changed #include 'HardwareEqu.a' to 'HardwarePrivateEqu.a'
@@ -89,7 +85,6 @@ CLUTBusy		EQU		13				; bit number in CTFlags (TransIndex) to
 			INCLUDE		'QDHooks.a'
 			INCLUDE		'FontPrivate.a'
 
-			INCLUDE		'CrsrDevEqu.a'	; 	<SM5> CSS
 			INCLUDE 	'ColorEqu.a'
 			INCLUDE		'SlotMgrEqu.a'
 			INCLUDE		'ROMEqu.a'
@@ -97,7 +92,6 @@ CLUTBusy		EQU		13				; bit number in CTFlags (TransIndex) to
 			INCLUDE		'HardwarePrivateEqu.a'
 			INCLUDE		'Palettes.a'
 			INCLUDE		'PalettePriv.a'
-			INCLUDE 	'SysPrivateEqu.a' ; <PN>
           PRINT     NOGEN,NOMDIR
           PRINT     ON
 
diff --git a/QuickDraw/CheckDevicesINIT.a b/QuickDraw/CheckDevicesINIT.a
--- a/QuickDraw/CheckDevicesINIT.a
+++ b/QuickDraw/CheckDevicesINIT.a
@@ -10,8 +10,6 @@
 ;	Change History (most recent first):
 ;
 ;	  <SM10>	09-23-93	jmp		Quit doing <SM8> below when the Display Manager is around.
-;	   <SM9>	 9/1/93		SKH		Fixed a bug with fixed CLUT devices (ie: DBLite).  SetEntries can not be called for
-;									direct or fixed devices
 ;	   <SM8>	04-07-93	jmp		Cleaned up the invalid 'scrn' resource code so that it actually
 ;									removes the invalid 'scrn' resource.  This makes family modes
 ;									work better.  However, this is really only a stop-gap measure
@@ -19,13 +17,11 @@
 ;	   <SM7>	11-05-92	jmp		Changed the TPD, FPD, and HR video driver patch mechanism so
 ;									that it now runs correctly from ROM (it was originally written
 ;									to work in RAM).
-;	   <SM6>	10/28/92	SWC		Changed SlotEqu.a->Slots.a and VideoEqu.a->Video.a.
 ;	   <SM5>	10/28/92	PN		# 1045532 Call QDSecondaryInit from the BootCode3.a to set up
 ;									the color and gdevice environment also fix up the code to run
 ;									from ROM and check for SuperMario ROM ID. Mike Puckett will come
 ;									back to this file and clean it up (he promised !) Also, take out
 ;									the system INIT stuff and the 950 patch.
-;		<SM4>	10/27/92	CSS		Changed a short branch to a word branch.
 ;		<SM3>	7/16/92		CSS		Update from Reality:
 ;									<27> 7/13/92 DTY	#1035553 <csd>: The Quadra950VideoPatch assumes that the driver
 ;														is RAM based, thus it treats the dCtlDriver field as a handle.
@@ -252,8 +248,8 @@ SetDevEntries
 			Move.l	A2,-(Sp)				; Storage for remembering gDevice.
 			
 			Move.l	(A0),A2					; gDevice Handle to gDevice Ptr.
-			Cmp.w	#clutType,gdType(A2)	; If the gDevice is direct or fixed (SKH), <SM9>
-			Bne.s	@sdeExit				;	then do nothing.
+			Cmp.w	#directType,gdType(A2)	; If the gDevice is direct or fixed
+			Beq.s	@sdeExit				;	then do nothing.
 			
 			Cmp.l	#-1,A1					; If A1 == -1, then use the
 			Beq.s	@usePMap				; 	gDevice’s PixMap.
@@ -339,53 +335,16 @@ CheckDevices								; <19>: Moved label from within if-endif to embed utility
 ;	the comments on the NoScrn code below).
 ;
 GetScrn
+			TST.B	scrnInval
+			BEQ.S	NoScrn
+
 			CLR.L	-(SP)					; make room for function result
 			MOVE.L	#'scrn',-(SP)			; push desired resource type
 			CLR		-(SP)					; resource ID = 0
 			_GetResource					; get the resource
 			MOVE.L	(SP)+,D0				; get the resource handle
-			Beq.s	NoScrn					; if nil, do the no 'scrn' code
+			BNE.S	GotScrn					; if nil, do the no 'scrn' code
 			
-; ••• 2nd INIT •••
-;
-; Test the scrnInval low-mem to make sure the screen resource is valid. (Note:  scrnInval
-;	will generally be cleared by the video card’s primaryInit IF the information in
-;	pRAM doesn’t match the current set up).  This is ALSO a case where we need to
-;	make a SetEntries call so the screen colors don’t change on the the first SetEntries
-;	and/or SetGamma call.
-;
-ChkScrn		
-			Tst.b	scrnInval				; If the 'scrn' resource is not invalid,
-			Bne.s	GotScrn					;	then just go on.
-						
-			Move.l	D0,A4					; Save the 'scrn' resource handle.
-			
-			Move.l	#gestaltDisplayMgrAttr,D0 ; We need to know if the Display Manager is around.
-			_Gestalt						; Ask, and ye shall receive.
-			Bne.s	@NoDM					; Oops, got an error.
-			Move.l	A0,D0					; Get the result into D0.
-			Btst	#gestaltDisplayMgrPresent,D0 ; If the Display Manager is around, then
-			Bne.s	NoScrn					; don’t dispose of the 'scrn' resource so
-@NoDM										; so that the Display Manager can deal with it.
-			
-			Clr.w	-(Sp)					; Make room for resFile refNum.
-			Move.l	A4,-(Sp)				; Push 'scrn' resource handle for resFile.
-			_HomeResFile					; Get refNum.
-			
-			Move.l	A4,-(Sp)				; Push 'scrn' resource handle for remove.
-			_RmveResource					; Try to remove it.
-			Tst.w	ResErr					; If everything is okay, then
-			Beq.s	@DisposeIt				;	just go on.
-			
-			Tst.w	(Sp)+					; Clean up the stack.
-			Move.l	A4,D0					; Get 'scrn' resource handle back into D0.
-			Bra.s	GotScrn					; And we’re screwed.
-			
-@DisposeIt	Movea.l	A4,A0					; Get 'scrn' resource handle into A0.
-			_DisposHandle					; Dispose it.
-			
-			_UpdateResFile					; Update the 'scrn's resFile lest we die later.
-
 ; If a 'scrn' resource is NOT around we’ll get here.  The only thing we want to do at this
 ;	point is to call SetDevEntries on the boot device so that the screen will not change colors
 ;	after a SetEntries/SetGamma call is made later.
@@ -724,8 +683,8 @@ ChkTbl
 			MOVE.L	(A0),A0					; get pixmap ptr
 			MOVE.W	pmPixelSize(A0),D0		; get depth
 
-			CMP		#clutType,gdType(A1)	; is it a direct/fixed (SKH) device? <SM9>
-			BNE  	SetGRect				; if so, then do nothing <19>:s <SM4> CSS
+			CMP		#directType,gdType(A1)	; is it a direct/fixed device?
+			BEQ.S 	SetGRect				; if so, then do nothing <19>:s
 
 			BTST	#gdDevType,gdFlags+1(A1)	; is it color or monochrome mode?
 			BNE.S	@ClrMode				; if set, then this is color
@@ -1017,7 +976,7 @@ GoHome
 ;		4) Mac II Portrait Video Card        (.DrPVC) [ROM Version PVC1.1, P/N 341-0732]
 ;
 
-			BRA		DoDrvrPatches			; Stupid extra branch because I calculate the size of the
+			BRA.S	DoDrvrPatches			; Stupid extra branch because I calculate the size of the
 											;   resident interrupt handler from labels, and they can't
 											;	be forward references. <15>: Changed name from Start to
 											;	DoDrvrPatches for <17>.
@@ -1050,6 +1009,387 @@ PtchStart
 PtchEnd
 ;----------------------------------------------------
 
+				WITH spBlock,vpBlock
+
+DoDrvrPatches
+
+;
+; Save all registers to prevent problems with the ROM INIT running code.
+;
+				MOVEM.L		A0-A6/D0-D7,-(SP)			; so we don’t screw up the boot process
+
+;
+; Point to UnitTable in A2.
+;
+				MOVE.L		UTableBase,A2				; point to base of unit table
+
+;
+; Allocate a spBlock (slot parameter block) on the stack.
+;
+				SUB.W		#spBlockSize,SP				; create an spBlock on the stack
+
+;
+; Set up stuff for the interrupt patch.
+;
+				LEA			TargetObj1,A0				; point to the start of the target sequence
+				MOVE.W		(A0),D6						; get the first word of the target sequence
+				MOVE.L		2(A0),D7					; get the remaining long of the target seq
+
+				MOVEQ		#0,D5						; if D5>0 at end, at least one card got patched
+
+;
+; It's easier to allocate the patch's memory and release it if it's not used than to allocate on
+;	demand.  This is only a small piece of memory anyway.
+;
+			If Not ForROM Then
+				MOVE.L		#PtchEnd-PtchStart,D0		; get the size of the interrupt fixer
+				_NewPtr	,Sys							; allocate some memory for it in sysheap
+				BNE 		Out							; if you can't get memory, exit
+
+				LEA			PtchStart,A1				; point at the code
+				EXG			A1,A0						; get source in A0, dest in A1
+				MOVE.L		#PtchEnd-PtchStart,D0		; get the size of the interrupt fixer
+				_BlockMove								; copy it down
+			Endif
+
+				LEA			ReplObj,A6					; point to the substitution object
+			If Not ForROM Then
+				MOVE.L		A1,2(A6)					; patch the JSR address with the sysHeap dest
+			Endif
+
+;
+; Get a pointer to the first gDevice in A3.  Since we won't upset memory, we don't need to lock it.
+;
+				MOVE.L		DeviceList,A3				; get handle
+				MOVE.L		(A3),A3						; get pointer
+
+;
+; Point to DCE of next gDevice
+;
+NxtSlotLoop
+				MOVE.W		gdRefNum(A3),D0				; get driver refnum
+				NOT.W		D0							; convert to offset
+				MOVE.L		(A2,D0*4),A1				; get DCE handle
+				MOVE.L		(A1),A1						; get DCE pointer
+
+				MOVE.L		A1,A4						; save this for driver patching code below
+
+;
+; Point to spBlock.
+;
+				MOVE.L		SP,A0						; save pointer to block
+
+;
+; Set up for an sRsrcInfo call.
+;
+				MOVE.B		dCtlSlot(A1),spSlot(A0)		; get slot number
+				MOVE.B		dCtlSlotID(A1),spID(A0)		; get ID
+				MOVE.B		dCtlExtDev(A1),spExtDev(A0)	; external device ID
+				_sRsrcInfo								; there should never be a miss here
+
+;
+; Now that we have the right sRsrcList in spsPointer, get the sRsrcFlags word
+;	from the video sRsrc.
+;
+				MOVE.B		#sRsrcFlags,spID(A0)		; look for sRsrcFlags
+				_sReadWord								; spsPointer is still set up from before
+				BNE.S		@IntPtch					; if not present, then it's 24-bit addressed
+				MOVE.L		spResult(A0),D0				; get the result in a reg
+
+;
+; Test the flag word for 32-bit devices
+;
+				BTST		#f32BitMode,D0				; test it
+				BEQ.S		@IntPtch					; if not a 32-bit device, don't do init
+   				BSET		#ext32Device,gdFlags(A3)	; set the 32-bit access flag in the gDevice
+
+;
+; Take the DCE pointer in A4 (from above), and test to see if we want to patch this driver.
+;
+@IntPtch
+			If Not ForROM Then
+				BTST		#dRAMBased,dCtlFlags+1(A4)	; test if this is a driver in ROM (Erickson overpatch)	<7.0>
+				BEQ			NxtSlot						; if so, then continue to next slot						<7.0>
+			Endif
+
+				MOVE.L		dCtlDriver(A4),A1			; get handle to driver
+				MOVE.L		(A1),A1						; get pointer to driver
+
+				MOVE.L		drvrName+2(A1),D0			; get a unique long from the name
+				CMP.L		#'DrWV',D0					; is it the 2-Page card?
+				BEQ.S		@isTwo						;
+				CMP.L		#'DrPV',D0					; is it the Portrait card?
+				BEQ.S		@isPort						;
+				CMP.L		#'Disp',D0					; could it be one of the others?
+				BNE			NxtSlot						; no, so don't do anything with this card
+				MOVE.L		drvrName+20(A1),D0			; pick up the next significant long
+				CMP.L		#'e_HR',D0					; is it the Hi-Res Video card?
+				BEQ.S		@isHR						;
+			If Not ForROM Then
+				CMP.L		#'e_RB',D0					; is it the Mac II ci?
+				BNE.S		NxtSlot						; no, so go to the next card
+			Else
+				Bra.s		NxtSlot
+			Endif
+
+; Here are the patch offsets for the Mac IIci Built-In Video v1.0 driver.
+
+			If Not ForROM Then
+				MOVE.W		#$1A4,D0					; pass the offset		<Control-SetVidMode>
+				BSR			CmpReplTarget1				; (compare and replace) or exit to NxtSlot if no match
+				MOVE.W		#$2C0,D0					;						<Control-SetEntries>
+				BSR			CmpReplTarget1				;
+				MOVE.W		#$656,D0					;						<Utility-WaitVSync>
+				BSR			CmpReplTarget1				;
+				BRA.S		@IncFlag					; and exit
+			Endif
+
+;
+; Since the Two-Page v1.2 and Portrait v1.1 are generated from the same source file, the offsets are the
+;	same.  Earlier releases of these two ROMs don't have this interrupt problem.
+;
+@isTwo													;
+@isPort
+				MOVE.W		#$2DA,D0					; pass the offset		<Control-SetVidMode>
+				BSR			CmpReplTarget1				; (compare and replace) or exit to NxtSlot if no match
+				MOVE.W		#$388,D0					;						<Control-SetEntries/nonsequential>
+				BSR			CmpReplTarget1				;
+				MOVE.W		#$4D8,D0					;						<Control-SetEntries/sequential>
+				BSR			CmpReplTarget1				;
+				MOVE.W		#$630,D0					;						<Control-DisableVGuts>
+				BSR			CmpReplTarget1				;
+				MOVE.W		#$8CC,D0					;						<Utility-TFBSetDepth>
+				BSR			CmpReplTarget1				;
+				BRA.S		@IncFlag					; and exit
+
+;
+; Here are the patch offsets for the Mac II Hi-Res Video Card v1.0.  I missed updating one case of the
+;	interrupt disabling code, so there is one special patch for that missed case.
+;
+@isHR
+				MOVE.W		#$45A,D0					; pass the offset		<Control-SetVidMode>
+				BSR			CmpReplTarget1				; (compare and replace) or exit to NxtSlot if no match
+				MOVE.W		#$58A,D0					;						<Control-SetEntries>
+				BSR			CmpReplTarget1				;
+				MOVE.W		#$6F2,D0					;						<Control-DisableVGuts>
+				BSR			CmpReplTarget1				;
+
+				BSR			CmpReplTarget2				; here's the one odd case <Utility-WaitVSync>
+
+				MOVE.W		#$A1E,D0					;						<Control-TFBSetDepth>
+				BSR			CmpReplTarget1				;
+
+@IncFlag		ADDQ		#1,D5						; increment patching flag
+NxtSlot
+				MOVE.L		gdNextGD(A3),D0				; get handle to next gDevice
+				MOVE.L		(ZA0,D0.L),A3
+				BNE			NxtSlotLoop
+
+;
+; See if the any drivers were patched.  If not, then release the patcher block in sysheap.
+;
+			If Not ForROM Then
+
+				TST.B		D5							; if zero, then nobody was patched
+				BNE.S		Out							;
+
+Out1			LEA			ReplObj,A6					; point to the substitution object
+				MOVE.L		2(A6),A0					; get the pointer block address from here
+				_DisposPtr								; release it
+
+			Endif
+
+;
+; Release the slot manager block.
+;
+
+Out				ADD.L		#spBlockSize,SP				; clean up the stack
+
+				Endwith
+
+;
+; Lets restore more registers than have ever been restored before. (Hey, you can never be too careful.)
+;
+				MOVEM.L	(SP)+,A0-A6/D0-D7				; so we don’t screw up the boot process
+
+; ••• 7th INIT •••
+;
+			If Not ForROM Then
+
+;---------------------------------------------------------------------
+;	Local variables, definitions, etc....
+;---------------------------------------------------------------------
+
+drHwDAFB		Equ		$001C						; Built-in Video Hardware ID for Macintosh Quadras 700/900/950.
+DrvrVer950		Equ		$0001						; Version number of the Macintosh Quadra 950’s video driver.
+
+badEntry		Equ		$38							; Location of bad table entry in the Macintosh Quadra 950 driver.
+
+; Straight from the Macintosh Quadra 950 ROM’s source code…
+;
+DAFBVidPrivates	RECORD	0
+saveBaseAddr 	DS.L	1							; the screen base address (NOT ST corrected!)
+saveScreenBase	DS.L	1							; ST corrected version of saveBaseAddr.
+saveSQElPtr 	DS.L	1							; the SQ element pointer (for _SIntRemove)
+saveGammaPtr 	DS.L	1							; the pointer to the Gamma correction table
+saveGamDispPtr	DS.L	1							; the pointer to the Gamma block
+saveVDACBase	DS.L	1							; the base addr of the VDAC
+saveDAFBBase	DS.L	1							; the base addr of the DAFB
+saveVidPtr		DS.L	1							; pointer to a big block of DAFB video parameters
+GFlags			DS.W	1							; flags word
+has16bppACDC	Ds.b	1							; true if AC842A is around
+pageModeSet		Ds.b	1							; true if the pRam PageMode enable bit is set
+saveMode		DS.W	1							; the current mode setting (in lo-byte)
+saveMonID		DS.W	1							; monitor type ID (in lo-byte)
+saveSlotId		DS.W	1							; spID of video sRsrc (hi-order byte only!)
+DAFBVidPrivSize	EQU		*
+				ENDR
+
+; Flags within GFlags word…
+;
+GrayFlag		EQU		15							; luminance mapped if GFlags(GrayFlag) = 1
+IntDisFlag		EQU		14							; interrupts disabled if GFlags(IntFlag) =1
+IsMono			EQU		13							; true if monochrome only display (Portrait/Kong)
+UseSeq			EQU		12							; true if sequence mode SetEntries
+UseTrans		Equ		12							; True if we’re supposed to translate 5-bit into 8 (DAFB 16bpp).
+Is16			EQU		11							; true if 16Mhz (Slow) CPU
+IsSlow			Equ		11							; True if Slow CPU (for DAFB, 25Mhz is slow).
+IsDirect		EQU		10							; true if direct video mode, else chunkyIndexed
+PsuedoIndex		EQU		 9							; true if SetEntries request was mapped to indexed from sequential
+													;	(due to screen depth hardware requirements)
+Has16bppSRsrc	Equ		 9							; True if FifthVidMode is 16bpp instead of 32bpp (DAFB).
+SyncOnGreen		Equ		 8							; True if we’re supposed to put sync on green (DAFB).
+
+
+				bra.s	PatchQuadra950Driver		; skip over the title
+				
+				String	Pascal
+
+DAFBVideoTitle	Dc.b	'.Display_Video_Apple_DAFB'
+				Align	2
+
+;---------------------------------------------------------------------
+;	Main
+;---------------------------------------------------------------------
+
+PatchQuadra950Driver
+				String	AsIs
+				With	SpBlock,DAFBVidPrivates
+				
+Quadra950SaveRegs	Reg		D4-D6					; Define work registers.
+
+			If AsInit Then
+				Cmp.w	#$3FFF,ROM85				; If Color QuickDraw is not around,
+				Bne		@ExitNow					;	then just leave.
+			EndIf
+			
+				Tst.l	DeviceList					; If the device list is empty,
+				Beq		@ExitNow					; 	then just leave.
+				
+				Move.l	DeviceList,A0				; Get the DeviceList Handle.
+				Move.l	(A0),A0						; Make it a pointer.
+				Move.w	gdRefNum(A0),D0				; If there’s no driver, then
+				Beq		@ExitNow					;	we can’t do anything here.
+				
+				Movem.l	Quadra950SaveRegs,-(Sp)		; Save work registers.
+				Suba.w	#spBlockSize,Sp				; Allocate SpBlock 
+
+; The shipping version of the Macintosh Quadra 950’s ROM (1.7F2) has a bug in the built-in video
+; driver which prevents the DirectSetEntries call from working correctly when the attached display
+; is put into 32 bit-per-pixel mode.  To fix this problem, we just patch the bad table in place
+; since it resides in the System heap.
+;
+				Move.l	Sp,A0						; Get spBlock ptr into A0.
+				Clr.b	spId(A0)					; Begin at id 0.
+				Clr.b	spSlot(A0)					; We only care about Slot $0.
+				Clr.b	spExtDev(A0)				; No external device.
+				Clr.b	spTBMask(A0)				; No mask in search.
+				Move.w	#catDisplay,spCategory(A0)	; Look for:	Display,
+				Move.w	#typVideo,spCType(A0)		;  			Video,
+				Move.w	#drSwApple,spDrvrSW(A0)		;  			Apple,
+				Move.w	#drHwDAFB,spDrvrHW(A0)		;  			DAFB.
+				Clr.l	spParamData(A0)				; Look only for enabled sRsrcs.
+				Bset	#foneslot,spParamData+3(A0)	; Limit search to this slot only.
+				_GetTypeSRsrc						; If built-in video is not enabled, then
+				Bne.s	@AllDone					;	just quit.
+				
+; We found the DAFB-based (Macintosh Quadra 700/900/950) built-in video in Slot $0.
+;
+				Moveq	#0,D5						; Prepare D5.
+				Move.w	spRefNum(A0),D5				; Get the refNum.
+				Beq.s	@AllDone					; If nil, then just leave (no driver).
+				Not.w	D5							; Convert the refNum into…
+				Lsl.w	#2,D5						;	…a UTable index.
+				
+				Add.l	UTableBase,D5				; Get a ptr to the AuxDCEHandle.
+				Move.l	D5,A0						; Get it into A0.
+				
+				Move.l	(A0),A0						; Get the AuxDCEHandle.
+				Move.l	(A0),A0						; Get the AuxDCEPtr.
+				Move.l	A0,D5						; Save it for later.
+
+				move.w	dCtlFlags(a0),d0			; <27> Get driver flags
+				Move.l	dCtlDriver(A0),A0			; Get driver.
+				btst	#dRAMBased,d0				; <27> Check to see if dCtlDriver is a handle or a pointer
+				bz.s	@gotDriverPointer			; <27> A ROM based driver means it’s a pointer
+				Move.l	(A0),A0						; Get ptr to driver.
+@gotDriverPointer
+				Move.l	A0,D6						; Save it for later.
+				
+				Moveq	#0,D0						; Prepare D0.
+				Lea		drvrName(A0),A0				; Point to the driver name.
+				Move.l	A0,D4						; Save it for later.
+				Move.b	(A0)+,D0					; Get its length.
+				Swap	D0							; Save it.
+				Lea		DAFBVideoTitle,A1			; Point to the driver name we want.
+				Move.b	(A1)+,D0					; Get its length.
+				_CmpString							; Compare the names.
+				Tst.w	D0							; If they are not equal, then we don’t know about
+				Bne.s	@AllDone					;	this DAFB driver, so just leave.
+				
+				Moveq	#0,D0						; Re-prepare D0.
+				Move.l	D4,A0						; Re-point to the driver name.
+				Move.b	(A0),D0						; Get its length.
+				Addq	#2,D0						; Adjust offset to version field.
+				Bclr	#0,D0						; Adjust offset for word alignment.
+				Move.w	(A0,D0),D4					; Get the driver’s version number.
+				Cmp.w	#DrvrVer950,D4				; If this isn’t the Quadra 950’s driver version,
+				Bne.s	@AllDone					;	then just leave.
+				
+				Adda.w	D0,A0						; Point to version part of driver name.
+				Move.l	A0,D4						; Save it for later.
+
+; We found the Macintosh Quadra 950’s version of the DAFB driver.
+;
+				Move.l	D5,A0						; Re-point to the AuxDCEPtr.
+				Move.l	dCtlStorage(A0),A0			; Get the Handle to DAFB private storage.
+				Move.l	(A0),A0						; Make it a pointer.
+				
+				Btst	#Has16bppSRsrc,GFlags(A0)	; If a 16bpp-capable sRsrc is not in use,
+				Beq.s	@AllDone					;	then just leave.
+
+				Move.l	D6,A0						; Re-point to the DAFB driver.
+				Move.b	#$FF,badEntry(A0)			; Fix the bad table entry.
+				
+				Move.l	D4,A0						; Re-point to the DAFB driver version number.
+				Move.w	#DrvrVer950+1,(A0)			; Update it.
+
+@AllDone
+				Add.w	#spBlockSize,Sp 			; Deallocate SpBlock.
+				Movem.l	(Sp)+,Quadra950SaveRegs		; Restore work registers.
+
+@ExitNow											; Outta here, dudes.
+				Rts
+				
+				Endwith
+				
+			Else
+				
+				Rts
+			
+			Endif
+
+
 ;
 ; This compares the object code at (A1,D0.W) with the target string in D6 and D7, then, if it
 ;	matches, replaces this object with a JSR absolute.  It saves a little code in the patch
@@ -1132,411 +1472,5 @@ ReplObj
 				NOP										; target2 needs some additional NOPs
 				NOP										;
 
-				WITH spBlock,vpBlock
-
-DoDrvrPatches
-
-;
-; Save all registers to prevent problems with the ROM INIT running code.
-;
-				MOVEM.L		A0-A6/D0-D7,-(SP)			; so we don’t screw up the boot process
-
-;
-; Point to UnitTable in A2.
-;
-				MOVE.L		UTableBase,A2				; point to base of unit table
-
-;
-; Allocate a spBlock (slot parameter block) on the stack.
-;
-				SUB.W		#spBlockSize,SP				; create an spBlock on the stack
-
-;
-; Set up stuff for the interrupt patch.
-;
-				LEA			TargetObj1,A0				; point to the start of the target sequence
-				MOVE.W		(A0),D6						; get the first word of the target sequence
-				MOVE.L		2(A0),D7					; get the remaining long of the target seq
-
-				MOVEQ		#0,D5						; if D5>0 at end, at least one card got patched
-
-;
-; It's easier to allocate the patch's memory and release it if it's not used than to allocate on
-;	demand.  This is only a small piece of memory anyway.
-;
-			If Not ForROM Then
-				MOVE.L		#PtchEnd-PtchStart,D0		; get the size of the interrupt fixer
-				_NewPtr	,Sys							; allocate some memory for it in sysheap
-				BNE 		Out							; if you can't get memory, exit
-
-				LEA			PtchStart,A1				; point at the code
-				EXG			A1,A0						; get source in A0, dest in A1
-				MOVE.L		#PtchEnd-PtchStart,D0		; get the size of the interrupt fixer
-				_BlockMove								; copy it down
-			Endif
-
-				LEA			ReplObj,A6					; point to the substitution object
-			If Not ForROM Then
-				MOVE.L		A1,2(A6)					; patch the JSR address with the sysHeap dest
-			Endif
-
-;
-; Get a pointer to the first gDevice in A3.  Since we won't upset memory, we don't need to lock it.
-;
-				MOVE.L		DeviceList,A3				; get handle
-				MOVE.L		(A3),A3						; get pointer
-
-;
-; Point to DCE of next gDevice
-;
-NxtSlotLoop
-				MOVE.W		gdRefNum(A3),D0				; get driver refnum
-				NOT.W		D0							; convert to offset
-				MOVE.L		(A2,D0*4),A1				; get DCE handle
-				MOVE.L		(A1),A1						; get DCE pointer
-
-				MOVE.L		A1,A4						; save this for driver patching code below
-
-;
-; Point to spBlock.
-;
-				MOVE.L		SP,A0						; save pointer to block
-
-;
-; Set up for an sRsrcInfo call.
-;
-				MOVE.B		dCtlSlot(A1),spSlot(A0)		; get slot number
-				MOVE.B		dCtlSlotID(A1),spID(A0)		; get ID
-				MOVE.B		dCtlExtDev(A1),spExtDev(A0)	; external device ID
-				_sRsrcInfo								; there should never be a miss here
-			If Not ForROM Then
-				Bne			Out1						; But if there is, exit gracefully.
-			Else
-				Bne			Out							; Ditto.
-			Endif
-
-;
-; Now that we have the right sRsrcList in spsPointer, get the sRsrcFlags word
-;	from the video sRsrc.
-;
-				MOVE.B		#sRsrcFlags,spID(A0)		; look for sRsrcFlags
-				_sReadWord								; spsPointer is still set up from before
-				BNE.S		@IntPtch					; if not present, then it's 24-bit addressed
-				MOVE.L		spResult(A0),D0				; get the result in a reg
-
-;
-; Test the flag word for 32-bit devices
-;
-				BTST		#f32BitMode,D0				; test it
-				BEQ.S		@IntPtch					; if not a 32-bit device, don't do init
-   				BSET		#ext32Device,gdFlags(A3)	; set the 32-bit access flag in the gDevice
-
-;
-; Take the DCE pointer in A4 (from above), and test to see if we want to patch this driver.
-;
-@IntPtch
-			If Not ForROM Then
-				BTST		#dRAMBased,dCtlFlags+1(A4)	; test if this is a driver in ROM (Erickson overpatch)	<7.0>
-				BEQ			NxtSlot						; if so, then continue to next slot						<7.0>
-			Endif
-
-				MOVE.L		dCtlDriver(A4),A1			; get handle to driver
-				MOVE.L		(A1),A1						; get pointer to driver
-
-				MOVE.L		drvrName+2(A1),D0			; get a unique long from the name
-				CMP.L		#'DrWV',D0					; is it the 2-Page card?
-				BEQ.S		@isTwo						;
-				CMP.L		#'DrPV',D0					; is it the Portrait card?
-				BEQ.S		@isPort						;
-				CMP.L		#'Disp',D0					; could it be one of the others?
-				BNE			NxtSlot						; no, so don't do anything with this card
-				MOVE.L		drvrName+20(A1),D0			; pick up the next significant long
-				CMP.L		#'e_HR',D0					; is it the Hi-Res Video card?
-				BEQ.S		@isHR						;
-			If Not ForROM Then
-				CMP.L		#'e_RB',D0					; is it the Mac II ci?
-				BNE.S		NxtSlot						; no, so go to the next card
-			Else
-				Bra.s		NxtSlot
-			Endif
-
-; Here are the patch offsets for the Mac IIci Built-In Video v1.0 driver.
-
-			If Not ForROM Then
-				MOVE.W		#$1A4,D0					; pass the offset		<Control-SetVidMode>
-				BSR			CmpReplTarget1				; (compare and replace) or exit to NxtSlot if no match
-				MOVE.W		#$2C0,D0					;						<Control-SetEntries>
-				BSR			CmpReplTarget1				;
-				MOVE.W		#$656,D0					;						<Utility-WaitVSync>
-				BSR			CmpReplTarget1				;
-				BRA.S		@IncFlag					; and exit
-			Endif
-
-;
-; Since the Two-Page v1.2 and Portrait v1.1 are generated from the same source file, the offsets are the
-;	same.  Earlier releases of these two ROMs don't have this interrupt problem.
-;
-@isTwo													;
-@isPort
-				MOVE.W		#$2DA,D0					; pass the offset		<Control-SetVidMode>
-				BSR			CmpReplTarget1				; (compare and replace) or exit to NxtSlot if no match
-				MOVE.W		#$388,D0					;						<Control-SetEntries/nonsequential>
-				BSR			CmpReplTarget1				;
-				MOVE.W		#$4D8,D0					;						<Control-SetEntries/sequential>
-				BSR			CmpReplTarget1				;
-				MOVE.W		#$630,D0					;						<Control-DisableVGuts>
-				BSR			CmpReplTarget1				;
-				MOVE.W		#$8CC,D0					;						<Utility-TFBSetDepth>
-				BSR			CmpReplTarget1				;
-				BRA.S		@IncFlag					; and exit
-
-;
-; Here are the patch offsets for the Mac II Hi-Res Video Card v1.0.  I missed updating one case of the
-;	interrupt disabling code, so there is one special patch for that missed case.
-;
-@isHR
-				MOVE.W		#$45A,D0					; pass the offset		<Control-SetVidMode>
-				BSR			CmpReplTarget1				; (compare and replace) or exit to NxtSlot if no match
-				MOVE.W		#$58A,D0					;						<Control-SetEntries>
-				BSR			CmpReplTarget1				;
-				MOVE.W		#$6F2,D0					;						<Control-DisableVGuts>
-				BSR			CmpReplTarget1				;
-
-				BSR			CmpReplTarget2				; here's the one odd case <Utility-WaitVSync>
-
-				MOVE.W		#$A1E,D0					;						<Control-TFBSetDepth>
-				BSR			CmpReplTarget1				;
-
-@IncFlag		ADDQ		#1,D5						; increment patching flag
-NxtSlot
-				MOVE.L		gdNextGD(A3),D0				; get handle to next gDevice
-				Beq.s		@EndSlotLoop				; If nil, we’re done.
-				Move.l		D0,A3						; Otherwise, copy the handle.
-				Move.l		(A3),A3						; Turn it into a pointer.
-				Bra.s		NxtSlotLoop					; Loop until done.
-
-@EndSlotLoop
-
-;
-; See if the any drivers were patched.  If not, then release the patcher block in sysheap.
-;
-			If Not ForROM Then
-
-				TST.B		D5							; if zero, then nobody was patched
-				BNE.S		Out							;
-
-Out1			LEA			ReplObj,A6					; point to the substitution object
-				MOVE.L		2(A6),A0					; get the pointer block address from here
-				_DisposPtr								; release it
-
-			Endif
-
-;
-; Release the slot manager block.
-;
-
-Out				LEA			spBlockSize(SP),SP			; clean up the stack						<SM6>
-
-				Endwith
-
-;
-; Lets restore more registers than have ever been restored before. (Hey, you can never be too careful.)
-;
-				MOVEM.L	(SP)+,A0-A6/D0-D7				; so we don’t screw up the boot process
-
-; ••• 6th INIT •••
-;
-			if asINIT then
-;
-; Early in the boot process an _InitGraf was performed (for the Welcome to Mac box).
-;	It's not correct if the main screen moved away from the boot screen, so let's call
-;	InitGraf on these early globals to correct the problem.  This will fix a problem
-;	with the LMgr "init" which didn't do an InitGraf while setting up the environment
-;	for an alert dialog.
-;
-; Note that for the new boot process this is no longer necessary.
-;
-
-				PEA			-4(A5)
-				_InitGraf
-			
-			endif
-
-; ••• 7th INIT •••
-;
-			If Not ForROM Then
-
-;---------------------------------------------------------------------
-;	Local variables, definitions, etc....
-;---------------------------------------------------------------------
-
-drHwDAFB		Equ		$001C						; Built-in Video Hardware ID for Macintosh Quadras 700/900/950.
-DrvrVer950		Equ		$0001						; Version number of the Macintosh Quadra 950’s video driver.
-
-badEntry		Equ		$38							; Location of bad table entry in the Macintosh Quadra 950 driver.
-
-; Straight from the Macintosh Quadra 950 ROM’s source code…
-;
-DAFBVidPrivates	RECORD	0
-saveBaseAddr 	DS.L	1							; the screen base address (NOT ST corrected!)
-saveScreenBase	DS.L	1							; ST corrected version of saveBaseAddr.
-saveSQElPtr 	DS.L	1							; the SQ element pointer (for _SIntRemove)
-saveGammaPtr 	DS.L	1							; the pointer to the Gamma correction table
-saveGamDispPtr	DS.L	1							; the pointer to the Gamma block
-saveVDACBase	DS.L	1							; the base addr of the VDAC
-saveDAFBBase	DS.L	1							; the base addr of the DAFB
-saveVidPtr		DS.L	1							; pointer to a big block of DAFB video parameters
-GFlags			DS.W	1							; flags word
-has16bppACDC	Ds.b	1							; true if AC842A is around
-pageModeSet		Ds.b	1							; true if the pRam PageMode enable bit is set
-saveMode		DS.W	1							; the current mode setting (in lo-byte)
-saveMonID		DS.W	1							; monitor type ID (in lo-byte)
-saveSlotId		DS.W	1							; spID of video sRsrc (hi-order byte only!)
-DAFBVidPrivSize	EQU		*
-				ENDR
-
-; Flags within GFlags word…
-;
-GrayFlag		EQU		15							; luminance mapped if GFlags(GrayFlag) = 1
-IntDisFlag		EQU		14							; interrupts disabled if GFlags(IntFlag) =1
-IsMono			EQU		13							; true if monochrome only display (Portrait/Kong)
-UseSeq			EQU		12							; true if sequence mode SetEntries
-UseTrans		Equ		12							; True if we’re supposed to translate 5-bit into 8 (DAFB 16bpp).
-Is16			EQU		11							; true if 16Mhz (Slow) CPU
-IsSlow			Equ		11							; True if Slow CPU (for DAFB, 25Mhz is slow).
-IsDirect		EQU		10							; true if direct video mode, else chunkyIndexed
-PsuedoIndex		EQU		 9							; true if SetEntries request was mapped to indexed from sequential
-													;	(due to screen depth hardware requirements)
-Has16bppSRsrc	Equ		 9							; True if FifthVidMode is 16bpp instead of 32bpp (DAFB).
-SyncOnGreen		Equ		 8							; True if we’re supposed to put sync on green (DAFB).
-
-
-				bra.s	PatchQuadra950Driver		; skip over the title
-				
-				String	Pascal
-
-DAFBVideoTitle	Dc.b	'.Display_Video_Apple_DAFB'
-				Align	2
-
-;---------------------------------------------------------------------
-;	Main
-;---------------------------------------------------------------------
-
-PatchQuadra950Driver
-				String	AsIs
-				With	SpBlock,DAFBVidPrivates
-				
-Quadra950SaveRegs	Reg		D4-D6					; Define work registers.
-
-			If AsInit Then
-				Cmp.w	#$3FFF,ROM85				; If Color QuickDraw is not around,
-				Bne		@ExitNow					;	then just leave.
-			EndIf
-			
-				Tst.l	DeviceList					; If the device list is empty,
-				Beq		@ExitNow					; 	then just leave.
-				
-				Move.l	DeviceList,A0				; Get the DeviceList Handle.
-				Move.l	(A0),A0						; Make it a pointer.
-				Move.w	gdRefNum(A0),D0				; If there’s no driver, then
-				Beq		@ExitNow					;	we can’t do anything here.
-				
-				Movem.l	Quadra950SaveRegs,-(Sp)		; Save work registers.
-				Suba.w	#spBlockSize,Sp				; Allocate SpBlock 
-
-; The shipping version of the Macintosh Quadra 950’s ROM (1.7F2) has a bug in the built-in video
-; driver which prevents the DirectSetEntries call from working correctly when the attached display
-; is put into 32 bit-per-pixel mode.  To fix this problem, we just patch the bad table in place
-; since it resides in the System heap.
-;
-				Move.l	Sp,A0						; Get spBlock ptr into A0.
-				Clr.b	spId(A0)					; Begin at id 0.
-				Clr.b	spSlot(A0)					; We only care about Slot $0.
-				Clr.b	spExtDev(A0)				; No external device.
-				Clr.b	spTBMask(A0)				; No mask in search.
-				Move.w	#catDisplay,spCategory(A0)	; Look for:	Display,
-				Move.w	#typVideo,spCType(A0)		;  			Video,
-				Move.w	#drSwApple,spDrvrSW(A0)		;  			Apple,
-				Move.w	#drHwDAFB,spDrvrHW(A0)		;  			DAFB.
-				Clr.l	spParamData(A0)				; Look only for enabled sRsrcs.
-				Bset	#foneslot,spParamData+3(A0)	; Limit search to this slot only.
-				_GetTypeSRsrc						; If built-in video is not enabled, then
-				Bne.s	@AllDone					;	just quit.
-				
-; We found the DAFB-based (Macintosh Quadra 700/900/950) built-in video in Slot $0.
-;
-				Moveq	#0,D5						; Prepare D5.
-				Move.w	spRefNum(A0),D5				; Get the refNum.
-				Beq.s	@AllDone					; If nil, then just leave (no driver).
-				Not.w	D5							; Convert the refNum into…
-				Lsl.w	#2,D5						;	…a UTable index.
-				
-				Add.l	UTableBase,D5				; Get a ptr to the AuxDCEHandle.
-				Move.l	D5,A0						; Get it into A0.
-				
-				Move.l	(A0),A0						; Get the AuxDCEHandle.
-				Move.l	(A0),A0						; Get the AuxDCEPtr.
-				Move.l	A0,D5						; Save it for later.
-
-				move.w	dCtlFlags(a0),d0			; <27> Get driver flags
-				Move.l	dCtlDriver(A0),A0			; Get driver.
-				btst	#dRAMBased,d0				; <27> Check to see if dCtlDriver is a handle or a pointer
-				bz.s	@gotDriverPointer			; <27> A ROM based driver means it’s a pointer
-				Move.l	(A0),A0						; Get ptr to driver.
-@gotDriverPointer
-				Move.l	A0,D6						; Save it for later.
-				
-				Moveq	#0,D0						; Prepare D0.
-				Lea		drvrName(A0),A0				; Point to the driver name.
-				Move.l	A0,D4						; Save it for later.
-				Move.b	(A0)+,D0					; Get its length.
-				Swap	D0							; Save it.
-				Lea		DAFBVideoTitle,A1			; Point to the driver name we want.
-				Move.b	(A1)+,D0					; Get its length.
-				_CmpString							; Compare the names.
-				Tst.w	D0							; If they are not equal, then we don’t know about
-				Bne.s	@AllDone					;	this DAFB driver, so just leave.
-				
-				Moveq	#0,D0						; Re-prepare D0.
-				Move.l	D4,A0						; Re-point to the driver name.
-				Move.b	(A0),D0						; Get its length.
-				Addq	#2,D0						; Adjust offset to version field.
-				Bclr	#0,D0						; Adjust offset for word alignment.
-				Move.w	(A0,D0),D4					; Get the driver’s version number.
-				Cmp.w	#DrvrVer950,D4				; If this isn’t the Quadra 950’s driver version,
-				Bne.s	@AllDone					;	then just leave.
-				
-				Adda.w	D0,A0						; Point to version part of driver name.
-				Move.l	A0,D4						; Save it for later.
-
-; We found the Macintosh Quadra 950’s version of the DAFB driver.
-;
-				Move.l	D5,A0						; Re-point to the AuxDCEPtr.
-				Move.l	dCtlStorage(A0),A0			; Get the Handle to DAFB private storage.
-				Move.l	(A0),A0						; Make it a pointer.
-				
-				Btst	#Has16bppSRsrc,GFlags(A0)	; If a 16bpp-capable sRsrc is not in use,
-				Beq.s	@AllDone					;	then just leave.
-
-				Move.l	D6,A0						; Re-point to the DAFB driver.
-				Move.b	#$FF,badEntry(A0)			; Fix the bad table entry.
-				
-				Move.l	D4,A0						; Re-point to the DAFB driver version number.
-				Move.w	#DrvrVer950+1,(A0)			; Update it.
-
-@AllDone
-				Add.w	#spBlockSize,Sp 			; Deallocate SpBlock.
-				Movem.l	(Sp)+,Quadra950SaveRegs		; Restore work registers.
-
-@ExitNow											; Outta here, dudes.
-				Rts
-				
-				Endwith
-				
-			Else
-				
-				Rts
-			
-			Endif
 
 			END
diff --git a/QuickDraw/ColorMgr.a b/QuickDraw/ColorMgr.a
--- a/QuickDraw/ColorMgr.a
+++ b/QuickDraw/ColorMgr.a
@@ -5,19 +5,9 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM9>	11/29/93	SAM		Yet another getCTable mod.  Move the handle to the clut copy
-;									into A0 prior to the seed range check.
 ;	   <SM8>	 11/7/93	SAM		Changed GetCTable to get a new seed if the id > 1023 (kMinSeed).
-;	   <SM7>	 9/29/93	SAM		From mc900ftjesus
-;	   <MC4>	 9/27/93	SAM		Rewrote the guts of GetCTable.  The result of calling GetCtable
-;									is a Handle to a ram based copy of the clut (whether its in ROM
-;									or not).  It no longer requires that you have 2x sixeof(clut)
-;									heap space. Made GetCTable not set ctSeed if the ct ID is ≤ 8.
 ;	   <SM6>	 9/13/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM5>	  3/3/93	PN		Fix the rGetResource in MakeITable by adjusting the CurMap to
-;									point to SysMap before calling rGetResource. Roll in patch
-;									StartRGetResourceFromSystemMapFormitqResources
 ;	   <SM4>	 1/21/93	KW		(LW3 fau) Rolled in the MySaveEntries patch:  In SaveEntries, if
 ;									the bpp is ≥ 16bpp it will exit with an error, but the code was
 ;									not returning the stack to it's correct state.  Renamed all the
@@ -418,10 +408,6 @@ AdjZone
 
 		move.w		#0,isTmpHandle(a6)	;assume handles are not in temp memory	<28Feb90 KON>
 
-; Here is the fix for rGetResource from ResourceMgrPatches.a
-		move.w	CurMap,-(sp)			; Save the current resource map. <SM5>
-		move.w	SysMap,CurMap			; <27> Start searching from the System file instead of the top <SM5>	
-
 ; allocate space on the heap for the queue, reading queue size from resource
 
 		SUBQ		#4,SP				; make room for the function return		<C835/20Feb87> DAF
@@ -430,8 +416,6 @@ AdjZone
 		_rGetResource					; system first, then ROM				<C835/20Feb87> DAF
 		MOVE.L		(SP)+,A0			; get the handle						<C835/20Feb87> DAF
 	
-		move.w		(sp)+,CurMap		; Restore the current resource map <SM5>
-		
 		MOVE.L		(A0),A0				; get the pointer in A0					<C835/20Feb87> DAF
 		MOVE.L		-12(A0,D7*4),D0		; get the queue size (adjust for no 1 or 2 bit resolutions) <C835/20Feb87> DAF
 		MOVE.L		D0,D3				; hold it for a second
@@ -2651,49 +2635,40 @@ notRes			MOVE	4(SP),D0				; Get requested ID
 				BRA.S	RTD2
 
 
-readIt			MOVEM.L	D6/D7,-(SP)				; Save some work registers					<SAM 27SEP93>
-				MOVE.W	#mapTrue,ROMMapInsert	; Put the ROM map at the lend of the list
-				SUBQ	#4,A7					; space for result
+readIt			SUBQ	#4,A7					; space for result
 				MOVE.L	#'clut',-(SP)			; resource type
-				MOVE	20(SP),-(SP)			; push ID number
+				MOVE	12(SP),-(SP)			; push ID number
 				_GetResource					; Get it.
-				MOVE.L	(SP)+,D7				; Did we get the resource?
-				BEQ.S	@readFail				; -> Nope, Clear A0 and exit.
+				MOVE.L	(SP)+,D0				; Did we get the resource?
+				BEQ.S	@otherThing
 
-				MOVE.L	D7,-(SP)				; Push the Resource Handle
+				MOVE.L	D0,-(SP)				; Push the Resource Handle
+				MOVE.L	D0,-(SP)				; Push the Resource Handle
 				_DetachResource					; Free it from the Map
+				MOVE.L	(SP)+,A0
+				_HNoPurge
+
+				MOVE.L	(A0),A1
+				SUBQ	#4,SP
+				_rGetCTSeed
+				MOVE.L	(SP)+,(A1)
 
-				MOVE.L	D7,D6					; Put the orig in D6
-				MOVE.L	D7,A0					; Get the handle in A0
-				MOVE.L	D7,A1					; Get the handle in A1
-				
-				MOVE.L	(A1),A1					; Get the ptr
-				CMP.L	ROMBase,A1				; Is the clut in ROM?
-				BLO.S	@SetTheSeed				; -> No. Its in RAM. Set the seed and leave
-				
-				_HandToHand						; Make a copy in a new handle in RAM
-				MOVE.L	A0,D6					; Save the copy in D6
-												
-				MOVE.L	D7,A0					; Get the resource handle in A0
-				_DisposHandle					; Free the ROM handle
-				
-				MOVE.L	D6,A0					; Move the copy into A0						<SM9>
-				TST.L	D6						; Did we get the copy?
-				BEQ.S	@ReadFail				; -> No. Clear A0 and exit
-				
-@SetTheSeed		CMPI.W	#1023,18(SP)			; Is this a request for a system clut?		<MC4><MC5>
-				BLS.S	@done					; -> Yes, leave the seed alone!				<MC4>
-				
-				CLR.L	-(SP)					; make room for function return
-				_rGetCTSeed						; get the next seed and leave it on the stack
-				MOVE.L	D6,A0					; Get the copy in A0
-				MOVE.L	(SP)+,([A0],ctSeed)		; Set the Seed in the copy
-				
-				_HNoPurge						; Make sure it doesn't go away
 				BRA.S	@Done					; -> Got It!
 
+@otherThing
+				MOVE	#$FFFF,RomMapInsert
+				SUBQ	#4,SP
+				MOVE.L	#'clut',-(SP)
+				MOVE	12(SP),-(SP)
+				_GetResource
+				MOVE.L	(SP)+,D0
+				BEQ.S	@readFail
+
+				MOVE.L	D0,A0
+				_HandToHand
+				BEQ.S	@done
+
 @readFail		SUBA.L	A0,A0					; A miserable failure.
-@done			MOVEM.L	(SP)+,D6/D7				; Restore the work registers
-				RTD		#2						; Lose ID, and go home.
+@done			RTD		#2						; Lose ID, and go home.
 
 
diff --git a/QuickDraw/DrawText.a b/QuickDraw/DrawText.a
--- a/QuickDraw/DrawText.a
+++ b/QuickDraw/DrawText.a
@@ -34,9 +34,6 @@
 ;														LinkedPatchMacros.a for ROM builds, since this file is included
 ;														into CQD.a.
 ;									<72> 4/24/92 DTY	Remove all Spline_Fonts conditionals.
-;	   <SM2>	 4/16/92	PN		Include the right files for ROM build, BigJSR. Eliminated
-;									has_color condition and 68000 condition (SuperMario will always
-;									run with colorQD and >68000)
 ;		<71>	 9/27/91	JSM		Don’t define hasDoubleByte for ROM builds.
 ;		<70>	 9/25/91	jlf		Rolled in Pacific TrueType modifications and removed
 ;									DOUBLE_BYTE conditional code. New doublebyte code is
@@ -365,7 +362,11 @@ hasFullKerning		EQU		1
 		ENDIF
 	ENDIF
 
+	IF HAS_COLOR THEN
 		MACHINE		MC68020      							;<PN>
+	ELSE
+		MACHINE		MC68000
+	ENDIF
 
 	IF (NOT forROM) THEN									; <31> DTY <PN> <SM3> CSS
 		CASE		OBJ
@@ -394,6 +395,9 @@ hasFullKerning		EQU		1
 		include		'Script.a'
 	endif
 
+ROMTrimRect		ROMBIND	(SE, $1692A), (Plus, $C1BA), (Portable, $23A10)
+ROMRSect		ROMBIND	(SE, $14880), (Plus, $A110), (Portable, $212C6)
+
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 ;
 ;  PROCEDURE DrText(count: INTEGER; textAddr: Ptr; numer,denom: Point);
@@ -406,7 +410,11 @@ hasFullKerning		EQU		1
 ;
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 
+	IF HAS_COLOR THEN
 DrText	PROC  EXPORT
+	ELSE
+BWDrText	PROC  EXPORT
+	ENDIF
 
 ; If the portVersion/rowBytes of any port has the following bits set, it is a GWorld
 GWorldFlag			equ		$C001					; isPixMap+isCPort+isGWorld
@@ -417,6 +425,9 @@ GWorldFlag			equ		$C001					; isPixMap+isCPort+isGWorld
 	IMPORT	ArithMode
 	IMPORT	GetStyleBufHand
 	IMPORT	CalcCharExtra
+	IF &TYPE('JStdTxMeas') = 'UNDEFINED' THEN
+		IMPORT	JStdTxMeas
+	ENDIF
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 ;									Font structure for bitmaps
@@ -649,6 +660,7 @@ STKOK
 		MOVE.L	(A0), A0								; get pointer to splineKey globals.	<61-CEL/RWB>
 		MOVE.W	#-2, splineKeyRec.safeCount(A0)			;init to -1 for flagging 	<61-CEL/RWB>
 	ENDIF
+	IF	HAS_COLOR THEN
 		MOVE.B	splineKeyRec.is32bit(A0),is32QD(A6)		; get 32 bit CQD flag in CCR.
 		MOVE.L	TheGDevice,LastTxGDevice	;save the text device for next time
 ;————————————————————————————————————————————————————————————————————————————————————————————————
@@ -692,6 +704,7 @@ STKOK
 		SEQ		CRSRFLAG(A6)				;If so, set it
 @doneSetFlag
 	ENDIF									;Gaudi
+	ENDIF									;HAS_COLOR
 
 ;———————————————————————————————————————————————————
 ; Load the matching Font and Measure the string
@@ -717,11 +730,18 @@ STKOK
 		PEA 	INFO(A6)								;PUSH VAR INFO
 		lea		JStdTxMeas,A0							;get piece of trap table	<31> DTY Changed from move.l
 		move.l	(a0),a0
+	IF	NOT HAS_COLOR THEN
+		MOVE.L	(A0),A0
+	ENDIF
 		JSR 	(A0)									;MEASURE TEXT
 
 ;———————————————————————
 ; Set up mask table ptr
 ;———————————————————————
+	IF	NOT HAS_COLOR THEN
+		_GetMaskTable
+		move.l	a0,maskTabPtr(a6)
+	ENDIF
 
 ;——————————————————————
 ; Fix for overflow of stdtxmeas
@@ -746,6 +766,9 @@ STKOK
 		MOVE.L	fontAdj(A4),D1							;get fixed point width
 		MOVE.L	fontPtr(A4),A4							;Point to FmOutput record
 
+	IF	HAS_COLOR THEN
+		TST.B	is32QD(A6)
+		BEQ.S	@1
 		move	portVersion(a3),d0						; get the port's portVersion/rowBytes
 		and		#GWorldFlag,d0							; mask all other bits than the GWorldFlag
 		cmp		#GWorldFlag,d0							; is it exactly equal to GWorldFlag?
@@ -759,6 +782,9 @@ STKOK
 		MOVEM.L	(SP)+, A0-A1/D0-D2						;Restore registers
 		ST		needs32Bit(A6)							; sending 32-bit data
 @1		MOVE.W	dstPix+pixelSize(A6),destDepth(A6)		;Get the pixel depth
+	ELSE
+		MOVE.W	#1,destDepth(A6)
+	ENDIF
 
 	IF (hasSplineFonts) OR (Gaudi) THEN		; <31> DTY
 ;———————————————————————————————————————————————————
@@ -895,7 +921,14 @@ STKOK
 
 		MOVE.L	D2, A0						;cache pointer
 		LEA		cache.glyphArray(A0), A2	;Get array of glyphs into A2
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
  		MOVE.L	0(A2,D5*4),D0				;Get offset to glyph in D0
+ 	ELSE
+		MOVE.W	D5,D0
+		ADD.W	D0,D0
+		ADD.W	D0,D0
+ 		MOVE.L	0(A2,D0),D0
+ 	ENDIF
 		BGT.S	@okayGlyph
 		BTST.L	#30, D0						;Check if there is an error
 		BNE.S	@doRSB						;branch if error
@@ -912,7 +945,13 @@ STKOK
 		clr.l	d0							; clear a long for the character code
 		move.b	lowByte(a6),d0				; double byte character?
 		beq.s	@checkLSB					; no, skip this
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		move.l	0(a0,d0.w*4),d0				; load glyph record offset
+	ELSE
+		add.w	d0, d0
+		add.w	d0, d0
+		move.l	0(a0,d0.w),d0
+	ENDIF
 		bgt.s	@haveGlyphOffset			; skip checks if positive
 		btst.l	#30,d0						; error rendering glyph?
 		bne.s	@doRSB						; yes, skip this glyph
@@ -938,7 +977,13 @@ STKOK
 	endif
 
 		MOVE.W	D3, D5						;copy of D3
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
  		MOVE.L	0(A2,D3*4),D0				;Get offset to glyph in D0
+ 	ELSE
+		ADD.W	D3, D3
+		ADD.W	D3, D3
+ 		MOVE.L	0(A2,D3),D0
+ 	ENDIF
 		BGT.S	@okayGlyph2
 		BTST.L	#30, D0						;Check if there is an error
 		BNE.S	@doneOverHang
@@ -952,7 +997,11 @@ STKOK
 		ADD.L	D2, D0						;add offset and point to glyph data
 		MOVE.L	D0, A0						;Get in address reg
 @calcROverHang
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE.W	0(A1,D3*4),D0				;Get the width
+	ELSE
+		MOVE.W	0(A1,D3),D0
+	ENDIF
 		MOVE.W	glyph.devLSB(A0), D3		;Get integralized left side bearing
 		ADD.W	glyph.bitWidth(A0), D3		;RoverHang = (lsb+bitwidth)-Width
 		SUB.W	D0, D3						;
@@ -969,6 +1018,7 @@ STKOK
 		MOVE	txMode(A3),D0
 		AND 	#$FFF7,D0	 				;clear pattern bit (let stretch reject invalid modes)
 		MOVE	D0,locMode(A6)				;initialize copy
+	IF	HAS_COLOR THEN
 		BTST	#6,D0						;bit 6 if set says use a mask
 		SNE		D3							;remember it
 		BEQ.S	@notMask
@@ -977,10 +1027,13 @@ STKOK
 @notMask
 		MOVE.B	D3,maskFont(A6)				;0 if mask bit clear, no mask font, or incoming 1 deep
 		MOVE.B	D3,textCopyMode(A6)			;set up bit insert/extract flag
+	ENDIF
 		BTST	#5,D0						;arithmetic mode?
 		BEQ.S	@doneMode					;if not, don’t map if dest. is 1 bit deep
+	IF	HAS_COLOR THEN
 		CMP		#1,dstPix+pixelSize(A6)		;1 bit deep destination?
 		BNE.S	@doneMode					;if not, arithmetic mode is OK
+	ENDIF
 		LEA		ArithMode,A0				;get mode map
 		AND		#7,D0						;look at each different arith mode
 		MOVE.B	0(A0,D0),D0					;map into 1 bit safe mode
@@ -1032,12 +1085,14 @@ STKOK
 @noMaskMode
 
 		moveq	#0,	d0							; clear the character extra.			<49>
+	IF	HAS_COLOR THEN
 		tst.b	portBits+rowBytes(a3)			; is this an old grafPort?
 		bpl.s	@oldGrafPort					; yes -> skip this.
 		move.w	chExtra(a3),d0					; load the character extra.
 		ext.l	d0								; for sign bits							<49>
 		asl.l	#4,d0							; convert to 16.16 format.
 @oldGrafPort
+	ENDIF
 	IF SCRIPT_CHAR_EXTRA THEN
 		move.l	grafGlobals(a5),a0				; load quickDraw globals.				<43>
 		add.l	qdChExtra(a0),d0				; add in the character extra.			<43>
@@ -1045,11 +1100,12 @@ STKOK
 		tst.l	d0								; have zero character extra?
 		beq.s	@zeroCharExtra					; yes -> skip call to scale.
 
-		bsr		CalcCharExtra					; scale by point size, etc.
+		jsr		CalcCharExtra					; scale by point size, etc.
 
 @zeroCharExtra
 		move.l	d0,characterExtra(a6)			; store scaled character extra.
 
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)			; is it a new port?
 		BPL.S	@useOld1						; no -> don’t set up fraction
 		MOVE	pnLocHFrac(A3),D2				; set up with proper fraction
@@ -1096,6 +1152,7 @@ STKOK
 		SNE		D0							;remember if black (or if fg/bk pixels are not equal)
 		BRA.S	@oldCommon
 @useOld1
+	ENDIF									;HAS_COLOR
 		BTST	#5,fgColor+3(A3)			;is the foreground color black?
 		SNE 	D0		 					;set to zero if not
 @oldCommon
@@ -1136,10 +1193,12 @@ STKOK
 		move.l	grafGlobals(a5),a0			; load quickDraw globals.
 		add.w	d1,pnLocFixed(a0)			; add width fraction to location fraction.
 	ENDIF
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)		; is it a new port?
 		BPL.S	@useOld						; no, don’t bother with fraction
 		ADD		D1,pnLocHFrac(A3)
 @useOld
+	ENDIF
 		;—————————————————————————————
 		; Move pen by the scaled text width
 		;—————————————————————————————
@@ -1181,7 +1240,11 @@ STKOK
 		MOVE	textR2+right(A6),-(SP)		;preserve existing right
 		MOVE	#32000,textR2+right(A6)		;get right from other rects
 		PEA 	TEXTR2(A6)					;PUSH (MAPPED) TEXTRECT
+	IF	HAS_COLOR THEN
 		PEA 	DSTPIX+BOUNDS(A6)			;PUSH PIXMAP BOUNDS
+	ELSE
+		PEA 	PORTBITS+BOUNDS(A3)			;PUSH PIXMAP BOUNDS
+	ENDIF
 		MOVE.L	CLIPRGN(A3),A0				;GET CLIPRGN HANDLE
 		MOVE.L	(A0),A0 					;DE-REFERENCE IT
 		PEA 	RGNBBOX(A0) 				;PUSH CLIPRGN BBOX
@@ -1190,7 +1253,11 @@ STKOK
 		PEA 	RGNBBOX(A0) 				;PUSH VISRGN BBOX
 		MOVE	#4,-(SP)					;PUSH NRECTS=4
 		PEA 	MINRECT(A6) 				;PUSH DST ADDR
+	IF	HAS_COLOR THEN
 		_RSECT								;CALC INTERSECTION
+	ELSE
+		jsrROM	ROMRSect
+	ENDIF
 		BEQ 	GOHOME						;QUIT IF NO INTERSECTION
 		MOVE	(SP)+,textR2+right(A6)		;restore text right
 											;———————————————————————————————
@@ -1205,9 +1272,15 @@ STKOK
 	;———————————————————————————————————————————————————
 		MOVE.L	A1,-(SP)					;PUSH VISRGN
 		PEA 	MINRECT(A6) 				;PUSH MINRECT
+	IF	HAS_COLOR THEN
+		TST.B	is32QD(A6)
+		BEQ.S	@no32bit
 		MOVE.W	#-1, -(SP)					;trim = true for BRUCE
 @no32bit
 		_TRIMRECT							;CALL TRIMRECT
+	ELSE
+		jsrROM	ROMTrimRect
+	ENDIF
 		BEQ.S	@rectRgn
 		BLT 	GOHOME						;quit if intersection empty
 		ST		clipHorz(A6)				;It was clipped so mark it
@@ -1252,11 +1325,13 @@ STKOK
 		MOVEQ	#10,D0
 		CMP 	RGNSIZE(A0),D0				;IS CLIPRGN RECTANGULAR ?
 		BNE		NotFast 					;NO, NOT FAST
+	IF	HAS_COLOR THEN
         CMP     #1, destDepth(A6)     		;****1-bit we can go fast
 		BEQ.S	@depthFast
 		TST.W	clipVert(A6)				;Vertically or horizontally clipped then go do norm loops
 		BNE		NotFast						;check to see if one bit only
 @depthFast
+	ENDIF
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 ;								END Calculate the MinRect
 ;————————————————————————————————————————————————————————————————————————————————————————————————
@@ -1284,6 +1359,9 @@ STKOK
 ;
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 sFAST
+		IF	HAS_COLOR THEN
+			TST.B	is32QD(A6)
+			BEQ.S	@not32bit
 			MOVEM.L	A0-A1/D0-D2,-(SP)				;Save registers
 @tryAgain	CLR.B	-(SP)					;result
 			MOVE.L	A3, -(SP)				;needs the current grafport
@@ -1291,9 +1369,12 @@ sFAST
 			TST.B	(SP)+					;Check result
 			BEQ.S	@tryAgain				;Check until ready!
 			MOVEM.L	(SP)+, A0-A1/D0-D2				;Restore registers
+@not32bit
+		ENDIF
 
 		ST		FASTFLAG(A6)					;REMEMBER WE'RE GOING FAST
 
+	IF	HAS_COLOR THEN
 		MOVE	sAscent(A6), topAdjust(A6)		;Get ascent into D0
 		MOVE	TEXTRECT+TOP(A6),D0 			;GET DST TOP
 		SUB 	DSTPIX+BOUNDS+TOP(A6),D0		;CONVERT TO GLOBAL COORDINATES
@@ -1326,6 +1407,19 @@ sFAST
 		_rSwapMMUMode							;get previous mode in d0.b (can trash a0/a1/a2, d0/d1/d2)
 		move.b	d0,MMUsave(a6)					;save previous state for later
 @skip32bit
+	ELSE
+		MOVE	sAscent(A6), topAdjust(A6)
+		MOVE	TEXTRECT+TOP(A6),D0
+		SUB 	PORTBITS+BOUNDS+TOP(A3),D0
+		MULS	PORTBITS+ROWBYTES(A3),D0
+		ADD.L	PORTBITS+BASEADDR(A3),D0
+		MOVE.L	D0,BUFSTART(A6)
+		MOVE	PORTBITS+ROWBYTES(A3),BUFROW(A6)
+		MOVE	PORTBITS+BOUNDS+LEFT(A3),BUFLEFT(A6)
+		PEA 	MINRECT(A6)
+		MOVE.L	PORTBITS+BOUNDS(A3),-(SP)
+		_SHIELDCURSOR
+	ENDIF
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 ;
 ;  Get pointers to location table, width table, and height table in font
@@ -1354,11 +1448,13 @@ fastBlit
 		MOVE	penLoc+H(A6),D4 			;Horz pen location
 		SUB 	D1,D4						;charloc relative to the buffer
 		SWAP	D4							;turn into fixed
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)		;is it a new port?
 		BPL.S	@useOld						;no, set fraction to 1/2
 		MOVE	penLocHFrac(A6),D4			;set up fractional part
 		BRA.S	@goOn
 @useOld
+	ENDIF
 		MOVE	#$8000,D4					;Treat so it will round
 @goOn
 ;———————————————————————-
@@ -1366,10 +1462,15 @@ fastBlit
 ;———————————————————————-
 		MOVEQ	#0, D3						;Init for nextBand to false
 		MOVE.L	cacheHand(A6), A0			;Handle to the cache
+	IF	HAS_COLOR THEN
 		MOVE.L	(A0), D0					;pointer to the cache
 		_StripAddress						;Make sure it is the right mode
 		MOVE.L	D0, D5						;save it for later
 		MOVE.L	D0, A0						;get in address register
+	ELSE
+		MOVE.L	(A0), D5
+		MOVE.L	D5, A0
+	ENDIF
 		LEA		cache.glyphArray(A0), A3	;Get array of glyphs into A0
 	    MOVE.L  widthTabHandle,A0           ;point to width table
         MOVE.L  (A0),A4						;Save pointer to the width table
@@ -1381,6 +1482,7 @@ fastBlit
 	IF HAS_COLOR | SCRIPT_CHAR_EXTRA THEN	;<7> CEL
 		MOVE.L	characterExtra(A6),D1		;add in character extra, if any
 	ENDIF
+	IF	HAS_COLOR THEN
 		CMP.W	#1, destDepth(A6)			;is it 1 deep
 		BEQ.S	@depth1						;Multi-depth blits
 		TST.B	FastFlag(A6)				;If not fast then do 1-bit to buffer		<5>CEL
@@ -1388,6 +1490,7 @@ fastBlit
 		TST.B	orMode(A6)					;If not src or then do 1 bit and buffer
 		BNE		deepChar					;It is deep char
 @depth1
+	ENDIF
 		MOVE.L	A6,-(SP)					;REMEMBER Stack frame ptr
 		BRA.S	NextChar
 doNextBand
@@ -1414,8 +1517,15 @@ renderIt1
 		MOVE.L	A0, A6						;glyphDataPtr in A6
 		BEQ		gotGlyph					;go blit it
 skipBand
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 skipChar
 		ADD.L	0(A4,D3*4),D4 				;GET FIXED POINT WIDTH
+	ELSE
+		ADD.W	D3, D3
+		ADD.W	D3, D3
+skipChar
+		ADD.L	0(A4,D3),D4
+	ENDIF
 	IF HAS_COLOR | SCRIPT_CHAR_EXTRA THEN	;<7> CEL
 		ADD.L	D1,D4						;add in character extra, if any
 	ENDIF
@@ -1474,7 +1584,13 @@ NextChar
 
 		CMP.B	#32,D3						;IS IT A SPACE ?
 		BEQ.S	spaceChar		 			;Skip the char extra
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE.L	0(A3,D3*4),D0				;Get offset to glyph in D3
+	ELSE
+		ADD.W	D3,D3
+		ADD.W	D3,D3
+		MOVE.L	0(A3,D3),D0
+	ENDIF
 		BLE.S	renderIt1					;Must render it
 		ADD.L	D5, D0						;Add in cacheptr address
 		MOVE.L	D0, A6						;glyphrec = cache + offset
@@ -1484,7 +1600,13 @@ NextChar
 		move.l	(sp),a0						; reload the stack frame pointer
 		move.b	lowByte(a0),d0				; double byte character?
 		beq.s	@haveGlyphRecord			; no, skip this
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		move.l	0(a6,d0.w*4),d0				; load glyph record offset
+	ELSE
+		add.w	d0,d0
+		add.w	d0,d0
+		move.l	0(a6,d0.w),d0
+	ENDIF
 		ble.s	renderIt1					; render if error or not cached
 		add.l	d5,d0						; convert offset to pointer
 		move.l	d0,a6						; load glyph record pointer
@@ -1499,7 +1621,11 @@ gotGlyph
 			;••• spot for skipping advance if char banding!!!
 		TST.L	D3							;do not advance since the is more of char
 		BMI.S	@skipAdvance				;another band of char
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		ADD.L	0(A4,D3*4),D4 				;GET FIXED POINT WIDTH
+	ELSE
+		ADD.L	0(A4,D3),D4
+	ENDIF
 	IF HAS_COLOR OR SCRIPT_CHAR_EXTRA THEN	;char extra used in 700 and/or color - not B&W < $700
 		ADD.L	D1,D4						;add in character extra, if any
 	ENDIF
@@ -1741,6 +1867,7 @@ blitJmpTable
 		DC.W	bigLong32-blitJmpTable		;6
 		DC.W	overLong32-blitJmpTable		;8
 	ENDIF
+	IF	HAS_COLOR THEN
 deepChar
 ;———————————————————————————————-
 ; Set up blit function pointers
@@ -2836,6 +2963,7 @@ overLong32
 		ADD.W	D7,A0						;advance to the next dest row
 		DBRA	D3,@mid
 		RTS
+	ENDIF
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 ;		END 32-bit NEW FAST blit loop
 ;————————————————————————————————————————————————————————————————————————————————————————————————
@@ -2863,6 +2991,7 @@ renderIt
 
 		MOVE.L	WidthTabHandle, -(SP)		;2) Push the Width Table Handle onto the stack
 		PEA		fontID(A6)					;1) Push the Glyph Rec Ptr
+	IF	HAS_COLOR THEN
 		TST.B	FASTFLAG(A6)				;if slow no need for 32-bit stuff
 		BEQ.S	@skip32						;
 		TST.B	needs32bit(A6)				;running 32 bit clean
@@ -2877,6 +3006,7 @@ renderIt
 		_rTranslate24To32					;mask off high byte
 		MOVE.L	D0,A2						;SAVE FOR LATER
 		BRA.S	@skip24
+	ENDIF
 @skip32
 		_sbRetrieveGlyph					;Call the routine via SplineDispatch
 		MOVE.L	srcAddr(A6), A2				;Get the address
@@ -2900,15 +3030,24 @@ renderIt
 		MOVE.L	(A0), A0									; get pointer to splineKey globals.
 		MOVE.L	splineKeyRec.cacheHand(A0),A0	; Get the handle in case it changed.
 		MOVE.L	A0, cacheHand(A6)			;restore cacheHand
+	IF	HAS_COLOR THEN
 		MOVE.L	(A0), D0					;pointer to the cache
 		_StripAddress						;Make sure it is the right mode
 		MOVE.L	D0, D5						;restore cache pointer
 		MOVE.L	D0, A0						;
+	ELSE
+		MOVE.L	(A0), D5					;pointer to the cache
+		MOVE.L	D5, A0						;
+	ENDIF
 		LEA		cache.glyphArray(A0), A3	;Get array of glyphs into A3
 ;——————————————————
 		TST.L	(SP)+						;Any Errors
 		MOVEM.L (SP)+, A1/D0-D2				;Restore all registers on return
 		BNE		@skipGlyph
+	IF	NOT HAS_COLOR THEN
+		ADD.W	D3, D3
+		ADD.W	D3, D3
+	ENDIF
 		MOVE.L	entryOffset(A6), D0
 		ADD.L	D0, A0						;point to glyph record
 		MOVEQ	#0,	D0						;No error
@@ -2954,6 +3093,10 @@ renderChar
 ;———————————————————
 		ADDQ	#4,	SP						;Ignore errors				<58-CEL>
 		MOVEM.L (SP)+, D0-D1				;Restore all registers on return
+	IF	NOT HAS_COLOR THEN
+		ADD.W	D5, D5
+		ADD.W	D5, D5
+	ENDIF
 		MOVE.L	entryOffset(A6), D0
 		BEQ		@errExit					;if zero then no info		<58-CEL>
 		ADD.L	D2, D0						;add offset and point to glyph data
@@ -3007,6 +3150,9 @@ Iterate
 		PEA 	INFO(A6)					;PUSH VAR INFO
 		lea		JStdTxMeas,A0				;get piece of trap table
 		move.l	(a0),a0						; <31> DTY changed from move.l
+	IF	NOT HAS_COLOR THEN
+		MOVE.L	(A0),A0
+	ENDIF
 		JSR 	(A0)						;MEASURE TEXT
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————
@@ -3089,8 +3235,15 @@ goBitSetUp
 		clr.l	d2							; no -> clear the high word.
 @0		swap	d2							; move to the high word.
 		move.w	LENGTH(a2),d2				; load the low word too.
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		lea		16(a2,d2.l*2),a0			; load pointer to offset/width table.
 		move.w	0(a0,d0.w*2),d0				; load character offset/width.
+	ELSE
+		add.l	d2,d2
+		lea		16(a2,d2.l),a0
+		add.w	d0,d0
+		move.w	0(a0,d0.w),d0
+	ENDIF
 		cmp.w	#-1,d0						; missing character?
 		bne.s	@1							; no -> skip this.
 		move.w	(a0),d0						; load missing character offset/width.
@@ -3116,16 +3269,20 @@ goBitSetUp
 		MOVEQ	#64,D0						;set it to srcCopy + mask
 @noColors
 		MOVE	D0,locMode(A6)				;initialize copy
+	IF	HAS_COLOR THEN
 		BTST	#6,D0						;bit 6 if set says use a mask
 		SNE		D3							;remember it
 		BEQ.S	@skipMask
 		LEA		srcPix(A6),A0				;assume no mask font needed; just use source instead
 		MOVE.L	A0,maskBitsPtr(A6)			;pass mask to stretch bits
 @skipMask
+	ENDIF
 		BTST	#5,D0						;arithmetic mode?
 		BEQ.S	@skipArith					;if not, don’t map if dest. is 1 bit deep
+	IF	HAS_COLOR THEN
 		CMP		#1,dstPix+pixelSize(A6)		;1 bit deep destination?
 		BNE.S	@multideep					;if not, arithmetic mode is OK
+	ENDIF
 		LEA		ArithMode,A0				;get mode map
 		AND		#7,D0						;look at each different arith mode
 		MOVE.B	0(A0,D0),D0					;map into 1 bit safe mode
@@ -3133,6 +3290,7 @@ goBitSetUp
 @skipArith
 @multideep
 		AND.B	D2,D3						;build mask characters if incoming is not 1 deep
+	IF	HAS_COLOR THEN
 		BEQ.S	@noMask
 		MOVE.L	widTabFont(A1),A0			;Add offset
 		MOVE.L	(A0),D0						;Get pointer
@@ -3148,6 +3306,7 @@ goBitSetUp
 		LEA		maskBits(A6),A0				;pointer to mask bitmap
 		MOVE.L	A0,maskBitsPtr(A6)			;pass mask to stretch bits
 @noMask
+	ENDIF
 		MOVE.B	D3,maskFont(A6)				;0 if mask bit clear, no mask font, or incoming 1 deep
 		OR.B	colorSource(A6),D3			;if color source or mask font, do bit insert/extract
 		MOVE.B	D3,textCopyMode(A6)			;set up bit insert/extract flag
@@ -3202,12 +3361,14 @@ goBitSetUp
 @noMaskMode
 
 		moveq	#0,	d0							; clear the character extra.			<49>
+	IF	HAS_COLOR THEN
 		tst.b	portBits+rowBytes(a3)			; is this an old grafPort?
 		bpl.s	@oldGrafPort					; yes -> skip this.
 		move.w	chExtra(a3),d0					; load the character extra.
 		ext.l	d0								; extend sign bits						<49>
 		asl.l	#4,d0							; convert to 16.16 format.
 @oldGrafPort
+	ENDIF
 	IF SCRIPT_CHAR_EXTRA THEN
 		move.l	grafGlobals(a5),a0				; load quickDraw globals.				<43>
 		add.l	qdChExtra(a0),d0				; add in the character extra.			<43>
@@ -3215,11 +3376,12 @@ goBitSetUp
 		tst.l	d0								; have zero character extra?
 		beq.s	@zeroCharExtra					; yes -> skip call to scale.
 
-		bsr		CalcCharExtra					; scale by point size, etc.
+		jsr		CalcCharExtra					; scale by point size, etc.
 
 @zeroCharExtra
 		move.l	d0,characterExtra(a6)			; store scaled character extra.
 
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)			; is it a new port?
 		BPL.S	@useOld							; no -> don’t set up fraction
 		MOVE	pnLocHFrac(A3),D2				; set up with proper fraction
@@ -3254,6 +3416,7 @@ goBitSetUp
 		TST.L	bkColor(A3)					;if colored source, must worry about bk = white also
 		BRA.S	@oldBackCommon				;share with old mode
 @useOld
+	ENDIF
 		BTST	#5,fgColor+3(A3)			;is the foreground color black?
 		SNE 	D0		 					;set to zero if not
 		TST.B	colorSource(A6)				;is the source multicolored?
@@ -3329,6 +3492,7 @@ NOSLOP
 	;  We will be stretching.  Setup fromRect and toRect and map textR2.
 	;
 		MOVE	stackOffset(A6),D3			;0 if no offset, 2 if word offset
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE.L	NUMER(A6,D3),D0				;GET NUMERATOR
 		SWAP	D0
 		CLR		D0							;make it fixed point
@@ -3337,6 +3501,31 @@ NOSLOP
 		MOVE	Denom+H(A6,D3),D2
 		SWAP	D2
 		DIVU.L	D2,D0:D1					;DIV BY DENOM.H
+	ELSE
+		MOVE.W	D1,D0
+		SWAP	D1
+		MULU.W	NUMER+2(A6,D3),D0
+		MULU.W	NUMER+2(A6,D3),D1
+		TST.W	D0
+		BPL.S	@noCarry
+		ADD.L	#$10000,D0
+@noCarry
+		CLR		D0
+		SWAP	D0
+		ADD.L	D1,D0
+		DIVU.W	DENOM+2(A6,D3),D0
+		MOVE.W	D0,D1
+		CLR		D0
+		DIVU.W	DENOM+2(A6,D3),D0
+		SWAP	D1
+		MOVE.W	D0,D1
+		SWAP	D0
+		ADD.W	D0,D0
+		CMP.W	DENOM+2(A6,D3),D0
+		BLE.S	@noCarry2
+		ADD.L	#1,D1
+@noCarry2
+	ENDIF
 		MOVE.L	PENLOC(A6),D0				;GET PENLOC
 		MOVE.L	D0,TORECT+TOPLEFT(A6)		;SET UP TORECT TOPLEFT
 		ADD.W	NUMER+H(A6,D3),D0			;CALC PENLOC.H + NUMER.H
@@ -3364,10 +3553,12 @@ NOSTRCH
 		move.l	grafGlobals(a5),a0			; load quickDraw globals.
 		add.w	d1,pnLocFixed(a0)			; add width fraction to location fraction.
 	ENDIF
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)		; is it a new port?
 		BPL.S	@useOld						; no, don’t bother with fraction
 		ADD		D1,pnLocHFrac(A3)
 @useOld
+	ENDIF
 		;—————————————————————————————
 		; Move pen by the scaled text width
 		;—————————————————————————————
@@ -3409,7 +3600,11 @@ NOSTRCH
 		MOVE	textR2+right(A6),-(SP)		;preserve existing right
 		MOVE	#32000,textR2+right(A6)		;get right from other rects
 		PEA 	TEXTR2(A6)					;PUSH (MAPPED) TEXTRECT
+	IF	HAS_COLOR THEN
 		PEA 	DSTPIX+BOUNDS(A6)			;PUSH PIXMAP BOUNDS
+	ELSE
+		PEA		PORTBITS+BOUNDS(A3)
+	ENDIF
 		MOVE.L	CLIPRGN(A3),A0				;GET CLIPRGN HANDLE
 		MOVE.L	(A0),A0 					;DE-REFERENCE IT
 		PEA 	RGNBBOX(A0) 				;PUSH CLIPRGN BBOX
@@ -3418,7 +3613,11 @@ NOSTRCH
 		PEA 	RGNBBOX(A0) 				;PUSH VISRGN BBOX
 		MOVE	#4,-(SP)					;PUSH NRECTS=4
 		PEA 	MINRECT(A6) 				;PUSH DST ADDR
+	IF	HAS_COLOR THEN
 		_RSECT								;CALC INTERSECTION
+	ELSE
+		jsrROM	ROMRSect
+	ENDIF
 		BEQ 	GOHOME						;QUIT IF NO INTERSECTION
 		MOVE	(SP)+,textR2+right(A6)		;restore text right
 	;—————————————————————————————————————————————
@@ -3461,6 +3660,7 @@ NOSTRCH
 		MOVEQ	#10,D0
 		CMP 	RGNSIZE(A0),D0				;IS CLIPRGN RECTANGULAR ?
 		BNE		NOTFAST 					;NO, NOT FAST
+	IF	HAS_COLOR THEN
 		MOVEQ	#1,D0
         MOVE    bitShift(A6),D1             ;get the depth of the source map
 		LSL		D1,D0						;turn into 1 … 8
@@ -3473,6 +3673,7 @@ NOSTRCH
 		clr		locmode(a6)					;this essentially alters mode to srcCopy
 		bra		NotFast
 modeok
+	ENDIF
 		MOVE.L	VISRGN(A3),A1				;GET VISRGN HANDLE
 		MOVE.L	(A1),A0 					;DE-REFERENCE IT
 		CMP 	#10,RGNSIZE(A0)				;IS VISRGN RECTANGULAR ?
@@ -3484,9 +3685,16 @@ modeok
 	;———————————————————————————————————————————————————
 		MOVE.L	A1,-(SP)					;PUSH VISRGN
 		PEA 	MINRECT(A6) 				;PUSH MINRECT
+	IF	HAS_COLOR THEN
+		TST.B	is32QD(A6)
+		BEQ.S	@not32bit
 		MOVE.W	#-1, -(SP)					;trim = true for BRUCE
-
+@not32bit
 		_TRIMRECT							;CALL TRIMRECT
+	ELSE
+		jsrROM	ROMTrimRect
+	ENDIF
+
 		BLT 	GOHOME						;quit if intersection empty
 		BGT		NOTFAST 					;continue if non-rectangular
 ;————————————————————————————————————————————————————————————————————————————————————————————————
@@ -3516,7 +3724,9 @@ modeok
 ;
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 FAST
-		IF has32bitQD THEN					;If 32-bit QD was around always we could do this
+		IF HAS_COLOR THEN
+			TST.B	is32QD(A6)
+			BEQ.S	@not32bit
 			MOVEM.L	A0-A1/D0-D2,-(SP)				;Save registers
 @tryAgain	CLR.B	-(SP)					;result
 			MOVE.L	A3, -(SP)				;needs the current grafport
@@ -3544,6 +3754,7 @@ VCLIP	CLR.B	HEIGHTFLAG(A6)					;can't use height table
 		SUB 	MINRECT+TOP(A6),D1				;calc clipped height
 		MOVE.B	D1,TOPHT+1(A6)					;replace TOPHT
 
+	IF	HAS_COLOR THEN
 VCLIPOK MOVE	TEXTRECT+TOP(A6),D0 			;GET DST TOP
 		SUB 	DSTPIX+BOUNDS+TOP(A6),D0		;CONVERT TO GLOBAL COORDINATES
 		MOVE	DSTPIX+ROWBYTES(A6),D1			;GET ROWBYTES
@@ -3589,6 +3800,18 @@ VCLIPOK MOVE	TEXTRECT+TOP(A6),D0 			;GET DST TOP
 		move.l	(sp)+,a2					;restore FontPtr
 		move.b	d0,MMUsave(a6)				;save previous state for later
 @skip32bit
+	ELSE
+VCLIPOK MOVE	TEXTRECT+TOP(A6),D0
+		SUB 	PORTBITS+BOUNDS+TOP(A3),D0
+		MULS.W	6(A3),D0
+		ADD.L	PORTBITS+BASEADDR(A3),D0
+		MOVE.L	D0,BUFSTART(A6)
+		MOVE	6(A3),BUFROW(A6)
+		MOVE	PORTBITS+BOUNDS+LEFT(A3),BUFLEFT(A6)
+		PEA 	MINRECT(A6)
+		MOVE.L	PORTBITS+BOUNDS(A3),-(SP)
+		_SHIELDCURSOR
+	ENDIF
 		BRA 	GETPTRS
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 ;								END FAST case Setup
@@ -3639,9 +3862,17 @@ NOTFAST
 @skipNewTextRect
 	ENDIF
 		MOVE	TEXTRECT+LEFT(A6),D0		;GET TEXTRECT LEFT
+	IF	HAS_COLOR THEN
 		SUB 	DSTPIX+BOUNDS+LEFT(A6),D0	;CONVERT TO GLOBAL
+	ELSE
+		SUB 	PORTBITS+BOUNDS+LEFT(A3),D0
+	ENDIF
 		AND 	#$FFE0,D0					;TRUNC TO LONG BOUND
+	IF	HAS_COLOR THEN
 		ADD 	DSTPIX+BOUNDS+LEFT(A6),D0	;RETURN TO LOCAL COORDS
+	ELSE
+		ADD 	PORTBITS+BOUNDS+LEFT(A3),D0
+	ENDIF
 		MOVE	D0,BUFLEFT(A6)				;REMEMBER FOR LATER
 	;————————————————————————
 	;  Calculate buffer size
@@ -3719,6 +3950,7 @@ NOTFAST
 		ADD.L	D0,D3						;in case vis is nonrectangular
 		LSL		D4,D0						;scale up by source depth
 		ADD.L	D0,D3						;add stretch destination buffer size
+	IF	HAS_COLOR THEN
 		MULU	dstPix+pixelSize(A6),D5		;size of composite mask
 		EXT.L	D5							;$$$ Make it a long
 		ADD.L	D5,D3						;include it
@@ -3760,6 +3992,11 @@ NOTFAST
 		EXT.L	D0							;Make it a long
 		ADD.L	D0,D3						;add stretch mask destination buffer size
 @noMask
+	ELSE
+		EXT.L	D5
+		ADD.L	D5,D3
+		ADD.L	D5,D3
+	ENDIF
 
 	IF (hasSplineFonts) OR (Gaudi) THEN		; <31> DTY
 		TST.B	isSpline(A6)				;Is it a spline
@@ -3785,7 +4022,8 @@ NOTFAST
 	;—————————————————————————————————————————————————
 	;  If stack is too small to allocate buffer(s), then draw half as many characters at a time.
 	;—————————————————————————————————————————————————
-		_StackAvail 						;Get StackAvail IN D0
+		MOVE.L	$594,A0
+		JSR		(A0)						;Get StackAvail IN D0
 		CMP.L	D0,D3						;IS stackNeeded > stackAvail ?
 		BLE		StackAlmost 				;NO, CONTINUE
 		BRA		DoSubDivide
@@ -3796,6 +4034,7 @@ NOTFAST
 	;—————————————————————————————————————————————————
 		MOVE.L	bufSize(A6),D0				;Get size of buffer to initialize
 		ADD.L	#2, D0						;Add 2 padding buffer on each end
+	IF	HAS_COLOR THEN
 		TST.B	maskFont(A6)
 		BEQ.S	@skipMaskAlloc
 		MOVEQ	#0, D1						;clear the long
@@ -3803,6 +4042,7 @@ NOTFAST
 		ADD.L	D1,D0						;Adding in maskSize
 		ADD.L	#2, D0						;Add 2 padding buffer on each end
 @skipMaskAlloc
+	ENDIF
 		TST.B	fmOutShadow(A4)				;Is there shadow
 		BEQ.S 	@noShadBuf					;SKIP IF NO SHADOWING
 		ADD.L	bufSize(A6),D0				;GET NUMBER OF LONGS IN BUF1
@@ -3815,7 +4055,8 @@ NOTFAST
 		MOVE.L	D0, D3						;Save value away
 		CMP.L	#$7000,D3					;is it bigger than 28K? (unit is longs)
 		BGT.S	@otherAlloc					;Try to get memory from other places
-		_StackAvail 						;Get StackAvail IN D0
+		MOVE.L	$594,A0
+		JSR		(A0)						;Get StackAvail IN D0
 		MOVE.L	D3, D2						;get needed space
 		ADD.L	#3346, D2					;make sure there is an extra 2.5k bytes
 		CMP.L	D0,D2						;IS stackNeeded > stackAvail ?
@@ -3844,9 +4085,7 @@ NOTFAST
 		CLR.L	stackHandle(A6)				;Zero out handle
 @skipReSize
 		MOVE.L	D3, D0						;restore size
-		MOVE.L	A4,-(SP)					;save a4 <PN> 
-		BigJSR	GetStyleBufHand,A4			;Expecting size in D0 <PN>
-		MOVE.L	(SP)+,A4					;restore a4  <PN>
+		jsr		GetStyleBufHand				;Expecting size in D0
 		BEQ.S	@subDivide					;go and band
 		MOVE.L	A0, stackHandle(A6)			;save away for later
 @gotMem
@@ -3865,7 +4104,9 @@ NOTFAST
 		_MoveHHi							;Move it high
 		_HLock								;Lock it down for now
 		MOVE.L	(A0), D0					;pointer to the cache
+	IF	HAS_COLOR THEN
 		_StripAddress						;Make sure it is the right mode
+	ENDIF
 		MOVE.L	D0, bufferPtr(A6)			;Save away the buffer pointer
 		MOVE.L	fmOutFontH(A4),A0			;GET FONT HANDLE
 		MOVE.B	fontState(A6), D0			;preserve it until the next change
@@ -3924,16 +4165,20 @@ DoSubDivide
 @noNew
 		MOVE.L	SP, clipStorage(A6)			;Save Address on variable for later cleanup
 		ADD.W	#1, repeatBands(A6)			;Bump up by one
+	IF	HAS_COLOR THEN
 		MOVE.B	HiliteMode,saveHilite(A6)	;save original in case stretch is called multiple times
+	ENDIF
 		MOVE.L	PENLOC(A6),PNLOC(A3)		;RESTORE PNLOC TO ORIGINAL
 	IF hasPenFraction THEN
 		move.l	grafGlobals(a5),a0				; load quickDraw globals.
 		move.w	penLocFixed(a6),pnLocFixed(a0)	; restore fractional pen location.
 	ENDIF
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)		; is it a new port?
 		BPL.S	@useOld2						; no, no fraction to restore
 		MOVE	PenLocHFrac(A6),pnLocHFrac(A3) ;restore fraction if applicable
 @useOld2
+	ENDIF
 		BRA		NOTFAST					;do new divide
 @contNormSplit
 	ENDIF
@@ -3955,7 +4200,9 @@ DoSubDivide
 
 		TST		charsRemain(A6)				;if zero, this is the first time through
 		BNE.S	@notFirst
+	IF	HAS_COLOR THEN
 		MOVE.B	HiliteMode,saveHilite(A6)	;save original in case stretch is called multiple times
+	ENDIF
 		MOVE	D0,charsRemain(A6)			;initialize partial count drawing location
 @notFirst
 		MOVE.L	PENLOC(A6),PNLOC(A3)		;RESTORE PNLOC TO ORIGINAL
@@ -3963,16 +4210,20 @@ DoSubDivide
 		move.l	grafGlobals(a5),a0				; load quickDraw globals.
 		move.w	penLocFixed(a6),pnLocFixed(a0)	; restore fractional pen location.
 	ENDIF
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)		; is it a new port?
 		BPL.S	@useOld						; no, no fraction to restore
 		MOVE	PenLocHFrac(A6),pnLocHFrac(A3) ;restore fraction if applicable
 @useOld
+	ENDIF
 		MOVE	D7,count(A6,D6)				;reset count to draw
 doIterate
 		MOVE.L	grafGlobals(A5),A4			;set up grafGlobals pointer for getting real width
 		MOVE.L	numer2(A6),numer(A6,D6)		;restore numerator
 		MOVE.L	denom2(A6),denom(A6,D6)		;restore denominator
+	IF	HAS_COLOR THEN
 		MOVE.B	saveHilite(A6),HiliteMode	;restore hilite bit
+	ENDIF
 		JMP		Iterate						;draw first half of string
 
 ; draw the second half of the string, but drawing no more characters than could be successfully
@@ -4007,6 +4258,7 @@ secondHalf
 ; ————————————————————————————————————————————————————————————————————————————————————————————
 StackAlmost
 		MOVEQ	#0,D0						;get a long of white
+	IF	HAS_COLOR THEN
 		CMP.W	#16, destDepth(A6)			;get destination bits per pixel
 		BGE.S	@whiteBackCol				;16 or 32 bit will not happen
 		TST		bitShift(A6)				;is source 1 bit?
@@ -4037,6 +4289,7 @@ StackAlmost
 		ADD		#10,SP						;strip RGBColor and long result
 
 @whiteBackCol
+	ENDIF
 		MOVE.L	D0,bkCol(A6)				;save for comparing with background, later
 
 STACKOK
@@ -4055,6 +4308,7 @@ CLRLP	MOVE.L	D0,(A0)+
 		MOVE.L	A0, bufEnd(A6)				;point to end of buffer
 		MOVE.L	D0,(A0)+					;PAD BUFFER WITH AN EXTRA ZERO
 
+	IF	HAS_COLOR THEN
 		TST.B	maskFont(A6)
 		BEQ.S	@noMask
 		CLR.L	(A0)+
@@ -4065,6 +4319,7 @@ CLRLP	MOVE.L	D0,(A0)+
 		CLR.L	(A0)+
 		DBRA	D3,@clrMask
 @noMask
+	ENDIF
 		MOVE.L	A0, currentEnd(A6)			;current end of allocated buffer
 		BRA.S	doneNEW1
 oldAlloc
@@ -4076,6 +4331,7 @@ CLRLOOP MOVE.L	D0,-(SP)
 		DBRA	D3,CLRLOOP					;ALLOCATE AND CLEAR BUFFER
 		MOVE.L	SP,BUFSTART(A6) 			;REMEMBER START OF BUFFER
 		MOVE.L	D0,-(SP)					;PAD BUFFER WITH AN EXTRA ZERO
+	IF	HAS_COLOR THEN
 		TST.B	maskFont(A6)
 		BEQ.S	@noMask
 		MOVE	maskSize(A6),D3
@@ -4086,6 +4342,7 @@ CLRLOOP MOVE.L	D0,-(SP)
 		DBRA	D3,@clrMask
 		MOVE.L	SP,maskStart(A6)
 @noMask
+	ENDIF
 		CLR.L	-(SP)
 doneNEW1
 	ELSE
@@ -4146,7 +4403,12 @@ GETPTRS
 		MOVEQ	#0,D0						;old fonts have negative of ascent here
 @notNegative
 		MOVE	LENGTH(A2),D0				;HOW MANY WORDS IN STRIKE BODY
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		LEA 	16(A2,D0.L*2),A1			;GET START OF WIDTH TABLE
+	ELSE
+		ASL.L	#1,D0
+		LEA 	16(A2,D0.L),A1
+	ENDIF
 		MOVE.L	A1,WIDTAB(A6)				;SAVE FOR LATER
 
 		MOVE	MAXCHAR(A2),D0				;GET MAXCHAR
@@ -4160,7 +4422,12 @@ GETPTRS
 		BEQ.S	NOWID						;NO, CONTINUE
         ADD     D0,D0                       ;SKIP WIDTH TABLE
 NOWID
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		LEA 	0(A1,D0*2),A0 				;POINT TO HEIGHT TABLE
+	ELSE
+		ASL.W	#1,D0
+		LEA 	0(A1,D0),A0
+	ENDIF
 		MOVE.L	A0,HEIGHTAB(A6) 			;SAVE FOR LATER
 
 skipBitTables								;Skipped the bitmap table setup
@@ -4185,10 +4452,12 @@ skipBitTables								;Skipped the bitmap table setup
 	ELSE
 		move.w	#$8000,charLoc+2(a6)			; default fraction to 1/2.
 	ENDIF
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)			; is it a new port?
 		BPL.S	@useOld							; no -> skip this.
 		MOVE	penLocHFrac(A6),CHARLOC+2(A6)	; use saved fraction.
 @useOld
+	ENDIF
 		SUB 	D1,MINRECT+LEFT(A6) 		;MAKE MINRECT.LEFT AND
 		SUB 	D1,MINRECT+RIGHT(A6)		;MINRECT.RIGHT BUFFER RELATIVE
 
@@ -4205,7 +4474,13 @@ MISSING
 		MOVE	MAXMIN(A6),D5				;NO, USE MISSING SYMBOL
 		ADD 	#1,D5						;WHICH IS ONE PAST MAXCHAR
 		MOVE.L	WIDTAB(A6),A0				;POINT TO WIDTH TABLE
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE	0(A0,D5*2),D3 				;GET OFFSET AND WIDTH BYTES
+	ELSE
+		MOVE.W	D5,D3
+		ASL.W	#1,D3
+		MOVE	0(A0,D3),D3
+	ENDIF
      	CMP     #-1,D3                      ;missing?
         BNE		NOTMISS                     ;IS MISSING CHAR MISSING ?
         BRA.S   NEXTCH                      ;YES, SKIP THIS CHAR
@@ -4221,7 +4496,13 @@ NEXTCH	MOVEQ 	#0, D5						;get ready for byte
 		BEQ.S	SPACECH 					;YES, HANDLE IT
 
         MOVE.L  widTabPtr(A6),A0			;Point to the width table
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE.L	0(A0,D5*4),D4 				;GET FIXED POINT WIDTH
+	ELSE
+        MOVE.W	D5,D4
+        ASL.W	#2,D4
+		MOVE.L	0(A0,D4),D4
+	ENDIF
 		ADD.L	characterExtra(A6),D4		;add in character extra, if any
 		SUB 	MINCH(A6),D5				;SUBTRACT SAVED MINCHAR
 		CMP 	MAXMIN(A6),D5				;IS CH BETWEEN MINCHAR AND MAXCHAR ?
@@ -4229,7 +4510,13 @@ NEXTCH	MOVEQ 	#0, D5						;get ready for byte
 
 OKCHAR	MOVE.L	WIDTAB(A6),A0				;POINT TO WIDTH TABLE
 
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE	0(A0,D5*2),D3 				;GET OFFSET AND WIDTH BYTES
+	ELSE
+		MOVE.W	D5,D3
+		ASL.W	#1,D3
+		MOVE	0(A0,D3),D3
+	ENDIF
         CMP     #-1,D3                      ;missing?
         BEQ		MISSING                     ;OFFSET NEG = MISSING CHAR
 
@@ -4240,8 +4527,15 @@ NOTMISS LSR 	#8,D3						;GET OFFSET BYTE
 		MOVE.L	LOCTAB(A6),A0				;POINT TO LOCATION TABLE
 		MOVEQ	#0,D1						; *** clear top word
 
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE	0(A0,D5*2),D1 				;GET SRCLEFT
 		MOVE	2(A0,D5*2),D2 				;GET SRCRIGHT
+	ELSE
+		MOVE.W	D5,D5
+		ASL.W	#1,D5
+		MOVE	0(A0,D5),D1
+		MOVE	2(A0,D5),D2
+	ENDIF
 
 		SUB 	D1,D2						;CALC WIDTH OF BITS
 		BLE		SKIPCH						;SKIP CHARBLT IF WIDTH <= 0
@@ -4251,7 +4545,11 @@ NOTMISS LSR 	#8,D3						;GET OFFSET BYTE
 		TST.B	HEIGHTFLAG(A6)				;does font have height table ?
 		BEQ.S	NOHEIGHT					;no, continue
 		MOVE.L	HEIGHTAB(A6),A0 			;get height table
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE	0(A0,D5*2),TOPHT(A6)		;get this char's top and height
+	ELSE
+		MOVE	0(A0,D5),TOPHT(A6)
+	ENDIF
 NOHEIGHT
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————
@@ -4312,16 +4610,46 @@ HORIZOK
 ;
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 
+	IF	HAS_COLOR THEN
 		MOVEM	D1-D3,maskBlts(A6)
 		MOVE.B	textCopyMode(A6),orNotOK(A6) ;if copy or if mask mode, do bit moves instead of OR
 		ST		notMaskPass(A6)				;use the bitDepth this pass
+	ELSE
+		MOVE.W	D3,D5
+		SUB.W	D1,D5
+		MOVEQ	#15,D0
+		AND.W	D0,D5
+	ENDIF
 
 		MOVE	BUFROW(A6),A3
 		MOVEM.L	SRCROW(A6),A2/A4-A5		;srcRow, srcAddr (src bitmap), bufStart (dst bitmap) <1.4-4april89-CEL>
+	IF	HAS_COLOR THEN
 		MOVE	bitShift(A6),D0				;get font scale factor
 		LSL		D0,D1
 		LSL		D0,D2
 		LSL		D0,D3						;scale up all three
+	ELSE
+		ADD.W	D5,D1
+		ASR.W	#4,D1
+		ADD.W	D1,D1
+		SUB.W	#2,D1
+		ADD.W	D1,A4
+		MOVE.W	D3,D1
+		ASR.W	#4,D1
+		ADD.W	D1,A5
+		ADD.W	D1,A5
+		MOVE.L	-$234(A6),A0
+		AND.W	D0,D3
+		ADD.W	D3,D3
+		MOVE.W	(A0,D3),D3
+		NOT.W	D3
+		MOVE.W	D2,D6
+		AND.W	D0,D2
+		ADD.W	D2,D2
+		MOVE.W	(A0,D2),D4
+		MOVE.L	-$254(A6),A2
+		MOVE.W	-$36(A6),A3
+	ENDIF
 maskBlt
 ;
 ;  Get char height into D7
@@ -4332,6 +4660,7 @@ maskBlt
 ;
 ;  Adjust srcPtr and dstPtr for charTop
 ;
+	IF	HAS_COLOR THEN
 		MOVEQ	#0,D0						;get ready for byte
 		MOVE.B	TOPHT(A6),D0				;get char top
 		MOVE.L	A2,D4						;get srcRow in D-reg
@@ -4340,6 +4669,16 @@ maskBlt
 		MOVE	A3,D4						;get dstRow in D-reg
 		MULU	D0,D4						;calc charTop * dstRow
 		ADD.L	D4,A5						;add to dstPtr
+	ELSE
+		CLR.W	D0
+		MOVE.B	TOPHT(A6),D0
+		MOVE.L	A2,D2
+		MULU.W	D0,D2
+		ADD.L	D2,A4
+		MOVE	A3,D2
+		MULU	D0,D2
+		ADD.L	D2,A5
+	ENDIF
 		BRA		pastBitMapPointers
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————
@@ -4365,7 +4704,9 @@ sGETPTRS
 
 		MOVE.L	cacheHand(A6), A0			;Handle to the cache
 		MOVE.L	(A0), D0					;pointer to the cache
+	IF	HAS_COLOR THEN
 		_StripAddress						;Make sure it is the right mode
+	ENDIF
 		MOVE.L	D0, cachePtr(A6)			;save it for later
 		MOVE.L	D0, A0
 		LEA		cache.glyphArray(A0), A0	;Get array of glyphs into A0
@@ -4383,10 +4724,12 @@ sGETPTRS
 		MOVE	PENLOC+H(A6),D0 			;GET PEN LOCATION
 		SUB 	D1,D0						;MAKE CHARLOC RELATIVE TO BUFLEFT
 		MOVE.W	D0,CHARLOC(A6)				;INIT INT PART OF CHARLOC
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)		;is it a new port?
 		BPL.S	@useOld						;no, set fraction to 1/2
 		MOVE	penLocHFrac(A6),CHARLOC+2(A6) ;set up fractional part		<PB362> BAL
 		BRA.S	@goOn
+	ENDIF
 @useOld
 		MOVE	#$8000,CHARLOC+2(A6)
 @goOn
@@ -4443,10 +4786,24 @@ sNextCh
 	endif
 	
 		MOVE.L  widTabPtr(A6),A0			;Point to the width table
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE.L	0(A0,D5*4),D4 				;GET FIXED POINT WIDTH
+	ELSE
+		MOVE.W	D5,D4
+		ADD.W	D4,D4
+		ADD.W	D4,D4
+		MOVE.L	0(A0,D4),D4
+	ENDIF
 
 		MOVE.L	glyphArray(A6), A0			;Get array of glyphs into A0
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE.L	0(A0,D5*4),D0				;Get offset to glyph in D3
+	ELSE
+		MOVE.W	D5,D0
+		ADD.W	D0,D0
+		ADD.W	D0,D0
+		MOVE.L	0(A0,D0),D0
+	ENDIF
 		BGT		isCached
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 ;							calling _sbRetrieveGlyph
@@ -4469,6 +4826,7 @@ doBand
 
 		MOVE.L	WidthTabHandle, -(SP)		;2) Push the Width Table Handle onto the stack
 		PEA		fontID(A6)					;1) Push the Glyph Rec Ptr
+	IF	HAS_COLOR THEN
 		TST.B	FASTFLAG(A6)				;WERE WE GOING DIRECT TO SCREEN ?
 		BEQ.S	@skip32						;NO, CONTINUE
 		TST.B	needs32bit(A6)				;running 32 bit clean
@@ -4479,6 +4837,7 @@ doBand
 		moveq	#true32b,d0					;switch to 32 bit addressing
 		_rSwapMMUMode						;get previous mode in d0.b (can trash a0/a1/a2, d0/d1/d2)
 		BRA.S	@skip24
+	ENDIF
 @skip32
 		_sbRetrieveGlyph					;Call the routine via SplineDispatch
 @skip24
@@ -4495,7 +4854,14 @@ doBand
 ; restore advance width
 ;——————————————————————
 		MOVE.L  widTabPtr(A6),A0			;Point to the width table
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVE.L	0(A0,D5*4),D4 				;GET FIXED POINT WIDTH
+	ELSE
+		MOVE.W	D5,D4
+		ADD.W	D4,D4
+		ADD.W	D4,D4
+		MOVE.L	0(A0,D4),D4
+	ENDIF
 ;——————————————————————
 		MOVE.L	expandMem,A0								; get low memory expand pointer.
 		MOVE.L	ExpandMemRec.emSplineKey(A0),A0				; get handle to splineKey globals.
@@ -4503,7 +4869,9 @@ doBand
 		MOVE.L	splineKeyRec.cacheHand(A0),A0	; Get the handle in case it changed.
 		MOVE.L	A0, cacheHand(A6)			;restore cacheHand
 		MOVE.L	(A0), D0					;pointer to the cache
+	IF	HAS_COLOR THEN
 		_StripAddress						;Make sure it is the right mode
+	ENDIF
 		MOVE.L	D0, cachePtr(A6)			;restore cache pointer
 		MOVE.L	D0, A2
 		LEA		cache.glyphArray(A2), A0	;Get array of glyphs into A0
@@ -4515,6 +4883,7 @@ doBand
 		MOVE.L	entryOffset(A6), D0
 		ADD.L	D0, A2						;Point to the data
 		MOVE.L	srcAddr(A6), A4				;Get the address
+	IF	HAS_COLOR THEN
 		TST.B	needs32bit(A6)				;running 32 bit clean
 		BEQ.S	@no32						;=>IF NOT, JUST RETURN
 		MOVEM.L	A0-A1/D0-D2,-(SP)			;Save off all registers before JSR
@@ -4523,6 +4892,7 @@ doBand
 		MOVE.L	D0,A4						;SAVE FOR LATER
 		MOVEM.L (SP)+, A0-A1/D0-D2			;Restore all registers on return
 @no32
+	ENDIF
 		MOVE.W	yMax(A6), D6				;Save yMax in D6
 		MOVE.W	scan(A6), D7				;Save the scan lines
 		MOVE.W	yMin(A6), D3				;Get ymin for later
@@ -4539,7 +4909,13 @@ isCached
 		clr.l	d0							; clear a long for the character code
 		move.b	lowByte(a6),d0				; double byte character?
 		beq.s	@haveGlyphRecord			; no, skip this
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		move.l	0(a2,d0.w*4),d0				; load glyph record offset
+	ELSE
+		add.w	d0,d0
+		add.w	d0,d0
+		move.l	0(a2,d0.w),d0
+	ENDIF
 		ble		errorOrNotCached			; fall into common error case
 		move.l	cachePtr(a6),a2				; load pointer to cache
 		add.l	d0,a2						; add offfset for glyph pointer
@@ -4628,6 +5004,7 @@ sfixCharWidth
 		SUB		D3,D0						;so recalculate char width to draw
 		MOVE	D0,charWidth(A6)			;and save this tidbit of info. for later
 sHORIZOK
+	ENDIF				;hasSplineFonts
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 ;							Blit loop for the 68020+ machines
 ;
@@ -4652,6 +5029,7 @@ sHORIZOK
 ;
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		MOVEM	D1-D3,maskBlts(A6)
 		MOVE.B	textCopyMode(A6),orNotOK(A6) ;if copy or if mask mode, do bit moves instead of OR
 		ST		notMaskPass(A6)				;use the bitDepth this pass
@@ -4665,7 +5043,6 @@ smaskBlt
 		ADD.L	D0,A5						;add to dstPtr
 ; Put glyph height - 1 into D7 for blit loop
 ;
-	ENDIF				;hasSplineFonts
 
 
 
@@ -5010,6 +5387,97 @@ offLongLoop
 ;								END Blit loop for the 68020+ machines
 ;————————————————————————————————————————————————————————————————————————————————————————————————
 
+;————————————————————————————————————————————————————————————————————————————————————————————————
+;							Blit loop for the 68000 machines
+;————————————————————————————————————————————————————————————————————————————————————————————————
+	ELSE									;68000
+		MOVE.W	D3,D5
+		SUB.W	D1,D5
+		MOVEQ	#$F,D0
+		AND.W	D0,D5
+		MOVE.W	-$36(A6),A3
+		MOVE.L	-$24C(A6),A5
+		ADD.W	D5,D1
+		ASR.W	#4,D1
+		ADD.W	D1,D1
+		SUB.W	#2,D1
+		ADD.W	D1,A4
+		MOVE.W	A3,D1
+		MULS.W	D1,D4
+		ADD.L	D4,A5
+		MOVE.W	D3,D1
+		ASR.W	#4,D1
+		ADD.W	D1,A5
+		ADD.W	D1,A5
+		MOVE.L	-$234(A6),A0
+		AND.W	D0,D3
+		ADD.W	D3,D3
+		MOVE.W	(A0,D3),D3
+		NOT.W	D3
+		MOVE.W	D2,D6
+		AND.W	D0,D2
+		ADD.W	D2,D2
+		MOVE.W	(A0,D2),D4
+pastBitMapPointers
+		ASR.W	#4,D6
+		SUB.W	D1,D6
+		BEQ.S	@5
+		SUB.W	#1,D6
+		BEQ.S	@3
+		ADDQ.W	#1,D7
+		BRA.S	@2
+@1
+		MOVE.L	(A4),D0
+		ADDQ.W	#2,A4
+		LSR.L	D5,D0
+		AND.W	D1,D0
+		OR.W	D0,(A5)+
+		MOVEQ	#-1,D1
+		DBRA	D2,@1
+		MOVE.L	(A4),D0
+		LSR.L	D5,D0
+		AND.W	D4,D0
+		OR.W	D0,(A5)
+		MOVE.L	-$46(A6),A4
+		ADD.L	A2,A4
+		MOVE.L	-$4A(A6),A5
+		ADD.W	A3,A5
+@2
+		MOVE.L	A4,-$46(A6)
+		MOVE.L	A5,-$4A(A6)
+		MOVE.W	D3,D1
+		MOVE.W	D6,D2
+		DBRA	D7,@1
+		BRA.S	decCount
+@3
+		SUB.W	#2,A3
+@4
+		MOVE.L	(A4),D0
+		LSR.L	D5,D0
+		AND.W	D3,D0
+		OR.W	D0,(A5)+
+		MOVE.L	2(A4),D0
+		LSR.L	D5,D0
+		AND.W	D4,D0
+		OR.W	D0,(A5)
+		ADD.L	A2,A4
+		ADD.W	A3,A5
+		DBRA	D7,@4
+		BRA.S	decCount
+@5
+		AND.W	D4,D3
+@6
+		MOVE.L	(A4),D0
+		LSR.L	D5,D0
+		AND.W	D3,D0
+		OR.W	D0,(A5)
+		ADD.L	A2,A4
+		ADD.W	A3,A5
+		DBRA	D7,@6
+	ENDIF									;68000
+;————————————————————————————————————————————————————————————————————————————————————————————————
+;								END Blit loop for the 68000 machines
+;————————————————————————————————————————————————————————————————————————————————————————————————
 
 decCount
 	IF (hasSplineFonts) OR (Gaudi) THEN		; <31> DTY
@@ -5028,6 +5496,7 @@ decCount
 
 STRDONE
 		MOVE.L	SAVEA5(A6),A5				;RESTORE GLOBAL PTR
+	IF	HAS_COLOR THEN
 		TST.B	FASTFLAG(A6)				;WERE WE GOING DIRECT TO SCREEN ?
 		BEQ.S	@1							;NO, CONTINUE
 		TST.B	needs32Bit(A6)				;device need 32-bit addressing <7Apr90 KON>
@@ -5036,6 +5505,10 @@ STRDONE
 		_rSwapMMUMode						;get previous mode in d0.b (can trash a0/a1/a2, d0/d1/d2)
 @0		tst.b	crsrFlag(a6)				;is dst to a screen <7Apr90 KON>
 		beq.s	@NoShow						;no, then don't show cursor
+	ELSE
+		tst.b	FastFlag(a6)
+		beq.s	@1
+	ENDIF
 		_SHOWCURSOR							;YES, RESTORE CURSOR
 @NoShow	BRA 	GOHOME						;AND QUIT
 @1		MOVE.L	GRAFGLOBALS(A5),A0			;POINT TO QUICKDRAW GLOBALS
@@ -5075,10 +5548,15 @@ NXTBOLD DBRA	D2,BOLDIT					;LOOP FOR EACH OVERSTRIKE
 		MOVE.L	BUFEND(A6),A1				;DSTPTR:=END OF BUFFER
 		MOVE	BUFROW(A6),D3				;GET BUFFER ROWBYTES
 		SUB 	D3,A1						;BACK UP DSTPTR TO END OF 2ND ROW
+	IF	HAS_COLOR THEN
 		LSR 	#2,D3						;LONGCNT:=ROWBYTES DIV 4
+	ELSE
+		LSR 	#1,D3
+	ENDIF
 		SUB 	#1,D3						;LONGCOUNT-1 FOR DBRA LOOP
 		MOVE	sHeight(A6),D6				;INIT ROW COUNTER
 		SUB		#1,D6						;Baseline not slanted				<38>
+	IF	HAS_COLOR THEN
 		MOVEQ	#0,D4						;INIT OFFSET
 		BRA.S	DOSLANT 					;GO TO LOOP START
 NXTROW	ADD.L	D2,D4						;OFFSET:=OFFSET+ITALIC
@@ -5087,11 +5565,35 @@ NXTROW	ADD.L	D2,D4						;OFFSET:=OFFSET+ITALIC
 		NEG.L	D5							;make negative for BFEXTU
 		MOVE.L	A1,A0						;SRCPTR:=DSTPTR
 		SUB 	#4,A0						;POINT TO LAST LONG
+	ELSE
+		CLR		D4
+		BRA.S	DOSLANT
+NXTROW	ADD		D2,D4
+		MOVE	D4,D0
+		LSR		#4,D0
+		MOVEQ	#$F,D5
+		AND.W	D0,D5
+		LSR		#4,D0
+		MOVE.L	A1,A0
+		SUB		#4,A0
+		SUB.W	D0,A0
+		SUB.W	D0,A0
+	ENDIF
 
 		MOVE	D3,D1						;INIT LOOP TO LONGCNT
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 NXTLONG BFEXTU	(A0){D5:0},D0 				;GET A SHIFTED LONG OF SRC
 		SUB 	#4,A0						;BUMP SRCPTR LEFT ONE LONG
+	ELSE
+NXTLONG MOVE.L	(A0),D0 					;GET A SHIFTED LONG OF SRC
+		SUB 	#2,A0						;BUMP SRCPTR LEFT ONE LONG
+		LSR.L	D5,D0
+	ENDIF
+	IF	HAS_COLOR THEN
 		MOVE.L	D0,-(A1)					;STORE IN DST AND BUMP DSTPTR
+	ELSE
+		MOVE.W	D0,-(A1)
+	ENDIF
 		DBRA	D1,NXTLONG					;LOOP ALL LONG THIS ROW
 DOSLANT DBRA	D6,NXTROW					;LOOP FOR ALL ROWS IN BUFFER
 
@@ -5157,8 +5659,13 @@ UL2 	MOVE.L	-(A3),D0					;GET FROM TEMP
 ;  Setup fakeRgn, a dummy rectangular region
 ;
 NOTUL	MOVE	#10,FAKERGN+RGNSIZE(A6) 	;SIZE=10 BYTES FOR RECT RGN
+	IF	HAS_COLOR THEN
 		MOVE.L	DSTPIX+BOUNDS(A6),FAKERGN+RGNBBOX(A6)
 		MOVE.L	DSTPIX+BOUNDS+4(A6),FAKERGN+RGNBBOX+4(A6)
+	ELSE
+		MOVE.L	PORTBITS+BOUNDS(A3),FAKERGN+RGNBBOX(A6)
+		MOVE.L	PORTBITS+BOUNDS+4(A3),FAKERGN+RGNBBOX+4(A6)
+	ENDIF
 	IF (hasSplineFonts) OR (Gaudi) THEN		; <31> DTY
 		TST.B	isSpline(A6)				;is it a spline
 		BEQ.S	@skipBandClip				;
@@ -5236,6 +5743,7 @@ NOTUL	MOVE	#10,FAKERGN+RGNSIZE(A6) 	;SIZE=10 BYTES FOR RECT RGN
 	ELSE									;
 		MOVE.L	TEXTRECT+BOTRIGHT(A6),(A0)+	;SET UP BOTTOM RIGHT
 	ENDIF									;
+	IF	HAS_COLOR THEN
 		LEA		SRCPIX(A6),A2
 		_BitsToPix
 		TST.B	maskFont(A6)
@@ -5312,6 +5820,7 @@ NOTUL	MOVE	#10,FAKERGN+RGNSIZE(A6) 	;SIZE=10 BYTES FOR RECT RGN
 		BEQ.S	@skipColorJam				;														<CEL-44>
 		MOVE.L	D0,srcPix+pmTable(A6) 		;set up color table, if any								<CEL-44>
 @skipColorJam
+	ENDIF
 
 ;
 ;  check if any shadowing:
@@ -5453,10 +5962,12 @@ DOWN2	MOVE.L	-(A0),D0					;GET A LONG FROM LINE ABOVE
 @1
 
 		PEA 	SRCBITS(A6) 				;PUSH SRCPIX
+	IF	HAS_COLOR THEN
 		MOVE.L	maskBitsPtr(A6),-(SP)		;a mask?
 		BEQ.S	@noMask
 		MOVE.L 	4(SP),(SP)					;replace mask with copy of source
 @noMask
+	ENDIF
 		PEA		PORTBITS(A3)				;TRANSFER TO SCREEN
 
 	IF Gaudi THEN							;fix intersection if ColorQD and Bass init
@@ -5485,7 +5996,9 @@ DOWN2	MOVE.L	-(A0),D0					;GET A LONG FROM LINE ABOVE
 		BRA.S	@contArgs
 	ENDIF
 @doOld	PEA 	SRCRECT(A6)					;PUSH SRCRECT = TEXTRECT
+	IF	HAS_COLOR THEN
 		PEA		SRCRECT(A6)					;maskRect same as source rect
+	ENDIF
 		PEA 	DSTRECT(A6)					;PUSH DSTRECT = TEXTR2
 @contArgs
 		MOVE	locMode(A6),-(SP)			;PUSH TEXTMODE
@@ -5493,12 +6006,19 @@ DOWN2	MOVE.L	-(A0),D0					;GET A LONG FROM LINE ABOVE
 		BEQ.S	@noDither					;							<CEL-39>
 		OR.W	#$40, (SP)					;Or in the dither bit		<CEL-39>
 @noDither
+	IF	HAS_COLOR THEN
 		CLR.L	-(SP)						;NO PATTERN FOR NOW
 		MOVE.L	CLIPRGN(A3),-(SP)			;PUSH CLIPRGN HANDLE
 		MOVE.L	VISRGN(A3),-(SP)			;PUSH VISRGN HANDLE
 		PEA 	FAKEPTR(A6) 				;PUSH FAKE HANDLE
 		CLR		-(SP)						;pass multicolor flag false
 		_StretchBits 						;TRANSFER BUFFER TO SCREEN
+	ELSE
+		MOVE.L	CLIPRGN(A3),-(SP)			;PUSH CLIPRGN HANDLE
+		MOVE.L	VISRGN(A3),-(SP)			;PUSH VISRGN HANDLE
+		PEA 	FAKEPTR(A6) 				;PUSH FAKE HANDLE
+		DC.W	$AB27
+	ENDIF
 
 ; if old port, srcOr, draw center part in bic; if bic, in srcOr
 ; (This is done for compatibility with older applications like MacProject and MacDraw that
@@ -5528,8 +6048,12 @@ DOWN2	MOVE.L	-(A0),D0					;GET A LONG FROM LINE ABOVE
 ;  Push params and call StretchBits to transfer buffer to screen
 ;
 NOSHAD
+	IF	HAS_COLOR THEN
 		PEA 	SRCPIX(A6) 					;PUSH SRCBITS
 		MOVE.L	maskBitsPtr(A6),-(SP)		;may be 0 if no mask bitmap
+	ELSE
+		PEA		SRCBITS(A6)
+	ENDIF									;HAS_COLOR
 		PEA		PORTBITS(A3)				;TRANSFER TO SCREEN
 
 
@@ -5556,7 +6080,9 @@ NOSHAD
 		BRA.S	@contArgs
 	ENDIF
 @doOld	PEA 	TEXTRECT(A6)				;PUSH SRCRECT = TEXTRECT
+	IF	HAS_COLOR THEN
 		PEA		TEXTRECT(A6)				;maskRect same as source rect
+	ENDIF									;HAS_COLOR
 		PEA 	TEXTR2(A6)					;PUSH DSTRECT = TEXTR2
 @contArgs
 
@@ -5565,6 +6091,7 @@ NOSHAD
 		BEQ.S	@noDither					;							<CEL-39>
 		OR.W	#$40, (SP)					;Or in the dither bit		<CEL-39>
 @noDither
+	IF	HAS_COLOR THEN
 		CLR.L	-(SP)						;NO PATTERN FOR NOW
 		MOVE.L	CLIPRGN(A3),-(SP)			;PUSH CLIPRGN HANDLE
 		MOVE.L	VISRGN(A3),-(SP)			;PUSH VISRGN HANDLE
@@ -5583,6 +6110,12 @@ NOSHAD
 @callStretch
 		move.w	d0,-(sp)					; push drawFlags					<08JUN92 SAH>
 		_StretchBits 						;TRANSFER BUFFER TO SCREEN
+	ELSE
+		MOVE.L	CLIPRGN(A3),-(SP)
+		MOVE.L	VISRGN(A3),-(SP)
+		PEA 	FAKEPTR(A6)
+		DC.W	$AB27
+	ENDIF
 
 ;——————————————————————————————————————————————————————————————————————————————————————————————————————
 ;		We are done so let’s cleanup…
@@ -5615,11 +6148,13 @@ GOHOME
 		move.l	grafGlobals(a5),a0				; load quickDraw globals.
 		move.w	penLocFixed(a6),pnLocFixed(a0)	; restore fractional pen location.
 	ENDIF
+	IF	HAS_COLOR THEN
 		TST		PORTBITS+ROWBYTES(A3)		; is it a new port?
 		BPL.S	@useOld3					; no, no fraction to restore
 		MOVE	PenLocHFrac(A6),pnLocHFrac(A3) ;restore fraction if applicable
 @useOld3
 		MOVE.B	saveHilite(A6),HiliteMode	;restore hilite bit
+	ENDIF
 
 		SUBQ.W	#1, repeatBands(A6)			;Decrement band count
 		ADDQ.L	#4, clipStorage(A6)			;Bump by a long for next top and Bottom clip
@@ -5638,17 +6173,29 @@ GOHOME
 		MOVE	D0,charsRemain(A6)			;if iterative, this will be greater than zero
 		BGT		secondHalf					;so there are more characters to draw
 @cleanUp
+	IF	HAS_COLOR THEN
 		BSET	#hiliteBit,HiliteMode		;reset hilite override, in case colormap was skipped
+	ENDIF
 		MOVEM.L (SP)+,D0-D7/A1-A4			;RESTORE REGS
 		TST.W	stackOffset(A6)				;was the stack aligned?
 		UNLK	A6
 		BEQ.S	@skipAlign
 		ADDQ	#2,SP
 @skipAlign
+	IF	&SETTING('MACHINE') <> 'MC68000' THEN
 		RTD		#PARAMSIZE					;Return and pop the stack		<1.6-11april89-CEL>
+	ELSE
+		MOVE.L	(SP)+,A0
+		LEA		PARAMSIZE(SP),SP
+		JMP		(A0)
+	ENDIF
 	ENDPROC
 
+	IF	HAS_COLOR THEN
 CalcCharExtra PROC  EXPORT
+	ELSE
+CalcCharExtra PROC  ENTRY
+	ENDIF
 
 ;------------------------------------------
 ;
diff --git a/QuickDraw/FastTraps.a b/QuickDraw/FastTraps.a
--- a/QuickDraw/FastTraps.a
+++ b/QuickDraw/FastTraps.a
@@ -7,10 +7,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	 10/6/93	SAM		The QDExtensions macros were not setting the upper word of the
-;									selector (what contains the param count for each routine).  This
-;									confused the native dispatcher.  The macros have been updated to
-;									contain the full longword of info in D0.
 ;	   <SM4>	 10/13/92	CSS		Nop calls if the machine doesn't support 24 bit mode
 ;									(SwapMMUMode and StripAddress).
 ;		 <8>	 7/26/92	DTY		Add fast traps for DeviceLoop and GetGray to get the ROM
@@ -1098,115 +1094,115 @@ selectGetGray			equ		25
 		
 				MACRO
 				_NewGWorld
-				MOVE.L	#$160000,D0
+				MOVEQ	#$0,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_LockPixels
-				MOVE.L	#$40001,D0
+				MOVEQ	#$1,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_UnlockPixels
-				MOVE.L	#$40002,D0
+				MOVEQ	#$2,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_UpdateGWorld
-				MOVE.L	#$160003,D0
+				MOVEQ	#$3,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_DisposeGWorld
-				MOVE.L	#$40004,D0
+				MOVEQ	#$4,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_GetGWorld
-				MOVE.L	#$80005,D0
+				MOVEQ	#$5,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_SetGWorld
-				MOVE.L	#$80006,D0
+				MOVEQ	#$6,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_CTabChanged
-				MOVE.L	#$40007,D0
+				MOVEQ	#$7,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_PixPatChanged
-				MOVE.L	#$40008,D0
+				MOVEQ	#$8,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_PortChanged
-				MOVE.L	#$40009,D0
+				MOVEQ	#$9,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_GDeviceChanged
-				MOVE.L	#$4000A,D0
+				MOVEQ	#$A,D0
 				_QDExtensions
 				ENDM
 		
 				MACRO
 				_AllowPurgePixels
-				MOVE.L	#$4000B,D0
+				MOVEQ	#$B,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_NoPurgePixels
-				MOVE.L	#$4000C,D0
+				MOVEQ	#$C,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_GetPixelsState
-				MOVE.L	#$4000D,D0
+				MOVEQ	#$D,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_SetPixelsState
-				MOVE.L	#$8000E,D0
+				MOVEQ	#$E,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_GetPixBaseAddr
-				MOVE.L	#$4000F,D0
+				MOVEQ	#$F,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_NewScreenBuffer
-				MOVE.L	#$E0010,D0
+				MOVEQ	#$10,D0
 				_QDExtensions
 				ENDM
 				
 				MACRO
 				_DisposeScreenBuffer
-				MOVE.L	#$40011,D0
+				MOVEQ	#$11,D0
 				_QDExtensions
 				ENDM
 		
 				MACRO
 				_GetGWorldDevice
-				MOVE.L	#$40012,D0
+				MOVEQ	#$12,D0
 				_QDExtensions
 				ENDM
 		
@@ -1214,7 +1210,7 @@ selectGetGray			equ		25
 		
 				MACRO
 				_QDDone
-				MOVE.L	#$40013,D0
+				MOVEQ	#$13,D0
 				_QDExtensions
 				ENDM
 		
diff --git a/QuickDraw/GDevice.a b/QuickDraw/GDevice.a
--- a/QuickDraw/GDevice.a
+++ b/QuickDraw/GDevice.a
@@ -13,12 +13,6 @@
 ;									devices.
 ;	   <SM4>	  4/8/93	IH		Add some comments on Display Manager assumptions about
 ;									InitGDevice to InitGDevice header.
-;	   <SM3>	  2/4/93	CSS		Update from Horror:
-;		<H2>	 7/10/92	SWC		Made a change to GetDevPixMap to fix a problem with fixed
-;									devices. It was generating a new ctSeed unconditionally, which
-;									caused problems with the IconUtilities package since the Palette
-;									Manager would say that the tolerance between the device's and
-;									system CLUTs wasn't close enough to draw a multi-bit icon.
 ;	   <SM2>	 6/11/92	stb		<sm 6/9/92>stb Synched with QDciPatchROM.a, added comments to
 ;									DisposGDevice and InitGDevice.
 ;		 <8>	 7/24/90	gbm		get rid of stupid branch
@@ -782,17 +776,11 @@ GetFromSlot	MOVE.B	#mTable,spID(A0)			; the fixed table							<2.3>
 			MOVE.L	A1,spResult(A0)				; put handle in destination					<2.3>
 			_sReadStruct						; read the table from the ROM				<2.3>
 
-;••• <SM3> CSS rollin patch GetDevPixMapPatch from horror
-			MOVE.L	ctSeed(A1),D0				; get the current seed						<H2>
-			BEQ.S	@GetNewSeed					; -> it's zero, so generate a new one		<H2>
-			CMPI.L	#minSeed,D0					; is it a resource ID?						<H2>
-			BLE.S	@UseOriginalSeed			; -> yes, assume we know what we're doing	<H2>
 @GetNewSeed	SUBQ	#4,SP						; make room for function result				<2.3>
 			_rGetCTSeed							; get a new, unique ctable seed				<2.3>
 			MOVE.L	(SP)+,ctSeed(A1)			; put in the new seed						<2.3>
 @UseOriginalSeed
 												;   transindex/ctflags set below			<2.3>
-;••• <SM3> CSS end rollin GetDevPixMapPatch from Horror
 
 			MOVE.L	A4,spsPointer(A0)			; Restore the pointer to mode list.			<C742>
 			bra.s	TableOK
diff --git a/QuickDraw/GWorld.a b/QuickDraw/GWorld.a
--- a/QuickDraw/GWorld.a
+++ b/QuickDraw/GWorld.a
@@ -7,9 +7,6 @@
 ;
 ;	   <SM5>	 9/12/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM4>	 6/14/93	kc		Roll in Ludwig.
-;	   <LW2>	 3/25/93	fau		Made the NewGWorld call allocate a buffer whose width is a whole
-;									number of quadwords, in order to help digitizer grabs.
 ;	   <SM3>	10/28/92	SWC		Replaced obsolete INCLUDEd filenames with their replacements.
 ;	   <SM2>	 6/11/92	stb		<sm 6/9/92>stb Synch with QDciPatchROM.a; added comments to
 ;									NewGWorld, UpdateGWorld, Pixmap32Bit, GetGWorldPixMap,
@@ -900,12 +897,6 @@ allocateBuffer
 		addq	#1,d0						; add one long as per simplified formula above
 		lsl.l	#2,d0						; convert longs to bytes
 
-; Make buffer's width quad longword aligned on both ends.  This will help when doing 
-; video digitizer grabs on Cyclone.
-
-		addi.l	#15,d0						; Add 15 bytes to make it to the next quad-w boundary 	<LW2>fau
-		andi.b	#$f0,d0						; Chop the remainder									<LW2>fau
-		
 		move	d0,bytesPerRow(a6)			; save # of bytes in a row
 
 		move	localRect+bottom(a6),d1		; compute height of rectangle
diff --git a/QuickDraw/PaletteMgr.a b/QuickDraw/PaletteMgr.a
--- a/QuickDraw/PaletteMgr.a
+++ b/QuickDraw/PaletteMgr.a
@@ -9,18 +9,9 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM11>	10/28/93	SAH		Rolled out change SM9 because it brought out bugs in the font
-;									manager. Rolled out change 14 because it caused the bug that
-;									caused change SM9. Both of these are correct changes, we just
-;									need to take them out until FlushFonts really flushes ALL the
-;									fonts (for all processes)...
 ;	  <SM10>	10-19-93	jmp		Removed the ctSeed whacking (Kon explained the error of my
 ;									ways).  We’ll have to come up with some other method to fix
 ;									dimming.
-;	   <SM9>	 9/20/93	SAH		Fixed a bug in ActivatePalette where it would always mark black
-;									or white tolerant entries as handled. It really needed to make
-;									sure they weren't explicit as well.
-;	   <SM8>	 9/13/93	SAM		Added a "code" to PMExit to call _TrashProcess (HeapUtilities).
 ;	   <SM7>	08-03-93	jmp		Changed the SetDepth code so that the MenuBar gets redrawn first
 ;									after a depth switch.  This is the way the pre-System7 Monitors
 ;									'cdev' did things.  And it looks much nicer.
@@ -622,17 +613,6 @@ linkSize	DS.B		0						; linky number
 			WITH	PXVars
 			LINK	A6,#linkSize
 
-			movem.l	a0-a2/d0-d2,-(sp)		; Those pesky c routines					<mc8>
-			sub.l	a0,a0					; Pass the current process (0)
-			move.w	#12,d0					; _TrashProcess
-			;_FigmentDispatch				; let everyone know this stuff is gone
-			dc.w	$A0A4
-			movem.l	(sp)+,a0-a2/d0-d2		; Restore em
-
-		IF (forRom OR theFuture) THEN
-			MOVE.l	WindowList,wList(A6)	; <SM2> FM save the current window list
-		ENDIF
-		
 			TST.B	QDExist					; if InitGraf has not been called yet…
 			BNE.S	@doNothing				; (a5) not valid and there is nothing to do
 			CMP.L	#PMgrNil,PMgrHandle		; If the palette manager doesnt exist...
@@ -667,7 +647,7 @@ linkSize	DS.B		0						; linky number
 			JSR		CheckAllDeviceCluts		; A pretty simple patch, really.
 			CLR		-(SP)					; No Setentries on Scatter
 			JSR		ScatterDevices
-			BSR		CheckForJuggler			; Is Jugglertm active?
+			BSR.S	CheckForJuggler			; Is Jugglertm active?
 			BNE.S	@doNothing				; No=>WMgr is void, next line dangerous
 			JSR		UpdateDevices
 			MOVE.L	mainDevice,theGDevice
@@ -1243,14 +1223,7 @@ Correlate	PROC	EXPORT
 			MOVE.L	(A3),A3					; A3-> device colortable
 			CLR.L	D3						; Clear the upper bits, for BF ops
 ExplLoop	MOVE	ciUsage(A2),D7			; D7 = usage of this entry
-	if 0 then
-		; <SAH 28OCT93>
-		; I'm taking this code out for now. It causes us to not add entries that we used to add. This code
-		; is not installed for IIci ROMs. It only began being installed for SuperMario. By taking it out we
-		; bring the palette manager back to the Quadra Rom but bring back a bug with tolerant+explicit+
-		; inhibited...
 			BMI.S	ExplLoopEnd				; Already handled?
-	endif
 			BTST	#TolerantBit,D7			; A Tolerator?
 			BEQ.S	ExplLoopEnd				; No, try next
 			BTST	#ExplicitBit,D7			; Explicit Tolerator?
@@ -4631,7 +4604,7 @@ linkSize	DS.B		0							; size of record
 			WITH		SDVars
 			
 			LINK		A6,#linkSize
-			MOVEM.L		A2-A3/D3-D5,-(SP)			;												<6>
+			MOVEM.L		A2/D3-D5,-(SP)				;												<6>
 
 			MOVE		#paramErr,result(A6) ; default to failure!
 
@@ -4660,11 +4633,7 @@ linkSize	DS.B		0							; size of record
 			MOVE		(SP)+,D4					; did we find one?
 			BEQ			@goHome
 
-@gotMode	Movea.l		gd(A6),A2					; Get GDHandle into A2.
-			Movea.l		(A2),A2						; Get a GDPtr into A2.
-			Btst		#mainScreen,gdFlags(A2)		; If we’re not on the menubar screen,
-			Beq.s		@NotMain1					;	then just keep going.
-			Move.w		theMenu,D5					; Get the currently hilited menuID.
+@gotMode	Move.w		theMenu,D5					; Get the currently hilited menuID.
 			Clr.w		-(Sp)						; And unhilite it.
 			_HiliteMenu
 @NotMain1
@@ -4687,12 +4656,8 @@ linkSize	DS.B		0							; size of record
 			MOVE.L		gd(A6),-(SP)				; push the handle
 			_InitGDevice
 
-			Btst		#mainScreen,gdFlags(A2)		; If we’re not on the menubar screen,
-			Beq.s		@NotMain2					;	then just keep going.
 			Move.w		D5,-(Sp)					; Get the hilite state.
 			_HiliteMenu								; Restore it.
-			_DrawMenuBar							; Draw the MenuBar.
-@NotMain2
 
 			CLR.L		-(SP)						; Activate the front palette
 			_FrontWindow							; before drawing anything.
diff --git a/QuickDraw/Patches/AllB&WQDPatch.a b/QuickDraw/Patches/AllB&WQDPatch.a
--- a/QuickDraw/Patches/AllB&WQDPatch.a
+++ b/QuickDraw/Patches/AllB&WQDPatch.a
@@ -2305,4 +2305,10 @@ JShowCursor		EQU		$0804					;this shouldn't be here
 
 ; ---------------------------------------------------------------------------
 
+		CASE		OBJ
+		ROMs		Plus,SE,Portable
+		MakePatch	BWStdText,_StdText				; {Sources}QuickDraw:Classic:Text.m.a
+		MakePatch	BWStdTxMeas,_StdTxMeas			; {Sources}QuickDraw:Classic:Text.m.a
+		MakePatch	BWMeasureText,_MeasureText		; {Sources}QuickDraw:Classic:Text.m.a
+
 				END
diff --git a/QuickDraw/Patches/QuickDrawPatches.a b/QuickDraw/Patches/QuickDrawPatches.a
--- a/QuickDraw/Patches/QuickDrawPatches.a
+++ b/QuickDraw/Patches/QuickDrawPatches.a
@@ -2601,4 +2601,10 @@ GoBack	MOVE.L	SAVESTK2(A6),SP				;RESTORE STACK POINTER
 
 		ENDPROC
 		
+		CASE		OBJ
+		ROMs		II,IIci
+		MakePatch	StdText,_StdText				; {Sources}QuickDraw:Text.a
+		MakePatch	StdTxMeas,_StdTxMeas			; {Sources}QuickDraw:Text.a
+		MakePatch	MeasureText,_MeasureText		; {Sources}QuickDraw:Text.a
+
 			END
diff --git a/QuickDraw/Patterns.a b/QuickDraw/Patterns.a
--- a/QuickDraw/Patterns.a
+++ b/QuickDraw/Patterns.a
@@ -12,8 +12,6 @@
 ;
 ;	   <SM8>	 9/12/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM7>	 1/15/93	kc		Change JSR to JMP to fix bug introduced in last checkin.
-;	   <SM6>	 1/13/93	kc		Change BSR ot JSR to appease the Linker gods.
 ;	   <SM4>	 8/18/92	CSS		Update from Reality:
 ;									<16> 8/18/92 SAH	#1040323 <KON>: Fixed Indexed SeedCFill bug by making
 ;														MakeScaleTbl check to see if fg color is black and bg color is
@@ -119,7 +117,7 @@ GetCCursor	PROC	EXPORT
 			MOVE	4(SP),D0				; get the cursor's resource ID
 			MOVE.L	#'crsr',D1				; get the desired resource type
 			MOVEQ	#CRSRRec,D2				; get size of cursor record
-			JMP		PATSHARE
+			BRA.S	PATSHARE
 			NOP								; silence the assembler <13>
 
 
diff --git a/QuickDraw/Pictures.a b/QuickDraw/Pictures.a
--- a/QuickDraw/Pictures.a
+++ b/QuickDraw/Pictures.a
@@ -14,11 +14,6 @@
 ;									DrawPicture, XTXFONT, TXRATIO, AddFontToTbl, LineLayout,
 ;									GlyphState, BITSOP, tryBands, PutPicVerb, UpdatePat, DONEW,
 ;									NEWPP, PutPicPixPat, PutDirectPMData.
-;	   <SM2>	 4/15/92	RB		Rolled in patch to DrawPicture from QuickDrawPatches.a. Save and
-;									restore global info so DrawPicture is reentrant. Do not draw
-;									purged Picture Handles and mark Handles non purgeable before
-;									doing the DrawPicture. This fixes bugs in balloon help while
-;									printing, and a bug in ResEdit while printing in the background.
 ;		<43>	 10/2/91	DTY		Conditionalise last change for TheFuture.
 ;		<42>	 10/1/91	KON		Bail on picture playback if StdGetPic an AbortPicPlayBackErr.
 ;		<41>	 7/10/91	JSM		Remove obsolete SysVers conditional.
@@ -980,31 +975,16 @@ saveOutline		equ		saveQdChExtra-1			;Byte
 savePreserve	equ		saveOutline-1			;Byte
 saveFractional	equ		savePreserve-1			;Byte
 saveUnscaled	equ		saveFractional-1		;Byte
-SavePatAlign	EQU 	saveUnscaled-4			; 							<SM2> rb
-SavePlayPic		EQU 	SavePatAlign-4			; 							<SM2> rb
-SavePlayIndex	equ		SavePlayPic-4			; 							<SM2> rb
-SaveHandleState	equ		SavePlayIndex-2			; 							<SM2> rb
-VARSIZE 		EQU 	SaveHandleState			;TOTAL BYTES OF LOCALS 		<SM2> rb
+VARSIZE 		EQU 	saveUnscaled			;TOTAL BYTES OF LOCALS
 
 
 		LINK	A6,#VARSIZE 					;ALLOCATE LOCALS
 		MOVEM.L D3-D7/A2-A4,-(SP)				;SAVE REGISTERS
 		MOVE.L	GRAFGLOBALS(A5),A4				;POINT TO QUICKDRAW GLOBALS
 		MOVE.L	THEPORT(A4),A3					;POINT TO CURRENT GRAFPORT
-		MOVE.L	MYPICTURE(A6),D0				;IS PICHANDLE NIL ?						<SM2> rb
+
+		TST.L	MYPICTURE(A6)					;IS PICHANDLE NIL ?						<SM2> rb
 		BEQ 	GOHOME							;YES, QUIT
-		MOVE.L  D0,A0							; put handle in a0						<SM2> rb
-		MOVE.L 	(A0),D0							; has the handle been purged ?			<SM2> rb
-		BEQ		GOHOME							; if so, then skip drawing picture		<SM2> rb
-
-; remember some state so we can go re-entrant
-		_HGetState								; get the handle's state				<SM2> rb
-		MOVE.B	D0,SaveHandleState(A6)			; and save it, so it can be restored	<SM2> rb
-		_HNoPurge								; make picture handle unpurgeable		<SM2> rb
-
-		MOVE.L	PATALIGN(A4),SavePatAlign(A6)	; save this baby...						<SM2> rb
-		MOVE.L	PLAYPIC(A4),SavePlayPic(A6)		; and his baby brother					<SM2> rb
-		MOVE.L	PLAYINDEX(A4),SavePlayIndex(A6)	; and his big sister					<SM2> rb
 
 ;--------------------------------------------------
 ;
@@ -1318,13 +1298,9 @@ DONELP	MOVE.W	(A0)+,(A3)+ 					;COPY A WORD INTO THEPORT
 ;
 ;  RESTORE GLOBAL VARS AND QUIT
 ;
-		MOVE.L	SavePatAlign(A6),PATALIGN(A4)	; Restore PATALIGN						<SM2> rb
-		MOVE.L	SavePlayPic(A6),PLAYPIC(A4) 	; Restore PLAYPIC 						<SM2> rb
-		MOVE.L	SavePlayIndex(A6),PLAYINDEX(A4)	; And PLAYINDEX							<SM2> rb
-
-		MOVE.B	SavehandleState(A6),D0			; get saved pic handle state 			<SM2> rb
-		MOVE.L	MyPicture(A6),A0				; get pic handle in a0 again 			<SM2> rb
-		_HSetState								; and restore the handle's properties 	<SM2> rb
+		CLR.L	PATALIGN(A4)
+		CLR.L	PLAYPIC(A4)
+		CLR.L	PLAYINDEX(A4)
 
 GOHOME	MOVEM.L (SP)+,D3-D7/A2-A4				;RESTORE REGISTERS
 		UNLINK	PARAMSIZE,'DRAWPICT'
diff --git a/QuickDraw/QD.a b/QuickDraw/QD.a
--- a/QuickDraw/QD.a
+++ b/QuickDraw/QD.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 9/12/93	SAM		Added "NOT forROM" around the code that implements
-;									_Translate24to32.  SuperMario is a 32-bit only ROM.
 ;		<19>	 8/30/91	DTY		Define hasCQD since we took it out of BBSStartup.  QuickDraw
 ;									used to use {Defs32}, so hasCQD needs to be true as it was in
 ;									that case.
@@ -131,6 +129,7 @@ WholeErrors 	EQU 1
 			INCLUDE		'qdHooks.a'
 			INCLUDE 	'fontPrivate.a'
 				 
+			INCLUDE		'CrsrDevEqu.a'
 			INCLUDE 	'colorequ.a'
 			INCLUDE		'SlotMgrEqu.a'
 			INCLUDE		'ROMEqu.a'
@@ -410,7 +409,6 @@ FastStart	PROC	EXPORT
 			; to override.
 
 			; Does the Translate24To32 dispatch trap exist?
-	IF NOT forROM THEN							; SuperMario is a 32-bit only ROM.
 			MOVE.W	#$A091, D0					; Translate24To32 Trap number
 			_GetTrapAddress ,NewOS				; get the address of Translate24To32
 			MOVEA.L	A0, A1						; Hold it for a sec
@@ -424,7 +422,6 @@ FastStart	PROC	EXPORT
 			ADD.L	A4,a0					; really get the actual address
 			_SetTrapAddress ,newOS	
 @skip		
-	ENDIF
 			lea		$4081c11c,a0			;point to copyright notice in rom78
 			move.l	a0,d7					;make a copy
 			
diff --git a/QuickDraw/QDHooks.a b/QuickDraw/QDHooks.a
--- a/QuickDraw/QDHooks.a
+++ b/QuickDraw/QDHooks.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 9/12/93	SAM		Removed rSwapMMUMode and rTranslate24to32 from the ROM build
-;									(SuperMario is a 32-bit mode only ROM).
 ;		 <5>	11/26/90	SMC		Added more macros for alpha channel bug fixes.  With BAL.
 ;		 <4>	10/31/90	SMC		Added macros for alpha channel bug fixes.
 ;		 <3>	 6/20/90	CL		Moving the rswapmmumode macro from CQD.a into this file so it
@@ -30,27 +28,15 @@
 CPU		EQU		$020
 	ENDIF
 
-	IF forROM THEN						; <SM2>
-		MACRO
-		_rSwapMMUMode
-		ENDM
-	ELSE
 		MACRO
 		_rSwapMMUMode
 		JSR		([$400+$5d*4])
 		ENDM
-	ENDIF
 
-	IF forROM THEN						; <SM2>
-		MACRO
-		_rTranslate24To32
-		ENDM
-	ELSE
 		MACRO
 		_rTranslate24To32
 		JSR		([$400+$91*4])
 		ENDM
-	ENDIF
 	
 		MACRO
 		_BitBlt
diff --git a/QuickDraw/QDUtil.a b/QuickDraw/QDUtil.a
--- a/QuickDraw/QDUtil.a
+++ b/QuickDraw/QDUtil.a
@@ -11,9 +11,6 @@
 ;	   <SM7>	 9/12/93	joe		seperately conditionalize out ElsieTranslate24To32.
 ;	   <SM6>	 9/12/93	SAM		Changed all instances of _Translate24to32 to _rTranslate24to32
 ;									so they can conditionalized out of the build.
-;	   <SM5>	 1/26/93	kc		Fix bug in GetAlphaMask. (renamed mask to alphaMask to avoid
-;									name collision)
-;	   <SM4>	 1/25/93	kc		Roll in Shannon Holland's alpha channel stuff.
 ;	   <SM3>	 7/16/92	CSS		Update from Reality:
 ;	   <R21>	 6/8/92		SAH		#1031825: Changed ColorMap to ignore the multColor flag.
 ;	   <SM2>	 6/11/92	stb		<sm 6/9/92>stb Synch with QDciPatch.a; added comments to
@@ -128,24 +125,6 @@
 ;  22Jan89	BAL		Altered DrawSlab loops to use patVPos as a long.
 
 
-;																	; <SM4>.start
-; Macros to set the alpha channel mask.
-; These will be moved into an interface file as soon as
-; the High Level API for manipulating the alpha channel is complete.
-;
-		MACRO
-		_GetForeAlphaMask
-		MOVE.W	#$0F,d0
-		JSR		([$E00+$3C0*4])
-		ENDM
-
-		MACRO
-		_GetBackAlphaMask
-		MOVE.W	#$10,d0
-		JSR		([$E00+$3C0*4])
-		ENDM															; <SM4>.end
-
-
 VisRgnChanged	PROC	EXPORT				;<26MAR90 KON>
 ;-----------------------------------------------------------
 ;
@@ -569,7 +548,7 @@ VARSIZE			EQU		0					;SIZE OF LOCALS
 		BPL		@noalpha					;yes, alpha mode is illegal
 		MOVE.W	dstPix+pixelSize(A6),D0		;get depth of destination
 		CMP.W	#16,D0						;direct device?
-		BLT		@noalpha					;no, skip this stuff											; <SM4>
+		BLT.S	@noalpha					;no, skip this stuff											; <SM4>
 		MOVE.L	grafVars(A2),D4				;get grafvars handle
 		BEQ		@noalpha					;no grafvars, no alpha
 		MOVE.L	D4,A0						;copy handle
@@ -577,16 +556,13 @@ VARSIZE			EQU		0					;SIZE OF LOCALS
 		BTST	#PmNewGVBit-8,pmFlags(A1)	;make sure grafvars have been expanded
 		BEQ.S	@noalpha					;if not, bail
 		MOVE.B	streamMode(A1),alphaMode(A6);save alpha mode in stack frame
-		SUB		#18,SP						;make room on stack for results and first error					; <SM4>.start
-		move.l	a0,-(sp)					;push GrafVars handle											
-		PEA		14(SP)						;push pointer to where we want results for background stream	
-		subq	#2,sp						;room for error													
-		move.l	a0,-(sp)					;push GrafVars handle											
-		PEA		16(SP)						;push pointer to where we want results for foreground stream	
-		_GetForeAlphaMask					;get foreground stream and ratio								
-		addq	#2,sp						;clear error													
-		_GetBackAlphaMask					;get background stream and ratio								
-		addq	#2,sp						;clear error													; <SM4>.end
+		SUB		#16,SP						;make room on stack for results and first error					; <SM4>.start
+		PEA		backStream(A1)
+		PEA		12(SP)
+		PEA		foreStream(A1)
+		PEA		12(SP)
+		_StreamToMask
+		_StreamToMask
 		MOVE.L	(SP)+,D0					;get alpha mask
 		MOVE.L	(SP)+,D4					;get alpha fore color
 		CMP.W	#srcXor,D5					;are we xoring?
@@ -955,12 +931,6 @@ xrgbGray	DC.W	$7FFF,$7FFF,$7FFF		;GRAY
 AlphaDispatch	PROC	EXPORT
 
 		IMPORT	RSetHSize
-		IMPORT	SetForeAlpha												; <SM4>.start
-		IMPORT	SetBackAlpha
-		IMPORT	GetForeAlpha
-		IMPORT	GetBackAlpha
-		IMPORT	GetForeAlphaMask
-		IMPORT	GetBackAlphaMask											; <SM4>.end
 
 		JMP		@dispatch(PC,D0.W*4)
 @dispatch
@@ -975,12 +945,6 @@ AlphaDispatch	PROC	EXPORT
 		BRA.W	GetBackTransparency
 		BRA.W	ResizeGrafVars
 		BRA.W	GetStreamMode
-		BRA.W	SetForeAlpha												; <SM4>.start
-		BRA.W	SetBackAlpha
-		BRA.W	GetForeAlpha
-		BRA.W	GetBackAlpha
-		BRA.W	GetForeAlphaMask
-		BRA.W	GetBackAlphaMask											; <SM4>.end
 
 ;
 ; FUNCTION AlphaVersion:INTEGER;
@@ -1180,181 +1144,6 @@ StreamToMask PROC EXPORT
 		RTD		#8
 
 
-;																													; <SM4>.start
-; FUNCTION SetForeAlpha(type: LONG; value: INTEGER) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): unsigned short alpha value
-;	(on stack): long alpha type
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-
-SetForeAlpha PROC EXPORT
-
-alpha		EQU		4						;[unsigned word] alpha value
-type		EQU		alpha+2					;[long] alpha type
-error		EQU		type+4					;[word] OSErr result
-paramSize	EQU		type					;size of parameters
-
-		clr.w	error(sp)					;clear error result
-		move.w	alpha(sp),-(sp)				;push alpha value
-		_SetForeTransparency				;set the foreground transparency
-		RTD		#paramSize
-		
-		
-;
-; FUNCTION SetBackAlpha(type: LONG; value: INTEGER) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): unsigned short alpha value
-;	(on stack): long alpha type
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-
-SetBackAlpha PROC EXPORT
-
-alpha		EQU		4						;[unsigned word] alpha value
-type		EQU		alpha+2					;[long] alpha type
-error		EQU		type+4					;[word] OSErr result
-paramSize	EQU		type					;size of parameters
-
-		clr.w	error(sp)					;clear error result
-		move.w	alpha(sp),-(sp)				;push alpha value
-		_SetBackTransparency				;set the background transparency
-		RTD		#paramSize
-
-
-		
-;
-; FUNCTION GetForeAlpha(VAR type: LONG; VAR value: INTEGER) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): long *alpha
-;	(on stack): long *type
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-
-GetForeAlpha PROC EXPORT
-
-alpha		EQU		4						;[long] alpha value
-type		EQU		alpha+4					;[long] alpha type
-error		EQU		type+4					;[word] OSErr result
-paramSize	EQU		type					;size of parameters
-
-		clr.w	error(sp)					;clear error result
-		subq	#2,sp						;room for short result
-		_GetForeTransparency				;get the foreground transparency
-		move.w	(sp)+,d0					;get alpha result
-		move.l	alpha(sp),a0				;get alpha var
-		move.w	d0,(a0)						;write alpha
-		move.l	type(sp),a0					;get type var
-		move.l	#'vido',(a0)				;write type
-		RTD		#paramSize
-
-		
-;
-; FUNCTION GetBackAlpha(VAR type: LONG; VAR value: INTEGER) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): long *alpha
-;	(on stack): long *type
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-
-GetBackAlpha PROC EXPORT
-
-alpha		EQU		4						;[long] alpha value
-type		EQU		alpha+4					;[long] alpha type
-error		EQU		type+4					;[word] OSErr result
-paramSize	EQU		type					;size of parameters
-
-		clr.w	error(sp)					;clear error result
-		subq	#2,sp						;room for short result
-		_GetBackTransparency				;get the background transparency
-		move.w	(sp)+,d0					;get alpha result
-		move.l	alpha(sp),a0				;get alpha var
-		move.w	d0,(a0)						;write alpha
-		move.l	type(sp),a0					;get type var
-		move.l	#'vido',(a0)				;write type
-		RTD		#paramSize
-
-
-		
-;
-; FUNCTION GetForeAlphaMask(grafVars: Handle,mask^: LONG) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): long mask ptr
-;	(on stack): long grafVars Handle
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-;
-; Note:
-;	We assume that the GrafVars are expanded
-;
-
-GetForeAlphaMask PROC EXPORT
-
-alphaMask	EQU		4						;[long] grafVars handle
-GrafVarsH	EQU		alphaMask+4				;[long] grafVars handle <SM5>
-error		EQU		grafVars+4				;[word] OSErr result
-paramSize	EQU		grafVars				;size of parameters
-
-		clr.w	error(sp)					;clear error
-		move.l	([GrafVarsH,sp]),a0			;get ptr to GrafVars
-		pea		foreStream(a0)				;push pointer to foreground stream and ratio
-		move.l	alphaMask+4(sp),-(sp)		;push ptr to stream and mask
-		_StreamToMask
-		RTD		#paramSize
-		
-
-		
-;
-; FUNCTION GetBackAlphaMask(grafVars: Handle,mask^: LONG) : OSErr
-;
-; On Entry:
-;	(on stack): return address
-;	(on stack): long mask ptr
-;	(on stack): long grafVars Handle
-;	(on stack): OSErr result
-;
-; On Exit:
-;	(on stack}: OSErr result
-;
-; Note:
-;	We assume that the GrafVars are expanded
-;
-
-GetBackAlphaMask PROC EXPORT
-
-alphaMask	EQU		4						;[long] grafVars handle
-GrafVarsH	EQU		alphaMask+4				;[long] grafVars handle <SM5>
-error		EQU		grafVars+4				;[word] OSErr result
-paramSize	EQU		grafVars				;size of parameters
-
-		clr.w	error(sp)					;clear error
-		move.l	([GrafVarsH,sp]),a0			;get ptr to GrafVars
-		pea		backStream(a0)				;push pointer to background stream and ratio
-		move.l	alphaMask+4(sp),-(sp)		;push ptr to stream and mask
-		_StreamToMask
-		RTD		#paramSize																									; <SM4>.end
-
-
 GetCPixel FUNC  EXPORT
 		EXPORT	GETPIXEL
 		IMPORT 	HideCursor,ShowCursor,PortToMap
diff --git a/QuickDraw/Regions.a b/QuickDraw/Regions.a
--- a/QuickDraw/Regions.a
+++ b/QuickDraw/Regions.a
@@ -7,7 +7,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	 1/25/93	kc		Roll in Shannon Holland's alpha channel fix to DrawRgn.
 ;	   <SM3>	 6/11/92	stb		<sm 6/9/92>stb Synch with QDciPatchROM.a; comments added to
 ;									StdRgn, MapRgn
 ;	   <SM2>	 5/21/92	kc		Change the name of QuickDraws wrapper for NewHandle to
@@ -259,10 +258,8 @@ VARSIZE		EQU		BBOX					;SIZE OF LOCALS
 		PEA		BBOX(A6)					;PUSH SRCRECT
 		CLR.L	-(SP)						;NO MASKRECT
 		PEA		BBOX(A6)					;PUSH DSTRECT
-		MOVE	MODE(A6),D1					;PUSH MODE										; <SM4>
-		OR		#$8,D1						;set the pattern bit in case the user forgot to	; <SM4>
-		_GetStreamMode						;strip mode										; <SM4>
-		MOVE.W	D1,-(SP)					;save stripped mode								; <SM4>
+		MOVE	MODE(A6),-(SP)				;PUSH MODE
+		OR		#$8,(SP)					;set the pattern bit in case the user forgot to
 		MOVE.L	PAT(A6),-(SP)				;PUSH PAT
 		MOVE.L	CLIPRGN(A1),-(SP)			;PUSH CLIPRGN
 		MOVE.L	VISRGN(A1),-(SP)			;PUSH VISRGN
diff --git a/QuickDraw/RgnBlt.a b/QuickDraw/RgnBlt.a
--- a/QuickDraw/RgnBlt.a
+++ b/QuickDraw/RgnBlt.a
@@ -10,13 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	  6/3/93	CSS		Per Shannon Holland and KON, The code RgnBlt checks for a
-;									pattern which is solid background color when it should check for
-;									a pattern which is a solid foreground color.
-;	   <SM3>	01/06/93	HI		#1052740: Modified D0 to D3 in RgnBlt in rcMASK0 section.
-;									Previously, it was masking out the destination instead of
-;									the source; so the images were drawn incorrectly. ANDing
-;									with D3 masks out the source and fixes the bug. (Hoon Im)
 ;	   <SM2>	 6/12/92	stb		<sm 6/9/92>stb Synch with QDciPatchROM.a; added comments to
 ;									rMASK8, rXMASK8, rslowHilite, rTransparent.
 ;		<11>	11/26/90	SMC		Fixed pattern hiliting once and for all.  With BAL.
@@ -281,12 +274,12 @@ CLRMASK CLR.L	-(SP)						;ALLOCATE AND CLEAR
 		TST		PATROW(A6)					;BIG PATTERN?
 		BNE.S	@oldWay						;if so, assume pattern contains background color
 		MOVE.L	exPat(A6),A0				;check if non-background pattern
-		MOVE.L	FCOLOR(A6),D1				;get foreground color <SM4> CSS
+		MOVE.L	BCOLOR(A6),D1				;get background color
 		MOVEQ	#$0F,D0						;number of longs in a short pattern
 @nextPatRow
 		CMP.L	(A0)+,D1					;is the row non-background?
 		DBEQ	D0,@nextPatRow				;if so, check for more rows
- 		BNE.S	@oldWay						;if not, can’t do fast hiliting <SM4> CSS
+ 		BEQ.S	@oldWay						;if not, can’t do fast hiliting
 		MOVE	#$10,locMode(A6)			;set the mode to the fast hilite variety
 		BRA.S	@newWay						;assume D0 = -1
 @noHilite
@@ -1481,7 +1474,7 @@ rcMASK0	move.w	hBump(a6),a4	;get hbump in a4
 		EOR.L	D5,D3			;apply bkcolor to src				<9>
 		MOVE.L	(A2),D0			;get dst							<9>
 		EOR.L	D0,D3			;apply it to src					<9>
-		AND.L	(A1)+,D3		;make it							<9> <SM3>
+		AND.L	(A1)+,D0		;make it							<9>
 		EOR.L	D0,D3			;reapply dst to src					<9>
 		MOVE.L	D3,(A2)			;move result to dst					<9>
 		add		a4,a2			;%%%bump dst
@@ -4109,15 +4102,6 @@ rslowHilite
 
 rTransparent
 rTransparentIndexed
-		TST.L	D3						;right to left?									<sm 6/9/92>stb
-		BMI.S	@1						;if so, skip									<sm 6/9/92>stb
-		CMP.W	#8,DSTPIX+PIXELSIZE(A6)	;is it 8 bit mode?								<sm 6/9/92>stb
-		BEQ		rTransparent8			;yes, go use quickdraw							<sm 6/9/92>stb
-									; if it is, go use Andy’s QuickerDraw special 8-bit case
-									; which doesn’t have this problem					<sm 6/9/92>stb
-	@1:	LEA		@RealrTransparent,A0; this fixes a bug that the optimization introduced	<sm 6/9/92>stb
-		MOVE.L	A0,ModeCase(A6)		; which was causing the loss of pattern data		<sm 6/9/92>stb
-@RealrTransparent
 		MOVE	patHMask(A6),D1		;set up source constriction
 		MOVE 	pixInLong1(A6),A0	;set up absolute long bump
 		MOVE	longBump(A6),A2		;set up long bump
diff --git a/QuickDraw/ScaleBlt.a b/QuickDraw/ScaleBlt.a
--- a/QuickDraw/ScaleBlt.a
+++ b/QuickDraw/ScaleBlt.a
@@ -7,11 +7,6 @@
 ;
 ;	   <SM9>	  7/6/93	kc		Roll in Ludwig.
 ;	   <SM8>	  7/6/93	kc		Roll in bug fix from Shannon Holland.
-;	   <SM7>	01/19/93	HI		#1060484:Fixed bug in scIndToInd where it was not
-;									properly offseting while masking. Fixes bugs where
-;									>1 bit images are clipped and some garbage is drawn
-;									as a result. For a detailed information of the bug
-;									fix, read the header of scIndToInd. (Hoon Im)
 ;	   <SM6>	 12/4/92	CSS		Revert SM5 as SM4 already fixed this bug.
 ;	   <SM5>	 12/2/92	kc		Roll in <R22> from QuickDrawPatches in Reality.
 ;		<R22>	 8/13/92	SAH		#1039892: Fixed a bug in the ScaleBlt 1->16 non-colorizing loop
@@ -356,9 +351,6 @@ ScaleColorBit	EQU		3
 		dbne	d0,@1
 		bne.s	@ScaleOK					;tables are not equal so perform pixel scaling
 
-		Bclr	#ScaleColorBit,XlateFlag+1(a6)	; •••  We are not scaling and it's an idendity map,
-												; •••  so set this bit for the callee
-
 ;if we installed a proc get rid of it before short circuiting stretch
 	
 		TST		D7							;DID WE INSTALL A PROC
@@ -2310,24 +2302,12 @@ scIndexedto16
 ;	<28MAY92 SAH>
 ;		scale and clip indexed source to indexed dst
 ;
-;	<SM7>
-;		If mask data contains an offset, then set the destination alignment
-;		to 0 and recalculate the source alignment value. Use the high word
-;		of D4 to store srcShift-dstShift value; this value is used to
-;		convert a destination alignment value to a source alignment value.
-;		If srcShift-dstShift >= 0 (higher bit depth to lower bit depth), then
-;		shift the dstAlign value to the left; if srcShift-dstShift < 0
-;		(lower bit depth to higher bit depth), then shift the dstAlign value to
-;		the right. Subtract the resulting value from the source offset value;
-;		this causes the source buffer pointer to be offset by the appropriate
-;		value and a new srcAlign value to be calculated.
-;
 ;-------------------------------------------------------
 ;		a0 = tmpsrc			d0 = vert/scratch
 ;		a1 = tmpmask		d1 = scanCount/scratch
 ;		a2 = tmpdst			d2 = scratch / dst pixel
 ;		a3 = scaleTbl		d3 = run cnt / scanCount
-;		a4 = srcPtr/patPtr	d4 = srcShift-dstShift / dst pixel size		<SM7>
+;		a4 = srcPtr/patPtr	d4 = dst pixel size
 ;		a5 = dstPtr			d5 = scratch
 ;		a6 = locals			d6 = bit offset in src / offset in dst
 ;		a7 = 				d7 = src shift / dst shift
@@ -2346,11 +2326,6 @@ scIndtoInd
 		
 		move.l	scaleTbl(a6),a3		;set this up once
 		
-		swap	d4					;use high word						<SM7>
-		move.w	srcShift(a6),d4		;calculate the difference of		<SM7>
-		sub.w	dstShift(a6),d4		;source and destination bit shifts	<SM7>
-		swap	d4					;use low word						<SM7>
-
 		lea		@first,a0			;go here from now on
 		move.l	A3,scaleBltA3(a6)	;save for reload after seekMask
 		move.l	a0,ScaleCase(a6)	;remember for later
@@ -2403,19 +2378,6 @@ scIndtoInd
 		swap	d7				;get shift
 		lsl.w	d7,d5			;make into bit skip
 		swap	d7				;put shift back
-		swap	d4				;get bit shift difference				<SM7>
-		tst.w	d4				;shift left or right?					<SM7>
-		bmi.s	@shiftRight		;shift right							<SM7>
-		lsl.w	d4,d0			;convert dst alignment to src alignment	<SM7>
-		bra.s	@afterShift		;										<SM7>
-@shiftRight						;										<SM7>
-		neg.w	d4				;get absolute value						<SM7>
-		lsr.w	d4,d0			;convert dst alignment to src alignment	<SM7>
-		neg.w	d4				;revert shift difference value			<SM7>
-@afterShift						;										<SM7>
-		swap	d4				;get dst pixel size						<SM7>
-		sub.w	d0,d5			;subtract								<SM7>
-		move.w	#0,d0			;no dst alignment						<SM7>
 		add.w	d5,d6			;bump src offset
 		move.w	d6,d5			;make a copy							
 		and.w	#$1f,d6			;make offset mod 32
diff --git a/QuickDraw/Stretch.a b/QuickDraw/Stretch.a
--- a/QuickDraw/Stretch.a
+++ b/QuickDraw/Stretch.a
@@ -885,16 +885,6 @@ skipTable
 		btst.l	#ColorizeInModeCaseBit,d0
 		beq		@CheckSwapping				; not modecase: go on
 
-;
-; This code reintroduced from version 54 for CubeE.
-;
-
-	if CubeE then							; <56>
-		move.l	([theGDevice]),a0			; <56> get a pointer to the device
-		tst.l	GDSearchProc(A0)			; <56> check the head of the search chain
-		beq		@CheckSwapping				; <56> no search proc: go on
-	endif									; <56> 
-
 ;
 ; fcolor and bcolor were mapped using search proc by colormap.  We want to use
 ; the unmapped versions.
diff --git a/QuickDraw/Text.a b/QuickDraw/Text.a
--- a/QuickDraw/Text.a
+++ b/QuickDraw/Text.a
@@ -181,6 +181,14 @@ hasGlyphState			EQU		1
 	EndIf
 		INCLUDE 	'SysPrivateEqu.a'
 		INCLUDE		'LinkedPatchMacros.a'
+
+CheckPic		RomBind		(II,$20ef2),(IIci,$33780)
+DPutPicByte		RomBind		(II,$20806),(IIci,$32bf0)
+DPutPicOp		RomBind		(II,$20884),(IIci,$32c90)
+PutPicData		RomBind		(II,$207f0),(IIci,$32bd0)
+PutPicLong		RomBind		(II,$20830),(IIci,$32c30)
+PutPicWord		RomBind		(II,$2081e),(IIci,$32c10)
+
 ;——————————————————————————————————————————————————————————————————————————————
 
 	MACHINE		MC68020
diff --git a/Resources/Sys.r b/Resources/Sys.r
--- a/Resources/Sys.r
+++ b/Resources/Sys.r
@@ -9,10 +9,6 @@
 
 	Change History (most recent first):
 
-	   <SM3>	 8/25/93	BH		Added dialogs for use by manual-eject drive software. This may
-									not be the most appropriate place for them, but they need a home
-									for now.
-	   <SM2>	 3/24/93	dwc		Changed to include AppleTalk resource AT58 instead of AT57.
 	   <290>	 1/23/92	hsK		Deleted 'dtab' resource which is no more used by the Dictionary
 									manager.
 	   <289>	 1/18/92	DTY		Lock the print driver so that it will get loaded low in the
@@ -780,6 +776,49 @@
 
 */
 
+//__________________________________________________________________________________________________
+// Resources that cannot be found in the SuperMario source. Move out of here if possible.
+
+data 'DITL' (-16601, sysheap) {
+	$"0004 0000 0000 0084 004B 0098 0088 0406"            /* .........K...... */
+	$"4361 6E63 656C 0000 0000 0084 009C 0098"            /* Cancel.......... */
+	$"00F7 040B 5072 696E 7420 4C61 7465 7200"            /* ....Print Later. */
+	$"0000 0000 0084 010B 0098 015F 0409 5072"            /* ..........._..Pr */
+	$"696E 7420 4E6F 7700 0000 0000 000A 0014"            /* int Now......... */
+	$"002A 0034 A002 0002 0000 0000 0007 004A"            /* .*.4...........J */
+	$"0077 0163 88BA 596F 7572 2064 6F63 756D"            /* .w.c..Your docum */
+	$"656E 7420 7769 6C6C 2062 6520 7072 696E"            /* ent will be prin */
+	$"7465 6420 696E 2074 6865 2062 6163 6B67"            /* ted in the backg */
+	$"726F 756E 6420 7768 656E 206D 6F72 6520"            /* round when more  */
+	$"6D65 6D6F 7279 2069 7320 6176 6169 6C61"            /* memory is availa */
+	$"626C 652E 0D0D 596F 7520 6361 6E20 7472"            /* ble...You can tr */
+	$"7920 7072 696E 7469 6E67 206E 6F77 2069"            /* y printing now i */
+	$"6E73 7465 6164 2C20 6275 7420 796F 7520"            /* nstead, but you  */
+	$"7769 6C6C 206E 6F74 2062 6520 6162 6C65"            /* will not be able */
+	$"2074 6F20 636F 6E74 696E 7565 2077 6F72"            /*  to continue wor */
+	$"6B69 6E67 2075 6E74 696C 2070 7269 6E74"            /* king until print */
+	$"696E 6720 6973 2066 696E 6973 6865 642E"            /* ing is finished. */
+};
+
+data 'RECT' (-16601, sysheap) {
+	$"002C 001C 00CE 0189"                                /* .,...... */
+};
+
+data 'STR ' (-16601, sysheap) {
+	$"0C50 7269 6E74 4D6F 6E69 746F 72"                   /* .PrintMonitor */
+};
+
+data 'STR ' (-16392, sysheap, locked) {
+	$"6154 6865 7265 2061 7265 206D 6F72 6520"            /* aThere are more  */
+	$"7468 616E 2031 3238 2066 6F6E 7420 6669"            /* than 128 font fi */
+	$"6C65 7320 696E 2074 6865 2046 6F6E 7473"            /* les in the Fonts */
+	$"2066 6F6C 6465 722E 2020 536F 6D65 2066"            /*  folder.  Some f */
+	$"6F6E 7473 206D 6179 206E 6F74 2062 6520"            /* onts may not be  */
+	$"6176 6169 6C61 626C 6520 666F 7220 7573"            /* available for us */
+	$"652E"                                               /* e. */
+};
+
+
 #include "Types.r"
 #include "SysTypes.r"
 
@@ -822,18 +861,22 @@
 
 	#define VersionString \
 		"Macintosh System version " SysVersion "\n\n\n" \
-		"© Apple Computer, Inc. 1983-1991\n" \
+		"© Apple Computer, Inc. 1983-1992\n" \
 		"All rights reserved."
 
 	resource 'STR ' (0) { VersionString };
 
 	resource 'vers' (1) {
-		LIntVers, LangInt, SysVersion, SysVersion", © Apple Computer, Inc. 1983-1991"
+		LIntVers, LangInt, SysVersion, SysVersion", © Apple Computer, Inc. 1983-1992"
+	};
+
+	resource 'vers' (2, purgeable) {
+		LIntVers, LangInt, SysVersion, "System Software "SysVersion
 	};
 
 	resource 'BNDL' (0) {
 		'MACS', 0, {
-			'FREF', { 0, 0; 1, 1; 2, 2; 3, 3; 4, 4; 5, 5; 6, 6 };
+			'FREF', { 0, 0; 1, 1; 2, 2; 3, 3; 4, 4; 5, 5; 6, 6; 7, 7 };
 			'ICN#', { 3, 3; -16415, -16415; 5, -5696; -16494, -16494; -16509, -16509 };
 		}
 	};
@@ -842,6 +885,7 @@
 	resource 'MACS' (0, purgeable) { VersionString };
 
 	resource 'FREF' (6) { 'zsys', -16494, "" };	// System File for 7.0
+	resource 'FREF' (7) { 'gbly', 3, "" };		// System Enabler for 7.0
 	resource 'FREF' (0) { 'ZSYS', 3, "" };		// System File for 6.0.x & other systemish files
 	resource 'FREF' (1) { 'FNDR', 3, "" };		// Finder
 	resource 'FREF' (2) { 'INIT', -16415, "" };	// standard INIT
@@ -885,7 +929,34 @@
 		"PowerBook 100",		// 24 Asahi
 		"PowerBook 140",		// 25 TimLC
 		"Macintosh Quadra 950",	// 26 Zydeco		<13> Leave 4 trailing spaces for the Installer
-		"Macintosh",			// 27 DBLite
+		"",						// 27 not used
+		"",						// 28 not used
+		"",						// 29 not used
+		"",						// 30 not used
+		"",						// 31 not used
+		"",						// 32 not used
+		"",						// 33 not used
+		"",						// 34 not used
+		"",						// 35 not used
+		"",						// 36 not used
+		"Macintosh LC II",		// 37
+		"",						// 38 not used
+		"",						// 39 not used
+		"",						// 40 not used
+		"",						// 41 not used
+		"",						// 42 not used
+		"",						// 43 not used
+		"",						// 44 not used
+		"",						// 45 not used
+		"",						// 46 not used
+		"",						// 47 not used
+		"",						// 48 not used
+		"",						// 49 not used
+		"",						// 50 not used
+		"",						// 51 not used
+		"",						// 52 not used
+		"",						// 53 not used
+		"PowerBook 145",		// 54
 	} };
 
 	type 'dbex' { integer=0; };		// nothing
@@ -920,14 +991,14 @@
 
 	resource 'gbly' (-16385, sysHeap) {
 		GibblyVersion1,
-		BuildTime,							// Time stamp
+		$A6C2441B,							// Time stamp, 1992-08-27 08:34:35
 		{									// Supported BoxFlags
 			$00FE, $00FF, $0000, $0001,
 			$0002, $0003, $0004, $0005,
 			$0006, $0007, $0008, $0009,
 			$000A, $000B, $000C, $000D,
 			$000E, $000F, $0010, $0011,
-			$0012, $0013, $0014, $0015
+			$0012, $0013, $0014
 		};
 	};
 
@@ -953,7 +1024,7 @@
 	// Picasso Macintosh icon (loaded by System Error Handler)
 
 	resource 'cicn' (-16396, purgeable) {
-		{0, 0, 32, 32}, 4,			// bounds, bits per pixel
+		16, {0, 0, 32, 32}, 4,			// bounds, bits per pixel
 	// mask
 		$"0007FF80 00080000 00087E20 00080120"
 		$"00080120 04080120 0C080120 08080120"
@@ -1078,16 +1149,7 @@
 
 		'clut',	127;	// 8 standard QuickDraw colors; green is fixed
 
-		'atlk', 1;		// AppleTalk
-		'atlk', 3;		// AppleTalk
 		'atlk', 10;		// EtherTalk driver (LC ROM only)
-		'ltlk', 0;		// AppleTalk
-		'ltlk', 1;		// AppleTalk
-		'ltlk', 2;		// AppleTalk
-		'ltlk', 3;		// AppleTalk
-    	'DRVR', 10;		// AppleTalk
-    	'DRVR', 40;		// AppleTalk
-    	'DRVR', 9;		// AppleTalk
     	'INIT', 18;		// AppleTalk
     	'lmgr', 0;		// AppleTalk
 
@@ -1129,9 +1191,7 @@
 
 	IncSys "ParityINIT.a.rsrc" codeAs 'INIT' (10, sysHeap, locked);
 
-	IncSys "EDiskShutdownPtch.a.rsrc" codeAs 'INIT' (12, sysHeap, locked);
-	
-	
+
 	resource 'mcky' (0, sysHeap, purgeable) { { 255, 255, 255, 255, 255, 255, 255, 255 } };
 	resource 'mcky' (1, sysHeap, purgeable) { { 6, 255, 255, 255, 255, 255, 255, 255 } };
 	resource 'mcky' (2, sysHeap, purgeable) { { 4, 10, 15, 255, 255, 255, 255, 255 } };
@@ -1168,8 +1228,8 @@
 //__________________________________________________________________________________________________
 // AppleTalk
 
-	// AppleTalk 58 resources
- 	include $$Shell("Misc")"APTK58.rsrc" not 'ckid';
+	// AppleTalk 57 resources
+ 	include $$Shell("Misc")"APTK57.rsrc" not 'ckid';
 	
 	// ^^ incorporates the following:
 	// IncSys "AppleTalk.rsrc" not 'vers';
@@ -1180,16 +1240,16 @@
 		"Your system has been placed in AppleTalk zone “",
 
 		"”.  "
-		"To select a different zone, please click the Network icon in the Control Panel, "
+		"To select a different zone, please open the Network icon in the Control Panels Folder, "
 		"then click the selected AppleTalk connection icon.",
 
 		"Access to your AppleTalk internet has now become available.  To use "
-		"the internet, please click the Network icon in the Control Panel, "
+		"the internet, please open the Network icon in the Control Panels Folder, "
 		"then click the selected AppleTalk connection icon.",
 
 		"An unexpected change in your AppleTalk internet has interrupted network access.  "
-		"To resume network use, please click the "
-		"Network icon in the Control Panel, "
+		"To resume network use, please open the "
+		"Network icon in the Control Panels Folder, "
 		"then click the selected AppleTalk connection icon.",
 	} };
 
@@ -1241,6 +1301,10 @@
 		"The Router could not run.  "
 		"The Router file is damaged.  "
 		"Please reinstall the Router.",
+
+		"The Router could not run. "
+		"The Router is not compatible with Virtual Memory. "
+		"The built-in LocalTalk port will be used for your AppleTalk connection.",
 	} };
 
 //__________________________________________________________________________________________________
@@ -1880,6 +1944,11 @@ resource 'PICT' (-16387) {
 
 	IncSys "EditionMgr.rsrc";
 
+//__________________________________________________________________________________________________
+// EDisk
+
+	resource 'STR ' (-16535, sysheap, locked) { "Internal RAM Disk" }; // for EDiskLocalNamePatch.a
+
 //__________________________________________________________________________________________________
 // Font Mgr
 
@@ -1905,9 +1974,9 @@ resource 'STR ' (-16391, purgeable) { "Font Cache" };
 	resource 'FOND' (3, "Geneva", purgeable) {
 		FakeFONDFlags, 3, FakeFONDFields, 1, { 9, plain, 393; 12, plain, 396; }, FakeFONDTables
 	};
-	data 'FONT' (384, "Geneva", purgeable) {};
 	IncSys "SystemFonts.rsrc" 'FONT' (393) as 'FONT' (393, purgeable);
 	IncSys "SystemFonts.rsrc" 'FONT' (396) as 'FONT' (396, purgeable);
+	IncSys "SystemFonts.rsrc" 'FONT' (521) as 'FONT' (521, purgeable);
 
 	resource 'FOND' (4, "Monaco", purgeable) {
 		FakeFONDFlags, 4, FakeFONDFields, 1, { 9, plain, 521; }, FakeFONDTables
@@ -2121,16 +2190,24 @@ resource 'pslt' (gestaltEclipse33, purgeable) {
 
 	IncSys "International.rsrc" 'kcs#' (0) as 'kcs#' (0, sysHeap, purgeable);
 	IncSys "International.rsrc" 'kcs4' (0) as 'kcs4' (0, sysHeap, purgeable);
-	IncSys "International.rsrc" 'kcs8' (0) as 'kcs8' (0, sysHeap, purgeable);
+	IncSys "International.rsrc" 'kcs#' (16383) as 'kcs#' (16383, sysHeap, purgeable);
+	IncSys "International.rsrc" 'kcs4' (16383) as 'kcs4' (16383, sysHeap, purgeable);
 	IncSys "International.rsrc" 'kcs#' (-16491) as 'kcs#' (-16491, sysHeap, purgeable);
 	IncSys "International.rsrc" 'kcs4' (-16491) as 'kcs4' (-16491, sysHeap, purgeable);
-	IncSys "International.rsrc" 'kcs8' (-16491) as 'kcs8' (-16491, sysHeap, purgeable);
+	IncSys "International.rsrc" 'kcs#' (-16492) as 'kcs#' (-16492, sysHeap, purgeable);
+	IncSys "International.rsrc" 'kcs4' (-16492) as 'kcs4' (-16492, sysHeap, purgeable);
 	IncSys "International.rsrc" 'STR#' (-16491) as 'STR#' (-16491, sysHeap, purgeable);
+	IncSys "International.rsrc" 'STR#' (-16492) as 'STR#' (-16492, sysHeap, purgeable);
+	IncSys "International.rsrc" 'STR#' (-16493) as 'STR#' (-16493, sysHeap, purgeable);
+	IncSys "International.rsrc" 'STR#' (-16494) as 'STR#' (-16494, sysHeap, purgeable);
+	IncSys "International.rsrc" 'STR#' (-16495) as 'STR#' (-16495, sysHeap, purgeable);
 	IncSys "International.rsrc" 'hmnu' (-16491) as 'hmnu' (-16491, sysHeap, purgeable);	// Keyboard menu help strings	<185>
-	IncSys "International.rsrc" 'DLOG' (-16491) as 'DLOG' (-16491, sysHeap, purgeable);	// About Keyboards…				<208>
-	IncSys "International.rsrc" 'DITL' (-16491) as 'DITL' (-16491, sysHeap, purgeable);	// About Keyboards…				<208>
 	IncSys "International.rsrc" 'DLOG' (-16492) as 'DLOG' (-16492, sysHeap, purgeable);	// About Keyboards…				<208>
 	IncSys "International.rsrc" 'DITL' (-16492) as 'DITL' (-16492, sysHeap, purgeable);	// About Keyboards…				<208>
+	IncSys "International.rsrc" 'DLOG' (-16493) as 'DLOG' (-16493, sysHeap, purgeable);	// About Keyboards…
+	IncSys "International.rsrc" 'DITL' (-16493) as 'DITL' (-16493, sysHeap, purgeable);	// About Keyboards…
+	IncSys "International.rsrc" 'DLOG' (-16494) as 'DLOG' (-16494, sysHeap, purgeable);	// About Keyboards…
+	IncSys "International.rsrc" 'DITL' (-16494) as 'DITL' (-16494, sysHeap, purgeable);	// About Keyboards…
 
 //__________________________________________________________________________________________________
 // List Mgr
@@ -2540,13 +2617,6 @@ resource 'ppci' (-16409)
 	IncSys "Scheduler.rsrc";
 	IncSys "DAHandler.rsrc";
 
-//__________________________________________________________________________________________________
-// SANE
-
-	IncSys "FPHW.rsrc" 'RSRC' (0) as 'PACK' (4, sysHeap, locked);
-	IncSys "ElemsHW.rsrc" 'RSRC' (0) as 'PACK' (5, sysHeap, locked);
-
-
 //__________________________________________________________________________________________________
 // QuickDraw
 
@@ -3102,14 +3172,20 @@ resource 'ppci' (-16409)
 
 //__________________________________________________________________________________________________
 // EDisk
-	resource 'STR#' (-4097, sysHeap, Locked) {
-		{
-			"The contents of the RAM Disk volume “^1” will be lost by shutting down.  "
-			"Do you wish to continue?",
-			"OK",
-			"Cancel",
-		}
+	resource 'DITL' (-16535, purgeable) { {
+		{84, 287, 104, 357}, Button { enabled, "OK" };
+		{84, 204, 104, 274}, Button { enabled, "Cancel" };
+		{10, 20, 42, 52}, Icon { disabled, 2 };
+		{7,  74, 72, 354}, StaticText { disabled,
+			"The contents of the RAM Disk volume “^0” will be lost by shutting down.  "
+			"Do you wish to continue?"
+		};
+	} };
+
+	resource 'DLOG' (-16535, purgeable) {
+		{0, 0, 114, 367}, dBoxProc, visible, noGoAway, 0, -16535, "", alertPositionMainScreen
 	};
+
 //__________________________________________________________________________________________________
 // Virtual Memory
 
@@ -3165,7 +3241,7 @@ data 'ppat' (18, sysheap, purgeable) {
 // color desktop pattern = dithered gray
 	resource 'ppat' (16, sysHeap, purgeable) {
 		$"AA55AA55AA55AA55",			// black & white pattern
-		{0, 0, 8, 8}, 4,				// bounds, bits per pixel
+		4, {0, 0, 8, 8}, 4,				// bounds, bits per pixel
 	// 4-bit color image
 		$"10101010"
 		$"01010101"
@@ -3540,78 +3616,4 @@ data 'ppat' (18, sysheap, purgeable) {
 
 #if hasAppleEventMgr
 	IncSys "AppleEventMgr.rsrc";
-#endif
-
-//__________________________________________________________________________________________________
-// Manual-eject drive stuff
-// This dialog and alert are used by the manual-eject drive software to communicate with the user
-// when a dirty disk has been manually-ejected.  This may not be the best place for them, but they
-// need to go somewhere for now.
-
-#if hasManEject
-resource 'DLOG' (-16413, sysheap, purgeable) {
-	{73, 114, 159, 411},
-	dBoxProc,
-	visible,
-	noGoAway,
-	0x0,
-	-16413,
-	""
-};
-
-resource 'DITL' (-16414, sysheap) {
-	{	/* array DITLarray: 2 elements */
-		/* [1] */
-		{60, 229, 80, 287},
-		Button {
-			enabled,
-			"OK"
-		},
-		/* [2] */
-		{9, 72, 54, 287},
-		StaticText {
-			disabled,
-			"Failing to update your disk may result i"
-			"n data loss."
-		}
-	}
-};
-
-resource 'DITL' (-16413, sysheap, purgeable) {
-	{	/* array DITLarray: 3 elements */
-		/* [1] */
-		{60, 229, 80, 287},
-		Button {
-			enabled,
-			"OK"
-		},
-		/* [2] */
-		{9, 72, 54, 287},
-		StaticText {
-			disabled,
-			"You may now safely remove the disk."
-		},
-		/* [3] */
-		{9, 10, 41, 42},
-		Icon {
-			disabled,
-			1
-		}
-	}
-};
-
-resource 'ALRT' (-16414, sysheap, purgeable) {
-	{73, 114, 159, 411},
-	-16414,
-	{	/* array: 4 elements */
-		/* [1] */
-		OK, visible, sound1,
-		/* [2] */
-		OK, visible, sound1,
-		/* [3] */
-		OK, visible, sound1,
-		/* [4] */
-		OK, visible, sound1
-	}
-};
 #endif
\ No newline at end of file
diff --git a/Tidbits/UserAlerts.a b/Tidbits/UserAlerts.a
--- a/Tidbits/UserAlerts.a
+++ b/Tidbits/UserAlerts.a
@@ -9,10 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 8/25/93	BH		Added stuff for manual-eject drive support and tweaked the old
-;									disk-switch alert a bit.  The changes are all conditionalized
-;									with hasManEject.  There is probably a better way to do this,
-;									but this stuff needs somewhere to go for now.
 ;		<18>	 6/12/91	LN		removed #include 'HardwareEqu.a'
 ;		<17>	  3/4/91	dba		dty: get rid of SysVers conditionals
 ;		<16>	  2/7/91	dnf		kst, #79676: Use dsRecoverVCBPtr to draw the name of the volume
@@ -131,6 +127,7 @@ dsiRemoveDisk			equ		-16401	; <SM1> <BH 25Aug93>
 dstMissingPatch			equ		-20000
 dstParityError			equ		-20001
 dstSystemDamaged		equ		-20002
+dstSCSIWarn				equ		-20003
 
 dstApplicationBusy		equ		-20100
 dstFinderMissing		equ		-20101
@@ -184,17 +181,13 @@ dssCancel				equ		-23104
 ;
 ; Entry count: bump 1 for each new item.
 
-	IF NOT hasManEject THEN
-	NumEntries: set 47
-		; 11 alerts
-		; 10 texts
+	NumEntries: set 49
+		; 12 alerts
+		; 11 texts
 		;  4 icons
 		;  8 button lists
 		;  5 button strings
 		;  9 procs
-	ELSE						; if hasManEject
-		NumEntries: set 52		; 13 + 9 + 5 + 8 + 5 + 12
-	ENDIF
 	
 			dc.w	NumEntries
 
@@ -216,14 +209,7 @@ dssCancel				equ		-23104
 
 			; other errors
 
-	IF hasManEject THEN														; <SM1> <BH 25Aug93>
-			dc.w	dsRemoveDisk,10,0,0,dsiRemoveDisk,dspDrawRmvDsk,0		; eject request
-			dc.w	dsDirtyDisk,10,0,0,dsiInsertDisk,dspDrawDirtyDsk,0		; ejected dirty
-			dc.w	dsReinsert,10,0,0,dsiInsertDisk,dspDrawDiskName,0		; new disk-switch
-	ELSE
 			dc.w	dsReinsert,10,dstInsertDisk,0,dsiDiskSwap,dspDrawDiskName,0
-	ENDIF
-	
 			dc.w	dsStknHeap,10,dstGeneralError,0,dsiBomb,dspStackSniffError,dsbRestartResume
 
 			; Startup, INITs, or apps ate too much of BufPtr space or the current heap
@@ -246,6 +232,10 @@ dssCancel				equ		-23104
 			dc.w	dsNoPatch,10,dstMissingPatch,0,dsiStop,0,dsbRestart
 			dc.w	dsParityErr,10,dstParityError,0,dsiBomb,0,dsbRestart
 
+			; SCSI Disk Mode
+
+			dc.w	dsSCSIWarn,10,dstSCSIWarn,0,dsiStop,0,0
+
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 ;
 ; Text definitions.
@@ -265,7 +255,6 @@ GeneralErrorMessage
 			align
 @end
 
-	IF NOT hasManEject THEN		; Drawn by proc below in man-eject systems <SM1> <BH 25Aug93>
 InsertDiskMessage
 			dc.w	dstInsertDisk,@end-@rest
 @rest
@@ -274,7 +263,6 @@ InsertDiskMessage
 			DC.B	0
 			align
 @end
-	ENDIF	; NOT hasManEject
 	
 SwitchOffMessage
 			dc.w	dstSwitchOff,@end-@rest
@@ -358,6 +346,20 @@ SomebodyAteAlltheRAMMessage
 			align
 @end
 
+CableRemovedMessage
+			dc.w	dstSCSIWarn,@end-@rest
+@rest
+			dc.w	88,114
+			dc.b	'/'
+			dc.b	'Hard Disk Cable Warning/'
+			dc.b	'/'
+			dc.b	'You must first shutdown the Macintosh before/'
+			dc.b	'attaching any SCSI hard disk cables.  Disconnect/'
+			dc.b	'the cable from the back of the machine right now./'
+			dc.b	0
+			align
+@end
+
 ; ——————————————————————————————————————————————————————————————————————————————————————————————————
 ;
 ; icon definitions
@@ -385,7 +387,6 @@ BombIcon
 
 ; disk-switched icon
 
-	IF NOT hasManEject THEN	; <SM1> <BH 25Aug93>
 							; The disk-switch icon for manual-eject systems is different
 DiskSwapIcon
 			dc.w	dsiDiskSwap,@end-@rest
@@ -401,38 +402,6 @@ DiskSwapIcon
 			dc.l	$01000000, $00800100, $007B5400, $00000000
 @end
 
-	ELSE					; Disk insert and remove icons for manual-eject systems
-
-DiskInsertIcon				; Used by both disk-switch and manual-eject stuff
-			dc.w	dsiInsertDisk,@end-@rest
-@rest
-			dc.w	12,20,44,52
-			dc.l	$00000000, $00000000, $00000000, $0001FFF0
-			dc.l	$00011148, $00411144, $00E11044, $01F11FC4
-			dc.l	$03F90004, $00E10004, $00E13FE4, $00E14014
-			dc.l	$00E14014, $00E14C14, $00E15214, $00016214
-			dc.l	$00014414, $0001CFFC, $00008920, $00008620
-			dc.l	$00008020, $00008020, $00008020, $00008040
-			dc.l	$00008080, $00008100, $00010200, $00010400
-			dc.l	$0003FC00, $0003FC00, $0003FC00, $00000000
-@end
-
-DiskRemoveIcon
-			dc.w	dsiRemoveDisk,@end-@rest
-@rest
-			dc.w	12,20,44,52
-			dc.l	$00000000, $00000000, $00000000, $0001FFF0
-			dc.l	$00011148, $00E11144, $00E11044, $00E11FC4
-			dc.l	$00E10004, $00E10004, $00E13FE4, $03F94014
-			dc.l	$01F14014, $00E14C14, $00415214, $00016214
-			dc.l	$00014414, $0001CFFC, $00008920, $00008620
-			dc.l	$00008020, $00008020, $00008020, $00008040
-			dc.l	$00008080, $00008100, $00010200, $00010400
-			dc.l	$0003FC00, $0003FC00, $0003FC00, $00000000
-@end
-
-	ENDIF	; NOT hasManEject
-
 ; stop icon
 
 DSStopIcon
@@ -822,7 +791,6 @@ MessagesTable
 
 EndDoSystemErrorButtons
 
-	IF NOT hasManEject THEN	; This proc has been replaced for man-eject systems <SM1> <BH 25Aug93>
 ; —————————————————————————————————————————————————
 ;
 ; DrawDiskName is used to by the disk switch alert
@@ -841,137 +809,6 @@ DrawDiskName
 			rts
 EndDrawDiskName
 	
-	ELSE
-
-; The following procedures are used to draw the various disk-insertion and disk-removal
-; syserr messages for manual-eject systems.  The old DrawDiskName has been superseded by
-; the one below for these systems.
-
-; These constants are used by the disk-message-drawing code that follows
-TextTop		EQU		24
-TextEdge	EQU		72
-LineHeight	EQU		16
-
-;________________________________________________________________________________
-; DrawNameStr is used by the following three procs to draw the name of the disk
-; they need in their alert boxes.  A pointer to the string to draw as the name is
-; passed on top of the stack.  The strings included in this proc are also used by
-; the other procs.
-;________________________________________________________________________________
-			dc.w	dspDrawNameStr,EndDrawNameStr-DrawNameStr
-DrawNameStr
-			MOVEA.L	(SP)+,A0		; pop return addr
-			MOVE.L	(SP)+,D0		; and parameter
-			MOVEM.L	A0/D0,-(SP)		; swap them on the stack
-			
-			MOVE.W	#210,-(SP)									; “
-			MOVE.L	#((TextTop+LineHeight)<<16)+TextEdge,-(SP)	; start of second line
-			_MoveTo												; go there
-			_DrawChar											; draw “
-			
-			_DrawString											; draw name (already on stack)
-			
-			MOVE.W	#211,-(SP)									; ”
-			MOVE.W	#46,-(SP)									; .
-			_DrawChar											; draw .
-			_DrawChar											; draw ”
-			
-			RTS
-			
-; These strings are used by the disk-message-drawing procedures
-				STRING	pascal
-InsertString	DC.B	'Please insert the disk'
-RemoveString	DC.B	'Please remove the disk'
-UpdateString1	DC.B	'It needs to be updated'
-UpdateString2	DC.B	'before you remove it.'
-FromString		DC.B	'from drive '
-				STRING	asis
-				ALIGN
-EndDrawNameStr
-
-; DrawDiskName draws the message "Please insert the disk 'xxxx'"  It is used by both
-; the old disk-switch syserr and the new manual-eject error for ejected dirty disks.
-; It gets the disk name from the dsRecoverNamePtr field of the filesystem vars as the
-; old disk-switch code did.
-			dc.w	dspDrawDiskName,EndDrawDiskName-DrawDiskName
-DrawDiskName
-			PEA		InsertString						; "Please insert the disk"
-			MOVE.L	#(TextTop<<16)+TextEdge,-(SP)		; start of top line
-			_MoveTo										; go there
-			_DrawString									; draw message
-			
-			MOVEA.L	FSVarsPtr,A1
-			MOVE.L	FSVars.dsRecoverNamePtr(A1),-(SP)	; get name string
-			BSR		DrawNameStr							; draw it on second line
-			
-			RTS
-EndDrawDiskName
-
-
-; DrawDirtyDisk draws the same message as DrawDiskName and adds "It needs to be updated
-; before you remove it" below.  It is used to request the return of a manually-ejected
-; dirty disk.
-			dc.w	dspDrawDirtyDsk,EndDrawDirtyDsk-DrawDirtyDsk
-DrawDirtyDsk
-			PEA		UpdateString2									; "before you remove it."
-			MOVE.L	#((TextTop+3*LineHeight)<<16)+TextEdge,-(SP)	; start of fourth line
-			PEA		UpdateString1									; "It needs to be updated"
-			MOVE.L	#((TextTop+2*LineHeight)<<16)+TextEdge,-(SP)	; start of third line
-			PEA		InsertString									; "Please insert the disk"
-			MOVE.L	#(TextTop<<16)+TextEdge,-(SP)					; start of top line
-			_MoveTo													; go there
-			_DrawString												; draw "Please insert..."
-			_MoveTo													; go to third line
-			_DrawString												; draw "It needs..."
-			_MoveTo													; go to fourth line
-			_DrawString												; draw "before you..."
-			
-			MOVEA.L	FSVarsPtr,A1
-			MOVE.L	FSVars.dsRecoverNamePtr(A1),-(SP)	; get name string
-			BSR		DrawNameStr							; draw it on second line
-			
-			RTS
-EndDrawDirtyDsk
-
-
-; DrawRmvDsk draws the message "Please remove the disk 'xxxx' from drive y."  It is used
-; by the _Eject trap to get the user to eject a disk from a manual-eject drive.  The name
-; and drive number are pointed to by the dsRecoverNamePtr field of the filesystem vars used
-; by the disk-insertion procs.  If no name is available, the name ptr is set to nil and the
-; proc does not draw it, producing "Please remove the disk from drive y."  There is always
-; a drive number available.
-			dc.w	dspDrawRmvDsk,EndDrawRmvDsk-DrawRmvDsk
-DrawRmvDsk
-			MOVEA.L	FSVarsPtr,A1
-			MOVEA.L	FSVars.dsRecoverNamePtr(A1),A1	; A1 -> struct { short drvNum; char *diskName; }
-			
-			PEA		RemoveString									; "Please remove the disk"
-			MOVE.L	#(TextTop<<16)+TextEdge,-(SP)					; start of top line
-			MOVE.W	#46,-(SP)										; .
-			MOVE.W	(A1),D0											; drive number
-			OR.B	#$30,D0											; ASCII equivalent
-			MOVE.W	D0,-(SP)
-			PEA		FromString										; "from drive "
-			MOVE.L	#((TextTop+LineHeight)<<16)+TextEdge,-(SP)		; start of second line
-			
-			TST.L	2(A1)											; disk name OK?
-			BEQ.S	@drawfrom										; no: skip to "from drive"
-			MOVE.L	2(A1),-(SP)										; get disk name
-			BSR		DrawNameStr										; draw it on second line
-			MOVE.L	#((TextTop+2*LineHeight)<<16)+TextEdge,(SP)		; start of third line for "from..."
-			
-@drawfrom	_MoveTo													; go to proper line
-			_DrawString												; draw "from drive "
-			_DrawChar												; draw number
-			_DrawChar												; draw .
-			_MoveTo													; go to top line
-			_DrawString												; draw "Please remove..."
-			
-			RTS
-EndDrawRmvDsk
-
-	ENDIF	; hasManEject
-
 ; —————————————————————————————————————————————————
 ;
 ; DrawCurrentName is used to draw the name of the INIT or application which ate up too much memory.
diff --git a/Toolbox/AliasMgr/FolderMgr.a b/Toolbox/AliasMgr/FolderMgr.a
--- a/Toolbox/AliasMgr/FolderMgr.a
+++ b/Toolbox/AliasMgr/FolderMgr.a
@@ -13,7 +13,6 @@
 ;
 ;	   <SM4>	10/29/92	SWC		Backed out <SM3> and fixed the INCLUDE filenames.
 ;	   <SM3>	10/28/92	SWC		Changed the INCLUDEs to a LOAD of StandardEqu.d.
-;		<SM2>	10/22/92	CSS		Change short branches to word branches.
 ;		<24>	 6/12/91	LN		added #include 'SysPrivateEqu.a'
 ;		<23>	 4/16/91	PP		sad,#??????:After making _LockRng call for Network Trash, return
 ;									errors ioErr and paramErr (for unimplemented afp _LockRng) to
@@ -1352,7 +1351,7 @@ pDiskResult			equ			a4					; pointer to the resulting disk
 	endwith
 		move.l		d0,a0							; get handle in address register, too
 		tst.l		(a0)							; check if it is purged
-		bz 			Done							; <SM2> CSS
+		bz.s		Done
 
 		move.l		a0,cacheHandle					; use this later
 		_GetHandleSize								; get the full length of the handle
diff --git a/Toolbox/AliasMgr/alUtil.c b/Toolbox/AliasMgr/alUtil.c
--- a/Toolbox/AliasMgr/alUtil.c
+++ b/Toolbox/AliasMgr/alUtil.c
@@ -957,7 +957,7 @@ void AL_GetMyServer (StringPtr serverName) //I server name pointer
 
 	strH = GetString(kServerNameID);
 	if (strH != NULL)
-		BlockMove ((*strH), serverName, Length(*strH)+1);	//<SM4>
+		BlockMove ((*strH), serverName, GetHandleSize(strH));
 
 } // end of AL_GetMyServer routine
 
@@ -1795,8 +1795,7 @@ static Boolean SizeCompatible (AliasVolType thisVol, //I for this volume type
 
 		drvType = cpb.csParam[1] & kDriveTypeMask;
 
-		if ((drvType == 5) ||				// 4-Meg Typhoon
-			(drvType == 4) ||				// means super drive, all floppies will fit
+		if ((drvType == 4) ||				// means super drive, all floppies will fit
 		    (drvType == 3 && thisVol != kVolFloppy1400K) || // 800K drive, only 1.4Mb won't fit
 		    (drvType == 2 && thisVol == kVolFloppy400K)) // 400K drive, only 400K will fit
 			return (TRUE);
diff --git a/Toolbox/AppleEventMgr/AEHashtable.a b/Toolbox/AppleEventMgr/AEHashtable.a
--- a/Toolbox/AppleEventMgr/AEHashtable.a
+++ b/Toolbox/AppleEventMgr/AEHashtable.a
@@ -13,17 +13,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 6/12/92	RB		This file had a few DC.L which do not work from ROM.  The code
-;									was supposed to store offsets to routines used to allocate,
-;									deallocate and execute memory blocks.  Also, there was an option
-;									to store user supplied routine pointers in this code itself
-;									which was not actually used.  To make this code work from ROM it
-;									all came down to deleting a bunch of useless code, deleting
-;									macros and making the code that returns the default memory
-;									procedures return the standard ones.  Someone is going to have
-;									to take a good look at the functionality they originally wanted
-;									out of this code.  Anyway, the 50% of apps that were breaking on
-;									SuperMario will now run.
 ;		 <4>	 1/11/91	Lai		Fix new hash table size bug when number of entries is an exact
 ;									power of 2, and bug in GetIndexedEntry
 ;		 <3>	12/18/90	Lai		Chagne size of minimum hash table to avoid using excessive
@@ -1138,7 +1127,8 @@ BKeyWrongContinue
 		Deref	&Src,&Dest
 			SubQ	#4,SP
 			Move.L	&Src,-(SP)
-			bsr	DeRefMemory
+			Move.L	0(A3),D0
+			Bsr		CallMessage
 			Move.L	(SP)+,&Dest
 		ENDM
 		
@@ -1149,7 +1139,8 @@ BKeyWrongContinue
 			SubQ	#2,SP			; for result
 			Move.L	&Src,-(SP)
 			Move.L	&Size,-(SP)
-			bsr	SetMemorySize
+			Move.L	8(A3),D0
+			Bsr		CallMessage
 			Move.W	(SP)+,D0
 		ENDM
 		
@@ -1159,7 +1150,8 @@ BKeyWrongContinue
 		KillMem	&Src
 			SubQ	#2,SP			; for result
 			Move.L	&Src,-(SP)
-			bsr	DisposeMemory
+			Move.L	12(A3),D0
+			Bsr		CallMessage
 			Move.W	(SP)+,D0
 		ENDM
 		
@@ -1173,7 +1165,8 @@ BKeyWrongContinue
 			Move.L	&Size,-(SP)
 			Move.W	&SysHeap,-(SP)		; pass the sysHeap boolean
 			Move.L	A0,-(SP)		; point to Var
-			bsr	NewMemory
+			Move.L	4(A3),D0
+			Bsr		CallMessage
 			Move.W	(SP)+,D0
 			Move.L	(SP)+,A0		; return the block in A0.
 		ENDM
@@ -1568,23 +1561,66 @@ DeRefMemory	Head	,NoLink
 		Move.L	(A0),thePtr(SP)
 		Tail	FirstParam
 
+; GetDefaultMemProcs - returns the default memory procs
+; into a buffer of four 4-byte offsets (pass ptr in A3)
+GetDefaultMemProcs
+		Move.L	A3,A1					; get place to stuff the procs.
+		Move.L	#$FFFFFFFF,D0			; all of these are negative offsets
+		Move.W	#BaseAddress-DeRefMemory,D0
+		Move.L	D0,(A1)+				; stuff all the procs.
+		Move.W	#BaseAddress-NewMemory,D0
+		Move.L	D0,(A1)+
+		Move.W	#BaseAddress-SetMemorySize,D0
+		Move.L	D0,(A1)+
+		Move.W	#BaseAddress-DisposeMemory,D0
+		Move.L	D0,(A1)
+		Rts
+
 ;
 ; SetUpMemProcs - Install the default memory procs, if not already done
 ;
-;	This macro has been killed.
-;
+SetUpMemProcs
+		Move.L	D0,-(SP)				; save MemHooks pointer, is it zero?
+		Lea		MemProcsFlag,A3
+		ST		(A3)
+		Lea		MemProcs,A3
+		BSR.S	GetDefaultMemProcs
+
+		Move.L	(SP)+,D0				; custom table
+		Beq.S	@NoCustomTable
+		Move.L	D0,A0
+		Lea		CustomMemProcs,A3
+		BSR.S	GetDefaultMemProcs
+		MoveQ	#3,D1					; fill blanks with default method
+		Move.L	A3,A1
+@Loop	Move.L	(A0)+,D0
+		Beq.S	@Dflt
+		BSet	#0,D0
+		Move.L	D0,(A1)
+@Dflt	AddQ	#4,A1
+		DBRA	D1,@Loop
+
+@NoCustomTable
+		Rts
+
+MemProcsFlag	DC.L	0
+MemProcs		DC.L	0,0,0,0
+CustomMemProcs	DC.L	0,0,0,0
 
 ;
-; SetUpMemProcs		;;; Move.L	MemProcs(SP),D0	; should be done already.
+; SetUpMemProcs
 ; _______________
 		MACRO
 		SetUpMemProcs
+		Bne.S	@SurelyDoIt
+		Lea		MemProcs,A3
+		Move.L	MemProcsFlag,D0
+		Bne.S	@DontDoIt
+		@SurelyDoIt:
+		BSR		SetUpMemProcs
+		@DontDoIt:
 		ENDM
 
-
-
-; <SM2> rb, space for variables moved to global record so this code works from ROM.
-
 ;
 ; SetUpHashCustom - set up the HashCustom field of the table, if it's nil.
 ;.
@@ -3044,41 +3080,6 @@ SetGrowThreshhold	Head	A2-A3,LocalSize
 		
 		EndWith
 		
-; GetDefaultMemProcs - returns the default memory procs. 
-		
-;	Function	GetDefaultMemProcs: MemProcs;
-
-GetDMPFrame	Record	{A6Link},Decr
-MemProcs	DS.L	1
-ReturnAddr	DS.L	1
-A6Link		DS.L	1
-LocalSize	EQU	*
-		EndR
-		With	GetDMPFrame
-		
-GetDefaultMemProcs	Head	A2-A3,LocalSize
-		IF	NotLobotimised	THEN
-
-		Break	'GetDefaultMemProcs'
-; set up the mem procs.
-
-		Clr.L	D0				; nil ensures the hooks will be set up.
-		SetUpMemProcs				; puts hooks, or defualt into A3.
-
-		Move.L	MemProcs(A6),A1			; get place to stuff the procs.
-		lea	DeRefMemory,a0			;					<SM2> rb
-		Move.L	A0,(A1)+			; stuff all the procs.			<SM2> rb
-		lea	NewMemory,a0			;					<SM2> rb
-		Move.L	a0,(A1)+			;					<SM2> rb
-		lea	SetMemorySize,a0		;					<SM2> rb
-		Move.L	a0,(A1)+			;					<SM2> rb
-		lea	DisposeMemory,a0		;					<SM2> rb
-		Move.L	a0,(A1)				;					<SM2> rb
-		ENDIF					; NotLobotimised
-		Tail	ReturnAddr			; restore regs, strip stack and return.
-		
-		EndWith
-		
 		ENDIF					; ForAppleEventsOnly.
 		
 		EndWith
diff --git a/Toolbox/CommToolbox/CommResourceMgr/CommResourceMgr.a b/Toolbox/CommToolbox/CommResourceMgr/CommResourceMgr.a
--- a/Toolbox/CommToolbox/CommResourceMgr/CommResourceMgr.a
+++ b/Toolbox/CommToolbox/CommResourceMgr/CommResourceMgr.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM3>	 9/28/93	PN		Adding two new calls AddStdPort and RemoveStdPort to the
-;									CommResourceManager from DBLite gibbly.
 ;		 <2>	 8/12/93	kc		<mb>: I deleted all of the "TheFuture" conditionals in all of
 ;									the CommToolbox files per Mike Bell's instructions. I also
 ;									deleted the code that was compiled under the "CubeE"
@@ -122,11 +120,6 @@ CRMStart
 															;	new for 1.0.1
 	DC.W		@CRMGetToolResource 		- CRMStart		;	23
 	DC.W		@CRMReleaseToolResource 	- CRMStart		;	24
-	
-	DC.W		@CRMParseCAPSResource	 	- CRMStart		;	25
-	DC.W		@CRMGetToolNamedResource 	- CRMStart		;	26
-	DC.W		@CRMAddStdPort			 	- CRMStart		;	27
-	DC.W		@CRMRemoveStdPort 			- CRMStart		;	28
 
 @None
 					RTS
@@ -317,40 +310,4 @@ CRMStart
 					MOVE.L	2(A0), -(SP)	;	theHandle
 					JSR		__CRMReleaseToolResource		; call it
 					RTS
-
-@CRMParseCAPSResource		;	25
-					CLR.W	-(SP)			; 	make space for return value
-					MOVE.L	10(A0),-(SP)	;	value
-					MOVE.L	6(A0), -(SP)	; 	selector
-					MOVE.L	2(A0), -(SP)	;	theHandle
-					JSR		__CRMParseCAPSResource		; call it
-					MOVE.W	(SP)+,D0		; get the return value
-					RTS
- 
-@CRMGetToolNamedResource	;	26
-					CLR.L	-(SP)			; 	make space for return value
-					MOVE.W	10(A0),-(SP)	;	procID
-					MOVE.L	6(A0), -(SP)	; 	type
-					MOVE.L	2(A0), -(SP)	;	name
-					JSR		__CRMGetToolNamedResource		; call it
-					MOVE.L	(SP)+,D0		; get the return value
-					RTS
- 
-@CRMAddStdPort				;	27
-					CLR.L	-(SP)			; 	make space for return value
-					MOVE.W	10(A0),-(SP)	;	procID
-					MOVE.L	6(A0), -(SP)	; 	type
-					MOVE.L	2(A0), -(SP)	;	name
-					JSR		AddPort			; call it
-					MOVE.L	(SP)+,D0		; get the return value
-					RTS
- 
-@CRMRemoveStdPort			;	28
-					CLR.L	-(SP)			; 	make space for return value
-					MOVE.W	10(A0),-(SP)	;	procID
-					MOVE.L	6(A0), -(SP)	; 	type
-					MOVE.L	2(A0), -(SP)	;	name
-					JSR		RemovePort		; call it
-					MOVE.L	(SP)+,D0		; get the return value
-					RTS
 					END
diff --git a/Toolbox/CommToolbox/CommResourceMgr/CommResourceMgrUtilities.a b/Toolbox/CommToolbox/CommResourceMgr/CommResourceMgrUtilities.a
--- a/Toolbox/CommToolbox/CommResourceMgr/CommResourceMgrUtilities.a
+++ b/Toolbox/CommToolbox/CommResourceMgr/CommResourceMgrUtilities.a
@@ -10,10 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		 <4>	 8/12/93	kc		<mb>: I deleted all of the "TheFuture" conditionals in all of
-;									the CommToolbox per Mike Bell's instructions. I also had to
-;									delete some old code that was compiled under the "CubeE"
-;									conditional.
 ;		<15>	  6/8/92	JSM		Fix ProcessMgrExists routine (already conditionalized for
 ;									TheFuture) to match the one in FileMgrPatches.a that looks at
 ;									emProcessMgrExists. Like that file, we may want to invert the
@@ -349,12 +345,14 @@ RetAddr 	DS.L	1			; place holder for return address
 		move.l	TheZone,d3
 	
 ;================================================= start <10>
+		IF NOT CubeE THEN
 @pmcheck										; check for process manager
 		moveq	#1,d5							; does not exist
 		bsr		ProcessMgrExists
 		bne.s	@afterpmcheck
 		moveq	#0,d5							; does exist
 @afterpmcheck
+		ENDIF
 ;------------------------------------------------- end <10>
 	
 @tryAgain
@@ -419,11 +417,14 @@ RetAddr 	DS.L	1			; place holder for return address
 		move.l	a1,a3
 		moveq	#32,d0
 		_BlockMove
-		bra.s	@tryAgain
+		bra		@tryAgain
 
 @gotRealFile
 
 ;================================================= start <10>
+		IF CubeE THEN
+	MOVEM.L	D0-D2/A0-A2,-(SP)
+		ELSE
 	MOVEM.L	D1-D2,-(SP)						; save registers for the duration of the open
 											; D1 is vrefnum, D2 is dirID
 		tst.l	d5							; process mgr?
@@ -436,6 +437,7 @@ RetAddr 	DS.L	1			; place holder for return address
 @afterbegin1
 
 	MOVEM.L	(SP),D1-D2						; changed number of saved registers from D0-D2/A0-A2
+		ENDIF
 ;------------------------------------------------- end <10>
 	
 	
@@ -449,6 +451,9 @@ RetAddr 	DS.L	1			; place holder for return address
 
 
 ;================================================= start <10>
+		IF CubeE THEN
+	MOVEM.L	(SP)+,D0-D2/A0-A2
+		ELSE
 		tst.l	d5							; process mgr?
 		bne.s	@afterend1					
 		
@@ -458,6 +463,7 @@ RetAddr 	DS.L	1			; place holder for return address
 		
 @afterend1									
 	MOVEM.L	(SP)+,D1-D2						; restore vrefnum and dirID
+		ENDIF
 ;------------------------------------------------- end <10>
 	
 		cmp.w	#-1,D4						; Did we have an error
@@ -513,6 +519,7 @@ RetAddr 	DS.L	1			; place holder for return address
 		
 @problem									; let's close down the file now
 ;================================================= start <10>
+		IF NOT CubeE THEN
 		tst.l	d5							; process mgr?
 		bne.s	@afterbegin2				; <10>
 
@@ -520,12 +527,14 @@ RetAddr 	DS.L	1			; place holder for return address
 		_BeginSystemMode					
 		addq	#2,sp
 @afterbegin2
+		ENDIF
 ;------------------------------------------------- end <10>
 	
 		move.w	d4,-(SP)
 		_CloseResFile
 
 ;================================================= start <10>
+		IF NOT CubeE THEN
 		tst.l	d5							; process mgr?
 		bne.s	@afterend2					; <10>
 
@@ -533,6 +542,7 @@ RetAddr 	DS.L	1			; place holder for return address
 		_EndSystemMode
 		addq	#2,sp
 @afterend2
+		ENDIF
 ;------------------------------------------------- end <10>
 	
 @problem1
@@ -641,6 +651,7 @@ refNum	DS.W	1
 		move.w	d1,-(sp)							; d1 is volatile.  d1 is also the refnum so just save
 													; 	thepart we care about
 
+		IF NOT CubeE THEN
 		moveq	#1,D3								; no pm
 		bsr		ProcessMgrExists			
 		bne.s	@afterbegin3		
@@ -651,6 +662,7 @@ refNum	DS.W	1
 
 		moveq	#0,D3
 @afterbegin3
+		ENDIF
 
 ;------------------------------------------------- end <10>
 											; refnum is already on stack (see above) <10>
@@ -658,6 +670,7 @@ refNum	DS.W	1
 
 
 ;================================================= start <10>
+		IF NOT CubeE THEN
 		tst.l	d3							; process mgr?
 		bne.s	@afterend1
 
@@ -665,6 +678,7 @@ refNum	DS.W	1
 		_EndSystemMode	
 		addq	#2,sp
 @afterend1
+		ENDIF
 
 ;------------------------------------------------- end <10>
 
@@ -1183,7 +1197,7 @@ RetAddr 	DS.L	1			; place holder for return address
 ;	 Exit
 ;		D0 - OSErr
 __CRMGetIndToolName FUNC
-		IMPORT	CRMFindCommunications, CRMCreateCommunications, CRMGetIndFile
+		IMPORT	CRMFindCommunications, CRMCreateCommunications, __CRMGetIndFile
 
 Parms	Record 0
 sel			ds.w	1
@@ -1221,11 +1235,6 @@ RetAddr 	DS.L	1			; place holder for return address
 			bra.s	@done						; just made -> no tools here yet
 			
 @FolderExists
-; pascal OSErr	CRMGetIndFile(Str63 fName, OSType fType, short vRefNum, long dirID, short index);
-
-
-			clr.w	-(sp)						; return value
-
 	
 			move.l	Parms.toolName(a2),-(sp)	; Ok, now get the info on the file
 			move.l	Parms.bundleType(a2),-(sp)
@@ -1233,8 +1242,12 @@ RetAddr 	DS.L	1			; place holder for return address
 			move.l	Locals.DirID(a6),-(sp)
 			move.w	Parms.Index(a2),-(sp)
 			
+			clr.w	-(sp)						; return value
+			move.l	sp,a0
 
-			jsr		CRMGetIndFile
+			jsr		__CRMGetIndFile
+
+			add		#4+4+2+4+2+2,sp
 
 	
 @done
diff --git a/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxDispatcher.a b/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxDispatcher.a
--- a/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxDispatcher.a
+++ b/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxDispatcher.a
@@ -11,9 +11,6 @@
 ;	   <SM3>	  7/6/92	PN		Take out emCommToolBoxTable and replcace it with
 ;									CommToolboxTable field in CTBBlock.  Also delete BigModel since
 ;									it's not used
-;	   <SM2>	 6/30/92	PN		Change CommToolboxDispatcher to use ExpandMem to store the
-;									dispatch table instead of pc relative so that this will work in
-;									SM
 ;		 <7>	 10/2/90	kaz		CM, FT, and TM are now loaded using the CRM to keep track of the
 ;									resources and the apps that call them. <jng>
 ;		 <6>	 9/18/90	kaz		Backing out last change to load the CM, TM, and FT using CRM.
@@ -94,6 +91,10 @@ JUGGLERTRAP		EQU		$A88F			; juggler dispatch trap
 
 COMMTOOLBOXDISPATCHER		FUNC	EXPORT
 				
+				BRA.S	EndMyCommToolboxGlobals
+MyCommToolboxGlobals
+				DCB.B	CTBBlock.CTBBlockSize - 8, 0	; ?bug, used old CommToolboxPriv.a
+EndMyCommToolboxGlobals
 				MOVEM.L	D3-D7/A3-A4,-(SP)	; save registers - across call
 ;
 ;	register conventions
@@ -115,13 +116,14 @@ COMMTOOLBOXDISPATCHER		FUNC	EXPORT
 				AND.L	D1,D3				; mask out message…
 				LSR.L	#8,D3				; and shift out lower byte to get manager
 
-				MOVE.L	CommToolboxGlobals,A1		; get expanded memory area <SM3>
-				WITH	CTBBlock
-				MOVE.L	CommToolBoxTable(A1),A2	; get pointer to dispatch table <SM3>
-				ENDWITH
+				LEA		MyCommToolboxGlobals,A2
 				CMP.L	#1,D2				; is message = 1? (init msg)
 				BNE.S	@GoForIt			; nope, so just go and execute it
 
+				MOVE.W	EndMyCommToolboxGlobals-2,D5
+				TST.W	D5
+				BEQ.S	@LoadIt
+				BRA.S	@GoForIt
 
 @LoadIt			CLR.L	-(SP)				; clear space
 				MOVE.L	#CTB_ConnectionMgrType, -(SP)		; push resource type
diff --git a/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxPatches.a b/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxPatches.a
--- a/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxPatches.a
+++ b/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxPatches.a
@@ -14,9 +14,6 @@
 ;									the CommToolbox files per Mike Bell's instructions. I also had
 ;									to delete some old code that was compiled under the "CubeE"
 ;									conditional.
-;	   <SM3>	  7/6/92	PN		Take out emCommToolboxGlobals and put it in the existing
-;									CTBBlock.
-;	   <SM2>	 6/30/92	PN		Add init routines to allocate space for the dispatch table
 ;		<18>	 10/4/91	JSM		Change PsychoticFarmerOrLater conditionals to TheFuture.
 ;		<17>	 10/2/91	DTY		Conditionalise <14> through <16> out of CubeE.
 ;		<16>	  7/3/91	BH		omitted setting gestaltTermMgrErrorString bit
@@ -66,12 +63,12 @@
 ;====================================================================================================
 ;====================================================================================================
 
-;•••ROMs Plus,SE,II,Portable,IIci <SM2>
+					ROMs Plus,SE,II,Portable,IIci
 
 ;====================================================================================================
 ;	this installs the CommToolbox dispatch mechanism…
 
-;•••	MakePatch COMMTOOLBOXDISPATCHER,_CommToolboxDispatch <SM2>
+					MakePatch COMMTOOLBOXDISPATCHER,_CommToolboxDispatch
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 ;;;;;;;;;;;;;;;;;;;;;WARNING WARNING WARNING WARNING WARNING
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -106,7 +103,7 @@
 
 ;====================================================================================================
 ;	this sets up the CommToolbox global variable
-SetupGlobals		installproc
+SetupGlobals		installproc		(Plus,SE,II,Portable,IIci)
 
 		; allocate CommToolbox low memory and CommToolBoxTable
 					WITH CTBBlock						; allocate CTB low memory block
@@ -116,10 +113,6 @@ SetupGlobals		installproc
 
 					MOVE.L		A1,CommToolboxGlobals	; stuff into low mem pointer
 
-					MOVEQ		#(19*4),D0					; •19 long entries <SM3>
-					_NewPtr 	,Sys,Clear					; <SM3>
-					MOVE.L		A0,CommToolBoxTable(A1) 	; stuff pointer in our global <SM3>			
-
 		; setup version
 					MOVE.W		#CTBBlockVersion, version(A1)
 
@@ -134,15 +127,12 @@ SetupGlobals		installproc
 					_InitCTBUtilities
 					ADDQ		#4,SP					; pop both return values
 
-		;Call RegisterBuiltInPorts
-					Import	RegisterBuiltInPorts    ;<SM2>
-					JSR		RegisterBuiltInPorts	;<SM2>
 					rts
 					endproc
 
 ;====================================================================================================
 ;	this sets up the gestalt selectors
-SetupGestalt		installproc
+SetupGestalt		installproc		(Plus,SE,II,Portable,IIci)
 					import		getCTBVersion
 					import		getCMAttr
 					import		getFTAttr
@@ -206,7 +196,7 @@ SetupGestalt		installproc
 ;====================================================================================================
 ;	this sets up the builtin serial port registration
 
-;••• MakeInstall RegisterBuiltInPorts <SM2>
+					MakeInstall RegisterBuiltInPorts
 
 
 ;====================================================================================================
@@ -253,7 +243,6 @@ getCMAttr											; features as bits
 getFTAttr											; features as bits
 					CLR.L	D0								; clear our gestalt value
 					BSET	#gestaltFXfrMgrPresent,D0
-					BSET	#gestaltFXfrMgrMultiFile,D0
 					BSET	#gestaltFXfrMgrErrorString,D0
 					bra.s	stdOK
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
@@ -266,8 +255,6 @@ getTMAttr											; features as bits
 getCRMAttr											; features as bits
 					CLR.L	D0								; clear our gestalt value
 					BSET	#gestaltCRMPresent,D0
-;					BSET	#gestaltCRMToolRsrcCalls,D0
-;					BSET	#gestaltCRMPersistentFix,D0
 					bra.s	stdOK
 ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 getDITLAttr											; features as bits
diff --git a/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxPatches.c b/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxPatches.c
--- a/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxPatches.c
+++ b/Toolbox/CommToolbox/CommToolboxStartup/CommToolboxPatches.c
@@ -95,7 +95,7 @@ pascal void CleanUpCommToolbox()
 //		is closed.
 //
 
-		while (CRMReleaseRF(oldRefNum) == noErr)
+		if (CRMReleaseRF(oldRefNum) == noErr)
 			;
 	}
 
diff --git a/Toolbox/CommToolbox/CommToolboxUtilities/Choose/Choose.p b/Toolbox/CommToolbox/CommToolboxUtilities/Choose/Choose.p
--- a/Toolbox/CommToolbox/CommToolboxUtilities/Choose/Choose.p
+++ b/Toolbox/CommToolbox/CommToolboxUtilities/Choose/Choose.p
@@ -409,12 +409,6 @@ BEGIN
 	IF theHandle = NIL THEN
 		cRec.msg := BOR(cRec.msg, ctbChooseNoChangeHandle);		{ app needs to allocate records}
 
-	IF (BAND(cRec.msg, ctbChooseNoDialog) = ctbChooseNoDialog) THEN			{ check for special case }
-	BEGIN
-		ChooseEntry := DoBackDoor(msg, theHandle, cRec);
-		Exit(ChooseEntry);
-	END;
-
 	savedRes := CurResFile;								{ avoid application resources <AMR 25> }
 	UseResFile(0);										{ <AMR 25> }
 														{ preflight values }
@@ -445,7 +439,6 @@ BEGIN
 	{ we need to tell the StdFilterProc to handle the default and cancel buttons }
 	IF SetDialogDefaultItem(theDialog, ChooseItemOK) <> noErr THEN;
 	IF SetDialogCancelItem(theDialog, ChooseItemCancel) <> noErr THEN;
-	IF SetDialogTracksCursor(theDialog, true) <> noErr THEN;
 
 	WITH infoP^ DO BEGIN
 		SetCursor(myWatch);
@@ -924,14 +917,6 @@ BEGIN
 	theErr := noErr;
 
 	WITH infoP^ DO BEGIN
-{begin addition <21>}
-{	this makes sure that the menu is empty so that after a crash we don't get the trailing X's }
-		maxTools := CountMItems(hMenu);
-		for theItem := 1 TO maxTools do
-			DelMenuItem(hMenu, theItem);
-		maxTools := 0;
-		theItem := 1;
-{end addition <21>}
 
 		WHILE theErr = noErr DO BEGIN
 			theErr := CRMGetIndFile(tempTool,theType, vRefNum, dirID, theItem);
@@ -943,9 +928,6 @@ BEGIN
 					{ Call the App's filter proc	}
 					includeIt := TRUE;							{ include it }
 
-					IF cRec.filterProc <> NIL THEN
-						includeIt:= DoAppFilter(@tempTool,msg,theHandle,cRec.filterProc);
-
 					IF includeIt THEN BEGIN
 						{ Is this the current tool? }
 						IF EqualString(tempTool, toolName, FALSE, TRUE) THEN
diff --git a/Toolbox/CommToolbox/CommToolboxUtilities/CommToolboxCore.c b/Toolbox/CommToolbox/CommToolboxUtilities/CommToolboxCore.c
--- a/Toolbox/CommToolbox/CommToolboxUtilities/CommToolboxCore.c
+++ b/Toolbox/CommToolbox/CommToolboxUtilities/CommToolboxCore.c
@@ -12,10 +12,6 @@
 
 	Change History (most recent first):
 
-		 <2>	 8/12/93	kc		<mb>: I deleted all of the "TheFuture" conditionals in all of
-									the CommToolbox files per Mike Bell's instructions. I also had
-									to delete some old code that was compiled under the "CubeE"
-									conditional.
 		<11>	 10/4/91	JSM		Change PsychoticFarmerOrLater to TheFuture.
 		<10>	 10/2/91	DTY		Conditionalise <9> out of CubeE.
 		 <9>	  7/1/91	BH		fix CTBGetErrorString to return empty string if the tool returns
@@ -568,11 +564,15 @@ pascal Boolean __CTBMenu(CoreHandle hCore,short menuid,short item )
 
 pascal void __CTBGetErrorString(CoreHandle hCore,short id,Str255 errMsg,short MgrSel)
 {
-	long rval;
+#if !CubeE
+	long rval =
+#endif
 	
-	rval = CallToolProc(nil,hCore,(MgrSel == CMSel ? cmGetErrorStringMsg : CTBGetErrorStringMsg),
+	CallToolProc(nil,hCore,(MgrSel == CMSel ? cmGetErrorStringMsg : CTBGetErrorStringMsg),
 	 																	id,(long) errMsg,0,nil);
+#if !CubeE
 	if (rval) errMsg[0] = 0;						// return empty string if there is a problem
+#endif
 }
 
 pascal void __CTBEvent(CoreHandle hCore,EventRecord *theEvent)
diff --git a/Toolbox/CommToolbox/CommToolboxUtilities/StandardNBP/StandardNBP.r b/Toolbox/CommToolbox/CommToolboxUtilities/StandardNBP/StandardNBP.r
--- a/Toolbox/CommToolbox/CommToolboxUtilities/StandardNBP/StandardNBP.r
+++ b/Toolbox/CommToolbox/CommToolboxUtilities/StandardNBP/StandardNBP.r
@@ -140,7 +140,7 @@ resource 'DITL' (CTB_NulookupDITLID, purgeable) {
 			disabled
 		},
 		/* [9] version string */
-#ifdef Pre70
+#if Pre70
 		{194, 10, 207, 176},
 #else
 		{197, 10, 207, 176},			// need more room for focus
@@ -168,7 +168,7 @@ resource 'DITL' (CTB_NulookupDITLID, purgeable) {
 		UserItem {
 			disabled
 		},
-#ifndef Pre70
+#if !Pre70
 		/* [14] hdlg ref 	*/
 		{0, 0, 0, 0},
 		HelpItem {
diff --git a/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgr.a b/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgr.a
--- a/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgr.a
+++ b/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgr.a
@@ -80,6 +80,9 @@ CMEntry			MAIN		EXPORT
 							__CMAddSearch, __CMRemoveSearch, __CMClearSearch, __CMIOKill, \
 							__CMNewIOPB, __CMDisposeIOPB, __CMPBRead, __CMPBWrite, \
 							__CMPBIOKill
+	IF CubeE THEN
+				IMPORT		__CM35, __CM36, __CM37, __CM38, __CM39, __CM3A, __CM3B
+	ENDIF
 	
 
 				BRA.S	start
@@ -154,6 +157,13 @@ CMStart
 	DC.W		@CMPBRead					- CMStart; 32
 	DC.W		@CMPBWrite					- CMStart; 33
 	DC.W		@CMPBIOKill					- CMStart; 34
+	DC.W		@CM35						- CMStart; 35
+	DC.W		@CM36						- CMStart; 36
+	DC.W		@CM37						- CMStart; 37
+	DC.W		@CM38						- CMStart; 38
+	DC.W		@CM39						- CMStart; 39
+	DC.W		@CM3A						- CMStart; 3A
+	DC.W		@CM3B						- CMStart; 3B
 
 @CMSetRefCon		; 258
 			_ExternalCore	#$40A
@@ -380,6 +390,73 @@ CMStart
 					RTS
 
 	
+	IF CubeE THEN
+@CM35
+					CLR.W	-(SP)			; make room
+					MOVE.L	4(A0), -(SP)	; hConn
+					MOVE.B	2(A0), -(SP)	; async
+					JSR		__CM35
+					MOVE.W	(SP)+, D0		; return point
+					RTS
+
+
+@CM36
+					CLR.W	-(SP)			; make room
+					MOVE.L	4(A0), -(SP)
+					MOVE.B	2(A0), -(SP)
+					JSR		__CM36
+					MOVE.W	(SP)+, D0		; return point
+					RTS
+
+
+@CM37
+					CLR.W	-(SP)			; make room
+					MOVE.L	4(A0), -(SP)
+					MOVE.B	2(A0), -(SP)
+					JSR		__CM37
+					MOVE.W	(SP)+, D0		; return point
+					RTS
+
+
+@CM38
+					CLR.W	-(SP)			; make room
+					MOVE.L	6(A0), -(SP)
+					MOVE.B	4(A0), -(SP)
+					MOVE.B	2(A0), -(SP)
+					JSR		__CM38
+					MOVE.W	(SP)+, D0		; return point
+					RTS
+
+
+@CM39
+					CLR.W	-(SP)			; make room
+					MOVE.L	12(A0), -(SP)
+					MOVE.L	10(A0), -(SP)
+					MOVE.L	6(A0), -(SP)
+					MOVE.L	2(A0), -(SP)
+					JSR		__CM39
+					MOVE.W	(SP)+, D0		; return point
+					RTS
+
+
+@CM3A
+					CLR.W	-(SP)			; make room
+					MOVE.L	12(A0), -(SP)
+					MOVE.L	10(A0), -(SP)
+					MOVE.L	6(A0), -(SP)
+					MOVE.L	2(A0), -(SP)
+					JSR		__CM3A
+					MOVE.W	(SP)+, D0		; return point
+					RTS
+
+
+@CM3B
+					MOVE.L	2(A0), -(SP)
+					JSR		__CM3B
+					RTS
+	ENDIF
+
+
 @CMPBIOKill
 					CLR.W	-(SP)			; make room
 					MOVE.L	6(A0), -(SP)	; hConn
diff --git a/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgrExtensions.c b/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgrExtensions.c
--- a/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgrExtensions.c
+++ b/Toolbox/CommToolbox/ConnectionMgr/ConnectionMgrExtensions.c
@@ -148,3 +148,130 @@ pascal CMErr  __CMPBIOKill(hConn, theIOPB)
 			(long) theIOPB, 0, 0 );
 	return(rval);
 }
+
+#if CubeE
+pascal CMErr  __CM35(hConn, async)
+	ConnHandle 	hConn;
+	Boolean 	async;
+{
+	CMErr			rval;
+	pascal long		(*callProc) (ConnHandle, short, long, long, long);
+	
+	(ProcPtr) callProc = (**hConn).defProc;
+	rval = (CMErr)(*callProc) ( hConn, 116, 
+			(async ? 1 : 0), 0, 0 );
+	return(rval);
+}
+
+pascal CMErr  __CM36(hConn, async)
+	ConnHandle 	hConn;
+	Boolean 	async;
+{
+	CMErr			rval;
+	pascal long		(*callProc) (ConnHandle, short, long, long, long);
+	
+	(ProcPtr) callProc = (**hConn).defProc;
+	rval = (CMErr)(*callProc) ( hConn, 117, 
+			(async ? 1 : 0), 0, 0 );
+	return(rval);
+}
+
+pascal CMErr  __CM37(hConn, async)
+	ConnHandle 	hConn;
+	Boolean 	async;
+{
+	CMErr			rval;
+	pascal long		(*callProc) (ConnHandle, short, long, long, long);
+	
+	(ProcPtr) callProc = (**hConn).defProc;
+	rval = (CMErr)(*callProc) ( hConn, 118, 
+			(async ? 1 : 0), 0, 0 );
+	return(rval);
+}
+
+pascal CMErr  __CM38(hConn, async, bsync)
+	ConnHandle 	hConn;
+	Boolean 	async;
+	Boolean 	bsync;
+{
+	CMErr			rval;
+	pascal long		(*callProc) (ConnHandle, short, long, long, long);
+	
+	(ProcPtr) callProc = (**hConn).defProc;
+	rval = (CMErr)(*callProc) ( hConn, 119, 
+			(async ? 1 : 0), (bsync ? 1 : 0), 0 );
+	return(rval);
+}
+
+struct BoobTown {
+	Boolean a;
+	long b;
+};
+
+pascal CMErr  __CM39(hConn, async, zoom1, zoom2)
+	ConnHandle 	hConn;
+	Boolean 	async;
+	long		zoom1;
+	long		zoom2;
+{
+	CMErr			rval;
+	pascal long		(*callProc) (ConnHandle, short, struct BoobTown *, long, long);
+	struct BoobTown MyStruct;
+	char theState;
+
+	MyStruct.a = async;
+	MyStruct.b = zoom1;
+
+	theState = HGetState(hConn);
+	(**hConn).flags &= ~cmStatusReserved0;
+
+	if(theState & 0x80) (**hConn).flags |= cmStatusReserved0;
+
+	HLock(hConn);
+	
+	(ProcPtr) callProc = (**hConn).defProc;
+	rval = (CMErr)(*callProc) ( hConn, 120, 
+			&MyStruct, zoom2, 0 );
+	return(rval);
+}
+
+pascal CMErr  __CM3A(hConn, async, zoom1, zoom2) /* Identical to previous except that selector is 121 not 120 */
+	ConnHandle 	hConn;
+	Boolean 	async;
+	long		zoom1;
+	long		zoom2;
+{
+	CMErr			rval;
+	pascal long		(*callProc) (ConnHandle, short, struct BoobTown *, long, long);
+	struct BoobTown MyStruct;
+	char theState;
+
+	MyStruct.a = async;
+	MyStruct.b = zoom1;
+
+	theState = HGetState(hConn);
+	(**hConn).flags &= ~cmStatusReserved0;
+
+	if(theState & 0x80) (**hConn).flags |= cmStatusReserved0;
+
+	HLock(hConn);
+	
+	(ProcPtr) callProc = (**hConn).defProc;
+	rval = (CMErr)(*callProc) ( hConn, 121, 
+			&MyStruct, zoom2, 0 );
+	return(rval);
+}
+
+pascal void  __CM3B(hConn)
+	ConnHandle 	hConn;
+{
+	CMErr			rval;
+	pascal long		(*callProc) (ConnHandle, short, long, long, long);
+	
+	(ProcPtr) callProc = (**hConn).defProc;
+	rval = (CMErr)(*callProc) ( hConn, 122, 
+			0, 0, 0 );
+
+	if(!((**hConn).flags & cmStatusReserved0)) HUnlock(hConn);
+}
+#endif
diff --git a/Toolbox/CommToolbox/FileTransferMgr/FileTransferMgr.a b/Toolbox/CommToolbox/FileTransferMgr/FileTransferMgr.a
--- a/Toolbox/CommToolbox/FileTransferMgr/FileTransferMgr.a
+++ b/Toolbox/CommToolbox/FileTransferMgr/FileTransferMgr.a
@@ -105,8 +105,6 @@ FTList
 	DC.W		@FTPChoose						- FTList;21
 	DC.W		@FTSetupXCleanup				- FTList;22
 	DC.W		@FTGetErrorString				- FTList;23
-	DC.W		@FTSend							- FTList;24
-	DC.W		@FTReceive						- FTList;25
 	
 @FTSetRefCon		; 258
 			_ExternalCore	#$40A
@@ -214,22 +212,4 @@ FTList
 				LEA		Version, A0
 				MOVE.W	(A0), D0		; put version number
 				RTS
-
-@FTSend		
-				CLR.W	-(SP)
-				MOVE.L	12(a0),-(SP)	; hFT
-				MOVE.W	10(A0),-(SP)	; numFiles
-				MOVE.L	6(A0),-(SP)		; pFSpec
-				MOVE.L	2(A0), -(SP)	; notifyProc
-				JSR		__FTSend
-				MOVE.W	(SP)+,D0
-				RTS
-@FTReceive
-				CLR.W	-(SP)
-				MOVE.L	10(a0),-(SP)	; hFT
-				MOVE.L	6(A0),-(SP)		; pFSpec
-				MOVE.L	2(A0), -(SP)	; notifyProc
-				JSR		__FTReceive
-				MOVE.W	(SP)+,D0
-				RTS
 				END
diff --git a/Toolbox/ComponentMgr/ComponentManagerSelectors.h b/Toolbox/ComponentMgr/ComponentManagerSelectors.h
--- a/Toolbox/ComponentMgr/ComponentManagerSelectors.h
+++ b/Toolbox/ComponentMgr/ComponentManagerSelectors.h
@@ -33,12 +33,3 @@
 	ComponentDispatch (UnloadComponent , OSErr , 32);
 	ComponentDispatch (OpenDefaultComponent , ComponentInstance , 33);
 	ComponentDispatch (ComponentSearch , void , 34);
-	ComponentDispatch (ValidComponent , RegisteredComponentPtr, 35);
-	ComponentDispatch (xDelegateStub , void, -36);
-	ComponentDispatch (ValidComponentInstance , RegisteredComponentInstancePtr , 37);
-	ComponentDispatch (GrowRegisteredComponentInstanceTable , OSErr, 38);
-	ComponentDispatch (GrowRegisteredComponentTable , OSErr, 39);
-	ComponentDispatch (GetComponentInfoPrivate , OSErr, 40);
-	ComponentDispatch (GetComponentIconSuite , OSErr, 41);
-	ComponentDispatch (RegisterROMComponents , void, 42);
-	ComponentDispatch (ResolveComponentPlatform , short, 43);
\ No newline at end of file
diff --git a/Toolbox/ComponentMgr/PrivateThingManager.h b/Toolbox/ComponentMgr/PrivateThingManager.h
--- a/Toolbox/ComponentMgr/PrivateThingManager.h
+++ b/Toolbox/ComponentMgr/PrivateThingManager.h
@@ -127,6 +127,7 @@ typedef struct rtFile
 	short	referenceCount;
 	short	vRefNum;
 	long	fileID;
+	Str63	name;
 	} rtFile;
 
 
@@ -155,6 +156,6 @@ typedef struct
 #define kComponentInstanceAllocationSize 32
 #define kComponentFileAllocationSize 1
 
-void doComponentSearch (void);
+pascal void __ComponentSearch (void);
 
 #endif _PrivateThingManager_
\ No newline at end of file
diff --git a/Toolbox/ComponentMgr/ThingFiles.c b/Toolbox/ComponentMgr/ThingFiles.c
--- a/Toolbox/ComponentMgr/ThingFiles.c
+++ b/Toolbox/ComponentMgr/ThingFiles.c
@@ -80,77 +80,31 @@ Boolean FSSpecEqual( register FSSpec *fileSpecA, register FSSpec *fileSpecB )
 short AddComponentFSSpec( FSSpec *fspec )
 {
 	register rtFile *rtFileList = ComponentManagerGlobals->rtFileTable;
-	register short i, empty = -1;
+	register short i, empty;
 	register short count = ComponentManagerGlobals->rtFileTotalCount;
-	HParamBlockRec pb;
-	OSErr err = -1;
-
-	// get the file's id
-	pb.fidParam.ioNamePtr = fspec->name;
-	pb.fidParam.ioVRefNum = fspec->vRefNum;
-	pb.fidParam.ioSrcDirID = fspec->parID;
-	err = PBCreateFileIDRefSync(&pb);
-	if (err == fidExists) err = noErr;
 
 	/* first check to see if it's already there */
 
 	for (i=0; i<count; i++) {
-		if (rtFileList->referenceCount)		/* is this spot in use? */
+		if (rtFileList->vRefNum)
 			{
-			if (rtFileList->vRefNum == 0)
+			// this entry contains an FSSpec handle, not a file id
+			if ( FSSpecEqual((FSSpec *)(&rtFileList->vRefNum), fspec) )
 				{
-				// this entry contains an FSSpec handle, not a file id
-				if ( FSSpecEqual(*(FSSpec **)rtFileList->fileID, fspec) )
-					{
-foundIndex:
-				rtFileList->referenceCount++;
-				return i;
-				}
-			}
-		else
-				{
-				// this entry contains a file id
-				if ((fspec->vRefNum == rtFileList->vRefNum) &&
-					(pb.fidParam.ioFileID == rtFileList->fileID))
-					goto foundIndex;
-				}
+			rtFileList->referenceCount++;
+			return i;
 			}
+		}
 		else
 			empty = i;
 	rtFileList++;
 	}
 
-	/* didn't find it so add it to an empty spot */
-
-	if (empty < 0) {
-		// need to grow the table. no empty spot was available.
-		if (GrowRTFileTable( kComponentFileAllocationSize ))
-			return empty;								/* error: could not allocate a file entry */
-
-		empty = ComponentManagerGlobals->rtFileTotalCount - 1;		// last entry should always be free
-	}
-
 	rtFileList = ComponentManagerGlobals->rtFileTable + empty;
-	if (err) {
-		// need to make a copy of the FSSpec and save it away
-		rtFileList->fileID = (Handle)NewHandleSys(0);
-		if (rtFileList->fileID) {
-			PtrAndHand((Ptr)fspec, (Handle)rtFileList->fileID, sizeof(FSSpec));
-			if (MemError() == noErr) {
-				rtFileList->vRefNum = 0;
-				goto rememberFile;
-			}
-		}
-		empty = -1;
-	}
-	else {
-		// just save away the file id
-		rtFileList->vRefNum = fspec->vRefNum;
-		rtFileList->fileID = pb.fidParam.ioFileID;
-rememberFile:
-		rtFileList->referenceCount = 1;
-		ComponentManagerGlobals->rtFileUsedCount++;
-	}
+
+	BlockMove((Ptr)fspec, (Ptr)(&rtFileList->vRefNum), sizeof(FSSpec));
+	rtFileList->referenceCount = 1;
+	ComponentManagerGlobals->rtFileUsedCount++;
 
 	return empty;
 }
@@ -186,6 +140,10 @@ rtFileNum AddComponentResFile( Handle h )
 {
 	FSSpec fspec;
 
+	if (ComponentManagerGlobals->rtFileUsedCount >= ComponentManagerGlobals->rtFileTotalCount) {
+		if(GrowRTFileTable(1)) return -1;
+	}
+
 	if (_FSSpecFromResource( h, &fspec ))
 		return -1;
 
@@ -206,11 +164,7 @@ OSErr RemoveComponentResFile( rtFileNum fn )
 	if (!--rtFileList->referenceCount)
 		{
 		// since the reference count went to zero, this spot is free
-		if (rtFileList->vRefNum == 0)
-			{
-			// the file id was really a handle to an FSSpec, so toss it
-			DisposHandle((Handle)rtFileList->fileID);
-			}
+		rtFileList->vRefNum = 0;
 		ComponentManagerGlobals->rtFileUsedCount--;
 		}
 
diff --git a/Toolbox/ComponentMgr/ThingManager.c b/Toolbox/ComponentMgr/ThingManager.c
--- a/Toolbox/ComponentMgr/ThingManager.c
+++ b/Toolbox/ComponentMgr/ThingManager.c
@@ -218,14 +218,10 @@ extern pascal short ThingyGestalt(OSType selector, long* responsePtr);
 pascal OSErr CoolReplaceGestalt(OSType selector,SelectorFunctionProcPtr selectorFunction)
     = {0xA5AD};
 
-#pragma parameter __A0 rHandToHand(__A0)
-Handle rHandToHand(Handle theHndl)
-	= {0xA9E1,0x31c0,0x0220};
-
-pascal void		__InitComponentManager(Ptr *cutBackAddress);
+pascal void		__InitComponentManager(void);
 pascal long		__ComponentManagerVersion(void);
-pascal OSErr	__GrowRegisteredComponentInstanceTable( short growCount );
-pascal OSErr	__GrowRegisteredComponentTable( short growCount );
+OSErr		__GrowRegisteredComponentInstanceTable( short growCount );
+OSErr	__GrowRegisteredComponentTable( short growCount );
 pascal long		__GetComponentListModSeed(void);
 long			RegisteredComponentPointerToComponentID(RegisteredComponent *rt);
 RegisteredComponent	*ComponentIDtoRegisteredComponentPointer(long t);
@@ -239,8 +235,8 @@ pascal Component	__RegisterComponent(ComponentDescription *td,
 					Handle ComponentInfo, Handle ComponentIcon);
 pascal Component	__RegisterComponentResource(ComponentResource **htr, short global);
 pascal long		__RegisterComponentResourceFile(short resRefNum, short global);
-pascal RegisteredComponentInstancePtr __ValidComponentInstance(ComponentInstance aComponentInstance);
-pascal RegisteredComponentPtr	__ValidComponent(Component aComponent);
+RegisteredComponentInstancePtr __ValidComponentInstance(ComponentInstance aComponentInstance);
+RegisteredComponentPtr	__ValidComponent(Component aComponent);
 int				RemoveRTFromList(RegisteredComponent *rt, RegisteredComponent **pRTList);
 pascal OSErr	__UnregisterComponent(Component aComponent);
 pascal OSErr	__SetDefaultComponent(Component aComponent, short flags);
@@ -263,7 +259,7 @@ void			KillHeapComponents(Ptr heapStart, Ptr heapEnd);
 pascal void		__CleanUpApplicationComponents(void);
 pascal Component	__FindNextComponent(long previousComponent, ComponentDescription *td);
 void			HandToXHand(Handle srcHandle, Handle dstHandle);
-pascal OSErr	__GetComponentInfoPrivate( Component aComponent,
+OSErr	__GetComponentInfoPrivate( Component aComponent,
 					Handle  nameHand, Handle infoHand, Handle iconHand );
 pascal OSErr	__GetComponentInfo(Component aComponent, ComponentDescription *td,
 					Handle nameHand, Handle infoHand, Handle iconHand);
@@ -279,7 +275,6 @@ pascal ComponentInstance	__OpenComponent(long componentID);
 pascal OSErr	__CloseComponent(ComponentInstance componentInstanceID);
 pascal ComponentInstance	__OpenDefaultComponent(OSType componentType, OSType componentSubType);
 pascal ComponentResult	__CallComponent(void);
-pascal void		__ComponentSearch(void);
 RegisteredComponentInstance *FindNextComponentInstance( register RegisteredComponentInstance *rti,  register RegisteredComponent *rt );
 
 static pascal void ThingMemoryTrashed(Ptr startAddr, Ptr stopAddr);
@@ -290,85 +285,21 @@ pascal long goComponentRegister(long theComponent ) = ComponentCallNow( kCompone
 pascal long goComponentUnregister(long theComponent ) = ComponentCallNow( kComponentUnregisterSelect,0);
 
 
-// Gestalt proc for returning the version of the installed Component Mgr
-pascal OSErr GestaltComponentMgrVersion(OSType selector, long* responsePtr)
-{
-#pragma unused (selector)
+pascal void __InitComponentManager(void)	// Called only once at install time
+	{
+	long saveCodecManagerGlobals = -1;
 
-	*responsePtr = ComponentManagerVersion();
-	return (noErr);
-}
-
-//#ifdef tLINKED
-
-void KillHeapComponents(Ptr heapStart, Ptr heapEnd);
+	ComponentManagerGlobals = (ComponentManagerGlobalsRecord *)NewPtrSysClear( sizeof(ComponentManagerGlobalsRecord) );
+	ComponentManagerGlobals->rtReservedForCodecManager = saveCodecManagerGlobals;
+	__GrowRegisteredComponentTable( 32 );
+	}
 
 pascal long __ComponentManagerVersion(void)
 	{
-	return 3;
+	return 1;
 	}
 
-Handle fixHandle(register Handle h)
-{
-	if (h == 1) h = 0;
-	return h;
-}
-
-#ifdef SupportNativeComponents
-
-pascal void * ResolveCodeFragment(RegisteredComponentPtr rt)
-{
-	Str255			errStr;
-	Ptr				mainAddr;
-	THz				oldZone;
-	OSErr			err;
-
-#ifdef WARHOL_DEBUG
-	Handle			nameHand;
-
-	nameHand = NewHandle(0);
-	if (nameHand == nil)
-		return (0);
-
-	err = GetComponentInfo(RegisteredComponentPointerToComponentID(rt), nil, nameHand, nil, nil);
-	if (err != noErr) {
-		DebugStr("\pno info");
-		DisposeHandle(nameHand);
-		goto bail;
-	}
-	HLock(nameHand);
-#endif
-
-	oldZone = GetZone();
-	SetZone(SystemZone());
-
-#ifdef WARHOL_DEBUG
-	err = GetMemFragment(*rt->rtRoutineHandle,0,*nameHand,kLoadNewCopy,&rt->rtConnectionID,&mainAddr,errStr);
-#else
-	err = GetMemFragment(*rt->rtRoutineHandle,0,"\pComponent",kLoadNewCopy,&rt->rtConnectionID,&mainAddr,errStr);
-#endif
-
-	SetZone(oldZone);
-
-#ifdef WARHOL_DEBUG
-	DisposeHandle(nameHand);
-#endif
-
-	if (err != noErr) {
-#ifdef WARHOL_DEBUG
-		DebugStr(errStr);
-#endif
-		return (nil);
-	}
-
-bail:
-	return (mainAddr);
-}
-
-#endif
-
-
-pascal OSErr __GrowRegisteredComponentTable( short growCount )
+OSErr __GrowRegisteredComponentTable( short growCount )
 /*
  * Grow the table of registered components.  String the new entries onto the free list.
  * Since the table moved, all absolute references to entries in the registered
@@ -442,14 +373,14 @@ pascal OSErr __GrowRegisteredComponentTable( short growCount )
 		DisposPtr((Ptr)oldTable);							/* dump the old one */
 
 	if (ComponentManagerGlobals->rtTableEntryCount > ComponentManagerGlobals->rtInstanceTableTotalCount)
-		GrowRegisteredComponentInstanceTable( ComponentManagerGlobals->rtTableEntryCount -  ComponentManagerGlobals->rtInstanceTableTotalCount);
+		__GrowRegisteredComponentInstanceTable( ComponentManagerGlobals->rtTableEntryCount -  ComponentManagerGlobals->rtInstanceTableTotalCount);
 
 	return 0;
 	}
 
 
 
-pascal OSErr __GrowRegisteredComponentInstanceTable( short growCount )
+OSErr __GrowRegisteredComponentInstanceTable( short growCount )
 /*
  * Grow the table of registered component instances.
  * Interrupts need not be disabled as long as the old table is kept intact and used until
@@ -508,7 +439,7 @@ long RegisteredComponentPointerToComponentID(register RegisteredComponent *rt)
 	}
 
 
-#if 1
+#if 0
 	#define ComponentIDtoRegisteredComponentPointer(t) ((RegisteredComponent *)( ComponentManagerGlobals->rtTable + (short)(t & 0xffff)))
 #else
 	RegisteredComponent *ComponentIDtoRegisteredComponentPointer( register long t )			/* should be a macro */
@@ -617,19 +548,7 @@ RegisteredComponent *FindPreviousMatchingComponent( register ComponentDescriptio
 	}
 
 
-static Handle cmHandToHand(register Handle h)
-{
-	if ((long)(h == 0) || ((long)h == 1))
-		return h;
-	else {
-#ifdef WARHOL_DEBUG
-	if (!*h) DebugStr("\pyou suck.");
-#endif
-		return rHandToHand(h);
-	}
-}
-
-pascal short __ResolveComponentPlatform(ComponentResource **htr, ComponentDescription *cd, ResourceSpec *rs)
+short __ResolveComponentPlatform(ComponentResource **htr, ComponentDescription *cd, ResourceSpec *rs)
 {
 	ComponentResourceExtension *cre;
 	long response = gestalt68k;
@@ -697,16 +616,15 @@ pascal Component __RegisterComponent(ComponentDescription *td, ComponentRoutine
 	{
 	THz	saveZone;
 	register RegisteredComponent *new, *previous;
-	ComponentDescription atd = *td;									// duplicate so that if it moves (or gets trashed...) we still have it
 
 	if (!ComponentManagerGlobals->rtFreeChain) {					/* no free entries available */
-		if (GrowRegisteredComponentTable( kComponentAllocationSize))	/* expand (and MOVE…) the table */
+		if (__GrowRegisteredComponentTable( kComponentAllocationSize))	/* expand (and MOVE…) the table */
 			return 0;												/* out of memory */
 	}
 
 	new = ComponentManagerGlobals->rtFreeChain;
 	ComponentManagerGlobals->rtFreeChain = new->rtNext;
-	new->rtDesc = atd;
+	new->rtDesc = *td;
 	new->rtRoutine = (ComponentRoutine *)StripAddress((Ptr)ComponentEntryPoint);
 	new->rtLocalA5 = (long)((global & registerComponentGlobal) ? 0 : *(long *)CurrentA5 );
 
@@ -714,15 +632,15 @@ pascal Component __RegisterComponent(ComponentDescription *td, ComponentRoutine
 
 	if (global & registerComponentGlobal)
 		SetZone(*(THz *)SysZone);
-	new->rtNameHand = cmHandToHand( ComponentName );
-	new->rtInfoHand = cmHandToHand( ComponentInfo );
-	new->rtIconHand = cmHandToHand( ComponentIcon );
+	new->rtNameHand = ComponentName; if (ComponentName) HandToHand(&new->rtNameHand);
+	new->rtInfoHand = ComponentInfo; if (ComponentInfo) HandToHand(&new->rtInfoHand);
+	new->rtIconHand = ComponentIcon; if (ComponentIcon) HandToHand(&new->rtIconHand);
 
 	SetZone((THz)saveZone);
 	if (global & registerComponentAfterExisting)			/* register after other similar ones */
-		atd.componentType++;
+		td->componentType++;
 														/* find the entry ordered before this one */
-	if  ( previous = FindPreviousMatchingComponent( &atd, ComponentManagerGlobals->rtUsedChain ) )
+	if  ( previous = FindPreviousMatchingComponent( td, ComponentManagerGlobals->rtUsedChain ) )
 		{
 		new->rtNext = previous->rtNext;						/* add this one to the ordered chain */
 		previous->rtNext = new;
@@ -734,7 +652,7 @@ pascal Component __RegisterComponent(ComponentDescription *td, ComponentRoutine
 		}
 
 	if (global & registerComponentAfterExisting)			/* restore component type */
-		atd.componentType--;
+		td->componentType--;
 
 	BumpModificationSeed( &ComponentManagerGlobals->rtModSeed );
 	if (!new->rtEntryUseCount)
@@ -743,13 +661,8 @@ pascal Component __RegisterComponent(ComponentDescription *td, ComponentRoutine
 	new->rtParent = 0;
 	new->rtRoutineHandle = 0;
 	new->rtFlags = 0;
-
-	// the upper byte is the platform type, but 0 means unknown and assumed to be 68k
-	if (((unsigned short)global >> 8) > gestalt68k)
-		new->rtFlags |= rtfCodeFragment;
 	new->rtDesc.componentFlagsMask = 0;						/* re-use this field: rt->rtRefcon */
 	new->rtFileNumber = -1;									/* flag as not a resource */
-	new->rtResourceType = 0;							/* flag as not a resource even more */
 	return RegisteredComponentPointerToComponentID( new );	/* return  index with useCount in highword */
 	}
 
@@ -766,28 +679,15 @@ pascal Component __RegisterComponentResource(ComponentResource **htr, short glob
 	char		saveState;
 	register 	ComponentResource *tr;
 	Handle		componentRoutine;
-	short	resID;
-	OSType	resType;
-	Str255	wastedName;
-	long	version = 0;
-	short	platformType;
-
-	GetResInfo((Handle)htr, &resID, &resType, wastedName);			// don't need the name under system 7
-	if (result = ResError()) return 0;
 
 	saveState = HGetState((Handle)htr);
 	HLock((Handle)htr);
 	tr = *htr;
 
-	platformType = ResolveComponentPlatform(htr, &tr->cd, nil);
-	if (platformType == 0)
-		{
-		HSetState((Handle)htr, saveState);
-		return componentDontRegister;
-		}
-
-	result = RegisterComponent(&tr->cd,  (ComponentRoutine )0L,  (global & 0x00FF) | (platformType << 8),
-						nil, nil, nil);
+	result = __RegisterComponent(&tr->cd,  (ComponentRoutine )0L,  global,
+						GetResource(tr->componentName.resType, tr->componentName.resID),
+						GetResource(tr->componentInfo.resType, tr->componentInfo.resID),
+						GetResource(tr->componentIcon.resType, tr->componentIcon.resID));
 
 	HSetState((Handle)htr, saveState);
 
@@ -795,45 +695,20 @@ pascal Component __RegisterComponentResource(ComponentResource **htr, short glob
 		{
 		register RegisteredComponent *new = ComponentIDtoRegisteredComponentPointer(result);
 
-		new->rtNameHand = (Handle)(tr->componentName.resType != 0);
-		new->rtInfoHand = (Handle)(tr->componentInfo.resType != 0);
-		new->rtIconHand = (Handle)(tr->componentIcon.resType != 0);
-
-		// deal with the compoent resource extension, if present
-		//	note: this is done before any calls that might move memory and therefore purge the resource
-		if (GetHandleSize((Handle)htr) >= (sizeof(ComponentResource) + sizeof(ComponentResourceExtension)))
-			{
-			ComponentResourceExtension *cre = (long *)((long)*htr + sizeof(ComponentResource));
-
-			version = cre->componentVersion;
-
-			if (cre->componentRegisterFlags & componentDoAutoVersion) {
-				new->rtFlags |= rtfAutoVersion;
-				if (cre->componentRegisterFlags & componentAutoVersionIncludeFlags)
-					new->rtFlags |= rtfAutoVersionUseFlags;
-			}
-
-			if (cre->componentRegisterFlags & componentWantsUnregister)
-				new->rtFlags |= rtfWantsUnregister;
-
-			if (cre->componentIconFamily)
-				new->rtFlags |= rtfHasIconSuite;
-			}
-
 		new->rtFileNumber = AddComponentResFile( (Handle)htr );
 		if ( new->rtFileNumber < 0)
 			{
 #ifdef	WARHOL_DEBUG
 			Debugger();						/* should never fail (can fail if no memory and couldn't get a file id)*/
 #endif
-			UnregisterComponent(result);
+			__UnregisterComponent(result);
 			return 0;
 			}
 		componentRoutine = NewHandleSys(0);
 		EmptyHandle(componentRoutine);
 
-		new->rtResourceID = resID;
-		new->rtResourceType = resType;
+		new->rtResourceID = (*htr)->component.resID;
+		new->rtResourceType = (*htr)->component.resType;
 		new->rtRoutineHandle = componentRoutine;
 		new->rtRoutine = 0L;
 
@@ -841,7 +716,7 @@ pascal Component __RegisterComponentResource(ComponentResource **htr, short glob
 
 		if ( (global & registerComponentNoDuplicates) && (CountSame(new)>1) )
 			{
-			UnregisterComponent(result);
+			__UnregisterComponent(result);
 			return 0;
 			}
 
@@ -850,20 +725,9 @@ pascal Component __RegisterComponentResource(ComponentResource **htr, short glob
 		if (( new->rtDesc.componentFlags & kComponentNeedsRegisterKiss ) )
 			if (goComponentRegister((ComponentInstance)result))
 				{
-				UnregisterComponent(result);
+				__UnregisterComponent(result);
 				return 0;
 				}
-
-		// scan the Component table for possible duplicates and kill the older one(s) (if auto versioning on)
-		// (can't do this before the register message since we might call GetComponentVersion on the component,
-		//	which it might not be able to deal with before the register)
-
-		if (DestroyOlder(new, version) == nil)
-			{
-			// we are too old. don't register.
-			UnregisterComponent(result);
-			return 0;
-			}
 		}
 
 	return	result;
@@ -897,7 +761,7 @@ pascal long __RegisterComponentResourceFile(short resRefNum, short global)
 				hdl = Get1IndResource(kComponentResourceType, i);
 				if (hdl)
 					{
-					if (RegisterComponentResource((ComponentResource **)hdl, global))
+					if (__RegisterComponentResource((ComponentResource **)hdl, global))
 						err++;						/* we registered something */
 					}
 			}
@@ -914,7 +778,7 @@ pascal long __RegisterComponentResourceFile(short resRefNum, short global)
 
 
 
-pascal RegisteredComponentInstancePtr __ValidComponentInstance(register ComponentInstance aComponentInstance)
+RegisteredComponentInstancePtr __ValidComponentInstance(register ComponentInstance aComponentInstance)
 	{
 	register long signature;
 	register RegisteredComponentInstance *result;
@@ -935,7 +799,7 @@ pascal RegisteredComponentInstancePtr __ValidComponentInstance(register Componen
 
 
 
-pascal RegisteredComponentPtr __ValidComponent(register Component aComponent)
+RegisteredComponentPtr __ValidComponent(register Component aComponent)
 	{
 	register long signature;
 	register RegisteredComponent *result;
@@ -953,7 +817,7 @@ pascal RegisteredComponentPtr __ValidComponent(register Component aComponent)
 		return result;
 	else
 		{
-		if (vti = ValidComponentInstance(aComponent + (signature<<16)))
+		if (vti = __ValidComponentInstance(aComponent + (signature<<16)))
 			return vti->rtiEntry;
 		}
 	return 0;
@@ -995,30 +859,28 @@ pascal OSErr __UnregisterComponent(Component aComponent)
 	{
 	register RegisteredComponent *rt;
 
-	if( ! (rt = ValidComponent(aComponent)) )
+	if( ! (rt = __ValidComponent(aComponent)) )
 		return invalidComponentID;						/* error : not a valid component ID */
 
 	if ( rt->rtReferenceCount )							/* error: valid instances exist */
 		return validInstancesExist;
 
-	if ( (rt->rtFlags & rtfWantsUnregister) && (rt->rtFlags & rtfHasBeenOpened) )
-		goComponentUnregister(aComponent);
-
 	if ( RemoveRTFromList( rt, &ComponentManagerGlobals->rtUsedChain ) )
 		return invalidComponentID;						/* error: not found in list */
 
 	rt->rtNext = ComponentManagerGlobals->rtFreeChain;	/* add this entry to the free list */
 	ComponentManagerGlobals->rtFreeChain = rt;
 
-	if (rt->rtNameHand != 1) DisposHandle(rt->rtNameHand);
-	if (rt->rtInfoHand != 1) DisposHandle(rt->rtInfoHand);
-	if (rt->rtIconHand != 1) DisposHandle(rt->rtIconHand);
+	DisposHandle(rt->rtNameHand);
+	DisposHandle(rt->rtInfoHand);
+	DisposHandle(rt->rtIconHand);
 
+	if (rt->rtRoutineHandle)
 		DisposHandle(rt->rtRoutineHandle);
 
 	RemoveComponentResFile( rt->rtFileNumber );			/* decrement the use count */
 
-	if (rt->rtParent)									/* if child, unchain from parent */
+	if (rt->rtFlags & rtfChild)							/* if child, unchain from parent */
 														/* note: this also unchains a parent from a child. this can happen, if
 															the component is loaded into the application heap for the
 															register message, and the component doesn't want to be
@@ -1051,10 +913,10 @@ pascal OSErr __SetDefaultComponent( Component aComponent, register short flags )
 	register RegisteredComponent *previous;
 	ComponentDescription td;
 
-	if( ! (rt = ValidComponent(aComponent)) )
+	if( ! (rt = __ValidComponent(aComponent)) )
 		return invalidComponentID;							/* error : not a valid component ID */
 
-	GetComponentInfo( aComponent, &td, 0L, 0L, 0L );
+	__GetComponentInfo( aComponent, &td, 0L, 0L, 0L );
 
 	if (flags & defaultComponentAnySubType)
 		td.componentSubType = 0;
@@ -1091,10 +953,10 @@ pascal Component __CaptureComponent( Component slave, Component master )
 	{
 	register RegisteredComponent *s, *m;
 
-	if( ! (s = ValidComponent(slave)) )
+	if( ! (s = __ValidComponent(slave)) )
 		return invalidComponentID;							/* error : not a valid component ID */
 
-	if( ! (m = ValidComponent(master)) )
+	if( ! (m = __ValidComponent(master)) )
 		return invalidComponentID;							/* error : not a valid component ID */
 
 	if (s->rtFlags & rtfCaptured)
@@ -1115,10 +977,10 @@ pascal OSErr __UncaptureComponent( Component aComponent )
 	{
 	register RegisteredComponent *rt;
 
-	if( ! (rt = ValidComponent(aComponent)) )
+	if( ! (rt = __ValidComponent(aComponent)) )
 		return invalidComponentID;							/* error : not a valid component ID */
 
-	if (!(rt->rtFlags & rtfCaptured)) 					/* not captured !!! */
+	if (!rt->rtFlags & rtfCaptured) 					/* not captured !!! */
 		return componentNotCaptured;
 
 	rt->rtFlags &= ~rtfCaptured;
@@ -1133,37 +995,17 @@ pascal short __OpenComponentResFile( Component aComponent )
 	register short fn;
 	short	 saveResLoad;
 	short	 result;
-	rtFile	*rtFileList;
-	FSSpec	theFile;
 
-	if( ! (rt = ValidComponent(aComponent)) )
-		return -1;									/* error : not a valid component ID */
+	if( ! (rt = __ValidComponent(aComponent)) )
+		return 0;									/* error : not a valid component ID */
 
 	fn = rt->rtFileNumber;
 	if ((fn < 0) || (fn >= ComponentManagerGlobals->rtFileTotalCount))
-		return -1;									/* no file here */
-
-	// figure out where the file is
-	rtFileList = ComponentManagerGlobals->rtFileTable + fn;
-	if (rtFileList->vRefNum == 0)
-		theFile = **(FSSpec **)rtFileList->fileID;
-	else
-		{
-		HParamBlockRec pb;
-
-		theFile.name[0] = 0;
-		pb.fidParam.ioNamePtr = theFile.name;
-		pb.fidParam.ioVRefNum = rtFileList->vRefNum;
-		pb.fidParam.ioFileID = rtFileList->fileID;
-		if (PBResolveFileIDRefSync(&pb) != noErr)
-			return -1;
-		theFile.vRefNum = rtFileList->vRefNum;
-		theFile.parID = pb.fidParam.ioSrcDirID;
-		}
+		return 0;									/* no file here */
 
 	saveResLoad = *(Boolean *)ResLoad;
 	SetResLoad(false);
-	result  = FSpOpenResFile( &theFile, fsRdPerm );
+	result  = FSpOpenResFile( (FSSpec *)&(ComponentManagerGlobals->rtFileTable + fn)->vRefNum, fsRdPerm );
 	SetResLoad(saveResLoad);
 	return result;
 
@@ -1174,7 +1016,7 @@ pascal OSErr __CloseComponentResFile( short refnum )
 	{
 	if (refnum>0) {
 		CloseResFile( refnum );
-		return ResError();
+		return *((short *) ResErr);
 		}
 	return 0;
 
@@ -1231,7 +1073,7 @@ pascal long __CountComponentInstances(Component aComponent)
 	{
 	register RegisteredComponent *rt;
 
-	if( ! (rt = ValidComponent(aComponent)) )
+	if( ! (rt = __ValidComponent(aComponent)) )
 		return 0;									/* error : not a valid component ID */
 
 	return (rt->rtReferenceCount);
@@ -1248,15 +1090,12 @@ pascal RegisteredComponent* CloneComponent( long componentID, short global )
 	Handle componentRoutine;
 	long saveSeed;
 
-	if( ! (rt = ValidComponent(componentID)) )
+	if( ! (rt = __ValidComponent(componentID)) )
 		return 0;									/* error : not a valid component ID */
 
 	saveSeed = ComponentManagerGlobals->rtModSeed;
 
-	if (rt->rtFileNumber >= 0)
-		newComponent = RegisterComponent(&rt->rtDesc, rt->rtRoutine, global, (Handle)(rt->rtNameHand != 0), (Handle)(rt->rtInfoHand != 0), (Handle)(rt->rtIconHand != 0));
-	else
-		newComponent = RegisterComponent(&rt->rtDesc, rt->rtRoutine, global, rt->rtNameHand, rt->rtInfoHand, rt->rtIconHand);
+	newComponent = __RegisterComponent(&rt->rtDesc, rt->rtRoutine, global, rt->rtNameHand, rt->rtInfoHand, rt->rtIconHand);
 
 	if (newComponent)
 		{
@@ -1276,7 +1115,6 @@ pascal RegisteredComponent* CloneComponent( long componentID, short global )
 		if (!global)
 			{
 			nt->rtFlags |= rtfChild;						/* mark as child -- hide from findnext */
-			nt->rtFlags |= (rt->rtFlags & (rtfAutoVersion|rtfHasIconSuite|rtfWantsUnregister|rtfAutoVersionUseFlags|rtfCodeFragment));	// transfer obscure flags
 			nt->rtLocalA5 = *(long *)CurrentA5;				/* mark for this app only */
 			ComponentManagerGlobals->rtModSeed = saveSeed;	/* seed must not change */
 			if (rt->rtParent)
@@ -1304,11 +1142,11 @@ pascal long __LoadComponent( long componentID )
  */
 	{
 	register RegisteredComponent *rt, *child = 0;
-	Handle	 entryPoint = nil;
+	Handle	 entryPoint;
 	THz		saveZone;
 	short	refnum;
 
-	if( ! (rt = ValidComponent(componentID)) )
+	if( ! (rt = __ValidComponent(componentID)) )
 		return 0;									/* error : not a valid component ID */
 
 	if (rt->rtParent)								/* check for children in this app */
@@ -1327,30 +1165,16 @@ pascal long __LoadComponent( long componentID )
 		{											/* resource file exists */
 		if (!rt->rtReferenceCount)					/* don't bump count until success */
 			{
-			if (!rt->rtRoutineHandle || !*rt->rtRoutineHandle)		/* code is purged, so go get it */
+			if (!*rt->rtRoutineHandle)		/* code is purged, so go get it */
 				{
-				short saveCurRes = CurResFile();
-				ResourceSpec resSpec;
-				ComponentResource **htr;
-
-				refnum = OpenComponentResFile( componentID );
-				if (refnum == -1)
+				refnum = __OpenComponentResFile( componentID );
+				if (refnum == 0)
 					return 0;						/* could not open the file */
 
-				// load the thing resource so that we can figure out where the code resource lives
-				htr = (ComponentResource **)Get1Resource(rt->rtResourceType, rt->rtResourceID);
-				if (!htr) goto closeDownFile;
-				LoadResource((Handle)htr);
-				if (!*htr) goto closeDownFile;
-
-				// we ignore the result, since it has already be determined to be correct
-				ResolveComponentPlatform(htr, nil, &resSpec);
-				ReleaseResource((Handle)htr);
-
 				saveZone = (THz)GetZone();
 				if (!rt->rtLocalA5)
 					SetZone(*(THz *)SysZone);
-				if (entryPoint = Get1Resource(resSpec.resType, resSpec.resID))
+				if (entryPoint = Get1Resource(rt->rtResourceType, rt->rtResourceID))
 					{
 					LoadResource(entryPoint);
 					DetachResource(entryPoint);
@@ -1360,10 +1184,8 @@ pascal long __LoadComponent( long componentID )
 						//	globals in the system heap cleanly. this is somewhat misguided and mostly
 						//	intended to keep ill-behaved components from dying miserably.
 
-						if (GetExpandMemProcessMgrExists()) {
-							if (!EnoughSystemHeapSlop())
-								EmptyHandle(entryPoint);					/* not enough space, so dump our handle */
-							}
+						if (entryPoint)
+								HSetState(entryPoint, 0);					/* not enough space, so dump our handle */
 						}
 					}
 				SetZone(saveZone);
@@ -1375,7 +1197,7 @@ pascal long __LoadComponent( long componentID )
 
 				if ((!entryPoint || !*entryPoint) && (!rt->rtLocalA5))
 					{
-					entryPoint = Get1Resource(resSpec.resType, resSpec.resID);
+					entryPoint = Get1Resource(rt->rtResourceType, rt->rtResourceID);
 					LoadResource(entryPoint);
 					DetachResource(entryPoint);
 					if (entryPoint && *entryPoint)						/* we got it */
@@ -1385,20 +1207,10 @@ pascal long __LoadComponent( long componentID )
 							rt = child;									/* refill the existing private copy */
 						else
 							rt = CloneComponent(componentID, false); 	/* make a private copy */
-
-						if (!rt)
-							{
-#ifdef	WARHOL_DEBUG
-						if (!rt)  DebugStr("\pClone component failed.");
-#endif
-							DisposHandle(entryPoint);
-							entryPoint = nil;						/* dump it, we'll exit soon */
-						}
 					}
 					}
 closeDownFile:
-				CloseComponentResFile(refnum);
-				UseResFile(saveCurRes);
+				__CloseComponentResFile(refnum);
 
 				if (!entryPoint || !*entryPoint)
 					return 0;											/* not enough memory */
@@ -1409,11 +1221,6 @@ closeDownFile:
 				}
 			if (rt->rtLocalA5)
 				MoveHHi( rt->rtRoutineHandle );					/* if it's in the app heap then force it high */
-			else
-				{
-				if (ComponentManagerGlobals->hasMoveHLo)
-					MoveHLow(rt->rtRoutineHandle);				// if it's in the system heap, force it low if possible
-				}
 			HLock( rt->rtRoutineHandle );							/* lock it down */
 #ifdef SupportNativeComponents
 			if(rt->rtFlags & rtfCodeFragment)
@@ -1441,13 +1248,8 @@ pascal OSErr __UnloadComponent( long componentID )
  */
 	{
 	register RegisteredComponent *rt;
-#ifdef SupportNativeComponents
-	THz oldZone;
-#endif
-	OSErr result;
 
-	result = noErr;
-	if( ! (rt = ValidComponent(componentID)) )
+	if( ! (rt = __ValidComponent(componentID)) )
 		return invalidComponentID;				/* error : not a valid component ID */
 
 	rt->rtReferenceCount--;						/* one fewer client */
@@ -1455,25 +1257,12 @@ pascal OSErr __UnloadComponent( long componentID )
 		{										/* resource file exists */
 		if (!rt->rtReferenceCount)
 			{									/* recover handle and make it purgeable */
-			rt->rtRoutine = 0L;					/* no longer valid */
-
-#ifdef SupportNativeComponents
-			if (rt->rtFlags & rtfCodeFragment)
-				{
-				oldZone = GetZone();
-				SetZone(SystemZone());
-				result = CloseConnection(&rt->rtConnectionID);
-				SetZone(oldZone);
-#ifdef WARHOL_DEBUG
-				if (result != noErr) DebugStr("\pCloseConnection failed");
-#endif
-				}
-#endif
 			HUnlock(rt->rtRoutineHandle);
 			HPurge(rt->rtRoutineHandle);
+			rt->rtRoutine = 0L;					/* no longer valid */
 			}
 		}
-	return	result;
+	return	noErr;
 	}
 
 
@@ -1487,12 +1276,12 @@ pascal ComponentInstance FindNextCommonComponentInstance(ComponentInstance aComp
 	register RegisteredComponentInstance *rti = 0;
 	register RegisteredComponent *rt;
 
-	if (!(rt = ValidComponent(aComponent)) || (rt->rtRoutine != (void *)StripAddress((Ptr)entryPoint)) )
+	if (!(rt = __ValidComponent(aComponent)) || (rt->rtRoutine != (void *)StripAddress((Ptr)entryPoint)) )
 		return 0;
 
 	if (aComponentInstance)
 		{
-		if ( !(rti = ValidComponentInstance(aComponentInstance)) || ( rti->rtiEntry->rtRoutine != (void *)StripAddress((Ptr)entryPoint) ))
+		if ( !(rti = __ValidComponentInstance(aComponentInstance)) || ( rti->rtiEntry->rtRoutine != (void *)StripAddress((Ptr)entryPoint) ))
 			return 0;						/* error : not a valid component ID or entry point doesn't match */
 		}
 
@@ -1511,7 +1300,7 @@ pascal OSErr __DestroyComponent(Component aComponent)
 	register RegisteredComponent *rt;
 	register RegisteredComponentInstance *rti;
 
-	if( ! (rt = ValidComponent(aComponent)) )
+	if( ! (rt = __ValidComponent(aComponent)) )
 		return invalidComponentID;					/* error : not a valid component ID */
 
 
@@ -1525,109 +1314,10 @@ pascal OSErr __DestroyComponent(Component aComponent)
 			rt->rtReferenceCount = 0;				/* force all instances to be gone.... */
 			break;
 			}
-		CloseComponent( ComponentInstancePointerToComponentInstanceID(rti) );
+		__CloseComponent( ComponentInstancePointerToComponentInstanceID(rti) );
 		}
 
-	return UnregisterComponent(aComponent);
-	}
-
-
-long getComponentVersion(register RegisteredComponent *rt)
-	{
-	long version = 0;
-	short fref;
-	Component t = RegisteredComponentPointerToComponentID(rt);
-
-	fref = OpenComponentResFile(t);
-	if (fref != -1)
-		{
-		ComponentResource **htr;
-
-		// load the component resource to see if the version number is available
-		htr = (ComponentResource **)Get1Resource(rt->rtResourceType, rt->rtResourceID);
-		if (htr)
-			{
-			LoadResource((Handle)htr);
-			if (*htr)
-				{
-				if ( GetHandleSize((Handle)htr) >= (sizeof(ComponentResource) + sizeof(ComponentResourceExtension)) )
-					{
-					ComponentResourceExtension *cre = (long *)((long)*htr + sizeof(ComponentResource));
-					version = cre->componentVersion;
-					}
-				}
-			}
-		CloseComponentResFile(fref);
-		if (version)
-			return version;
-		}
-
-	// that failed, so just ask the Component
-	version = GetComponentVersion(t);
-	if (version < 0)
-		version = 0;
-
-	return version;
-	}
-
-
-pascal RegisteredComponent *DestroyOlder( register RegisteredComponent *new, long version )
-/*
-  */
-	{
-	register RegisteredComponent *rtList = ComponentManagerGlobals->rtUsedChain;
-
-	while (rtList)
-		{
-		if (
-			(rtList->rtDesc.componentType			== new->rtDesc.componentType) &&
-			(rtList->rtDesc.componentSubType		== new->rtDesc.componentSubType) &&
-			(rtList->rtDesc.componentManufacturer	== new->rtDesc.componentManufacturer) &&
-			(rtList->rtLocalA5						== new->rtLocalA5) &&
-			((rtList->rtFlags & rtfAutoVersion) || (new->rtFlags & rtfAutoVersion)) &&
-			(rtList != new)
-		   )
-		   {
-		   long thisVersion;
-		   Component c;
-
-			if (
-				((rtList->rtFlags & rtfAutoVersionUseFlags) || (new->rtFlags & rtfAutoVersionUseFlags)) &&
-				(rtList->rtDesc.componentFlags	!= new->rtDesc.componentFlags)
-			   )
-				goto next;
-
-			// found one that's the same
-			thisVersion = getComponentVersion(rtList);
-			c = RegisteredComponentPointerToComponentID(rtList);
-
-			rtList = rtList->rtNext;				// get the next one (assumes UnregisterComponent never kills more than one Component)
-
-			if (!version)
-				version = getComponentVersion(new);
-
-#ifdef WARHOL_DEBUG
-			DebugStr("\pDeath to the old.");
-#endif
-			if (thisVersion <= version)
-				{
-				// kill the other one, let us live
-				DestroyComponent(c);
-				}
-			else
-				{
-				// we are older than this one, so kill us
-				return nil;
-				}
-		   }
-		   else
-		   	{
-next:
-			rtList = rtList->rtNext;
-			}
-		}
-
-	return new;
+	return __UnregisterComponent(aComponent);
 	}
 
 
@@ -1641,8 +1331,8 @@ void KillHeapComponentInstances(register Ptr heapStart, register Ptr heapEnd)
 
 	for(--i; i >= 0; --i)
 		{
-		if ( (rti->rtiEntry) && ((Ptr)rti->rtiStorage >= heapStart) && ((Ptr)rti->rtiStorage <= heapEnd) )
-			CloseComponent( ComponentInstancePointerToComponentInstanceID(rti) );
+		if ( (rti->rtiEntry) && ((Ptr)rti->rtiStorage > heapStart) && ((Ptr)rti->rtiStorage < heapEnd) )
+			__CloseComponent( ComponentInstancePointerToComponentInstanceID(rti) );
 		rti++;
 		}
 	}
@@ -1658,10 +1348,9 @@ void KillHeapComponents(register Ptr heapStart, register Ptr heapEnd)
 		{
 		rt2 = rt;
 		rt=rt->rtNext;
-		if ((((Ptr)rt2->rtRoutine >= heapStart) && ((Ptr)rt2->rtRoutine <= heapEnd)) ||
-			((Ptr)rt2->rtRoutineHandle >= heapStart) && ((Ptr)rt2->rtRoutineHandle <= heapEnd) ||
-			(((Ptr)rt2->rtLocalA5 >= heapStart) && ((Ptr)rt2->rtLocalA5 <= heapEnd)))
-			DestroyComponent( RegisteredComponentPointerToComponentID(rt2) );
+		if ((((Ptr)rt2->rtRoutine > heapStart) && ((Ptr)rt2->rtRoutine < heapEnd)) ||
+			(rt2->rtLocalA5 == *(long *)CurrentA5))
+			__DestroyComponent( RegisteredComponentPointerToComponentID(rt2) );
 		}
 	}
 
@@ -1674,14 +1363,25 @@ pascal void ThingMemoryTrashed(Ptr startAddr, Ptr stopAddr)
 
 pascal void __CleanUpApplicationComponents(void)
 	{
-#if 0
-	// if we use the strange MemoryTrashed zone notification stuff, then this is not necessary
 	Ptr zoneBegin, zoneEnd;
+	unsigned long flags;
 
-	GetApplZoneBounds(&zoneBegin, &zoneEnd);
-	KillHeapComponentInstances(zoneBegin, zoneEnd);
-	KillHeapComponents(zoneBegin, zoneEnd);
-#endif
+	zoneBegin = *(Ptr *)ApplZone;
+
+	if (zoneBegin != *(Ptr *)SysZone) {
+		if (!GetExpandMemProcessMgrExists()) {
+			zoneEnd = *(Ptr *)BufPtr;
+		} else if ((flags = *(unsigned long *)(zoneBegin - 8)) >> 24 == 0x80) {
+			zoneEnd = zoneBegin + (flags & 0xFFFFFF);
+		} else if (*(unsigned long *)(zoneBegin - 12) >> 16 == 0x8080) {
+			zoneEnd = zoneBegin + flags;
+		} else {
+			zoneEnd = *(Ptr *)zoneBegin;
+		}
+
+		KillHeapComponentInstances(zoneBegin, zoneEnd);
+		KillHeapComponents(zoneBegin, zoneEnd);
+		}
 	}
 
 
@@ -1696,7 +1396,7 @@ pascal Component __FindNextComponent( long previousComponent, ComponentDescripti
 	register RegisteredComponent *rt;
 
 
-	if( previousComponent && (rt = ValidComponent(previousComponent)) )
+	if( previousComponent && (rt = __ValidComponent(previousComponent)) )
 		rt = rt->rtNext;								/* valid component ID, so start with successor */
 	else
 		rt = ComponentManagerGlobals->rtUsedChain;		/* start from beginning */
@@ -1713,13 +1413,10 @@ void HandToXHand(register Handle srcHandle, register Handle dstHandle)
 
 	if (dstHandle)
 		{
-		srcHandle = fixHandle(srcHandle);
 		if (srcHandle && *srcHandle)
 			{
 			size = GetHandleSize(srcHandle);
 			SetHandleSize( dstHandle, size );
-			if (MemError() == -109)
-				ReallocHandle(dstHandle, size);			// we return empty handles, so let the pass them to us
 			if (! MemError())
 				{
 				BlockMove( *srcHandle, *dstHandle, size );
@@ -1732,140 +1429,28 @@ void HandToXHand(register Handle srcHandle, register Handle dstHandle)
 
 
 
-pascal OSErr __GetComponentInfoPrivate( Component aComponent, Handle  nameHand, Handle infoHand, Handle iconHand )
-	{
-	register RegisteredComponent *rt = ValidComponent(aComponent);
-
-	if ( rt->rtResourceType) {
-		Boolean force = false;
-
-		if (nameHand && (rt->rtNameHand == 1))	{rt->rtNameHand = 0; force = true;}
-		if (infoHand && (rt->rtInfoHand == 1))	{rt->rtInfoHand = 0; force = true;}
-		if (iconHand && (rt->rtIconHand == 1))	{rt->rtIconHand = 0; force = true;}
-
-		 if  ( force ||
-			(nameHand && rt->rtNameHand && !*rt->rtNameHand) ||
-			  (infoHand && rt->rtInfoHand && !*rt->rtInfoHand) ||
-			   (iconHand && rt->rtIconHand && !*rt->rtIconHand) ) {
-				// reload the whole lot
-			THz saveZone = (THz)GetZone();
-			short saveRes = CurResFile();
-			short resRef;
-
-			SetZone(*(THz *)SysZone);
-
-			resRef = OpenComponentResFile(aComponent);
-			if (resRef != -1) {
-				Boolean saveResLoad = *(Boolean *)ResLoad;
-				register RegisteredComponent *thisRT = ComponentManagerGlobals->rtUsedChain;
-
-				SetResLoad(true);
-
-				for (thisRT = ComponentManagerGlobals->rtUsedChain; thisRT && (thisRT->rtDesc.componentType <= rt->rtDesc.componentType); thisRT = thisRT->rtNext) {
-					Handle h;
-
-					if ((thisRT->rtFileNumber != rt->rtFileNumber) ||
-						(thisRT->rtDesc.componentType != rt->rtDesc.componentType))
-						continue;
-
-					h = Get1Resource(thisRT->rtResourceType, thisRT->rtResourceID);
-					if (h) {
-						ComponentResource cr = **(ComponentResource **)h;
-
-						ReleaseResource(h);
-
-						if (nameHand && cr.componentName.resType) {
-							DisposHandle(fixHandle(thisRT->rtNameHand));
-							if (thisRT->rtNameHand = Get1Resource(cr.componentName.resType, cr.componentName.resID)) {
-								HNoPurge(thisRT->rtNameHand);
-								DetachResource(thisRT->rtNameHand);
-							}
-						}
-						if (infoHand && cr.componentInfo.resType) {
-							DisposHandle(fixHandle(thisRT->rtInfoHand));
-							if (thisRT->rtInfoHand = Get1Resource(cr.componentInfo.resType, cr.componentInfo.resID)) {
-								HNoPurge(thisRT->rtInfoHand);
-								DetachResource(thisRT->rtInfoHand);
-							}
-						}
-						if (iconHand && cr.componentIcon.resType) {
-							DisposHandle(fixHandle(thisRT->rtIconHand));
-							if (thisRT->rtIconHand = Get1Resource(cr.componentIcon.resType, cr.componentIcon.resID)) {
-								HNoPurge(thisRT->rtIconHand);
-								DetachResource(thisRT->rtIconHand);
-							}
-						}
-
-						if (thisRT != rt) {
-							HPurge(fixHandle(thisRT->rtNameHand));
-							HPurge(fixHandle(thisRT->rtInfoHand));
-							HPurge(fixHandle(thisRT->rtIconHand));
-						}
-					}
-				}
-
-				SetResLoad(saveResLoad);
-				CloseComponentResFile(resRef);
-			}
-
-			SetZone(saveZone);
-			UseResFile(saveRes);
-		}
-	}
-
-	HandToXHand(rt->rtNameHand, nameHand);
-	HandToXHand(rt->rtInfoHand, infoHand);
-	HandToXHand(rt->rtIconHand, iconHand);
-
-	if (rt->rtResourceType) {
-		HPurge(fixHandle(rt->rtNameHand));
-		HPurge(fixHandle(rt->rtInfoHand));
-		HPurge(fixHandle(rt->rtIconHand));
-	}
-
-	return noErr;
-}
-
-pascal void ClearD0(void)
-	= 0x7000;
-
 pascal OSErr __GetComponentInfo( Component aComponent, register ComponentDescription *td, Handle  nameHand, Handle infoHand, Handle iconHand )
 /*
   */
 	{
 	register RegisteredComponent *rt;
-	OSErr err;
 
-	if ( rt = ValidComponent(aComponent))
+	if ( rt = __ValidComponent(aComponent))
 		{
 		if (td)
 			{
-			register RegisteredComponent *rtTemp = rt;
-
 			*td = rt->rtDesc;					/* copy type, subtype, manufacturer, flags */
-			while (rtTemp->rtFlags & rtfChild)
-				{
-				rtTemp = rtTemp->rtParent;
-#ifdef WARHOL_DEBUG
-				if (!rtTemp)
-					DebugStr("\pClonedComponentHell");
-#endif
-				}
-
-			td->componentFlagsMask = RegisteredComponentPointerToComponentID(rtTemp);
+			td->componentFlagsMask = RegisteredComponentPointerToComponentID(rt);
 			}								/* return component ID for uniqueness */
 
+		HandToXHand(rt->rtNameHand, nameHand);
+		HandToXHand(rt->rtInfoHand, infoHand);
+		HandToXHand(rt->rtIconHand, iconHand);
 
-		if (nameHand || infoHand || iconHand)
-			err = GetComponentInfoPrivate(aComponent, nameHand, infoHand, iconHand);
-		else
-			err = noErr;
+		return noErr;
 		}
 	else
-		err = invalidComponentID;								/* error : not a valid component ID */
-
-	ClearD0();						//•• this makes the 7.1 Keyboard menu code not crash (fun, huh?)
-	return err;
+		return invalidComponentID;								/* error : not a valid component ID */
 	}
 
 
@@ -1876,7 +1461,7 @@ pascal long __GetComponentRefcon( long aComponent )
 	{
 	register RegisteredComponent *rt;
 
-	if (rt = ValidComponent(aComponent))
+	if (rt = __ValidComponent(aComponent))
 		{
 		return rt->rtDesc.componentFlagsMask;	/* re-use this field: rt->rtRefcon */
 		}
@@ -1892,7 +1477,7 @@ pascal void __SetComponentRefcon( long aComponent, long theRefcon )
 	{
 	register RegisteredComponent *rt;
 
-	if( rt = ValidComponent(aComponent) )
+	if( rt = __ValidComponent(aComponent) )
 		rt->rtDesc.componentFlagsMask = theRefcon;		/* re-use this field: rt->rtRefcon */
 	}
 
@@ -1905,7 +1490,7 @@ pascal OSErr __GetComponentInstanceError( long aComponentInstance )
 	register RegisteredComponentInstance *rti;
 	short err;
 
-	if( ! (rti = ValidComponentInstance(aComponentInstance)) )
+	if( ! (rti = __ValidComponentInstance(aComponentInstance)) )
 		return invalidComponentID;				/* error : not a valid component ID */
 
 	err = rti->rtiError;
@@ -1920,7 +1505,7 @@ pascal void __SetComponentInstanceError( long aComponentInstance, OSErr theError
 	{
 	register RegisteredComponentInstance *rti;
 
-	if( rti = ValidComponentInstance(aComponentInstance) )
+	if( rti = __ValidComponentInstance(aComponentInstance) )
 		rti->rtiError = theError;
 	}
 
@@ -1931,7 +1516,7 @@ pascal Handle __GetComponentInstanceStorage( long aComponentInstance )
 	{
 	register RegisteredComponentInstance *rti;
 
-	if( ! (rti = ValidComponentInstance(aComponentInstance)) )
+	if( ! (rti = __ValidComponentInstance(aComponentInstance)) )
 		return 0;								/* error : not a valid component ID */
 
 	return rti->rtiStorage;
@@ -1944,7 +1529,7 @@ pascal void __SetComponentInstanceStorage( long aComponentInstance, Handle theSt
 	{
 	register RegisteredComponentInstance *rti;
 
-	if( rti = ValidComponentInstance(aComponentInstance) )
+	if( rti = __ValidComponentInstance(aComponentInstance) )
 		rti->rtiStorage = theStorage;
 	}
 
@@ -1955,7 +1540,7 @@ pascal long __GetComponentInstanceA5( long aComponentInstance )
 	{
 	register RegisteredComponentInstance *rti;
 
-	if( ! (rti = ValidComponentInstance(aComponentInstance)) )
+	if( ! (rti = __ValidComponentInstance(aComponentInstance)) )
 		return 0;								/* error : not a valid component ID */
 
 	return rti->rtiSwitchedA5;
@@ -1968,7 +1553,7 @@ pascal void __SetComponentInstanceA5( long aComponentInstance, long theA5 )
 	{
 	register RegisteredComponentInstance *rti;
 
-	if( rti = ValidComponentInstance(aComponentInstance) )
+	if( rti = __ValidComponentInstance(aComponentInstance) )
 		rti->rtiSwitchedA5 = theA5;
 	}
 
@@ -1982,7 +1567,7 @@ pascal ComponentInstance __OpenComponent( long componentID )
 	ComponentInstance ti;
 	long	result;
 
-	if( ! (rt = (RegisteredComponent*)LoadComponent(componentID) ) )
+	if( ! (rt = (RegisteredComponent*)__LoadComponent(componentID) ) )
 		{
 #ifdef	WARHOL_DEBUG
 		DebugStr("\pFailed to load component.  Not enough memory.;g");
@@ -1991,7 +1576,7 @@ pascal ComponentInstance __OpenComponent( long componentID )
 		}
 
 	if (( ComponentManagerGlobals->rtInstanceTableUsedCount >= ComponentManagerGlobals->rtInstanceTableTotalCount )
-	     && (GrowRegisteredComponentInstanceTable( kComponentInstanceAllocationSize )))
+	     && (__GrowRegisteredComponentInstanceTable( kComponentInstanceAllocationSize )))
 		return 0;									/* error: could not allocate an instance record */
 
 	if (! (rti = FindNextComponentInstance( 0L, 0L)))/* start at beginning and look for a nil component ptr */
@@ -1999,11 +1584,9 @@ pascal ComponentInstance __OpenComponent( long componentID )
 
 	ComponentManagerGlobals->rtInstanceTableUsedCount++;
 
-	rt->rtFlags |= rtfHasBeenOpened;			// remember that this one has been used
-
 	rti->rtiEntry = rt;								/* store pointer to the parent registered component */
 	rti->rtiStorage = 0;							/* set high bit of flags with component flags  bit 30  */
-	rti->rtiFlags = (((~rt->rtDesc.componentFlags) >> 23) & 0x80);
+	rti->rtiFlags = (((rt->rtDesc.componentFlags) >> 23) ^ 0x80);
 	rti->rtiError = 0;
 	rti->rtiSwitchedA5 = rt->rtLocalA5;
 	if (!rti->rtiEntryUseCount)
@@ -2019,7 +1602,7 @@ pascal ComponentInstance __OpenComponent( long componentID )
 #ifdef	WARHOL_DEBUG
 		DebugStr("\pOpen component failed.");
 #endif
-		CloseComponent(ti);
+		__CloseComponent(ti);
 		return 0;
 		}
 	return ti;
@@ -2036,14 +1619,14 @@ pascal OSErr __CloseComponent( ComponentInstance componentInstanceID )
 	ComponentInstance ti;
 	long	result;
 
-	if( ! (rti = ValidComponentInstance(componentInstanceID)) )
+	if( ! (rti = __ValidComponentInstance(componentInstanceID)) )
 		return invalidComponentID;						/* error : not a valid component ID */
 
 	/***** Call the Component with the CLOSE message Here *******/
 	ti = ComponentInstancePointerToComponentInstanceID(rti);
 	result = goComponentClose( ti , ti);				/* 4 bytes of params, selector close = -2 */
 
-	UnloadComponent( componentInstanceID );				/* Drops reference count */
+	__UnloadComponent( componentInstanceID );				/* Drops reference count */
 	rt = rti->rtiEntry;
 	ComponentManagerGlobals->rtInstanceTableUsedCount--;
 
@@ -2073,22 +1656,14 @@ pascal ComponentInstance __OpenDefaultComponent( OSType componentType, OSType co
 	look.componentFlagsMask = 0;
 
 	while (!result) {
-		if (!(cmp = FindNextComponent(cmp, &look)))
+		if (!(cmp = __FindNextComponent(cmp, &look)))
 			return 0;
-		result = OpenComponent(cmp);
+		result = __OpenComponent(cmp);
 		}
 	return result;
 	}
 
 
-
-// this is only here because of CubeE which links it in…
-pascal void __ComponentSearch (void)
-{
-	doComponentSearch();
-}
-//#endif
-
 /********************************
 
 	everything below here is cut back
@@ -2096,34 +1671,6 @@ pascal void __ComponentSearch (void)
 
 ********************************/
 
-pascal void __InitComponentManager(Ptr *cutBackAddress)	// Called only once at install time
-	{
-#pragma unused (cutBackAddress)
-
-	long saveCodecManagerGlobals = -1;
-
-#if 0
-	*cutBackAddress = (Ptr)&_InitComponentManager;		// for QuickTime use only
-#endif
-
-	RegisterHandleTrashNotification(ThingMemoryTrashed, kComponentManagerPriority, 0);
-
-	if ( (long)ComponentManagerGlobals != -1) {			// don't install if already there (but always return cutback address)
-		// 7.1 calls GetComponentManagerVersion via JSR, not a trap
-		CoolReplaceGestalt(gestaltComponentMgr,GestaltComponentMgrVersion);
-		goto bail;
-	}
-
-	NewGestalt(gestaltComponentMgr, GestaltComponentMgrVersion);
-
-	ComponentManagerGlobals = (ComponentManagerGlobalsRecord *)NewPtrSysClear( sizeof(ComponentManagerGlobalsRecord) );
-	ComponentManagerGlobals->rtReservedForCodecManager = saveCodecManagerGlobals;
-	GrowRegisteredComponentTable( 32 );
-bail:
-	ComponentManagerGlobals->hasMoveHLo = (GetOSTrapAddress(_MoveHLow) != GetToolboxTrapAddress(_Unimplemented));
-	}
-
-
 pascal ComponentResult __CallComponent(void) 		/* referenced by dispatch table--but never called */
 	{
 	return 0;
@@ -2173,7 +1720,7 @@ pascal Component RegisterComponentRomResource(ComponentResource **htr, short glo
 	H2 = GetSystemThenROMRes(tr->componentInfo.resType, tr->componentInfo.resID);
 	H3 = GetSystemThenROMRes(tr->componentIcon.resType, tr->componentIcon.resID);
 	H4 = GetSystemThenROMRes(tr->component.resType, tr->component.resID);
-	result = RegisterComponent(&tr->cd,  (ComponentRoutine )*H4,  global, H1, H2, H3);
+	result = __RegisterComponent(&tr->cd,  (ComponentRoutine )*H4,  global, H1, H2, H3);
 	HSetState((Handle)htr, saveState);
 	ReleaseResource(H1);
 	ReleaseResource(H2);
diff --git a/Toolbox/ComponentMgr/ThingManagerDispatcher.a b/Toolbox/ComponentMgr/ThingManagerDispatcher.a
--- a/Toolbox/ComponentMgr/ThingManagerDispatcher.a
+++ b/Toolbox/ComponentMgr/ThingManagerDispatcher.a
@@ -286,8 +286,7 @@ lastSelector		EQU	43
 		;cmp.w	#-1,d0
 		bmi.s	ChainThingFunction
 		cmp.w	#delegateSelector,d0
-		beq		DelegateComponentCall
-		cmp.w	#lastSelector,d0
+		beq.s	DelegateComponentCall
 		bhi.s	ComponentBummer
 		lea		ComponentDispTableHead,a0
 		lsl.w		#2,d0				; don't assume 020
diff --git a/Toolbox/ComponentMgr/ThingManagerPatch.a b/Toolbox/ComponentMgr/ThingManagerPatch.a
new file mode 100644
--- /dev/null
+++ b/Toolbox/ComponentMgr/ThingManagerPatch.a
@@ -0,0 +1,32 @@
+			LOAD	'StandardEqu.d'
+			INCLUDE	'GestaltEqu.a'
+			INCLUDE	'LinkedPatchMacros.a'
+
+
+InstallThingManager		InstallProc		(Plus,SE,II,Portable,IIci)
+			import		__InitComponentManager
+
+			move.w		#$A82A,d0
+			leaResident	MainComponent,a0
+			_SetTrapWordAddress
+
+			jsr			__InitComponentManager
+
+			move.l		#gestaltComponentMgr,d0
+			leaResident	GestaltComponentMgrVersion,a0
+			_NewGestalt
+
+			rts
+
+
+GestaltComponentMgrVersion	Proc	Export
+			import		__ComponentManagerVersion
+
+			clr.l		-(sp)
+			jsr			__ComponentManagerVersion
+			move.l		8(sp),a0
+			move.l		(sp)+,(a0)
+			move.l		(sp)+,a0
+			addq		#8,sp
+			clr.w		(sp)
+			jmp			(a0)
diff --git a/Toolbox/ComponentMgr/ThingManagerPatch.a.idump b/Toolbox/ComponentMgr/ThingManagerPatch.a.idump
new file mode 100644
--- /dev/null
+++ b/Toolbox/ComponentMgr/ThingManagerPatch.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Toolbox/ComponentMgr/ThingSearch.c b/Toolbox/ComponentMgr/ThingSearch.c
--- a/Toolbox/ComponentMgr/ThingSearch.c
+++ b/Toolbox/ComponentMgr/ThingSearch.c
@@ -66,12 +66,12 @@
 
 static void searchFolder(register CInfoPBRec *fInfo, FSSpec *fileSpec,
 			long dirID, Boolean recurse);
+pascal long		__RegisterComponentResourceFile(short resRefNum, short global);
 
-long TestFile (FSSpecPtr fileSpec)
+void TestFile (FSSpecPtr fileSpec)
 {
 	short fRef;
 	Boolean oldResLoad;
-	short result = 0;
 
 	oldResLoad = *(Boolean *)ResLoad;
 	SetResLoad(false);
@@ -79,14 +79,13 @@ long TestFile (FSSpecPtr fileSpec)
 	fRef = FSpOpenResFile(fileSpec, fsRdPerm);
 	if (ResError() == noErr)
 		{
-		result = RegisterComponentResourceFile(fRef, registerComponentGlobal);
+		__RegisterComponentResourceFile(fRef, registerComponentGlobal);
 		CloseResFile(fRef);
 		}
 	SetResLoad(oldResLoad);
-	return (result > 0);
 }
 
-void doComponentSearch ()
+pascal void __ComponentSearch ()
 {
 	short		systemVRef;
 	long		blessedFolder;
@@ -174,7 +173,8 @@ static void searchFolder(register CInfoPBRec *fInfo, FSSpec *fileSpec,
 			long dirID, Boolean recurse)
 {
 	short ix = 0;
-	Boolean isFolder, wasAliased;
+	Boolean isFolder;
+	AliasHandle aliasHdl;
 
 	while (true)
 	{
@@ -185,15 +185,36 @@ static void searchFolder(register CInfoPBRec *fInfo, FSSpec *fileSpec,
 
 		if (!(fInfo->hFileInfo.ioFlAttrib & ioDirMask)) {
 			if (fInfo->hFileInfo.ioFlFndrInfo.fdType == targetType) {
-				fileSpec->vRefNum = fInfo->hFileInfo.ioVRefNum;
-				fileSpec->parID = dirID;
-				BlockMove(fInfo->hFileInfo.ioNamePtr, fileSpec->name, fInfo->hFileInfo.ioNamePtr[0]+1);
+				if(FSMakeFSSpec(fInfo->hFileInfo.ioVRefNum, dirID, fInfo->hFileInfo.ioNamePtr, fileSpec) == noErr) {
+				OSErr err;
 				isFolder = false;
-				ResolveAliasFile(fileSpec, true, &isFolder, &wasAliased);
-				if (!isFolder)
+				err = MatchAliasFile(fileSpec, &fInfo->hFileInfo.ioFlFndrInfo, &aliasHdl, &isFolder);
+				if ((!err) && !isFolder)
 					TestFile(fileSpec);
+				} /*FSMakeFSSpec above*/
 			}
 		} else if (recurse)
 			searchFolder(fInfo, fileSpec, fInfo->dirInfo.ioDrDirID, true);
 	}
 }
+
+
+
+
+
+
+
+
+// pascal OSErr FSMakeFSSpec(short vRefNum,long dirID,ConstStr255Param fileName,
+//  FSSpecPtr spec)
+//  = {0x303C,0x0001,0xAA52}; 
+
+
+
+
+
+
+
+
+
+
diff --git a/Toolbox/ControlMgr/ButtonCDEF.a b/Toolbox/ControlMgr/ButtonCDEF.a
--- a/Toolbox/ControlMgr/ButtonCDEF.a
+++ b/Toolbox/ControlMgr/ButtonCDEF.a
@@ -14,7 +14,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<SM2>	10/22/92	CSS		Change short branches to word branches.
 ;		<14>	 4/11/91	gbm		csd, KSM, BRC#86464: Fix many references to the control
 ;									rectangle which are invalid because the control handle can be
 ;									unlocked.
@@ -159,7 +158,7 @@ FrameSize		EQU	 -58
 
 			CMP.W	#$3FFF,ROM85		; do we have color QD?
 			SLS		IsColor(A6)			; set boolean depending on color or B&W system
-			BHI		@BWSys				; no, this system has B&W QD <SM2> CSS 
+			BHI.S	@BWSys				; no, this system has B&W QD
 
 ; save the current port’s colors and textMode						<C59/30Jun86> DAF
 
diff --git a/Toolbox/ControlMgr/ControlMgrExtensions.a b/Toolbox/ControlMgr/ControlMgrExtensions.a
--- a/Toolbox/ControlMgr/ControlMgrExtensions.a
+++ b/Toolbox/ControlMgr/ControlMgrExtensions.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM2>	 5/18/93	RC		perfomance/bug fix (speed up scrolling with Truth changes to
-;									ScrollDelay)
 ;		 <2>	 6/30/92	JSM		Move scroll speed throttling code here from ScrollSpeedFix.a,
 ;									add install proc for the future and ROM builds to set up
 ;									ExpandMem.
@@ -83,7 +81,7 @@ result			DS.W	1
 FirstValue		EQU		12						; Number of ticks to begin with.
 KnownEndValue	EQU		3						; Number of ticks to end with, when the list size is known.
 UnknownEndValue	EQU		0						; Number of ticks to end with, when the list size is unknown.
-DecayValue		EQU		48						; Time to decay from StartValue to EndValue.
+DecayValue		EQU		108						; Time to decay from StartValue to EndValue.
 KnownConst		EQU		DecayValue / (FirstValue - KnownEndValue)
 UnknownConst	EQU		DecayValue / (FirstValue - UnknownEndValue)
 
@@ -98,14 +96,13 @@ UnknownConst	EQU		DecayValue / (FirstValue - UnknownEndValue)
 				WITH	sdFrame
 				CLR.W	result(SP)				; No error.
 				
-; Commented out 5/18/93 RPC so that EndValue is always 0 for both ListMgr and non-ListMgr alike.
-;				TST.W	itemsVisible(SP)		; Know the number of items visible?
-;				BEQ.S	@unknown				; No, skip this part.
-;				MOVEQ.L	#KnownEndValue, D0		; EndValue = KnownEndValue
-;				MOVEQ.L	#KnownConst, D1			; For speed
-;				BRA.S	@calcDelay
+				TST.W	itemsVisible(SP)		; Know the number of items visible?
+				BEQ.S	@unknown				; No, skip this part.
+				MOVEQ.L	#KnownEndValue, D0		; EndValue = KnownEndValue
+				MOVEQ.L	#KnownConst, D1			; For speed
+				BRA.S	@calcDelay
 
-;@unknown
+@unknown
 				MOVEQ.L	#UnknownEndValue, D0	; EndValue = UnknownEndValue
 				MOVEQ.L	#UnknownConst, D1		; For speed
 
@@ -123,16 +120,17 @@ UnknownConst	EQU		DecayValue / (FirstValue - UnknownEndValue)
 ; We need to loop until D0 <= TickCount() or the mouse button comes up.
 				MOVE.L	D0, -(SP)				; Save the time on the stack.
 @loopDelay
+				SUBQ.L	#2, SP
+				_StillDown						; Mouse still down?
+				TST.B	(SP)+
+				BEQ.S	@endDelay
+
 				SUBQ.L	#4, SP
 				_TickCount
 				MOVE.L	(SP)+, D0
 				CMP.L	(SP), D0				; Timed out?
-				BHS.S	@endDelay				; Yes, Get Out.
+				BLO.S	@loopDelay
 
-				SUBQ.L	#2, SP
-				_StillDown						; Mouse still down?
-				TST.B	(SP)+
-				BNE.S	@loopDelay				; Yes, Try Again.
 
 
 @endDelay
diff --git a/Toolbox/ControlMgr/PopupCDEF.c b/Toolbox/ControlMgr/PopupCDEF.c
--- a/Toolbox/ControlMgr/PopupCDEF.c
+++ b/Toolbox/ControlMgr/PopupCDEF.c
@@ -9,8 +9,6 @@
 
 	Change History (most recent first):
 
-	   <SM4>	11/19/92	RB		Set ROMMapInsert to mapTRue to look for resources in ROM first.
-		<43>	11/13/92	JDR		Updated QuickDraw.h to not use the dangerous pattern type.
 		<42>	 11/7/92	JDR		Removed the PopupPrivateData record, which is now a public
 									structure.  Change occurances of the usage too,
 		<41>	 11/3/92	DTY		Strip out unnecessary includes.
@@ -287,6 +285,7 @@
 		Make popup return different part codes
 */
 
+#define dangerousPattern
 #include <Types.h>
 #include <Controls.h>
 #include <Fonts.h>
@@ -860,8 +859,7 @@ long DoTrack(ControlHandle hControl, short theVar)
 	useSpandex = (growWidth > 0);
 
 	if (useSpandex) {										// invoke spandex MDEF
-		*(short*) RomMapInsert = mapTrue;												// <SM4> rb
-		theHandle = (SpandexH) GetResource(SpandexResType, SpandexMDEF);				// <SM4> rb
+		theHandle = (SpandexH) GetResource(SpandexResType, SpandexMDEF);
 		if (theHandle != nil) {								// load in spandex MDEF
 			LoadResource( (Handle) theHandle );				// load in case of purged -- now unpurgeable so remove this
 			HLock( (Handle) theHandle );
diff --git a/Toolbox/ControlMgr/ScrollBarCDEF.a b/Toolbox/ControlMgr/ScrollBarCDEF.a
--- a/Toolbox/ControlMgr/ScrollBarCDEF.a
+++ b/Toolbox/ControlMgr/ScrollBarCDEF.a
@@ -12,34 +12,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM6>	  2/1/94	SWC		Changed the entry code for setting up the drawing environment to
-;									only do that for calls that will actually be doing some drawing.
-;									This is to prevent the situation where a ‘clut’ resource is
-;									continuously being loaded (by GetCTable) and unloaded (by
-;									DisposeCTable) when all that's being done is hit testing, region
-;									calculations, etc. This fixes a problem when running Microsoft
-;									Excel 4.0 on a PowerBook: since the resource was always being
-;									purged, GetResource ended up doing a disk read, which registers
-;									as machine usage to the Power Manager, and thus the PowerBook
-;									never auto-sleeps. A beneficial side effect for desktop machines
-;									is that running thru this code will now be a bit faster. While I
-;									was at it, changed word branches to short branches, where
-;									appropriate.
-;	   <SM5>	  6/7/93	CSS		Resupport drawthumboutline and make it do something different
-;									for ROM (render a rgn instead of a rect).
-;	   <SM4>	 4/30/93	CSS		DragTheRgn now will drag a black outline instead of a yellow one
-;									when dragging the scroll bar thumb. So, take out <SM3>. Also,
-;									desupported the DrawThumbOutline Message which was for the hack
-;									on FrameRect which we no longer do.
-;	   <SM3>	 4/21/93	CSS		Implement a custom dragging routine so that we can draw a black
-;									box instead of a yellow one (the standard dragging in
-;									dragcontrol uses dragthergn which uses xor and creates a nice
-;									yellow color in 256 colors). This routine will use hilite mode
-;									in color and notpatxor in black&white. This was implemented in
-;									7.1 as a nice comefrompatch hack on _FrameRect (e.g. if we are
-;									dragging and if we came from _DragControl... you get the idea).
-;	   <SM2>	11/19/92	RB		Set ROMMapInsert to mapTrue to look for resources in ROM first
-;									when doing GetResource calls.
 ;		<36>	 5/30/91	DTY		We look for things to make it go faster.
 ;		<35>	 4/11/91	gbm		dba, ws#-dba041001: Stop trying to do fancy offscreen stuff to
 ;									buffer screen drawing if we're not actually drawing to the
@@ -309,8 +281,14 @@ hilite				equ		50
 
 ; test if the message is in range
 
+			cmp.w	#6,message(A6)
+			bls.s	@MsgOK
+			cmp.w	#10,message(A6)
+			beq.s	@MsgOK
+			cmp.w	#11,message(A6)
+			beq.s	@MsgOK
 			cmp.w	#drawThumbOutlineMsg,message(A6) ; compare to highest value
-			bhi.s	OORange				; We respond to 0-12								<1.2><SM6>
+			bne		OORange				; We respond to 0-12								<1.2>
 @MsgOK
 
 ; save the penState and set it our way
@@ -319,6 +297,62 @@ hilite				equ		50
 			_GetPenState				; remember current penState
 			_PenNormal					; set the pen the way we	want it
 
+; sets up the drawing environment for calls that do drawing
+
+; Determine type of system.  We need to know if we have color QuickDraw and a color
+;	window manager port.
+
+			cmp.w	#$3FFF,ROM85		; do we have color QD?
+			SLS		IsColor(A6)			; set boolean depending on color or B&W system
+			BHI.s	@BWSys				; no, this system has B&W QD
+
+; save the current port's colors
+
+			move.l	GrafGlobals(A5),A0	; get pointer to grafGlobals	<C407/16Nov86> DAF
+			move.l	thePort(A0),A0		; get pointer to thePort		<C407/16Nov86> DAF
+
+			PEA		SavFgCol(A6)		; save foreColor
+			_GetForeColor				;
+			PEA		SavBkCol(A6)		; save backColor too
+			_GetBackColor				;
+
+
+; get the CtlAuxRec for this guy and lock it's colortable			<DAF 26Apr86>
+
+			CLR.l	-(SP)				; return the handle here
+			CLR.b	-(SP)				; space for boolean func return
+			move.l	CtlHndl(A6),-(SP)	; push the control handle
+			PEA		6(SP)				; push a pointer to placeholder
+			_GetAuxCtl					; get its auxRec
+			addQ	#2,SP				; don't need boolean result
+			move.l	(SP)+,A0			; get auxCtl handle
+			move.l	(A0),A0				; a pointer to the auxCtlRec
+			move.l	acCTable(A0),A0		; get colortable's handle		<1.3>
+			move.l	A0,AuxCtlHndl(A6)	; save the handle
+			_HLock						; lock the handle
+			move.l	(A0),AuxCtlPtr(A6)	; save a pointer
+
+; ------------- get a pixmap for drawing the gadgets ------------
+
+			subq.l	#4, SP					; room for a PixMapHandle
+			move.l	#'pmap', -(SP)			; the Pixmap resource type
+			move.w	#kPixmapID, -(SP)		; ID of working pixmap
+			_GetResource
+			move.l	(SP), workPixmap(A6)	; save it for later
+			
+			
+			move.w	#kClutID,-(sp)			; ID of clut for pixmap
+			_GetCTable
+			move.l	(sp)+,workCLUT(a6)
+
+			move.l	workPixmap(a6),a0
+			move.l	(a0),a0
+			move.l	workCLUT(a6),pmTable(a0)	; Stash colour table into pmap handle
+			
+@BWSys
+			clr.l	tempPixels(A6)			; init this to NIL
+
+
 ; fetch the parameters into registers
 
 			lea 	8(A6),A0			; get ptr to first parameter
@@ -331,6 +365,11 @@ hilite				equ		50
 
 ; case out on the message number
 
+			cmp.w	#6,d0
+			bls		@nocollapse
+			subq	#3,d0
+@nocollapse
+
 			add 	D0,D0				; double for word index
 			lea 	GoScrollBar,A1		; get table address
 			add 	0(A1,D0),A1 		; compute dispatch address
@@ -341,9 +380,23 @@ hilite				equ		50
 			PEA 	SavePen(A6) 		; push savePenState
 			_SetPenState				; restore original pen state
 
+			tst.b	IsColor(A6)			;
+			beq.s	@NoColor1			; if on B&W, then skip
+
+			move.l	AuxCtlHndl(A6),A0	; unlock the CDEF
+			_HUnlock
+			PEA		SavFgCol(A6)		;
+			_RGBForeColor				;
+			PEA		SavBkCol(A6)		;
+			_RGBBackColor				;
+
+			move.l	workCLUT(a6),-(sp)
+			_DisposCTable
+			
+@NoColor1
+
 ; we're done -- restore registers and return to caller
 
-
 OORange									; 'Out Of Range, of course'
 			moveM.l (SP)+,D3-D6/A1-A4	; restore work registers
 			UNLK	A6					; unlink	stack frame
@@ -351,9 +404,6 @@ TenBytExit	move.l	(SP)+,A0			; get return address
 			add 	#12,SP				; strip parameters
 			JMP 	(A0)				; return	to caller
 
-JustRTS		clr.l	ProcResult(a6)		; indicate we didn't handle this message
-			rts
-			
 GoScrollBar
 			DC.w	DrawSBar-GoScrollBar	; draw is message 0
 			DC.w	HitSBar-GoScrollBar		; hit test is message 1
@@ -362,92 +412,12 @@ GoScrollBar
 			DC.w	DispSBar-GoScrollBar	; de-allocate indicator region (4)
 			DC.w	MoveSBar-GoScrollBar	; move indicator call (5)
 			DC.w	ThumbSBar-GoScrollBar	; message 6 is thumb dragging
-			DC.w	JustRTS-GoScrollBar		; message 7 is thumb dragging custom message
-			DC.w	JustRTS-GoScrollBar		; message 8 is not supported
-			DC.w	JustRTS-GoScrollBar		; message 9 is not supported
-			DC.w	CalcWholeSBar-GoScrollBar; calc whole regions is message 10		<1.2>
-			DC.w	CalcThumbSBar-GoScrollBar; calc thumb regions is message 11		<1.2>
-			DC.w	DrawThumbOutline-GoScrollBar;									<26>
-
-
-; sets up the drawing environment for calls that do drawing
-
-InitDrawingStuff						;											<SM6>
-
-; Determine type of system.  We need to know if we have color QuickDraw and a color
-;	window manager port.
-
-			cmp.w	#$3FFF,ROM85		; do we have color QD?
-			SLS		IsColor(A6)			; set boolean depending on color or B&W system
-			BHI.s	@BWSys				; no, this system has B&W QD
-
-; save the current port's colors
-
-			move.l	GrafGlobals(A5),A0	; get pointer to grafGlobals	<C407/16Nov86> DAF
-			move.l	thePort(A0),A0		; get pointer to thePort		<C407/16Nov86> DAF
-
-			PEA		SavFgCol(A6)		; save foreColor
-			_GetForeColor				;
-			PEA		SavBkCol(A6)		; save backColor too
-			_GetBackColor				;
-
-
-; get the CtlAuxRec for this guy and lock it's colortable			<DAF 26Apr86>
-
-			CLR.l	-(SP)				; return the handle here
-			CLR.b	-(SP)				; space for boolean func return
-			move.l	CtlHndl(A6),-(SP)	; push the control handle
-			PEA		6(SP)				; push a pointer to placeholder
-			_GetAuxCtl					; get its auxRec
-			addQ	#2,SP				; don't need boolean result
-			move.l	(SP)+,A0			; get auxCtl handle
-			move.l	(A0),A0				; a pointer to the auxCtlRec
-			move.l	acCTable(A0),A0		; get colortable's handle		<1.3>
-			move.l	A0,AuxCtlHndl(A6)	; save the handle
-			_HLock						; lock the handle
-			move.l	(A0),AuxCtlPtr(A6)	; save a pointer
-
-; ------------- get a pixmap for drawing the gadgets ------------
-
-			subq.l	#4, SP					; room for a PixMapHandle
-			move.l	#'pmap', -(SP)			; the Pixmap resource type
-			move.w	#kPixmapID, -(SP)		; ID of working pixmap
-			move.w	#MapTrue,RomMapInsert				;									<SM2> rb
-			_GetResource					; look in ROM first							<SM2> rb
-			move.l	(SP), workPixmap(A6)	; save it for later
-			
-			
-			move.w	#kClutID,-(sp)			; ID of clut for pixmap
-			_GetCTable
-			move.l	(sp)+,workCLUT(a6)
-
-			move.l	workPixmap(a6),a0
-			move.l	(a0),a0
-			move.l	workCLUT(a6),pmTable(a0)	; Stash colour table into pmap handle
-			
-@BWSys
-			clr.l	tempPixels(A6)			; init this to NIL
-			rts
-
+			DC.w	CalcWholeSBar-GoScrollBar
+			DC.w	CalcThumbSBar-GoScrollBar
+			DC.w	DrawThumbOutline-GoScrollBar
 
 ; clean up color stuff												<DAF 28Apr86>
 
-RestoreDrawingStuff						;												<SM6>
-			tst.b	IsColor(A6)			;
-			beq.s	@NoColor1			; if on B&W, then skip
-
-			move.l	AuxCtlHndl(A6),A0	; unlock the CDEF
-			_HUnlock
-			PEA		SavFgCol(A6)		;
-			_RGBForeColor				;
-			PEA		SavBkCol(A6)		;
-			_RGBBackColor				;
-
-			move.l	workCLUT(a6),-(sp)
-			_DisposCTable
-			
-@NoColor1	rts
-
 
 
 CDefDrawFrame	RECORD	0				; stack frame for DeviceLoop draw proc
@@ -466,8 +436,6 @@ ParamSize		EQU		*-StartParams
 ; desired "hilite" area code.
 
 DrawSBar
-			bsr		InitDrawingStuff	; initialize the drawing environment				<SM6>
-
 		; if we are drawing to the screen, use _DeviceLoop to handle the case of
 		; multiple monitors. If we are not drawing to the screen, then _DeviceLoop
 		; could do the wrong thing--just draw the control directly.
@@ -498,7 +466,7 @@ DrawSBar
 			move.w	#fakeDeviceFlags, -(SP)	; assume non-CQD case
 			clr.l	-(SP)				; NIL gDeviceHandle for non-CQD machines
 			btst	#6, ROM85			; Color QuickDraw available?
-			bnz.s	@deviceAndFlagsOk	; of not, fake versions on stack are correct		<SM6>
+			bne		@deviceAndFlagsOk	; of not, fake versions on stack are correct
 			move.l	theGDevice, A1		; current device GDHandle
 			move.l	A1, (SP)			; fix gdHandle on stack
 			move.l	(A1), A1			; point to the device
@@ -506,8 +474,8 @@ DrawSBar
 @deviceAndFlagsOk
 
 			clr.l	-(SP)				; flag clear (not drawing to screen)
-			bsr.s	CDefDrawControl		; draw the control									<SM6>
-			bra.s	RestoreDrawingStuff	; cleanup after doing drawing						<SM6>
+			bsr		CDefDrawControl		; draw the control
+			rts
 
 @drawToScreen
 			subq	#4, SP				; room for RgnHandle
@@ -529,7 +497,7 @@ DrawSBar
 			move.l	controlRgn(A6), -(SP)
 			_DisposRgn
 
-			bra		RestoreDrawingStuff	; cleanup after doing drawing						<SM6>
+			rts
 
 
 CDefDrawControl
@@ -669,7 +637,7 @@ SkipDown
 			bsr		SetupColors						;
 			PEA		TempRect						; push the rectangle
 			_EraseRect								; paint the shade on the scroll bar
-			bra.s	DoIndicator						; done drawing background of scroll bar
+			bra		DoIndicator						; done drawing background of scroll bar
 @whiteOutScrollBar
 			PEA		TempRect						; push the rectangle
 			move.l	(A5),A0 						; get grafGlobals
@@ -697,12 +665,12 @@ SkipDown
 
 DoIndicator
 			bsr		IsDisabled				; is it disabled
-			bz.s	FrameCtl				; yes => go frame the control						<SM6>
+			bz		FrameCtl				; yes => go frame the control
 
 			move.l	IndicatorRect(A6),TempRect
 			move.l	IndicatorRect+4(A6),TempRect+4
 			tst.b	shaded(a6)				; is it shaded
-			bnz.s	@drawShadedThumb		; yes => handle shaded thumb						<SM6>
+			bnz		@drawShadedThumb		; yes => handle shaded thumb
 			
 			move.l	#$FFFF0000,d0			; Inset height
 			tst.w	isHoriz(a6)				; Horizontal thumb?
@@ -797,7 +765,7 @@ DrawArrowBox
 			tst.b	shaded(a6)			; If we’re drawing in black and white, then
 			bz.s	@bwScrollBar		; it doesn’t matter if we’re disabled or not.
 			
-			bsr.s	IsDisabled			; If disabled & drawing in colour,						<SM6>
+			bsr		IsDisabled			; If disabled & drawing in colour,
 			bnz.s	@notDisabled		; use black and white arrows to draw.
 			
 ; Set up colours to match faint gray used in body of scroll bar
@@ -847,7 +815,7 @@ IsDisabled
 			move.l	(A3),A0 			; get sBar pointer
 			move.w	ContrlMin(A0),D0	; get the min
 			cmp.w	ContrlMax(A0),D0	; same as the max?
-			beq.s	doneChecking		;														<SM6>
+			beq		doneChecking
 			move.b	ContrlHilite(A0),D0 ; get the hilite parameter
 			addQ.b	#1,D0				; was it	255?
 doneChecking
@@ -1093,7 +1061,7 @@ GetIndRgn
 ; the whole region was requested
 
 CalcWholeSBar
-			move.l	#1, ProcResult(A6)	; return 1 to show that we respond				<V1.2>
+			move.b	#1, ProcResult+3(A6); return 1 to show that we respond				<V1.2>
 GetWholeRgn
 			move.l	D3,-(SP)			; push the region handle
 			PEA 	ContrlRect(A0)		; push rectangle	pointer
@@ -1101,7 +1069,7 @@ GetWholeRgn
 			rts 						; all done!
 
 CalcThumbSBar
-			move.l	#1, ProcResult(A6)	; return 1 to show that we respond				<V1.2>
+			move.b	#1, ProcResult+3(A6); return 1 to show that we respond				<V1.2>
 			BRA.s	GetIndRgn			;												<V1.2>
 
 PlotLtGray
@@ -1112,13 +1080,13 @@ PlotLtGray
 			beq.s	@useOldStyle		; no => fill using black on white
 			move.w	#wHiliteShade8,D0	; use a dark gray for dots in pattern
 			move.w	#cArrowShade2,D1	; use a light gray for the background
-			bra.s	@plotPAT			;												<SM6>
+			bra		@plotPAT
 @useOldStyle
 			move.w	#cFrameColor,D0		; black foreground
 			move.w	#cBodyColor,D1		; white background
 @plotPAT
 			bsr		SetupColors			; set up the foreground and background colors
-			bsr.s	GetOldStyleLtGray	; use common routine to get the PAT				<SM6>
+			bsr		GetOldStyleLtGray	; use common routine to get the PAT
 			move.l	(A0),-(SP)			; dereference to get PatPtr
 			_FillRect					; fill the rect
 @doneGetLtGray
@@ -1534,7 +1502,7 @@ SetupRatioColor
 			move.l	(A0)+, endRGB(A6)					; copy red and green
 			move.w	(A0), endRGB+4(A6)					; copy blue
 			move.w	(SP)+, D2							; get shade percentage
-			bsr		MakeRatioRGB						; create a shade between the two		<SM6>
+			bsr		MakeRatioRGB						; create a shade between the two
 			rts
 
 ; ================================================
@@ -1645,8 +1613,7 @@ SetupColorPict
 			subq.l	#4, SP								; room for the PicHandle
 			move.l	#'pixs', -(SP)
 			move.w	d0, -(SP)							; push the resource ID
-			move.w	#MapTrue,RomMapInsert				;									<SM2> rb
-			_GetResource								; look in ROM first					<SM2> rb
+			_GetResource
 			move.l	(SP)+, A0							; pixels handle
 			_HLock										; don’t want it to move
 			move.l	A0, tempPixels(A6)					; save for dispose
@@ -1726,8 +1693,6 @@ AdjustRect
 ; <26> The following routine is used to draw the outline of the thumb during dragging.
 DrawThumbOutline
 
-				bsr		InitDrawingStuff				; initialize the drawing environment	<SM6>
-
 	IF NOT forROM THEN
 				subq.l	#4,sp							; get a new rgn
 				_NewRgn
@@ -1747,7 +1712,7 @@ DrawThumbOutline
 				_DisposRgn
 	ENDIF
 				ST		ProcResult(a6)
-				bra		RestoreDrawingStuff				; cleanup after doing drawing			<SM6>
+				rts
 
 
 ; <26> The following routine is for drawing of the outline of a dragged thumb.
@@ -1791,7 +1756,7 @@ ThumbDrawRoutine
 			_FrameRect
 		ENDIF
 
-		bra.s		@doneDrawThumb				;												<SM6>
+		bra			@doneDrawThumb
 @colorWindow									; yes => use the HiliteMode
 		bsr			SetupWMgrCPort
 		move.w		#hilite,-(sp)					; set HiliteMode
diff --git a/Toolbox/DataAccessMgr/DataAccessMgr.c b/Toolbox/DataAccessMgr/DataAccessMgr.c
--- a/Toolbox/DataAccessMgr/DataAccessMgr.c
+++ b/Toolbox/DataAccessMgr/DataAccessMgr.c
@@ -11,8 +11,6 @@
 
 	Change History (most recent first):
 
-	   <SM2>	11/19/92	RB		Set ROMMapInsert to MapTrue just before doing some GetResource
-									calls so that we look in ROM first.
 		<30>	 3/13/92	JSM		Renamed this file DataAccessMgr.c from SnarfMan.c, keeping all
 									the old revisions.
 		<29>	 7/15/91	dba		get rid of MEMERR
@@ -286,8 +284,6 @@ SMInitDBPack(short version)
 				get unlocked and/or purged at the wrong
 				time by PACKHelper.
 			*/
-			*((short*) RomMapInsert) = mapTrue;
-			
 			resH = GetResource(COMPCODERESTYPE, COMPCODERESID);
 			if (resH != NULL)
 			{
@@ -384,8 +380,6 @@ InstallDefaultHandlers(snarfGlobPtr	glob)
 	if (rc == noErr)
 	{
 		/* get the 'rtt#' */
-		*((short*) RomMapInsert) = mapTrue;
-		
 		resH = GetResource(RTTLISTRESTYPE, RTTLISTID);
 		if (resH != NULL)
 		{
@@ -406,9 +400,6 @@ InstallDefaultHandlers(snarfGlobPtr	glob)
 			resP += sizeof(short);
 
 			/* load in 'proc' */
-			
-			*((short*) RomMapInsert) = mapTrue;
-			
 			handlerH = GetResource(RTTCODERESTYPE, handlerID);
 			if (handlerH != NULL)
 			{
@@ -2184,8 +2175,6 @@ SMGetNewQuery(short queryID, QueryHandle *query)
 	*query = NULL;
 
 	/* get the 'qrsc' */
-	*((short*) RomMapInsert) = mapTrue;
-	
 	resH = (queryRes**)GetResource(QRSCRESTYPE, queryID);
 
 	if (!resH)
@@ -2251,8 +2240,6 @@ SMGetNewQuery(short queryID, QueryHandle *query)
 				/* get qdef proc - id 0 means no qdef */
 				if (resP->qdefID != 0)
 				{
-					*((short*) RomMapInsert) = mapTrue;
-					
 					queryP->queryProc = GetResource(QDEFRESTYPE, resP->qdefID);
 					if (!queryP->queryProc)
 					{
@@ -2278,8 +2265,6 @@ SMGetNewQuery(short queryID, QueryHandle *query)
 
 					for (i = 0; i < resP->numQueries; i++)
 					{
-						*((short*) RomMapInsert) = mapTrue;
-						
 						*queries = GetResource(QUERYRESTYPE, *wstrID);
 						if (*queries)
 						{
diff --git a/Toolbox/DialogMgr/DialogDispatch.a b/Toolbox/DialogMgr/DialogDispatch.a
--- a/Toolbox/DialogMgr/DialogDispatch.a
+++ b/Toolbox/DialogMgr/DialogDispatch.a
@@ -219,7 +219,6 @@ rName			ds.b		256					; resName
 
 				move.l	windowDef(a4),d0		; Get the defproc handle
 				_StripAddress					; Get rid of variant kept in hi byte (to be clean)
-				move.w	#MapTrue,ROMMapInsert	; this WDEF could be in ROM !								<SM7> rb
 				move.l	d0,-(sp)				; Push the handle
 				pea		id(a6)					; VAR id
 				pea		rType(a6)				; VAR type
@@ -430,7 +429,7 @@ kBOCorner		 EQU 	16			; Radius for outline frame
 
 
 
-				linkSave	A2-A4/D3-D7			; link and save the registers to be used
+				linkSave	A2-A4/D4-D7			; link and save the registers to be used
 				move.l		theEvent(a6),a2
 				move.l		evtMessage(a2),d4	; cache event.message
 
@@ -553,17 +552,8 @@ kBOCorner		 EQU 	16			; Radius for outline frame
 
 		; if cursor is over a TE field, then turn cursor to an I-beam, else the arrow
 
-		; Note: the current port may not be our dialog, we need to set it before							<19>
-		; calling GetMouse since it returns the mouse in local coordinates.									<19>
-		
-				pea			savedPort(a6)			;														<19>
-				_GetPort							;														<19>
-				push.l		a4						; switch current port to get right coordinates			<19>
-				_SetPort							;														<19>
 				pea			cursorLocation(a6)
 				_GetMouse							; get currect mouse position in local coordinates
-				push.l		savedPort(a6)			;														<19>
-				_SetPort							; restore port											<19>
 				subq		#2,sp
 				push.l		a4						; this is assumed to be the front window, because of how ClaimEvent works
 				push.l		cursorLocation(a6)
@@ -650,16 +640,7 @@ kBOCorner		 EQU 	16			; Radius for outline frame
 				_SetPort
 
 @doneUpdate
-		; If this is an update event for another window, it will never get cleared until the modal dialog	<19>
-		; is dismissed.  So, we'll never see a null event, which means we need to track the cursor here as	<19>
-		; well as for null events.  Also, A4 points to the window the update event is for, so we need to	<19>
-		; call FrontWindow to get the dialog we're really interested in.									<19>
-				subq		#4,sp					; room for frontmost window								<19>
-				_FrontWindow						;														<19>
-				pop.l		a4						; get frontmost window into a4							<19>
-				move.b		dlgFlagsByte(a4),d6		; and get the flags into d6								<19>
-				bra.s		@checkCursor			; track cursor in case this update event is always		<19>
-													; pending and we never get a null event					<19>
+				bra.s		@done
 
 
 
diff --git a/Toolbox/DialogMgr/DialogMgrPatches.a b/Toolbox/DialogMgr/DialogMgrPatches.a
--- a/Toolbox/DialogMgr/DialogMgrPatches.a
+++ b/Toolbox/DialogMgr/DialogMgrPatches.a
@@ -9,12 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<29>	12/17/92	JSM		Fix bug in DialogSelectFixes patch where item hit was not being
-;									set to -1 (just putting it in D3 isn’t enough, since we jump
-;									back into ROM after the point where D3 is stuffed into
-;									DSItemHit).  This code path appears to be rarely taken, so the
-;									bug probably doesn't show up much (I discovered it just looking
-;									at the code).
 ;		<28>	 6/11/92	JSM		Add comments about IIci patches that have been rolled into
 ;									DialogMgr.a: IsDialogEventFixes, DialogSelectFixes, DSEditPatch,
 ;									FixDoAlertToDisposeCIconHandles, FixDoStaticSub, and
@@ -300,8 +294,6 @@ DSResult		EQU 		DSEvent+4				; function result
 				jmprom		DSAfterClaimEvent		; rejoin the ROM
 @NotValid
 				moveq		#-1,d3
-				move.l		DSItemHit(a6), a0		; get VAR address of user’s item		<29>
-				move.w		d3, (a0)				; Save item number hit					<29>
 				jmprom		DSNotMineExit			; not a dialog event; exit through ROM
 
 				EndProc
diff --git a/Toolbox/DialogMgr/ModalDialogMenuExtensions.a b/Toolbox/DialogMgr/ModalDialogMenuExtensions.a
--- a/Toolbox/DialogMgr/ModalDialogMenuExtensions.a
+++ b/Toolbox/DialogMgr/ModalDialogMenuExtensions.a
@@ -181,17 +181,16 @@ SetAnalyzedWindowState	proc	export
 				export	GetAnalyzedWindowState
 
 				move.l	(sp)+,a0
-				move.l	ExpandMem,a1						; A1 -> Expanded Low Memory
-				move.l	ExpandMemRec.emDialogGlobals(a1),a1	; A1-> ptr to globals
-				move.w	(sp)+,DialogMgrGlobals.AnalyzedWindowState(a1)		; set new value
+				lea		theState,a1
+				move.w	(sp)+,(a1)		; set new value
 				jmp		(a0)
 
 GetAnalyzedWindowState
-				move.l	ExpandMem,a1						; A1 -> Expanded Low Memory
-				move.l	ExpandMemRec.emDialogGlobals(a1),a1	; A1-> ptr to globals
-				move.w	DialogMgrGlobals.AnalyzedWindowState(a1),4(sp)	; get return value
+				move.w	theState,4(sp)	; get return value
 				rts
 
+theState		dc.w	0
+
 				endproc
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
@@ -200,17 +199,16 @@ SetAnalyzedWindow		proc	export
 				export	GetAnalyzedWindow
 
 				move.l	(sp)+,a0
-				move.l	ExpandMem,a1						; A1 -> Expanded Low Memory
-				move.l	ExpandMemRec.emDialogGlobals(a1),a1	; A1-> ptr to globals
-				move.l	(sp)+,DialogMgrGlobals.AnalyzedWindow(a1)	; set new value
+				lea		theState,a1
+				move.l	(sp)+,(a1)		; set new value
 				jmp		(a0)
 
 GetAnalyzedWindow
-				move.l	ExpandMem,a1						; A1 -> Expanded Low Memory
-				move.l	ExpandMemRec.emDialogGlobals(a1),a1	; A1-> ptr to globals
-				move.l	DialogMgrGlobals.AnalyzedWindow(a1),4(sp)	; get return value
+				move.l	theState,4(sp)	; get return value
 				rts
 
+theState		dc.l	1
+
 				endproc
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
@@ -219,18 +217,17 @@ SetSavedMenuState		proc	export
 				export	GetSavedMenuState
 
 				move.l	(sp)+,a0
-				move.l	ExpandMem,a1						; A1 -> Expanded Low Memory
-				move.l	ExpandMemRec.emDialogGlobals(a1),a1	; A1-> ptr to globals
-				move.l	(sp)+,DialogMgrGlobals.SavedMenuState(a1)	; set new value
+				lea		theState,a1
+				move.l	(sp)+,(a1)		; set new value
 				jmp		(a0)
 
 GetSavedMenuState
 
-				move.l	ExpandMem,a1						; A1 -> Expanded Low Memory
-				move.l	ExpandMemRec.emDialogGlobals(a1),a1	; A1-> ptr to globals
-				move.l	DialogMgrGlobals.SavedMenuState(a1),4(sp)	; get return value
+				move.l	theState,4(sp)	; get return value
 				rts
 
+theState		dc.l	0
+
 				endproc
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
diff --git a/Toolbox/DialogMgr/ModalDialogMenuPatches.a b/Toolbox/DialogMgr/ModalDialogMenuPatches.a
--- a/Toolbox/DialogMgr/ModalDialogMenuPatches.a
+++ b/Toolbox/DialogMgr/ModalDialogMenuPatches.a
@@ -13,11 +13,6 @@
 ;		<16>	 6/11/92	JSM		Remove unneeded ROMBinds, add comment about
 ;									ModalDialogSetFlagsAndAddFilter patch that was rolled into
 ;									DialogMgr.a.
-;		<15>	 6/10/92	JSM		Move some routines common to both ROM and System to
-;									ModalDialogMenuExtensions.a from this file, ModalDialogMenuSetup
-;									and MDJGNEFilter are now just MakePatch macros referencing
-;									routines there. Add MakeInstall of InitDialogMgrGlobals for
-;									TheFuture so we don’t keep our globals in code space.
 ;		<14>	 2/10/91	KSM		DBA,#80950: Fix to handle graying of Applications Menu properly.
 ;		<13>	 1/21/91	DFH		(KSM) Process Menu is now called Application Menu.
 ;		<12>	 1/18/91	KSM		<RLC> Change include of BalloonPACKEqu to BalloonsPriv.a.
@@ -54,15 +49,6 @@
 
 DEBUG	default		false						; Required for InternalMacros.a
 
-;————————————————————————————————————————————————————————————————————————————————————————————————————
-; InitDialogMgrGlobals - defined in DialogMgrExtensions.a
-;
-; allocate and initialize globals stored in emDialogGlobals
-;
-
-			import		InitDialogMgrGlobals
-			MakeInstall	InitDialogMgrGlobals,(Plus,SE,II,Portable,IIci)
-
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 ; ModalDialog — set up flags so we can recognize modal dialogs, and put in a new improved filter
 ;
diff --git a/Toolbox/DiskInit/DiskInit.make.idump b/Toolbox/DiskInit/DiskInit.make.idump
new file mode 100644
--- /dev/null
+++ b/Toolbox/DiskInit/DiskInit.make.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Toolbox/DiskInit/DiskInitBadBlock.c b/Toolbox/DiskInit/DiskInitBadBlock.c
--- a/Toolbox/DiskInit/DiskInitBadBlock.c
+++ b/Toolbox/DiskInit/DiskInitBadBlock.c
@@ -98,10 +98,6 @@
 #include <HFSDefs.h>
 #include <Disks.h>
 
-typedef	unsigned long	ulong;				/* idiosyncrasy of the author */
-typedef	unsigned short	ushort;
-typedef	unsigned char	uchar;
-
 #define	BUFSIZE		18				/* test buffer size, in sectors (mb >=18) */ 
 							/* 18 is bad 'cause it's greater than a track (KSCT) */
 #define	CLUMP		1				/* coallesce badspots only if they are contig */
diff --git a/Toolbox/FontMgr/BassExtensions.a b/Toolbox/FontMgr/BassExtensions.a
--- a/Toolbox/FontMgr/BassExtensions.a
+++ b/Toolbox/FontMgr/BassExtensions.a
@@ -191,9 +191,30 @@ JStdTxMeas 	PROC	EXPORT
 ;	application heap. 																		
 ;——————————————————————————————————————————————————————————————————————————————————————————	
 																							
-;SetAppBaseCacheCleaner	PatchProc	$A057,(Plus,SE,II,Portable,IIci) ;SetAppBase				
+SetAppBaseCacheCleaner	PatchProc	$A057,(Plus,SE,II,Portable,IIci) ;SetAppBase				
+		MOVEM.L	D0-D3/A0-A2,-(SP)
+		CLR.L	-(SP)
+		MOVE.L	ApplZone,A0
+		MOVE.L	A0,-(SP)
+		MOVE.L	(A0),-(SP)
+		MOVEQ	#2,D0					; SB_KillSomeCaches
+		_FontDispatch
+		ADDQ	#4,SP
+		MOVEM.L	(SP)+,D0-D3/A0-A2
+		jmpOld
 
-;InitApplZoneCacheCleaner	PatchProc	$A02C,(Plus,SE,II,Portable,IIci) ;InitApplZone
+
+InitApplZoneCacheCleaner	PatchProc	$A02C,(Plus,SE,II,Portable,IIci) ;InitApplZone
+		MOVEM.L	D0-D3/A0-A2,-(SP)
+		CLR.L	-(SP)
+		MOVE.L	ApplZone,A0
+		MOVE.L	A0,-(SP)
+		MOVE.L	(A0),-(SP)
+		MOVEQ	#2,D0					; SB_KillSomeCaches
+		_FontDispatch
+		ADDQ	#4,SP
+		MOVEM.L	(SP)+,D0-D3/A0-A2
+		jmpOld
 
 
 
@@ -201,13 +222,146 @@ JStdTxMeas 	PROC	EXPORT
 ;					ATM lovely hack remains with system files
 ;——————————————————————————————————————————————————————————————————————————————————————————
 
+ATMThing_FMSwapFont	PROC	EXPORT
+		EXPORT	ATMThing_FMSwapFont_Data
+
+		CLR.L	-(SP)
+		MOVE.L	8(SP),-(SP)
+		MOVE.L	ATMThing_FMSwapFont_Data+4,A0
+		JSR		(A0)
+		MOVE.L	(SP)+,A1
+		MOVE.L	WidthTabHandle,A0
+		MOVE.L	(A0),A0
+		TST.B	WidthIsSpline(A0)
+		BNZ.S	@spline
+		MOVE.L	ATMThing_FMSwapFont_Data,A0
+		JMP		(A0)
+@spline
+		MOVE.L	(SP)+,A0
+		ADDQ	#4,SP
+		MOVE.L	A1,(SP)
+		JMP		(A0)
+ATMThing_FMSwapFont_Data
+		DC.L	0, 0
+
+
+ATMThing_StdText	PROC	EXPORT
+		EXPORT	ATMThing_StdText_Data
+
+		LINK	A6,#0
+		CLR.W	-(SP)
+		MOVE.L	12(A6),-(SP)
+		MOVE.L	8(A6),-(SP)
+		_IsOutline
+		TST.W	(SP)+
+		UNLK	A6
+		BNE.S	@isoutline
+		MOVE.L	ATMThing_StdText_Data,A0
+		JMP		(A0)
+@isoutline
+		MOVE.L	ATMThing_StdText_Data+4,A0
+		JMP		(A0)
+ATMThing_StdText_Data
+		DC.L	0, 0
+
+
+ATMInstallRoutine	PROC	EXPORT
+		MOVEM.L	D0/D1/A0,-(SP)
+		MOVE.W	(A0)+,D0
+		CMP.W	#$4EF9,D0		; JMP to 4-byte absolute address
+		BNE.S	@return
+		MOVE.L	(A0),A0
+		MOVEQ	#0,D0
+		MOVE.W	#50,D1
+@lup
+		ADD.L	(A0)+,D0
+		DBRA	D1,@lup
+@lup2
+		MOVE.L	(A1)+,D1
+		BEQ.S	@return1
+		CMP.L	D1,D0
+		BEQ.S	@return
+		BRA.S	@lup2
+@return1
+		MOVEQ	#1,D0
+@return
+		MOVEM.L	(SP)+,D0/D1/A0
+		RTS
+
+
+;R1086	PROC	EXPORT
+ATMPatchInterceptor	PatchProc	_SetTrapAddress, (Plus,SE,II,Portable,IIci)
+		IMPORT	ATMThing_FMSwapFont, ATMThing_FMSwapFont_Data
+		IMPORT	ATMThing_StdText, ATMThing_StdText_Data
+		EXPORT	ATMPatchInterceptor_JmpOld
+
+		CMP.W	#$A647,D1			; wrap SetToolTrapAddress only
+		BNE.S	@return
+
+		CMP.W	#$A901,D0
+		BNE.S	@tryOtherTrap
+
+		LEARESIDENT	ATMThing_FMSwapFont,A2		; when called on FMSwapFont
+		PEA		ATMThing_FMSwapFont_Data
+		LEA		CallerChecksums_FMSwapFont,A1
+		BRA.S	@commonPath
+
+@tryOtherTrap
+		CMP.W	#$A882,D0
+		BNE.S	@return
+
+		LEARESIDENT	ATMThing_StdText,A2		; when called on StdText
+		PEA		ATMThing_StdText_Data
+		LEA		CallerChecksums_StdText,A1
+
+@commonPath
+		JSR		ATMInstallRoutine
+		MOVE.L	(SP)+,A1
+		BNE.S	@return
+		MOVE.L	A0,(A1)+
+		MOVEM.L	D0,-(SP)
+		_GetToolTrapAddress
+		MOVEM.L	(SP)+,D0
+		MOVE.L	A0,(A1)
+		MOVE.L	A2,A0
+@return
+		EXPORT	ATMPatchInterceptor_JmpOld
+ATMPatchInterceptor_JmpOld					; self-modifying code
+		JMPOLD
+CallerChecksums_FMSwapFont
+		DC.L	$417FFC36
+		DC.L	$2D71904E
+		DC.L	$44EDD323
+		DC.L	$40CFFC7E
+		DC.L	$2CC19096
+		DC.L	$4535D273
+		DC.L	0
+CallerChecksums_StdText
+		DC.L	$E339FCB4
+		DC.L	$86FDFDCE
+		DC.L	$36B5833C
+		DC.L	$E335FCB4
+		DC.L	$86F9FDCE
+		DC.L	$36B1833C
+		DC.L	0
+
+
+;R1092	PROC	EXPORT
+NeutralizeATMPatch	PatchProc	_Launch, (Plus,SE,II,Portable,IIci) ; probably the wrong call!
+		IMPORT	ATMPatchInterceptor
+
+		LEA		ATMPatchInterceptor,A1
+		MOVE.W	#$4EF9,(A1)+
+		LEA		ATMPatchInterceptor_JmpOld,A2
+		ADDQ	#2,A2
+		MOVE.L	(A2),(A1)
+		JMPOLD
 
 ;——————————————————————————————————————————————————————————————————————————————————————————
 ;				Bass Dispatcher
 ;——————————————————————————————————————————————————————————————————————————————————————————
 
-;SplineCall PatchProc $A854,(Plus,SE,II,Portable,IIci)
-SPLINECALL 	Proc 	Export
+SplineCall PatchProc $A854,(Plus,SE,II,Portable,IIci)
 		MOVE.L	expandMem, A0				; get low mem expand
 		MOVE.L	ExpandMemRec.emSplineKey(A0),D1		; splineKey invalid?
 		BEQ.S	@bailOut				; yes -> bail out
@@ -222,10 +376,11 @@ SPLINECALL 	Proc 	Export
 @fontCache
 		MOVE.L	(A1)+,D1				; load vector table size.
 		CMP.W	D1,D0					; valid selector?
-		BHS.S	@bailOut				; no -> bail out.		<SM3 chp>
+		BGE.S	@bailOut				; no -> bail out.
 @loadVector
-		move.l	(a1,d0*4),a1				; Get address of routine	<SM3 chp>
-		jmp	(a1)					; Jump to routine		<SM3 chp>
+		LSL.L	#2,D0
+		move.l	(a1,d0),a1				; Get address of routine
+		jmp	(a1)					; Jump to routine
 
 @bailOut
 		SWAP	D0					; Get number of params
@@ -264,18 +419,6 @@ FontMgrGestalt	PROC	EXPORT
 ;				EntryTables…
 ;——————————————————————————————————————————————————————————————————————————————————————————
 
-FREE_SPOT	PROC	EXPORT			; Just a place holder
-		RTS
-		ENDPROC
-
-
-; <SM3 chp>	Current versions of the StyleWriter driver know about the structure of the
-; <SM3 chp>	DispatchFontCache table and patch it, so the table cannot change until
-; <SM3 chp>	the StyleWriter driver changes (post Cube-E). For now, DispatchFontCache
-; <SM3 chp>	is a template for a nonrelocatable block of memory in the system heap.
-; <SM3 chp>	DispatchFontScaler needs to have the same general structure as the former
-; <SM3 chp>	table since it is used in the same manner by the same dispatch routine.
-
 DispatchFontCache	record	0					; <SM3 chp>
 entries			ds.l	1
 vIsOutline		ds.l	1		; selector  0
@@ -324,40 +467,73 @@ vfs_GetBitMapData	ds.l	1		; selector  11
 size			equ	*
 			endr						; <SM3 chp>
 
+FontCacheTable		PROC	EXPORT
+	case		off
+	import		IsOutline, SetOutlinePreferred, SB_KillSomeCaches
+	import		sb_FillPrinterWidths, sb_RetrieveGlyph, sb_FillWidthTab
+	import		sb_SearchForCache, sb_PreflightFontMem
+	import		OutlineMetrics, GetOutlinePreferred
+	import		SetPreserveGlyph, GetPreserveGlyph
+	import		sb_FlushFonts, sb_SFNTMatchSize, fs_LowestPPEM
+	import		InitializePartialFonts, InitializeDiskCache
+
+	dc.l				(@end-*)/4
+	dcImportResident	IsOutline
+	dcImportResident	SetOutlinePreferred
+	dcImportResident	SB_KillSomeCaches
+	dcImportResident	sb_FillPrinterWidths
+	dcImportResident	sb_RetrieveGlyph
+	dcImportResident	sb_FillWidthTab
+	dcImportResident	sb_SearchForCache
+	dcImportResident	sb_PreflightFontMem
+	dcImportResident	OutlineMetrics
+	dcImportResident	GetOutlinePreferred
+	dcImportResident	SetPreserveGlyph
+	dcImportResident	GetPreserveGlyph
+	dcImportResident	sb_FlushFonts
+	dcImportResident	sb_SFNTMatchSize
+	dcImportResident	fs_LowestPPEM
+	dcImportResident	InitializePartialFonts
+	dcImportResident	InitializeDiskCache
+@end
+	case		obj
+
+
+FontScalerTable		PROC	EXPORT
+	case		off
+	import		fs_OpenFonts, fs_Initialize, fs_NewSfnt
+	import		fs_NewTransformation, fs_NewGlyph
+	import		fs_GetAdvanceWidth
+	import		fs_ContourGridFit, fs_ContourNoGridFit
+	import		fs_FindBitMapSize, fs_SizeOfOutlines
+	import		fs_SaveOutlines, fs_RestoreOutlines
+	import		fs_ContourScan, fs_CloseFonts
+
+	dc.l				(@end-*)/4
+	dcImportResident	fs_OpenFonts
+	dcImportResident	fs_Initialize
+	dcImportResident	fs_NewSfnt
+	dcImportResident	fs_NewTransformation
+	dcImportResident	fs_NewGlyph
+	dcImportResident	fs_GetAdvanceWidth
+	dcImportResident	fs_ContourGridFit
+	dcImportResident	fs_ContourNoGridFit
+	dcImportResident	fs_FindBitMapSize
+	dcImportResident	fs_SizeOfOutlines
+	dcImportResident	fs_SaveOutlines
+	dcImportResident	fs_RestoreOutlines
+	dcImportResident	fs_ContourScan
+	dcImportResident	fs_CloseFonts
+@end
+	case		obj
+
 
 
 ;——————————————————————————————————————————————————————————————————————————————————————————
 ;	Boot-time initialization code, if any, goes here.
 ;——————————————————————————————————————————————————————————————————————————————————————————
 
-;InstallBassCommon	InstallProc	(Plus,SE,II,Portable,IIci)
-INSTALLBASSCOMMON	Proc	Export
-
-; <SM3 chp>	Since the above-described dispatch tables are no longer initialized by the
-; <SM3 chp>	link patch mechanism and cannot be placed in ROM, all of the following
-; <SM3 chp>	entry points are imported and initialized into the tables by this routine.
-;
-		case		off
-		import		IsOutline, SetOutlinePreferred, SB_KillSomeCaches
-		import		sb_FillPrinterWidths, sb_RetrieveGlyph, sb_FillWidthTab
-		import		sb_SearchForCache, sb_PreflightFontMem
-		import		OutlineMetrics, GetOutlinePreferred
-		import		SetPreserveGlyph, GetPreserveGlyph
-		import		sb_FlushFonts, sb_SFNTMatchSize, fs_LowestPPEM
-		import		InitializePartialFonts, InitializeDiskCache
-
-		import		fs_OpenFonts, fs_Initialize, fs_NewSfnt
-		import		fs_NewTransformation, fs_NewGlyph
-		import		fs_GetAdvanceWidth
-		import		fs_ContourGridFit, fs_ContourNoGridFit
-		import		fs_FindBitMapSize, fs_SizeOfOutlines
-		import		fs_SaveOutlines, fs_RestoreOutlines
-		import		fs_ContourScan, fs_CloseFonts
-	if TheFuture then
-		import		fs_GetGlyphInfo, fs_GetGlyphData
-		import		fs_GetBitMapInfo, fs_GetBitMapData
-	endif
-		case		obj
+InstallBassCommon	InstallProc	(Plus,SE,II,Portable,IIci)
 
 ;——————————————————————————————————————————————————————————————————————————————————————————
 ;					Allocate splinekey memory…
@@ -374,95 +550,10 @@ INSTALLBASSCOMMON	Proc	Export
 ;——————————————————————————————————————————————————————————————————————————————————————————
 ;					Fill out dispatch tables…
 ;——————————————————————————————————————————————————————————————————————————————————————————
-		moveq		#DispatchFontCache.size,d0		; <SM3 chp>
-		_NewPtr		,sys,clear
+		leaResident	FontCacheTable,A0
 		MOVE.L		A0, splineKeyRec.vFontCache(A2)		; Save dispatch table ptr (fontCache)
-		beq.b		@endDFCInit
-
-		moveq		#(DispatchFontCache.size/4)-1,d0	; number of vector entries in table
-		move.l		d0,(a0)+
-		lea		IsOutline,a1			; selector  0
-		move.l		a1,(a0)+
-		lea		SetOutlinePreferred,a1		; selector  1
-		move.l		a1,(a0)+
-		lea		SB_KillSomeCaches,a1		; selector  2
-		move.l		a1,(a0)+
-		lea		sb_FillPrinterWidths,a1		; selector  3
-		move.l		a1,(a0)+
-		lea		sb_RetrieveGlyph,a1		; selector  4
-		move.l		a1,(a0)+
-		lea		sb_FillWidthTab,a1		; selector  5
-		move.l		a1,(a0)+
-		lea		sb_SearchForCache,a1		; selector  6
-		move.l		a1,(a0)+
-		lea		sb_PreFlightFontMem,a1		; selector  7
-		move.l		a1,(a0)+
-		lea		OutlineMetrics,a1		; selector  8
-		move.l		a1,(a0)+
-		lea		GetOutlinePreferred,a1		; selector  9
-		move.l		a1,(a0)+
-		lea		SetPreserveGlyph,a1		; selector  a
-		move.l		a1,(a0)+
-		lea		GetPreserveGlyph,a1		; selector  b
-		move.l		a1,(a0)+
-		lea		sb_FlushFonts,a1		; selector  c
-		move.l		a1,(a0)+
-		lea		sb_SFNTMatchSize,a1		; selector  d
-		move.l		a1,(a0)+
-		lea		fs_LowestPPEM,a1		; selector  e
-		move.l		a1,(a0)+
-		lea		InitializePartialFonts,a1	; selector  f	<14>
-		move.l		a1,(a0)+
-		lea		InitializeDiskCache,a1		; selector  10	<14>
-		move.l		a1,(a0)+
-@endDFCInit
-
-		moveq		#DispatchFontScaler.size,d0
-		_NewPtr		,sys,clear
+		leaResident	FontScalerTable,A0
 		MOVE.L		A0, splineKeyRec.vFontScaler(A2)	; Save dispatch table ptr (fontScaler)
-		beq.b		@endDFSInit
-
-		moveq		#(DispatchFontScaler.size/4)-1,d0	; number of vector entries in table
-		move.l		d0,(a0)+
-		lea		fs_OpenFonts,a1			; selector  0
-		move.l		a1,(a0)+
-		lea		fs_Initialize,a1		; selector  1
-		move.l		a1,(a0)+
-		lea		fs_NewSfnt,a1			; selector  2
-		move.l		a1,(a0)+
-		lea		fs_NewTransformation,a1		; selector  3
-		move.l		a1,(a0)+
-		lea		fs_NewGlyph,a1			; selector  4
-		move.l		a1,(a0)+
-		lea		fs_GetAdvanceWidth,a1		; selector  5
-		move.l		a1,(a0)+
-		lea		fs_ContourGridFit,a1		; selector  6
-		move.l		a1,(a0)+
-		lea		fs_ContourNoGridFit,a1		; selector  7
-		move.l		a1,(a0)+
-		lea		fs_FindBitMapSize,a1		; selector  8
-		move.l		a1,(a0)+
-		lea		fs_SizeOfOutlines,a1		; selector  9
-		move.l		a1,(a0)+
-		lea		fs_SaveOutlines,a1		; selector  a
-		move.l		a1,(a0)+
-		lea		fs_RestoreOutlines,a1		; selector  b
-		move.l		a1,(a0)+
-		lea		fs_ContourScan,a1		; selector  c
-		move.l		a1,(a0)+
-		lea		fs_CloseFonts,a1		; selector  d
-		move.l		a1,(a0)+
-	if TheFuture then
-		lea		fs_GetGlyphInfo,a1		; selector  e
-		move.l		a1,(a0)+
-		lea		fs_GetGlyphData,a1		; selector  f
-		move.l		a1,(a0)+
-		lea		fs_GetBitMapInfo,a1		; selector  10
-		move.l		a1,(a0)+
-		lea		fs_GetBitMapData,a1		; selector  11
-		move.l		a1,(a0)+
-	endif
-@endDFSInit								; <SM3 chp>
 
 ;——————————————————————————————————————————————————————————————————————————————————————————
 ;					Initialize the splinePreferred flag…
@@ -501,21 +592,40 @@ INSTALLBASSCOMMON	Proc	Export
 ; Force _InitFonts to be called.
 ; Don’t include Mac Plus in ROM list, since FMExist doesn’t on the Plus.
 ;——————————————————————————————————————————————————————————————————————————————————————————
-;ForceInitFontsCall	InstallProc	(SE,II,Portable,IIci)
-FORCEINITFONTSCALL	Proc	Export
+ForceInitFontsCall	InstallProc	(SE,II,Portable,IIci)
 		ST		FMExist
 		rts
 		ENDPROC
 		
 
+;——————————————————————————————————————————————————————————————————————————————————————————
+; InitializePartialFonts
+;——————————————————————————————————————————————————————————————————————————————————————————
+DecrementMeasurer	InstallProc	(Plus)
+		IMPORT	JStdTxMeas
+		LEA		JStdTxMeas,A0
+		SUB.L	#$200,(A0)
+		RTS
+
+
+;——————————————————————————————————————————————————————————————————————————————————————————
+; InitializePartialFonts
+;——————————————————————————————————————————————————————————————————————————————————————————
+InstallInitializePartialFonts	InstallProc	(Plus,SE,II,Portable,IIci)
+		SUBQ	#2,SP
+		MOVE.L	#$2800,-(SP)
+		_InitializePartialFonts
+		ADDQ	#2,SP
+		RTS
+
+
 ;——————————————————————————————————————————————————————————————————————————————————————————
 ; Register our selector 'font' 
 ;——————————————————————————————————————————————————————————————————————————————————————————
-;InstallFontGestalt	InstallProc	(Plus,SE,II,Portable,IIci)
-INSTALLFONTGESTALT	Proc	Export
+InstallFontGestalt	InstallProc	(Plus,SE,II,Portable,IIci)
 		IMPORT		FontMgrGestalt
 		MOVE.L		#gestaltFontMgrAttr, D0
-		LEA		FontMgrGestalt, A0
+		LEARESIDENT	FontMgrGestalt, A0
 		_NewGestalt								; Install our function
 ;		BEQ.S		@noError						; error is in D0
 ;		DC.W		$A9FF							; let me know if it failed
diff --git a/Toolbox/FontMgr/Bass_Allocate.a b/Toolbox/FontMgr/Bass_Allocate.a
--- a/Toolbox/FontMgr/Bass_Allocate.a
+++ b/Toolbox/FontMgr/Bass_Allocate.a
@@ -10,7 +10,6 @@
 ;	   <SM3>	  2/4/93	PN		I did a global search and NewTempHandle is only called from
 ;									CTempBuffHand. So I change the name to FontNewTempHandle to
 ;									eliminate confusion with QD call.
-;	   <SM2>	 4/16/92	PN		Change GETSTYLEBUFHAND to upper case
 ;		 <3>	 7/10/91	JSM		Remove obsolete SysVers conditionals.
 ;		 <2>	 3/20/91	CL		B3B, #84919: Fixed NewTempHandle, EndSystem mode reset the state
 ;									from MFTempHandle.  This resulted in a memory leak since we
@@ -244,9 +243,9 @@ DisposeTempBuffer	PROC 	EXPORT			;<18Jun89>	BAL
 ;
 ;
 CtempBufHand		PROC 	EXPORT
-		EXPORT		GETSTYLEBUFHAND
+		EXPORT		GetStyleBufHand
 		MOVE.L	4(SP), d0				; Get size
-GETSTYLEBUFHAND
+GetStyleBufHand
 		MOVE.L	D0, D3					; Save request in reg
 		BSR		FontNewTempHandle			; Try to get it from Multi Temp
 		BNE.S	@returnVal				; Worked so go home
diff --git a/Toolbox/FontMgr/FontFolderExtension.a b/Toolbox/FontMgr/FontFolderExtension.a
--- a/Toolbox/FontMgr/FontFolderExtension.a
+++ b/Toolbox/FontMgr/FontFolderExtension.a
@@ -19,7 +19,6 @@
 ;		<14>	  5/8/92	DTY		#1029253: After opening the fonts, expand the FCB array by the
 ;									number of fonts opened.
 ;		 <1>	 4/16/92	PN		first checked in
-;		<13>	 1/30/92	DTY		Change maxFontFiles to 128.
 ;		<12>	 1/22/92	DTY		For each font file that’s opened, call _ResolveIDConflicts to
 ;									make sure there are no duplicating resource IDs.
 ;		<11>	 12/6/91	DTY		Remove the code that opens font files, and call _AddSuitcase
@@ -50,8 +49,9 @@
 			include		'FileMgrPrivate.a'		; <SM2> CSS
 			include		'LinkedPatchMacros.a'	; <SM2> CSS
 			include		'ResourceMgrPriv.a'
+			include		'Notification.a'
 
-maxFontFiles		equ	128					; Open a maximum of 128 files
+maxFontFiles		equ	129					; Open a maximum of 129 files
 isAlias				equ	15
 resolveSpecialFolderAliases	equ	0			; Bummers.  Not allowed to resolve aliases yet.
 
@@ -176,6 +176,32 @@ stackFrameSize	equ	*
 			cmp.l	d1,d0 					; Is it a font file?
 			bne.s	@fileTypeLoop			; Nope
 
+			cmp.w	#128,d5					; More than 128 fonts opened?
+			blt.s	@notTooMany
+			subq	#4,sp
+			move.w	#-16392,-(sp)
+			_GetString
+			move.l	(sp)+,a1
+
+		WITH NMRec
+			move.l	#NMRecSize,d0
+			_NewPtr	,sys,clear
+			move.w	#nmType,qType(a0)
+			move.l	#-1,nmSound(a0)
+			move.l	a1,nmRefCon(a0)
+			move.l	(a1),a1
+			move.l	a1,nmStr(a0)
+			leaResident	manyFontNotificationResp,a1
+			move.l	a1,nmResp(a0)
+		ENDWITH
+
+			subq	#2,sp
+			_NMInstall
+			addq	#2,sp
+
+			bra.s	@expandFCBArray
+@notTooMany
+
 ;
 ;	Add the file to the resource chain.
 ;
@@ -233,5 +259,22 @@ fileTypeTable
 			dc.b	'ffil', 'tfil', 'FFIL'
 			dc.l	0
 			EndProc
+
+
+manyFontNotificationResp	Proc	Export
+			move.l	(sp)+,d0
+			move.l	(sp)+,a0
+			move.l	d0,-(sp)
+			move.l	NMRec.nmRefCon(a0),-(sp)
+
+			subq	#2,sp
+			_NMRemove
+			addq	#2,sp
+
+			_ReleaseResource
+
+			rts
+
+			EndProc
 			End
 			
\ No newline at end of file
diff --git a/Toolbox/FontMgr/FontMgr.a b/Toolbox/FontMgr/FontMgr.a
--- a/Toolbox/FontMgr/FontMgr.a
+++ b/Toolbox/FontMgr/FontMgr.a
@@ -71,8 +71,6 @@
 ;									the system script font.
 ;		<71>	 1/11/93	DTY		Fix GetFONDForSizeAndStyle to use correct style when styles are
 ;									split across multiple FONDs.
-;	  <SM19>	11/19/92	RB		Set ROMMapInsert to MapTrue just before doing some GetResource
-;									calls so that we look in ROM first.
 ;	  <SM18>	11/12/92	PN		Get rid of ≥ 020 conditionals
 ;	   <SM17>	10/22/92	CSS		Change some short branches to word branches.
 ;		<70>	  9/2/92	DTY		Use records for the synthetic font labels.
@@ -615,6 +613,34 @@
 	 		BLANKS	ON
 			STRING	ASIS
 
+;——————————————————————————————————————————————————————————————————————————————————————————
+;						Needed for Linked Patches, not sure where they were originally
+;——————————————————————————————————————————————————————————————————————————————————————————
+			INCLUDE		'LinkedPatchMacros.a'
+			INCLUDE		'Traps.a'
+
+			CASE		OBJ
+
+			ROMs		II,IIci
+			MakePatch	FontManager,_InitFonts
+			MakePatch	FMSwapFont,_FMSwapFont
+			MakePatch	GetFontName,_GetFName
+			MakePatch	RealFont,_RealFont
+			MakePatch	GetFNum,_GetFNum
+			MakePatch	SetFontLock,_SetFontLock
+			MakePatch	FontMetrics,_FontMetrics
+
+			ROMs		Plus,SE,Portable
+			MakePatch	BWFontManager,_InitFonts
+			MakePatch	BWFMSwapFont,_FMSwapFont
+			MakePatch	BWGetFontName,_GetFName
+			MakePatch	BWRealFont,_RealFont
+			MakePatch	BWGetFNum,_GetFNum
+			MakePatch	BWSetFontLock,_SetFontLock
+			MakePatch	BWSetFScaleDisable,_SetFScaleDisable
+			MakePatch	BWSetFractEnable,_SetFractEnable
+			MakePatch	BWFontMetrics,_FontMetrics
+
 ;——————————————————————————————————————————————————————————————————————————————————————————
 ;						Check Defines…
 ;——————————————————————————————————————————————————————————————————————————————————————————
@@ -773,7 +799,7 @@ BWInitFonts
 			BNE.S	@doneAlloc				; Check for spline ready
 			MOVE.L	#WidTabSize,D0			; size of table
 			_NewHandle ,SYS					; new handle in sysHeap
-			BNE.S	CantAllocMem			; if an error, skip
+			BNE		CantAllocMem			; if an error, skip
 
 			MOVE.L	A0,WidthTabHandle		; remember it
 
@@ -798,6 +824,7 @@ BWInitFonts
 			MOVE.L	A0,JSwapFont			; 
 		ENDIF
 
+		IF	HAS_COLOR THEN
 			MOVEQ	#SyntheticStrikeTable.synEntry,D0			; size of 1 entry version
 			MOVE.L	SynListHandle,D1		; already got it?
 			BLE.S	@createSynList			; if zero or -1, create one
@@ -817,6 +844,7 @@ BWInitFonts
 			TST.B	fmExist
 			BPL.S	@skipRest
 			CLR.B	fmExist
+		ENDIF
 			CLR.L	FOutFontHandle			; may point to non-existent font, so clear
 			CLR.L	LastFOND
 			BSR.S	InValWidths 			; invalidate all of the width tables.
@@ -1192,9 +1220,9 @@ CheckPurged
 			MOVE.L		WidthTabHandle, A1
 			MOVE.L		(A1), A1							; Width table ptr
 			TST.B		WidthIsSpline(A1)					; Get flag stating if spline			<14-jlf>
-			beq.s		@DoNormalPurgeCheck					; do normal stuff if not a spline		<14-jlf>
+			beq			@DoNormalPurgeCheck					; do normal stuff if not a spline		<14-jlf>
 			tst.b		KeepSplineOnDisk(a1)				; should we do the load?				<14-jlf>
-			bne.s		@skipBuildTable						; no, skip it							<14-jlf>
+			bne			@skipBuildTable						; no, skip it							<14-jlf>
 			move.w		WidthStrikeID(a1),d0				; setup sfnt resource id parameter		<14-jlf>
 			jsr			LoadSplineFontResource				; load the spline font resource			<14-jlf>
 			bsr			DerefWidthTab						; get the widthtablepointer in a0		<14-jlf>
@@ -1202,7 +1230,7 @@ CheckPurged
 			move.l		d0,a0								; move splineHandle						<14-jlf>
 			tst.l		(a0)								; was the spline loaded?				<14-jlf>
 			seq			KeepSplineOnDisk(a1)				; no, don't try to load it again.		<14-jlf>
-			bra.s		@skipBuildTable						; Do not build height table if spline	<14-jlf>
+			bra			@skipBuildTable						; Do not build height table if spline	<14-jlf>
 			
 @DoNormalPurgeCheck
 			MOVE.L	A0,-(SP)								; push it
@@ -1220,7 +1248,7 @@ CheckPurged
 FMSwapDone
 			BSR		DerefWidthTab							; get pointer to width table in A0
 			TST.B	WidthIsSpline(A0)						; Test if spline
-			BEQ.S	@skipSpline								; not a spline
+			BEQ		@skipSpline								; not a spline
 			MOVEM.L	A0-A1/D0-D2,-(SP)						; Save regs
 			SUBQ	#4,SP									; make room for result
 			MOVE.L	WidthTabHandle, -(SP)					; 1) Push the Width Table Handle onto the stack
@@ -1652,7 +1680,7 @@ GotFontHandle
 			MOVE.L	WidthTabHandle, A1
 			MOVE.L	(A1), A1				; get Width Table pointer									<14-jlf>
 			TST.B	WidthIsSpline(A1)		; is this a spline width table?								<14-jlf>
-			beq.s	@SkipSplineLoad			; no, do non-spline cases									<14-jlf>
+			beq		@SkipSplineLoad			; no, do non-spline cases									<14-jlf>
 			tst.b	KeepSplineOnDisk(a1)	; should we load the spline?								<14-jlf>
 			bne		NoColors				; no, skip the load											<14-jlf>
 			move.w	WidthStrikeID(a1),d0	; setup sfnt resource id parameter							<14-jlf>
@@ -1735,11 +1763,7 @@ GetPixDepth
 			MOVE.L	thePort(A1),D0
 			BEQ.S	useDefault					; no port after InitGraf until at least InitWindows (and InitFonts in between!)
 			MOVE.L	D0,A0
-; This code used to dig ScrnBase out of the QuickDraw Globals.                          <SM22>
-; This doesn't work so well because Cyclone changes ScrnBase on depth switch            <SM22>
-; without updating the QuickDraw Globals. A "More Correct" fix would be to              <SM22>
-; have the process manager update the QuickDraw Globals of all running processes.       <SM22>
-            MOVE.L  ScrnBase,D0                 ; get pointer to screen base address    <SM22>
+			MOVE.L	screenBits(A1),D0			; get pointer to screen base address
 			TST		portBits+rowBytes(A0)		; IS SRC A PIXMAP?
 			BPL.S	@doBits						; =>NO, IT'S A BITMAP
 			MOVE.L	([portBits+baseAddr,A0]),A0	; GET POINTER TO PORT'S PIXMAP
@@ -2054,7 +2078,6 @@ LookForColor
 			SUBQ	#4,SP					; make space for function result
 			MOVE.L	#'fctb',-(SP)			; pass resource type
 			MOVE	D0,-(SP)				; pass resource ID
-			MOVE.W	#MapTrue,RomMapInsert	; look in ROM first								<SM19> rb
 			_GetResource					; only uses D0,A0
 			MOVE.L	(SP)+,D5				; if it fails, then no color table to pass to MakeScaleTbl
 
@@ -2800,10 +2823,10 @@ AdjustSpace
 			MOVE.L	(A3)+,(A1)+ 			; update numer, denom
 			MOVE.L	(A3),(A1)				; of the scale factors.
 			TST.B	WidthIsSpline(A0)		; Test if spline
-			BEQ.S	@skipFill				; do not do spline things
+			BEQ		@skipFill				; do not do spline things
 			CLR.B	WidthUsedFam(A0)		; Splines never used FOND widths.
 			tst.b	KeepSplineOnDisk(a0)	; should we load the spline?			<14-jlf>
-			bne.s	@fontOkay				; no, skip the load.					<14-jlf>
+			bne		@fontOkay				; no, skip the load.					<14-jlf>
 			move.w	WidthStrikeID(a0),d0	; push the sfnt resource id				<14-jlf>
 			jsr		LoadSplineFontResource	; load the spline resource				<14-jlf>
 			bsr		DerefWidthTab			; get widthpointer in a0				<14-jlf>
@@ -3223,15 +3246,7 @@ checkNeighborhood							; common entry point for system family as well.
 tryNeighborhoodBase
 			CMP		#$4000,D3
 			BLO.S	@mustBeRoman
-;;			AND		#$FE00,D3				; base is neighborhood & ~512
-
-			subq	#6,SP					; <73> 2 for Font2RealScript, 4 for GetScript
-			move.w	D3,-(SP)				; <73> push current font id
-			_Font2RealScript				; <73> convert it to script code
-			move.w	#smScriptSysFond,-(SP)
-			_GetScript						; <73> get system font id for the script
-			move.l	(SP)+,D3				; <73> try the script system font
-
+			AND		#$FE00,D3				; base is neighborhood & ~512
 			RTS
 @mustBeRoman
 			MOVEQ	#3,D3					; hard code to Geneva
@@ -3348,10 +3363,10 @@ LoadSplineFontResource
 			move.l	(sp)+,d0					; <15> Set the condition code properly
 @foundSpline
 			move.l	d0,resourceHandle(a6)		; pop the spline handle
-			beq.s	@Exit						; bail if it was nil
+			beq		@Exit						; bail if it was nil
 			move.l	d0,a0						; grab the resource handle
 			tst.l	(a0)						; is the handle already loaded into memory?
-			bne.s	@Exit						; yes, return immediately
+			bne		@Exit						; yes, return immediately
 			
 ; at this point the empty resource handle is:
 ;
@@ -3365,11 +3380,11 @@ LoadSplineFontResource
 			_SizeRsrc							; get the size of the resource
 			move.l	(sp)+,d0					; pop the resource size
 			cmp.l	#128*1024,d0				; is the spline size greater than 128k?
-			bgt.s	@LoadEmptySplineIntoSystemHeap	; yes, load an empty spline into the system heap
+			bgt		@LoadEmptySplineIntoSystemHeap	; yes, load an empty spline into the system heap
 
 			move.l	resourceHandle(a6),-(sp)	; push empty resource handle
 			_LoadResource						; load the resource into memory
-			bra.s	@Exit						; return
+			bra		@Exit						; return
 
 ; The spline font is bigger than 128K, so don’t load it into memory, but create an empty
 ; handle for it in it’s resource reference entry.  We can probably get rid of the call to
@@ -3468,7 +3483,6 @@ LoadNoROM
 			SUBQ	#4,SP					; <14-jlf>
 			MOVE.L	#'NFNT',-(SP)			; push NFNT
 			MOVE.W	D0,-(SP)
-			MOVE.W	#MapTrue,RomMapInsert	; look in ROM first								<SM19> rb
 			_GetResource
 			MOVE.L	(SP)+,D0				; got it?
 			bz.s	fontOnlyLoad			; if not, look for FONT
@@ -3477,7 +3491,7 @@ LoadNoROM
 			MOVE	#$8000,widthNFNT(A0)	; remember that we found a NFNT
 			MOVE	(SP)+,widthStrikeID(A0)
 			TST.L	D0						; clear z flag					; <3.1-16May89-CEL>
-			BRA.S	weGotIt 				; return z clear, handle in D0.
+			BRA		weGotIt 				; return z clear, handle in D0.
 
 ; we couldn't find the NFNT, so look for a FONT
 
@@ -3603,7 +3617,7 @@ FindSize
 			DBRA	D1,@fSizeLoop			; check them all out
 @trySpline
 			TST		D0						; check if Spline was found
-			BEQ		@cantFind
+			BEQ.S	@cantFind
 @gotSpline
 
 ;
@@ -3631,11 +3645,6 @@ FindSize
 @CheckSplinePreferred
 			movem.l (sp)+, a1/d0-d2				; Restore it all
 
-			MOVE.L	(A2),A0 							; <73> handle->pointer
-			LEA 	FontFamilyRecord.FONDAssoc(A0),A0	; <73> bump past header
-			tst.w	(A0)								; <73> only sfnt is installed?
-			beq.s	@DoRomanLogic						; <73> then use it.
-
 			btst.b	#splinePreferred,HiliteMode	; bit flag set in HiliteMode?
 			bne.s	@DoRomanLogic				; yes, force spline
 ;
@@ -3777,11 +3786,6 @@ GetFONDForSizeAndStyle
 			bra.s	@checkSplinePreferred	; Yes.  See if it’s ok to return a TrueType font.
 			
 @styledSplineEntry
-			cmp.w	d2,d0					; <71> See if style is exactly the same
-			bne.s	@testForStyle			; <71> No.  See if this candidate has the style we want
-			move.l	a4,d4					; <71> This 'FOND' has the style we want
-			bra.s	@gotStyledSpline		; <71>
-@testForStyle
 			and.w	d2,d0					; See if this 'FOND' describes the desired style
 			bnz.s	@savePotentialStyleMatch	; It does indeed.  Prepare to load it in.
 			move.l	d3,d0					; <63> This 'FOND' doesn’t have the desired style.
@@ -3881,13 +3885,6 @@ GetFONDForSizeAndStyle
 ;
 
 @CheckAlternates
-			btst	#splinePreferred,HiliteMode	; <71> See if TrueType fonts are preferred
-			bz.s	@useBitMapAlternates	; <71> No.  Get a bitmapped font
-			tst.l	d4						; <71> See if we have styled spline candidate
-			bnz.s	@tryForSpline			; <71> We do.  Use it.
-			tst.l	d7						; <71> See if we have plain spline candidate
-			bnz.s	@tryForSpline			; <71> We do.  Use it.
-@useBitMapAlternates
 			tst.l	d6						; See if plain variation was found
 			bz.s	@tryForStyledAlternate	; <67> If there is a plain, return it.
 			move.l	d6,a1					; The plain variant was found
@@ -3908,9 +3905,7 @@ GetFONDForSizeAndStyle
 			bz.s	@tryForPlainSpline		; A plain font was desired
 @tryForStyledSpline
 			tst.l	d4						; See if a styled spline was picked up.
-			bz.s	@tryForPlainSpline		; <71> It wasn’t.  Try plain.
-			move.l	d4,a1					; <71> Use styled spline
-			bra.s	@setupForLoad			; <71>
+			bnz.s	@passBackStyledSpline
 @tryForPlainSpline
 			tst.l	d7						; See if a plain TrueType font was picked up.
 			bnz.s	@passBackPlainSpline	; We’ve got a TrueType version.  Go use it.
@@ -4293,9 +4288,6 @@ FindClosest
 			MOVEQ	#0,D1					; no font yet
 			MOVE	#$7FFF,D2 				; closest delta so far
 			
-			tst.w	(A0)					; <73> don’t take sfnt as the closest NFNT
-			beq.s	NxtSizeLoop				; <73> assuming sfnt is the first entry 
-
 Scan4SizeLoop
 			MOVE.W	D5,D0					; get one we want <DLD-12-Sep-85>
 
@@ -4719,7 +4711,6 @@ GetFOND
 			SUBQ	#4,SP
 			MOVE.L	#'FOND',-(SP)			; push type "FOND"
 			MOVE.W	D1,-(SP)				; push the ID
-			MOVE.W	#MapTrue,RomMapInsert	; look in ROM first								<SM19> rb
 			_GetResource					; look for it
 			MOVE.L	(SP)+,D0
 			MOVE.L	D0,A0
@@ -4957,13 +4948,13 @@ BWSetFontLock
 
 			move.l	FOutFontHandle,a0		; get the current font handle				<14-jlf>
 			tst.l	(a0)					; is it purged?								<14-jlf>
-			bne.s	@NoPurgeFont			; no, skip the resource load stuff			<14-jlf>
+			bne		@NoPurgeFont			; no, skip the resource load stuff			<14-jlf>
 			move.l	WidthTabHandle,a0		; get current width table					<14-jlf>
 			move.l	(a0),a0					; get master pointer						<14-jlf>
 			tst.b	WidthIsSpline(a0)		; is this a spline font?					<14-jlf>
-			beq.s	@DoNormalFontLock		; no, do normal stuff						<14-jlf>
+			beq		@DoNormalFontLock		; no, do normal stuff						<14-jlf>
 			tst.b	KeepSplineOnDisk(a0)	; should the spline be loaded into memory?	<14-jlf>
-			bne.s	@doneSFL				; no, bail out of routine					<14-jlf>
+			bne		@doneSFL				; no, bail out of routine					<14-jlf>
 			move.w	WidthStrikeID(a0),d0	; setup sfnt resource id parameter			<14-jlf>
 			jsr		LoadSplineFontResource	; call the load routine						<14-jlf>
 			bsr		DerefWidthTab			; get widthPointer in a0					<14-jlf>
@@ -4971,8 +4962,8 @@ BWSetFontLock
 			tst.l	(a0)					; was the spline loaded into memory?		<14-jlf>
 			exg		d0,a0					; swap the registers back					<14-jlf>
 			seq		KeepSplineOnDisk(a0)	; don't try to load next time if not loaded	<14-jlf>
-			beq.s	@doneSFL				; skip the nopurge if it wasn't loaded		<14-jlf>
-			bra.s	@NoPurgeFont			; make it non-purgeable						<14-jlf>
+			beq		@doneSFL				; skip the nopurge if it wasn't loaded		<14-jlf>
+			bra		@NoPurgeFont			; make it non-purgeable						<14-jlf>
 			
 @DoNormalFontLock
 		
diff --git a/Toolbox/FontMgr/OutlineMetrics.a b/Toolbox/FontMgr/OutlineMetrics.a
--- a/Toolbox/FontMgr/OutlineMetrics.a
+++ b/Toolbox/FontMgr/OutlineMetrics.a
@@ -63,9 +63,7 @@
 ;
 
 
-	IF (&TYPE('hasDoubleByte') = 'UNDEFINED') THEN
-		hasDoubleByte		EQU		1
-	ENDIF
+hasDoubleByte		EQU		1
 	
 		LOAD		'StandardEqu.d'
 		INCLUDE 	'SplineDefines.a'
diff --git a/Toolbox/FontMgr/PartialFont/Source/PartialFontExtensions.c b/Toolbox/FontMgr/PartialFont/Source/PartialFontExtensions.c
--- a/Toolbox/FontMgr/PartialFont/Source/PartialFontExtensions.c
+++ b/Toolbox/FontMgr/PartialFont/Source/PartialFontExtensions.c
@@ -51,7 +51,6 @@
 		 							<2> 3/27/92	DTY	#1024868: Take out calls to assertion routines since they don’t
 													do anything anymore, and the assertion messages are wasting
 													memory.
-		<SM2>	 4/17/92	PN		Change InitZone to InitZoneGlue to do ROM build with Bass fonts
 
 		System 6.1.0 Changes:
 		
@@ -84,7 +83,7 @@
 	#include	"Bass_Cache.h"
 
 //••••• Temporary hack for INitZone
-extern pascal void INITZONEGLUE (GrowZoneProcPtr pgrowZone,short cmoreMasters,void *limitPtr,
+extern pascal void INITZONE (GrowZoneProcPtr pgrowZone,short cmoreMasters,void *limitPtr,
  void *startPtr);
 
 /*	--------------------------------------------------------------------------------------
@@ -353,7 +352,7 @@ pascal OSErr InitializePartialFonts( Size partialFontZoneSize )
 	error = NewZonePtr( &partialFontZone, partialFontZoneSize, SystemZone( ) );
 	if ( error == noErr ) {
 //••••Temporary hack
-			INITZONEGLUE( (GrowZoneProcPtr) PartialFontZoneGrowZoneProcedure, partialFontZoneSize/kPartialFontBytesPerMasterPointer, partialFontZone + partialFontZoneSize, partialFontZone ); //<SM3> <SM4>
+			INITZONE( (GrowZoneProcPtr) PartialFontZoneGrowZoneProcedure, partialFontZoneSize/kPartialFontBytesPerMasterPointer, partialFontZone + partialFontZoneSize, partialFontZone ); //<SM3> <SM4>
 			if ( (error = MemError( )) == noErr ) {
 			
 				error = NewZoneHandle( (Handle*) &fragmentTableCache, (Size) sizeof( FragmentTableCacheStructure ), (THz) partialFontZone );
diff --git a/Toolbox/HelpMgr/BalloonExtensions.a b/Toolbox/HelpMgr/BalloonExtensions.a
--- a/Toolbox/HelpMgr/BalloonExtensions.a
+++ b/Toolbox/HelpMgr/BalloonExtensions.a
@@ -9,8 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	11/19/92	RB		Set ROMMapInsert to MapTrue just before doing some GetResource
-;									calls so that we look in ROM first.
 ;		 <2>	  7/8/92	JSM		Move HelpMgrInstall, Pack14Entry, ptchHMUpdateHelpMenu,
 ;									ptchHMGetHelpGlobal, ptchHMGetBalloons, and ptchHMSetHelpGlobal
 ;									here from Balloonptch28.a.
@@ -145,7 +143,6 @@ BSaveReg		REG		A3/A4
 				subq	#4,sp									; room for package
 				move.l	#'PACK',-(sp)							; we want the package resource
 				move	#14,-(sp)								; of ID = 14
-				MOVE.W	#MapTrue,RomMapInsert					; look in ROM first							<SM4> rb
 				_GetResource
 				move.l	(sp)+,d0								; did we get it?
 				beq.s	done									; no, so exit w/o putting up icon
diff --git a/Toolbox/HelpMgr/BalloonPACK.a b/Toolbox/HelpMgr/BalloonPACK.a
--- a/Toolbox/HelpMgr/BalloonPACK.a
+++ b/Toolbox/HelpMgr/BalloonPACK.a
@@ -13,7 +13,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<SM3>	10/22/92	CSS		Change some branch short instructions to word branches.
 ;		<72>	 5/14/92	KST		#1027497 <JH>: #1025797,#1027497: In '__HMScanHWinResource', we
 ;									ask TSM if the mouse is over a floating window. If it is, then
 ;									TSM will try to locate and open the resource file to load the
@@ -2789,7 +2788,7 @@ workString		ds.w		128							; space for a STR255 work area
 				MOVE.L	origString(A6),A2				; A2-> string beginning (len byte)
 				MOVEQ	#0,D3							; clear some hibits
 				MOVE.B	(A2),D3							; get length
-				BEQ 	@ExitFCS						; exit if original string was zero <SM3> CSS 
+				BEQ.S	@ExitFCS						; exit if original string was zero
 				
 				MOVE.B	#'^',D0							; look for citation caret character
 				LEA		1(A2),A1						; A1 -> string data
diff --git a/Toolbox/HelpMgr/BalloonPACK.p b/Toolbox/HelpMgr/BalloonPACK.p
--- a/Toolbox/HelpMgr/BalloonPACK.p
+++ b/Toolbox/HelpMgr/BalloonPACK.p
@@ -9,8 +9,6 @@
 
 	Change History (most recent first):
 
-	   <SM3>	 2/17/93	kc		Allocate pictures in the System Heap because they persist longer
-									than the application heap.
 		<81>	  6/2/92	KST		#1030643 <JH>: We have only 1 default message for the floating
 									window instead of two (floating windows are all active).
 		<80>	 5/14/92	KST		#1027497 <JH>: #1025797,#1027497: In '__HMGetWindowPartCode',
@@ -2185,7 +2183,6 @@ FUNCTION  __HMCalculateBalloon(	aHelpMsg: HMMessageRecord;
 		tix				: LongInt;
 		sloppy			: BOOLEAN;
 		hasColorQD		: BOOLEAN;
-		oldZone			: THz;				{ <SM2> }
 			
 	BEGIN
 		__HMCalculateBalloon	:= hmBalloonAborted;		{ make default case aborted }
@@ -2326,15 +2323,10 @@ FUNCTION  __HMCalculateBalloon(	aHelpMsg: HMMessageRecord;
 												inPort	:= @picPort;
 											end;
 											
-										oldZone := GetZone;		{ get the current heap zone }	{ <SM2> }										
-										SetZone(SystemZone);	{ point at the system heap } 	{ <SM2> }
-										          												{ <SM2> }
 										pic := OpenPicture(visibleRect);
 										TEUpdate(visibleRect,aTE);
 										ClosePicture;
 
-										SetZone(oldZone);										{ <SM2> }
-																								{ <SM2> }
 										with aTE^^ do
 											inPort := tPort;
 									end;
@@ -2343,15 +2335,9 @@ FUNCTION  __HMCalculateBalloon(	aHelpMsg: HMMessageRecord;
 						otherwise
 							if aTE<>NIL then
 								begin
-									oldZone := GetZone;		{ get the current heap zone }		{ <SM2> }										
-									SetZone(SystemZone);	{ point at the system heap } 		{ <SM2> }
-																								{ <SM2> }
 									pic := OpenPicture(visibleRect);
 									TEUpdate(visibleRect,aTE);
 									ClosePicture;
-																								{ <SM2> }
-									SetZone(oldZone);											{ <SM2> }
-																								{ <SM2> }
 								end;
 					end;
 
diff --git a/Toolbox/IconUtils/IconUtils.a b/Toolbox/IconUtils/IconUtils.a
--- a/Toolbox/IconUtils/IconUtils.a
+++ b/Toolbox/IconUtils/IconUtils.a
@@ -10,12 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	  6/3/93	PN		In routines GetIconCacheData and SetIconCacheData the input
-;									parameters are 8 bytes. In returning from the routines, 6 was
-;									added to stack pointer and left 2 bytes on the stack. Correction
-;									is made by adding 8 to stack pointer.
-;	   <SM4>	11/19/92	RB		Set ROMMapInsert to MapTrue just before doing some GetResource
-;									calls so that we look in ROM first.
 ;		<28>	  7/1/92	DC		#1032893 <csd>: Replaced the Psychotic Farmer fix to the listed
 ;									bug with the CubeE fix which is more robust and correct and
 ;									makes the world safe for Tsunami.
@@ -159,7 +153,6 @@ FromResource	PROC	EXPORT
 			LEA		typeTable, A1		;	get the table of resTypes
 			MOVE.L	$00(A1,D0.W), -(SP)	;	push the icon type
 			MOVE.W	D1, -(SP)			;	push the icon id
-			MOVE.W	#MAPTRUE,ROMMAPINSERT	; look in ROM first							<SM4> rb
 			_GetResource				;	call GetResource
 			MOVE.L	(A7)+, D0			;	pop the handle into D0 for return
 			RTS							;	return
@@ -531,7 +524,7 @@ GETCODE	MOVEA.L	THEDATA(SP), A1			;	get the address to return data in
 		MOVE.L	(A0), (A1)				;	return the data
 EXITOK	MOVEQ	#noErr, D0				;	record no error.
 EXIT	MOVEA.L	(SP)+, A0				;	Pop return address into A0
-		ADDQ.L	#8, SP					;	Point stack at return value <PN>
+		ADDQ.L	#6, SP					;	Point stack at return value
 		MOVE.W	D0, (SP)				;	put return value on the stack
 		JMP		(A0)					;	return
 		
@@ -693,7 +686,6 @@ FromResource	PROC	EXPORT
 			LEA		typeTable, A1		;	get the table of resTypes
 			MOVE.L	$00(A1,D0.W), -(SP)	;	push the icon type
 			MOVE.W	D1, -(SP)			;	push the icon id
-			MOVE.W	#MAPTRUE,ROMMAPINSERT	; look in ROM first								<SM4> rb
 			_GetResource				;	call GetResource
 			MOVE.L	(A7)+, D0			;	pop the handle into D0 for return
 			RTS							;	return
@@ -1065,7 +1057,7 @@ GETCODE	MOVEA.L	THEDATA(SP), A1			;	get the address to return data in
 		MOVE.L	(A0), (A1)				;	return the data
 EXITOK	MOVEQ	#noErr, D0				;	record no error.
 EXIT	MOVEA.L	(SP)+, A0				;	Pop return address into A0
-		ADDQ.L	#8, SP					;	Point stack at return value <PN>
+		ADDQ.L	#6, SP					;	Point stack at return value
 		MOVE.W	D0, (SP)				;	put return value on the stack
 		JMP		(A0)					;	return
 		
diff --git a/Toolbox/ListMgr/ListMgrPACK.a b/Toolbox/ListMgr/ListMgrPACK.a
--- a/Toolbox/ListMgr/ListMgrPACK.a
+++ b/Toolbox/ListMgr/ListMgrPACK.a
@@ -11,30 +11,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM7>	  9/9/93	SAM		Changed ShiftDown to not assume the PtInRect will leave
-;									thePoint.v in D1 (good lord!).
-;	   <SM6>	 8/16/93	fau		Moved <LW3,4,5> to happen in the GetTheListProc routine, instead
-;									of where they were.  This is where the check should be
-;									performed.  This was exposed by a PageMaker bug, after Ludwig
-;									shipped.
-;	   <SM5>	 6/14/93	kc		Roll in Ludwig.
-;	   <LW5>	  5/3/93	chp		Flush the caches for LDEF handles smaller than 32 bytes. It used
-;									to be 16 bytes, but a 22-byte, unflushed, fake defproc has been
-;									discovered in Software Ventures Microphone II and Microphone
-;									Pro. (RADAR #1082386)
-;	   <LW4>	  3/8/93	fau		Made the compare in previous checkin be 16 bytes, instead of 12,
-;									and unsigned.
-;	   <LW3>	  3/6/93	fau		Fixed bug 1070072.  Essentially, a slimy developer was using a
-;									fake LDEF to stuff their own code and NOT flushing the cache
-;									afterwards.  They relied on the HLOCK in the initlist routine to
-;									flush it for them.  We "fixed" them by checking the size of the
-;									LDEF handle to see if it's less than 12 bytes.  If so, we will
-;									flush the cache for them.  This penalizes developers who use
-;									this method and do flush the cache.  All for compatibility.
-;	   <SM4>	 1/27/93	PN		Add emStartTicks extended memory global to use in ListMgrPack to
-;									replace the 'startTicks'.
-;		 <3>	11/11/92	GMA		Set RomMapInsert to mapTrue before getting LDEF resources. fixes
-;									bug # 1052658.
 ;	   <SM2>	 11/5/92	SWC		Changed PackMacs.a->Packages.a.
 ;		<13>	  3/4/91	dba		dty: get rid of SysVers conditionals
 ;		<12>	 1/14/91	dba		(stb) Restore the use of hilite value of 255 when there is no
@@ -722,11 +698,11 @@ clickWait
 			MOVE.L		(SP)+, D1				; Copy it into D1.
 			MOVE.L		D1, 10(SP)				; And put it on the stack for ScrollDelay.
 
-			move.l		ExpandMem,A0						; A0 -> ExpandedMem	 <SM4>
-			move.l		ExpandMemRec.emStartTicks(A0),D0	; See if we need to set this. <SM4>
+			LEA			startTicks,A0
+			MOVE.L		(A0),D0					; See if we need to set this.
 			BNE.S		@startTicksOK			; Skip if not.
 			MOVE.L		D1, D0					; Use TickCount value.
-			MOVE.L		D0,ExpandMemRec.emStartTicks(A0)	; Put it in startTicks. <SM4>
+			MOVE.L		D0,(A0)					; Put it in startTicks.
 
 @startTicksOK
 			MOVE.L		D0,14(SP)				; copy startTicks to stack for ScrollDelay.
@@ -739,8 +715,8 @@ clickWait
 			BRA.S		@doneAutoScroll
 
 @noAutoScroll
-			move.l	ExpandMem,A0						; A0 -> ExpandedMem	 <SM4>
-			move.l	#0,ExpandMemRec.emStartTicks(A0)	; Clear out startTicks we're not scrolling anymore <SM4>
+			LEA			startTicks,A0
+			CLR.L		(A0)					; Clear out startTicks we're not scrolling anymore
 
 @doneAutoScroll
 
@@ -1013,8 +989,8 @@ clickCont
 			SUBQ.L		#4, SP
 			_TickCount							; Get a time stamp.
 		
-			move.l	ExpandMem,A0						; A0 -> ExpandedMem	 <SM4>
-			move.l	(SP)+,ExpandMemRec.emStartTicks(A0)	; Put it in startTicks. <SM4>
+			LEA			startTicks,A0
+			MOVE.L		(SP)+,(A0)				; Put it in startTicks.
 
 			SUBQ		#2,SP
 			MOVE.L		D7,-(SP)				; pass ctl Handle
@@ -1023,8 +999,8 @@ clickCont
 			_TrackControl
 			ADDQ		#2,SP
 clickExit
-			move.l	ExpandMem,A0						; A0 -> ExpandedMem	 <SM4>
-			move.l	#0,ExpandMemRec.emStartTicks(A0)	; Clear out startTicks <SM4>
+			LEA			startTicks,A0
+			CLR.L		(A0)					; Clear out startTick
 
 			ADDQ		#8,SP					; strip off the rect
 Std10Exit
@@ -1134,7 +1110,7 @@ ShiftDown
 @3
 			MOVE.B		D0,-(SP)				; only on if in rect and turn on
 			MOVE.W		D3,-(SP)				; push the cell again
-			MOVE.W		D5,-(SP)				; push point.v (dont assume PtInRect will leave it in D1! SHeesh!)	<SM7> SAM
+			MOVE.W		D1,-(SP)				; push point.v
 			MOVE.L		A4,-(SP)				; and the handle
 			_LSetSelect 						; and select/deselect the cell
 @12
@@ -1152,6 +1128,8 @@ ShiftDown
 			RTS
 
 
+startTicks	DC.L		0
+
 ;-------------------------------------------------------------------------------
 ;			PROCEDURE ClickTrack( ctl: ControlHandle; part: INTEGER );
 ;									10					 8
@@ -1209,8 +1187,7 @@ ClickTrack
 @2
 
 			SUBQ.L		#2, SP					; Make room for ScrollDelay return
-			move.l		ExpandMem,A0						; A0 -> ExpandedMem	 <SM4>
-			move.l		ExpandMemRec.emStartTicks(A0),-(SP)	; startTicks for ScrollDelay <SM4>
+			MOVE.L		startTicks,-(SP)		; startTicks for ScrollDelay
 			SUBQ.L		#4, SP					; Reserve space for actionTicks
 			MOVE.W		D0, -(SP)				; itemsVisible for ScrollDelay
 
@@ -1351,21 +1328,7 @@ DoDrExit
 GetTheListProc
 			MOVE.L		ListDefHandle(A3),D0	; get the handle
 			BEQ.S		@done					; => didn’t get one
-
-; Some programmers are pretty slimy and load an LDEF that is empty.  They then					<LW3> fau
-; stuff some code into it.  However, since HLOCK does not flush the cache anymore,				<LW3> fau
-; the code that they stuff into it might not get written back to memory.  To solve this,		<LW3> fau
-; we check here whether the LDEF resource size is less than, say, 32 bytes.  If so, we			<LW5> chp
-; assume that they have already loaded the LDEF and modified it, so we flush the cache			<LW3> fau
-; for them.
-
-			MOVE.L		ListDefHandle(A3),A0	; get the handle								<LW3> fau
-			_GetHandleSize						; How big is our LDEF Handle					<LW3> fau
-			cmp.l		#32,D0					; Is it "small"									<LW5> chp
-			bhi.s		@RealLDEF				; no, don't flush the cache						<LW3> fau
-			jsr			([jCacheFlush])			; else, flush the caches.						<LW3> fau
-@RealLDEF										;												<LW3> fau
-			MOVE.L		ListDefHandle(A3),A0	; get the handle								<LW3> fau
+			MOVE.L		D0,A0
 			MOVE.L		A0,-(SP)				; and load the defProc
 			_LoadResource
 			MOVE.L		(A0),D0					; Is the handle still empty?	<S412	29Feb88>
@@ -1757,8 +1720,6 @@ ListNew 										; don’t use StdEntry because no handles yet
 
 ; initialize the list defProc handle
 
-			MOVE.W		#MapTrue, RomMapInsert	; insert ROM map							<SM3>
-
 			MOVE.W		NLProc(A6),D3			; get the defProc ID
 
 			SUBQ		#4,SP					; make room for function result
diff --git a/Toolbox/ListMgr/TextLDEF.a b/Toolbox/ListMgr/TextLDEF.a
--- a/Toolbox/ListMgr/TextLDEF.a
+++ b/Toolbox/ListMgr/TextLDEF.a
@@ -21,7 +21,6 @@
 ;	Change History (most recent first):
 ;
 ;	   <SM4>	 11/5/92	SWC		Changed PackMacs.a->Packages.a.
-;		<SM3>	10/14/92	CSS		Change some branch short instructions to word branches.
 ;		<11>	 2/26/92	DTY		#1018596: When calculating the pen position to start drawing the
 ;									text for a cell, take teSysJust into account for right-left
 ;									systems. If teSysJust is non zero, compute the pen position from
@@ -209,7 +208,7 @@ ListDraw
 				MOVE.W		D3,-(SP)			; length of text
 				_TextWidth
 				CMP.W		(SP),D7				; will string fit? <11> Leave width on stack
-				BGE 		@noTruncate			; yes, no need to truncate <SM3> CSS 
+				BGE.S 		@noTruncate			; yes, no need to truncate
 
 				addq		#2,sp				; <11> Width isn’t needed til after truncation.  Lose it.
 				
diff --git a/Toolbox/MenuMgr/InvalMenuBarPatch.a b/Toolbox/MenuMgr/InvalMenuBarPatch.a
--- a/Toolbox/MenuMgr/InvalMenuBarPatch.a
+++ b/Toolbox/MenuMgr/InvalMenuBarPatch.a
@@ -38,6 +38,18 @@
 		include	'MenuMgrPriv.a'
 
 
+;————————————————————————————————————————————————————————————————————————————————————————————————————
+; InvalMenuBar
+
+; Set the low memory bit
+
+InvalMenuBar PatchProc _InvalMenuBar,(Plus,SE,II,Portable,IIci)
+
+		bset	#MenuBarInvalidBit,MenuBarInvalidByte		; set the invalid bit
+		rts
+
+				EndProc
+
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 ; DrawMenuBar clear MenuBarInvalidBit and MenuBarGlobalInvalidBit
 ;
@@ -77,4 +89,44 @@ DrawMenuBarIfInvalidOnHiliteMenu PatchProc _HiliteMenu,(Plus,SE,II,Portable,IIci
 
 				EndProc
 
+;————————————————————————————————————————————————————————————————————————————————————————————————————
+; ValidateMenuBar is the routine that draws the menu bar only if necessary (local or global dirty bit set)
+;
+; Note that the Process Mgr will not let the _DrawMenuBar through if we’re not the frontmost process.
+;
+; For the local dirty bit, we don’t care, since we’ll get redrawn anyway when we come to the front. This
+; means we can clear it here to eliminate multiple calls to _DrawMenuBar that won’t do anything.
+;
+; However, we want to only test (not clear) the global dirty bit here, which is set by DrawMBARString, since
+; we want to make sure the menu bar gets redrawn eventually no matter which app is at the front.
+;
+; To avoid problems where apps patch any of DrawMenuBar, HiliteMenu, MenuSelect (i.e., the routines
+; herein that utilize ValidateMenuBar) and recurse forever trying to validate the menu bar, we
+; use a semaphore.  (THINK Pascal 3.0 was our orignal culprit.)  Note the InstallProc below to
+; initialize the semaphore to zero (meaning we are not in ValidateMenuBar).
+
+InitValidateMenuBarSemaphore	InstallProc	(Plus,SE,II,Portable,IIci)		; <7>
+
+		bclr	#ValidateMenuBarSemaphoreBit,ValidateMenuBarSemaphoreByte	; clear semaphore at startup
+		rts
+
+				EndProc
+
+ValidateMenuBar	Proc	EXPORT
+
+		bset	#ValidateMenuBarSemaphoreBit,ValidateMenuBarSemaphoreByte	; Check and set semaphore		<7>
+		bnz.s	@dontRecurse												; If set, then do nothing.		<7>
+		bclr	#MenuBarInvalidBit,MenuBarInvalidByte						; clear the local invalid bit
+		bnz.s	@dirty														; draw menu bar if set			<6>
+		btst	#MenuBarGlobalInvalidBit,MenuBarGlobalInvalidByte			; check the global invalid bit	<6>
+		bz.s	@notDirty													; exit if not set				<6>
+@dirty
+		_DrawMenuBar
+@notDirty
+		bclr	#ValidateMenuBarSemaphoreBit,ValidateMenuBarSemaphoreByte	; Clear semaphore at exit		<7>
+@dontRecurse
+		rts
+
+				EndProc
+
 				end
diff --git a/Toolbox/MenuMgr/MenuMgr.a b/Toolbox/MenuMgr/MenuMgr.a
--- a/Toolbox/MenuMgr/MenuMgr.a
+++ b/Toolbox/MenuMgr/MenuMgr.a
@@ -481,10 +481,6 @@ CreateMenuList
 
 				clr		theMenu					; clear lo mem so no hilited menu			<FJL C222>
 
-				move.l	a1, MenuCInfo			; store the color table too					<FJL C408>
-				IMPORT	GetMBColors
-				bsr		GetMBColors				; get menubar color info from the system	<FJL C408>
-
 				MOVEQ	#$0C,D0					;only use 2 bits worth
 				AND.B	SPMisc2,D0				;get pRam flags
 				LSR		#2,D0					;get menuFlash in the low bits
@@ -506,17 +502,9 @@ CreateMenuList
 
 IMDone
 
-				RTS								; <SM13> this was mistakenly deleted at some point
-
 ; InitMList alloc’s a menuList with no menus and no hierarchical menus					<FJL C222>
 				ENTRY	InitMList
 InitMList
-				moveq	#mctEntrySize, d0		; allocate one record in the color tbl	<FJL C408>
-				_NewHandle						;										<FJL C408>
-				move.l	(a0), a1				; dereference
-				move	#mctLastIDIndic, mctID(a1)	; store -99 as ID ==> last entry	<FJL C408>
-				move.l	a0, -(SP)				; store it on the stack temporarily		<FJL C408>
-
 				moveq	#InitMListSize, d0		; get size of menuList d.s.
 				_NewHandle	CLEAR				; alloc it
 				move.l	(a0), a1				; dereference the handle
@@ -524,78 +512,25 @@ InitMList
 												;set up the menu header
 				move.w	#mbMenu1Loc, lastRight(a1)	; set lastRight to ten (decimal)
 
-				move.l	(SP)+, a1				; get the color tbl handle in a1		<FJL C408>
-
 				rts
 				ENDPROC
 
 
-GetMBColors		PROC	ENTRY
-;-----------------------------------------------
-;	Utility -- GetMBColors
-;-----------------------------------------------
-; See if there is a menubar color table entry.  It will automatically look for one in	<FJL C408>
-; the applications resfile then in the system res file.									<FJL C408>
-;
-				move.b	#1, -(SP)			; force Resource Load to true
-				_SetResLoad
-
-				subq	#4, SP				; make room for the result
-				move.l	#'mctb', -(SP)		; push resource type
-				clr.w	-(SP)				; push menuID 0 = menu bar
-				_GetResource				; get the resource
-				move.l	(SP)+, a0			; get the handle in a0
-				move.l	a0, d0				; set z-flag
-				beq.s	@1					; handle is nil, so no color table
-
-				_HGetState					; get state of resource
-				move.b	d0, -(SP)			; store them on the stack
-				move.l	a0, -(SP)			; store handle on stack too
-				_HLock						; lock the handle down temporarily
-
-				move.l	(a0), a0			; get ptr to resource
-				move	(a0)+, -(SP)		; push number of table entries
-				move.l	a0, -(SP)			; push base address of table
-				_SetMCEntries				; call trap
-
-				move.l	(SP)+, a0			; get handle
-				move.b	(SP)+, d0			; and previous state
-				_HSetState					; return handle to previous state
-
-@1				rts
-				ENDPROC
-
 CLEARMENUBAR	PROC	EXPORT
 ;
 ; PROCEDURE ClearMenuBar -- clear the menuBar/menuList data structure
 ;
 
-;•HMClearMenuBarPatch roll in from BalloonPatch28.a
-			IMPORT	ptchHMGetBalloons
-			JSR		ptchHMGetBalloons					; what is the state of What Is? mode?
-			BEQ.S	@BalloonsOff						; EQ means no, so, let's not do anything.
-			SUBQ	#2,SP								; remove any balloons that might have been up
-			_HMRemoveBalloon							; do the remove
-			TST.W	(SP)+								; toss result
-
-@BalloonsOff	
 				IMPORT	GetA0List
 				BSR		GetA0List				; check for purged list			<EHB 11-Apr-85>
 
 				MOVE.L	MENULIST,A0				; get handle to menuList
 				_DisposHandle					; dispose of the handle			<FJL C222>
 
-				move.l	MenuCInfo, a0			; get handle to color tbl			<FJL C408>
-				_DisposHandle					; and toss it						<FJL C408>
-
 				IMPORT	InitMList
 				bsr		InitMList				; init a new one				<FJL C222>
 				move.l	a0, menuList			; and store it					<FJL C222>
 
-				move.l	a1, MenuCInfo			; and store it too				<FJL C408>
-				IMPORT	GetMBColors
-				bsr		GetMBColors				; get menubar color info from the system	<FJL C408>
-
 				CLR.W	THEMENU					; no menu is hilited
 
 				RTS
@@ -693,10 +628,6 @@ DELETEMENU		PROC	EXPORT
 				_HiliteMenu						; Unhighlight it							<PMAB568	07Sep88	EMT>
 @NotHilited										;											<PMAB568	07Sep88	EMT>
 
-				move	4(SP), -(SP)			; push the menuID					<FJL C408>
-				move	#mctAllItems, -(SP)		; push flag meaning all items		<FJL C408>
-				_DelMCEntries					; call delete routine				<FJL C408>
-
 				moveq	#0, d1					; clear d1 for GetHIndex			<FJL C222>
 				MOVE.W	4(SP),D1				; get the menuID
 				IMPORT	GetHIndex
@@ -851,104 +782,6 @@ INSERTMENU		PROC	EXPORT
 ;	If beforeID = -1 then insert menu at front of HMenuList						<FJL C222>
 ;	Used < 0 as the criteria for inserting in HMenus, changed to = -1			<FJL 8May87>
 
-;  Roll in PatchInsertMenu in SystemMenuPatch.a
-; When this patch sees a system menu (-16385 thru -32768), it adds it to the system menu bar.
-; If the system menu bar doen't exist, this patch creates it.
-; If the menu is not a system menu, ensure that the beforeID is modified so that the
-; menu is inserted before the system menu partition.
-				IMPORT	FindFirstSystemMenu6BO
-InsertStack		RECORD	{base},DECR
-	ParamBegin:	EQU		*			; start parameters after this point
-menuHdl			DS.L	1
-beforeID		DS.W	1
-	ParamSize:	EQU		ParamBegin-*
-retAddr			DS.L	1
-base			DS.W	0
-	LocalSize:	EQU		*
-				ENDR
-
-				WITH	InsertStack
-				CMP.W	#$FFFF, beforeID(SP)				; beforeID = -1 ==> H Menu
-				beq		OldInsertMenu
-
-; If a system menu is being inserted, put it into the System Menu Bar
-
-				MOVE.L	menuHdl(SP), A0						; Get the MenuHandle
-				MOVE.L	(A0), A0							; dereference
-				SUBQ.L	#4,SP								; Make Room for result & VAR
-				MOVE.W	menuID(A0),-(SP)					; Push the menuID
-				PEA		4(SP)								; Point to VAR
-				_IsSystemMenu								; Do it the standard way
-				ADDQ.L	#2,SP								; Eat the result
-				TST.B	(SP)+								; Is it a system menu?
-				BNE.S	@DoSystemMenu						; EQ means it is a system menu
-
-; Menu for main list, be sure it is inserted before all the system menus
-				BSR		FindFirstSystemMenu6BO				; Find the system menu partition
-				beq		OldInsertMenu										; Do old stuff if no system menus
-				MOVE.W	D0, D1								; Save off 6BO of 1st system menu
-				MOVE.W	beforeID(SP), D0					; Get the beforeID
-				BEQ.S	@forceBeforeSys						; branch if zero
-				BSR		Find6BOFromID						; Find its offset
-				BEQ.S	@forceBeforeSys						; branch if the beforeID not in list
-				CMP.W	D1, D0								; Is it after the system partition?
-				ble		OldInsertMenu										; No, do as caller wanted
-				MOVE.W	D0, D1								; It is after the system partition
-
-@forceBeforeSys	; the beforeID must be changed to before the 1st system menu
-				MOVE.L	MenuList, A0						; get the menulist
-				MOVE.L	(A0), A0							; deref
-				MOVE.L	menuOH(A0,D1.W), A0					; get the menuhandle to insert before
-				MOVE.L	(A0), A0							; deref
-				MOVE.W	menuID(A0), beforeID(SP)			; Make beforeID be 1st system menu
-				bra		OldInsertMenu										; Now go do it
-
-@DoSystemMenu
-; If menuID already exists in system menulist, we're done!
-				MOVE.L	MenuList, A1						; Save Menulist
-				MOVE.L	SystemMenuList, MenuList			; Store system as menulist
-				JSR		Find6BOFromID						; Is this menuID already in the list?
-				MOVE.L	A1, MenuList						; Restore Menulist
-				TST.W	D0									; Was the menuID found?
-				BNE.S	@Done								; Don't double insert it, done.
-
-; Swap the two menu lists so this menu inserts into the system menu
-				MOVE.W	beforeID(SP), D0					; Get the beforeID
-				BEQ.S	@AddAtEnd							; Yes, branch
-				MOVE.L	MenuList, A1						; Save Menulist
-				MOVE.L	SystemMenuList, MenuList			; Store system as menulist
-				JSR		Find6BOFromID						; Look up the beforeID
-				MOVE.L	A1, MenuList						; Restore Menulist
-				TST.W	D0									; Was the menuID found?
-				BNE.S	@DoTheAdd
-@AddAtEnd
-				MOVE.L	SystemMenuList, A0					; Get system menulist
-				MOVE.L	(A0), A0							; deref
-				MOVE.W	lastMenu(A0), D0					; Get last menu
-				ADDQ.W	#6, D0								; Insert "before" the end
-@DoTheAdd
-				SUBQ.L	#4, SP								; Make room for result
-				MOVE.L	SystemMenuList, -(SP)				; handle
-				MOVE.W	D0, -(SP)							; Move the offset
-				CLR.W	-(SP)								; as a long with high cleared
-				CLR.L	-(SP)								; ptr1 = 0
-				CLR.L	-(SP)								; len1 = 0
-				PEA		6+20(SP)							; ptr2 = menuhandle parameter
-				MOVEQ.L	#6, D0
-				MOVE.L	D0, -(SP)							; len2 = 6
-				_Munger										; Munge away!  Left coord will be junk.
-				ADDQ.L	#4, SP								; Dump result
-				; Remember to update the lastMenu field
-				MOVE.L	SystemMenuList, A0					; Get system menulist
-				MOVE.L	(A0), A0							; handle -> ptr
-				ADDQ.W	#6, lastMenu(A0)					; Bump the count
-@Done
-				MOVE.L	(SP)+, A0							; Get the return address
-				ADDQ.L	#ParamSize, SP						; Cut back the parameters
-				JMP		(A0)
-
-OldInsertMenu
-
 				movem.l	d3/a3-a4,-(SP)			; save working registers
 
 				cmp.w	#$FFFF, 16(SP)			; beforeID = -1 ==> H Menu		<FJL 8May87>
@@ -963,7 +796,7 @@ OldInsertMenu
 				MOVE	menuID(a0), d1			; get menuId of menu to be installed
 				IMPORT	GetIndex
 				BSR		GETINDEX				; is it already in the list?
-				BNE		@DONEINSERT				; don’t insert same one twice
+				BNE.S	@DONEINSERT				; don’t insert same one twice
 
 				move.w	16(SP),d1				; get beforeID
 				BSR		GETINDEX				; get index into menuList of beforeID menu
@@ -1062,25 +895,6 @@ DRAWMENUBAR		PROC	EXPORT
 ;	Call HiliteMenu around DrawMenuBar so that don’t have dangling bits behind all around <FJL PMAB255>
 ; 	Clear the low memory bits whenever we draw the menu bar.
 
-; <SM17> CSS
-;Roll in SynchKeyboardMenuState —	Make sure the keyboard menu state corresponds to the
-;							application’s desired setting (enable/disable) in the
-;							application-specific global flag, scriptDisableKybds
-; from MenuMgrPatch.a, this patch says that it shouldn't be rolled in because the
-; it should be in the process manager.  Well, for 7.1 it is not in the process manager,
-; so I am rolling it in anyways.
-				moveq	#smKeySynchKbdMenuState,d0	; Set up the KeyScript verb
-				move.w	d0,-(sp)					; to just synchronize the keyboard menu
-				_KeyScript							; Do it.
-;end Roll in SyncKeyboardMenuState
-
-;Roll in ValidateMenuBarWhenDrawing
-				bclr	#MenuBarInvalidBit,MenuBarInvalidByte					; clear the local invalid bit
-				bclr	#MenuBarGlobalInvalidBit,MenuBarGlobalInvalidByte		; clear the global invalid bit	<6> 
-;Roll in PatchMDDrawMenuBar from ModialDiaglogMenuPatches.a	 <PN> <SM5>			
-				import PushMenuState,PopMenuState     ;<PN> <SM5>
-				jsr		PushMenuState			; Potentially save off the menu state <PN> <SM5>
- 
 				Move.W	TheMenu, -(SP)			; save off currently hilited menu		<FJL PMAB255>
 				Clr.W	-(SP)					; call HiliteMenu(0)
 				_HiliteMenu
@@ -1093,7 +907,7 @@ DRAWMENUBAR		PROC	EXPORT
 				BSR		CallMBarProc			; execute the defproc					<DAF 20Aug86>
 
 				_HiliteMenu						; TheMenu is already on the stack.		<FJL PMAB255>
-				jsr		PopMenuState			; Restore the menu state if it was saved <PN> <SM5>
+				;jsr		PopMenuState			; Restore the menu state if it was saved <PN> <SM5>
 
 				RTS
 				ENDPROC
@@ -1174,23 +988,6 @@ HILITEMENU		PROC	EXPORT
 ; if MBarHeight <= 3 then don’t hilite.  Otherwise MBarProc will save off a VERY LARGE
 ; handle for the bits behind the menu title.
  
-; HiliteMenu draw menu bar if invalid
-; ROLL IN ValidateMenuBarWhenDrawing
-				IMPORT	ValidateMenuBar
-				jsr		ValidateMenuBar
-		
-; Roll in PatchMDHiliteMenu
-; The saves menus state, calls old HiliteMenu, then restores state
-				import PushMenuState,PopMenuState ;<SM5> <PN>
-
-				parametersStackFrame
-menuID			ds.w		1					; the menuID <SM5> <PN>
-				endStackFrame
-
-				linkSave
-				jsr		PushMenuState			; Potentially save off the menu state <SM5> <PN>
-				move.w	menuID(a6),-(sp)		; Push the parameter <SM5> <PN>
-
 				Cmpi.W	#3, MBarHeight			; is height > 3					<PMAB233 FJL>
 				Bgt.S	@HeightOK				; yes -> ok
 				Bra.S	HLNone					; no	-> nope, skip entirely
@@ -1199,7 +996,7 @@ menuID			ds.w		1					; the menuID <SM5> <PN>
 
 @HeightOK		MOVE.W	theMenu,D1				; get the currently hilited menu
 				BEQ.S	HLOn					; if theMenu is 0, then don’t unhilite	<DAF 20Aug86>
-				CMP.W	(SP),D1					; is this the currently hilited menu	<DAF 20Aug86>
+				CMP.W	4(SP),D1				; is this the currently hilited menu	<DAF 20Aug86>
 				BEQ.S	HLDone					; already hilited, so skip				<DAF 20Aug86>
 
 				IMPORT	GetIndex
@@ -1215,7 +1012,7 @@ menuID			ds.w		1					; the menuID <SM5> <PN>
 ; now, turn on the selected menu
 
 HLOn
-				MOVE.W	(SP),D1					; get menuID of new selection			<DAF 20Aug86>
+				MOVE.W	4(SP),D1				; get menuID of new selection			<DAF 20Aug86>
 				BSR		GetIndex				; convert to menuIndex
 				BEQ.S	HLNone					; if zero, invalid menuID				<FJL C175>
 				SWAP	D0						; save menuIndex in hi half
@@ -1225,17 +1022,15 @@ HLOn
 				MOVEQ	#5,D0					; set up the hilite message				<DAF 20Aug86>
 				BSR		CallMBarProc			; execute the defproc					<DAF 20Aug86>
 HLDone				
+				MOVE.L	(SP)+,A0
 				MOVE.W	(SP)+,theMenu			; update theMenu					<FJL C175>
-				bra		Done
-; don’t store the menuID if we couldn’t find the index.  No index means the			<FJL C175>
-; menuID doesn’t exist on the menu bar, and storing a non-existent menuID			<FJL C175>
-; in theMenu global causes the next HiliteMenu(0) to flip the bar (ugh-ly).			<FJL C175>
+				JMP		(A0)
 HLNone						; get the return address			<FJL C175>
+				move.l	(sp)+,a0
 				addq.l	#2, SP					; throw away the parameter			<FJL C175>
 				clr.w	theMenu					; update theMenu					<FJL C175>
 Done
-				jsr		PopMenuState			; Restore the menu state if it was saved <SM5> <PN>
-				restoreUnlinkReturn
+				JMP		(A0)
 				ENDPROC
 
 ENABLEITEM		PROC	EXPORT
@@ -1371,7 +1166,7 @@ lastFuncResult	EQU		menuDragSave - 2		; funcResult last time thru MSLoop		<FJL C
 lastItemResult	EQU		lastFuncResult - 2		; itemResult last time thru MSLoop		<FJL C222>
 firstMenuID		EQU		lastItemResult - 2		; ID of REGULAR menu up					<FJL C222>
 NewHMenuOffset	EQU		firstMenuID - 2			; offset into MenuList of new HMenu		<FJL C222>
-SelectFrame		EQU		NewHMenuOffset			; number of bytes to save				<FJL C222>
+SelectFrame		EQU		NewHMenuOffset-8			; number of bytes to save				<FJL C222>
 
 msHMenuStorage	EQU		4						; 4 bytes per menu needed for temp storage <FJL C222>
 
@@ -1390,90 +1185,6 @@ MENUSELECT		PROC	EXPORT
 ;	zero, no menu was chosen.  The low word is called "whichItem" and contains the item
 ;	number of the selected item.  If no choice was selected, the longWord result is zero
 
-	; MenuSelect draw menu bar if invalid
-	; ROLL IN DrawMenuBarIfInvalidOnMenuSelect
-				IMPORT	ValidateMenuBar
-				IMPORT	ptchHMUpdateHelpMenu
-				IMPORT	ptchHMShowHelpAboutDialog
-				IMPORT	ptchHMToggleWhatIs
-				
-				jsr		ValidateMenuBar
-;Roll in PatchMDMenuSelect
-;The saves menus state, calls old MenuSelect, then restores state
-				import PushMenuState,PopMenuState ;<PN> <SM5>
-
-				resultsStackFrame
-result			ds.l		1					; the MenuSelect result <PN> <SM5>
-				parametersStackFrame
-startPt			ds.l		1					; the start point <PN> <SM5>
-				endStackFrame
-
-				linkSave A2						;								<SM15> To preserve A2!
-				MOVE.L	MenuList,D0				; check if menu list is nil.	<SM12> rb, start
-				BEQ.S	@CallOldCode			; if NIL just call the old trap
-
-				JSR		ptchHMUpdateHelpMenu	; update the menu checked status
-
-				MOVE.L	ExpandMem,A2			; <33> point to the expand mem ptr
-				MOVE.L	ExpandMemRec.emHelpGlobals(A2),A2	; <33> A2 = global ptr
-				CLR.W	hmgSystemMenuID(A2)		; <33> clear the last system menu ID
-				CLR.W	hmgSystemMenuItem(A2)	; <33> clear the last system menu item
-				ST		hmgInMenuSelectFlag(A2)	; <33> say that we're in MenuSelect
-@CallOldCode									; <SM12> rb, end
-
-				jsr		PushMenuState			; Potentially save off the menu state <PN> <SM5>
-				subq	#4,sp					; Make room for result <PN> <SM5>
-				move.l	startPt(a6),-(sp)		; Push the parameter <PN> <SM5>
-
-				jsr		OrigninalMenuSelect		;<PN> <SM5>
-				move.l	(sp)+,result(a6)		; Store the result <PN> <SM5>
-				jsr		PopMenuState			; Restore the menu state if it was saved <PN> <SM5>
-				
-				MOVE.L	result(a6),D0			; get the result of the _MenuSelect call <SM12> rb, start
-				MOVE.L	ExpandMem,A2						; <33> point to the expand mem ptr
-				MOVE.L	ExpandMemRec.emHelpGlobals(A2),A2	; <33> A2 = global ptr
-
-				SWAP	D0							; put menu ID in low word for test
-				TST.W	D0							; was the menu ID non-zero?
-				BNE.S	@NormalMenuSelect			; yes, so just return result of _MenuSelect
-
-				MOVE.W	hmgSystemMenuID(A2),D1		; return the last system menu ID
-				BEQ.S	@NormalMenuSelect			; if zero then the menu wasn't the help menu
-
-				SWAP	D1							; put menu ID in hiword
-				MOVE.W	hmgSystemMenuItem(A2),D1	; return the last help menu item
-
-@HandleHelpMenu
-				CMP		#kHMAboutHelpItem,D1		; was it the about item
-				BNE.S	@TryShowBalloonsItem		; no, check for Show/Hide Balloons item
-
-				JSR		ptchHMShowHelpAboutDialog	; show the about dialog
-				BRA.S	@HelpMenuHandled			; exit w/ zeroed menu result long
-
-@TryShowBalloonsItem
-				CMP.W	#kHMShowBalloonsItem,D1		; was the selection Show/Hide Balloons??
-				BNE.S	@DoneHelpMenu				; no, it was some other item
-
-				JSR		ptchHMToggleWhatIs			; toggles state of "Show Balloons" global,
-				BRA.S	@HelpMenuHandled			; exit w/ zeroed menu result long
-
-@DoneHelpMenu
-				MOVE.L	D1,D0						; put the setup menu result in D0 for result(A6)
-				BRA.S	@CorrectedResult			; exit
-
-@HelpMenuHandled
-				MOVEQ	#0,D0						; say that hi and lo words are zero
-@NormalMenuSelect
-				SWAP	D0							; put item number back in lo word
-@CorrectedResult
-				MOVE.L	D0,result(a6)				; stuff the non-corrected result
-
-				CLR.W	hmgInMenuSelectFlag(A2)		; <33> say that we're out of MenuSelect
-
-				restoreUnlinkReturn
-				
-OrigninalMenuSelect	
-
 				LINK	A6,#SelectFrame			;set up a stack frame
 				MOVEM.L D2-D7/A2-a4,-(SP)		;save work registers
 				
@@ -1497,7 +1208,7 @@ OrigninalMenuSelect
 				PEA		MSavePort(A6)
 				_GetPort
 
-				move.l	wMgrCPort, a2			; get color port
+				move.l	wMgrPort, a2			; get port
 
 				move.l	a2, -(SP)				; set the port
 				_SetPort
@@ -1511,6 +1222,8 @@ OrigninalMenuSelect
 				CLR		D5						; current menuIndex is empty
 				CLR		D4						; oldMenuIndex is empty
 				clr		msLastMenu(a6)			; clear msLastMenu index				<FJL C222>
+				IMPORT	SetTickCounters
+				bsr		SetTickCounters			; set DelayTicks and DragTicks
 				clr.l	lastItemResult(a6)		; clear both lastFuncResult and lastItemResult
 				clr		firstMenuID(a6)			; no menu selected at start
 
@@ -1519,10 +1232,6 @@ OrigninalMenuSelect
 				move.b	mbMenuDelay(a0), menuDelaySave(a6)
 				move.b	mbMenuDrag(a0), menuDragSave(a6)
 
-				IMPORT	SetTickCounters			; <SM13> call SetTickCounters after
-												; menuDelaySave and menuDragSave are set up
-				bsr		SetTickCounters			; set DelayTicks and DragTicks			<FJL C222>
-
 				MOVE.L	STARTPT(A6),D3			; start off with initial mouse point
 
 				move.l	#5*msHMenuStorage, d0	; alloc space for 5 menuIndices [words]	<FJL C222>
@@ -1781,7 +1490,7 @@ PopUpMenuSelect	PROC	EXPORT					;;<FJL C844>
 				PEA		MSavePort(A6)
 				_GetPort
 
-				move.l	wMgrCPort, a2			; get color port
+				move.l	wMgrPort, a2			; get port
 
 				move.l	a2, -(SP)				; set the port
 				_SetPort
@@ -1824,17 +1533,6 @@ PopUpMenuSelect	PROC	EXPORT					;;<FJL C844>
 				move	d0, d4					; save index in D4						<PMAB364	23Jan88	EMT>
 				beq		@EndPopUpMS				; zero index ==> couldn’t find it (shouldn’t happen)
 
-; Alter WMgr portRect to point to the rect of the device the cursor is on
-				MOVE.L	CrsrDevice, A1			; Get the cursor GDevice				<PMAB364	23Jan88	EMT>
-				MOVE.L	(A1), A1				; Dereference							<PMAB364	23Jan88	EMT>
-				MOVE.L	gdRect+topLeft(A1), portRect+topLeft(A2)	; Copy to			<PMAB364	23Jan88	EMT>
-				MOVE.L	gdRect+botRight(A1), portRect+botRight(A2)	; WMgr portRect		<PMAB364	23Jan88	EMT>
-
-				IMPORT	DirtyHMenus
-				BSR		DirtyHMenus				; Dirty size of all hierchical menus	<PMAB364	23Jan88	EMT>
-				MOVE.L	PopUpMenuH(A6), -(SP)	; Push the menuHandle					<PMAB539	19Jul88	EMT>
-				_CalcMenuSize					; And recalculate it					<PMAB539	19Jul88	EMT>
-
 				move	d4, d5					; copy saved index to D5				<PMAB364	23Jan88	EMT>
 
 				IMPORT	DrawFirstMenu
@@ -1939,13 +1637,6 @@ PopUpMenuSelect	PROC	EXPORT					;;<FJL C844>
 				clr		funcResult(A6)			; no Item ==> so clear Func too
 
 @DonePopUpMS	move	(SP)+, MBarHeight		; restore previous MBarHeight saved on the stack
-; Restore WMgr portRect. WMgrCPort is in A2
-				MOVE.L	WMgrPort, A0			; Get b&w WMgrPort						<PMAB364	23Jan88	EMT>
-				MOVE.L	portRect+topLeft(A0), portRect+topLeft(A2)		; Copy to		<PMAB364	23Jan88	EMT>
-				MOVE.L	portRect+botRight(A0), portRect+botRight(A2)	; WMgr portRect	<PMAB364	23Jan88	EMT>
-
-				IMPORT	DirtyHMenus
-				BSR		DirtyHMenus				; Dirty size of all hierchical menus	<PMAB364	23Jan88	EMT>
 
 				IMPORT	DoneMS
 				bra		DoneMS					; use common code
@@ -2005,7 +1696,7 @@ CALCMENUSIZE	PROC	EXPORT
 				MOVE.L	SP, -(SP)				;										<PMAB364	23Jan88	EMT>
 				_GetPort						;										<PMAB364	23Jan88	EMT>
 
-				MOVE.L	WMgrCPort, A1			; Get color port						<PMAB364	23Jan88	EMT>
+				MOVE.L	WMgrPort, A1			; Get port								<PMAB364	23Jan88	EMT>
 
 				MOVE.L	A1, -(SP)				; Set the port							<PMAB364	23Jan88	EMT>
 				_SetPort						;										<PMAB364	23Jan88	EMT>
@@ -2760,18 +2451,6 @@ paramSize	EQU		18
 				_LoadResource					; load it
 				MOVE.L	D3, A0					; get the MDEF handle
 
-; Some programmers are pretty slimy and load a MDEF that is empty.  They then					<LW4> fau
-; stuff some code into it.  However, since HLOCK does not flush the cache anymore,				<LW4> fau
-; the code that they stuff into it might not get written back to memory.  To solve this,		<LW4> fau
-; we check here whether the MDEF resource size is less than, say, 32 bytes.  If so, we			<LW5> chp
-; assume that they have already loaded the MDEF and modified it, so we flush the cache			<LW4> fau
-; for them.
-
-				_GetHandleSize					; How big is our MDEF Handle					<LW4> fau
-				cmp.l		#32,D0				; Is it "small"									<LW5> chp
-				bhi.s		@RealMDEF			; no, don't flush the cache						<LW4> fau
-				jsr			([jCacheFlush])		; else, flush the caches.						<LW4> fau
-@RealMDEF										;												<LW4> fau
 				_HLock							; lock it the gentleman’s way		<C169>
 				MOVE.L	(A0),A0					; handle -> pointer
 
@@ -2987,15 +2666,6 @@ SetMenuBar		PROC	EXPORT
 				_HandToHand						; make a copy of the parameter list	<FJL C222>
 				move.l	a0, menuList			; store the new menuList			<FJL C222>
 
-				MOVE.L	a0,D0				; Get result
-				BEQ.S	@done				; EQ means no menulist or memfull
-
-				; Call the MBDF to put in the system menus
-				MOVEQ	#2,D0				; set up for the menu-edge-calc msg
-				CLR.L	D1					; calc entire bar
-				IMPORT	CallMBarProc
-				jsr		CallMBarProc
-@done
 				RTS
 				ENDPROC
 
@@ -3698,26 +3368,6 @@ MENUKEY
 ;
 ; Hilite the "parent" menu when a hierarchical menu is chosen.						<FJL C222>
 
-; Roll in PatchMDMenuKey  <SM5> <PN>
-				import 	PushMenuState,PopMenuState ;<SM5> <PN>
-
-				resultsStackFrame
-result			ds.l		1					; the menukey result <SM5> <PN>
-				parametersStackFrame
-ch				ds.w		1					; the char to pass thru <SM5> <PN>
-				endStackFrame
-
-				linkSave
-				jsr		PushMenuState			; Potentially save off the menu state <SM5> <PN>
-				subq	#4,sp					; Make room for MenuKey result <SM5> <PN>
-				move.w	ch(a6),-(sp)			; Push the character <SM5> <PN>
-
-				jsr		OriginalMenuKey			;<SM5> <PN>
-
-				move.l	(sp)+,result(a6)		; Save off the result <SM5> <PN>
-				jsr		PopMenuState			; Restore the menu state if it was saved <SM5> <PN>
-				restoreUnlinkReturn
-OriginalMenuKey	
 				link	a6, #KeyFrame			; set up stackframe
 				MOVEM.L D3-D6/A3,-(SP)			;save work registers
 
@@ -4400,14 +4050,6 @@ DELMENUITEM		PROC	EXPORT					;										<EHB 15-Apr-85>
 				MOVE.L	(SP),-(SP)				; old RTS -> phony newItem
 				MOVEM.L D3-D4/A2-A4,-(SP)		; save work registers
 
-; begin by removing item’s entry in menu color table									<FJL C408>
-
-				MOVE.L	30(SP),A3				; get menu handle						<FJL C408>
-				MOVE.L	(A3),A0					; get menu ptr							<FJL C408>
-				move	menuID(a0), -(sp)		; push menuID on stack					<FJL C408>
-				MOVE.W	30(SP),-(sp)			; push itemNum on stack					<FJL C408>
-				_DelMCEntries					; and remove item's menu color entry	<FJL C408>
-
 ; set up for rest of DelMenuItem
 
 				MOVE.L	30(SP),A3				; get menu handle
diff --git a/Toolbox/MenuMgr/MenuMgr.c b/Toolbox/MenuMgr/MenuMgr.c
--- a/Toolbox/MenuMgr/MenuMgr.c
+++ b/Toolbox/MenuMgr/MenuMgr.c
@@ -70,6 +70,10 @@
 				addedResources - the number of items to compare against (1st time is always zero)
 	Outputs:	FindInsertIPt - the item number after which rsrcName should be inserted.
 */
+// things that didn't work to get theMenu into A2:
+// changing theMenu to a Handle instead of MenuHandle, and changing the casts accordingly
+// creating a new variable (the codegen indicated that A2 is definitely an alias for the argument)
+// register keyword
 short FindInsertIPt(StringPtr rsrcName, short rsrcScript, MenuHandle theMenu, short afterItem, short addedResources)
 {
 	StringPtr	itemRecPtr;
diff --git a/Toolbox/MenuMgr/MenuMgrPatch.a b/Toolbox/MenuMgr/MenuMgrPatch.a
--- a/Toolbox/MenuMgr/MenuMgrPatch.a
+++ b/Toolbox/MenuMgr/MenuMgrPatch.a
@@ -70,7 +70,8 @@
 		endif											; <12>
 	endif												; <12>
 	
-			load		'StandardEqu.d'
+			include		'MenuMgr.a'
+
 			include		'LinkedPatchMacros.a'
 			include		'ScriptPriv.a'					; <13>
 
@@ -103,8 +104,6 @@
 			MakePatch	DelMenuItem,$A952
 			MakePatch	MenuChoice,_MenuChoice,(Plus,SE,Portable)
 
-			include		'MenuMgr.a'
-
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 ;	SetClipForCallDrawMDEF
 ;
diff --git a/Toolbox/MenuMgr/StandardMBDF.a b/Toolbox/MenuMgr/StandardMBDF.a
--- a/Toolbox/MenuMgr/StandardMBDF.a
+++ b/Toolbox/MenuMgr/StandardMBDF.a
@@ -10,7 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<SM3>	10/22/92	CSS		Change some branch short instructions to word branches.
 ;		<49>	 4/30/92	DTY		#1027995 <KSM>: SetTitleColor expects a4 to point to a MenuInfo
 ;									record on entry. The BannerMsg routine calls SetTitleColor
 ;									without setting up a4. This kinda makes sense, since the menu
@@ -826,7 +825,7 @@ SkipSysLoop
 DONEDRAWMLOOP
 				BSR		ClipMBar				; Restore the clip to the whole menu bar <10>
 				move	saveD3(a6), d0			; get savedID of hilited menu			<FJL A428>
-				beq 	DrawDone				; branch if none						<FJL A428> <SM3> CSS 
+				beq.s	DrawDone				; branch if none						<FJL A428>
 				move	d0,d3					; and put it in d3 too					<FJL A428>
 				bsr		GetTitleRect			; get selected title's rect				<FJL A428>
 				move.l	menuOH(a3,d3),a0		; get selected menuHandle				<FJL A428>
@@ -1468,7 +1467,7 @@ CalcBar
 				MOVE.L	SystemMenuList, A0		; Get system menulist
 				MOVE.L	(A0), A1				; deref system menulist handle
 				TST.W	lastMenu(A1)			; Are there any system menus?
-				BEQ 	SystemMenusAreIN		; Well, there aren't any -- so they are all in! <SM3> CSS 
+				BEQ.S	SystemMenusAreIN		; Well, there aren't any -- so they are all in!
 
 				BSR		FindFirstSystemMenu6BO	; See if the system menus are in.
 				BNE.S	SystemMenusAreIN		; Yes, they are (D0 is offset to 1st one)
@@ -1721,7 +1720,7 @@ HiliteBar
 				BSR		ClipMBar				;								<EMT S297>
 
 				MOVE.W	param2+2(A6),D0			; get the hilite selector
-				BEQ	FlipBar						; if index = 0 then flip bar		<FJL C175><35> <SM3> CSS 
+				BEQ.S	FlipBar						; if index = 0 then flip bar		<FJL C175><35>
 
 				CMP.W	#1,param2(a6)			; hi-word has hilite
 				BGT.S	DoneHilite				; if not in range we support then bye-bye
diff --git a/Toolbox/MenuMgr/StandardMDEF.a b/Toolbox/MenuMgr/StandardMDEF.a
--- a/Toolbox/MenuMgr/StandardMDEF.a
+++ b/Toolbox/MenuMgr/StandardMDEF.a
@@ -11,15 +11,7 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	 12/7/92	CSS		Update from Reality:
-;									<64> 12/4/92 KSM	Don't call DisposHandle if NIL upon exiting even though the call
-;														can handle it. It wastes time and inhibits debugging other
-;														things.
 ;	   <SM3>	 11/5/92	SWC		Changed PackMacs.a->Packages.a.
-;	   <SM2>	10/16/92	RB		Removed SOME of the NOT forROM conditionals, since some of that
-;									code did not make sense anymore for SuperMario ROMs. This fixed
-;									the disabled menu items not being drawn in gray color instead of
-;									gray pattern.
 ;		<63>	 8/22/91	KSM		csd,#Bruges: fix font/face cleanup problem in script systems.
 ;		<62>	 3/26/91	KSM		rlc,#85632: Reset the font back to the default after script
 ;									changed it.
@@ -442,9 +434,7 @@ MDEFSaveReg	REG		D3-D7/A2-A4
 			move.l	a3, a0				; get menuHandle
 			_HUnlock					; and unlock it before we leave
 
-			move.l	arrowHandle(a6),d0	; the arrow handle or NIL					<48><64>
-			beq.s	@skipDispose		; Don't bother if already NIL				<64>
-			move.l	d0,a0				; Get ready for DisposeHandle				<64>
+			move.l	arrowHandle(a6),a0	; the arrow handle							<48>
 			_DisposeHandle				; DisposeHandle can deal with NIL			<48>
 @skipDispose
 
@@ -1933,7 +1923,7 @@ DrawDash
 			BRA		DoneDrawItem		; dive	back into mainstream
 
 NotDash
-	;	IF NOT forROM THEN				; only do this for System builds, not ROMs				<33><SM2> rb
+		IF NOT forROM THEN				; only do this for System builds, not ROMs				<33>
 			TST.B	onColorMachine(a6)	; on color machine?
 			BEQ.S	@skipPenMode		; no, skip _TextMode
 			TST.B	enableState(a6)		;										<34>
@@ -1942,7 +1932,7 @@ NotDash
 			MOVE.W	D0,-(SP)
 			_TextMode
 @skipPenMode							; <51=BRC#79297>
-	;	ENDIF							; { NOT forROM }										<33><SM2> rb
+		ENDIF							; { NOT forROM }										<33>
 
 			ADDQ.W	#2, D5				; Add the 2 pixels here instead				<S550	27Jul88	EMT>
 
@@ -2299,16 +2289,16 @@ DRAWITEXT
 
 			TST.B	enableState(A6)		; If enabled, don’t bitclear or reset textmode
 			BNE.S	DoneDrawItem
-	;IF (not forROM) THEN																		<SM2> rb
+	IF (not forROM) THEN
 			TST.B	onColorMachine(A6)	; If color, we drew in gray so don’t bitclear
 			BNE.S	@fixcolor
-	;ENDIF																						<SM2> rb
+	ENDIF
 			BSR.S	BitClearItem
-	;IF (not forROM) THEN																		<SM2> rb
+	IF (not forROM) THEN
 @fixColor
 			MOVE.W	#srcOr,-(SP)
 			_TextMode
-	;ENDIF																						<SM2> rb
+	ENDIF
 
 DoneDrawItem
 			bsr		ResetPreviousColors	; restore colors saved in the stackframe <FJL C408>
@@ -2603,7 +2593,7 @@ doneExpand
 ;						This code returns an even multiple of MFHeight if the menu scrolls.
 
 DoCalcMsg
-	;	IF NOT forROM THEN					;									<2.2>	<SM2> rb
+		IF NOT forROM THEN					;									<2.2>
 			BSR.S	PushThePort
 ;			CMP.W	#$3FFF, ROM85			; color machine ?							<PMAB364	23Jan88	EMT>
 			TST.B	onColorMachine(A6)		; color machine ?							<S394	12Feb88	DBG>
@@ -2618,7 +2608,7 @@ DoCalcMsg
 
 @SetPort									;											<PMAB364	23Jan88	EMT>
 			_SetPort						; set it									<PMAB364	23Jan88	EMT>
-	;	ENDIF	; if NOT forROM															<SM2> rb
+		ENDIF	; if NOT forROM
 
 ; since calc msg could be called at any time, we need to reset the wmgr’s textfont here else
 ; could get incorrectly sized menus
@@ -2728,9 +2718,9 @@ DoCalcDone1								; if NIL menu, return 0				<EHB 10-Apr-85>
 ;			CLR.W	-(SP)					; better restore style to normal
 ;			_TextFace						; set the style
 
-	;	IF NOT forROM THEN					; <2.2>										<SM2> rb
+		IF NOT forROM THEN					; <2.2>
 			_SetPort						; restore original grafPort					<PMAB364	23Jan88	EMT>
-	;	ENDIF	; if NOT forROM															<SM2> rb
+		ENDIF	; if NOT forROM
 
 			rts								; all done! so return to dispatcher
 
diff --git a/Toolbox/NotificationMgr/NotificationMgr.c b/Toolbox/NotificationMgr/NotificationMgr.c
--- a/Toolbox/NotificationMgr/NotificationMgr.c
+++ b/Toolbox/NotificationMgr/NotificationMgr.c
@@ -9,11 +9,6 @@
 
 	Change History (most recent first):
 
-	   <SM6>	  1/8/94	kc		Initialize SndChannelPtr before calling SndNewChannel in
-									DoSound. This fixes bug found in MacWorld Compatability Lab.
-	   <SM5>	12/21/93	SAM		Changed DoSound to manually get a new sound channel and set its
-									volume to the "alert" volume level before calling SndPlay.
-	   <SM4>	 5/18/93	RC		perfomance/bug fix (seed up WaitNextEvent by 20%)
 	   <SM3>	 12/3/92	RB		Renamed Call to avoid a conflict.
 		<14>	 5/29/92	DCL		Included TextUtils.p. EqualString was moved for the New Inside
 									Mac.
@@ -662,9 +657,6 @@ void
 DoSound(NMRecPtr theNMRec, int procLevel)
 {
 	register Handle	theSound = theNMRec->nmSound;
-	SndChannelPtr		chan = nil;	// <SM6>
-	long				sysBeepVolume = 0;
-	SndCommand			cmd;
 
 	theNMRec->nmFlags |= fSndPlayed;
 	if (theSound) 
@@ -674,16 +666,7 @@ DoSound(NMRecPtr theNMRec, int procLevel)
 			SysBeep(3);
 		else 
 		{
-			if ( SndNewChannel(&chan, 0, 0, nil) == noErr )
-			{
-				GetSysBeepVolume(&sysBeepVolume);
-					cmd.cmd = volumeCmd;
-					cmd.param2 = sysBeepVolume;
-					SndDoImmediate(chan, &cmd);
-				
-				SndPlay(chan, theSound, false);
-				SndDisposeChannel(chan, true);
-			}
+			SndPlay(NULL, theSound, false);
 		}
 	}
 }
@@ -829,17 +812,13 @@ NMTask(void)
 	register int	procLevel;
 	short	selector[4];
 	
-	/* NOTE: If this code seems buggy, take this 'if' statement and move it below after the call to AddIconRec() */
-	if (NMQHdr->requests.qHead == nil)
-		return;
-
-	selector[0] = MoveSICNToPM;
-	selector[1] = MoveICSToPM;
-	selector[2] = MoveSICNToAM;
-	selector[3] = MoveICSToAM;
-	
 	procLevel = disable();
  
+	selector[3] = MoveICSToAM;
+	selector[2] = MoveSICNToAM;
+	selector[1] = MoveICSToPM;
+	selector[0] = MoveSICNToPM;
+	
 	{
 		/* Find the first queue element that needs attention.
 		 * Note that the response proc is the last thing done.
diff --git a/Toolbox/Printing/PrintGlue.a b/Toolbox/Printing/PrintGlue.a
--- a/Toolbox/Printing/PrintGlue.a
+++ b/Toolbox/Printing/PrintGlue.a
@@ -7,10 +7,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	 6/28/93	kc		Roll in Ludwig.
-;	   <LW2>	 6/25/93	fau		(with mal and chp):  If the PDEF is 32 bytes or less, go flush
-;									the cache, in case the developer is using the PDEF as a stub and
-;									stuffing their own code.
 ;	   <SM3>	 11/5/92	SWC		Changed PrEqu.a->Printing.a and
 ;									PrintCallsEqu.a->PrintTrapsEqu.a.
 ;		<SM1>	 6/15/92	CSS		Take out forRom and CubeE conditionals because the forRomed code is old
@@ -225,8 +221,6 @@
 			INCLUDE			'Aliases.a'
 			INCLUDE			'LinkedPatchMacros.a'
 
-			MACHINE MC68020							; needed for cache flush <LW2> fau
-
 ;************************************************************************************************
 ;* _MDebugStr takes a string for a parameter and calls DebugStr with it.
 ;*
@@ -352,18 +346,6 @@ GotPDEF
 		Move.l	d0,a4					; Transfer the handle to an a-reg
 		Move.l	a4,a0					; Lock that baby down
 
-; Some programmers are pretty slimy and load a PDEF that is empty.  They then					<LW2> fau
-; stuff some code into it.  However, since HLOCK does not flush the cache anymore,				<LW2> fau
-; the code that they stuff into it might not get written back to memory.  To solve this,		<LW2> fau
-; we check here whether the PDEF resource size is less than, say, 32 bytes.  If so, we			<LW2> fau
-; assume that they have already loaded the PDEF and modified it, so we flush the cache			<LW2> fau
-; for them.																						<LW2> fau
-
-		_GetHandleSize					; How big is our PDEF Handle					<LW2> fau
-		cmp.l		#32,D0				; Is it "small"									<LW2> fau
-		bhi.s		@RealPDEF			; no, don't flush the cache						<LW2> fau
-		jsr			([jCacheFlush])		; else, flush the caches.						<LW2> fau
-@RealPDEF										;										<LW2> fau
 		_HLock
 ;<22Feb87> JNP Restore curMap before jumping into the print code.
 		Move.w	a3, -(sp)				; <22Feb87> JNP user's resfile refnum
diff --git a/Toolbox/ResourceMgr/ResourceMgr.a b/Toolbox/ResourceMgr/ResourceMgr.a
--- a/Toolbox/ResourceMgr/ResourceMgr.a
+++ b/Toolbox/ResourceMgr/ResourceMgr.a
@@ -1094,7 +1094,7 @@ InitResources
 
 		move.l	IntlSpec,D0				; if IntlSpec is not set up,	<1.2><1.3>
 		addq	#1,D0					;	go set it up.				<1.2><1.3>
-		BigJsr	SmgrInitialize,a0		; <SM22>
+		bsr		SmgrInitialize
 @exit
 
 ;	Rolled in InstallProc  rolled in to set emScanOverrideMaps to true here.
diff --git a/Toolbox/ResourceMgr/ResourceMgrExtensions.a b/Toolbox/ResourceMgr/ResourceMgrExtensions.a
--- a/Toolbox/ResourceMgr/ResourceMgrExtensions.a
+++ b/Toolbox/ResourceMgr/ResourceMgrExtensions.a
@@ -33,9 +33,6 @@
 ;									serial number is 0.
 ;	  <SM16>	 5/24/93	BT		The size of an empty map in MakeOverrideMap should be 32, not
 ;									30.  Andy Nicholas found this and Dean Yu verified it. So there.
-;	  <SM15>	 5/14/93	kc		Roll in change from Reality that fixes a bug in ReleaseTheFont
-;									that was leaving all of the fonts locked down in the system
-;									heap.
 ;	  <SM14>	 4/16/93	kc		Change call to AddNewRef to AddNewRefWithoutUpdate so that
 ;									MakeOverrideMap doesn't set the mapChanged bit. This fixes
 ;									#1069183.
@@ -901,8 +898,8 @@ ValidateFontResourceIDs	Proc	Export
 				bsr		FindIDInFromToList				; <57> Go find the ID
 				move.w	(sp)+,d2						; <57> FindIDInFromList will return the ID to renumber to, or -1 if this ID wasn’t in the table
 				cmpi.w	#-1,d2							; <57> Did we get back a -1?
-				bne		@changeFATEntry					; <57> This font was already renumbered.  Just change the font association table entry.
-				bra		@nextTableEntry					; <57> A -1 means that this ID isn’t in our list, so this 'FOND' entry is probably bad.
+				bne.s	@changeFATEntry					; <57> This font was already renumbered.  Just change the font association table entry.
+				bra.s	@nextTableEntry					; <57> A -1 means that this ID isn’t in our list, so this 'FOND' entry is probably bad.
 				
 ;
 ; See if the ID conflicts with a font resource in the main chain.
@@ -916,31 +913,7 @@ ValidateFontResourceIDs	Proc	Export
 				move.w	4(a3),-(sp)						; Look for this ID.
 				_GetResource							; Does it exist?
 				move.l	(sp)+,d0
-				bne.s	@conflictOccured				; This number is used
-
-				cmpi.l	#'FONT',d3						; <mc3> If it is a FONT, also check for NFNT conflicts 
-				beq.s	@checkForNFNTs					; <mc3> 
-				cmpi.l	#'NFNT',d3						; <mc3> If it is a NFNT, also check for FONT conflicts
-				beq.s	@checkForFONTs					; <mc3> 
-				bra.s	@nextTableEntry					; <mc3> If it is a sfnt or other, go on to the next one.
-
-@checkForFONTs
-				subq	#4,sp							; <mc3>
-				move.l	#'FONT',-(sp)					; <mc3> Look for FONT type in the main chain
-				move.w	4(a3),-(sp)						; <mc3> Look for this ID.
-				_GetResource							; <mc3> Does it exist?
-				move.l	(sp)+,d0						; <mc3>
-				bz.s	@nextTableEntry					; <mc3> This number is fine
-				bra.s	@conflictOccured
-
-@checkForNFNTs
-				subq	#4,sp							; <mc3>
-				move.l	#'NFNT',-(sp)					; <mc3> Look for NFNT type in the main chain
-				move.w	4(a3),-(sp)						; <mc3> Look for this ID.
-				_GetResource							; <mc3> Does it exist?
-				move.l	(sp)+,d0						; <mc3>
-				bz.s	@nextTableEntry					; <mc3> This number is fine
-
+				bz.s	@nextTableEntry					; This number is fine
 @conflictOccured
 				move.l	d0,a0							; <46>
 				btst	#kDeanBit,kBrianBits			; <53> See if we loaded the resource
@@ -1116,7 +1089,7 @@ FontResourceTypes
 ReleaseTheFont	Proc	Export
 				With	ConflictStackFrame
 				move.l	(sp)+,d1						; Save the return address
-				tst.b	fontAlreadyLoaded(a6)			; <46> See if we loaded the font <SM15>
+				tst.w	fontAlreadyLoaded(a6)			; <46> See if we loaded the font
 				bz.s	@weLoadedTheFont				; <46> If we did, then unload it
 				addq	#4,sp							; <46> If it was already loaded when we got our hands on it, leave it alone.
 				clr.w	fontAlreadyLoaded(a6)			; <46> And clear this flag for the next time.
@@ -1289,6 +1262,7 @@ retAddr			ds.l	1
 A6Link			ds.l	1
 catInfoRec		ds.b	ioHFQElSiz						; Parameter block for _GetCatInfo call
 currentZone		ds.l	1								; Current zone
+somethinghere	ds.w	1
 realCurMap		ds.w	1								; Current resource map
 openingFontFile	ds.w	1								; <34> Non zero if this file is a font file
 localSize		equ		*
@@ -1301,6 +1275,7 @@ localSize		equ		*
 				
 				move.w	#-1,fileRefNum(a6)				; Be pessimistic and assume we’ll fail
 				clr.w	openingFontFile(a6)				; <34> Assume it’s not a font file.
+				clr.w	somethinghere(a6)
 				
 ; Get the file type and creator of this file.
 				
@@ -1339,6 +1314,15 @@ localSize		equ		*
 				move.l	TheZone,currentZone(a6)			; Save the current zone
 				move.l	SysZone,TheZone					; Make sure map is opened in the system heap
 				
+				move.l	ExpandMem,a0
+				tst.w	ExpandMemRec.emProcessMgrExists(a0)	; See if Process Manager is around so _BeginSystemMode exists
+				bz.s	@noBeginSystemMode					; It’s not.  Don’t call BeginSystemMode
+				st		somethinghere(a6)
+				subq	#2,sp
+				_BeginSystemMode							; The file was opened in system mode, so it needs to be closed that way.
+				addq	#2,sp
+@noBeginSystemMode
+
 				move.l	TopMapHndl,a3					; Remember current top resource map
 				subq	#2,sp
 				move.l	fileSpec(a6),-(sp)				; Pass file descriptor
@@ -1365,10 +1349,14 @@ localSize		equ		*
 				move.l	ExpandMem,a0					; <34> This was a font file
 				add.w	#1,ExpandMemRec.emOpenFontFiles(a0)
 @markFileOwner
-				move.w	fileRefNum(a6),d0
-				bsr		MarkFileAsOwnedByTheSystem		; <62<mc2>> Do this instead of opening in system mode
 				
 @restoreHeap
+				tst.b	somethinghere(a6)				; See if Process Manager is around so _BeginSystemMode exists
+				bz.s	@noEndSystemMode				; It’s not.  Don’t call EndSystemMode
+				subq	#2,sp
+				_EndSystemMode
+				addq	#2,sp
+@noEndSystemMode
 				move.l	currentZone(a6),TheZone			; Restore the current heap
 @exit
 				move.w	realCurMap(a6),CurMap			; <19> Restore CurMap
@@ -1518,7 +1506,9 @@ IsThisASystemResourceMap	Proc	Export
 
 				move.l	(a0)+,d0						; Get high long of PSN
 				bnz.s	@exit							; If not zero, it can’t be kSystemProcess
-				cmpi.l	#kSystemProcess,(a0)			; <62><mc2> Check low word of PSN.
+				move.l	(a0),d0
+				beq.s	@isSystemResource
+				cmpi.l	#kSystemProcess,d0				; <62> Check low word of PSN.
 				bne.s	@exit
 @isSystemResource
 				move.w	#-1,4(sp)						; This is a system resource map
@@ -1892,7 +1882,7 @@ MakeOverrideMap	Proc	Export
 		
 				move.l	d0,-(sp)						; save handle for ReleaseResource later
 		
-				moveq	#32,d0							; Space for header, map info, and type count
+				moveq	#30,d0							; Space for header, map info, and type count
 				_NewHandle ,Sys,Clear					; Create a new map
 				move.l	a0,a4							; Keep handle to new map in A4
 				move.l	(a0),a0
@@ -1909,9 +1899,6 @@ MakeOverrideMap	Proc	Export
 				move.w	#mNames+4,(a0)+					; Point to after resource map for name list
 				move.w	#-1,(a0)+						; Nothing in the resource map
 				clr.w	(a0)							; No names in the map
-				move.l	(a4),a1							; get map pointer in a1										<SM12> rb
-				bset	#twoDeepBit,mInMemoryAttr(a1)	; mark for extended search									<SM12> rb
-				bset	#overrideNextMapBit,mInMemoryAttr(a1) ; mark as an override map								<SM14> rb
 				
 				move.l	(sp),a1							; get rovm resource handle
 				move.l	(a1),a1							; get rovm resource pointer
@@ -1957,12 +1944,12 @@ MakeOverrideMap	Proc	Export
 ; If this resource has a name, add the name to the override map
 ;
 
-				exg		a1,a2							; Get entry pointer back in A2						<SM11> rb
 				move.w	rNameOff(a0),d0					; Get offset to resource name
 				bmi.s	@noName							; If negative, this resource has no name
 				move.l	(a5),a0							; Dereference ROM map handle
 				add.w	MNames(a0),a0					; Get to resource name list
 				add.l	d0,a0							; A0 now points to the name for this resource
+				exg		a1,a2							; Get entry pointer back in A2
 				jsrROM	AddName							; Let the Resource Manager do the hard part
 
 ;
@@ -2000,8 +1987,6 @@ MakeOverrideMap	Proc	Export
 ; up properly.
 
 InsertOverrideMap	Proc	Export
-				Import	MarkFileAsOwnedByTheSystem		; <mc2>
-				
 				jsrROM	StdZEntry						; Make sure nothing is inserted before the ROM map
 				
 				move.w	#nilHandleErr,ResErr			; <40> Assume nil handle
@@ -2089,11 +2074,6 @@ InsertOverrideMap	Proc	Export
 				bset	#dontCountOrIndexDuplicatesBit,mInMemoryAttr(a0)	; And ignore duplicates in this map now
 				clr.w	ResErr							; No error if we got this far
 
-; <62><mc2> Mark override map as being owned by the system
-
-				move.w	mRefNum(a1),d0					; Get file reference number
-				bsr		MarkFileAsOwnedByTheSystem
-				
 ; Clear emLastMapOverridden to force a resynchronization of the override maps.
 
 				move.l	ExpandMem,a0							; <58>
@@ -2334,5 +2314,244 @@ localSize		equ		*
 				rts										; Return
 				EndProc
 
+;____________________________________________________________________________________________________
+; StdDirIDExit
+;
+; This is a way out of Resource Mgr patches that clears the dirID global.
+; It does very little of what StdExit in the Resource Manager does:
+; For example, it does not restore saved registers.
+
+StdDirIDExit	PROC	EXPORT
+
+		move.l	ExpandMem,a0			; point to extended low-memory
+		clr.l	ExpandMemRec.resourceMgrDirID(a0)	; get rid of special dirID (done in StdExit on newer ROMs)
+
+		move.l	(sp)+,a0				; get return address in A0
+		add.l	d0,sp					; pop off parameters
+		jmp		(a0)					; return
+
+		endproc	
+	
+	
+	
+	
+;____________________________________________________________________________________________________
+; CreateResFile(fileName: Str255);
+
+CreateResFileDirIDExit PatchProc	_CreateResFile,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		move.l	4(sp),-(sp)				; pass file name
+	If forRom Then													; <2> kc.start
+		Import	CreateResFile
+		jsr		CreateResFile
+	Else
+		jsrOld							; create resource file
+	Endif															; <2> kc.end
+
+		moveq	#4,d0					; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; HCreateResFile(vRefNum: INTEGER; dirID: LONGINT; fileName: Str255);
+; This procedure needs to be named differently to get linked into LinkedPatches.rsrc by LinkPatch.
+
+CreateDirIDResFile PatchProc	_HCreateResFile,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		move.l	ExpandMem,a0			; point to extended low-memory
+		move.l	4+4(sp),ExpandMemRec.resourceMgrDirID(a0)	; jam in the dirID
+
+		move.w	4+4+4(sp),d0			; get the vRefNum
+
+		move.l	4(sp),-(sp)				; pass file name
+		pea		ReturnHere				; start doing a CreateResFile
+		jsrROM	StdZEntry				; save registers, etc. (D0 is saved across this call)
+		move.w	d0,ioStkFrame+ioVRefNum(a6)	; stuff vRefNum into parameter block
+		jmpROM	AfterStdZEntryInCreateResFile	; join CreateResFile
+ReturnHere
+
+		moveq	#4+4+2,d0				; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; OpenResFile(fileName: Str255): INTEGER;
+
+OpenResFileDirIDExit PatchProc	_OpenResFile,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		subq	#2,sp					; make room for result
+		move.l	2+4(sp),-(sp)			; pass file name
+	If forRom Then													; <2> kc.start
+		Import	OpenResFile
+		jsr		OpenResFile
+	Else
+		jsrOld							; open resource file
+	Endif															; <2> kc.end
+		move.w	(sp)+,4+4(sp)			; propagate result out
+
+		moveq	#4,d0					; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; OpenRFPerm(fileName: Str255; vRefNum: INTEGER; permission: SignedByte): INTEGER;
+
+OpenRFPermDirIDExit PatchProc	_OpenRFPerm,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		subq	#2,sp					; make room for result
+		move.l	2+4+2+2(sp),-(sp)		; pass file name
+		move.w	4+2+4+2(sp),-(sp)		; pass vRefNum
+		move.b	2+4+2+4(sp),-(sp)		; pass permission
+
+		jsrOld							; open resource file
+
+		move.w	(sp)+,4+2+2+4(sp)		; propagate result out
+
+		moveq	#2+2+4,d0				; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; HOpenResFile(vRefNum: INTEGER; dirID: LONGINT; fileName: Str255; permission: SignedByte): INTEGER;
+; This procedure needs to be named differently to get linked into LinkedPatches.rsrc by LinkPatch.
+
+OpenDirIDResFile PatchProc	_HOpenResFile,(Plus,SE,II,Portable,IIci)
+		import	StdDirIDExit
+
+		move.l	ExpandMem,a0			; point to extended low-memory
+		move.l	4+2+4(sp),ExpandMemRec.resourceMgrDirID(a0)	; jam in the dirID
+
+		subq	#2,sp					; make room for result
+		move.l	2+4+2(sp),-(sp)			; pass file name
+		move.w	4+2+4+2+4+4(sp),-(sp)	; pass vRefNum
+		move.b	2+4+2+4(sp),-(sp)		; pass permission
+		jsrROM	ROMOpenRFPerm			; open resource file
+		move.w	(sp)+,4+2+4+4+2(sp)		; propagate result out for HOpenResFile
+
+		moveq	#2+4+4+2,d0				; get size of parameters
+		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
+
+		endproc
+
+;____________________________________________________________________________________________________
+; patch to Create to use dirID
+;
+; This patch should only apply to the Create call in CreateResFile.
+; Since come-from patches are a pain, instead we assume that the “resourceMgrDirID”
+; global will be zero, except for some cases when Create is called from CreateResFile.
+;
+; Come-from patches are now cake with linked patches, so this routine has been changed into
+; a proper come-from patch.  <2>  DTY 6/27/90
+
+
+NewCreate ComeFromPatchProc	_Create,AfterCreateInCreateResFile,(Plus,SE,II,Portable,IIci)
+		move.l	a0,-(sp)				; save pointer to the old parameter block
+
+		sub		#ioHQElSize,sp			; make room for new parameter block
+
+		move.l	ioFileName(a0),ioFileName(sp)	; use the same file name
+		move.w	ioVRefNum(a0),ioVRefNum(sp)		; use the same vRefNum
+		move.b	ioFileType(a0),ioFileType(sp)	; use the same “file type”
+		move.l	ExpandMem,a1					; point to extended low-memory
+		move.l	ExpandMemRec.resourceMgrDirID(a1),d0	; get the dirID
+		move.l	d0,ioDirID(sp)					; put in the dirID
+
+		move.l	sp,a0					; use the new parameter block
+		or.w	#newHFS,d1				; set the HFS bit in the trap word (passed by dispatcher)
+		jsrOld							; Call old _Create
+
+		add		#ioHQElSize,sp			; get rid of the parameter block
+
+		move.l	(sp)+,a0				; get pointer to the old parameter block
+		move.w	d0,ioResult(a0)			; put result in the old parameter block
+
+		rts
+
+		endproc
+
+;____________________________________________________________________________________________________
+; patch to OpenRF to use dirID
+;
+; This patch should only apply to the OpenRF call in ORFCommon.
+; Since come-from patches are a pain, instead we assume that the “resourceMgrDirID”
+; global will be zero, except for some cases when OpenRF is called from ORFCommon.
+;
+; Come-from patches are now cake with linked patches, so this routine has been changed into
+; a proper come-from patch.  <2>  DTY 6/27/90
+
+NewOpenRF ComeFromPatchProc	_OpenRF,AfterOpenRFInORFCommon,(Plus,SE,II,Portable,IIci)
+		move.l	a0,-(sp)				; save pointer to the old parameter block
+
+		sub		#ioHQElSize,sp			; make room for new parameter block
+
+		move.l	ExpandMem,a1			; point to extended low-memory
+		move.l	ExpandMemRec.resourceMgrDirID(a1),d0	; get the dirID
+		move.l	d0,ioDirID(sp)			; put in the dirID
+
+		move.l	ioFileName(a0),ioFileName(sp)	; use the same file name
+		move.w	ioVRefNum(a0),ioVRefNum(sp)		; use the same vRefNum
+		move.b	ioFileType(a0),ioFileType(sp)	; use the same “file type”
+		move.b	ioPermssn(a0),ioPermssn(sp)		; use the same permissions
+		move.l	ioOwnBuf(a0),ioOwnBuf(sp)		; and the same file buffer
+
+		move.l	sp,a0					; use the new parameter block
+		or.w	#newHFS,d1				; set the HFS bit in the trap word (passed by dispatcher)
+		jsrOld							; Call old _OpenRF routine
+
+		move.w	ioRefNum(sp),d1			; get the refNum result into a register
+
+		add		#ioHQElSize,sp			; get rid of the parameter block
+
+		move.l	(sp)+,a0				; get pointer to the old parameter block
+		move.w	d0,ioResult(a0)			; put result in the old parameter block
+		move.w	d1,ioRefNum(a0)			; put refNum in the old parameter block
+
+		rts
+
+		endproc
+
+;____________________________________________________________________________________________________
+; Un-implement (de-announce) _AddReference and _RmveReference traps
+
+InstallResourceMgrExtensions	InstallProc	(Plus,SE,II,Portable,IIci)
+
+		move.w	#$9f,d0
+		_GetTrapAddress newTool			; get the address of the Unimplemented trap
+		move.w	#$1AC,d0
+		_SetTrapAddress newTool			; nuke AddReference
+		move.w	#$1AE,d0
+		_SetTrapAddress newTool			; nuke RmveReference
+
+		rts
+
+		EndProc
+
+;____________________________________________________________________________________________________
+; patch to _SetEOF inside CheckGrow to check for resource file too large
+;
+; CheckGrow is called by AddResource, ChangedResource, SetResInfo, and (more or less) by
+; SetResourceSize above. It calls _SetEOF to grow the file to accomodate these operations.
+; Unfortunately, while the File Mgr supports files > 16 meg, the Resource Mgr does not.
+; This patch checks if the size passed to _SetEOF is too big, and returns eofErr (for lack of
+; a better error) in this case.
+
+ValidateFileSizeInCheckGrow ComeFromPatchProc _SetEOF,AfterSetEOFInCheckGrow,(Plus,SE,II,Portable,IIci)
+	
+		tst.b	(a1)					; get new size of file set up by CheckGrow (a1 points to ioLEOF inside param block)
+										; note: 16 meg = $01000000, so if any bits are set in first byte it’s >= 16 meg
+		beqOld							; no, grow the file as usual
+		move.w	#eofErr,d0				; yes, return an error (not really an eofErr, but it is the end of the resource fork)
+		rts
+
+		endproc
+
 
 		End
diff --git a/Toolbox/ResourceMgr/ResourceMgrPatches.a b/Toolbox/ResourceMgr/ResourceMgrPatches.a
--- a/Toolbox/ResourceMgr/ResourceMgrPatches.a
+++ b/Toolbox/ResourceMgr/ResourceMgrPatches.a
@@ -775,247 +775,6 @@ MyGetResource	PatchProc	_GetResource,(Plus,SE,II,Portable,IIci)
 		EndProc
 
 	endif
-;____________________________________________________________________________________________________
-; StdDirIDExit
-;
-; This is a way out of Resource Mgr patches that clears the dirID global.
-; It does very little of what StdExit in the Resource Manager does:
-; For example, it does not restore saved registers.
-
-StdDirIDExit	PROC	EXPORT
-
-		move.l	ExpandMem,a0			; point to extended low-memory
-		clr.l	ExpandMemRec.resourceMgrDirID(a0)	; get rid of special dirID (done in StdExit on newer ROMs)
-
-		move.l	(sp)+,a0				; get return address in A0
-		add.l	d0,sp					; pop off parameters
-		jmp		(a0)					; return
-
-		endproc	
-	
-	
-	
-	
-;____________________________________________________________________________________________________
-; CreateResFile(fileName: Str255);
-
-CreateResFileDirIDExit PatchProc	_CreateResFile,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		move.l	4(sp),-(sp)				; pass file name
-	If forRom Then													; <2> kc.start
-		Import	CreateResFile
-		jsr		CreateResFile
-	Else
-		jsrOld							; create resource file
-	Endif															; <2> kc.end
-
-		moveq	#4,d0					; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; HCreateResFile(vRefNum: INTEGER; dirID: LONGINT; fileName: Str255);
-; This procedure needs to be named differently to get linked into LinkedPatches.rsrc by LinkPatch.
-
-CreateDirIDResFile PatchProc	_HCreateResFile,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		move.l	ExpandMem,a0			; point to extended low-memory
-		move.l	4+4(sp),ExpandMemRec.resourceMgrDirID(a0)	; jam in the dirID
-
-		move.w	4+4+4(sp),d0			; get the vRefNum
-
-		move.l	4(sp),-(sp)				; pass file name
-		pea		ReturnHere				; start doing a CreateResFile
-		jsrROM	StdZEntry				; save registers, etc. (D0 is saved across this call)
-		move.w	d0,ioStkFrame+ioVRefNum(a6)	; stuff vRefNum into parameter block
-		jmpROM	AfterStdZEntryInCreateResFile	; join CreateResFile
-ReturnHere
-
-		moveq	#4+4+2,d0				; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; OpenResFile(fileName: Str255): INTEGER;
-
-OpenResFileDirIDExit PatchProc	_OpenResFile,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		subq	#2,sp					; make room for result
-		move.l	2+4(sp),-(sp)			; pass file name
-	If forRom Then													; <2> kc.start
-		Import	OpenResFile
-		jsr		OpenResFile
-	Else
-		jsrOld							; open resource file
-	Endif															; <2> kc.end
-		move.w	(sp)+,4+4(sp)			; propagate result out
-
-		moveq	#4,d0					; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; OpenRFPerm(fileName: Str255; vRefNum: INTEGER; permission: SignedByte): INTEGER;
-
-OpenRFPermDirIDExit PatchProc	_OpenRFPerm,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		subq	#2,sp					; make room for result
-		move.l	2+4+2+2(sp),-(sp)		; pass file name
-		move.w	4+2+4+2(sp),-(sp)		; pass vRefNum
-		move.b	2+4+2+4(sp),-(sp)		; pass permission
-
-		jsrOld							; open resource file
-
-		move.w	(sp)+,4+2+2+4(sp)		; propagate result out
-
-		moveq	#2+2+4,d0				; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; HOpenResFile(vRefNum: INTEGER; dirID: LONGINT; fileName: Str255; permission: SignedByte): INTEGER;
-; This procedure needs to be named differently to get linked into LinkedPatches.rsrc by LinkPatch.
-
-OpenDirIDResFile PatchProc	_HOpenResFile,(Plus,SE,II,Portable,IIci)
-		import	StdDirIDExit
-
-		move.l	ExpandMem,a0			; point to extended low-memory
-		move.l	4+2+4(sp),ExpandMemRec.resourceMgrDirID(a0)	; jam in the dirID
-
-		subq	#2,sp					; make room for result
-		move.l	2+4+2(sp),-(sp)			; pass file name
-		move.w	4+2+4+2+4+4(sp),-(sp)	; pass vRefNum
-		move.b	2+4+2+4(sp),-(sp)		; pass permission
-		jsrROM	ROMOpenRFPerm			; open resource file
-		move.w	(sp)+,4+2+4+4+2(sp)		; propagate result out for HOpenResFile
-
-		moveq	#2+4+4+2,d0				; get size of parameters
-		jmp		StdDirIDExit			; clear the dirID and exit (done by StdExit on newer ROMs)
-
-		endproc
-
-;____________________________________________________________________________________________________
-; patch to Create to use dirID
-;
-; This patch should only apply to the Create call in CreateResFile.
-; Since come-from patches are a pain, instead we assume that the “resourceMgrDirID”
-; global will be zero, except for some cases when Create is called from CreateResFile.
-;
-; Come-from patches are now cake with linked patches, so this routine has been changed into
-; a proper come-from patch.  <2>  DTY 6/27/90
-
-
-NewCreate ComeFromPatchProc	_Create,AfterCreateInCreateResFile,(Plus,SE,II,Portable,IIci)
-		move.l	a0,-(sp)				; save pointer to the old parameter block
-
-		sub		#ioHQElSize,sp			; make room for new parameter block
-
-		move.l	ioFileName(a0),ioFileName(sp)	; use the same file name
-		move.w	ioVRefNum(a0),ioVRefNum(sp)		; use the same vRefNum
-		move.b	ioFileType(a0),ioFileType(sp)	; use the same “file type”
-		move.l	ExpandMem,a1					; point to extended low-memory
-		move.l	ExpandMemRec.resourceMgrDirID(a1),d0	; get the dirID
-		move.l	d0,ioDirID(sp)					; put in the dirID
-
-		move.l	sp,a0					; use the new parameter block
-		or.w	#newHFS,d1				; set the HFS bit in the trap word (passed by dispatcher)
-		jsrOld							; Call old _Create
-
-		add		#ioHQElSize,sp			; get rid of the parameter block
-
-		move.l	(sp)+,a0				; get pointer to the old parameter block
-		move.w	d0,ioResult(a0)			; put result in the old parameter block
-
-		rts
-
-		endproc
-
-;____________________________________________________________________________________________________
-; patch to OpenRF to use dirID
-;
-; This patch should only apply to the OpenRF call in ORFCommon.
-; Since come-from patches are a pain, instead we assume that the “resourceMgrDirID”
-; global will be zero, except for some cases when OpenRF is called from ORFCommon.
-;
-; Come-from patches are now cake with linked patches, so this routine has been changed into
-; a proper come-from patch.  <2>  DTY 6/27/90
-
-NewOpenRF ComeFromPatchProc	_OpenRF,AfterOpenRFInORFCommon,(Plus,SE,II,Portable,IIci)
-		move.l	a0,-(sp)				; save pointer to the old parameter block
-
-		sub		#ioHQElSize,sp			; make room for new parameter block
-
-		move.l	ExpandMem,a1			; point to extended low-memory
-		move.l	ExpandMemRec.resourceMgrDirID(a1),d0	; get the dirID
-		move.l	d0,ioDirID(sp)			; put in the dirID
-
-		move.l	ioFileName(a0),ioFileName(sp)	; use the same file name
-		move.w	ioVRefNum(a0),ioVRefNum(sp)		; use the same vRefNum
-		move.b	ioFileType(a0),ioFileType(sp)	; use the same “file type”
-		move.b	ioPermssn(a0),ioPermssn(sp)		; use the same permissions
-		move.l	ioOwnBuf(a0),ioOwnBuf(sp)		; and the same file buffer
-
-		move.l	sp,a0					; use the new parameter block
-		or.w	#newHFS,d1				; set the HFS bit in the trap word (passed by dispatcher)
-		jsrOld							; Call old _OpenRF routine
-
-		move.w	ioRefNum(sp),d1			; get the refNum result into a register
-
-		add		#ioHQElSize,sp			; get rid of the parameter block
-
-		move.l	(sp)+,a0				; get pointer to the old parameter block
-		move.w	d0,ioResult(a0)			; put result in the old parameter block
-		move.w	d1,ioRefNum(a0)			; put refNum in the old parameter block
-
-		rts
-
-		endproc
-
-;____________________________________________________________________________________________________
-; Un-implement (de-announce) _AddReference and _RmveReference traps
-
-InstallResourceMgrExtensions	InstallProc	(Plus,SE,II,Portable,IIci)
-
-		move.w	#$9f,d0
-		_GetTrapAddress newTool			; get the address of the Unimplemented trap
-		move.w	#$1AC,d0
-		_SetTrapAddress newTool			; nuke AddReference
-		move.w	#$1AE,d0
-		_SetTrapAddress newTool			; nuke RmveReference
-
-		rts
-
-		EndProc
-
-;____________________________________________________________________________________________________
-; patch to _SetEOF inside CheckGrow to check for resource file too large
-;
-; CheckGrow is called by AddResource, ChangedResource, SetResInfo, and (more or less) by
-; SetResourceSize above. It calls _SetEOF to grow the file to accomodate these operations.
-; Unfortunately, while the File Mgr supports files > 16 meg, the Resource Mgr does not.
-; This patch checks if the size passed to _SetEOF is too big, and returns eofErr (for lack of
-; a better error) in this case.
-
-ValidateFileSizeInCheckGrow ComeFromPatchProc _SetEOF,AfterSetEOFInCheckGrow,(Plus,SE,II,Portable,IIci)
-	
-		tst.b	(a1)					; get new size of file set up by CheckGrow (a1 points to ioLEOF inside param block)
-										; note: 16 meg = $01000000, so if any bits are set in first byte it’s >= 16 meg
-		beqOld							; no, grow the file as usual
-		move.w	#eofErr,d0				; yes, return an error (not really an eofErr, but it is the end of the resource fork)
-		rts
-
-		endproc
-
-;____________________________________________________________________________________________________
-
 
 ;————————————————————————————————————————————————————————————————————————————————————————————————————
 ;	STILL TO DO
diff --git a/Toolbox/ResourceMgr/ResourceOverridePatches.a b/Toolbox/ResourceMgr/ResourceOverridePatches.a
--- a/Toolbox/ResourceMgr/ResourceOverridePatches.a
+++ b/Toolbox/ResourceMgr/ResourceOverridePatches.a
@@ -203,6 +203,10 @@
 ;									implemented.
 ;		 <1>	10/17/91	DTY		first checked in
 
+	IF &TYPE('PrNonPortable') = 'UNDEFINED' THEN
+		PrNonPortable: EQU 1
+	ENDIF
+
 			include		'Traps.a'
 			include		'SysEqu.a'
 			include		'SysErr.a'
@@ -493,7 +497,14 @@ localSize		equ		*
 				clr.w	oneDeepCall(a6)					; <26> It’s not one deep after all
 				bsr		SyncTopOverrideMap				; Set up the override maps
 @isCount1Types											; <24>
+				tst.b	ROMMapInsert
+				bz.s	@normalCase						; <42> No special case if ROMMapInsert is not set
+				move.w	CurMap,d0						; <42>
+				cmp.w	SysMap,d0						; <42> Is the system the current resource file?
+				beq.s	@specialCase
+@normalCase
 				clr.b	ResOneDeep						; <27> Clear ResOneDeep so CountTypes will count all resources left in the chain.
+@specialCase
 				subq	#2,sp							; Room for word result
 				jsrOld									; Call through to the Resource Manager
 				move.w	(sp)+,numTypes(a6)				; Pass the result back to the caller
@@ -1437,6 +1448,8 @@ localSize		equ		*
 				move.l	realNextMap(a1),mNext(a0)		; <11> Restore the chain below this map
 				move.l	realTopMap(a1),TopMapHndl		; <11> Restore the real top map
 @notOneDeep
+				move.b	ResOneDeep,-(sp)
+				move.b	RomMapInsert,-(sp)
 				link	a6,#RMgrStack					; Create a stack frame for CheckLoad
 				clr.w	ioStkFrame+ioVRefNum(a6)		; so that it has a IOPB where it
 				clr.w	ioStkFrame+ioFileType(a6)		; expects it on the stack
@@ -1444,6 +1457,8 @@ localSize		equ		*
 				move.l	jCheckLoad,a0					; Handy dandy vector to see if a resource is loaded
 				jsr		(a0)							; Go load the resource if necessary
 				unlk	a6								; Toss the parameter block
+				move.b	(sp)+,RomMapInsert
+				move.b	(sp)+,ResOneDeep
 				move.l	a0,resHandle(a6)				; Return the handle
 				move.l	a0,HSCHandle					; <37> And save it in the cache
 @exitGetIndResourceOverride
@@ -2059,6 +2074,7 @@ FlushFontsCallThroughCommon
 				move.l	(a1),a0							; Nail the next one too
 				_DisposeHandle
 				clr.l	(a1)
+				clr.l	LastFOND
 				bra.s	Exit
 
 DontFlushFonts
diff --git a/Toolbox/ScriptMgr/International.r b/Toolbox/ScriptMgr/International.r
--- a/Toolbox/ScriptMgr/International.r
+++ b/Toolbox/ScriptMgr/International.r
@@ -646,7 +646,7 @@
 
 	resource 'STR#' (kKeybdMenuItemsID, sysHeap, purgeable) { {			// strings for menu items			<x121><25>
 		"\0x00";														// marker for default keybd			<2><9>
-		"About Keyboards";												//									<2><23>
+		"About Keyboards…";												//									<2><23>
 //		"Next Script";													// currently not used
 //		"Next Keyboard in Script";										// currently not used
 	} };
@@ -740,7 +740,7 @@
 			{14, 15, 46, 447},
 			StaticText {
 				disabled,
-				"About Keyboards"										//	<23>
+				"About Keyboards…"										//	<23>
 			}
 		}
 	};
@@ -763,7 +763,7 @@
 			{14, 17, 44, 422},
 			StaticText {
 				disabled,
-				"About Keyboards"										//	<23>
+				"About Keyboards…"										//	<23>
 			}
 		}
 	};
@@ -792,7 +792,7 @@
 			{14, 15, 46, 447},
 			StaticText {
 				disabled,
-				"About Keyboards"					
+				"About Keyboards…"					
 			}
 		}
 	};
diff --git a/Toolbox/ScriptMgr/RomanNewJust.a b/Toolbox/ScriptMgr/RomanNewJust.a
--- a/Toolbox/ScriptMgr/RomanNewJust.a
+++ b/Toolbox/ScriptMgr/RomanNewJust.a
@@ -10,9 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM4>	 9/17/92	kc		Fix bug in PortChExtra. The rts was missing, and it was falling
-;									through to the next procedure. This was benign until we added a
-;									vector to the end of the procedure.
 ;		<24>	  7/8/92	HA		#1035313 <PKE>: In NChar2Pixel, when we call StdTxMeas, we use
 ;									the fixed value that is returned in field fontAdj field of QD
 ;									globals . This would make NC2P more accurate and consistent with
@@ -2682,8 +2679,6 @@ GetPortChExtra
 			move.l	(sp)+,d2				; get real chExtra for our size
 @donePortChExtra							;
 
-			rts
-
 			endproc
 
 ; -----------------------------------------------------------------------------	<x5>
diff --git a/Toolbox/ScriptMgr/ScriptMgrExtensions.a b/Toolbox/ScriptMgr/ScriptMgrExtensions.a
--- a/Toolbox/ScriptMgr/ScriptMgrExtensions.a
+++ b/Toolbox/ScriptMgr/ScriptMgrExtensions.a
@@ -12,12 +12,7 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM8>	 5/21/93	CSS		Update fixes from Reality per P. Edberg's review:
-;		<12>	  4/2/93	ngk		Fix bug with gestalt routine. It was returning a long instead of
-;									a short. This is bad with Pascal calling conventions.
-;	   <SM7>	11/19/92	RB		When looking for the standard Chicago font, look in ROM first.
 ;	   <SM6>	 11/6/92	SWC		Changed PackMacs.a->Packages.a.
-;	   <SM5>	10/27/92	CSS		Changed short branch to word branch.
 ;		<10>	  7/6/92	HA		##1034403 <PKE>: Fixed bug in StyledLineBreak, now I made sure
 ;									to return the correct offset when the (text buffer ends with a
 ;									carriage return) AND (textStart parameter is > 0 ) AND the whole
@@ -100,7 +95,7 @@ gestaltScriptMgr
 
 ; initialize loop, set up default return values
 			move.l	gestaltSelector(a6),d0				; selector value
-			move.w	#gestaltUndefSelectorErr,result(a6) ; assume unknown selector	<12>
+			move.l	#gestaltUndefSelectorErr,result(a6) ; assume unknown selector
 			lea	gestaltSMgrTable,a1
 
 ; loop to find Gestalt selector in table
@@ -599,7 +594,6 @@ MacPlusISOOptSp	equ	$1004				; bits set for Opt & Space on Mac+ ISO		<7>
 		subq	#4,sp						; space for return value
 		move.l	#'FOND',-(sp)				; push type
 		move.w	d4,-(sp)					; push next id in range
-		MOVE.W	#MapTrue,RomMapInsert	; look in ROM first								<SM7> rb
 		_GetResource
 		tst.l	(sp)+						; was it there?
 		bne.s	@popRetnAndSetSysFondId		; if yes, go reset
@@ -1033,7 +1027,6 @@ FixFond
 			subq	#4,sp						; return room
 			move.l	#'FOND',-(sp)				; see if this FOND exists
 			move.w	(a2),-(sp)					; id, get the id from a2 pointer <47>
-			MOVE.W	#MapTrue,RomMapInsert		; look in ROM first						<SM7> rb
 			_GetResource
 			tst.l	(sp)+						; was it there?
 			bne.s	@fixFondDone				; yes, ok
@@ -1689,7 +1682,7 @@ haveValidScript								;										<38>
 			move.l	d0,sourceLen(a6)		; save length
 			_PtrToHand						; make new handle containing copy of text
 			move.w	d0,errCode(a6)			; save err code
-			bne		lwrTrUnlk				; if error in PtrToHand, quit <SM5> CSS
+			bne.s	lwrTrUnlk				; if error in PtrToHand, quit
 			move.l	a0,sourceHndl(a6)		; save new source handle
 			move.l	sourceLen(a6),d0		; get length again
 			_NewHandle						; make new handle with random contents
diff --git a/Toolbox/ScriptMgr/ScriptMgrInit.a b/Toolbox/ScriptMgr/ScriptMgrInit.a
--- a/Toolbox/ScriptMgr/ScriptMgrInit.a
+++ b/Toolbox/ScriptMgr/ScriptMgrInit.a
@@ -13,28 +13,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM11>	 5/27/93	CSS		Don't initialize emNumer and emDenom because these are obsolete
-;									fields.
-;	  <SM10>	 5/21/93	CSS		Initialize some expandmem: emNumer, emDenom, emScriptAppGlobals
-;									from ScriptMgrExtTail.a.
-;	   <SM9>	 5/21/93	CSS		Rollin from Reality:
-;		<33>	 5/19/93	PKE		#1086200: Change roman dispatch table initialization to handle
-;									nil entries in romanDispTable by setting the corresponding
-;									dispatch table entry to be nil. Then make nil entries in
-;									romanDispTable for IsSpecialFont and RawPrinterValues for ROM
-;									builds.
-;	   <SM8>	 1/27/93	CSS		Rollin fix to auto-install scripts. This fix loads the itlb
-;									resource for each script an determines if the auto-install bit
-;									(for simple scripts) is set. If it is this patch installs the
-;									script. This fixes a bug Radar#1060646 "WorldScript I and/or
-;									Cyrillic does not work correctly." Wherein, the Cyrillic script
-;									was not installing. Also, fixed the vectors for getscript and
-;									setscript for roman scripts to call the new routines
-;									"RomanGetScript" and "RomanSetScript." This is per Radar bug
-;									#1025998.
-;	   <SM7>	12/15/92	CSS		Look for dictionary manager in ROM.
-;	   <SM6>	11/19/92	RB		When looking for the standard Chicago font, look in ROM first.
-;	   <SM5>	 10/2/92	PN		Add initDictionary to the initialization process
 ;		<32>	 6/17/92	HA		#1029756,<PKE>: Removing StyledlineBreak  to
 ;									ScriptMgrExtensions.a.
 ;		<31>	 6/12/92	FM		More changes to bring the rom build up to date with system 7
@@ -654,11 +632,8 @@ BootConf
 		move.w	#(sisHighCall-smGetScript)/2,d0	; number of entries - 1
 		move.l	a2,-(sp)						; save a2
 @romanTabLoop
-		movea.l	#0,a2							; assume 0 entry in dispatch table		<33>
 		move.w	(a1)+,d1						; get offset from romanDispTable
-		beq.s	@gotAddress						; if 0, leave entry as 0				<33>
 		lea		0(a4,d1.w),a2					; make it a real vector
-@gotAddress										;										<33>
 		move.l	a2,(a0)+						; stuff it in table
 		dbra	d0,@romanTabLoop				; if more, keep going
 		move.l	(sp)+,a2						; restore a2
@@ -669,7 +644,6 @@ BootConf
 		subq	#4,sp							; return room
 		move.l	#'FOND',-(sp)					; see if we have real Chicago
 		move.w	d4,-(sp)						; id
-		MOVE.W	#MapTrue,RomMapInsert			; look in ROM first								<SM6> rb
 		_GetResource
 		tst.l	(sp)+							; was it there?
 		bne.s	@SkipResetFond					; yes, skip
@@ -704,129 +678,6 @@ BadError								;								<05/30/89 pke><9>
 
 RomanDone
 	
-; -----------------------------------------------------------------------------
-; Perform auto-initialization of script	systems based on info in their itlb	 <SM8> CSS
-
-; Skip if Opt-E or Shift														
-		btst	#0,KeyMap+7		; shift key down?								
-		bne		DoneAutoInit	; if yes, skip script install					
-		btst	#2,KeyMap+7		; option key down?								
-		beq.s	@noSkipInstall	; no, skip check.					
-		subq	#2,sp			; make room for Boolean result						
-		move.w	#'e',-(sp)		; push 'e' as the char to test for					
-
-		import	iTestLetter		;													
-		bsr		iTestLetter		; returns TRUE if key with Roman 'e' being pressed	
-
-		tst.b	(sp)+			; what was the result?								
-		bne		DoneAutoInit	; if Opt-e, skip script install						
-@noSkipInstall					;				
-
-; no Opt-E, go ahead
-		with	scriptRecord,itlbRecord,ItlbExtRecord
-		GetSMgrCore	a4							; reset a4 to point to SMgrRecord
-		move.w	#smgrCount-1,d3					; for all entries.
-			
-@SimpleLoopStart
-		move.w	d3,d0							; copy index.
-		lsl.w	#2,d0							; long word offset.
-		move.l	smgrEntry(a4,d0.w),d0			; script installed?
-		bne		@NextSimple						; yes -> try next entry.
-		
-		subq.l	#4,sp							; make room for handle.
-		move.l	#'itlb',-(sp)					; push bundle type.
-		move.w	d3,-(sp)						; push bundle number.
-		_GetResource							; load the resource.
-		move.l	(sp)+,d0						; handle = nil?
-		beq		@NextSimple						; yes -> try next entry.
-
-; we have a prospective itlb, so check if the simple bit is on
-		move.l	d0,a3							; load bundle handle.
-		move.l	(a3),a0							; load bundle pointer.
-		btst.b	#smsfAutoInit,itlbFlags+1(a0)	; auto-init it? (+1 for mem test)
-		beq		@ReleaseSimple					; no, try next one
-
-; we have a simple script, so allocate the record, load the font numbers
-
-		move.l	itlbLocalSize(a0),d0			; requested size for script locals
-		cmp.l	#scriptSize,d0					; must be ≥ ScriptRecord size
-		bcc.s	@doneFixLocalRecordSize			; if it already is, skip fix
-		move.l	#scriptSize,d0					; if too small, fix it
-@doneFixLocalRecordSize
-		_NewPtr	sys,clear						; allocate script local data
-		bne		BadError						; if error, bail
-		move.l	a0,a2							; save entry pointer.
-		move.w	d3,d0							; get script number
-		asl.w	#2,d0							; *4 for long array
-		move.l	a2,smgrEntry(a4,d0.w)			; store in SMgr globals.
-	
-; Use SimpleTable to initialize scriptVersion, scriptCreator, scriptFile instead		
-; of explicitly initializing them here.
-
-; Copy font information from itlb, and check it.
-; For 7.0, this is moved to InitScripts.												
-
-; copy relevant entries from Roman ScriptRecord to simple ScriptRecord
-; a2=simple ScriptRecord
-
-		move.l	smgrEntry+(smRoman*4)(a4),a0	; address of roman globals
-		lea		SimpleTable,a1					; load table pointer.
-@SimpleEntryLoop	
-		move.w	(a1)+,d0						; get offset (and trap code).
-		blt.s	@ReleaseSimple					; last entry is -1.						
-		move.w	0(a0,d0.w),0(a2,d0.w)			; copy Roman word to simple scriptRecord
-		bra.s	@SimpleEntryLoop				; do the next routine.
-
-@ReleaseSimple
-; Don't bother releasing anymore														
-		
-@NextSimple		
-		subq	#1,d3							; don't do Roman
-		bgt.s	@SimpleLoopStart				; keep going until 0 or less
-		bra		DoneAutoInit					; clean exit							
-		endWith									;
-
-; -----------------------------------------------------------------------------
-; Table of ScriptRecord fields to copy from Roman when auto-initializing
-; a script.
-;
-; Moved initialization of scriptVersion, scriptCreator, scriptFile here instead
-; of explicitly initializing them above.
-;
-; Changed terminator to be -1, cause one of the fields we want to initialize
-; with this table has an offset of 0.
-; -----------------------------------------------------------------------------
-
-SimpleTable
-			with	ScriptRecord
-			dc.w	scriptVersion				;								
-			dc.w	scriptCreator				;			
-			dc.w	scriptCreator+2				; (long)						
-			dc.w	scriptFile					;								
-			dc.w	scriptFile+2				; (long)						
-			dc.w	scriptDispTable
-			dc.w	scriptDispTable+2			; (long)
-			dc.w	scriptDispLow
-			dc.w	scriptDispHigh
-			dc.w	scriptPrint
-			dc.w	scriptPrint+2				; (long)
-			dc.w	scriptTrap
-			dc.w	scriptTrap+2				; (long)
-			dc.w	scriptName
-			dc.w	scriptName+2				; (long)
-			dc.w	$ffff						; now -1 is terminato
-			endwith
-
-DoneAutoInit
-
-; -----------------------------------------------------------------------------
-; Update from ScriptMgrExtTail.a <SM10> CSS
-;
-; Initialize emScriptAppGlobals field.
-;
-			move.l	ExpandMem,a0
-			move.l	#-1,ExpandMemRec.emScriptAppGlobals(a0)
-
 SMgrInitDone
 ;Roll in from ScripMgrExtTail.a
 	IF forROM then
@@ -845,27 +696,6 @@ SmgrExit
 
 	endWith
 
-;=======================================================================
-;
-;	InitDictionaryMgr
-;		Called to load the 'dimg' file which contains the 
-;		Dictionary Manager code.  We load the resources stick
-;		them into expand mem, and call it a day.
-;		JH, 10-9-91
-;========================================================================
-
-InitDictionaryMgr
-			with	ExpandMemRec
-			clr.l	-(sp)								;room for our handle
-			move.l	#'dimg',-(sp)						;looking for a 'dimg' resource
-			move.w	#-16385,-(sp)						;with an id of -16385
-			move.w	#MapTrue,RomMapInsert				;check if resource is in ROM (it should be) <SM7> CSS
-			_GetResource								;see if we can get it
-			move.l	ExpandMem,a0						;ptr to expandmem rec into a0
-			move.l	(sp)+,emDictionaryMgrPackHandle(a0)	;move the handle into our expandmem handle
-	;		move.w	#0,emDictionaryMgrUseCount(a0)		;0 our count
-			rts
-			endwith	;ExpandMemRec
 ; -----------------------------------------------------------------------------
 ; Utility routine to allocate and clear global space
 ; (was above BufPtr in old systems)  <10/10/88ldc>
@@ -1125,7 +955,7 @@ utilTable
 		export	romanDispTable
 		import	BitBucket, BitBucketReg
 		
-		import	RomanGetScript, RomanSetScript, CharByte						; <SM8> CSS
+		import	rGetScript, rSetScript, CharByte
 		import	Translit, FindWord, HiliteText
 		import	VisibleLength
 	  IF forRom THEN								;							<21>
@@ -1150,8 +980,8 @@ utilTable
 
 romanDispTable										;							<04/26/89 pke>
 	 IF (NOT forRom) THEN							;							<x2><x4><x10><21>
-		dc.w	RomanGetScript	- romanDispTable	; GetScript		(12)		<x10> <SM8> CSS
-		dc.w	RomanSetScript	- romanDispTable	; SetScript		(14)		<x10> <SM8> CSS
+		dc.w	rGetScript		- romanDispTable	; GetScript		(12)		<x10>
+		dc.w	rSetScript		- romanDispTable	; SetScript		(14)		<x10>
 		dc.w	CharByte		- romanDispTable	; CharByte		(16)
 		dc.w	BitBucket		- romanDispTable	; CharType		(18)		<26>
 		dc.w	BitBucket		- romanDispTable	; Pixel2Char	(20)
@@ -1173,8 +1003,8 @@ romanDispTable										;							<04/26/89 pke>
 		dc.w	BitBucket		- romanDispTable	; NMeasureJust	(52)
 		dc.w	BitBucket		- romanDispTable	; NPortionText	(54)
 	 ELSE
-		dc.w	RomanGetScript	- romanDispTable	; GetScript		(12)		<x10> <SM8> CSS
-		dc.w	RomanSetScript	- romanDispTable	; SetScript		(14)		<x10> <SM8> CSS
+		dc.w	rGetScript		- romanDispTable	; GetScript		(12)		<x10>
+		dc.w	rSetScript		- romanDispTable	; SetScript		(14)		<x10>
 		dc.w	CharByte		- romanDispTable	; CharByte		(16)
 		dc.w	CharType		- romanDispTable	; CharType		(18)		<26>
 		dc.w	Pixel2Char		- romanDispTable	; Pixel2Char	(20)
diff --git a/Toolbox/ScriptMgr/ScriptMgrKbdMenu.a b/Toolbox/ScriptMgr/ScriptMgrKbdMenu.a
--- a/Toolbox/ScriptMgr/ScriptMgrKbdMenu.a
+++ b/Toolbox/ScriptMgr/ScriptMgrKbdMenu.a
@@ -9,9 +9,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;		<43>	  4/2/93	YK		Initialize D0 to zero before getting a length byte into the
-;									lowest byte.
-;		<42>	 3/27/93	YK		Use system script font for ‘About Keyboards…’ menu item.
 ;		<41>	 1/19/93	PKE		Update include file names: PackMacs.a->Packages.a. No effect on
 ;									objects.
 ;		<40>	 6/26/92	SMB		#1033660,<kst>: When we realized that Simplified Chinese
@@ -290,7 +287,7 @@ InitKeybdMenu
 		_UseResFile							;													<14>
 
 		move.b	ResLoad,-(sp)				;													<14>
-		st		ResLoad						; set to true										<14>
+		move.b	#$FF,ResLoad				; set to true										<14>
 
 ; setup defaultMark for the menu
 		move.w	#KeybdDefaultMrk,defaultMark(a6)	; initialize to empty, 0x00
@@ -299,10 +296,10 @@ InitKeybdMenu
 		move.w	#DefMarkIndex,-(sp)			; string index										<34>
 		import	localGetIndString			;													<34>
 		bsr		localGetIndString			; making a pString (rather than a ptr to text)													<34>
-		sf		ResLoad						; reset to F										<14>
+		clr.b	ResLoad						; reset to F										<14>
 
 		tst.b	NextItemString(a6)			; do we have a string?								<34>
-		beq.s	@useDefMarker				; if empty, use default marker						<32>
+		beq		@useDefMarker				; if empty, use default marker						<32>
 ; fetch the localized character
 		move.b	NextItemString+1(a6),defaultMark+1(a6)	; write out the default marker byte	(skip length)	<34>
 @useDefMarker
@@ -341,9 +338,9 @@ InitKeybdMenu
 		bsr		BuildIMTable				; Init the ItemInstalledRec table for input methods	<21>
 		bsr		BuildKCHRTable				; Init the ItemInstalledRec table for KCHRs			<21>
 ;-----------------------------------------------------------------------------------
-		st		ResLoad						; must be T for _IUTextOrderSys						<14>
+		move.b	#$FF,ResLoad				; must be T for _IUTextOrderSys						<14>
 		bsr		SortItems					; sort the Items 									<10>
-		sf		ResLoad						; reset to F										<14>
+		clr.b	ResLoad						; reset to F										<14>
 ;-------------------------------------------
 
 ; Allocate AuxKeyboardMenuInfo record for IconSuite handles for MF and other info for SystemMenu patch
@@ -375,7 +372,7 @@ InitKeybdMenu
 ; equivalent, cmd-opt-space bar (to switch between keybds. in a script) works.	 				<15>
 		move.w	#1,menuItem(a6)				; initialize earlier for bra						<15>
 		tst.b	smgrKbdMenuAvail(a1)		; do we want to display a menu?						<15>
-		beq.s	@BuildMenuRec				;													<15>
+		beq		@BuildMenuRec				;													<15>
 ; Do we already have a menu? (are we called from RebuildKeybdMenu?)
 		tst.b	rebuildFlag(a6)				; do we already have a menu?						<21>
 		bne.s	@GotMenuH					; bra if so											<21>
@@ -389,29 +386,21 @@ InitKeybdMenu
 @GotMenuH
 
 ; Add the About Keyboards… menuitem followed by a disabled line									<10>
-		st		ResLoad						; set to true										<35>									<14>
+		move.b	#$FF,ResLoad				; set to true										<35>									<14>
 		pea		NextItemString(a6)			; ptr to Str255										<34>
 		move.w  #kKeyboardMenuItemsID,-(sp)	; strListID											<34><38>
 		move.w	#AboutKybdsIndex,-(sp)		; string index										<34>
 		import	localGetIndString			;													<34>
 		bsr		localGetIndString			;													<34>
-		sf		ResLoad						; reset to false									<35>
+		clr.b	ResLoad						; reset to false									<35>
 		tst.b	NextItemString(a6)			; do we have the string								<34>
-		beq.s	@BuildMenuRec				; no, don't add AboutKeyboards…						<34>
+		beq		@BuildMenuRec				; no, don't add AboutKeyboards…						<34>
 
 ; name the menu item
 		move.l	menuH(a6),-(sp)
 		pea		NextItemString(a6)			; name of this KCHR: pString
 		move.w	menuItem(a6),-(sp)			; insert ‘after’ this menuItem
 		_InsMenuItem
-		move.l	menuH(a6),-(sp)
-		move.w	#1,-(sp)					; the first item has a script code.		<42>
-		move.w	#$1C,-(sp)
-		_SetItemCmd
-		move.l	menuH(a6),-(sp)
-		move.w	#1,-(SP)
-		move.w	#smSystemScript,-(sp)		; the script code is the sytem script	<42>
-		_SetItmIcon
 		add.w	#1,menuItem(a6)
 		add.w	#AuxMenuInfoSize,a2			; point past 1st menuItem now
 		bsr		AddDisabledLine				; separate scripts by a disabled line				<8>
@@ -457,7 +446,7 @@ InitKeybdMenu
 @ScriptItemsLoop	
 		; if script not enabled, loop for next input. (a0 set above)
 		tst.b	scriptEnabled(a0)			; script enabled?
-		beq.s	@NextInput					; bra to fetch next input item if not a valid script
+		beq		@NextInput					; bra to fetch next input item if not a valid script
 
 ; find out the type of input to build the iconsuite
 		move.b	itemInpuType(a4), itemType(a2)	; type of input								<25>
@@ -496,7 +485,7 @@ InitKeybdMenu
 ; Get next input!
 		sub.w	#1,d4						; are we out of inputs/menuItems to add?
 	IF NOT DoCmdKeyEquivalents THEN			; bra if done									<8>
-		beq.s	@SetTitle					;									 			<3>;temporary<6>
+		beq		@SetTitle					;									 			<3>;temporary<6>
 	ELSE
 		beq		@SetCmdKeyEquiv				; add Next Keyboard and Next Script 			<3>;temporary<6>
 	ENDIF
@@ -535,7 +524,7 @@ InitKeybdMenu
 @SetTitle
 		GetSmgrCore a3								; get script manager core.				<15>
 		tst.b	smgrKbdMenuAvail(a3)				; do we want to display a menu?			<15>
-		beq.s	@Cleanup							;										<15>
+		beq		@Cleanup							;										<15>
 		move.l	menuH(a6),a0
 		move.l	(a0),a0								; deref
 ; stuff the length (5 bytes) and special byte into the name: 01 indicates a handle is following
@@ -619,7 +608,7 @@ CountMenuContents
 		bz.s	@GetNewIMs					; No handle, so assume no old input method.  Go find some new ones.  <26>
 		move.l	d0,a0						;											<26>
 		tst.b	scriptEnabled(a0)			; script enabled?							<25>
-		beq.s	@GetNewIMs					; no Japanese script so get only new IMs now	<25>
+		beq		@GetNewIMs					; no Japanese script so get only new IMs now	<25>
 ; get handle to table of input methods
 		move.l	intfArray(a0),a0			; load table handle							<25>
 		move.l	(a0),a0						; load table pointer						<25>
@@ -857,7 +846,7 @@ BuildIMTable
 		move.l	(sp), itemInfo(a4)			; component identifier: use as input on next call	
 		move.l	(sp)+, compID(a6)			; need for next FindNextComponent call
 		cmp.l	#0, itemInfo(a4)			; 0 => no more matching components
-		beq.s	@DoOldIMs					;											<25>
+		beq		@DoOldIMs					;											<25>
 
 @GetIMInfo
 ; must create a handle for the name
@@ -883,9 +872,9 @@ BuildIMTable
 		move.l	itemHandle(a4),a0			; double deref handle
 		move.l	(a0),a0						; pointer to name
 		lea		itemName(a4),a1				; ptr to name space on stack
-		moveq	#0,D0						; clear high bytes for BlockMove
-		move.b  (a0)+,d0					; get the length of this string
+		move.b  (a0),d0						; get the length of this string
 		move.b	d0,(a1)+					; store the length in the string (make a pString!)
+		add.w	#1,a0
 		move.w  d0,d1						; save the length
 		_BlockMove							; copy it into theString
 		clr.b   0(a1,d1)					; set terminator byte
@@ -910,7 +899,7 @@ BuildIMTable
 @DoOldIMs
 ; now get old input methods
 		btst.b	#HaveOldJapanIMbit,CJKcount(a6)	; optimized: is there an old JIM		<34>
-		beq.s	@NoMoreIMs					; no, so done								<32>
+		beq		@NoMoreIMs					; no, so done								<32>
 		GetSMgrCore	a1						; get Script Mgr core						<25>
 		move.l	smgrEntry+(smJapanese*4)(a1),a1	; get handle to the Japanese system globals	<25> <26><34>
 
@@ -927,7 +916,7 @@ BuildIMTable
 		move.l	(a2)+,a0					; input method source
 ; check if this input method is "ready" before installing it							<38>
 		btst.b	#intfFReady-8,intfFlags(a0)	; is the IM ready?							<38>
-		bne.s	@InstallIM					; yes, install it							<38>
+		bne		@InstallIM					; yes, install it							<38>
 		add		#1,d5						; no, so be sure to decrement totals		<38>
 		bra.s	@GetNextIM					; fetch the next one						<38>
 			
@@ -938,8 +927,9 @@ BuildIMTable
 		lea		intfName(a0),a0				; changed from intfFile to intfName			<38>
 		lea		itemName(a4),a1				; ptr to name space on stack
 		clr.l	d0							; clear this space!							<27>
-		move.b  (a0)+,d0					; get the length of this string
+		move.b  (a0),d0						; get the length of this string
 		move.b	d0,(a1)+					; store the length in the string (make a pString!)
+		add.w	#1,a0
 		move.w  d0,d1						; save the length
 		_BlockMove							; copy it into theString
 		clr.b   0(a1,d1)					; set terminator byte
@@ -996,7 +986,7 @@ iconSuiteRegs	reg		a0/a3/d6
 		_NewIconSuite
 		move.w	(sp)+,d0
 		move.w	d0,result(a6)				; save (shouldn't affect CCs)
-		bne.s	@Done						; error exit really								<23>		
+		bne		@Done						; error exit really								<23>		
 
 ; get a handle to each script’s small icon resource (‘kcs#’,‘kcs4’,‘kcs8’) and stuff in the icon suite
 		lea		kcsTable,a3
@@ -1124,7 +1114,7 @@ IMiconSuiteRegs	reg		d2-d6/a0
 		beq.s	@noResource					; no
 		
 ; if we are loading from component's resfile, better set resload to true ...
-		st		ResLoad						; set to true
+		move.b	#1,ResLoad					; set to true
 		bra.s	@doIt						; yes, use common code
 		
 ; if we can't load the resource, then close the resfile and use the generic small 
@@ -1294,7 +1284,7 @@ AddMenuRegs	reg	d3/d4/a0/a2-a4				; save a0, too											<23>
 		move.l	#UsingOldStyleIM,-(sp)		; TRUE								<34>
 		_SetScript
 		tst.w	(sp)+						; ignore OSErr						<34>
-		bra.s	@SaveItemNum				; and save the item num
+		bra		@SaveItemNum				; and save the item num
 
 ;------------------------------------------------------------------------------------------ 	
 @oldDefIM									; default is old-style IM
@@ -1303,7 +1293,7 @@ AddMenuRegs	reg	d3/d4/a0/a2-a4				; save a0, too											<23>
 		
 		move.w	compID+sidFEPID(a6),d0		; saved in low word of long
 		cmp.w	itemRsrcID(a2),d0			; is this item the default component for this script?
-		bne.s	@done						; no
+		bne		@done						; no
 
 ; this is the default old-style IM so use it
 		Import	GetKanjiUserIDIntf			; call local version of UserIDIntf		
@@ -1313,7 +1303,7 @@ AddMenuRegs	reg	d3/d4/a0/a2-a4				; save a0, too											<23>
 		move.l	smgrEntry+(smJapanese*4)(a1),a1		; load doubleTalkRecord for Japanese.
 ; if an error occured, didn't active old-style IM so don't make secret SetScript call.
 		tst.w	ScriptSystemGlobals.FISError(a1)	; bad index?
-		bne.s	@done								; yes -> bail.
+		bne		@done								; yes -> bail.
 
 	; we have a problem here. If the old default IM is not in the system ......
 	;; what to do if we failed ???? <??> how could it get registered as the default if
@@ -1330,17 +1320,17 @@ AddMenuRegs	reg	d3/d4/a0/a2-a4				; save a0, too											<23>
 		move.l	#UsingOldStyleIM,-(sp)				; TRUE	
 		_SetScript
 		tst.w	(sp)+								; result OSErr
-		bne.s	@done
-		bra.s	@SaveItemNum				;
+		bne		@done
+		bra		@SaveItemNum				;
 
 ;------------------------------------------------------------------------------------------ 	
 @newDefIM									; default is TSM-style IM
 		cmp.b	#TSMIMitem, itemType(a2)	; is this new?
-		bne.s	@done						; no,
+		bne		@done						; no,
 		move.l	auxItemInfo(a2),d0			; compare to the default
 		cmp.l	compID(a6),d0				; is this item the default component for this script?
-		bne.s	@done						; no 
-		bra.s	@SaveItemNum				;
+		bne		@done						; no 
+		bra		@SaveItemNum				;
 
 ; < End new #29 >
 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
@@ -1351,7 +1341,7 @@ AddMenuRegs	reg	d3/d4/a0/a2-a4				; save a0, too											<23>
 @KCHRinput
 		move.w	itemRsrcID(a2),d1			; get the first KCHR ID
 		cmp.w	scriptBundle.itlbKeys(a3),d1
-		bne.s	@done
+		bne		@done
 ;------------------------------------------------------------------------------------------ 		<21>
 
 @SaveItemNum
@@ -1369,7 +1359,7 @@ AddMenuRegs	reg	d3/d4/a0/a2-a4				; save a0, too											<23>
 
 ; Add ‘√’mark to the system KCHR
  		cmp.w	itemScript(a4),d4			; is this the system KCHR?
-		bne.s	@done
+		bne		@done
 ; system KCHR gets ‘√’ mark and its icon gets put into menu name
 		move.l	menuH(a6),-(sp)
 		move.w	d3,-(sp)
diff --git a/Toolbox/ScriptMgr/ScriptMgrMisc.a b/Toolbox/ScriptMgr/ScriptMgrMisc.a
--- a/Toolbox/ScriptMgr/ScriptMgrMisc.a
+++ b/Toolbox/ScriptMgr/ScriptMgrMisc.a
@@ -12,9 +12,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	 5/21/93	CSS		Delete body of SMgrCalRect as it is obsolete per P. Edberg's
-;									review. Leave an RTS so that the vector here still works.
-;		<SM4>	10/22/92	CSS		Change some branch short instructions to word branches.
 ;		<10>	 6/12/92	FM		Broke out the SMgrpostMunging routine into its own proc, and put
 ;									it here. It used to be in ScriptMgrPatch.a. This way it can be
 ;									used in the rom build without all the unecessary patch code for
@@ -205,7 +202,7 @@ xSwapKybd								; <06/30/89 pke>
 
 		bne.s	@loadItlk					; no - go load itlk. Otherwise…
 		_UseResFile							; restore old resfile (refnum on stack)	<5><6>
-		bra 	DoneKybd					; bail, keep old KCHR & itlk. 			<SM4> CSS 
+		bra.s	DoneKybd					; bail, keep old KCHR & itlk.
 
 @loadItlk
 ; if we already have an itlk, dispose of it											<6>
@@ -463,11 +460,51 @@ DoneEvent
 ; warning:	This routine is a trap patch for InitMenus.
 ;			This routine saves all registers.
 ;
-; This routine is obsolete.
+; This routine calculates the bounds of the menubar icon.
 ; ----------------------------------------------------------------------------
 
+mbarIconPix	equ	16
+
 SMgrCalcRect Proc Export
+		with	SMgrRecord
+
+		movem.l	a2,-(sp)
+		GetSMgrCore a2
+
+		move.w	MBarHeight,d0				; vertical placement
+		lsr.w	#1,d0
+		subq	#mbarIconPix/2,d0
+		move.w	d0,smgrRect+top(a2)
+		add.w	#mbarIconPix,d0
+		move.w	d0,smgrRect+bottom(a2)
+
+		subq	#4,sp
+		move.l	sp,-(sp)
+		_GetWMgrPort
+		move.l	(sp)+,a0
+
+		tst.b	smgrIconSideFlag(a2)		; horizontal placement
+		bnz.s	@iconLeft
+
+@iconRight									; ...on one side...
+		move.w	portRect+right(a0),d0
+		sub.w	smgrIconOffset(a2),d0
+		move.w	d0,smgrRect+right(a2)
+		sub.w	#mbarIconPix,d0
+		move.w	d0,smgrRect+left(a2)
+		bra.s	@return
+@iconLeft									; ...or the other.
+		move.w	portRect+left(a0),d0
+		add.w	smgrIconOffset(a2),d0
+		move.w	d0,smgrRect+left(a2)
+		add.w	#mbarIconPix,d0
+		move.w	d0,smgrRect+right(a2)
+
+@return
+		movem.l	(sp)+,a2
 		rts
+
+		endwith
 		endproc
 
 ; ----------------------------------------------------------------------------
diff --git a/Toolbox/ScriptMgr/ScriptMgrUtilDate.a b/Toolbox/ScriptMgr/ScriptMgrUtilDate.a
--- a/Toolbox/ScriptMgr/ScriptMgrUtilDate.a
+++ b/Toolbox/ScriptMgr/ScriptMgrUtilDate.a
@@ -14,7 +14,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	11/12/92	PN		Get rid of ≥ 020 conditionals for ROM builds
 ;	   <SM4>	 11/6/92	SWC		Changed PackMacs.a->Packages.a.
 ;		<15>	 6/12/92	FM		remove MacsBug symbols and obsolete smgrKeepMacsBugSymbols
 ;									conditional. Replaced long divisions w/ a macro that uses a
@@ -237,8 +236,12 @@ genCdevRangeHi	equ	$DA319179			; =3660681599, secs for 2019-Dec-31 23:59:59
 		macro
 			LongDiv
 			
-				machine	mc68020
+			IF &SETTING('MACHINE') = 'MC68000' THEN
+				bsr		LongDivFunc
+			ELSE
 				divs.l	d2,d0:d1			; do it
+			ENDIF
+
 			
 		endm
 
@@ -1213,6 +1216,74 @@ RD2SRegs	reg	a2/d3-d7
 	
 
 
+;============================================================================
+;    Arguments: d0:d1 = dividend (u64), d2 = divisor (u32)
+;    Returns: d0 = remainder (u32), d1 = quotient (u32)
+;============================================================================
+
+LongDivFunc	proc	export
+
+		cmp.b	#cpu68020, CPUFlag
+		blt.s	@useSANE
+
+@useDIVS
+		machine	MC68020
+		divs.l	d2,d0:d1
+		rts
+		machine	MC68000
+
+@useSANE
+
+DivRec		record  {oldA6},decr
+return		ds.l    1
+oldA6		ds.l    1
+divisor		ds.l	1
+dividend	ds.d	1
+argBuffer
+float80		ds.x	1
+remultiply	ds.d	1
+quotient	ds.l	1
+localFrame	equ		*
+			endr
+
+		with	DivRec
+
+		link	a6,#localFrame
+
+		lea		argBuffer(a6),a0
+		move.l	d0,(a0)+			; save dividend
+		move.l	d1,(a0)+			; ...
+		move.l	d2,(a0)				; and divisor
+
+		pea		dividend(a6)		; convert to 80-float
+		pea		float80(a6)
+		FC2X
+
+		pea		divisor(a6)			; divide via SANE
+		pea		float80(a6)
+		FDIVL
+
+		pea		float80(a6)			; quotient as long
+		pea		quotient(a6)
+		FX2L
+
+		move.l	quotient(a6),-(sp)	; get quotient * divisor
+		move.l	divisor(a6),-(sp)
+		pea		remultiply(a6)
+		_LongMul
+
+		move.l	quotient(a6),d1		; result: quotient
+
+		move.l	dividend+4(a6),d0	; result: remainder
+		sub.l	remultiply+4(a6),d0
+
+		unlk	a6
+		rts
+
+		endWith
+		endProc
+
+
 ;============================================================================
 ;pascal void LongSecs2Date (longSecs, longDate, selector)
 ;    LongDate*		longSecs;
@@ -1253,6 +1324,7 @@ RS2DRegs	reg	a2/d3-d7
 
 		with	LS2DRec,LongDateRec
 		import	MonthStarts,LeapStarts,secsInDayX
+		import	LongDivFunc
 
 		CheckSelector
 		link	a6,#localFrame
diff --git a/Toolbox/ShutDownMgr/ShutDownMgr.a b/Toolbox/ShutDownMgr/ShutDownMgr.a
--- a/Toolbox/ShutDownMgr/ShutDownMgr.a
+++ b/Toolbox/ShutDownMgr/ShutDownMgr.a
@@ -20,94 +20,11 @@
 ;
 ;	Change History (most recent first):
 ;
-;	  <SM33>	 11/6/93	SAM		Roll <MC8> from mc900ftjesus.
-;	   <MC8>	 11/6/93	SAM		Now handle the restart from the "..safe to switch off..." case
-;									correctly (ie restore the nanok warmstart).
-;	  <SM32>	 11/6/93	SAM		Roll <MC7> from mc900ftjesus.
-;	   <MC7>	 11/6/93	SAM		Changed ClearWarmStart to check for a V0 style emulator and if
-;									present to clear the emu warmstart flag.
-;	  <SM31>	10/29/93	CCH		Modified KillEDisk to deal with EDisks that don't use checksums.
-;	   <MC5>	10/11/93	CCH		Modified KillEDisk to use new HwPriv parms on PowerPC.
-;	   <MC4>	 9/27/93	SAM		Added ClearWarmstart too.
-;	   <MC3>	 9/27/93	SAM		Added exports of DoRAMDiskAlert, KillEDisk, FindEDisk,
-;									ShutRestart, and ShutPower for vectorization.
-;	   <MC2>	 9/25/93	SAM		Completely cleaned up this file.  Removed tons of shit, bogus
-;									and sloppy code.  Looking more and more like it was in Terror...
-;	  <SM28>	 8/12/93	BG		Converted references to gestaltCyclone40 to gestaltQuadra840AV.
-;	  <SM27>	 7/20/93	SAM		Removed the Scruffy code from ShutRestart. (we will never be a
-;									Mac II).
-;	  <SM26>	 7/13/93	RB		For the third time, removed checks for 67C ROM.
-;	  <SM25>	 6/14/93	kc		Roll in Ludwig.
-;	   <LW3>	 5/27/93	KW		Added code in the Shutdown Continue Proc from the
-;									ShutDownMgrPatches.a from the gibbly to remove the Chassis Sw
-;									TimeMgr Task if you are running on a Cyclone CPU. The Chassis Ss
-;									TimeMgr Task is piggybacked onto the emKeyTmTaskPtr
-;	   <LW2>	 5/14/93	KW		After calling "DoRAMDiskAlert", if user hit cancel remove the
-;									tickletimer and send cuda and EnDisPDM command with PDMContinue.
-;									Fixes some radar bug
-;	  <SM24>	  4/8/93	SAM		Added some Supports24bit conds around swapmmu code in
-;									ClearWarmStart and KillEDisk.
-;	  <SM23>	  3/9/93	jmp		Cleaned up the ShutDown/Restart blank-the-screen code so that it
-;									now works more consistently across all CPUs (i.e., due to the
-;									fact that various CPUs these days don't tie reset to I/O, the
-;									desktop could sometimes persist thru bootbeep).
-;	  <SM22>	01-18-93	jmp		Added a TimeMgr-based timeout task that forces the wait-eject
-;									code to terminate (if it isn’t already done) after 2 seconds.
-;									This prevents things like stuck disks, etc…, from hanging the
-;									restart/shutdown sequence.
-;	  <SM21>	12-17-92	jmp		Removed the Wait500ms routine in favor of “wait for floppy
-;									eject” described in <SM20>.
-;	  <SM20>	12-16-92	jmp		Added some code that waits until the drive queue has noticed
-;									that all floppies have been ejected (in DoUnmount) before
-;									shutting down or restarting.
-;	  <SM19>	 12/9/92	RB		Remove (AGAIN) the check for Terror ROMs regarding EDisk. This
-;									ain't Terror, Also save and restore A5 in BlankScreen so that
-;									the cursor is not trashed on Macs that don't support soft
-;									shutdown.
-;	  <SM18>	11/20/92	FU		Removed another tickle cuda call.
-;	  <SM17>	11/20/92	RB		Removed the call to TickleCuda.
-;	  <SM16>	11/20/92	GS		(bg)  Updated ShutPower to include the chks for Sonic to issue a
-;									reset to the Sonic Chip before executing the Shutdown.  Removed
-;									the EnablePDMsgs from ShutInit.  Now found in Boot3.a.  Added
-;									the CloseLCDVideo, DockInitSCC routines for the portables.
-;	  <SM15>	 11/3/92	SWC		Changed ShutdownEqu.a->Shutdown.a and SlotEqu.a->Slots.a.
-;	  <SM14>	 10/8/92	GS		Added a 500ms delay before pulling the power plug in the
-;									ShutPower routine to help with the async call by New Age to
-;									eject the floppy.
-;	  <SM13>	 9/28/92	RB		Fix the Soft Power Shutdown on the Quadra 900 and 950. ••• WHEN
-;									UPDATING FROM REALITY OR HORROR, DO NOT MESS WITH SHUTINIT, make
-;									sure that it still calls EnablePDMsgs, AND that EnablePDMsgs has
-;									a ble, not bne !!!!!
-;	  <SM12>	  9/3/92	PN		Nuke the check for IIci because this is SuperMario.
-;	  <SM11>	 8/19/92	CSS		Update from Reality:
-;									<52> 8/18/92 DTY	Change the name of BootGlobs to StartGlobals to avoid confusion
-;														with BootGlobals, which is used by the boot code in Boot[1-3].a.
-;	  <SM10>	 7/28/92	MR		Restart crashes under VM because a switch
-;									to supervisor mode is   done only if ROM is IIci. Now checks for
-;									SuperMario
-;	   <SM9>	 7/7/92		CSS		Update from Reality:
-;									<51> 6/2/92	JSM	#1031451 <csd>: Like we do on the PowerBook 140 and 170, close
-;													the video driver at shutdown or restart for the PowerBook 145.
-;									<50> 4/9/92	JSM	#1026795,<DTY>: Set CLUT to 50% gray on restart for the LC II as
-;													well as the LC.
-;	   <SM8>	  7/1/92	RB		Do the EDisk check at Shutdown without checking the ROM version
-;									of Terror, since SuperMArio also has Edisk. Do not call Cuda on
-;									machines without it.
-;	   <SM7>	 6/26/92	GS		ReIncluded ROMBind, InstallProc, and PatchProc  Linked Patch
-;									Macro calls to support CubeE builds.
-;	   <SM6>	 6/23/92	GS		Having a problem with the latest set of check-ins. The Header
-;									format could not be found. Cleaning up header...
-;	   <SM5>	 6/23/92	GS		Was a Bad Dog!!!!  Re Including the LinkedPatchMacros.a for
-;									support of Non-SuperMario ROM based machines.  
-;									H/W specific chks in place for Egret chip with Cuda FW.
-;									Rolled in changes for the Soft Power off support with code from
-;									Cyclone version of Regatta.  This includes chks in the sdSoftOff
-;									code to chk for Cuda FW in the Egret chip.  Removed Linked patch
-;									macro support.
-;	   <SM3>	 5/16/92	kc		Roll in Horror Changes. Include PowerPrivEqu instead of
-;									ROMPrivateEqu.
-;	   <SM2>	  4/1/92	JSM		Roll-in changes from Reality:
-;		<49>	  4/1/92	JSM		#1025166,<DTY>: Roll-in code formerly in the file
+;		<51>	  6/2/92	csd		Like we do on the PowerBook 140 and 170, close
+;									the video driver at shutdown or restart for the PowerBook 145.
+;		<50>	  4/9/92	DTY		Set CLUT to 50% gray on restart for the LC II as
+;									well as the LC.
+;		<49>	  4/1/92	DTY		Roll-in code formerly in the file
 ;									ShutDownRAMDiskPatchINIT.a that puts up a warning dialog if a
 ;									user tries to shutdown with a RAM disk, and make it work for ROM
 ;									builds, too.
@@ -291,7 +208,7 @@
 				include		'MMUEqu.a'
 				include		'BootEqu.a'
 				include		'HardwarePrivateEqu.a'
-				include		'PowerPrivEqu.a'
+				include		'ROMPrivateEqu.a'
 				include		'GestaltEqu.a'
 				include		'GestaltPrivateEqu.a'
 				include		'UniversalEqu.a'
@@ -301,6 +218,8 @@
 				include		'EgretEqu.a'
 				include		'EDiskEqu.a'
 				include		'DialogsPriv.a'					; <49> for _SetDialogDefaultItem, etc
+				include		'Devices.a'
+				include		'DepVideoEqu.a'
 				
 				MACRO										; <MC2> SAM
 				SETMACHINE
@@ -339,7 +258,834 @@ sdBitDrivers	EQU		3				;  before Driver Goodbye Kiss.
 QSDProcPtr		EQU		QType+2
 QSDRecSize		EQU		QSDProcPtr+4
 
-SDHeader 		EQU 	$BBC			; low mem for ROM version
+ShutDownPatch	PatchProc	_ShutDown,(Plus,SE,II,Portable,IIci)
+
+
+				IMPORT		FindEDisk, KillEDisk
+
+;_______________________________________________________________________
+;
+; Routine:		ShutDown
+;
+; Arguments:	A0 (input) :	address of a ShutDown routine
+;				D0 (input) :    command word (SDInit, SDPowerOff ...)
+;				D1 (input) :    for an SDInstall operation, the flags word.
+;
+; Function: 	This routine dispatches to one of several functions:  SDInit
+;					initializes the ShutDown Queue and sets up a default
+;					shutdown routine to eject disks.  SDPowerOff calls the
+;					power down routines, and then turns power off (or waits
+;					for the user to do so).  SDRestart calls the restart routines
+;					and then does a re-boot.  SDInstall installs a power
+;					off or restart proc.  SDRemove removes a proc.
+;
+; ShutDown(OpWord)
+;
+;_______________________________________________________________________
+				EXPORT	Shutdown
+				
+ShutDown		move.l	(SP)+,D2			; save return
+				move.w	(SP)+,D0			; get opcode word
+				move.l	D2,-(SP)			; restore the return
+				subq	#SDPowerOff,D0
+				bcs.w	@unknownSelector
+				beq		ShutPower			; if d0=1, Shutdown
+
+				subq	#SDInstall-SDPowerOff,D0	
+				bcs		ShutRestart			; if d0=2, carry set, bra to restart
+				beq.s	ShutInstall			; if d0=3, Install
+
+				subq.w	#sdUserChoice-sdInstall,d0	
+				bmi.s	ShutRemove			;if  d0=4, Remove
+				beq		UserChoice			; if d0=5, User Choice
+@unknownSelector
+				rts							; unknown selector (do nothing, assume no parameters)
+
+;_______________________________________________________________________
+;
+; ShutInstall - Installs a shutDown procedure in the SD Queue.
+;		Entry On Stack: Long - Proc pointer, to install in Queue, call later.
+;						Word - Flags word, with low bits defining when to call proc.
+;
+; ShutDown(Proc, WhenFlags, 3)
+;_______________________________________________________________________
+
+				EXPORT	ShutInstall
+ShutInstall
+				move.l	(SP)+,D2
+				move.w	(SP)+,D1				; get flags word
+				move.l	(SP)+,a1				;  and ProcPointer
+				move.l	D2,-(SP)
+				moveq	#QSDRecSize,D0			; create the queue element.
+				_NewPtr sys
+				move.w	D1,QType(A0)			; stuff in the flags and proc.
+				move.l	A1,QSDProcPtr(A0)
+
+				lea		SDHeader,A1			 	; get address of queue
+				_Enqueue						; install it in the queue
+				Rts
+
+;_______________________________________________________________________
+;
+; ShutRemove - Removes a shutDown procedure in the SD Queue.
+;		Entry:	TOS - Proc pointer, to remove from the Queue.
+;		Exit:	D0 - Error Code.
+;
+; ShutDown(Proc, 4)
+;_______________________________________________________________________
+
+				Export	ShutRemove
+ShutRemove
+				move.l	(SP)+,D2
+				move.l	(SP)+,A0				; get proc pointer from NOS
+				move.l	D2,-(SP)
+				move.l	A2,-(SP)
+				lea		SDHeader,A1	 			; get address of queue
+				AddQ	#QHead,A1				; point to the head
+				move.l	(A1)+,A2
+				move.l	(A1),D0					; remember the tail
+				beq.s	@NotFound				; are there any entries?
+
+; Search for the matching entry.
+
+@ScanLoop
+				cmp.l	QSDProcPtr(A2),A0		; is this the one?
+				beq.s	@Found
+
+				move.l	QLink(A2),A1			; get the link to the next.
+				cmp.l	A2,D0					; did we do the end?
+				move.l	A1,A2
+				Bne.S	@ScanLoop
+@NotFound
+				moveq	#qErr,D0				; return error - not found.
+				Bra.S	@Terminate
+@Found
+				lea		SDHeader,A1				; get the SD Queue Header A1.
+				move.l	A2,A0
+				_Dequeue						; remove it from the linked list.
+				move.l	A2,A0
+				_DisposPtr						; de-allocate the memory for the pt
+@Terminate
+				move.l	(SP)+,A2				; restore work registers
+				Rts
+
+;_______________________________________________________________________
+;
+; ShutRestart - do a shut-down and restart the system
+;
+;		Entry:	no parameters
+;		Exit:	never does.
+;
+; ShutDown(2)
+;_______________________________________________________________________
+;
+;	Some history for all you young'ns:
+;
+;	Some things to be aware of about the RESET instruction on various Macintosh Products	<2.7>
+;
+;	1)	This code is in ROM on Aurora, Esprit, F19, and all new CPUs.  It is in RAM, from
+;		the System Disk on the Mac Plus, SE, II, IIx, IIcx, SE30.
+;
+;	2)	StartInit contains a RESET instruction in ROM on the 68020/030 CPU ROMs.
+;
+;	3)	On the Mac Plus and Mac SE, a RESET will cause the 68000 to get a Reset, and it
+;		will switch into overlay mode, and  Re-Boot through the reset vector.
+;
+;	4)	When running a ROM image out of RAM, we do not want to do a RESET, because it will
+;		cause a switch into overlay mode, and the RAM base code cannot be fetched.
+;
+;	5)	On 68030 based machines, if the translation tables are in RAM (AURORA/F19, VM or Romulator),
+;		you should not do a RESET when the MMU is enabled, even if you are executing in ROM.
+;		If there is a miss in the ATC, it will attempt to fetch descriptors from RAM, but overlay
+;		is now enabled, and data from ROM will be used instead, causing lots of problems.
+;
+;	6)	Esprit has some problem when RESET is executed, and RESET should NEVER be used.
+;
+;	7)	This all means that RESET is only needed on a MacPlus and MacSE.
+;		It might not be a problem on machines based on the MacII/IIx ROMs,
+;		since they have the MMU tables in ROM, but it is not reccommended.
+;		All other situations should not do a RESET in Shutdown.
+;
+
+						
+ShutRestart		
+				with	ROMHeader				
+
+				moveq	#sdOnPowerOff,d5		; Remove poweroff routines from the queue		<13>
+				bsr		RemoveOtherRoutines
+
+				moveq	#SDBitRestart,D0		; remember that we will reboot.
+				bsr		CallRoutines			; do the shutDown cleanup.
+
+				cmp.b	#boxMacLC,BoxFlag
+				beq.s	@grayElsie
+				cmp.b	#boxMacLCII,BoxFlag
+				bne.s	@dontGrayNotElsie
+@grayElsie
+				bsr		GrayCLUT
+				bra.s	@endif
+@dontGrayNotElsie
+				cmp.b	#boxPowerBook170,BoxFlag
+				beq.s	@thing
+				cmp.b	#boxPowerBook140,BoxFlag
+				beq.s	@thing
+				cmp.b	#boxPowerBook145,BoxFlag	; <51>
+				beq.s	@thing
+				bra.s	@endif
+@thing
+				bsr		CloseLCDVideo
+@endif
+
+
+				
+
+;				moveq	#1,D5					; Go ahead and hide cursor/close LCDs.
+;				bsr		BlankDesktop			; Go blank the desktop.
+
+				move.l	ROMBase,A2					; point to the ROM
+				lea		ROMHeader.Restart(A2),A2	; point to the restart routine
+
+				cmp.w	#$37A,-2(A2)
+				beq.s	@noReset
+				tst.b	CPUFlag
+				bne.s	@noReset
+				reset
+@noReset
+
+				cmp.w	#$67C,-2(A2)
+				bne.s	@noJAWS
+
+				move.l	#gestaltVMAttr,d0		; Is VM running?
+				_Gestalt
+				bne.s	@noVM					; -> No.  Assume we're in Supervisor Mode				
+				move.l	a0,D0
+				beq.s	@noVM					; -> No.  Assume we're in Supervisor Mode				
+				_EnterSupervisorMode			; Enter supervisor mode (don’t worry about munging the stack...)
+@noVM
+
+				TestFor	JawsExists				; are we running on a Tim machine with JAWS				<SM16><5> HJR
+				beq.s	@noJAWS					; -> No JAWS, jump to RESTART now.						<SM16><43>
+
+				with	PmgrRec, pmCommandRec
+@JawsRestartSeq									; -- Special Case for JAWS --							<5> HJR
+				move.l	PMgrBase,a0				; get pointer to the power manager globals
+				move.l	HDVector(a0),a0			; get pointer to hard disk power down
+				jsr		(a0)					; kill the hard disk
+				lea		-pmBlkSize(sp),sp		; Create stack frame									<v5.7>
+				lea		pmData(sp),a0			; Get pointer to a xmit buffer
+				move.l	a0,pmRBuffer(sp)		; Load pointer to receive buffer
+				move.l	a0,pmSBuffer(sp)		; Load pointer to xmit buffer
+				clr.l	(a0)					; No data
+				clr.w	pmLength(sp)			; No data
+				move.w	#$21,pmCommand(sp)		; ADB autopoll disable
+				move.l	sp,a0					; a0 get pointer to paramter block
+				_PmgrOp							; go kill the machine
+				clr.l	pmData(a0)				; clear data
+				clr.w	pmLength(a0)			; clear length
+				move.w	#$d0,pmCommand(sp)		; reset CPU command
+				move.w	Timedbra,d1				; set-up our counter
+				lsl.w	#2,d1					; give ourselves 4 milliseconds
+				_PmgrOp							; go kill the machine
+
+@waitloop		dbra	d1,@waitloop			; stick around for 4 milliseconds
+												; Fall into the JMP to Restart							<43>
+
+	; Finally!  Restart the machine by Jumping through the Restart vector in the ROM header
+	
+@noJAWS
+				MACHINE	MC68030
+				cmp.w	#$178,-2(A2)
+				bne.s	@justJump
+				cmp.l	#$2000,SysZone
+				bne.s	@justJump
+				move.w	#$2700,sr
+				lea		@zero,a0
+				pmove	(a0),tc
+				move.l	#$2000,d0
+				movec	d0,cacr
+				SETMACHINE
+
+@justJump
+				JMP		(A2)					; exit thru the restart routine							<mc2>				
+
+@zero
+				dc.l	0
+
+;________________________________________________________________________________________________
+
+
+
+;_______________________________________________________________________
+;
+; ShutPower - Do a shutDown and power off the system if possible.  If it’s
+;				and older system (no power off ability) then put up an
+;				alert that the system can go down now.
+;
+;		Entry:	no parameters
+;		Exit:	never does.
+;
+; ShutDown(1)
+;_______________________________________________________________________
+				
+ShutPower		
+				moveq	#sdOnRestart,D5			; Remove all restart procedures from the queue	<13>
+				bsr.w	RemoveOtherRoutines		; Go remove these procedures from the queue		<13>
+
+				moveq	#SDBitPowerOff,D0		; pass parameter: power off.
+				bsr.s	CallRoutines			; do cleanup and check if new mac.
+
+
+				cmp.b	#boxPowerBook170,BoxFlag
+				beq.s	@thing
+				cmp.b	#boxPowerBook140,BoxFlag
+				beq.s	@thing
+				cmp.b	#boxPowerBook145,BoxFlag
+				beq.s	@thing
+				bra.s	@endif
+@thing
+				bsr		CloseLCDVideo
+@endif
+
+				bsr		BlankDesktop			; Clear the whole desktop.
+								
+				move.l	ROMBase,a0
+				cmp.w	#$67C,ROMHeader.MachineNumber(a0)
+				bne.s	@noEDisk
+				bsr		FindEDisk				; Do we have an EDisk in the drive Q?
+				beq.s	@noEDisk				; -> Nope, continue w/power off
+				bsr		KillEDisk				; Clear the EDisk's checksum data (invalidate the disk)
+@noEDisk
+
+				bsr		CheckForSoftPowerOff	; does this machine have software power-off?
+				bz.s	@noSoftPowerOff			; no, don’t even try it
+
+				_PowerOff						; turn power off
+												; it’s nice that we fall through if PowerOff does nothing
+@noSoftPowerOff
+				_InitCursor
+				moveq	#shutDownAlert,D0
+
+;_______________________________________________________________________
+;
+; DoSysErrDialog
+;
+;	Put up a dialog (done by the system error handler).
+;	The system error ID must be in D0.
+;
+;_______________________________________________________________________
+
+DoSysErrDialog
+				clr.l	ResumeProc				; don’t show resume button
+				_SysError						; will never return
+
+;_______________________________________________________________________
+;
+; UserChoice
+;
+;	Start off as a power-off. If the machine supports soft power-off,
+;	we give the user a choice between Restart and Shut Down (some of the
+;	code to handle this is in system error tables). If the machine
+;	does not support soft power-off, Shut Down and Restart are equivalent,
+;	so we put up an alert with a single Restart button (the text reflects
+;	the fact that the computer made the choice).
+;
+;_______________________________________________________________________
+
+UserChoice
+				bsr		BlankDesktop			; Clear the entire desktop for consistency.
+
+				bsr		CheckForSoftPowerOff	; does this machine have software power-off?
+				bz.s	@noSoftPowerOff			; no!
+
+				move.w	#dsShutDownOrRestart,d0	; yes, let the user choose Shut Down or Restart
+				bra.s	DoSysErrDialog
+
+@noSoftPowerOff
+				moveq	#sdBitPowerOff,d0		; notify just as we would for PowerOff
+				bsr.s	CallRoutines			; go do the notification
+
+				move.w	#dsSwitchOffOrRestart,d0	; no, let the user switch off or Restart
+				bra.s	DoSysErrDialog
+
+
+;_______________________________________________________________________
+;
+; CallRoutines
+;		Entry:	D0 - Bit number to test (shutdown type).
+;		Exit:	regs saved.
+;_______________________________________________________________________
+
+CallRoutines
+				movem.l	A1-A3/D0-D5,-(SP)
+				move.w	D0,D4
+
+; Call Cleanup for Drivers, and Custom cleanup Procs.
+
+				moveq	#SDBitDrivers,D5		; do Pre-Driver cleanUp
+				bsr.s	CallCleanUp
+
+; Call Cleanup to unmount volumes, and then custom PowerOff/Restart.
+
+				moveq	#SDBitUnMount,D5		; do Vol UnMounts
+				bsr.s	CallCleanUp
+				move.w	D4,D5					; do PowerOff or ReStart cleanup
+				bsr.s	CallCleanUp
+
+; set up the flags for the caller.
+
+				movem.l	(SP)+,A1-A3/D0-D5
+				Rts
+
+;_______________________________________________________________________
+;
+; RemoveOtherRoutines - Remove all occurences of the passed in shutdown procedure type from the shutdown queue.	<13>
+;		This differentiates routines that wish to be executed before drivers on restart, but not at all on poweroff
+;		(as an example).  Before, there was no differentiation between restart and poweroff for routines that were
+;		to run before drivers close, or before volumes are unmounted.  There are cases when such differentiation
+;		is desired, but was previously impossible.  By removing routines of the “other” type (other being restart on
+;		a poweroff, and vice versa), the only routines left in the queue are those that should be executed.  Routines
+;		that execute on both poweroff and restart are left in the queue.  On a final note, the routines aren’t actually
+;		removed from the queue, since the machine will either be powered off or restarted in a few seconds, so it really
+;		doesn’t matter what gets left lying around in memory.  This way, a call to _SDRemove is saved.
+;
+;		Entry:	D5 - Bit number of shutdown type to remove from queue
+;		Exit:
+;_______________________________________________________________________
+
+RemoveOtherRoutines
+				lea		SDHeader,A1				; get header into A1.
+				Lea		QHead(A1),A3			; point to the head
+				move.l	(A3)+,A2
+				move.l	(A3),D3					; remember the tail
+				beq.s	@NotFound				; are there any entries?
+
+; Find entry that matches the type to remove
+
+@ScanLoop
+				move.l	QLink(A2),A3			; get the link to the next
+				move.w	QType(A2),D0			; get the shutdown flags
+				andi.w	#3,d0					; We’re only interested in the poweroff and restart bits
+				cmp.w	d0,d5					; Is this a type that should be removed?
+				bne.S	@DontRemove				; don’t remove this entry
+
+; now remove the proc from the queue.
+; Since the whole state of the machine is going into la-la land very shortly, there’s no point
+; in actually removing the procedure.  Just zapping the shutdown flags to zero to prevent this
+; routine from being found again is good enough.												<13>
+
+				clr.w	QType(a2)				; QType holds the shutdown flags
+
+@DontRemove
+				cmp.l	A2,D3					; at the end?
+				move.l	A3,A2
+				Bne.S	@ScanLoop
+@NotFound
+				Rts
+
+;_______________________________________________________________________
+;
+; CallCleanUp
+;		Entry:	D5 - Bit number to test (shutdown type).
+;		Exit:
+;_______________________________________________________________________
+
+CallCleanUp
+				lea		SDHeader,A1					; get header into A1.
+				Lea		QHead(A1),A3			; point to the head
+				move.l	(A3)+,A2
+				move.l	(A3),D3					; remember the tail
+				beq.s	@NotFound				; are there any entries?
+
+; Search for an entry that wants a call now.
+
+@ScanLoop
+				move.l	QLink(A2),A3			; get the link to the next
+				move.w	QType(A2),D0			; get the shutdown flags
+				BTst	D5,D0					; want call now?
+				beq.s	@DontCallUs				; don’t call for this kind
+
+; call the proc, with bit number in D0, in case it cares.
+
+				move.l	QSDProcPtr(A2),A0		; call the shutdown routine
+				move.w	D5,D0					; pass bit number in D0
+				Jsr		(A0)
+
+; now remove the proc from the queue.
+; Since the whole state of the machine is going into la-la land very shortly, there’s no point
+; in actually removing the procedure.  Just zapping the shutdown flags to zero to prevent this
+; routine from being found again is good enough. <13>
+
+				clr.w	QType(a2)				; QType holds the shutdown flags
+@DontCallUs
+				cmp.l	A2,D3					; at the end?
+				move.l	A3,A2
+				Bne.S	@ScanLoop
+@NotFound
+				Rts
+
+;_______________________________________________________________________
+;
+; DoDrivers - The Default shutdown routine to kiss all of the drivers
+;					goodbye.
+;		Entry:	No paramters.
+;
+;_______________________________________________________________________
+
+			export	DoDrivers
+DoDrivers
+			; first, send a doGoodBye call to all drivers that want one
+
+			MOVEM.L	D0-D1/D4-D7/A0-A1,-(SP)			; save registers		<4> jmp
+			SUB		#IOQElSize,SP					; allocate pBlock
+			MOVE	#-1,CSCode(SP)					; set up control code
+			MOVE.L	UTableBase,A1					; point to unit table
+			MOVE.W	UnitNtryCnt,D1					; get # entries in unit table
+@loop
+			MOVE.L	(A1)+,D0						; get the DCE handle
+			BEQ.S 	@next		 					; if NIL, try next one
+
+			MOVE.L	D0,A0							; get the DCE handle
+			MOVE.L	(A0),A0 						; get the DCE pointer
+
+;------------------------------------------------------------------------	<4> jmp
+			
+			Btst	#dRamBased,DCtlFlags+1(A0)		; If we’ve got a pointer, then just skip
+			Beq.s	@skipVidChk						;	this code (our drivers are RamBased).
+			
+			Move.l	A0,D7							; Save pointer to DCE.
+			Move.l	A1,D6							; Save UTable pointer.
+			
+			Move.l	dCtlDriver(A0),A0				; Get handle to driver.
+			Move.l	(A0),A0							; Get pointer to driver.
+			Lea		drvrName(A0),A0					; Point to driver name.
+			Move.l	A0,D5							; Save it for later.
+			
+			moveq	#0,D0							; Prepare D0.
+			Move.b	(A0),D0							; Get the length of the driver name.
+			Move.w	D0,D4							; Make a copy.
+			Addq	#2,D4							; Adjust offset to version field (len + 1)
+			Bclr	#0,D4							; Adjust offset for word alignment.
+			Move.w	(A0,D4.w),D4					; Get the version number.
+			Bne.s	@endVidChk						; If non-zero, then just leave.
+			
+			Swap	D0								; Get 1st string length into hi-word.
+			Addq	#1,A0							; Point to text of driver name.
+			Lea		TimVidTitle,A1					; Point to TIM/TIM-LC’s video driver name.
+			Move.b	(A1)+,D0						; Get 2nd string length into lo-word.
+			_CmpString								; Compare drvrName with TimVidTitle.
+			Tst.b	D0								; If this is the TIM/TIM-LC driver,
+			Beq.s	@fixFlags						;	then don’t kiss it goodbye.
+			
+			Move.l	D5,A0							; Restore pointer to driver name.
+			moveq	#0,D0							; Re-prepare D0.
+			Move.b	(A0)+,D0						; Get length of 1st string…
+			Swap	D0								; 	…into the hi-word.
+			Lea		DAFBVidTitle,A1					; Point to Spike/Eclipse video driver name.
+			Move.b	(A1)+,D0						; Get 2nd string length into lo-word.
+			_CmpString								; Compare drvrName with DAFVidTitle.
+			Tst.b	D0								; If this is the DAFB (Spike/Eclipse) driver,
+			Beq.s	@fixFlags						;	then don’t kiss it goodbye.
+			Bra.s	@endVidChk						; Otherise, just leave.
+			
+@fixFlags	Move.l	D7,A0							; Restore pointer to DCE.
+			Bclr	#DNeedGoodbye,DCtlFlags(A0) 	; Reset the good-bye kiss flag.
+
+@endVidChk	Move.l	D7,A0							; Restore pointer to DCE.
+			Move.l	D6,A1							; Restore pointer to UTable.
+			
+@skipVidChk
+
+;------------------------------------------------------------------------	<4> jmp		
+			
+			BTST	#DNeedGoodbye,DCtlFlags(A0) 	; need a goodbye kiss?
+			BEQ.S 	@next		 					; not tonight dear
+
+			; we found one that needs a goodbye call so issue the control call
+
+			MOVE.W	DCtlRefNum(A0),IORefNum(SP) 	; set up the refNum
+			MOVE.L	SP,A0							; point to the DCE
+			_Control								; kiss it goodbye...
+@next
+			SUBQ		#1,D1						; check next entry
+			BNE.S 	@loop	 						; if so, loop
+
+			; done, return
+
+			ADD		#IOQElSize,SP					; deallocate pBlock
+			MOVEM.L	(SP)+,D0-D1/D4-D7/A0-A1			; restore registers		<4> jmp
+			RTS
+
+;------------------------------------------------------------------------	<4> jmp		
+
+			String	Pascal
+
+TIMVidTitle
+			DC.W	'.Display_Video_Apple_TIM'		; Name of TIM/TIM-LC Video Driver.
+
+DAFBVidTitle
+			DC.W	'.Display_Video_Apple_DAFB'		; Name of Spike/Eclipse Video Driver.
+
+;------------------------------------------------------------------------	<4> jmp		
+
+;_______________________________________________________________________
+;
+; DoUnmount - Unmount all of the volumes on line, so the disks will be updated before our power off.
+;
+;		Entry:	No parameters.
+;
+;_______________________________________________________________________
+
+			export	DoUnmount
+DoUnmount
+			sub		#IOQElSize,SP				; allocate pBlock
+
+; Go through the VCB Queue to Flush and eject all volumes.
+
+		  	move.l	SP,A0						; point to the parameter block
+			clr.L	ioVNPtr(A0)
+			clr.W	ioRefNum(A0)
+			move.l	VCBQHdr+QHead,A1			; get the queue header
+			move.l	VCBQHdr+QTail,D2			; get the tail too
+			beq.s	@AllFlushed
+			bsr.s	ZapVCBQueue					; wipe out the whole queue
+
+@AllFlushed
+			add.W	#IOQElSize,SP				; deallocate pBlock
+		  	rts
+
+;_______________________________________________________________________					<5>
+;
+; ClearWarmStart - Shutdown task to clear warm start variable if user
+;					chooses 'Shut Down' from the Finder.
+;
+;_______________________________________________________________________					<5>
+
+			export	ClearWarmStart
+
+ClearWarmStart
+			move.l	ROMBase,A0
+			cmp.w	#$75,ROMHeader.MachineNumber(A0)
+			beq.s	@return
+			move.l	#gestaltMiscAttr,D0
+			_Gestalt
+			move.l	A0,D0
+			btst	#1,D0
+			beq.s	@noClear
+
+			btst	#3,$B22
+			beq.s	@noSwap
+			moveq	#true32b,D0
+			_SwapMMUMode
+@noSwap
+
+			movea.l	BootGlobPtr,A0					; point to bootGlobals
+			clr.l	StartGlobals.sgWarmStart(A0)	; clear warm start flag
+
+			btst	#3,$B22
+			beq.s	@noSwapBack
+			_SwapMMUMode
+@noSwapBack
+@noClear
+
+			clr.l	WarmStart						; write warm start constant to indicate warm start
+			
+@return
+			rts
+
+;_______________________________________________________________________					<5>
+; ZapVCBQueue - This routine goes through the VCB Queue, and calls HUnmountVol for each entry.
+;
+;		Entry:	A0 - IOParam Block
+;				A1 - Pointer to current Entry
+;				D2 - Tail entry Pointer.
+;		Exit:	A1 - Pointer to next Entry.
+;				D1 - Preserved.
+;_______________________________________________________________________					<5>
+
+ZapVCBQueue
+			move.w	D1,-(SP)			; save for re-entrancy.
+			
+			move.w	vcbVRefNum(A1),D1	; get a VRefNum
+			move.l	QLink(A1),-(SP)		; go on to the next VCB
+			cmp.l	D2,A1
+			move.l	(SP)+,A1
+			beq.s	@FlushTime			; have we reached the end?
+			bsr.s	ZapVCBQueue			; not yet, save the VRefNum, call self.
+@FlushTime
+			move.w	D1,ioVRefNum(A0)	; set up the refNum in the PBlock.
+			_Eject
+			_HUnMountVol				; shut the volume down.
+			move.w	(SP)+,D1			; restore crucial VRefNum
+			Rts							; for reentrancy.
+
+;_______________________________________________________________________
+;
+; BlankDesktop
+;
+;	Blank the whole deskstop. This fills the entire desktop with black.
+;	It used to be the case that we wanted the screen to go white on
+;	portables, but that causes a really ugly white flash, and it’s
+;	not necessary since portables always (famouse last words) have
+;	soft power.  Note that this routine is now also called by restart
+;	instead of only during shutdown.  The reason for this is that
+;	many newer CPUs don’t pass the reset instruction thru the CPU
+;	to the I/O devices.  As a result, the desktop can persist on many
+;	displays thru BootBeep until PrimaryInit, which looks bad.
+;
+;	Note that it also hides the cursor, for a more tidy look.
+;
+;_______________________________________________________________________
+
+AllocFakeRgns	ROMBind	(Plus,$11ac),(SE,$13f4),(II,$2186),(Portable,$386c),(IIci,$27c0)
+
+BlankDesktop
+
+			_HideCursor						; Otherwise, hide it.
+
+			LEA 	-4(SP),A5				; start A5 here
+			SUB.W	#GrafSize+140,SP		; allocate global, port space
+			MOVE.L	SP,A6					; remember start of port
+
+			PEA 	-4(A5)					; point to QD global space
+			MOVE.B	QDExist,D3				; preserve state of QDExist flag (don't let us affect it)
+			_InitGraf						; initialize QuickDraw
+			MOVE.B	D3,QDExist
+
+			; allocate a grafPort using the stack and initialize it
+
+			JsrROM	AllocFakeRgns,A1		; init dummy vis and clip to wide-open			
+			MOVE.L	A6,-(SP)				; push address of grafPort
+			_InitPort						; initialize the port.  This particular case
+											;  doesn’t move memory, even when it calls COPYRGN!
+			MOVE.L	clipRgn(sp),-(sp)		; region for FillRgn
+
+			MOVE.L	#gestaltMiscAttr,D0
+			_Gestalt
+			MOVE.L	A0,D0
+
+			MOVE.L  GrafGlobals(A5),A1		; get QuickDraw globals
+
+			BTST	#gestaltSquareMenuBar,D0
+			BEQ.S	@black
+			PEA		white(A1)				; get white
+			BRA.S	@gotcolor
+@black
+			PEA		black(A1)				; get black
+@gotcolor
+
+			_FillRgn						; fill, wide region, with wide clip in wide bounded port
+											;  i.e. fill all screens with the appropriate color.
+											;  doesn’t move memory.
+			ADD.W	#GrafSize+140,SP		; dispose of the port
+			
+			RTS
+
+
+;_______________________________________________________________________
+;
+; CheckForSoftPowerOff
+;
+;	Check to see if this machine has a working PowerOff trap.
+;
+;	Note that this must be accurate for machines like the SE/30, since
+;	it is sometimes used to decide whether the user has choice between
+;	Shut Down and Restart.
+;
+;	Returns: Z if there is no soft power-off, NZ if there is
+;
+;_______________________________________________________________________
+
+CheckForSoftPowerOff
+
+			move.l	#gestaltHardwareAttr,d0		; check for soft power-off hardware				<39>
+			_Gestalt							; Gestalt										<39>
+			move.l	a0,d0						;	It’s not just a good idea.					<39>
+			btst	#gestaltHasSoftPowerOff,d0	;	It’s the law.								<39>
+
+			rts
+
+
+;_______________________________________________________________________
+;
+; GrayCLUT
+;
+;_______________________________________________________________________
+
+gcCntl		equ		-$78
+gcSlot		equ		-$38
+
+GrayCLUT
+			WITH	spBlock,cntrlParam
+
+			link	a6,#gcCntl
+
+			lea		gcSlot(a6),a0
+			move.l	#$30001,spCategory(a0)	; spCategory/spCType
+			move.l	#$1001A,spDrvrSW(a0)	; spDrvrSW/spDrvrHW
+			clr.b	spTBMask(a0)
+			clr.b	spSlot(a0)
+			clr.b	spID(a0)
+			clr.b	spExtDev(a0)
+			clr.l	spParamData(a0)
+			bset	#1,spParamData+3(a0)
+			_GetTypeSRsrc
+			bne.s	@return
+
+			lea		gcCntl(a6),a0
+			move.w	gcSlot+spRefNum(a6),ioCRefNum(a0)
+			move.w	#cscV8GoodBye,csCode(a0)
+			_Control ,Immed
+
+@return		unlk	a6
+			rts
+
+			ENDWITH
+
+
+;————————————————————————————————————————————————————————————————————————————————————————			 <4> HJR
+; Routine:	CloseLCDVideo																			  |
+;																									  v
+; Inputs:	none 
+;
+; Outputs:	none
+;
+; Trashes:	D0
+;
+; Function:	Run through the slot manager record looking for apple video.  Afterward check
+;			if the video is of type LCD.  If so, then close the video driver.  
+;————————————————————————————————————————————————————————————————————————————————————————
+
+CloseLCDFrame		RECORD	0, DECR
+CloseLCDSpBlk		DS.B	spBlock.spBlockSize		; Slot Manager param block.
+CloseLCDCntBlk		DS.B	IOVQElSize				; control call parm block
+CloseLCDFrameSize	EQU		*						; size of frame
+					ENDR
+
+CloseLCDVideo		
+		WITH CloseLCDFrame,spBlock
+			LINK	A6,#CloseLCDFrameSize			; allocate variable space
+			LEA		CloseLCDSpBlk(A6),A0			; Get pointer to spBlock
+			MOVE.L	#$00030001,$28(A0)				; spCategory=CatDisplay spCType=typTypVideo
+			MOVE.L	#$0001001B,$2C(A0)				; spDrvrSW=DrSwApple spDrvrHW=drHwTim
+			CLR.B	spTBMask(A0)
+			CLR.B	spSlot(A0)						; Set slot number
+			CLR.B	spId(A0)
+			CLR.B	spExtDev(A0)					; No external devices
+			CLR.L	spParamData(A0)
+			BSET	#1,spParamData+3(A0)
+			_GetTypeSRsrc							; get the spsPointer
+			BNE.S	@Done
+
+			LEA		CloseLCDCntBlk(A6),A0			; Get pointer to ioPB
+			MOVE.W	CloseLCDSpBlk+spRefNum(A6),ioRefNum(A0)		; Get the driver refNum
+			_Close									; Close the driver
+
+@Done
+			UNLK	A6								; Clean up the stackframe
+			RTS										;												<4> HJR
+		ENDWITH
+
+
 
 ;_______________________________________________________________________
 ;
@@ -348,884 +1094,73 @@ SDHeader 		EQU 	$BBC			; low mem for ROM version
 ;	Will not stick around in System builds, but will be there for ROMs.
 ;_______________________________________________________________________
 
-ShutInit		PROC	Export
-				moveq	#10,D0					; SD Queue Header is pointed to by low memory in ROM
-				_NewPtr sys,clear
-				move.l	A0,SDHeader
+				EXPORT	SDHeader
+SDHeader		dcb.b	10,0
 
-				pea		DoDrivers				; the default routine to unload				
+ShutInit		InstallProc		(Plus,SE,II,Portable,IIci)
+
+				IMPORT	SDHeader				; SD Queue Header is inside this resource
+				lea		SDHeader,A1
+				clr.l	(A1)+
+				clr.l	(A1)+
+				clr.w	(A1)
+
+				peaResident	DoDrivers			; the default routine to unload				
 				move.w	#SDOnUnMount,-(SP)		; all drivers with a goodbye
 				jsr		ShutInstall				; install it in the queue
 
-				pea		DoUnmount				; the default routine to unmount volumes		
+				peaResident	DoUnmount			; the default routine to unmount volumes		
 				move.w	#sdRestartOrPower,-(SP)	; do before power-off or restart
 				jsr		ShutInstall
 
-				pea		ClearWarmStart
+				peaResident	ClearWarmStart
 				move.w	#sdOnPowerOff,-(SP)		; only on 'shut down'						<26>
 				jsr		ShutInstall				; install it in the queue					<26>
 
 				Rts
 
 
-;_______________________________________________________________________
-;
-; Routine:		ShutDown
-;
-; Arguments:	A0 (input) :	address of a ShutDown routine
-;				D0 (input) :    command word (SDInit, SDPowerOff ...)
-;				D1 (input) :    for an SDInstall operation, the flags word.
-;
-; Function: 	This routine dispatches to one of several functions:  SDInit
-;					initializes the ShutDown Queue and sets up a default
-;					shutdown routine to eject disks.  SDPowerOff calls the
-;					power down routines, and then turns power off (or waits
-;					for the user to do so).  SDRestart calls the restart routines
-;					and then does a re-boot.  SDInstall installs a power
-;					off or restart proc.  SDRemove removes a proc.
-;
-; ShutDown(OpWord)
-;
-;_______________________________________________________________________
-				EXPORT	Shutdown
-				
-ShutDown		move.l	(SP)+,D2			; save return
-				move.w	(SP)+,D0			; get opcode word
-				move.l	D2,-(SP)			; restore the return
-				subq	#SDPowerOff,D0
-				bcs.w	ShutInit			; if d0=0, _SDInit a selector in ROM versions
-				beq		ShutPower			; if d0=1, Shutdown
-
-				subq	#SDInstall-SDPowerOff,D0	
-				bcs		ShutRestart			; if d0=2, carry set, bra to restart
-				beq.s	ShutInstall			; if d0=3, Install
-
-				subq.w	#sdUserChoice-sdInstall,d0	
-				bmi.s	ShutRemove			;if  d0=4, Remove
-				beq		UserChoice			; if d0=5, User Choice
-@unknownSelector
-				rts							; unknown selector (do nothing, assume no parameters)
-
-;_______________________________________________________________________
-;
-; ShutInstall - Installs a shutDown procedure in the SD Queue.
-;		Entry On Stack: Long - Proc pointer, to install in Queue, call later.
-;						Word - Flags word, with low bits defining when to call proc.
-;
-; ShutDown(Proc, WhenFlags, 3)
-;_______________________________________________________________________
-
-				EXPORT	ShutInstall
-ShutInstall
-				move.l	(SP)+,D2
-				move.w	(SP)+,D1				; get flags word
-				move.l	(SP)+,a1				;  and ProcPointer
-				move.l	D2,-(SP)
-				moveq	#QSDRecSize,D0			; create the queue element.
-				_NewPtr sys
-				move.w	D1,QType(A0)			; stuff in the flags and proc.
-				move.l	A1,QSDProcPtr(A0)
-
-				move.l SDHeader,A1			 	; get address of queue
-				_Enqueue						; install it in the queue
-				Rts
-
-;_______________________________________________________________________
-;
-; ShutRemove - Removes a shutDown procedure in the SD Queue.
-;		Entry:	TOS - Proc pointer, to remove from the Queue.
-;		Exit:	D0 - Error Code.
-;
-; ShutDown(Proc, 4)
-;_______________________________________________________________________
-
-				Export	ShutRemove
-ShutRemove
-				move.l	(SP)+,D2
-				move.l	(SP)+,A0				; get proc pointer from NOS
-				move.l	D2,-(SP)
-				move.l	A2,-(SP)
-				move.l SDHeader,A1	 			; get address of queue
-				AddQ	#QHead,A1				; point to the head
-				move.l	(A1)+,A2
-				move.l	(A1),D0					; remember the tail
-				beq.s	@NotFound				; are there any entries?
-
-; Search for the matching entry.
-
-@ScanLoop
-				cmp.l	QSDProcPtr(A2),A0		; is this the one?
-				beq.s	@Found
-
-				move.l	QLink(A2),A1			; get the link to the next.
-				cmp.l	A2,D0					; did we do the end?
-				move.l	A1,A2
-				Bne.S	@ScanLoop
-@NotFound
-				moveq	#qErr,D0				; return error - not found.
-				Bra.S	@Terminate
-@Found
-				move.l SDHeader,A1				; get the SD Queue Header A1.
-				move.l	A2,A0
-				_Dequeue						; remove it from the linked list.
-				move.l	A2,A0
-				_DisposPtr						; de-allocate the memory for the pt
-@Terminate
-				move.l	(SP)+,A2				; restore work registers
-				Rts
-
-;_______________________________________________________________________
-;
-; ShutRestart - do a shut-down and restart the system
-;
-;		Entry:	no parameters
-;		Exit:	never does.
-;
-; ShutDown(2)
-;_______________________________________________________________________
-;
-;	Some history for all you young'ns:
-;
-;	Some things to be aware of about the RESET instruction on various Macintosh Products	<2.7>
-;
-;	1)	This code is in ROM on Aurora, Esprit, F19, and all new CPUs.  It is in RAM, from
-;		the System Disk on the Mac Plus, SE, II, IIx, IIcx, SE30.
-;
-;	2)	StartInit contains a RESET instruction in ROM on the 68020/030 CPU ROMs.
-;
-;	3)	On the Mac Plus and Mac SE, a RESET will cause the 68000 to get a Reset, and it
-;		will switch into overlay mode, and  Re-Boot through the reset vector.
-;
-;	4)	When running a ROM image out of RAM, we do not want to do a RESET, because it will
-;		cause a switch into overlay mode, and the RAM base code cannot be fetched.
-;
-;	5)	On 68030 based machines, if the translation tables are in RAM (AURORA/F19, VM or Romulator),
-;		you should not do a RESET when the MMU is enabled, even if you are executing in ROM.
-;		If there is a miss in the ATC, it will attempt to fetch descriptors from RAM, but overlay
-;		is now enabled, and data from ROM will be used instead, causing lots of problems.
-;
-;	6)	Esprit has some problem when RESET is executed, and RESET should NEVER be used.
-;
-;	7)	This all means that RESET is only needed on a MacPlus and MacSE.
-;		It might not be a problem on machines based on the MacII/IIx ROMs,
-;		since they have the MMU tables in ROM, but it is not reccommended.
-;		All other situations should not do a RESET in Shutdown.
-;
-
-						
-				export	ShutRestart	
-ShutRestart		
-				with	ROMHeader				
-
-				moveq	#sdOnPowerOff,d5		; Remove poweroff routines from the queue		<13>
-				bsr		RemoveOtherRoutines
-
-				moveq	#SDBitRestart,D0		; remember that we will reboot.
-				bsr		CallRoutines			; do the shutDown cleanup.
-
-				moveq	#1,D5					; Go ahead and hide cursor/close LCDs.
-				bsr		BlankDesktop			; Go blank the desktop.
-
-				move.l	ROMBase,A2					; point to the ROM
-				lea		ROMHeader.Restart(A2),A2	; point to the restart routine
-
-				move.l	#emuWarmStartConst,D0	; Does the upper long match?
-				move.l	#WmStConst,D1			; Does the upper long match?
-				bsr		UpdateEmuWarmstart		; Write the warmstart (We may have come from a shutdown...) <MC8>
-							
-				tst.l	VMGlobals				; Is VM running?
-				bmi.s	@noVM					; -> No.  Assume we're in Supervisor Mode				
-				_EnterSupervisorMode			; Enter supervisor mode (don’t worry about munging the stack...)
-@noVM
-				bsr		DockInitSCC				; reset the SCC	(if we have Power controls)				<SM16><3>
-
-				TestFor	JawsExists				; are we running on a Tim machine with JAWS				<SM16><5> HJR
-				beq.s	@noJAWS					; -> No JAWS, jump to RESTART now.						<SM16><43>
-
-				with	PmgrRec, pmCommandRec
-@JawsRestartSeq									; -- Special Case for JAWS --							<5> HJR
-				move.l	PMgrBase,a0				; get pointer to the power manager globals
-				move.l	HDVector(a0),a0			; get pointer to hard disk power down
-				jsr		(a0)					; kill the hard disk
-				lea		-pmBlkSize(sp),sp		; Create stack frame									<v5.7>
-				lea		pmData(sp),a0			; Get pointer to a xmit buffer
-				move.l	a0,pmRBuffer(sp)		; Load pointer to receive buffer
-				move.l	a0,pmSBuffer(sp)		; Load pointer to xmit buffer
-				clr.l	(a0)					; No data
-				clr.w	pmLength(sp)			; No data
-				move.w	#$21,pmCommand(sp)		; ADB autopoll disable
-				move.l	sp,a0					; a0 get pointer to paramter block
-				_PmgrOp							; go kill the machine
-				clr.l	pmData(a0)				; clear data
-				clr.w	pmLength(a0)			; clear length
-				move.w	#$d0,pmCommand(sp)		; reset CPU command
-				move.w	Timedbra,d1				; set-up our counter
-				lsl.w	#2,d1					; give ourselves 4 milliseconds
-				_PmgrOp							; go kill the machine
-
-@waitloop		dbra	d1,@waitloop			; stick around for 4 milliseconds
-												; Fall into the JMP to Restart							<43>
-
-	; Finally!  Restart the machine by Jumping through the Restart vector in the ROM header
-	
-@noJAWS			JMP		(A2)					; exit thru the restart routine							<mc2>				
-
-;________________________________________________________________________________________________
-
-
-
-;_______________________________________________________________________
-;
-; ShutPower - Do a shutDown and power off the system if possible.  If it’s
-;				and older system (no power off ability) then put up an
-;				alert that the system can go down now.
-;
-;		Entry:	no parameters
-;		Exit:	never does.
-;
-; ShutDown(1)
-;_______________________________________________________________________
-				export	ShutPower
-				
-ShutPower		
-				bsr		DoRAMDiskAlert			; Check for RAM disk.  Should we kill the power?
-				beq		@continuePowerOff		; -> Yes.  Pull the plug!				
-				rts								; Cancel the Shutdown.
-
-@continuePowerOff
-
-				moveq	#sdOnRestart,D5			; Remove all restart procedures from the queue	<13>
-				bsr.w	RemoveOtherRoutines		; Go remove these procedures from the queue		<13>
-
-				moveq	#SDBitPowerOff,D0		; pass parameter: power off.
-				bsr.w	CallRoutines			; do cleanup and check if new mac.
-
-				moveq	#1,D5					; Go ahead and hide cursor/close LCDs.
-				bsr		BlankDesktop			; Clear the whole desktop.
-								
-				bsr		FindEDisk				; Do we have an EDisk in the drive Q?
-				beq.s	@noEDisk				; -> Nope, continue w/power off
-				bsr		KillEDisk				; Clear the EDisk's checksum data (invalidate the disk)
-@noEDisk
-
-	; Send Sonic a soft reset																	<16> thru next <16>
-
-				TestFor	SonicExists				; Does this machine have a SONIC ENet chip?
-				beq.s	@noSONIC				; IF hasSONIC THEN
-
-				With	DecoderInfo
-				movea.l	UnivInfoPtr,a0			;     get address of universal product info
-				adda.l	ProductInfo.DecoderInfoPtr(a0),a0; and point to table of base addresses
-				moveq	#SonicExists,d0			;     get offset to Sonic base address
-				movea.l	(a0,d0.w*4),a0			;     grab Sonic base address
-				tst.l	a0						;     check address just in case its bogus (?)
-				beq.s	@noSONIC				;     dont do anything if address is zero
-				bset	#7,(a0)					;     bit 7 of SonicAddr+0 causes a SW reset
-				EndWith
-@noSONIC										; ENDIF											<16>
-
-				bsr		CheckForSoftPowerOff	; does this machine have software power-off?
-				bz.s	@noSoftPowerOff			; no, don’t even try it
-
-				_PowerOff						; turn power off
-												; it’s nice that we fall through if PowerOff does nothing
-@noSoftPowerOff
-				_InitCursor
-				moveq	#shutDownAlert,D0
-
-;_______________________________________________________________________
-;
-; DoSysErrDialog
-;
-;	Put up a dialog (done by the system error handler).
-;	The system error ID must be in D0.
-;
-;_______________________________________________________________________
-
-DoSysErrDialog
-				clr.l	ResumeProc				; don’t show resume button
-				_SysError						; will never return
-
-;_______________________________________________________________________
-;
-; UserChoice
-;
-;	Start off as a power-off. If the machine supports soft power-off,
-;	we give the user a choice between Restart and Shut Down (some of the
-;	code to handle this is in system error tables). If the machine
-;	does not support soft power-off, Shut Down and Restart are equivalent,
-;	so we put up an alert with a single Restart button (the text reflects
-;	the fact that the computer made the choice).
-;
-;_______________________________________________________________________
-
-UserChoice
-				moveq	#0,D5					; Don’t hide cursor/close LCDs.
-				bsr		BlankDesktop			; Clear the entire desktop for consistency.
-
-				bsr		CheckForSoftPowerOff	; does this machine have software power-off?
-				bz.s	@noSoftPowerOff			; no!
-
-				move.w	#dsShutDownOrRestart,d0	; yes, let the user choose Shut Down or Restart
-				bra.s	DoSysErrDialog
-
-@noSoftPowerOff
-				moveq	#sdBitPowerOff,d0		; notify just as we would for PowerOff
-				bsr.s	CallRoutines			; go do the notification
-
-				move.w	#dsSwitchOffOrRestart,d0	; no, let the user switch off or Restart
-				bra.s	DoSysErrDialog
-
-
-;_______________________________________________________________________
-;
-; CallRoutines
-;		Entry:	D0 - Bit number to test (shutdown type).
-;		Exit:	regs saved.
-;_______________________________________________________________________
-
-CallRoutines
-				movem.l	A1-A3/D0-D5,-(SP)
-				move.w	D0,D4
-
-; Call Cleanup for Drivers, and Custom cleanup Procs.
-
-				moveq	#SDBitDrivers,D5		; do Pre-Driver cleanUp
-				bsr.s	CallCleanUp
-
-; Call Cleanup to unmount volumes, and then custom PowerOff/Restart.
-
-				moveq	#SDBitUnMount,D5		; do Vol UnMounts
-				bsr.s	CallCleanUp
-				move.w	D4,D5					; do PowerOff or ReStart cleanup
-				bsr.s	CallCleanUp
-
-; set up the flags for the caller.
-
-				movem.l	(SP)+,A1-A3/D0-D5
-				Rts
-
-;_______________________________________________________________________
-;
-; RemoveOtherRoutines - Remove all occurences of the passed in shutdown procedure type from the shutdown queue.	<13>
-;		This differentiates routines that wish to be executed before drivers on restart, but not at all on poweroff
-;		(as an example).  Before, there was no differentiation between restart and poweroff for routines that were
-;		to run before drivers close, or before volumes are unmounted.  There are cases when such differentiation
-;		is desired, but was previously impossible.  By removing routines of the “other” type (other being restart on
-;		a poweroff, and vice versa), the only routines left in the queue are those that should be executed.  Routines
-;		that execute on both poweroff and restart are left in the queue.  On a final note, the routines aren’t actually
-;		removed from the queue, since the machine will either be powered off or restarted in a few seconds, so it really
-;		doesn’t matter what gets left lying around in memory.  This way, a call to _SDRemove is saved.
-;
-;		Entry:	D5 - Bit number of shutdown type to remove from queue
-;		Exit:
-;_______________________________________________________________________
-
-RemoveOtherRoutines
-				move.l	SDHeader,A1				; get header into A1.
-				Lea		QHead(A1),A3			; point to the head
-				move.l	(A3)+,A2
-				move.l	(A3),D3					; remember the tail
-				beq.s	@NotFound				; are there any entries?
-
-; Find entry that matches the type to remove
 
-@ScanLoop
-				move.l	QLink(A2),A3			; get the link to the next
-				move.w	QType(A2),D0			; get the shutdown flags
-				andi.w	#3,d0					; We’re only interested in the poweroff and restart bits
-				cmp.w	d0,d5					; Is this a type that should be removed?
-				bne.S	@DontRemove				; don’t remove this entry
-
-; now remove the proc from the queue.
-; Since the whole state of the machine is going into la-la land very shortly, there’s no point
-; in actually removing the procedure.  Just zapping the shutdown flags to zero to prevent this
-; routine from being found again is good enough.												<13>
-
-				clr.w	QType(a2)				; QType holds the shutdown flags
-
-@DontRemove
-				cmp.l	A2,D3					; at the end?
-				move.l	A3,A2
-				Bne.S	@ScanLoop
-@NotFound
-				Rts
-
-;_______________________________________________________________________
-;
-; CallCleanUp
-;		Entry:	D5 - Bit number to test (shutdown type).
-;		Exit:
-;_______________________________________________________________________
-
-CallCleanUp
-				move.l SDHeader,A1					; get header into A1.
-				Lea		QHead(A1),A3			; point to the head
-				move.l	(A3)+,A2
-				move.l	(A3),D3					; remember the tail
-				beq.s	@NotFound				; are there any entries?
-
-; Search for an entry that wants a call now.
-
-@ScanLoop
-				move.l	QLink(A2),A3			; get the link to the next
-				move.w	QType(A2),D0			; get the shutdown flags
-				BTst	D5,D0					; want call now?
-				beq.s	@DontCallUs				; don’t call for this kind
-
-; call the proc, with bit number in D0, in case it cares.
-
-				move.l	QSDProcPtr(A2),A0		; call the shutdown routine
-				move.w	D5,D0					; pass bit number in D0
-				Jsr		(A0)
-
-; now remove the proc from the queue.
-; Since the whole state of the machine is going into la-la land very shortly, there’s no point
-; in actually removing the procedure.  Just zapping the shutdown flags to zero to prevent this
-; routine from being found again is good enough. <13>
-
-				clr.w	QType(a2)				; QType holds the shutdown flags
-@DontCallUs
-				cmp.l	A2,D3					; at the end?
-				move.l	A3,A2
-				Bne.S	@ScanLoop
-@NotFound
-				Rts
-
-;_______________________________________________________________________
-;
-; DoDrivers - The Default shutdown routine to kiss all of the drivers
-;					goodbye.
-;		Entry:	No paramters.
-;
-;_______________________________________________________________________
-
-			export	DoDrivers
-DoDrivers
-			; first, send a doGoodBye call to all drivers that want one
-
-			MOVEM.L	D0-D1/D4-D7/A0-A1,-(SP)			; save registers		<4> jmp
-			SUB		#IOQElSize,SP					; allocate pBlock
-			MOVE	#-1,CSCode(SP)					; set up control code
-			MOVE.L	UTableBase,A1					; point to unit table
-			MOVE.W	UnitNtryCnt,D1					; get # entries in unit table
-@loop
-			MOVE.L	(A1)+,D0						; get the DCE handle
-			BEQ.S 	@next		 					; if NIL, try next one
-
-			MOVE.L	D0,A0							; get the DCE handle
-			MOVE.L	(A0),A0 						; get the DCE pointer
-
-;------------------------------------------------------------------------	<4> jmp
-			
-			Btst	#dRamBased,DCtlFlags+1(A0)		; If we’ve got a pointer, then just skip
-			Beq.s	@skipVidChk						;	this code (our drivers are RamBased).
-			
-			Move.l	A0,D7							; Save pointer to DCE.
-			Move.l	A1,D6							; Save UTable pointer.
-			
-			Move.l	dCtlDriver(A0),A0				; Get handle to driver.
-			Move.l	(A0),A0							; Get pointer to driver.
-			Lea		drvrName(A0),A0					; Point to driver name.
-			Move.l	A0,D5							; Save it for later.
-			
-			moveq	#0,D0							; Prepare D0.
-			Move.b	(A0),D0							; Get the length of the driver name.
-			Move.w	D0,D4							; Make a copy.
-			Addq	#2,D4							; Adjust offset to version field (len + 1)
-			Bclr	#0,D4							; Adjust offset for word alignment.
-			Move.w	(A0,D4.w),D4					; Get the version number.
-			Bne.s	@endVidChk						; If non-zero, then just leave.
-			
-			Swap	D0								; Get 1st string length into hi-word.
-			Addq	#1,A0							; Point to text of driver name.
-			Lea		TimVidTitle,A1					; Point to TIM/TIM-LC’s video driver name.
-			Move.b	(A1)+,D0						; Get 2nd string length into lo-word.
-			_CmpString								; Compare drvrName with TimVidTitle.
-			Tst.b	D0								; If this is the TIM/TIM-LC driver,
-			Beq.s	@fixFlags						;	then don’t kiss it goodbye.
-			
-			Move.l	D5,A0							; Restore pointer to driver name.
-			moveq	#0,D0							; Re-prepare D0.
-			Move.b	(A0)+,D0						; Get length of 1st string…
-			Swap	D0								; 	…into the hi-word.
-			Lea		DAFBVidTitle,A1					; Point to Spike/Eclipse video driver name.
-			Move.b	(A1)+,D0						; Get 2nd string length into lo-word.
-			_CmpString								; Compare drvrName with DAFVidTitle.
-			Tst.b	D0								; If this is the DAFB (Spike/Eclipse) driver,
-			Beq.s	@fixFlags						;	then don’t kiss it goodbye.
-			Bra.s	@endVidChk						; Otherise, just leave.
-			
-@fixFlags	Move.l	D7,A0							; Restore pointer to DCE.
-			Bclr	#DNeedGoodbye,DCtlFlags(A0) 	; Reset the good-bye kiss flag.
-
-@endVidChk	Move.l	D7,A0							; Restore pointer to DCE.
-			Move.l	D6,A1							; Restore pointer to UTable.
-			
-@skipVidChk
-
-;------------------------------------------------------------------------	<4> jmp		
-			
-			BTST	#DNeedGoodbye,DCtlFlags(A0) 	; need a goodbye kiss?
-			BEQ.S 	@next		 					; not tonight dear
-
-			; we found one that needs a goodbye call so issue the control call
-
-			MOVE.W	DCtlRefNum(A0),IORefNum(SP) 	; set up the refNum
-			MOVE.L	SP,A0							; point to the DCE
-			_Control								; kiss it goodbye...
-@next
-			SUBQ		#1,D1						; check next entry
-			BNE.S 	@loop	 						; if so, loop
-
-			; done, return
-
-			ADD		#IOQElSize,SP					; deallocate pBlock
-			MOVEM.L	(SP)+,D0-D1/D4-D7/A0-A1			; restore registers		<4> jmp
-			RTS
-
-;------------------------------------------------------------------------	<4> jmp		
-
-			String	Pascal
-
-TIMVidTitle
-			DC.W	'.Display_Video_Apple_TIM'		; Name of TIM/TIM-LC Video Driver.
-
-DAFBVidTitle
-			DC.W	'.Display_Video_Apple_DAFB'		; Name of Spike/Eclipse Video Driver.
-
-;------------------------------------------------------------------------	<4> jmp		
-
-;_______________________________________________________________________
-;
-; DoUnmount - Unmount all of the volumes on line, so the disks will be updated before our power off.
-;
-;		Entry:	No parameters.
-;
-;_______________________________________________________________________
-
-			export	DoUnmount
-DoUnmount
-			sub		#IOQElSize,SP				; allocate pBlock
-
-; Go through the VCB Queue to Flush and eject all volumes.
-
-		  	move.l	SP,A0						; point to the parameter block
-			clr.L	ioVNPtr(A0)
-			clr.W	ioRefNum(A0)
-			move.l	VCBQHdr+QHead,A1			; get the queue header
-			move.l	VCBQHdr+QTail,D2			; get the tail too
-			beq.s	@AllFlushed
-			bsr		ZapVCBQueue					; wipe out the whole queue
-
-@AllFlushed
-			add.W	#IOQElSize,SP				; deallocate pBlock
-			
-	; Wait for all floppy drives that have diskettes inserted to eject, or for 2 seconds,
-	; whichever comes first.  (Note:  This should now be “universal,” even
-	; for CPUs that don’t have auto-eject floppy mechanisms.)
-
-taskActive	equ		7							; High bit of qType word is active flag.
-
-			moveq.l	#(tmXQSize/2)-1,D0			; Set up the init-loop counter.
-@clrTask	clr.w	-(Sp)						; Allocate and clear a TMTask record.
-			dbra	D0,@clrTask					; Do it one word at a time.
-			move.l	Sp,A0						; Point to the TMTask record.
-			_InsXTime							; Install it.
-			
-			move.l	#2*1000*1000,D0				; We need ~1.5sec, but we’ll say 2sec for safety.
-			neg.l	D0							; (Negate for µsec timer.)
-			_PrimeTime							; Start the TMTask.
-
-			move.l	DrvQHdr+QHead,D0			; Now, get a pointer to the first drvQElem.
-@Repeat		move.l	D0,A1						; Copy the drvQElem pointer into A1.
-			cmpi.w	#-5,dqRefNum(A1)			; If this isn’t a floppy (.Sony) driver drive,
-			bne.s	@Until						;	then just go on.
-			
-@WaitEject	btst.b	#taskActive,qType(A0)		; If the TMTask has completed,
-			beq.s	@TimedOut					;	then we can now exit this loop.
-			move.l	-4(A1),D0					; Otherwise, get the drvQElem flags.
-			andi.l	#$00FF0000,D0				; If the media is still in the mechanism,
-			bne.s	@WaitEject					;	then just wait.
-			
-@Until		move.l	qLink(A1),D0				; Otherwise, get the next entry in the queue.
-			bne.s	@Repeat						; Loop until done.
-			
-@TimedOut	_RmvTime							; Remove TMTask.
-
-			adda.w	#tmXQSize,Sp				; Reclaim the stack space.
-		  	rts
-
-;_______________________________________________________________________					<5>
-;
-; ClearWarmStart - Shutdown task to clear warm start variable if user
-;					chooses 'Shut Down' from the Finder.
+;__________________________________________________________________________________
 ;
-;_______________________________________________________________________					<5>
-
-			export	ClearWarmStart
-
-ClearWarmStart
-			movea.l	BootGlobPtr,A0					; point to bootGlobals
-			clr.l	StartGlobals.sgWarmStart(A0)	; clear warm start flag
-			clr.l	WarmStart						; write warm start constant to indicate warm start
-			
-			moveq	#0,D0							; hi long
-			moveq	#0,D1							; lo long
-			bsr.l	UpdateEmuWarmstart				; Clear the warmstart					<MC8>	
-			
-			rts
-
-
-
-;_______________________________________________________________________					<MC8> SAM
-;
-; UpdateEmuWarmstart - 
-;
-;	 The emulator warmstart flag lives in the writeprotected diagnostic info block in the Nanokernel's
-;	 data page.  We need to "map" the diag page to a normally mapped page of RAM, write the warmstart
-;	 constant, and remap the memory back the way it was.  Oh, I'm using logical page number 1
-;	 (i.e. $1000 - 4k pages). Oh, yeah, the RAM at $1000 never actually gets modified...
-;
-;	Entry - D0.l warmstart low
-;			D1.1 warmstart high
-;
-;_______________________________________________________________________					<MC8>
-			Export	UpdateEmuWarmstart
-
-UpdateEmuWarmstart	
-			With	nkDiagInfo	
-
-			testFor	has68kEmulator					; Does this machine have a V0 style emulator?
-			beq		@Done							; -> Nope, we're done.  Exit.
-			
-			move	SR,-(SP)						; Save SR
-			ori.w	#hiIntMask,SR					; Disable interrupts
-			movem.l	D2-D7,-(SP)						; Save some D regs
-			
-			move.l	D0,D6
-			move.l	D1,D7
-			move.w	#12,D2							; Shift Count (12 bits in 4k)
-			
-			lea		1,A0							; Logical page #1 ($1000)
-			_nkGetPTEntryGivenPage					; Get its Pte
-			move.l	D0,D3							; Save the Pte in D3
-			
-			move.l	(nkDiagInfoPtr),D0				; Get the DiagPage Logical Address
-			move.l	D0,D5							; Make a copy
-			and.l	#4096-1,D5						; Get the offset into the page
-			
-			lsr.l	D2,D0							; Make it a page number
-	
-			move.l	D0,A0							; Page into A0
-			_nkGetPTEntryGivenPage					; Get the Diag Pte
-			move.l	D0,D4							; Save it
-			
-			lea		1,A0							; Get the buffer page number in A0
-			lea		1,A1							; Say page is inited (#1)
-			_nkMMUMarkBacking						; Mark this page as outta here
-	
-			lea		1,A0							; Logical Page number of the buffer
-			move.l	D4,D0							; Get the Diag Pte
-			lsr.l	D2,D0							; Get its Physical Page number
-			move.l	D0,A1							; Set Physical Page
-			_nkMMUMarkResidentGlue					; Map the diag's physical address to the buffer's logical addr
-	
-			lea		$1000,A0						; Get our logical starting point
-			add.l	D5,A0							; Add in the offset from the start of the diag page
-			
-			move.l	D6,DiagWarmStartLow(A0)
-			move.l	D7,DiagWarmStartHigh(A0)
-	
-			lea		1,A0							; Get the lo Page number in A0
-			lea		1,A1							; Say page is inited (#1)
-			_nkMMUMarkBacking						; Mark this page as outta here
-	
-			lea		1,A0							; Get the lo Page number in A0
-			move.l	D3,D0							; Get the LoPage's Pte
-			lsr.l	D2,D0							; Get its Physical Page number
-			move.l	D0,A1							; Set Physical Page
-			_nkMMUMarkResidentGlue					; Move the HiPage to the loPage's logical addr
-	
-			movem.l	(SP)+,D2-D7						; Save some D regs
-			move	(SP)+,SR						; Restore IRQ enable state
-
-@Done		rts										; all done
-			
-			EndWith
-
-;_______________________________________________________________________					<5>
-; ZapVCBQueue - This routine goes through the VCB Queue, and calls HUnmountVol for each entry.
-;
-;		Entry:	A0 - IOParam Block
-;				A1 - Pointer to current Entry
-;				D2 - Tail entry Pointer.
-;		Exit:	A1 - Pointer to next Entry.
-;				D1 - Preserved.
-;_______________________________________________________________________					<5>
-
-ZapVCBQueue
-			move.w	D1,-(SP)			; save for re-entrancy.
-			
-			move.w	vcbVRefNum(A1),D1	; get a VRefNum
-			move.l	QLink(A1),-(SP)		; go on to the next VCB
-			cmp.l	D2,A1
-			move.l	(SP)+,A1
-			beq.s	@FlushTime			; have we reached the end?
-			bsr.s	ZapVCBQueue			; not yet, save the VRefNum, call self.
-@FlushTime
-			move.w	D1,ioVRefNum(A0)	; set up the refNum in the PBlock.
-			_Eject
-			_HUnMountVol				; shut the volume down.
-			move.w	(SP)+,D1			; restore crucial VRefNum
-			Rts							; for reentrancy.
-
-;_______________________________________________________________________
-;
-; BlankDesktop
-;
-;	Blank the whole deskstop. This fills the entire desktop with black.
-;	It used to be the case that we wanted the screen to go white on
-;	portables, but that causes a really ugly white flash, and it’s
-;	not necessary since portables always (famouse last words) have
-;	soft power.  Note that this routine is now also called by restart
-;	instead of only during shutdown.  The reason for this is that
-;	many newer CPUs don’t pass the reset instruction thru the CPU
-;	to the I/O devices.  As a result, the desktop can persist on many
-;	displays thru BootBeep until PrimaryInit, which looks bad.
-;
-;	Note that it also hides the cursor, for a more tidy look.
-;
-;_______________________________________________________________________
-
-			IMPORT	AllocFakeRgns			;
-
-BlankDesktop
-
-			MOVE.L	A5,-(Sp)				; Save A5-world. Why?
-
-; Somewhat stolen from StartAlert.a
-
-			TST.B	D5						; If we’re not supposed to hide the cursor,
-			BEQ.S	@SkipHide				;	then just go on.
-			_HideCursor						; Otherwise, hide it.
-@SkipHide
-
-			LEA 	-4(SP),A5				; start A5 here
-			SUB.W	#GrafSize+140,SP		; allocate global, port space
-			MOVE.L	SP,A6					; remember start of port
-
-			PEA 	-4(A5)					; point to QD global space
-			MOVE.B	QDExist,D3				; preserve state of QDExist flag (don't let us affect it)
-			_InitGraf						; initialize QuickDraw
-			MOVE.B	D3,QDExist
-
-			; allocate a grafPort using the stack and initialize it
-
-			BigJsr	AllocFakeRgns,A1		; init dummy vis and clip to wide-open			
-			MOVE.L	A6,-(SP)				; push address of grafPort
-			_InitPort						; initialize the port.  This particular case
-											;  doesn’t move memory, even when it calls COPYRGN!
-			MOVE.L	clipRgn(sp),-(sp)		; region for FillRgn
-
-			MOVE.L  GrafGlobals(A5),A1		; get QuickDraw globals
-			PEA		black(A1)				; get black
-
-			_FillRgn						; fill, wide region, with wide clip in wide bounded port
-											;  i.e. fill all screens with the appropriate color.
-											;  doesn’t move memory.
-			ADD.W	#GrafSize+140,SP		; dispose of the port
-			
-			TST.B	D5						; If we’re not supposed to close LCDs,
-			BEQ.S	@SkipClose				;	then just go on.
-			BSR		CloseLCDVideo			; Otherwise, close ’em.
-@SkipClose
-
-			MOVE.L	(Sp)+,A5				; Restore A5-world.
-			RTS
-
-
-;_______________________________________________________________________
-;
-; CheckForSoftPowerOff
-;
-;	Check to see if this machine has a working PowerOff trap.
+;	EnablePDMsgs - Enable Eclipse PowerDown Messages
 ;
-;	Note that this must be accurate for machines like the SE/30, since
-;	it is sometimes used to decide whether the user has choice between
-;	Shut Down and Restart.
-;
-;	Returns: Z if there is no soft power-off, NZ if there is
-;
-;_______________________________________________________________________
-
-CheckForSoftPowerOff
+;		This causes Caboose PowerDown messages to be sent to Eclipse instead of
+;		having Caboose turn the power off FOR you.  This way, we can unmount volumes
+;		and flush file caches, etc.  The code that does this is initialized in the ROM
+;		but has problems running before the filesystem is initialized.  Hence, it lives
+;		here because this is where the ShutdownMgr finally gets itself established.
+;__________________________________________________________________________________
 
-			move.l	#gestaltHardwareAttr,d0		; check for soft power-off hardware				<39>
-			_Gestalt							; Gestalt										<39>
-			move.l	a0,d0						;	It’s not just a good idea.					<39>
-			btst	#gestaltHasSoftPowerOff,d0	;	It’s the law.								<39>
 
-			rts
-
-
-;————————————————————————————————————————————————————————————————————————————————————————			 <4> HJR
-; Routine:	CloseLCDVideo																			  |
-;																									  v
-; Inputs:	none 
+EnablePDMsgs	InstallProc		(IIci,hasTERROR)
+;	Only perform this initialization on machines that have Caboose-style keyswitches			<5>
+;	(i.e.:  Eclipse + Zydeco)																	<5>
 ;
-; Outputs:	none
+			move.l	d0,-(sp)						; save a handy working register				<5>
+			move.l	#KeyswMask,d0					; get isolation mask ready					<5>
+			and.l	UnivROMFlags,d0					; grab keyswitch bits in UnivROMFlags		<5>
+			sub.l	#KeyswCaboose,d0				; and check if we're a Caboose keyswitch	<5>
+			movem.l	(sp)+,d0						; restore D0 (MOVEM doesn't reset CCR)		<5>
+			bne.s	@exit							; IF Caboose-Style Keyswitch THEN			<5>
 ;
-; Trashes:	D0
+;		Enable Caboose/Cuda to send Power Down Messages
 ;
-; Function:	Run through the slot manager record looking for apple video.  Afterward check
-;			if the video is of type LCD.  If so, then close the video driver.  
-;————————————————————————————————————————————————————————————————————————————————————————
-
-CloseLCDFrame		RECORD	0, DECR
-CloseLCDCntBlk		DS.B	IOVQElSize				; control call parm block
-CloseLCDSpBlk		DS.B	spBlock.spBlockSize		; Slot Manager param block.
-CloseLCDFrameSize	EQU		*						; size of frame
-					ENDR
-
-CloseLCDVideo		
-CloseLCDVideoRegs	REG		D1/A0-A1	
-		WITH CloseLCDFrame,spBlock
-			LINK	A6,#CloseLCDFrameSize			; allocate variable space
-			MOVEM.L	CloseLCDVideoRegs,-(SP)			; Save them regs
-			LEA		CloseLCDSpBlk(A6),A1			; Get pointer to spBlock
-			MOVEA.L	A1,A0							; Set pointer to A0
-			CLR.B	spSlot(A0)						; Set slot number
-			MOVEQ	#0,D1							; set spId to 0
-			CLR.B	spExtDev(A0)					; No external devices
-			MOVE.W	#CatDisplay,spCategory(A0)		; Look for this slot's card
-			MOVE.W	#TypVideo,spCType(A0)			; Make sure it is video
-			MOVE.W	#DrSwApple,spDrvrSW(A0)			; Make sure it is from Apple
-			MOVE.B	#1,spTBMask(A0)					; mark spDrvrHw field as don’t care
-@sNextLoop
-			MOVEA.L	A1,A0							; Get pointer to spBlock
-			MOVE.B	D1,spId(A0)						; Set spID
-			_sNextTypesRsrc							; get the spsPointer
-			BNE.S	@Done
-
-			MOVE.B	spId(A0),D1						; Save spId for later use
-			MOVE.B	#sVidAttributes,spId(A0)		; read flag field in sRsrc
-			_sReadWord								; ...pointed to by spsPointer
-			BNE.S	@sNextLoop						; no flags - find next sRsrc
+		WITH	EgretPB
 
-			MOVEQ.L	#1<<fLCDScreen,D0				; got flag word
-			AND.W	spResult+2(A0),D0				; test if LCD screen
-			BEQ.S	@sNextLoop
-			
-			LEA		CloseLCDCntBlk(A6),A0			; Get pointer to ioPB
-			MOVE.W	spRefNum(A1),ioRefNum(A0)		; Get the driver refNum
-			_Close									; Close the driver
+			movem.l	d0/a0-a1,-(sp)					;     create some work registers
+			suba.l	#EgretPbSize,sp					;     make room for PB
+			move.l	sp,a0							;     point A0 to parameter block
+			move.w	#(PseudoPkt << 8) \
+					+ EnDisPDM,pbCmdType(a0)		;     Enable PowerDown Messages
+			move.b	#-1,pbParam(a0)					;     Egret powerdown msg enable
+			clr.l	pbCompletion(a0)				;	  No Completion
+			_EgretDispatch
 
-			BRA.S	@sNextLoop
-@Done
-			MOVEM.L	(SP)+,CloseLCDVideoRegs			; Restore them regs
-			UNLK	A6								; Clean up the stackframe
-			RTS										;												<4> HJR
+			adda.l	#EgretPbSize,sp					;     discard the parameter block
+			movem.l	(sp)+,d0/a0-a1					;     restore registers
+@exit												; ENDIF
+			rts										; Return to Caller
 		ENDWITH
 
 
@@ -1243,6 +1178,7 @@ CloseLCDVideoRegs	REG		D1/A0-A1
 ;		A0 - Drive Queue Element Ptr
 ;__________________________________________________________________________________		<7> SAM
 
+			PROC
 			EXPORT	FindEDisk
 FindEDisk
 						
@@ -1300,6 +1236,8 @@ EDiskName	DC.W	'.EDisk'				; EDisk driver name
 ;	Entry:
 ;		A0 - EDiskDrive Queue Element Ptr
 ;__________________________________________________________________________________		<7> SAM
+			PROC
+
 hwEDiskProt	EQU		8						; _hwPriv Write protect EDisk selector
 BytesToKill	EQU		$8000					; Number of bytes to erase from base of EDisk data area
 
@@ -1307,16 +1245,13 @@ BytesToKill	EQU		$8000					; Number of bytes to erase from base of EDisk data ar
 KillEDisk	
 			WITH	EDiskDriveInfo
 			
-			MOVE.L	DataStartPtr(A0),A2		; Get Ptr to the start of the data area
-			CMP.B	#EMMU1,MMUType			; Check for PowerPC MMU emulation
-			BNE.S	@noEMMU					; IF we have an EMMU THEN
-			MOVE.L	A2,A0					;	get ptr to start of data area
-			MOVE.L	#BytesToKill,A1			;	get number of bytes to erase
-			MOVE.L	#(0<<16)|hwEDiskProt,D0	;	_HwPriv EDisk write protect selector and "unprotect" parm
-			BRA.S	@unProtect				; ELSE
-@noEMMU		MOVE.L	CheckSumPtr(A0),A0		;	Get Ptr to the start of the checksum area, if it exists
-			TST.L	A0						;	Check if RAM Disk is using checksums
-			BNE.S	@cksumOn				;	IF checksumming is off THEN
+			MOVE.L	A0,A2
+			MOVE.B	MMU32bit,-(SP)
+			MOVEQ	#true32b,D0
+			_SwapMMUMode
+			MOVE.L	DataStartPtr(A2),D2
+			MOVE.L	CheckSumPtr(A2),A2		;	Get Ptr to the start of the checksum area, if it exists
+
 			MOVE.L	A2,A0					;	  base address of RAM disk is same as DataStartPtr
 @cksumOn									;	ENDIF
 			SUB.L	A1,A1					;	Protect flag.  Zero = Unprotect
@@ -1326,12 +1261,15 @@ KillEDisk
 			CMPI.W	#paramErr,D0			; Does not clear D0 on success, Check for failure
 			BEQ.S	@Done					; -> enable failed.  Bail out now or Bus Error!		
 			
-			MOVE.W	#BytesToKill/4-1,D2		; number of bytes to erase
 @whackLupe									; LOOP (to erase bytes in data area)
-			CLR.L	(A2)+					;	clear a longword
-			DBRA	D2,@whackLupe			; UNTIL (we've erased all bytes)
+			NOT.L	(A2)+
+			CMP.L	D2,A2
+			BLO.S	@whackLupe
+@Done
+			MOVE.B	(SP)+,D0
+			_SwapMMUMode
 
-@Done		RTS
+			RTS
 
 			ENDWITH
 
@@ -1353,6 +1291,7 @@ KillEDisk
 ; otherwise, put up an alert asking if the shutdown should continue
 ; return false if OK is hit, true if cancel is hit
 ;
+			Proc
 			Export	DoRAMDiskAlert
 			
 DoRAMDiskAlert
@@ -1487,83 +1426,23 @@ exitFalse	move.w	#false,d0					; allow shutdown to continue
 
 justExit	move.l	(sp)+,a2					; restore a2
 			rts
-			
-;________________________________
-;
-;	Docking Dispatch Trap
-;
-
-DockInitSCC		MOVEM.L	D0-D2/A0-A2,-(SP)			;														<3>
-				MOVE.W	#UnimplementedTrapNumber,D0	; does the _DockingDispatch trap exist?
-				_GetTrapAddress	,NEWTOOL
-				MOVEA.L	A0,A1
-				MOVE.W	#$AA57,D0
-				_GetTrapAddress	,NEWTOOL
-				CMPA.L	A0,A1
-				BEQ.S	@Done						; -> no, skip it
-				MOVEQ	#sccOn-256,D0				; turn SCC power on
-				BSR.S	@SCCPower
-				BSR.S	InitSCC						; reset the SCC so it doesn't cause us trouble
-				MOVEQ	#sccOff,D0					; turn SCC power off
-				BSR.S	@SCCPower
-@Done			MOVEM.L	(SP)+,D0-D2/A0-A2
-				RTS
-@SCCPower
-				TestFor	hwCbPwrMgr					; does this machine have a Power Manager?
-				BEQ.S	@NoPMGR						; -> nope, skip
-				MOVE.B	D0,-(SP)
-				MOVE.L	SP,-(SP)					;  pmRBuffer
-				MOVE.L	(SP),-(SP)					;  pmSBuffer
-				MOVE.W	#1,-(SP)					;  pmLength = 1 byte to send
-				MOVE.W	#powerCntl,-(SP)			;  pmCommand = power control
-				MOVEA.L	SP,A0						; point to the parameter block
-				_PMgrOp								; turn SCC power on or off
-				LEA		pmRBuffer+4+2(SP),SP		; toss the parameter block and buffer
-@NoPMGR			RTS
-InitBData
-				DC.B	9,$C0						; do a hard reset
-				DC.B	9,$40						; reset the channel
-				DC.B	4,$4C						; set async mode (magic?)
-				DC.B	2,$00						; zero interrupt vector for dispatcher
-				DC.B	3,$C0						; DCD not an auto-enable
-				DC.B	15,$00						; no interrupts
-				DC.B	0,$10						; reset ext/sts interrupts twice
-				DC.B	0,$10
-				DC.B	1,$00						; no interrupts
-InitBLth		EQU 	*-InitBData
-	
-InitAData		DC.B	9,$80						; reset the channel
-				DC.B	4,$4C						; set async mode (magic?)
-				DC.B	3,$C0						; DCD not an auto-enable
-				DC.B	15,$00						; no interrupts
-				DC.B	0,$10						; reset ext/sts interrupts twice
-				DC.B	0,$10
-				DC.B	1,$00						; no interrupts
-InitALth		EQU 	*-InitAData
-	
-	
-InitSCC
-				TestFor	SCCIOPExists				; see if we have a SCC IOP
-				bne.s	@hasIOP						; if so, don't try to initialize it
-				MOVEA.L	SCCWr,A0					; point to SCC base write address (chan B)
-				MOVEA.L	SCCRd,A1					; point to SCC base read address (chan B)
-				LEA 	InitBData,A2				; point to channel B init data
-				MOVEQ	#InitBLth,D1				;  and set up the length
-				BSR.S	@WriteSCC					; then init channel B
-	
-				ADDQ.W	#ACtl,A0					; adjust SCC addresses for channel A
-				ADDQ.W	#ACtl,A1
-													; A2 points to channel A's init data
-				MOVEQ	#InitALth,D1				;  init data length
-@WriteSCC		MOVE.B	(A1),D2 					; read to make sure SCC is sync'ed up
-				BRA.S	@2							; delay for timing, too
-@1				MOVE.L	(SP),(SP)					; delay long for reset
-				MOVE.L	(SP),(SP)
-				MOVE.B	(A2)+,(A0)
-@2				DBRA	D1,@1
-	
-@hasIOP			RTS
  				
-		endwith	
-		ENDP
+
+DoRAMDiskAlertCaller	PatchProc	_ShutDown,(IIci)
+			IMPORT		DoRAMDiskAlert
+
+			cmp.w	#1,4(sp)
+			beq.s	@is1
+@loop
+			jmpOld
+@is1
+			jsr		DoRAMDiskAlert
+			beq.s	@loop
+			move.l	(sp)+,a0
+			addq.w	#2,sp
+			jmp		(a0)
+
+
+
+
 		END
diff --git a/Toolbox/SoundMgr/SoundMgr.make.idump b/Toolbox/SoundMgr/SoundMgr.make.idump
new file mode 100644
--- /dev/null
+++ b/Toolbox/SoundMgr/SoundMgr.make.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Toolbox/SoundMgr/SoundMgrPatch.a b/Toolbox/SoundMgr/SoundMgrPatch.a
new file mode 100644
--- /dev/null
+++ b/Toolbox/SoundMgr/SoundMgrPatch.a
@@ -0,0 +1,5592 @@
+; for linked patches
+
+	CASE		OBJ
+
+	LOAD		'StandardEqu.d'
+	INCLUDE		'Devices.a'
+	INCLUDE		'EgretEqu.a'
+	INCLUDE		'GestaltEqu.a'
+	INCLUDE		'HardwarePrivateEqu.a'
+	INCLUDE		'InternalOnlyEqu.a'
+	INCLUDE		'IOPrimitiveEqu.a'
+	INCLUDE		'LinkedPatchMacros.a'
+	INCLUDE		'SysEqu.a'
+	INCLUDE		'SysPrivateEqu.a'
+	INCLUDE		'UniversalEqu.a'
+	INCLUDE		'TrapsPrivate.a'
+
+
+	MACHINE		MC68030
+
+
+	MakePatch	SYSBEEP,_SysBeep,(Plus,SE,II,Portable,IIci,notAUX)
+
+
+OldPBSoundOpen		ROMBind		(IIci,$E5A0A)
+OldPBSoundPrime		ROMBind		(IIci,$E5A12)
+OldPBSoundControl	ROMBind		(IIci,$E5A1C)
+OldPBSoundStatus	ROMBind		(IIci,$E5B5A)
+OldPBSoundClose		ROMBind		(IIci,$E5A26)
+
+
+batmanSnd			equ			$b0
+elsieSound			equ			$e0
+
+
+;16:043fe
+SetSosumi	InstallProc		(IIci)
+			cmp.b	#boxMacIIsi,BoxFlag
+			bne.s	@return
+
+			subq	#2,sp
+			move.l	sp,a0
+			move.l	#$0002007C,d0
+			_ReadXPram
+			tst.w	(sp)
+			bne.s	@cleanup
+			move.w	#9,(sp) ; sosumi
+			move.l	sp,a0
+			move.l	#$0002007C,d0
+			_WriteXPram
+@cleanup
+			addq	#2,sp
+@return
+			rts
+
+
+;03:00f0e
+InitSoundMgrA	InstallProc		(Plus,SE)
+			IMPORT	Snd_Func1, InitSndDispatch, InitMACEDispatch, InitSoundMgrCommon
+			jsr		Snd_Func1
+			jsr		InitSndDispatch
+			jsr		InitMACEDispatch
+			jmp		InitSoundMgrCommon
+
+
+;28:000f2
+InitSoundMgrB	InstallProc		(II,Portable,IIci,notAUX,notEricksonSoundMgr)
+			IMPORT	Snd_Func1, InitSndDispatch, InitMACEDispatch, InstallSoundIntHandler, InitSoundMgrCommon
+			jsr		Snd_Func1
+			jsr		InitSndDispatch
+			jsr		InitMACEDispatch
+			jsr		InstallSoundIntHandler
+			jmp		InitSoundMgrCommon
+
+
+;16:04428
+InitSoundMgrC	InstallProc		(IIci,notAUX,hasEricksonSoundMgr)
+			IMPORT	Snd_Func1, InstallSoundIntHandler, InitSoundMgrCommon
+			move.l	SMGlobals,a1
+			move.l	6(a1),a0
+			_DisposeHandle
+			move.l	10(a1),a0
+			_DisposePtr
+			move.l	26(a1),a0
+			_RecoverHandle
+			_DisposeHandle
+			move.l	42(a1),a2
+			move.l	a1,a0
+			_DisposePtr
+
+			jsr		Snd_Func1
+			move.l	SMGlobals,a1
+			move.l	a2,42(a1)
+
+			jsr		InstallSoundIntHandler
+			jmp		InitSoundMgrCommon
+
+
+;31:29048
+InitSoundMgrCommon	Proc	Export
+			IMPORT	InstallNewGlobals, LoadSoundInputDriver
+			clr.w	-(sp)
+			move.w	#8,-(sp)
+			peaResident	SndManagerDispatch
+			move.l	#$00040000,d0
+			_SoundDispatch
+			move.w	(sp)+,d0
+
+			clr.w	-(sp)
+			move.w	#20,-(sp)
+			peaResident	SoundInDispatch
+			move.l	#$00040000,d0
+			_SoundDispatch
+			move.w	(sp)+,d0
+
+			move.l	#32,d0
+			_NewPtr	,sys,clear
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	a0,38(a1)
+
+			leaResident	soundAttrGestalt,a0
+			move.l	#gestaltSoundAttr,d0
+			_NewGestalt
+			beq.s	@noreplace
+
+			leaResident	soundAttrGestalt,a0
+			move.l	#gestaltSoundAttr,d0
+			_ReplaceGestalt
+@noreplace
+
+			jsr		InstallNewGlobals
+			jsr		LoadSoundInputDriver
+			rts
+
+
+;31:290a4
+LoadSoundInputDriver	Proc	Export
+fBase			equ		-322
+fCntlBlock		equ		-322
+fSndBlock		equ		-270
+fRefNum			equ		-14
+fDriverHdl		equ		-12
+fUTblEntry		equ		-8
+fUTblEntry2		equ		-4
+
+			link	a6,#-322
+
+			move.l	#gestaltSoundAttr,d0
+			_Gestalt
+			move.l	a0,d0
+			btst	#gestaltBuiltInSoundInput,d0
+			beq		@return
+
+			subq	#4,sp
+			move.l	#'DRVR',-(sp)
+			pea		@AppleSoundInput
+			_GetNamedResource
+			move.l	(sp)+,d0
+			beq		@return
+
+			move.l	d0,fDriverHdl(a6)
+			move.l	d0,-(sp)
+			_DetachResource
+			move.l	fDriverHdl(a6),a0
+			_HLock
+
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	38(a1),a1
+			move.w	#1,$1E(a1)
+
+			cmp.b	#boxQuadra900,BoxFlag
+			beq.s	@q9x
+			cmp.b	#boxQuadra950,BoxFlag
+			bne.s	@notq9x
+@q9x		move.w	#3,$1E(a1)
+@notq9x
+
+			move.l	UTableBase,a0
+			adda.l	#48*4,a0
+			move.l	#~48,d0
+
+@lup		tst.l	(a0)+
+			dbeq	d0,@lup
+			sub.l	#4,a0
+			move.l	a0,fUTblEntry(a6)
+			move.w	d0,fRefNum(a6)
+
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	38(a1),a1
+			move.w	d0,(a1)
+			move.l	fUTblEntry(a6),fUTblEntry2(a6)
+
+			move.l	fDriverHdl(a6),a0
+			move.l	(a0),a0
+			dc.w	$A43D							; _DrvrInstall,LOCK - make a DCE
+
+			move.l	fUTblEntry(a6),a0				; lock the DCE
+			move.l	(a0),a0
+			_HLock
+
+			move.l	fUTblEntry(a6),a1				; a0=DRVR ptr, a1=DCE ptr
+			move.l	(a1),a1
+			move.l	(a1),a1
+			move.l	-12(a6),a0
+			move.l	(a0),a0
+
+			move.l	a0,dCtlDriver(a1)
+			move.w	drvrFlags(a0),dCtlFlags(a1)
+			move.w	drvrDelay(a0),dCtlDelay(a1)
+			move.w	drvrEMask(a0),dCtlEMask(a1)
+			move.w	drvrMenu(a0),dCtlMenu(a1)
+			bset	#DOpened,dCtlFlags+1(a1)
+
+			add		drvrOpen(a0),a0
+			jsr		(a0)
+
+			lea		fCntlBlock(a6),a0
+			move.w	fRefNum(a6),CntrlParam.ioCRefNum(a0)
+			move.w	#2,CntrlParam.csCode(a0)
+			move.l	#'name',CntrlParam.csParam(a0)
+			lea		fSndBlock(a6),a2
+			move.l	a2,CntrlParam.csParam+4(a0)
+			_Status	,immed
+			bne.s	@return
+
+			subq	#2,sp
+			move.w	fRefNum(a6),-(sp)
+			pea		fSndBlock(a6)
+			_SPBSignInDevice
+			move.w	(sp)+,d0
+
+@return		unlk	a6
+			rts
+
+@AppleSoundInput
+			string	pascal
+			dc.b	'.AppleSoundInput'
+			align	2
+
+;16:0445c
+_R2490		InstallProc		(IIci,notAUX)
+			move.l	#gestaltMachineType,d0
+			_Gestalt
+			move.l	a0,d2
+			sub.b	#gestaltMacIIci,d2
+			and.w	#$FF,d2
+
+			movea.l	UnivInfoPtr,a1						; a1 = ptr to productinfo record
+			move.l	$30(a1),d0							; get offset to sound vector tbl
+			beq.s	@noRomTable
+			bsr		copyPrimitiveTbl
+			bsr		overridePrimitiveTbl
+			bra.s	@tableDone
+
+@noRomTable
+			move.l	#gestaltSoundAttr,d0
+			_Gestalt
+			move.l	a0,d0
+			btst	#gestaltBuiltInSoundInput,d0
+			beq.s	@partialTableDone
+
+; we have sound input hardware, meaning DFAC... so force insertion of crappy table
+			leaResident	TableOfTables,a1
+			add.l	(a1,d2*4),a1
+			moveq	#0,d0
+			bsr		copyPrimitiveTbl
+			jsrTBL	sndDFACInit
+
+@tableDone
+			moveq.l	#1,d0								; default all cpu's with AGC on
+			jsrTBL	sndAGCcontrol
+
+@partialTableDone
+			bsr.s	installVBL
+			bsr.s	overrideSinDRVR
+			rts
+
+
+installVBL
+			Import	ReGenSoundInt
+
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			cmp.b	#$B0,46(a1)
+			bne.s	@return
+
+			TestFor	VIA2Exists
+			beq.s	@return
+
+			TestFor	JawsExists
+			bne.s	@return
+
+			move.l	ROMBase,a0
+			cmp.w	#$67C,8(a0)
+			bne.s	@return
+			cmp.w	#$15F1,18(a0)
+			bne.s	@return
+
+			moveq	#14,d0
+			_NewPtr	,sys,clear
+			leaResident	ReGenSoundInt,a1
+			move.l	a1,vblAddr(a0)
+			move.w	#vType,vblType(a0)
+			move.w	#30,vblCount(a0)
+			clr.w	vblPhase(a0)
+			_VInstall
+
+@return		rts
+
+
+overrideSinDRVR
+			Import	NewPBSoundDrvr
+
+			move.l	#gestaltMachineType,d0
+			_Gestalt
+			move.l	a0,d0
+			cmp.b	#gestaltPowerBook140,d0
+			beq.s	@pb14x
+			cmp.b	#gestaltPowerBook145,d0
+			bne.s	@return
+@pb14x
+
+			leaResident	NewPBSoundDrvr,a0
+			move.l	SoundDCE,a1
+			move.l	a0,dCtlDriver(a1)
+
+@return		rts
+
+
+;	Convert ROM sound primitive offset table into a RAM pointer table.
+
+copyPrimitiveTbl
+			With	SoundIOHeader
+			SndTblLength: equ -2
+
+			adda.l	d0,a1								; a1 = ptr to ROM tbl
+			moveq.l	#0,d0								; clear d0
+			move.w	SndTblLength(a1),d0					; d0 = number of entries in table
+			asl.l	#2,d0								; convert long entries to byte count
+			addq.l	#SoundIOHeaderSize,d0				; size of global header records
+			_NewPtr	,sys,clear							; alloc storage
+
+			adda.l	#SoundIOHeaderSize,a0				; inc past global header
+			move.l	a0,([Expandmem],\
+					ExpandMemRec.emSndPrimitives)		; set the expandmem pointer
+
+			move.b	#sndAGCOff,UserAGC(a0)				; init AGC off as default
+
+;	Convert the offset values in the original table to long addresses in the RAM-based
+;	table.  a0 = ptr to new RAM-based tbl, a1 = ptr to old ROM table
+
+			move.w	SndTblLength(a1),d0					; get number of entries in table
+			subq.w	#1,d0								; adjust for dbra
+			move.l	a1,d1								; d1 = address of ROM/RAM table
+@Loop
+			move.l	(a1)+,(a0)							; get routine offset
+			add.l	d1,(a0)+							; add ROM/RAM table address to convert to 32 bit address
+			dbra	d0,@Loop
+
+			rts
+
+			EndWith
+
+
+overridePrimitiveTbl
+			leaResident	TableOfTables,a1				; a1 = ptr to table of tables
+			cmp.w	-2(a1),d2							; d2 = 'mach' minus 11 (IIci)
+			bhs.s	@Return								; punt if no table for machine
+			move.l	(a1,d2*4),d0
+			beq.s	@Return								; again, punt if no table
+			add.l	d0,a1								; a1 = ptr to this table
+
+			move.l	([Expandmem],\
+					ExpandMemRec.emSndPrimitives),a0	; get the expandmem pointer
+
+;	Convert the offset values in the original table to long addresses in the RAM-based
+;	table.  a0 = ptr to new RAM-based tbl, a1 = ptr to old LINKED PATCH table
+
+			move.w	SndTblLength(a1),d0					; get number of entries in table
+			subq.w	#1,d0								; adjust for dbra
+			move.l	a1,d1								; d1 = address of ROM/RAM table
+@Loop
+			move.l	(a1)+,d2							; get routine offset
+			beq.s	@0									; do we offer one?
+			add.l	d1,d2								; add ROM/RAM table address to convert to 32 bit address
+			move.l	d2,(a0)
+@0			add.w	#4,a0								; postincrement (even if zero)
+			dbra	d0,@Loop
+
+@Return
+			rts
+
+
+;_________________________________________________________________________________________
+;	Sound primitives vector table
+
+
+;16:045ac
+			Proc
+
+			Export	TableOfTables
+			dc.w	(TableOfTablesEnd-TableOfTables)/4
+TableOfTables
+			dc.l	0									; 11
+			dc.l	0									; 12
+			dc.l	0									; 13
+			dc.l	0									; 14
+			dc.l	0									; 15
+			dc.l	0									; 16 
+			dc.l	0									; 17
+			dc.l	SndCntlMacIIsi-TableOfTables		; 18
+			dc.l	SndCntlLC-TableOfTables				; 19
+			dc.l	SndCntlQuadra900-TableOfTables		; 20
+			dc.l	SndCntlPB170-TableOfTables			; 21
+			dc.l	SndCntlQuadra700-TableOfTables		; 22
+			dc.l	SndCntlClassicII-TableOfTables		; 23
+			dc.l	0									; 24
+			dc.l	SndCntlPB140-TableOfTables			; 25
+			dc.l	SndCntlQuadra950-TableOfTables		; 26
+			dc.l	SndCntlLCIII-TableOfTables			; 27
+			dc.l	SndCntlUnk28-TableOfTables			; 28
+			dc.l	0									; 29
+			dc.l	0									; 30
+			dc.l	0									; 31
+			dc.l	0									; 32
+			dc.l	0									; 33
+			dc.l	0									; 34
+			dc.l	0									; 35
+			dc.l	0									; 36
+			dc.l	SndCntlLCII-TableOfTables			; 37
+			dc.l	0									; 38
+			dc.l	0									; 39
+			dc.l	0									; 40
+			dc.l	0									; 41
+			dc.l	0									; 42
+			dc.l	0									; 43
+			dc.l	0									; 44
+			dc.l	0									; 45
+			dc.l	0									; 46
+			dc.l	0									; 47
+			dc.l	0									; 48
+			dc.l	0									; 49
+			dc.l	0									; 50
+			dc.l	0									; 51
+			dc.l	0									; 52
+			dc.l	0									; 53
+			dc.l	SndCntlPB145-TableOfTables			; 54
+TableOfTablesEnd
+
+
+			dc.w	(SndCntlMacIIsiEnd-SndCntlMacIIsi)/4
+SndCntlMacIIsi
+			dc.l	EricksonDFACInit-SndCntlMacIIsi
+			dc.l	EgretDFACSend-SndCntlMacIIsi
+			dc.l	ASCSetVol-SndCntlMacIIsi
+			dc.l	EnableSoundInts-SndCntlMacIIsi
+			dc.l	DisableSoundInts-SndCntlMacIIsi
+			dc.l	ClearSoundInt-SndCntlMacIIsi
+			dc.l	InputSelect-SndCntlMacIIsi
+			dc.l	QueryInput-SndCntlMacIIsi
+			dc.l	ByPassControl-SndCntlMacIIsi
+			dc.l	PlayThruVol-SndCntlMacIIsi
+			dc.l	AGCControl-SndCntlMacIIsi
+SndCntlMacIIsiEnd
+
+
+			dc.w	(SndCntlLCEnd-SndCntlLC)/4
+SndCntlLC
+SndCntlLCII
+			dc.l	ElsieDFACInit-SndCntlLC
+			dc.l	EgretDFACSend-SndCntlLC
+			dc.l	ASCSetVol-SndCntlLC
+			dc.l	EnableSoundInts-SndCntlLC
+			dc.l	DisableSoundInts-SndCntlLC
+			dc.l	ClearSoundInt-SndCntlLC
+			dc.l	ElsieInputSelect-SndCntlLC
+			dc.l	QueryInput-SndCntlLC
+			dc.l	ByPassControl-SndCntlLC
+			dc.l	PlayThruVol-SndCntlLC
+			dc.l	AGCControl-SndCntlLC
+SndCntlLCEnd
+
+
+			dc.w	(SndCntlClassicIIEnd-SndCntlClassicII)/4
+SndCntlClassicII
+			dc.l	ElsieDFACInit-SndCntlClassicII
+			dc.l	EgretDFACSend-SndCntlClassicII
+			dc.l	ASCSetVol-SndCntlClassicII
+			dc.l	EnableSoundInts-SndCntlClassicII
+			dc.l	DisableSoundInts-SndCntlClassicII
+			dc.l	ClearSoundInt-SndCntlClassicII
+			dc.l	ElsieInputSelect-SndCntlClassicII
+			dc.l	QueryInput-SndCntlClassicII
+			dc.l	ByPassControl-SndCntlClassicII
+			dc.l	PlayThruVol-SndCntlClassicII
+			dc.l	AGCControl-SndCntlClassicII
+SndCntlClassicIIEnd
+
+
+			dc.w	(SndCntlQuadra700End-SndCntlQuadra700)/4
+SndCntlQuadra700
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	InputSelect-SndCntlQuadra700
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+SndCntlQuadra700End
+
+
+			dc.w	(SndCntlQuadra900End-SndCntlQuadra900)/4
+SndCntlQuadra900
+SndCntlQuadra950
+			dc.l	0
+			dc.l	EgretDFACSend-SndCntlQuadra900
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	EclipseInputSelect-SndCntlQuadra900
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+SndCntlQuadra900End
+
+
+			dc.w	(SndCntlPB170End-SndCntlPB170)/4
+SndCntlPB170
+SndCntlPB140
+SndCntlPB145
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	TIMInputSelect-SndCntlPB170
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+SndCntlPB170End
+
+
+			dc.w	(SndCntlLCIIIEnd-SndCntlLCIII)/4
+SndCntlLCIII
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+SndCntlLCIIIEnd
+
+
+			dc.w	(SndCntlUnk28End-SndCntlUnk28)/4
+SndCntlUnk28
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+			dc.l	0
+SndCntlUnk28End
+
+
+EricksonDFACInit
+			moveq	#sndEricksonDFAC,d0
+			bra.s	EgretDFACInit
+ElsieDFACInit
+			moveq	#sndElsieDFAC-256,d0
+EgretDFACInit
+			jsrTBL	sndDFACSend
+			rts
+
+
+;——————————————————————————————————————————————————————————————————————————————
+;	EgretDFACSend  -  send a byte to DFAC using Egret
+;
+;	Use this routine during runtime after traps are enabled.
+;
+;	Input:	d0.b = byte to send DFAC (in DFAC order)
+;	Output:	none
+;
+
+EgretDFACSend
+@saveregs	reg		d1-d3/a0-a1
+
+			WITH	EgretPB, SoundIOHeader, ExpandMemRec
+
+			movem.l	@saveregs,-(sp)					; work register
+
+;	Reverse the order of the bits because Egret shifts them out in reverse order
+;	to what DFAC is expecting MSB first.
+
+			move.l	d0,d3							; save DFAC value in DFAC order
+			moveq	#0,d1							; destination
+			moveq	#8-1,d2							; loop count for 8 bits
+@Loop
+			asr.b	#1,d0							; shift lsb into extend bit
+			roxl.b	#1,d1							; shift extend bit towards msb
+			dbra	d2,@Loop
+
+			move.w	sr,-(sp)
+			ori.w	#$700,sr
+
+;	Build a Parameter block for the default DFAC message
+
+			suba.w	#EgretPbSize,sp					; make room for PB
+			movea.l	sp,a0							; point a0 to pbBuffer
+			move.b	#pseudoPkt,pbCmdType(a0)
+			move.b	#WrDFAC,pbCmd(a0)
+			move.w	#1,pbByteCnt(a0)				; set byte count
+			clr.l	pbBufPtr(a0)					; clear unused fields
+			clr.w	pbFlags(a0)
+			clr.w	pbResult(a0)
+			clr.l	pbCompletion(a0)
+			move.b	d1,pbParam(a0)					; set byte to send DFAC
+
+			_EgretDispatch
+			adda.w	#EgretPbSize,sp					; discard the parameter block and data buffer
+			bne.s	@Done							; some error - do not update image of DFAC
+
+;	Update the RAM image of the DFAC register
+
+			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
+			move.b	d3,DFAClast(a0)					; update DFAC register image
+
+@Done
+			move.w	(sp)+,sr
+			movem.l	(sp)+,@saveregs
+			rts										; Return to Caller
+
+			ENDWITH
+
+
+;——————————————————————————————————————————————————————————————————————————————
+;	ElsieInputSelect  -  Select the sound input source on Elsie
+;
+;	If we are turning off the source (equivalent to disabling recording), then
+;	re-establish the playback mode by selecting the Aux source with AGC on and
+;	playthrough volume set to the maximum.
+;
+;	Input:	do.b	input selection
+;						0  =  none (off)
+;						1  =  microphone
+;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
+;	Output:	none
+;
+
+ElsieInputSelect
+
+			WITH	ExpandMemRec, SoundIOHeader
+
+			cmpi.b	#sndMicrophone,d0				; are we selecting the mike?
+			beq.s	InputSelect						; yes - continue
+
+;	In Elsie sound, the playthrough with the auxiliary source is how playback is
+;	done.  If not selecting mike, then enable playback
+
+@saveregs	reg		d1/a0
+			movem.l	@saveregs,-(sp)
+			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
+			move.w	sr,-(sp)
+			ori.w	#$700,sr
+			moveq	#(sndByPassMask\				;												<t6>
+					AND sndPlayThruMask\
+					AND	sndAGCMask),d1				; mask off bypass, volume, and AGC bits
+			and.b	DFAClast(a0),d1					; get DFAC register image
+			moveq	#sndElsieDFAC-256,d0			; DFAC playback mode for Elsie sound			<t6>
+			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem			<t6>
+			move.w	(sp)+,sr
+			movem.l	(sp)+,@saveregs
+			rts
+
+			ENDWITH
+
+
+;——————————————————————————————————————————————————————————————————————————————
+;	InputSelect  -  Select the sound input source
+;
+;	If we are selecting "none" for the input source, then turn off the volume
+;	and AGC to prevent any noise leakage.  Save the old volume and restore it
+;	later when a new source is selected.
+;
+;	AGCInputSelect
+;	On Tim and Spike, sound input does not work unless AGC is enabled.  We
+;	kludge something to always set AGC.
+;
+;	Input:	do.b	input selection
+;						0  =  none (off)
+;						1  =  microphone
+;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
+;	Output:	d0.b	last source
+;
+
+InputSelect
+@saveregs	reg		d1-d2/a0-a1						; added d2 to save registers 					<H23>
+
+			WITH	SoundIOHeader
+
+			movem.l	@saveregs,-(sp)
+			move.l	([Expandmem],\
+					ExpandMemRec.emSndPrimitives),a0; a0 = ptr to vector table
+			move.w	sr,-(sp)						;												<t9>
+			ori.w	#HiIntMask,sr					; disable ints									<t9>
+
+			moveq.l	#3,d2							; get selection bits to return					<t9>
+			and.b	DFAClast(a0),d2					; save for return								<t9>
+
+			moveq	#(sndSelectMask\				;												<t6>
+					AND sndPlayThruMask\
+					AND	sndAGCMask),d1				; mask off selection, volume, and AGC bits
+			and.b	DFAClast(a0),d1					;  in the DFAC register image					<t6>
+			or.b	d0,d1							;  and OR them into DFAC image					<t6>
+
+;	Check for volume and AGC to update in DFAC now that a sound source has been selected.
+;	If we are disabling input, then zero the volume and disable AGC to prevent noise
+;	leakage, otherwise set the currently selected volume and AGC levels.
+
+			tst.b	d0								; are we turning off input?
+			beq.s	@send							; yes - set no input and zero volume
+			or.b	UserVolume(a0),d1				; set volume level
+			cmpi.b	#sndMicrophone,d0				; are we selecting the mike input?				<H13>
+			bne.s	@send							; no - do not enable AGC						<H13>
+			or.b	UserAGC(a0),d1					; set AGC level									<t6>
+
+@send
+			move.b	d1,d0							; d0 = new DFAC value
+			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem			<t6>
+
+			move.w	(sp)+,sr						; enable ints									<t9>
+			move.b	d2,d0							; return source bits we replaced				<t9>
+			movem.l	(sp)+,@saveregs
+			rts
+
+			ENDWITH
+
+
+;——————————————————————————————————————————————————————————————————————————————						<t6>
+			dc.b	0,1,2,0,0,0
+
+
+;——————————————————————————————————————————————————————————————————————————————						<t6>
+;	PlayThruVol  -  Set the playthrough volume
+;
+;	If a sound source has not been selected, then save the volume in the globals
+;	to be updated to DFAC later when the source is selected.  Also set playback
+;	volume for consistancy.
+;
+;	Input:	d0.b = volume level (0-7)
+;	Output:	none
+;
+
+PlayThruVol
+@saveregs	reg		d1/a0
+
+			WITH	SoundIOHeader
+
+			movem.l	@saveregs,-(sp)
+			movea.l	([Expandmem],\
+					ExpandMemRec.emSndPrimitives),a0; a0 = ptr to vector table
+			move.w	sr,-(sp)						;												<t9>
+			ori.w	#HiIntMask,sr					; disable ints									<t9>
+
+			asl.b	#5,d0							; shift volume into s5-s7 position
+			move.b	d0,UserVolume(a0)				; save user set volume level
+			moveq	#(sndSelectMask-256),d1			; mask off selection bits
+			and.b	DFAClast(a0),d1					;  in the DFAC register image
+			beq.s	@Done							; no sound source - we are done
+
+			moveq	#sndPlayThruMask,d1				; mask off volume bits
+			and.b	DFAClast(a0),d1					;  in the DFAC register image
+			or.b	d1,d0							; or-in value to send DFAC to set volume
+			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem
+@Done
+			move.w	(sp)+,sr						; enable ints									<t9>
+			movem.l	(sp)+,@saveregs
+			rts
+
+			ENDWITH
+
+
+;——————————————————————————————————————————————————————————————————————————————						<t6>
+;	AGCControl  -  enable or disable AGC
+;
+;	Enable or disable AGC.  If no sound source has been selected, then
+;	save the AGC value and set it whenever the sound source is selected.
+;
+;	Input:	d0.b  =   0 is disable, nonzero is enable
+;	Output:	none
+;
+
+AGCControl
+@saveregs	reg		d1/a0
+
+			WITH	SoundIOHeader
+
+			movem.l	@saveregs,-(sp)
+			movea.l	([Expandmem],\
+					ExpandMemRec.emSndPrimitives),a0; a0 = ptr to vector table
+			moveq.l	#sndAGCOff,d1					; assume AGC off (min gain)						<t11>
+			tst.b	d0								; enable or disable AGC
+			beq.s	@continue						; was disable AGC
+			moveq.l	#sndAGCOn,d1					; enable AGC
+@continue
+			move.w	sr,-(sp)						;												<t9>
+			ori.w	#HiIntMask,sr					; disable ints									<t9>
+			move.b	d1,UserAGC(a0)					; save value
+
+			moveq	#(sndSelectMask-256),d0			; mask off selection bits
+			and.b	DFAClast(a0),d0					;  in the DFAC register image
+			beq.s	@Done							; no sound source - we are done
+
+			moveq	#sndAGCMask-256,d0				; mask off the AGC control bits
+			and.b	DFAClast(a0),d0					;  in the DFAC register image
+			or.b	d1,d0							; or-in AGC value to send to DFAC
+			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem
+@Done
+			move.w	(sp)+,sr						; enable ints									<t9>
+			movem.l	(sp)+,@saveregs
+			rts
+
+			ENDWITH
+
+
+;——————————————————————————————————————————————————————————————————————————————
+;	ASCSetVol  -  Set the playback volume on normal ASC/Batman hardware
+;
+;	Set the playback volume using the volume control register on Batman.
+;
+;	Input:	d0.b = volume level (0-7)
+;	Output:	none
+;
+
+ASCSetVol	move.l	a0,-(sp)
+			movea.l	ASCBase,a0						; get base address of asc/batman
+			lsl.b	#5,d0							; shift volume up to pwm position
+			move.b	d0,ascVolControl(a0)			; save it in ASC volume register
+			movea.l	(sp)+,a0
+			rts
+
+
+;——————————————————————————————————————————————————————————————————————————————						<t6>
+;	ByPassControl  -  enable or disable aux bypass
+;
+;	Input:	d0.b  =   0 is disable, nonzero is enable
+;	Output:	none
+;
+
+ByPassControl
+@saveregs	reg		d1/a0
+
+			WITH	SoundIOHeader, ExpandMemRec
+
+			movem.l	@saveregs,-(sp)
+			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
+			moveq.l	#sndByPassOff,d1				; assume bypass off
+			tst.b	d0								; enable or disable bypass
+			beq.s	@continue						; was bypass off
+			moveq.l	#sndByPassOn,d1					; set bypass on
+@continue	move.w	sr,-(sp)						;												<t9>
+			ori.w	#HiIntMask,sr					; disable ints									<t9>
+			moveq	#sndByPassMask-256,d0			; mask off bypass control bit
+			and.b	DFAClast(a0),d0					;  in the DFAC register image
+			or.b	d1,d0							; d0 = value to send DFAC
+			jsrTBL	sndDFACSend						; call DFACSend routine thru expandmem
+			move.w	(sp)+,sr						; enable ints									<t9>
+			movem.l	(sp)+,@saveregs
+			rts
+
+			ENDWITH
+
+
+;——————————————————————————————————————————————————————————————————————————————
+;	QueryInput  -  return current input source selected
+;
+;	Input:	none
+;	Output:	d0.b	input source
+;						0  =  none (off)
+;						1  =  microphone
+;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
+
+			WITH	SoundIOHeader, ExpandMemRec
+
+QueryInput	move.l	a0,-(sp)
+			movea.l	([Expandmem],emSndPrimitives),a0; a0 = ptr to vector table
+			moveq	#~(sndSelectMask-256),d0		; mask off selection bits						<t6>
+			and.b	DFAClast(a0),d0					;  in the DFAC register image					<t6>
+			movea.l	(sp)+,a0
+			rts
+
+			ENDWITH
+
+
+;——————————————————————————————————————————————————————————————————————————————						<t6>
+			dc.b	0,1,2,0
+
+
+;——————————————————————————————————————————————————————————————————————————————
+EnableSoundInts
+			move.l	a0,-(sp)
+			move.l	VIA2,a0
+			move.b	#$90,$1C13(a0)
+			move.l	(sp)+,a0
+			rts
+
+
+DisableSoundInts
+			move.l	a0,-(sp)
+			move.l	VIA2,a0
+			move.b	#$10,$1C13(a0)
+			move.l	(sp)+,a0
+			rts
+
+
+ClearSoundInt
+			move.l	a0,-(sp)
+			move.l	VIA2,a0
+			move.b	#$90,$1A03(a0)
+			move.l	(sp)+,a0
+			rts
+
+
+;——————————————————————————————————————————————————————————————————————————————				<r8> thru next <r8> djw
+;	TIMInputSelect  -  Select the sound input source on Tim
+;
+;	On Tim, the input selection routine in ROM always turns AGC on.  Patch
+;	it out to not force AGC on.
+;
+;	Input:	do.b	input selection
+;						0  =  none (off)
+;						1  =  microphone
+;						2  =  auxillary (modem sound on Tim)
+;	Output:	d0.b	last source
+;
+
+			WITH	SoundIOHeader, ExpandMemRec
+
+AutoSlpDisable	equ		$f8						; Counting semaphor to disable sleep
+
+TIMInputSelect
+@workingReg	reg		d2/a0-a1
+			move.w	sr,-(sp)					; save the old sr
+			movem.l	@workingReg,-(sp)			; save working registers
+
+			move.l	PmgrBase,a1					; point a1 to globals
+			movea.l	([Expandmem],emSndPrimitives),a0	; a0 = ptr to vector table
+			ori.w	#HiIntMask,sr				; disable ints
+
+			moveq.l	#3,d2						; get selection bits
+			and.b	DFAClast(a0),d2				;
+			beq.s	@currentlyOff				; is a source active ??
+
+@currentlySelected								; sound source currently selected
+			tst.b	d0							; check new state,
+			bne.s	@setsource					; if just new source, set the source
+			subq.b	#1,AutoSlpDisable(a1)		; ... if turning off source, dec the nosleep semaphore
+			bra.s	@setsource
+
+@currentlyOff									; sound source currently off
+			tst.b	d0							; check new state,
+			beq.s	@setsource					; if new source still off, set the source
+			addq.b	#1,AutoSlpDisable(a1)		; ... if turning on source, inc the nosleep semaphore
+;			bra.s	@setsource
+
+@setsource
+			movem.l	(sp)+,@workingReg			; restore working registers
+			bsr		InputSelect					; change the source					<r10> djw
+			move.w	(sp)+,sr					; enable ints
+			rts
+
+			ENDWITH
+
+
+;_______________________________________________________________________							<Z16> thru next <Z16>									<Z18> thru next <Z18>
+;
+;  Routine:		ReGenSoundIntVBL
+;
+;  Desc:		Since reading VIAx[vBufB] causes interrupts to cleared,
+;				this re-generates those sound interrupts.
+;
+;				This routine stolen from
+;
+;					{Regatta}Toolbox:SoundMgr:SoundMgrPatch.a
+;
+;				...Then brought back from SndPrimitives.a
+;
+;_______________________________________________________________________
+
+			Export	ReGenSoundInt
+ReGenSoundInt ; file=SoundMgrPatch.a (per SndPrimitives.a/Sony.a comment)
+			move.w	#30,vblCount(a0)				; re-arm VBL task
+
+			movea.l	ASCBase,a1						; point to Batman
+
+			move.w	sr,-(sp)						; preserve the status register
+			ori.w	#$0700,sr						; mask interrupts
+
+			tst.b	bmIntControlA(a1)				; channel A interrupt enabled?
+			beq.s	@do
+			tst.b	bmIntControlB(a1)				; channel B interrupt enabled?
+			bne.s	@dont
+
+@do			move.b	#1,bmIntControlA(a1)			; disable chnl A interrupts
+			move.b	#1,bmIntControlB(a1)			; disable chnl B interrupts
+			clr.b	bmIntControlA(a1)				; clear the interrupt mask to re-generate
+			clr.b	bmIntControlB(a1)				; clear the interrupt mask to re-generate
+
+			move.w	#1,vblCount(a0)
+
+@dont		move.w	(sp)+,sr
+			rts
+
+
+;_______________________________________________________________________							<Z16> thru next <Z16>									<Z18> thru next <Z18>
+
+			Export	NewPBSoundDrvr
+NewPBSoundDrvr
+			dc.b	(1<<dWritEnable)	| \
+					(1<<dCtlEnable)		| \
+					(1<<dStatEnable)	| \
+					(1<<dNeedLock)			; drvFlags (upper byte)
+			dc.b	0						; drvFlags (upper lower)
+			dc.w	0						; drvDelay
+			dc.w	0						; drvEMask
+			dc.w	0						; drvMenu
+			dc.w	NewPBSoundOpen-NewPBSoundDrvr
+			dc.w	NewPBSoundPrime-NewPBSoundDrvr
+			dc.w	NewPBSoundControl-NewPBSoundDrvr
+			dc.w	NewPBSoundStatus-NewPBSoundDrvr
+			dc.w	NewPBSoundClose-NewPBSoundDrvr
+
+			string	pascal
+			dc.b	'.Sound '				; drvName, including leading length byte
+			align	2						; force back to even boundaries
+
+NewPBSoundOpen
+			jmpROM	OldPBSoundOpen
+
+NewPBSoundPrime
+			jmpROM	OldPBSoundPrime
+
+NewPBSoundControl
+			cmp.w	#2,CntrlParam.csCode(a0)
+			bne.s	@old
+			move.w	CntrlParam.csParam(a0),d0
+			jsrTBL	sndPlaybackVol
+@old		jmpROM	OldPBSoundControl
+
+NewPBSoundStatus
+			jmpROM	OldPBSoundStatus
+
+NewPBSoundClose
+			jmpROM	OldPBSoundClose
+
+
+;——————————————————————————————————————————————————————————————————————————————						<t6>
+;	EclipseInputSelect  -  Select the sound input source on Eclipse
+;
+;	On Eclipse, the sound input source is selected by two bits on VIA2 port B
+;	register in addition to DFAC.  There are four sound input sources on
+;	Eclipse: Microphone (or none?), RCA jacks, Microphone, and the CD (aux).
+;	These sources are selected through the VIA2 bits and routed through DFAC.
+;
+;	If we are selecting "none" for the input source, then turn off the volume
+;	and AGC to prevent any noise leakage.  Save the old volume and restore it
+;	later when a new source is selected.
+;
+;	Input:	do.b	input selection
+;						0  =  none (off)
+;						1  =  microphone
+;						2  =  auxillary (modem sound on Tim, CD on Spike and Eclipse)
+;						3  =  RCA jacks
+;	Output:	none
+;
+
+EclipseInputSelect
+
+			move.w	sr,-(sp)						;												<t12> djw
+			ori.w	#HiIntMask,sr					;												<t12> djw
+			movem.l	d0-d1,-(sp)						;												<t12> djw
+			move.b	([via2],vBufB),d1				; read current via values						<t12> djw
+			and.b	#%10110111,d1					; clear the previous value (bits pb6,pb3)		<t12> djw
+			andi.w	#$ff,d0							; make a word index
+			or.b	EclipseSelectTable(pc,d0.w),d1	; set new input									<t12> djw
+			move.b	d1,([via2],vBufB)				; set via2 bits
+			movem.l	(sp)+,d0-d1						;												<t12> djw
+			move.w	(sp)+,sr						;												<t12> djw
+
+			tst.b	d0								; selecting no source?
+			beq		InputSelect						; yes - ok to go setup DFAC						<t14> djw
+			moveq.l	#sndMicrophone,d0				; all sound sources go through DFAC mike input
+			bra		InputSelect						;												<t14> djw
+
+EclipseSelectTable
+			dc.b	%00000000						; none (or microphone?)	pb6=0, pb3=0
+			dc.b	%01000000						; microphone			pb6=1, pb3=0
+			dc.b	%01001000						; auxilary (CD)			pb6=1, pb3=1
+			dc.b	%00001000						; RCA jacks				pb6=0, pb3=1
+
+
+;——————————————————————————————————————————————————————————————————————————————						<t6>
+;31:291c2
+
+__Comp3to1		Proc	Export
+			Import	Table_1,Table_2,Table_3,Table_4,Table_5
+
+			link	a6,#0
+			movem.l	d0-d7/a0-a5,-(sp)
+			cmpi.l	#6,$18(a6)
+			blt.w	loc_129428
+			movea.l	$14(a6),a0
+			cmpa.w	#0,a0
+			bne.s	loc_1291ea
+			clr.w	d3
+			move.w	d3,d4
+			move.w	d3,d5
+			move.w	d3,d6
+			bra.s	loc_1291f8
+loc_1291ea
+			move.w	(a0),d3
+			move.w	2(a0),d4
+			move.w	4(a0),d5
+			move.w	6(a0),d6
+loc_1291f8
+			movea.l	$20(a6),a2
+			movea.l	$1c(a6),a3
+			move.l	8(a6),d0
+			subq.l	#1,d0
+			adda.l	d0,a2
+			movea.l	$c(a6),a5
+			subq.l	#1,a5
+loc_12920e
+			move.b	(a2)+,d0
+			adda.l	a5,a2
+			addi.b	#-$80,d0
+			ext.w	d0
+			asl.w	#8,d0
+			addi.b	#-$80,d0
+			sub.w	d4,d0
+			bvc.s	loc_12922e
+			bmi.s	loc_12922a
+			move.w	#$8001,d0
+			bra.s	loc_12922e
+loc_12922a
+			move.w	#$7fff,d0
+loc_12922e
+			move.w	d3,d1
+			asr.w	#4,d1
+			add.w	d1,d1
+			lea		Table_1,a4
+			adda.w	d1,a4
+			muls.w	(a4),d0
+			swap	d0
+			or.w	d0,d0
+			bmi.s	loc_129264
+			cmpi.w	#$13,d0
+			bgt.s	loc_12924c
+			moveq	#0,d2
+			bra.s	loc_129286
+loc_12924c
+			cmpi.w	#$28,d0
+			bgt.s	loc_129256
+			moveq	#1,d2
+			bra.s	loc_129286
+loc_129256
+			cmpi.w	#$43,d0
+			bgt.s	loc_129260
+			moveq	#2,d2
+			bra.s	loc_129286
+loc_129260
+			moveq	#3,d2
+			bra.s	loc_129286
+loc_129264
+			not.w	d0
+			cmpi.w	#$13,d0
+			bgt.s	loc_129270
+			moveq	#7,d2
+			bra.s	loc_129286
+loc_129270
+			cmpi.w	#$28,d0
+			bgt.s	loc_12927a
+			moveq	#6,d2
+			bra.s	loc_129286
+loc_12927a
+			cmpi.w	#$43,d0
+			bgt.s	loc_129284
+			moveq	#5,d2
+			bra.s	loc_129286
+loc_129284
+			moveq	#4,d2
+loc_129286
+			asl.w	#3,d1
+			lea		Table_5,a4
+			add.w	d2,d1
+			add.w	d2,d1
+			adda.w	d1,a4
+			move.w	(a4),d6
+			add.w	d4,d6
+			bvc.s	loc_1292a4
+			bmi.s	loc_1292a0
+			move.w	#$8001,d6
+			bra.s	loc_1292a4
+loc_1292a0
+			move.w	#$7fff,d6
+loc_1292a4
+			move.w	d6,d0
+			move.w	d6,d4
+			asr.w	#3,d0
+			sub.w	d0,d4
+			move.w	d3,d0
+			asr.w	#5,d0
+			sub.w	d0,d3
+			lea		Table_4,a4
+			adda.w	d2,a4
+			adda.w	d2,a4
+			add.w	(a4),d3
+			bge.s	loc_1292c0
+			clr.w	d3
+loc_1292c0
+			move.b	d2,d7
+			move.b	(a2)+,d0
+			adda.l	a5,a2
+			addi.b	#-$80,d0
+			ext.w	d0
+			asl.w	#8,d0
+			addi.b	#-$80,d0
+			sub.w	d4,d0
+			bvc.s	loc_1292e2
+			bmi.s	loc_1292de
+			move.w	#$8001,d0
+			bra.s	loc_1292e2
+loc_1292de
+			move.w	#$7fff,d0
+loc_1292e2
+			move.w	d3,d1
+			asr.w	#4,d1
+			add.w	d1,d1
+			lea		Table_1,a4
+			adda.w	d1,a4
+			muls.w	(a4),d0
+			swap	d0
+			or.w	d0,d0
+			bmi.s	loc_129304
+			cmpi.w	#$23,d0
+			bgt.s	loc_129300
+			moveq	#0,d2
+			bra.s	loc_129312
+loc_129300
+			moveq	#1,d2
+			bra.s	loc_129312
+loc_129304
+			not.w	d0
+			cmpi.w	#$23,d0
+			bgt.s	loc_129310
+			moveq	#3,d2
+			bra.s	loc_129312
+loc_129310
+			moveq	#2,d2
+loc_129312
+			asl.w	#3,d1
+			lea		Table_3,a4
+			add.w	d2,d1
+			add.w	d2,d1
+			adda.w	d1,a4
+			move.w	(a4),d6
+			add.w	d4,d6
+			bvc.s	loc_129330
+			bmi.s	loc_12932c
+			move.w	#$8001,d6
+			bra.s	loc_129330
+loc_12932c
+			move.w	#$7fff,d6
+loc_129330
+			move.w	d6,d0
+			move.w	d6,d4
+			asr.w	#3,d0
+			sub.w	d0,d4
+			move.w	d3,d0
+			asr.w	#5,d0
+			sub.w	d0,d3
+			lea		Table_2,a4
+			adda.w	d2,a4
+			adda.w	d2,a4
+			add.w	(a4),d3
+			bge.s	loc_12934c
+			clr.w	d3
+loc_12934c
+			asl.b	#3,d2
+			add.b	d2,d7
+			move.b	(a2)+,d0
+			adda.l	a5,a2
+			addi.b	#-$80,d0
+			ext.w	d0
+			asl.w	#8,d0
+			addi.b	#-$80,d0
+			sub.w	d4,d0
+			bvc.s	loc_129370
+			bmi.s	loc_12936c
+			move.w	#$8001,d0
+			bra.s	loc_129370
+loc_12936c
+			move.w	#$7fff,d0
+loc_129370
+			move.w	d3,d1
+			asr.w	#4,d1
+			add.w	d1,d1
+			lea		Table_1,a4
+			adda.w	d1,a4
+			muls.w	(a4),d0
+			swap	d0
+			or.w	d0,d0
+			bmi.s	loc_1293a6
+			cmpi.w	#$13,d0
+			bgt.s	loc_12938e
+			moveq	#0,d2
+			bra.s	loc_1293c8
+loc_12938e
+			cmpi.w	#$28,d0
+			bgt.s	loc_129398
+			moveq	#1,d2
+			bra.s	loc_1293c8
+loc_129398
+			cmpi.w	#$43,d0
+			bgt.s	loc_1293a2
+			moveq	#2,d2
+			bra.s	loc_1293c8
+loc_1293a2
+			moveq	#3,d2
+			bra.s	loc_1293c8
+loc_1293a6
+			not.w	d0
+			cmpi.w	#$13,d0
+			bgt.s	loc_1293b2
+			moveq	#7,d2
+			bra.s	loc_1293c8
+loc_1293b2
+			cmpi.w	#$28,d0
+			bgt.s	loc_1293bc
+			moveq	#6,d2
+			bra.s	loc_1293c8
+loc_1293bc
+			cmpi.w	#$43,d0
+			bgt.s	loc_1293c6
+			moveq	#5,d2
+			bra.s	loc_1293c8
+loc_1293c6
+			moveq	#4,d2
+loc_1293c8
+			asl.w	#3,d1
+			lea		Table_5,a4
+			add.w	d2,d1
+			add.w	d2,d1
+			adda.w	d1,a4
+			move.w	(a4),d6
+			add.w	d4,d6
+			bvc.s	loc_1293e6
+			bmi.s	loc_1293e2
+			move.w	#$8001,d6
+			bra.s	loc_1293e6
+loc_1293e2
+			move.w	#$7fff,d6
+loc_1293e6
+			move.w	d6,d0
+			move.w	d6,d4
+			asr.w	#3,d0
+			sub.w	d0,d4
+			move.w	d3,d0
+			asr.w	#5,d0
+			sub.w	d0,d3
+			lea		Table_4,a4
+			adda.w	d2,a4
+			adda.w	d2,a4
+			add.w	(a4),d3
+			bge.s	loc_129402
+			clr.w	d3
+loc_129402
+			asl.b	#5,d2
+			add.b	d2,d7
+			move.b	d7,(a3)+
+			subq.l	#3,$18(a6)
+			bgt.w	loc_12920e
+			movea.l	$10(a6),a0
+			cmpa.w	#0,a0
+			beq.s	loc_129428
+			move.w	d3,(a0)
+			move.w	d4,2(a0)
+			move.w	d5,4(a0)
+			move.w	d6,6(a0)
+loc_129428
+			movem.l	(sp)+,d0-d7/a0-a5
+			movea.l	4(a6),a0
+			unlk	a6
+			adda.l	#$20,sp
+			jmp		(a0)
+
+
+__Exp1to3		Proc	Export
+			Import	Table_2,Table_4
+
+			link	a6,#0
+			movem.l	d0-d7/a0-a5,-(sp)
+			cmpi.l	#1,$18(a6)
+			blt.w	loc_129620
+			movea.l	$14(a6),a0
+			cmpa.w	#0,a0
+			bne.s	loc_12945c
+			clr.w	d2
+			clr.w	d3
+			bra.s	loc_129462
+loc_12945c
+			move.w	(a0),d2
+			move.w	2(a0),d3
+loc_129462
+			movea.l	$20(a6),a2
+			movea.l	$1c(a6),a3
+			move.w	#$7f0,d6
+			movea.w	#$10,a5
+			move.w	#$8080,d7
+			move.l	8(a6),d0
+			subq.l	#1,d0
+			lsl.l	#1,d0
+			adda.l	d0,a2
+			movea.l	$c(a6),a1
+			subq.l	#1,a1
+			adda.l	a1,a1
+loc_129488
+			move.b	(a2)+,d4
+			moveq	#7,d1
+			and.b	d4,d1
+			add.w	d1,d1
+			lea		Table_4,a4
+			adda.w	d1,a4
+			move.w	d2,d1
+			move.w	d2,d0
+			asr.w	#5,d0
+			sub.w	d0,d2
+			add.w	(a4),d2
+			bge.s	loc_1294a4
+			moveq	#0,d2
+loc_1294a4
+			and.w	d6,d1
+			add.w	a5,d1
+			adda.w	d1,a4
+			add.w	(a4),d3
+			bvc.s	loc_1294ba
+			bmi.s	loc_1294b6
+			move.w	#$8001,d3
+			bra.s	loc_1294ba
+loc_1294b6
+			move.w	#$7fff,d3
+loc_1294ba
+			move.w	d3,d0
+			move.w	d0,d5
+			andi.w	#$ff00,d5
+			asr.w	#3,d0
+			sub.w	d0,d3
+			lsr.w	#2,d4
+			moveq	#6,d1
+			and.b	d4,d1
+			lea		Table_2,a4
+			adda.w	d1,a4
+			move.w	d2,d1
+			move.w	d2,d0
+			asr.w	#5,d0
+			sub.w	d0,d2
+			add.w	(a4),d2
+			bge.s	loc_1294e0
+			moveq	#0,d2
+loc_1294e0
+			and.w	d6,d1
+			add.w	a5,d1
+			adda.w	d1,a4
+			add.w	(a4),d3
+			bvc.s	loc_1294f6
+			bmi.s	loc_1294f2
+			move.w	#$8001,d3
+			bra.s	loc_1294f6
+loc_1294f2
+			move.w	#$7fff,d3
+loc_1294f6
+			move.w	d3,d0
+			asr.w	#3,d0
+			sub.w	d0,d3
+			lsr.w	#5,d0
+			andi.w	#$ff,d0
+			or.w	d0,d5
+			eor.w	d7,d5
+			move.w	d5,(a3)+
+			lsr.w	#2,d4
+			moveq	#$e,d1
+			and.b	d4,d1
+			lea		Table_4,a4
+			adda.w	d1,a4
+			move.w	d2,d1
+			move.w	d2,d0
+			asr.w	#5,d0
+			sub.w	d0,d2
+			add.w	(a4),d2
+			bge.s	loc_129522
+			moveq	#0,d2
+loc_129522
+			and.w	d6,d1
+			add.w	a5,d1
+			adda.w	d1,a4
+			add.w	(a4),d3
+			bvc.s	loc_129538
+			bmi.s	loc_129534
+			move.w	#$8001,d3
+			bra.s	loc_129538
+loc_129534
+			move.w	#$7fff,d3
+loc_129538
+			move.w	d3,d0
+			move.w	d0,d5
+			andi.w	#$ff00,d5
+			asr.w	#3,d0
+			sub.w	d0,d3
+			move.b	(a2)+,d4
+			moveq	#7,d1
+			and.b	d4,d1
+			add.w	d1,d1
+			lea		Table_4,a4
+			adda.w	d1,a4
+			move.w	d2,d1
+			move.w	d2,d0
+			asr.w	#5,d0
+			sub.w	d0,d2
+			add.w	(a4),d2
+			bge.s	loc_129560
+			moveq	#0,d2
+loc_129560
+			and.w	d6,d1
+			add.w	a5,d1
+			adda.w	d1,a4
+			add.w	(a4),d3
+			bvc.s	loc_129576
+			bmi.s	loc_129572
+			move.w	#$8001,d3
+			bra.s	loc_129576
+loc_129572
+			move.w	#$7fff,d3
+loc_129576
+			move.w	d3,d0
+			asr.w	#3,d0
+			sub.w	d0,d3
+			lsr.w	#5,d0
+			andi.w	#$ff,d0
+			or.w	d0,d5
+			eor.w	d7,d5
+			move.w	d5,(a3)+
+			lsr.w	#2,d4
+			moveq	#6,d1
+			and.b	d4,d1
+			lea		Table_2,a4
+			adda.w	d1,a4
+			move.w	d2,d1
+			move.w	d2,d0
+			asr.w	#5,d0
+			sub.w	d0,d2
+			add.w	(a4),d2
+			bge.s	loc_1295a2
+			moveq	#0,d2
+loc_1295a2
+			and.w	d6,d1
+			add.w	a5,d1
+			adda.w	d1,a4
+			add.w	(a4),d3
+			bvc.s	loc_1295b8
+			bmi.s	loc_1295b4
+			move.w	#$8001,d3
+			bra.s	loc_1295b8
+loc_1295b4
+			move.w	#$7fff,d3
+loc_1295b8
+			move.w	d3,d0
+			move.w	d0,d5
+			andi.w	#$ff00,d5
+			asr.w	#3,d0
+			sub.w	d0,d3
+			lsr.w	#2,d4
+			moveq	#$e,d1
+			and.b	d4,d1
+			lea		Table_4,a4
+			adda.w	d1,a4
+			move.w	d2,d1
+			move.w	d2,d0
+			asr.w	#5,d0
+			sub.w	d0,d2
+			add.w	(a4),d2
+			bge.s	loc_1295de
+			moveq	#0,d2
+loc_1295de
+			and.w	d6,d1
+			add.w	a5,d1
+			adda.w	d1,a4
+			add.w	(a4),d3
+			bvc.s	loc_1295f4
+			bmi.s	loc_1295f0
+			move.w	#$8001,d3
+			bra.s	loc_1295f4
+loc_1295f0
+			move.w	#$7fff,d3
+loc_1295f4
+			move.w	d3,d0
+			asr.w	#3,d0
+			sub.w	d0,d3
+			lsr.w	#5,d0
+			andi.w	#$ff,d0
+			or.w	d0,d5
+			eor.w	d7,d5
+			move.w	d5,(a3)+
+			adda.l	a1,a2
+			subq.l	#1,$18(a6)
+			bne.w	loc_129488
+			movea.l	$10(a6),a0
+			cmpa.w	#0,a0
+			beq.s	loc_129620
+			move.w	d2,(a0)
+			move.w	d3,2(a0)
+loc_129620
+			movem.l	(sp)+,d0-d7/a0-a5
+			movea.l	4(a6),a0
+			unlk	a6
+			adda.l	#$20,sp
+			jmp		(a0)
+
+
+__Exp1to6		Proc	Export
+			Import	Table_2,Table_4
+
+			link	a6,#-4
+			movem.l	d0-d7/a0-a5,-(sp)
+			cmpi.l	#1,$18(a6)
+			blt.w	loc_129870
+			movea.l	$14(a6),a0
+			cmpa.w	#0,a0
+			bne.s	loc_12965c
+			suba.l	a4,a4
+			move.w	a4,d5
+			move.w	a4,d3
+			movea.w	a4,a5
+			move.w	a4,d4
+			move.w	a4,d2
+			bra.s	loc_129672
+loc_12965c
+			movea.w	(a0),a4
+			move.w	2(a0),d5
+			move.w	4(a0),d3
+			movea.w	6(a0),a5
+			move.w	8(a0),d4
+			move.w	$a(a0),d2
+loc_129672
+			movea.l	$20(a6),a0
+			movea.l	$1c(a6),a2
+			move.w	#$7f0,d6
+			move.w	#$10,d7
+			move.l	8(a6),d0
+			subq.l	#1,d0
+			adda.l	d0,a0
+			movea.l	$c(a6),a3
+			subq.l	#1,a3
+loc_129690
+			move.b	(a0)+,d1
+			moveq	#7,d0
+			and.w	d1,d0
+			add.w	d0,d0
+			move.w	d0,-2(a6)
+			lsr.w	#2,d1
+			moveq	#6,d0
+			and.w	d1,d0
+			move.w	d0,-4(a6)
+			lsr.w	#2,d1
+			andi.w	#$e,d1
+			lea		Table_4,a1
+			adda.w	d1,a1
+			move.w	d3,d1
+			move.w	d3,d0
+			asr.w	#5,d0
+			sub.w	d0,d3
+			add.w	(a1),d3
+			bge.s	loc_1296c0
+			clr.w	d3
+loc_1296c0
+			and.w	d6,d1
+			add.w	d7,d1
+			adda.w	d1,a1
+			move.w	(a1),d0
+			eor.w	d0,d2
+			bmi.s	loc_1296ea
+			add.w	a5,d0
+			bvc.s	loc_1296dc
+			bmi.s	loc_1296d8
+			move.w	#$8001,d0
+			bra.s	loc_1296dc
+loc_1296d8
+			move.w	#$7fff,d0
+loc_1296dc
+			move.w	d0,d2
+			addi.w	#$1fa,d4
+			bvc.s	loc_1296e8
+			move.w	#$7fff,d4
+loc_1296e8
+			bra.s	loc_129706
+loc_1296ea
+			add.w	a5,d0
+			bvc.s	loc_1296fa
+			bmi.s	loc_1296f6
+			move.w	#$8001,d0
+			bra.s	loc_1296fa
+loc_1296f6
+			move.w	#$7fff,d0
+loc_1296fa
+			move.w	d0,d2
+			subi.w	#$13a,d4
+			bvc.s	loc_129706
+			move.w	#$8001,d4
+loc_129706
+			muls.w	d4,d0
+			add.l	d0,d0
+			swap	d0
+			movea.w	d0,a5
+			asr.w	#1,d2
+			move.w	d5,d1
+			sub.w	d2,d1
+			asr.w	#2,d1
+			move.w	d5,d0
+			add.w	a4,d0
+			sub.w	d1,d0
+			move.w	a4,d5
+			movea.w	d2,a4
+			add.w	a4,d1
+			add.w	d5,d1
+			andi.w	#$ff00,d0
+			lsr.w	#8,d1
+			or.w	d0,d1
+			eori.w	#$8080,d1
+			move.w	d1,(a2)+
+			move.w	-4(a6),d1
+			lea		Table_2,a1
+			adda.w	d1,a1
+			move.w	d3,d1
+			move.w	d3,d0
+			asr.w	#5,d0
+			sub.w	d0,d3
+			add.w	(a1),d3
+			bge.s	loc_12974a
+			clr.w	d3
+loc_12974a
+			and.w	d6,d1
+			add.w	d7,d1
+			adda.w	d1,a1
+			move.w	(a1),d0
+			eor.w	d0,d2
+			bmi.s	loc_129774
+			add.w	a5,d0
+			bvc.s	loc_129766
+			bmi.s	loc_129762
+			move.w	#$8001,d0
+			bra.s	loc_129766
+loc_129762
+			move.w	#$7fff,d0
+loc_129766
+			move.w	d0,d2
+			addi.w	#$1fa,d4
+			bvc.s	loc_129772
+			move.w	#$7fff,d4
+loc_129772
+			bra.s	loc_129790
+loc_129774
+			add.w	a5,d0
+			bvc.s	loc_129784
+			bmi.s	loc_129780
+			move.w	#$8001,d0
+			bra.s	loc_129784
+loc_129780
+			move.w	#$7fff,d0
+loc_129784
+			move.w	d0,d2
+			subi.w	#$13a,d4
+			bvc.s	loc_129790
+			move.w	#$8001,d4
+loc_129790
+			muls.w	d4,d0
+			add.l	d0,d0
+			swap	d0
+			movea.w	d0,a5
+			asr.w	#1,d2
+			move.w	d5,d1
+			sub.w	d2,d1
+			asr.w	#2,d1
+			move.w	d5,d0
+			add.w	a4,d0
+			sub.w	d1,d0
+			move.w	a4,d5
+			movea.w	d2,a4
+			add.w	a4,d1
+			add.w	d5,d1
+			andi.w	#$ff00,d0
+			lsr.w	#8,d1
+			or.w	d0,d1
+			eori.w	#$8080,d1
+			move.w	d1,(a2)+
+			move.w	-2(a6),d1
+			lea		Table_4,a1
+			adda.w	d1,a1
+			move.w	d3,d1
+			move.w	d3,d0
+			asr.w	#5,d0
+			sub.w	d0,d3
+			add.w	(a1),d3
+			bge.s	loc_1297d4
+			clr.w	d3
+loc_1297d4
+			and.w	d6,d1
+			add.w	d7,d1
+			adda.w	d1,a1
+			move.w	(a1),d0
+			eor.w	d0,d2
+			bmi.s	loc_1297fe
+			add.w	a5,d0
+			bvc.s	loc_1297f0
+			bmi.s	loc_1297ec
+			move.w	#$8001,d0
+			bra.s	loc_1297f0
+loc_1297ec
+			move.w	#$7fff,d0
+loc_1297f0
+			move.w	d0,d2
+			addi.w	#$1fa,d4
+			bvc.s	loc_1297fc
+			move.w	#$7fff,d4
+loc_1297fc
+			bra.s	loc_12981a
+loc_1297fe
+			add.w	a5,d0
+			bvc.s	loc_12980e
+			bmi.s	loc_12980a
+			move.w	#$8001,d0
+			bra.s	loc_12980e
+loc_12980a
+			move.w	#$7fff,d0
+loc_12980e
+			move.w	d0,d2
+			subi.w	#$13a,d4
+			bvc.s	loc_12981a
+			move.w	#$8001,d4
+loc_12981a
+			muls.w	d4,d0
+			add.l	d0,d0
+			swap	d0
+			movea.w	d0,a5
+			asr.w	#1,d2
+			move.w	d5,d1
+			sub.w	d2,d1
+			asr.w	#2,d1
+			move.w	d5,d0
+			add.w	a4,d0
+			sub.w	d1,d0
+			move.w	a4,d5
+			movea.w	d2,a4
+			add.w	a4,d1
+			add.w	d5,d1
+			andi.w	#$ff00,d0
+			lsr.w	#8,d1
+			or.w	d0,d1
+			eori.w	#$8080,d1
+			move.w	d1,(a2)+
+			adda.l	a3,a0
+			subq.l	#1,$18(a6)
+			bne.w	loc_129690
+			movea.l	$10(a6),a0
+			cmpa.w	#0,a0
+			beq.s	loc_129870
+			move.w	a4,(a0)
+			move.w	d5,2(a0)
+			move.w	d3,4(a0)
+			move.w	a5,6(a0)
+			move.w	d4,8(a0)
+			move.w	d2,$a(a0)
+loc_129870
+			movem.l	(sp)+,d0-d7/a0-a5
+			movea.l	4(a6),a0
+			unlk	a6
+			adda.l	#$20,sp
+			jmp		(a0)
+
+
+__Comp6to1		Proc	Export
+			Import	Table_1,Table_2,Table_4
+
+			link	a6,#-4
+			movem.l	d0-d7/a0-a5,-(sp)
+			cmpi.l	#6,$18(a6)
+			blt.w	loc_129c5c
+			movea.l	$14(a6),a0
+			cmpa.w	#0,a0
+			bne.s	loc_1298b8
+			move.w	#$fc02,d6
+			movea.w	#$fc02,a5
+			move.w	#$e00f,d7
+			movea.w	#$e00f,a4
+			clr.w	d3
+			clr.w	d4
+			clr.w	d5
+			suba.l	a2,a2
+			bra.s	loc_1298d6
+loc_1298b8
+			move.w	(a0),d6
+			movea.w	2(a0),a5
+			move.w	4(a0),d7
+			movea.w	6(a0),a4
+			move.w	8(a0),d3
+			move.w	$a(a0),d4
+			move.w	$c(a0),d5
+			movea.w	$e(a0),a2
+loc_1298d6
+			movea.l	$20(a6),a0
+			movea.l	$1c(a6),a1
+			move.l	8(a6),d0
+			subq.l	#1,d0
+			adda.l	d0,a0
+			move.l	$c(a6),-4(a6)
+			subq.l	#1,-4(a6)
+loc_1298f0
+			moveq	#$ffffff80,d1
+			add.b	(a0)+,d1
+			adda.l	-4(a6),a0
+			ext.w	d1
+			asl.w	#4,d1
+			add.w	d6,d1
+			sub.w	a5,d1
+			asr.w	#1,d1
+			move.w	a5,d0
+			add.w	d6,d0
+			add.w	d6,d0
+			add.w	d1,d0
+			movea.w	d6,a5
+			move.w	d1,d6
+			movea.w	d7,a4
+			asr.w	#1,d7
+			add.w	d0,d7
+			moveq	#$ffffff80,d0
+			add.b	(a0)+,d0
+			adda.l	-4(a6),a0
+			ext.w	d0
+			asl.w	#4,d0
+			add.w	d6,d0
+			sub.w	a5,d0
+			asr.w	#1,d0
+			move.w	a5,d1
+			add.w	d6,d1
+			add.w	d6,d1
+			add.w	d0,d1
+			movea.w	d6,a5
+			move.w	d0,d6
+			move.w	a4,d0
+			add.w	d7,d0
+			add.w	d7,d0
+			movea.w	d7,a4
+			asr.w	#1,d7
+			add.w	d1,d7
+			add.w	d7,d0
+			sub.w	d4,d0
+			bvc.s	loc_129950
+			bmi.s	loc_12994c
+			move.w	#$8001,d0
+			bra.s	loc_129950
+loc_12994c
+			move.w	#$7fff,d0
+loc_129950
+			move.w	d3,d1
+			asr.w	#4,d1
+			add.w	d1,d1
+			lea		Table_1,a3
+			adda.w	d1,a3
+			muls.w	(a3),d0
+			swap	d0
+			or.w	d0,d0
+			bmi.s	loc_129986
+			cmpi.w	#$15,d0
+			bgt.s	loc_12996e
+			moveq	#0,d2
+			bra.s	loc_1299a8
+loc_12996e
+			cmpi.w	#$2b,d0
+			bgt.s	loc_129978
+			moveq	#1,d2
+			bra.s	loc_1299a8
+loc_129978
+			cmpi.w	#$48,d0
+			bgt.s	loc_129982
+			moveq	#2,d2
+			bra.s	loc_1299a8
+loc_129982
+			moveq	#3,d2
+			bra.s	loc_1299a8
+loc_129986
+			not.w	d0
+			cmpi.w	#$15,d0
+			bgt.s	loc_129992
+			moveq	#7,d2
+			bra.s	loc_1299a8
+loc_129992
+			cmpi.w	#$2b,d0
+			bgt.s	loc_12999c
+			moveq	#6,d2
+			bra.s	loc_1299a8
+loc_12999c
+			cmpi.w	#$48,d0
+			bgt.s	loc_1299a6
+			moveq	#5,d2
+			bra.s	loc_1299a8
+loc_1299a6
+			moveq	#4,d2
+loc_1299a8
+			move.w	d3,d0
+			asr.w	#5,d0
+			sub.w	d0,d3
+			lea		Table_4,a3
+			adda.w	d2,a3
+			adda.w	d2,a3
+			add.w	(a3),d3
+			bge.s	loc_1299bc
+			clr.w	d3
+loc_1299bc
+			asl.w	#3,d1
+			lea		$10(a3),a3
+			adda.w	d1,a3
+			move.w	(a3),d0
+			move.w	a2,d1
+			eor.w	d0,d1
+			bmi.s	loc_1299ea
+			add.w	d4,d0
+			bvc.s	loc_1299dc
+			bmi.s	loc_1299d8
+			move.w	#$8001,d0
+			bra.s	loc_1299dc
+loc_1299d8
+			move.w	#$7fff,d0
+loc_1299dc
+			movea.w	d0,a2
+			addi.w	#$1fa,d5
+			bvc.s	loc_1299e8
+			move.w	#$7fff,d5
+loc_1299e8
+			bra.s	loc_129a06
+loc_1299ea
+			add.w	d4,d0
+			bvc.s	loc_1299fa
+			bmi.s	loc_1299f6
+			move.w	#$8001,d0
+			bra.s	loc_1299fa
+loc_1299f6
+			move.w	#$7fff,d0
+loc_1299fa
+			movea.w	d0,a2
+			subi.w	#$13a,d5
+			bvc.s	loc_129a06
+			move.w	#$8001,d5
+loc_129a06
+			muls.w	d5,d0
+			add.l	d0,d0
+			swap	d0
+			move.w	d0,d4
+			asl.b	#5,d2
+			move.b	d2,(a1)
+			moveq	#$ffffff80,d1
+			add.b	(a0)+,d1
+			adda.l	-4(a6),a0
+			ext.w	d1
+			asl.w	#4,d1
+			add.w	d6,d1
+			sub.w	a5,d1
+			asr.w	#1,d1
+			move.w	a5,d0
+			add.w	d6,d0
+			add.w	d6,d0
+			add.w	d1,d0
+			movea.w	d6,a5
+			move.w	d1,d6
+			movea.w	d7,a4
+			asr.w	#1,d7
+			add.w	d0,d7
+			moveq	#$ffffff80,d0
+			add.b	(a0)+,d0
+			adda.l	-4(a6),a0
+			ext.w	d0
+			asl.w	#4,d0
+			add.w	d6,d0
+			sub.w	a5,d0
+			asr.w	#1,d0
+			move.w	a5,d1
+			add.w	d6,d1
+			add.w	d6,d1
+			add.w	d0,d1
+			movea.w	d6,a5
+			move.w	d0,d6
+			move.w	a4,d0
+			add.w	d7,d0
+			add.w	d7,d0
+			movea.w	d7,a4
+			asr.w	#1,d7
+			add.w	d1,d7
+			add.w	d7,d0
+			sub.w	d4,d0
+			bvc.s	loc_129a72
+			bmi.s	loc_129a6e
+			move.w	#$8001,d0
+			bra.s	loc_129a72
+loc_129a6e
+			move.w	#$7fff,d0
+loc_129a72
+			move.w	d3,d1
+			asr.w	#4,d1
+			add.w	d1,d1
+			lea		Table_1,a3
+			adda.w	d1,a3
+			muls.w	(a3),d0
+			swap	d0
+			or.w	d0,d0
+			bmi.s	loc_129a94
+			cmpi.w	#$25,d0
+			bgt.s	loc_129a90
+			moveq	#0,d2
+			bra.s	loc_129aa2
+loc_129a90
+			moveq	#1,d2
+			bra.s	loc_129aa2
+loc_129a94
+			not.w	d0
+			cmpi.w	#$25,d0
+			bgt.s	loc_129aa0
+			moveq	#3,d2
+			bra.s	loc_129aa2
+loc_129aa0
+			moveq	#2,d2
+loc_129aa2
+			move.w	d3,d0
+			asr.w	#5,d0
+			sub.w	d0,d3
+			lea		Table_2,a3
+			adda.w	d2,a3
+			adda.w	d2,a3
+			add.w	(a3),d3
+			bge.s	loc_129ab6
+			clr.w	d3
+loc_129ab6
+			asl.w	#3,d1
+			lea		$10(a3),a3
+			adda.w	d1,a3
+			move.w	(a3),d0
+			move.w	a2,d1
+			eor.w	d0,d1
+			bmi.s	loc_129ae4
+			add.w	d4,d0
+			bvc.s	loc_129ad6
+			bmi.s	loc_129ad2
+			move.w	#$8001,d0
+			bra.s	loc_129ad6
+loc_129ad2
+			move.w	#$7fff,d0
+loc_129ad6
+			movea.w	d0,a2
+			addi.w	#$1fa,d5
+			bvc.s	loc_129ae2
+			move.w	#$7fff,d5
+loc_129ae2
+			bra.s	loc_129b00
+loc_129ae4
+			add.w	d4,d0
+			bvc.s	loc_129af4
+			bmi.s	loc_129af0
+			move.w	#$8001,d0
+			bra.s	loc_129af4
+loc_129af0
+			move.w	#$7fff,d0
+loc_129af4
+			movea.w	d0,a2
+			subi.w	#$13a,d5
+			bvc.s	loc_129b00
+			move.w	#$8001,d5
+loc_129b00
+			muls.w	d5,d0
+			add.l	d0,d0
+			swap	d0
+			move.w	d0,d4
+			asl.b	#3,d2
+			add.b	d2,(a1)
+			moveq	#$ffffff80,d1
+			add.b	(a0)+,d1
+			adda.l	-4(a6),a0
+			ext.w	d1
+			asl.w	#4,d1
+			add.w	d6,d1
+			sub.w	a5,d1
+			asr.w	#1,d1
+			move.w	a5,d0
+			add.w	d6,d0
+			add.w	d6,d0
+			add.w	d1,d0
+			movea.w	d6,a5
+			move.w	d1,d6
+			movea.w	d7,a4
+			asr.w	#1,d7
+			add.w	d0,d7
+			moveq	#$ffffff80,d0
+			add.b	(a0)+,d0
+			adda.l	-4(a6),a0
+			ext.w	d0
+			asl.w	#4,d0
+			add.w	d6,d0
+			sub.w	a5,d0
+			asr.w	#1,d0
+			move.w	a5,d1
+			add.w	d6,d1
+			add.w	d6,d1
+			add.w	d0,d1
+			movea.w	d6,a5
+			move.w	d0,d6
+			move.w	a4,d0
+			add.w	d7,d0
+			add.w	d7,d0
+			movea.w	d7,a4
+			asr.w	#1,d7
+			add.w	d1,d7
+			add.w	d7,d0
+			sub.w	d4,d0
+			bvc.s	loc_129b6c
+			bmi.s	loc_129b68
+			move.w	#$8001,d0
+			bra.s	loc_129b6c
+loc_129b68
+			move.w	#$7fff,d0
+loc_129b6c
+			move.w	d3,d1
+			asr.w	#4,d1
+			add.w	d1,d1
+			lea		Table_1,a3
+			adda.w	d1,a3
+			muls.w	(a3),d0
+			swap	d0
+			or.w	d0,d0
+			bmi.s	loc_129ba2
+			cmpi.w	#$15,d0
+			bgt.s	loc_129b8a
+			moveq	#0,d2
+			bra.s	loc_129bc4
+loc_129b8a
+			cmpi.w	#$2b,d0
+			bgt.s	loc_129b94
+			moveq	#1,d2
+			bra.s	loc_129bc4
+loc_129b94
+			cmpi.w	#$48,d0
+			bgt.s	loc_129b9e
+			moveq	#2,d2
+			bra.s	loc_129bc4
+loc_129b9e
+			moveq	#3,d2
+			bra.s	loc_129bc4
+loc_129ba2
+			not.w	d0
+			cmpi.w	#$15,d0
+			bgt.s	loc_129bae
+			moveq	#7,d2
+			bra.s	loc_129bc4
+loc_129bae
+			cmpi.w	#$2b,d0
+			bgt.s	loc_129bb8
+			moveq	#6,d2
+			bra.s	loc_129bc4
+loc_129bb8
+			cmpi.w	#$48,d0
+			bgt.s	loc_129bc2
+			moveq	#5,d2
+			bra.s	loc_129bc4
+loc_129bc2
+			moveq	#4,d2
+loc_129bc4
+			move.w	d3,d0
+			asr.w	#5,d0
+			sub.w	d0,d3
+			lea		Table_4,a3
+			adda.w	d2,a3
+			adda.w	d2,a3
+			add.w	(a3),d3
+			bge.s	loc_129bd8
+			clr.w	d3
+loc_129bd8
+			asl.w	#3,d1
+			lea		$10(a3),a3
+			adda.w	d1,a3
+			move.w	(a3),d0
+			move.w	a2,d1
+			eor.w	d0,d1
+			bmi.s	loc_129c06
+			add.w	d4,d0
+			bvc.s	loc_129bf8
+			bmi.s	loc_129bf4
+			move.w	#$8001,d0
+			bra.s	loc_129bf8
+loc_129bf4
+			move.w	#$7fff,d0
+loc_129bf8
+			movea.w	d0,a2
+			addi.w	#$1fa,d5
+			bvc.s	loc_129c04
+			move.w	#$7fff,d5
+loc_129c04
+			bra.s	loc_129c22
+loc_129c06
+			add.w	d4,d0
+			bvc.s	loc_129c16
+			bmi.s	loc_129c12
+			move.w	#$8001,d0
+			bra.s	loc_129c16
+loc_129c12
+			move.w	#$7fff,d0
+loc_129c16
+			movea.w	d0,a2
+			subi.w	#$13a,d5
+			bvc.s	loc_129c22
+			move.w	#$8001,d5
+loc_129c22
+			muls.w	d5,d0
+			add.l	d0,d0
+			swap	d0
+			move.w	d0,d4
+			add.b	d2,(a1)+
+			subq.l	#6,$18(a6)
+			bgt.w	loc_1298f0
+			movea.l	$10(a6),a0
+			cmpa.w	#0,a0
+			beq.s	loc_129c5c
+			move.w	d6,(a0)
+			move.w	a5,2(a0)
+			move.w	d7,4(a0)
+			move.w	a4,6(a0)
+			move.w	d3,8(a0)
+			move.w	d4,$a(a0)
+			move.w	d5,$c(a0)
+			move.w	a2,$e(a0)
+loc_129c5c
+			movem.l	(sp)+,d0-d7/a0-a5
+			movea.l	4(a6),a0
+			unlk	a6
+			adda.l	#$20,sp
+			jmp		(a0)
+
+
+;——————————————————————————————————————————————————————————————————————————————						<t6>
+;31:29c6c
+
+InitSndDispatch	Proc	Export
+			Import	DispFuncDisp, UnimplFunction, _R24DE, DispAddTool, _R24EA, _R24F0, SoundDispatcher
+			move.l	#52,d0
+			_NewPtr	,sys
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	a0,42(a1)
+
+			leaResident	DispFuncDisp,a1
+			move.l		a1,(a0)+
+
+			move.l		#7,d1
+			leaResident	UnimplFunction,a1
+@Loop8		move.l		a1,(a0)+
+			dbra		d1,@Loop8
+
+			leaResident	_R24DE,a1
+			move.l		a1,(a0)+
+			leaResident	DispAddTool,a1
+			move.l		a1,(a0)+
+			leaResident	_R24EA,a1
+			move.l		a1,(a0)+
+			leaResident	_R24F0,a1
+			move.l		a1,(a0)+
+
+			leaResident	SoundDispatcher,a0
+			move.l		#$00,d0				; SoundDispatch
+			_SetTrapAddress	,newTool
+
+			rts
+
+
+;31:29cb0
+SoundDispatcher	Proc	Export
+			move.l	ExpandMem,a0
+			move.l	ExpandMemRec.soundMgrGlobals(a0),a0
+			move.l	42(a0),a0
+			move.l	(a0,d0),a0
+			swap	d0
+			jmp		(a0)
+
+			Export	DispFuncDisp
+DispFuncDisp
+			cmp.w	#16,d0
+			bhs.s	UnimplFunction
+			move.l	ExpandMem,a0
+			move.l	ExpandMemRec.soundMgrGlobals(a0),a0
+			move.l	42(a0),a0
+			move.l	36(a0,d0),a0
+			jmp		(a0)
+
+			Export	UnimplFunction
+UnimplFunction
+			tst.w	d0
+			bne.s	@return
+			clr.l	4(sp)
+@return		rts
+
+
+_R24DE	Proc	Export
+			Import	SoundDispatcher
+
+			move.w	4(sp),d0
+			beq.s	@version
+			cmp.w	#36,d0
+			bhs.s	@bad
+
+			move.l	(sp),a0
+			add.l	#6,sp
+			move.l	a0,-(sp)
+			and.l	#$FFFF,d0
+			jmp		SoundDispatcher
+
+@bad		clr.l	6(sp)
+			bra.s	@return
+
+@version	move.l	#$01002001,6(sp)	; 1.0d1
+
+@return		move.l	(sp),a0
+		OPT NONE
+			addq.l	#6,sp
+		OPT ALL
+			jmp		(a0)
+			rts
+
+
+;31:29d18
+DispAddTool	Proc	Export
+			move.w	8(sp),d0
+			cmp.w	#36,d0
+			bge.s	@bad
+
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	42(a1),a1
+
+			move.l	4(sp),a0
+			move.l	a0,(a1,d0)
+			clr.w	10(sp)
+			bra.s	@return
+
+@bad		move.w	#paramErr,10(sp)
+
+@return		move.l	(sp),a0
+			adda.l	#10,sp
+			jmp		(a0)
+
+
+;31:29d4a
+_R24EA	Proc	Export
+			Import	UnimplFunction
+
+			move.w	4(sp),d0
+			cmp.w	#36,d0
+			bhs.s	@bad
+
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	42(a1),a1
+
+			leaResident	UnimplFunction,a0
+			move.l	a0,(a1,d0)
+			clr.w	6(sp)
+			bra.s	@return
+
+@bad		move.w	#paramErr,6(sp)
+
+@return		move.l	(sp),a0
+		OPT NONE
+			addq.l	#6,sp
+		OPT ALL
+			jmp		(a0)
+
+
+;31:29d7a
+_R24F0	Proc	Export
+			Import	UnimplFunction
+
+			move.w	4(sp),d0
+			cmp.w	#36,d0
+			bhs.s	@bad
+
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	42(a1),a1
+
+			move.l	(a1,d0),d0
+			lea		UnimplFunction,a0
+			cmp.l	a0,d0
+			bne.s	@ne
+
+@bad		moveq	#0,d0
+
+@ne			move.l	d0,6(sp)
+			move.l	(sp),a0
+			add.l	#6,sp
+			jmp		(a0)
+
+
+;31:29da8
+InitMACEDispatch	Proc	Export
+			Import	MACEDispatch
+
+			clr.w		-(sp)
+			move.w		#16,-(sp)
+			peaResident	MACEDispatch
+			move.l		#$00040000,d0
+			_SoundDispatch
+			move.w		(sp)+,d0
+			rts
+
+
+;31:29dbe
+MACEDispatch	Proc	Export
+			jmp		@jumptable(d0)
+@jumptable
+			Import	Version
+			jmp		Version
+			Import	__Comp3to1
+			jmp		__Comp3to1
+			Import	__Exp1to3
+			jmp		__Exp1to3
+			Import	__Comp6to1
+			jmp		__Comp6to1
+			Import	__Exp1to6
+			jmp		__Exp1to6
+
+
+;28:00106
+InstallSoundIntHandler	Proc	Export
+			Import	SoundIntHandler, SetupSoundInterruptVectors
+
+			leaResident	SoundIntHandler,a0
+			move.l	a0,$D80
+			jsr		SetupSoundInterruptVectors
+
+			move.l	a0,-(sp)
+			move.l	ExpandMem,a0
+			move.l	ExpandMemRec.jSetupSoundInterrupt(a0),a0
+			jsr		(a0)
+			move.l	(sp)+,a0
+			rts
+
+
+;28:00122
+SoundIntHandler	Proc	Export
+			move.l	a0,-(sp)
+			move.l	ExpandMem,a0
+			move.l	ExpandMemRec.jAcknowledgeSoundInterrupt(a0),a0
+			jsr		(a0)
+			move.l	(sp)+,a0
+
+			move.l	ExpandMem,a0
+			move.l	ExpandMemRec.soundMgrGlobals(a0),a0
+			move.l	ASCBase,a1
+
+			clr.l	d0				; we use the high bit as a flag
+			move.b	ascFifoInt(a1),d0
+
+			move.l	30(a0),d1
+			beq.s	@doneChecking
+
+; try 0
+			cmp.b	#0,46(a0)
+			bne.s	@not0
+			btst	#0,d0
+			beq.s	@doneChecking
+			bset	#31,d0
+			bra.s	@defer
+
+@not0 ; try E0
+			cmp.b	#elsieSound,46(a0)
+			bne.s	@notElsie
+			bset	#0,d0
+			beq.s	@doneChecking
+			move.l	a0,-(sp)
+			move.l	ExpandMem,a0
+			move.l	ExpandMemRec.jSuspendSoundInterrupt(a0),a0
+			jsr		(a0)
+			move.l	(sp)+,a0
+			bra.s	@defer
+
+@notElsie ; try B0
+			cmp.b	#batmanSnd,46(a0)
+			bne.s	@notBatman
+			tst.b	bmIntControlA(a1)
+			bne.s	@doneChecking
+			tst.b	47(a0)
+			beq.s	@otherpath
+			btst	#0,d0
+			beq.s	@doneChecking
+			bra.s	@common
+@otherpath	btst	#0,d0
+			bne.s	@doneChecking
+@common		move.b	#1,bmIntControlA(a1)
+			bset	#31,d0
+			bra.s	@defer
+
+@notBatman
+			_Debugger
+
+@defer		movem.l	d0/a0/a1,-(sp)
+			move.l	d1,a0
+			_DeferUserFn
+			movem.l	(sp)+,d0/a0/a1
+@doneChecking ; now do something similar for bmIntControlB...
+laber_barrier
+			move.l	34(a0),d1
+			beq.s	@doneChecking
+
+; try 0
+			cmp.b	#0,46(a0)
+			bne.s	@not0
+			btst	#2,d0
+			beq.s	@doneChecking
+			bset	#31,d0
+			bra.s	@defer
+
+@not0 ; try E0
+			cmp.b	#elsieSound,46(a0)
+			bne.s	@notElsie
+			btst	#0,d0
+			beq.s	@doneChecking
+			move.l	a0,-(sp)
+			move.l	ExpandMem,a0
+			move.l	ExpandMemRec.jSuspendSoundInterrupt(a0),a0
+			jsr		(a0)
+			move.l	(sp)+,a0
+			bra.s	@defer
+
+@notElsie ; try B0
+			cmp.b	#batmanSnd,46(a0)
+			bne.s	@notBatman
+			tst.b	bmIntControlB(a1)
+			bne.s	@doneChecking
+			btst	#2,d0
+			beq.s	@doneChecking
+			move.b	#1,bmIntControlB(a1)
+			bset	#31,d0
+			bra.s	@defer
+
+@notBatman
+			_Debugger
+
+@defer		movem.l	d0/a0/a1,-(sp)
+			move.l	d1,a0
+			_DeferUserFn
+			movem.l	(sp)+,d0/a0/a1
+
+@doneChecking
+; defer myself
+			btst	#31,d0
+			beq.s	@noInt
+			movem.l	d0/a0/a1,-(sp)
+			lea		SoundIntHandler,a0
+			_DeferUserFn
+			movem.l	(sp)+,d0/a0/a1
+@noInt		rts
+
+
+;28:00232
+EnableASCInts	ROMBind		(II,$1),(Portable,$232),(IIci,$a00e)
+DisableASCInts	ROMBind		(II,$1),(Portable,$232),(IIci,$a02e)
+ClearASCInt		ROMBind		(II,$1),(Portable,$232),(IIci,$a04c)
+
+SetupSoundInterruptVectors	Proc	Export
+			leaROM	EnableASCInts,a1
+			leaROM	DisableASCInts,a2
+			move.l	a1,a3
+			leaROM	ClearASCInt,a4
+
+			Import	ElsieEnableASCInts
+			move.l	ASCBase,a0				; nop out EnableASCInts on Elsie
+			move.b	ascVersion(a0),d0
+			and.b	#$F0,d0
+			cmp.b	#elsieSound,d0
+			bne.s	@notElsie
+			leaResident	ElsieEnableASCInts,a1
+@notElsie
+
+			Import	IIEnableASCInts, IIDisableASCInts, IIClearASCInt
+			move.l	a1,d0					; replace all on Mac II
+			btst	#0,d0
+			beq.s	@probablyBad
+			leaResident	IIEnableASCInts,a1
+			leaResident	IIDisableASCInts,a2
+			move.l	a1,a3
+			leaResident	IIClearASCInt,a4
+@probablyBad
+
+			move.l	ExpandMem,a0
+			lea		ExpandMemRec.jSetupSoundInterrupt(a0),a0
+			move.l	a1,(a0)+				; jSetupSoundInterrupt
+			move.l	a2,(a0)+				; jSuspendSoundInterrupt
+			move.l	a3,(a0)+				; jResumeSoundInterrupt
+			move.l	a4,(a0)+				; jAcknowledgeSoundInterrupt
+			rts
+
+
+;28:00284
+ElsieEnableASCInts	Proc	Export
+			rts
+
+
+;28:00286
+IIEnableASCInts	Proc	Export
+			move.l	VIA2,a0
+			bclr	#4,vPCR(a0)
+			move.b	#(1<<ifCB1)|(1<<ifIRQ),vIER(a0)
+			rts
+
+
+;28:00298
+IIDisableASCInts	Proc	Export
+			move.l	VIA2,a0
+			move.b	#(1<<ifCB1),vIER(a0)
+			rts
+
+
+;28:002a4
+IIClearASCInt	Proc	Export
+			move.l	VIA2,a0
+			move.b	#(1<<ifCB1)|(1<<ifIRQ),vIFR(a0)
+			rts
+
+
+;31:29dd6
+InstallNewGlobals	Proc	Export
+			; sound input
+			move.w	#MapFalse,ROMMapInsert
+			sub.l	#4,sp
+			move.l	#'proc',-(sp)
+			move.w	#-16497,-(sp)
+			_GetResource
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	38(a1),a1
+			move.l	(sp)+,14(a1)
+
+			; play from disk
+			move.w	#MapFalse,ROMMapInsert
+			sub.l	#4,sp
+			move.l	#'proc',-(sp)
+			move.w	#-16498,-(sp)
+			_GetResource
+			move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	38(a1),a1
+			move.l	(sp)+,20(a1)
+
+			rts
+
+
+;31:29e20
+SoundInDispatch	Proc	Export
+			tst.b	d0
+			bne.s	@notVersion
+			move.l	(sp)+,a0
+			move.l	#$01018000,(sp)
+			jmp		(a0)
+
+@notVersion	move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	38(a1),a1
+			move.l	14(a1),a0
+			lea		18(a1),a1
+			lsr.b	#1,d0
+			_ProcHelper
+
+
+;31:29e4a
+SndManagerDispatch	Proc	Export
+			clr.w	d1
+			move.b	d0,d1
+			jmp		@table(d1)
+@table
+			jmp		@easy
+			jmp		@easy
+			jmp		@easy
+			Import	__SNDSOUNDMANAGERVERSION
+			jmp		__SNDSOUNDMANAGERVERSION
+			Import	__SNDCHANNELSTATUS
+			jmp		__SNDCHANNELSTATUS
+			Import	__SNDMANAGERSTATUS
+			jmp		__SNDMANAGERSTATUS
+			Import	__SNDGETSYSBEEPSTATE
+			jmp		__SNDGETSYSBEEPSTATE
+			Import	__SNDSETSYSBEEPSTATE
+			jmp		__SNDSETSYSBEEPSTATE
+			Import	__SNDPLAYDOUBLEBUFFER
+			jmp		__SNDPLAYDOUBLEBUFFER
+			Import	__SND_NotSure
+			jmp		__SND_NotSure
+			Import	__SND_NotSure2
+			jmp		__SND_NotSure2
+
+@easy		move.l	ExpandMem,a1
+			move.l	ExpandMemRec.soundMgrGlobals(a1),a1
+			move.l	38(a1),a1
+			move.l	20(a1),a0
+			lea		24(a1),a1
+			lsr.b	#1,d0
+			_ProcHelper
+
+
+;31:29e9a
+_R253E	Proc	Export
+			move.l	4(sp),a0
+			_RmvTime
+			clr.l	tmWakeUp(a0)
+			_InsXTime
+			rts
+
+
+;31:29ea8
+_R2544	Proc	Export
+			move.l	16(sp),a0
+			tst.l	8(sp)
+			bne.s	@reinsert
+			move.w	4(a0),d0
+			btst	#15,d0
+			bne.s	@return
+			move.l	12(sp),d0
+			neg.l	d0
+			_PrimeTime
+@return		rts
+
+@reinsert	move.w	4(a0),d0
+			btst	#15,d0
+			beq.s	@doprime
+			_RmvTime
+			clr.l	tmWakeUp(a0)
+			_InsXTime
+@doprime	move.l	12(sp),d0
+			neg.l	d0
+			_PrimeTime
+			rts
+
+
+;31:29ee2
+_R254A	Proc	Export
+			dc.w	$0A
+			dc.w	$11
+			dc.w	$17
+			dc.w	$07
+			dc.w	$09
+			dc.w	$0B
+			dc.w	$10
+			dc.w	$21
+			dc.w	$2E
+			dc.w	$22
+			dc.w	$31
+			dc.w	$0E
+			dc.w	$18
+			dc.w	$21
+			dc.w	$2C
+			dc.w	$10
+			dc.w	$0D
+
+
+;31:29f04
+_R2550	Proc	Export
+			move.l	4(sp),a0
+			clr.l	d0
+			move.w	(a0),d0
+			mulu.w	#$A60,d0
+			clr.l	d1
+			move.w	TimeDBRA,d1
+			bne.s	@gotTimeDBRA
+			move.w	#$311,d1
+@gotTimeDBRA
+			divu.w	d1,d0
+			rts
+
+
+;31:29f20
+_R2556	Proc	Export
+			move.l	VIA,a0
+			bset	#7,(a0)
+			rts
+
+
+;31:29f2a
+_R255C	Proc	Export
+			move.w	sr,d0 ; set interrupt level to >= 2, save original in d0
+			move.w	d0,d1
+			and.w	#$700,d1
+			cmp.w	#$200,d1
+			bge.s	@return
+			move.w	d0,d1
+			and.w	#~$700,d1
+			or.w	#$200,d1
+			move.w	d1,sr
+@return		rts
+
+
+soundAttrGestalt	Proc	Export ; file=SoundMgrLowLevel.a (GestaltFunction.a changelog)
+			link	a6,#-$100
+			move.l	d3,-(sp)
+			move.l	#'mach',d0
+			_Gestalt
+			move.l	a0,d0
+			moveq	#8,d3
+			cmpi.w	#$36,d0
+			bne.s	loc_129F62
+			move.w	#$19,d0
+loc_129F62
+			cmp.w	byte_12A000,d0
+			bhi.s	loc_129F74
+			subq.w	#1,d0
+			lea		unk_12A002,a0
+			move.b	(a0,d0.w),d3
+			bra.s	loc_129FB0
+loc_129F74
+			move.l	$DD4,d1
+			move.l	d1,d2
+			andi.l	#$700,d2
+			beq.s	loc_129F86
+			bset	#4,d3
+loc_129F86
+			move.l	d1,d2
+			andi.l	#$800,d2
+			beq.s	loc_129F94
+			bset	#0,d3
+loc_129F94
+			move.l	d1,d2
+			andi.l	#$1000,d2
+			beq.s	loc_129FA2
+			bset	#1,d3
+loc_129FA2
+			move.l	d1,d2
+			andi.l	#$2000,d2
+			beq.s	loc_129FB0
+			bset	#6,d3
+loc_129FB0
+			move.l	#$A89F,d0
+			_GetToolTrapAddress
+			move.l	a0,-(sp)
+			move.l	#$A800,d0
+			_GetToolTrapAddress
+			cmpa.l	(sp)+,a0
+			beq.s	loc_129FEC
+			clr.l	-(sp)
+			moveq	#$14,d0
+			_SoundDispatch
+			tst.l	(sp)+
+			beq.s	loc_129FEC
+			clr.w	-(sp)
+			move.w	#1,-(sp)
+			pea		-$100(a6)
+			clr.l	-(sp)
+			move.l	#$5140014,d0
+			_SoundDispatch
+			tst.w	(sp)+
+			bne.s	loc_129FEC
+			bset	#5,d3
+loc_129FEC
+			movea.l	8(a6),a0
+			move.l	d3,(a0)
+			clr.w	$10(a6)
+			move.l	(sp)+,d3
+			unlk	a6
+			movea.l	(sp)+,a0
+			addq.l	#8,sp
+			jmp		(a0)
+byte_12A000	dc.b	0
+			dc.b	$1C
+unk_12A002	dc.b	8
+			dc.b	8
+			dc.b	8
+			dc.b	8
+			dc.b	8
+			dc.b	9
+			dc.b	9
+			dc.b	9
+			dc.b	$B
+			dc.b	9
+			dc.b	9
+			dc.b	0
+			dc.b	9
+			dc.b	0
+			dc.b	0
+			dc.b	0
+			dc.b	8
+			dc.b	$5B
+			dc.b	$18
+			dc.b	$5B
+			dc.b	$5B
+			dc.b	$5B
+			dc.b	$18
+			dc.b	8
+			dc.b	$5B
+			dc.b	$5B
+			dc.b	$18
+			dc.b	$5B
+
+
+_R2568	Proc	Export
+			link	a6,#-4
+			move.l	d7,-(sp)
+			move.l	#'hdwr',d0
+			lea		-4(a6),a0
+			movea.l	a0,a1
+			_Gestalt
+			move.l	a0,(a1)
+			move.w	d0,d7
+			moveq	#8,d0
+			and.l	-4(a6),d0
+			move.l	-8(a6),d7
+			unlk	a6
+			rts
+
+
+Snd_Func1	Proc	Export
+			Import	_R254A
+			Import	_R2550
+			Import	_R2568
+
+			link	a6,#-4
+			movem.l	d3/d6-d7/a3-a4,-(sp)
+			moveq	#$40,d0
+			_NewPtrSysClear
+			movea.l	a0,a3
+			movea.l	$2B6,a0
+			move.l	a3,$110(a0)
+			movea.l	$2AE,a0
+			tst.b	8(a0)
+			beq.s	loc_12A068
+			move.l	a3,$CC4
+loc_12A068
+			move.w	#$64,$16(a3)
+			move.w	#1,$18(a3)
+			jsr		_R2568
+			tst.w	d0
+			beq.w	loc_12A14C
+			move.l	#$400,d0
+			_NewPtrSysClear
+			movea.l	a0,a4
+			move.l	a4,$A(a3)
+			clr.w	d7
+			move.w	#$400,d3
+loc_12A092
+			dc.w	$18fc,$ff80		; move.b #$FF80,(a4)+
+			move.w	d7,d0
+			addq.w	#1,d7
+			cmp.w	d7,d3
+			bgt.s	loc_12A092
+			move.l	#'mach',d0
+			lea		-4(a6),a0
+			movea.l	a0,a1
+			_Gestalt
+			move.l	a0,(a1)
+			move.w	d0,d6
+			moveq	#$28,d0
+			_NewPtrSysClear
+			movea.l	a0,a4
+			clr.w	d7
+			move.l	d7,d0
+			add.w	d0,d0
+			lea		_R254A,a0
+			move.w	(a0,d0.w),(a4)
+			moveq	#1,d7
+loc_12A0C6
+			move.l	d7,d0
+			add.w	d0,d0
+			lea		_R254A,a0
+			pea		(a0,d0.w)
+			jsr		_R2550
+			ext.l	d7
+			move.l	d7,d1
+			add.l	d1,d1
+			add.l	a4,d1
+			movea.l	d1,a0
+			move.w	d0,(a0)
+			addq.w	#4,sp
+			move.w	d7,d0
+			addq.w	#1,d7
+			cmpi.w	#$11,d7
+			blt.s	loc_12A0C6
+			move.l	a4,$1A(a3)
+			move.l	#$100,d0
+			_NewHandle	,sys,clear
+			move.l	a0,6(a3)
+			movea.l	$CC0,a0
+			move.b	$800(a0),d0
+			ext.w	d0
+			move.w	#$F0,d1
+			and.b	d0,d1
+			move.b	d1,$2E(a3)
+			movea.l	$CC0,a0
+			moveq	#$F,d0
+			and.b	$800(a0),d0
+			move.b	d0,$2F(a3)
+			moveq	#0,d0
+			move.b	$2E(a3),d0
+			cmpi.w	#$B0,d0
+			bne.s	loc_12A152
+			movea.l	$CC0,a0
+			move.b	#1,$F09(a0)
+			movea.l	$CC0,a0
+			move.b	#1,$F29(a0)
+			movea.l	$CC0,a0
+			move.b	#1,$801(a0)
+			bra.s	loc_12A152
+loc_12A14C
+			move.b	#$FF,$2E(a3)
+loc_12A152
+			moveq	#0,d0
+			movem.l	-$18(a6),d3/d6-d7/a3-a4
+			unlk	a6
+			rts
+
+
+_R2574	Proc	Export
+			link	a6,#0
+			movem.l	d3/d5-d7/a3-a4,-(sp)
+			movea.l	8(a6),a3
+			move.w	$E(a6),d5
+			cmpi.w	#2,d5
+			bge.s	loc_12A178
+			moveq	#0,d0
+			bra.s	loc_12A1B6
+loc_12A178
+			movea.l	a3,a0
+			_HUnlock
+			movea.l	a3,a0
+			move.w	d5,d0
+			ext.l	d0
+			asl.l	#8,d0
+			_SetHandleSize
+			move.w	$220,d6
+			movea.l	a3,a0
+			_HLock
+			tst.w	d6
+			beq.s	loc_12A196
+			move.w	d6,d0
+			bra.s	loc_12A1B6
+loc_12A196
+			movea.l	(a3),a4
+			clr.w	d6
+			move.w	#$100,d3
+loc_12A19E
+			clr.w	d7
+			bra.s	loc_12A1A8
+loc_12A1A2
+			move.b	d6,(a4)+
+			move.w	d7,d0
+			addq.w	#1,d7
+loc_12A1A8
+			cmp.w	d7,d5
+			bgt.s	loc_12A1A2
+			move.w	d6,d0
+			addq.w	#1,d6
+			cmp.w	d6,d3
+			bgt.s	loc_12A19E
+			moveq	#0,d0
+loc_12A1B6
+			movem.l	-$18(a6),d3/d5-d7/a3-a4
+			unlk	a6
+			rts
+
+
+_R257A	Proc	Export
+			Import	_R255C
+
+			link	a6,#0
+			movem.l	d7/a4,-(sp)
+			movea.l	8(a6),a4
+			jsr		_R255C
+			move.w	d0,d7
+			move.w	$20(a4),d0
+			cmp.w	$22(a4),d0
+			bne.s	loc_12A1E6
+			ext.l	d7
+			move.l	d7,d0
+			move	d0,sr
+			moveq	#1,d0
+			bra.s	loc_12A228
+loc_12A1E6
+			moveq	#$FFFFFFFF,d0
+			cmp.w	$20(a4),d0
+			bne.s	loc_12A1FA
+			move.w	$22(a4),$20(a4)
+			andi.w	#$FFEF,$1C(a4)
+loc_12A1FA
+			movea.l	$C(a6),a0
+			move.w	$22(a4),d0
+			addq.w	#1,$22(a4)
+			ext.l	d0
+			asl.l	#3,d0
+			lea		$24(a4,d0.l),a1
+			move.l	(a0)+,(a1)+
+			move.l	(a0)+,(a1)+
+			move.w	$22(a4),d0
+			cmp.w	$1E(a4),d0
+			bne.s	loc_12A220
+			clr.w	$22(a4)
+loc_12A220
+			ext.l	d7
+			move.l	d7,d0
+			move	d0,sr
+			moveq	#0,d0
+loc_12A228
+			movem.l	-8(a6),d7/a4
+			unlk	a6
+			rts
+
+
+_R2580	Proc	Export
+			link	a6,#0
+			move.l	a4,-(sp)
+			movea.l	8(a6),a4
+			moveq	#$FFFFFFFF,d0
+			cmp.w	$20(a4),d0
+			bne.s	loc_12A248
+			moveq	#1,d0
+			bra.s	loc_12A286
+loc_12A248
+			move.w	$20(a4),d0
+			addq.w	#1,$20(a4)
+			ext.l	d0
+			asl.l	#3,d0
+			movea.l	$C(a6),a0
+			lea		$24(a4,d0.l),a1
+			move.l	(a1)+,(a0)+
+			move.l	(a1)+,(a0)+
+			move.w	$20(a4),d0
+			cmp.w	$1E(a4),d0
+			bne.s	loc_12A26E
+			clr.w	$20(a4)
+loc_12A26E
+			move.w	$20(a4),d0
+			cmp.w	$22(a4),d0
+			bne.s	loc_12A284
+			move.w	#$FFFF,$20(a4)
+			ori.w	#$10,$1C(a4)
+loc_12A284
+			moveq	#0,d0
+loc_12A286
+			movea.l	-4(a6),a4
+			unlk	a6
+			rts
+
+
+_R2586	Proc	Export
+			Import	_R2544
+
+			link	a6,#0
+			movem.l	d3/a3-a4,-(sp)
+			movea.l	8(a6),a0
+			movea.l	4(a0),a4
+			move.l	a4,d0
+			beq.w	def_12A2C6
+			bra.s	loc_12A2A8
+loc_12A2A6
+			movea.l	(a4),a4
+loc_12A2A8
+			tst.l	(a4)
+			bne.s	loc_12A2A6
+			movea.l	$C(a6),a0
+			move.w	(a0),d0
+			subq.w	#3,d0
+			bcs.w	def_12A2C6
+			cmpi.w	#$1C,d0
+			bhi.w	def_12A2C6
+			add.w	d0,d0
+			move.w	jtbl(d0),d0
+jtblbase	equ		*+2
+			jmp		jtblbase(d0)
+jtbl		dc.w	loc_12A304-jtblbase
+			dc.w	loc_12A312-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	loc_12A332-jtblbase
+			dc.w	loc_12A37A-jtblbase
+			dc.w	loc_12A388-jtblbase
+			dc.w	loc_12A3C6-jtblbase
+			dc.w	loc_12A3E2-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	loc_12A466-jtblbase
+			dc.w	loc_12A4A4-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+			dc.w	def_12A2C6-jtblbase
+loc_12A304
+			movea.l	8(a6),a0
+			ori.w	#2,$1C(a0)
+			bra.w	def_12A2C6
+loc_12A312
+			movea.l	8(a6),a0
+			move.w	#$FFFF,$20(a0)
+			movea.l	8(a6),a0
+			clr.w	$22(a0)
+			movea.l	8(a6),a0
+			ori.w	#$10,$1C(a0)
+			bra.w	def_12A2C6
+loc_12A332
+			movea.l	$C(a6),a0
+			moveq	#0,d0
+			move.w	2(a0),d0
+			tst.l	d0
+			movea.l	8(a6),a0
+			move.l	d0,$10(a0)
+			move.l	$42(a4),-(sp)
+			movea.l	8(a6),a0
+			move.l	$10(a0),d1
+			move.l	d1,d0
+			mulu.w	#$1F4,d1
+			swap	d0
+			mulu.w	#$1F4,d0
+			swap	d0
+			clr.w	d0
+			add.l	d0,d1
+			move.l	d1,-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			move.l	8(a6),-(sp)
+			jsr		_R2544
+			lea		$10(sp),sp
+			bra.w	def_12A2C6
+loc_12A37A
+			movea.l	8(a6),a0
+			ori.w	#4,$1C(a0)
+			bra.w	def_12A2C6
+loc_12A388
+			movea.l	8(a6),a0
+			andi.w	#$FFB3,$1C(a0)
+			moveq	#0,d0
+			move.l	d0,$10(a4)
+			movea.l	8(a6),a0
+			move.l	d0,$10(a0)
+			movea.l	8(a6),a0
+			moveq	#$FFFFFFFF,d1
+			cmp.w	$20(a0),d1
+			beq.w	def_12A2C6
+			move.l	$42(a4),-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			move.l	d0,-(sp)
+			move.l	a0,-(sp)
+			jsr		_R2544
+			lea		$10(sp),sp
+			bra.w	def_12A2C6
+loc_12A3C6
+			movea.l	8(a6),a0
+			tst.l	8(a0)
+			beq.w	def_12A2C6
+			move.l	a0,-(sp)
+			move.l	$C(a6),-(sp)
+			movea.l	8(a0),a1
+			jsr		(a1)
+			bra.w	def_12A2C6
+loc_12A3E2
+			movea.l	$C(a6),a0
+			movea.l	8(a6),a1
+			lea		$14(a1),a1
+			move.l	(a0)+,(a1)+
+			move.l	(a0)+,(a1)+
+			movea.l	8(a6),a0
+			ori.w	#8,$1C(a0)
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	(a0),a3
+			bra.s	loc_12A460
+loc_12A408
+			moveq	#8,d0
+			and.w	$1C(a3),d0
+			beq.s	loc_12A45E
+			movea.l	$C(a6),a0
+			move.l	$18(a3),d0
+			cmp.l	4(a0),d0
+			bne.s	loc_12A45E
+			subq.w	#1,$16(a3)
+			tst.w	$16(a3)
+			bne.s	loc_12A45E
+			andi.w	#$FFF7,$1C(a3)
+			movea.l	4(a3),a4
+			bra.s	loc_12A436
+loc_12A434
+			movea.l	(a4),a4
+loc_12A436
+			tst.l	(a4)
+			bne.s	loc_12A434
+			movea.l	8(a6),a0
+			moveq	#$FFFFFFFF,d0
+			cmp.w	$20(a0),d0
+			beq.s	loc_12A45E
+			move.l	a4,d0
+			beq.s	loc_12A45E
+			move.l	$42(a4),-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			move.l	d0,-(sp)
+			move.l	a0,-(sp)
+			jsr		_R2544
+			lea		$10(sp),sp
+loc_12A45E
+			movea.l	(a3),a3
+loc_12A460
+			move.l	a3,d0
+			bne.s	loc_12A408
+			bra.s	def_12A2C6
+loc_12A466
+			movea.l	$C(a6),a0
+			moveq	#0,d0
+			move.w	2(a0),d0
+			move.l	d0,$10(a4)
+			move.l	d0,$C(a4)
+			move.l	$3E(a4),-(sp)
+			move.l	$C(a4),d1
+			move.l	d1,d0
+			mulu.w	#$1F4,d1
+			swap	d0
+			mulu.w	#$1F4,d0
+			swap	d0
+			clr.w	d0
+			add.l	d0,d1
+			move.l	d1,-(sp)
+			move.l	a4,-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			jsr		_R2544
+			lea		$10(sp),sp
+			bra.s	def_12A2C6
+loc_12A4A4
+			movea.l	$C(a6),a0
+			moveq	#0,d0
+			move.w	2(a0),d0
+			move.l	d0,$C(a4)
+			move.l	$3E(a4),-(sp)
+			move.l	$C(a4),d1
+			move.l	d1,d0
+			mulu.w	#$1F4,d1
+			swap	d0
+			mulu.w	#$1F4,d0
+			swap	d0
+			clr.w	d0
+			add.l	d0,d1
+			move.l	d1,-(sp)
+			move.l	a4,-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			jsr		_R2544
+			lea		$10(sp),sp
+def_12A2C6
+			movem.l	-$C(a6),d3/a3-a4
+			unlk	a6
+			rts
+
+
+_R258C_OTHERNAME	Proc	Export
+			Import	_R2586
+			Import	_R258C
+
+			link	a6,#0
+			movem.l	d6-d7/a3-a4,-(sp)
+			movea.l	$10(a6),a3
+			movea.l	$C(a6),a4
+			clr.w	d6
+loc_12A4F8
+			moveq	#0,d0
+			move.w	(a4),d0
+			tst.l	d0
+			beq.s	loc_12A536
+			move.l	a3,d0
+			beq.s	loc_12A528
+			subq.l	#2,sp
+			move.l	8(a6),-(sp)
+			move.l	a4,-(sp)
+			move.l	a3,-(sp)
+			movea.l	4(a3),a0
+			jsr		(a0)
+			move.b	(sp)+,d7
+			move.l	(a3),-(sp)
+			move.l	a4,-(sp)
+			move.l	8(a6),-(sp)
+			jsr		_R258C ; this is an internal call, we need the assembler not to optimise it
+			lea		$C(sp),sp
+			bra.s	loc_12A536
+loc_12A528
+			clr.b	d7
+			move.l	a4,-(sp)
+			move.l	8(a6),-(sp)
+			jsr		_R2586
+			addq.w	#8,sp
+loc_12A536
+			move.w	#$15,(a4)
+			addq.w	#1,d6
+			move.w	d6,2(a4)
+			tst.b	d7
+			bne.s	loc_12A4F8
+			movem.l	-$10(a6),d6-d7/a3-a4
+			unlk	a6
+			rts
+
+
+_R2592	Proc	Export
+			Import	_R2580
+			Import	_R258C_OTHERNAME
+
+			link	a6,#-8
+			move.l	a4,-(sp)
+			movea.l	8(a6),a4
+			pea		-8(a6)
+			move.l	a4,-(sp)
+			jsr		_R2580
+			tst.b	d0
+			addq.w	#8,sp
+			beq.s	loc_12A56C
+			moveq	#1,d0
+			bra.s	loc_12A580
+loc_12A56C
+			move.l	4(a4),-(sp)
+			pea		-8(a6)
+			move.l	a4,-(sp)
+			jsr		_R258C_OTHERNAME
+			moveq	#0,d0
+			lea		$C(sp),sp
+loc_12A580
+			movea.l	-$C(a6),a4
+			unlk	a6
+			rts
+
+
+_R2598	Proc	Export
+			Import	_R253E
+			Import	_R258C_OTHERNAME
+
+			link	a6,#-8
+			movem.l	a3-a4,-(sp)
+			movea.l	8(a6),a3
+			moveq	#$10,d0
+			and.w	$1C(a3),d0
+			beq.s	loc_12A5D0
+			move.w	#$F,-8(a6)
+			move.l	4(a3),-(sp)
+			pea		-8(a6)
+			move.l	a3,-(sp)
+			jsr		_R258C_OTHERNAME
+			andi.w	#$FFEF,$1C(a3)
+			movea.l	4(a3),a4
+			lea		$C(sp),sp
+			bra.s	loc_12A5C2
+loc_12A5C0
+			movea.l	(a4),a4
+loc_12A5C2
+			tst.l	(a4)
+			bne.s	loc_12A5C0
+			move.l	$42(a4),-(sp)
+			jsr		_R253E
+			addq.w	#4,sp
+loc_12A5D0
+			movem.l	-$10(a6),a3-a4
+			unlk	a6
+			rts
+
+
+_R259E	Proc	Export
+			Import	_R258C_OTHERNAME
+
+			link	a6,#-8
+			move.w	#$14,-8(a6)
+			move.l	$C(a6),-(sp)
+			pea		-8(a6)
+			move.l	8(a6),-(sp)
+			jsr		_R258C_OTHERNAME
+			unlk	a6
+			rts
+
+
+_R25A4	Proc	Export
+			link	a6,#-4
+			movem.l	d3/a3-a4,-(sp)
+			move.l	8(a6),d0
+			_StripAddress
+			move.l	d0,-4(a6)
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	(a0),a3
+			bra.s	loc_12A634
+loc_12A616
+			movea.l	4(a3),a4
+			bra.s	loc_12A62E
+loc_12A61C
+			move.l	4(a4),d0
+			_StripAddress
+			cmp.l	-4(a6),d0
+			bne.s	loc_12A62C
+			move.l	a4,d0
+			bra.s	loc_12A63A
+loc_12A62C
+			movea.l	(a4),a4
+loc_12A62E
+			move.l	a4,d0
+			bne.s	loc_12A61C
+			movea.l	(a3),a3
+loc_12A634
+			move.l	a3,d0
+			bne.s	loc_12A616
+			moveq	#0,d0
+loc_12A63A
+			movem.l	-$10(a6),d3/a3-a4
+			unlk	a6
+			rts
+
+
+_R25AA	Proc	Export
+			Import	_R2568
+			Import	_R2574
+			Import	_R258C_OTHERNAME
+			Import	_R25A4
+
+			link	a6,#-8
+			movem.l	d3/a3-a4,-(sp)
+			move.l	8(a6),d0
+			_StripAddress
+			movea.l	d0,a4
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			lea		(a0),a3
+			bra.s	loc_12A674
+loc_12A660
+			move.l	(a3),d0
+			_StripAddress
+			cmpa.l	d0,a4
+			bne.s	loc_12A670
+			movea.l	8(a6),a0
+			move.l	(a0),(a3)
+			bra.s	loc_12A678
+loc_12A670
+			movea.l	(a3),a0
+			movea.l	a0,a3
+loc_12A674
+			tst.l	(a3)
+			bne.s	loc_12A660
+loc_12A678
+			movea.l	8(a6),a0
+			movea.l	4(a0),a4
+			bra.s	loc_12A6D2
+loc_12A682
+			movea.l	(a4),a3
+			move.w	#2,-8(a6)
+			move.l	a4,-(sp)
+			pea		-8(a6)
+			move.l	8(a6),-(sp)
+			jsr		_R258C_OTHERNAME
+			move.l	4(a4),-(sp)
+			jsr		_R25A4
+			tst.l	d0
+			lea		$10(sp),sp
+			bne.s	loc_12A6B4
+			tst.l	$16(a4)
+			beq.s	loc_12A6B4
+			movea.l	$16(a4),a0
+			_HUnlock
+loc_12A6B4
+			movea.l	$3E(a4),a0
+			_RmvTime
+			movea.l	$3E(a4),a0
+			_DisposePtr
+			movea.l	$42(a4),a0
+			_RmvTime
+			movea.l	$42(a4),a0
+			_DisposePtr
+			movea.l	a4,a0
+			_DisposePtr
+			movea.l	a3,a4
+loc_12A6D2
+			move.l	a4,d0
+			bne.s	loc_12A682
+			movea.l	8(a6),a0
+			move.w	$1C(a0),d0
+			btst	#0,d0
+			beq.s	loc_12A6E6
+			_DisposePtr
+loc_12A6E6
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			tst.w	4(a0)
+			ble.s	loc_12A72A
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			subq.w	#1,4(a0)
+			jsr		_R2568
+			tst.w	d0
+			beq.s	loc_12A72A
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.w	4(a0),d0
+			ext.l	d0
+			move.l	d0,-(sp)
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.l	6(a0),-(sp)
+			jsr		_R2574
+			addq.w	#8,sp
+loc_12A72A
+			movem.l	-$14(a6),d3/a3-a4
+			unlk	a6
+			rts
+
+
+_R25B0	Proc	Export
+			link	a6,#-$C
+			movem.l	d3/d6-d7/a3-a4,-(sp)
+			movea.l	$C(a6),a0
+			movea.l	(a0),a3
+			lea		4(a3),a4
+			move.w	2(a3),d7
+			bra.s	loc_12A76A
+loc_12A74C
+			subq.l	#2,sp
+			move.l	8(a6),-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			move.w	(a4),-(sp)
+			move.l	2(a4),-(sp)
+			_SndAddModifier
+			move.w	(sp)+,d6
+			beq.s	loc_12A766
+			move.w	d6,d0
+			bra.s	loc_12A7BE
+loc_12A766
+			subq.w	#1,d7
+			addq.w	#6,a4
+loc_12A76A
+			tst.w	d7
+			bgt.s	loc_12A74C
+			movea.l	a4,a0
+			move.w	(a0)+,d7
+			move.l	a0,-$C(a6)
+			bra.s	loc_12A7B8
+loc_12A778
+			move.l	-$C(a6),d0
+			addq.l	#8,-$C(a6)
+			movea.l	d0,a0
+			lea		-8(a6),a1
+			move.l	(a0)+,(a1)+
+			move.l	(a0)+,(a1)+
+			moveq	#0,d0
+			move.w	-8(a6),d0
+			move.w	#$8000,d1
+			and.w	d0,d1
+			beq.s	loc_12A7A4
+			move.l	a3,d0
+			add.l	d0,-4(a6)
+			andi.w	#$7FFF,-8(a6)
+loc_12A7A4
+			subq.l	#2,sp
+			move.l	8(a6),-(sp)
+			pea		-8(a6)
+			moveq	#0,d0
+			move.b	d0,-(sp)
+			_SndDoCommand
+			addq.w	#2,sp
+			subq.w	#1,d7
+loc_12A7B8
+			tst.w	d7
+			bgt.s	loc_12A778
+			moveq	#0,d0
+loc_12A7BE
+			movem.l	-$20(a6),d3/d6-d7/a3-a4
+			unlk	a6
+			rts
+
+
+_R25B6	Proc	Export
+			Import	_R2544
+			Import	_R259E
+
+			link	a6,#-4
+			movem.l	a3-a4,-(sp)
+			move.l	a1,d0
+			movea.l	d0,a3
+			move.l	$16(a3),-4(a6)
+			movea.l	$1A(a3),a4
+			move.l	a4,-(sp)
+			move.l	-4(a6),-(sp)
+			jsr		_R259E
+			tst.l	$10(a4)
+			addq.w	#8,sp
+			ble.s	loc_12A81E
+			move.l	$10(a4),$C(a4)
+			move.l	a3,-(sp)
+			move.l	$10(a4),d1
+			move.l	d1,d0
+			mulu.w	#$1F4,d1
+			swap	d0
+			mulu.w	#$1F4,d0
+			swap	d0
+			clr.w	d0
+			add.l	d0,d1
+			move.l	d1,-(sp)
+			move.l	a4,-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			jsr		_R2544
+			lea		$10(sp),sp
+loc_12A81E
+			movem.l	-$C(a6),a3-a4
+			unlk	a6
+			rts
+
+
+_R25BC	Proc	Export
+			Import	_R253E
+			Import	_R2592
+			Import	_R2598
+			Import	NGETTRAPADDRESS
+
+			link	a6,#-4
+			movem.l	d7/a3-a4,-(sp)
+			move.l	a1,d0
+			move.l	d0,-4(a6)
+			movea.l	d0,a0
+			movea.l	$16(a0),a4
+			movea.l	-4(a6),a0
+			movea.l	$1A(a0),a3
+			move.l	$10(a4),d7
+			moveq	#0,d0
+			move.l	d0,$10(a4)
+			tst.l	d7
+			bne.s	loc_12A884
+			movea.l	4(a4),a3
+			bra.s	loc_12A85A
+loc_12A858
+			movea.l	(a3),a3
+loc_12A85A
+			tst.l	(a3)
+			bne.s	loc_12A858
+			move.l	$42(a3),-(sp)
+			jsr		_R253E
+			addq.w	#4,sp
+			bra.s	loc_12A884
+loc_12A86A
+			move.l	a4,-(sp)
+			jsr		_R2592
+			tst.b	d0
+			addq.w	#4,sp
+			beq.s	loc_12A884
+			tst.l	d7
+			beq.s	loc_12A892
+			move.l	a4,-(sp)
+			jsr		_R2598
+			addq.w	#4,sp
+			bra.s	loc_12A892
+loc_12A884
+			tst.l	$10(a4)
+			bne.s	loc_12A892
+			moveq	#$4C,d0
+			and.w	$1C(a4),d0
+			beq.s	loc_12A86A
+loc_12A892
+			movem.l	-$10(a6),d7/a3-a4
+			unlk	a6
+			rts
+
+
+IsDeadProcess	Proc	Export
+			Import	NGETTRAPADDRESS
+
+			link	a6,#-$A
+			clr.b	-1(a6)
+			subq.l	#4,sp
+			move.w	#$A89F,-(sp)
+			moveq	#1,d0
+			move.b	d0,-(sp)
+			jsr		NGETTRAPADDRESS
+			subq.l	#4,sp
+			move.w	#$A88F,-(sp)
+			moveq	#1,d0
+			move.b	d0,-(sp)
+			jsr		NGETTRAPADDRESS
+			move.l	(sp)+,d0
+			cmp.l	(sp)+,d0
+			beq.s	loc_12A8EC
+			subq.l	#2,sp
+			pea		-$A(a6)
+			move.w	#$37,-(sp)
+			_OSDispatch
+			tst.w	(sp)+
+			bne.s	loc_12A8EC
+			subq.l	#2,sp
+			pea		-$A(a6)
+			pea		8(a6)
+			pea		-1(a6)
+			move.w	#$3D,-(sp)
+			_OSDispatch
+			addq.w	#2,sp
+loc_12A8EC
+			move.b	-1(a6),d0
+			unlk	a6
+			rts
+
+
+__SNDAPPDEAD	PatchProc	_SndAppDead,(Plus,SE,II,Portable,IIci,notAUX)
+			Import	_R2556
+			Import	IsDeadProcess
+
+			link	a6,#-4
+			movem.l	d3/a3-a4,-(sp)
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	(a0),a3
+			bra.s	loc_12A93C
+loc_12A908
+			move.l	(a3),-4(a6)
+			movea.l	4(a3),a4
+			bra.s	loc_12A934
+loc_12A912
+			lea		$84(a4),a0
+			move.l	-(a0),-(sp)
+			move.l	-(a0),-(sp)
+			jsr		IsDeadProcess
+			tst.b	d0
+			addq.w	#8,sp
+			beq.s	loc_12A932
+			subq.l	#2,sp
+			move.l	a3,-(sp)
+			moveq	#1,d0
+			move.b	d0,-(sp)
+			_SndDisposeChannel
+			addq.w	#2,sp
+			bra.s	loc_12A938
+loc_12A932
+			movea.l	(a4),a4
+loc_12A934
+			move.l	a4,d0
+			bne.s	loc_12A912
+loc_12A938
+			movea.l	-4(a6),a3
+loc_12A93C
+			move.l	a3,d0
+			bne.s	loc_12A908
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	$26(a0),a0
+			movea.l	2(a0),a3
+			bra.s	loc_12A976
+loc_12A952
+			movea.l	(a3),a4
+			lea		$5C(a3),a0
+			move.l	-(a0),-(sp)
+			move.l	-(a0),-(sp)
+			jsr		IsDeadProcess
+			tst.b	d0
+			addq.w	#8,sp
+			beq.s	loc_12A974
+			subq.l	#2,sp
+			move.l	a3,-(sp)
+			move.l	#$21C0014,d0
+			_SoundDispatch
+			addq.w	#2,sp
+loc_12A974
+			movea.l	a4,a3
+loc_12A976
+			move.l	a3,d0
+			bne.s	loc_12A952
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			tst.w	4(a0)
+			bne.s	loc_12A98C
+			jsr		_R2556
+loc_12A98C
+			movem.l	-$10(a6),d3/a3-a4
+			unlk	a6
+			rts
+
+
+__SNDDOCOMMAND	PatchProc	_SndDoCommand,(Plus,SE,II,Portable,IIci,notAUX)
+			Import	_R2544
+			Import	_R255C
+			Import	_R257A
+			Import	_R261C
+
+			link	a6,#0
+			movem.l	d6-d7/a3-a4,-(sp)
+			move.b	8(a6),d6
+			movea.l	$E(a6),a3
+			move.l	a3,-(sp)
+			jsr		_R261C
+			tst.b	d0
+			addq.w	#4,sp
+			beq.s	loc_12A9BA
+			move.w	#$FF33,$12(a6)
+			bra.s	loc_12AA2C
+loc_12A9BA
+			movea.l	4(a3),a4
+			move.l	a4,d0
+			bne.s	loc_12A9CC
+			move.w	#$FF33,$12(a6)
+			bra.s	loc_12AA2C
+loc_12A9CA
+			movea.l	(a4),a4
+loc_12A9CC
+			tst.l	(a4)
+			bne.s	loc_12A9CA
+loc_12A9D0
+			move.l	$A(a6),-(sp)
+			move.l	a3,-(sp)
+			jsr		_R257A
+			move.b	d0,d7
+			addq.w	#8,sp
+			beq.s	loc_12A9E4
+			tst.b	d6
+			beq.s	loc_12A9D0
+loc_12A9E4
+			jsr		_R255C
+			move.w	d0,d6
+			tst.l	$10(a3)
+			bgt.s	loc_12AA14
+			moveq	#$4C,d0
+			and.w	$1C(a3),d0
+			bne.s	loc_12AA14
+			moveq	#$FFFFFFFF,d0
+			cmp.w	$20(a3),d0
+			beq.s	loc_12AA14
+			move.l	$42(a4),-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			move.l	d0,-(sp)
+			move.l	a3,-(sp)
+			jsr		_R2544
+			lea		$10(sp),sp
+loc_12AA14
+			ext.l	d6
+			move.l	d6,d0
+			move	d0,sr
+			tst.b	d7
+			beq.s	loc_12AA26
+			move.l	#$FFFFFF35,d0
+			bra.s	loc_12AA28
+loc_12AA26
+			moveq	#0,d0
+loc_12AA28
+			move.w	d0,$12(a6)
+loc_12AA2C
+			movem.l	-$10(a6),d6-d7/a3-a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			lea		$A(sp),sp
+			jmp		(a0)
+
+
+__SNDDOIMMEDIATE	PatchProc	_SndDoImmediate,(Plus,SE,II,Portable,IIci,notAUX)
+			Import	_R253E
+			Import	_R255C
+			Import	_R258C_OTHERNAME
+			Import	_R261C
+
+			link	a6,#-8
+			movem.l	d7/a3-a4,-(sp)
+			movea.l	$C(a6),a3
+			move.l	a3,-(sp)
+			jsr		_R261C
+			tst.b	d0
+			addq.w	#4,sp
+			beq.s	loc_12AA5C
+			move.w	#$FF33,$10(a6)
+			bra.s	loc_12AAB2
+loc_12AA5C
+			movea.l	8(a6),a0
+			moveq	#0,d0
+			move.w	(a0),d0
+			moveq	#$28,d1
+			cmp.l	d0,d1
+			bne.s	loc_12AA84
+			movea.l	4(a3),a4
+			bra.s	loc_12AA72
+loc_12AA70
+			movea.l	(a4),a4
+loc_12AA72
+			tst.l	(a4)
+			bne.s	loc_12AA70
+			move.l	a4,d0
+			beq.s	loc_12AA84
+			move.l	$42(a4),-(sp)
+			jsr		_R253E
+			addq.w	#4,sp
+loc_12AA84
+			movea.l	8(a6),a0
+			lea		-8(a6),a1
+			move.l	(a0)+,(a1)+
+			move.l	(a0)+,(a1)+
+			jsr		_R255C
+			move.w	d0,d7
+			move.l	4(a3),-(sp)
+			pea		-8(a6)
+			move.l	a3,-(sp)
+			jsr		_R258C_OTHERNAME
+			ext.l	d7
+			move.l	d7,d0
+			move	d0,sr
+			clr.w	$10(a6)
+			lea		$C(sp),sp
+loc_12AAB2
+			movem.l	-$14(a6),d7/a3-a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			addq.w	#8,sp
+			jmp		(a0)
+
+
+__SNDNEWCHANNEL	PatchProc	_SndNewChannel,(Plus,SE,II,Portable,IIci,notAUX)
+; Touched by AIncludes Release Notes, 5/27/92 10:41:35 PM
+			Import	_R255C
+			Import	_R2568
+			Import	_R2574
+			Import	_R25AA
+
+			link	a6,#-4
+			movem.l	d3/d5-d7/a3-a4,-(sp)
+			move.w	$10(a6),d5
+			tst.l	$12(a6)
+			bne.s	loc_12AADC
+			move.w	#$FF33,$16(a6)
+			bra.w	loc_12AC74
+loc_12AADC
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			tst.l	$1E(a0)
+			beq.s	loc_12AB10
+			move.l	#'snd ',d0
+			lea		-4(a6),a0
+			movea.l	a0,a1
+			_Gestalt
+			move.l	a0,(a1)
+			tst.w	d0
+			bne.s	loc_12AB10
+			moveq	#6,d0
+			and.l	-4(a6),d0
+			bne.s	loc_12AB10
+			move.w	#$FF37,$16(a6)
+			bra.w	loc_12AC74
+loc_12AB10
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	(a0),a4
+			bra.s	loc_12AB42
+loc_12AB1C
+			movea.l	(a4),a3
+			movea.l	$12(a6),a0
+			cmpa.l	(a0),a4
+			bne.s	loc_12AB30
+			move.w	#$FF2F,$16(a6)
+			bra.w	loc_12AC74
+loc_12AB30
+			moveq	#$20,d0
+			and.w	$1C(a4),d0
+			beq.s	loc_12AB40
+			move.l	a4,-(sp)
+			jsr		_R25AA
+			addq.w	#4,sp
+loc_12AB40
+			movea.l	a3,a4
+loc_12AB42
+			move.l	a4,d0
+			bne.s	loc_12AB1C
+			clr.b	d7
+			movea.l	$12(a6),a0
+			movea.l	(a0),a4
+			move.l	a4,d0
+			bne.s	loc_12AB80
+			move.l	#$424,d0
+			_NewPtrSysClear
+			movea.l	$12(a6),a1
+			move.l	a0,(a1)
+			movea.l	a0,a4
+			move.l	a4,d0
+			bne.s	loc_12AB70
+			move.w	$220,$16(a6)
+			bra.w	loc_12AC74
+loc_12AB70
+			moveq	#1,d7
+			move.w	#1,$1C(a4)
+			move.w	#$80,$1E(a4)
+			bra.s	loc_12AB94
+loc_12AB80
+			tst.w	$1E(a4)
+			bne.s	loc_12AB90
+			move.w	#$FF33,$16(a6)
+			bra.w	loc_12AC74
+loc_12AB90
+			clr.w	$1C(a4)
+loc_12AB94
+			moveq	#0,d0
+			move.l	d0,4(a4)
+			move.l	8(a6),8(a4)
+			move.l	d0,$C(a4)
+			move.l	d0,$10(a4)
+			move.w	#$FFFF,$20(a4)
+			clr.w	$22(a4)
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.l	(a0),(a4)
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			addq.w	#1,4(a0)
+			tst.w	d5
+			beq.s	off_12ABFA
+			subq.l	#2,sp
+			move.l	a4,-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			move.w	d5,-(sp)
+			move.l	$C(a6),-(sp)
+			_SndAddModifier
+			move.w	(sp)+,d6
+			beq.s	off_12ABFA
+			tst.b	d7
+			beq.s	loc_12ABEC
+			movea.l	$12(a6),a0
+			moveq	#0,d0
+			move.l	d0,(a0)
+loc_12ABEC
+			move.l	a4,-(sp)
+			jsr		_R25AA
+			move.w	d6,$16(a6)
+			addq.w	#4,sp
+			bra.s	loc_12AC74
+off_12ABFA	jsr		_R255C
+			move.w	d0,d5
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.l	a4,(a0)
+			ext.l	d5
+			move.l	d5,d0
+			move	d0,sr
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			moveq	#1,d0
+			cmp.w	4(a0),d0
+			bge.s	loc_12AC70
+			jsr		_R2568
+			tst.w	d0
+			beq.s	loc_12AC70
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.w	4(a0),d0
+			ext.l	d0
+			move.l	d0,-(sp)
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.l	6(a0),-(sp)
+			jsr		_R2574
+			tst.w	d0
+			sne		d0
+			neg.b	d0
+			ext.w	d0
+			move.w	d0,d6
+			addq.w	#8,sp
+			beq.s	loc_12AC70
+			tst.b	d7
+			beq.s	loc_12AC62
+			movea.l	$12(a6),a0
+			moveq	#0,d0
+			move.l	d0,(a0)
+loc_12AC62
+			move.l	a4,-(sp)
+			jsr		_R25AA
+			move.w	d6,$16(a6)
+			addq.w	#4,sp
+			bra.s	loc_12AC74
+loc_12AC70
+			clr.w	$16(a6)
+loc_12AC74
+			movem.l	-$1C(a6),d3/d5-d7/a3-a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			lea		$E(sp),sp
+			jmp		(a0)
+
+
+__SNDDISPOSECHANNEL	PatchProc	_SndDisposeChannel,(Plus,SE,II,Portable,IIci,notAUX)
+			Import	_R25AA
+			Import	_R261C
+
+			link	a6,#-$C
+			move.l	a4,-(sp)
+			movea.l	$A(a6),a4
+			move.l	a4,-(sp)
+			jsr		_R261C
+			tst.b	d0
+			addq.w	#4,sp
+			beq.s	loc_12ACA2
+			move.w	#$FF33,$E(a6)
+			bra.s	loc_12AD10
+loc_12ACA2
+			tst.l	4(a4)
+			beq.s	loc_12ACF8
+			moveq	#2,d0
+			and.w	$1C(a4),d0
+			bne.s	loc_12ACF8
+			tst.b	8(a6)
+			beq.s	loc_12ACDA
+			move.w	#4,-$C(a6)
+			subq.l	#2,sp
+			move.l	a4,-(sp)
+			pea		-$C(a6)
+			_SndDoImmediate
+			move.w	#3,-$C(a6)
+			subq.l	#2,sp
+			move.l	a4,-(sp)
+			pea		-$C(a6)
+			_SndDoImmediate
+			addq.w	#4,sp
+			bra.s	loc_12ACF0
+loc_12ACDA
+			move.w	#3,-$C(a6)
+			subq.l	#2,sp
+			move.l	a4,-(sp)
+			pea		-$C(a6)
+			moveq	#0,d0
+			move.b	d0,-(sp)
+			_SndDoCommand
+			addq.w	#2,sp
+loc_12ACF0
+			moveq	#2,d0
+			and.w	$1C(a4),d0
+			beq.s	loc_12ACF0
+loc_12ACF8
+			movea.w	#3,a0
+			lea		-4(a6),a1
+			_Delay
+			move.l	d0,(a1)
+			move.l	a4,-(sp)
+			jsr		_R25AA
+			clr.w	$E(a6)
+			addq.w	#4,sp
+loc_12AD10
+			movea.l	-$10(a6),a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			addq.w	#6,sp
+			jmp		(a0)
+
+
+__SNDPLAY	PatchProc	_SndPlay,(Plus,SE,II,Portable,IIci,notAUX)
+			Import	_R2568
+			Import	_R2574
+			Import	_R25AA
+			Import	_R25B0
+			Import	_R261C
+
+			link	a6,#-$C
+			movem.l	d4-d7/a3-a4,-(sp)
+			move.b	8(a6),d4
+			movea.l	$E(a6),a3
+			movea.l	$A(a6),a4
+			move.l	a3,d0
+			seq		d0
+			andi.w	#1,d0
+			ext.l	d0
+			move.b	d0,d6
+			beq.s	loc_12AD40
+			clr.b	d4
+loc_12AD40
+			move.l	a4,d0
+			beq.s	loc_12AD48
+			tst.l	(a4)
+			bne.s	loc_12AD52
+loc_12AD48
+			move.w	#$FF34,$12(a6)
+			bra.w	loc_12AF1E
+loc_12AD52
+			movea.l	(a4),a0
+			moveq	#1,d0
+			cmp.w	(a0),d0
+			beq.s	loc_12AD6A
+			moveq	#2,d0
+			cmp.w	(a0),d0
+			beq.s	loc_12AD6A
+			move.w	#$FF32,$12(a6)
+			bra.w	loc_12AF1E
+loc_12AD6A
+			movea.l	a4,a0
+			_HGetState
+			move.b	d0,d5
+			movea.l	a4,a0
+			_HLock
+			tst.b	d6
+			beq.s	loc_12ADA2
+			moveq	#0,d0
+			move.l	d0,-$C(a6)
+			subq.l	#2,sp
+			pea		-$C(a6)
+			moveq	#0,d0
+			move.w	d0,-(sp)
+			moveq	#0,d1
+			move.l	d1,-(sp)
+			move.l	d1,-(sp)
+			_SndNewChannel
+			move.w	(sp)+,d7
+			beq.s	loc_12ADC2
+			movea.l	a4,a0
+			move.b	d5,d0
+			_HSetState
+			move.w	d7,$12(a6)
+			bra.w	loc_12AF1E
+loc_12ADA2
+			move.l	a3,-(sp)
+			jsr		_R261C
+			tst.b	d0
+			addq.w	#4,sp
+			beq.s	loc_12ADBE
+			movea.l	a4,a0
+			move.b	d5,d0
+			_HSetState
+			move.w	#$FF33,$12(a6)
+			bra.w	loc_12AF1E
+loc_12ADBE
+			move.l	a3,-$C(a6)
+loc_12ADC2
+			movea.l	(a4),a0
+			moveq	#1,d0
+			cmp.w	(a0),d0
+			bne.w	loc_12AE66
+			tst.w	2(a0)
+			bne.s	loc_12AE38
+			movea.l	-$C(a6),a0
+			tst.l	4(a0)
+			bne.s	loc_12AE38
+			subq.l	#2,sp
+			move.l	-$C(a6),-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			moveq	#1,d1
+			move.w	d1,-(sp)
+			move.l	d0,-(sp)
+			_SndAddModifier
+			move.w	(sp)+,d7
+			beq.s	loc_12AE38
+			tst.b	d6
+			beq.s	loc_12AE00
+			move.l	-$C(a6),-(sp)
+			jsr		_R25AA
+			addq.w	#4,sp
+loc_12AE00
+			jsr		_R2568
+			tst.w	d0
+			beq.s	loc_12AE2A
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.w	4(a0),d0
+			ext.l	d0
+			move.l	d0,-(sp)
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.l	6(a0),-(sp)
+			jsr		_R2574
+			addq.w	#8,sp
+loc_12AE2A
+			movea.l	a4,a0
+			move.b	d5,d0
+			_HSetState
+			move.w	d7,$12(a6)
+			bra.w	loc_12AF1E
+loc_12AE38
+			move.l	a4,-(sp)
+			move.l	-$C(a6),-(sp)
+			jsr		_R25B0
+			move.w	d0,d7
+			addq.w	#8,sp
+			beq.w	loc_12AED8
+			tst.b	d6
+			beq.s	loc_12AE58
+			move.l	-$C(a6),-(sp)
+			jsr		_R25AA
+			addq.w	#4,sp
+loc_12AE58
+			movea.l	a4,a0
+			move.b	d5,d0
+			_HSetState
+			move.w	d7,$12(a6)
+			bra.w	loc_12AF1E
+loc_12AE66
+			subq.l	#2,sp
+			move.l	-$C(a6),-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			moveq	#5,d1
+			move.w	d1,-(sp)
+			move.l	d0,-(sp)
+			_SndAddModifier
+			move.w	(sp)+,d7
+			beq.s	loc_12AE98
+			tst.b	d6
+			beq.s	loc_12AE8A
+			move.l	-$C(a6),-(sp)
+			jsr		_R25AA
+			addq.w	#4,sp
+loc_12AE8A
+			movea.l	a4,a0
+			move.b	d5,d0
+			_HSetState
+			move.w	d7,$12(a6)
+			bra.w	loc_12AF1E
+loc_12AE98
+			move.w	#$51,-8(a6)
+			clr.w	-6(a6)
+			movea.l	(a4),a3
+			addq.w	#4,a3
+			move.l	a3,d0
+			addq.l	#2,d0
+			move.w	(a3),d1
+			ext.l	d1
+			asl.l	#3,d1
+			add.l	d0,d1
+			move.l	d1,-4(a6)
+			subq.l	#2,sp
+			move.l	-$C(a6),-(sp)
+			pea		-8(a6)
+			moveq	#0,d0
+			move.b	d0,-(sp)
+			_SndDoCommand
+			move.w	(sp)+,d7
+			beq.s	loc_12AED8
+			tst.b	d6
+			beq.s	loc_12AED8
+			move.l	-$C(a6),-(sp)
+			jsr		_R25AA
+			addq.w	#4,sp
+loc_12AED8
+			tst.b	d4
+			bne.s	loc_12AF1A
+			tst.b	d6
+			beq.s	loc_12AEF0
+			subq.l	#2,sp
+			move.l	-$C(a6),-(sp)
+			moveq	#0,d0
+			move.b	d0,-(sp)
+			_SndDisposeChannel
+			move.w	(sp)+,d7
+			bra.s	loc_12AF14
+loc_12AEF0
+			move.w	#3,-8(a6)
+			subq.l	#2,sp
+			move.l	-$C(a6),-(sp)
+			pea		-8(a6)
+			moveq	#0,d0
+			move.b	d0,-(sp)
+			_SndDoCommand
+			addq.w	#2,sp
+loc_12AF08
+			movea.l	-$C(a6),a0
+			moveq	#2,d0
+			and.w	$1C(a0),d0
+			beq.s	loc_12AF08
+loc_12AF14
+			movea.l	a4,a0
+			move.b	d5,d0
+			_HSetState
+loc_12AF1A
+			move.w	d7,$12(a6)
+loc_12AF1E
+			movem.l	-$24(a6),d4-d7/a3-a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			lea		$A(sp),sp
+			jmp		(a0)
+
+
+__SNDCONTROL	PatchProc	_SndControl,(Plus,SE,II,Portable,IIci,notAUX)
+			Import	_R2568
+			Import	_R2586
+
+			link	a6,#-4
+			movem.l	d5-d7/a3-a4,-(sp)
+			movea.l	8(a6),a3
+			move.w	$C(a6),d7
+			beq.w	loc_12AFEC
+			move.w	d7,d6
+			cmpi.w	#$800,d7
+			bge.s	loc_12AF74
+			jsr		_R2568
+			tst.w	d0
+			beq.s	loc_12AF70
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			moveq	#0,d0
+			move.b	$2E(a0),d0
+			tst.l	d0
+			beq.s	loc_12AF6A
+			cmpi.w	#5,d7
+			bne.s	loc_12AF70
+loc_12AF6A
+			addi.w	#$800,d6
+			bra.s	loc_12AF74
+loc_12AF70
+			addi.w	#$1000,d6
+loc_12AF74
+			moveq	#0,d5
+			move.b	$A5E,d5
+			moveq	#1,d0
+			move.b	d0,-(sp)
+			_SetResLoad
+			subq.l	#4,sp
+			move.l	#'snth',-(sp)
+			move.w	d6,-(sp)
+			_GetResource
+			movea.l	(sp)+,a4
+			move.l	a4,d0
+			bne.s	loc_12AFC0
+			subq.l	#4,sp
+			move.l	#'snth',-(sp)
+			move.w	d7,-(sp)
+			_GetResource
+			movea.l	(sp)+,a4
+			move.l	a4,d0
+			bne.s	loc_12AFC0
+			subq.l	#2,sp
+			_ResError
+			move.w	(sp)+,d7
+			beq.s	loc_12AFB0
+			move.w	d7,d0
+			bra.s	loc_12AFB4
+loc_12AFB0
+			move.w	#$FF34,d0
+loc_12AFB4
+			move.w	d0,d7
+			move.b	d5,-(sp)
+			_SetResLoad
+			move.w	d7,$E(a6)
+			bra.s	loc_12AFFC
+loc_12AFC0
+			move.b	d5,-(sp)
+			_SetResLoad
+			movea.l	a4,a0
+			_HGetState
+			move.b	d0,d5
+			movea.l	a4,a0
+			_HLock
+			move.l	(a4),-4(a6)
+			subq.l	#2,sp
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			move.l	a3,-(sp)
+			move.l	d0,-(sp)
+			movea.l	-4(a6),a0
+			jsr		(a0)
+			movea.l	a4,a0
+			move.b	d5,d0
+			_HSetState
+			addq.w	#2,sp
+			bra.s	loc_12AFF8
+loc_12AFEC
+			move.l	a3,-(sp)
+			moveq	#0,d0
+			move.l	d0,-(sp)
+			jsr		_R2586
+			addq.w	#8,sp
+loc_12AFF8
+			clr.w	$E(a6)
+loc_12AFFC
+			movem.l	-$18(a6),d5-d7/a3-a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			addq.w	#6,sp
+			jmp		(a0)
+
+
+__SNDADDMODIFIER	PatchProc	_SndAddModifier,(Plus,SE,II,Portable,IIci,notAUX)
+			Import	_R255C
+			Import	_R2568
+			Import	_R258C_OTHERNAME
+			Import	_R25A4
+			Import	_R25B6
+			Import	_R25BC
+			Import	NGETTRAPADDRESS
+
+			link	a6,#-$C
+			movem.l	d3-d7/a3-a4,-(sp)
+			move.l	8(a6),d5
+			move.w	$C(a6),d7
+			tst.l	$12(a6)
+			bne.s	loc_12B02A
+			move.w	#$FF33,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B02A
+			tst.l	$E(a6)
+			bne.w	loc_12B146
+			tst.w	d7
+			bne.s	loc_12B03E
+			clr.w	$16(a6)
+			bra.w	loc_12B3AE
+loc_12B03E
+			tst.b	$27E
+			beq.s	loc_12B0BC
+			tst.b	$27E
+			bge.s	loc_12B054
+			move.w	#$FF37,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B054
+			cmpi.w	#1,d7
+			bne.s	loc_12B064
+			move.w	#$FF37,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B064
+			cmpi.w	#5,d7
+			bne.s	loc_12B07C
+			jsr		_R2568
+			tst.w	d0
+			bne.s	loc_12B07C
+			move.w	#$FF37,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B07C
+			cmpi.w	#3,d7
+			beq.s	loc_12B088
+			cmpi.w	#5,d7
+			bne.s	loc_12B09C
+loc_12B088
+			move.b	$27E,d0
+			ext.w	d0
+			cmp.w	d0,d7
+			beq.s	loc_12B09C
+			move.w	#$FF37,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B09C
+			cmpi.w	#3,d7
+			bne.s	loc_12B0BC
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			moveq	#4,d0
+			cmp.w	4(a0),d0
+			bge.s	loc_12B0BC
+			move.w	#$FF37,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B0BC
+			move.w	d7,d6
+			cmpi.w	#$800,d7
+			bge.s	loc_12B0EE
+			jsr		_R2568
+			tst.w	d0
+			beq.s	loc_12B0EA
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			moveq	#0,d0
+			move.b	$2E(a0),d0
+			tst.l	d0
+			beq.s	loc_12B0E4
+			cmpi.w	#5,d7
+			bne.s	loc_12B0EA
+loc_12B0E4
+			addi.w	#$800,d6
+			bra.s	loc_12B0EE
+loc_12B0EA
+			addi.w	#$1000,d6
+loc_12B0EE
+			moveq	#0,d4
+			move.b	$A5E,d4
+			moveq	#1,d0
+			move.b	d0,-(sp)
+			_SetResLoad
+			subq.l	#4,sp
+			move.l	#'snth',-(sp)
+			move.w	d6,-(sp)
+			_GetResource
+			movea.l	(sp)+,a3
+			move.l	a3,d0
+			bne.s	loc_12B142
+			cmpi.w	#$800,d7
+			bge.s	loc_12B120
+			subq.l	#4,sp
+			move.l	#'snth',-(sp)
+			move.w	d7,-(sp)
+			_GetResource
+			movea.l	(sp)+,a3
+loc_12B120
+			move.l	a3,d0
+			bne.s	loc_12B142
+			subq.l	#2,sp
+			_ResError
+			move.w	(sp)+,d6
+			beq.s	loc_12B130
+			move.w	d6,d0
+			bra.s	loc_12B134
+loc_12B130
+			move.w	#$FF34,d0
+loc_12B134
+			move.w	d0,d6
+			move.b	d4,-(sp)
+			_SetResLoad
+			move.w	d6,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B142
+			move.b	d4,-(sp)
+			_SetResLoad
+loc_12B146
+			movea.l	$12(a6),a0
+			movea.l	4(a0),a4
+			bra.s	loc_12B170
+loc_12B150
+			move.l	4(a4),d0
+			_StripAddress
+			move.l	d0,-$C(a6)
+			move.l	(a3),d0
+			_StripAddress
+			move.l	-$C(a6),d1
+			cmp.l	d1,d0
+			bne.s	loc_12B16E
+			clr.w	$16(a6)
+			bra.w	loc_12B3AE
+loc_12B16E
+			movea.l	(a4),a4
+loc_12B170
+			move.l	a4,d0
+			bne.s	loc_12B150
+			tst.l	$E(a6)
+			bne.s	loc_12B17E
+			movea.l	a3,a0
+			_HLock
+loc_12B17E
+			move.l	#$84,d0
+			_NewPtrSysClear
+			movea.l	a0,a4
+			move.l	a4,d0
+			bne.s	loc_12B1AE
+			move.w	$220,d6
+			tst.l	$E(a6)
+			bne.s	loc_12B1A6
+			move.l	(a3),-(sp)
+			jsr		_R25A4
+			tst.l	d0
+			addq.w	#4,sp
+			bne.s	loc_12B1A6
+			movea.l	a3,a0
+			_HUnlock
+loc_12B1A6
+			move.w	d6,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B1AE
+			moveq	#$1E,d0
+			_NewPtrSysClear
+			move.l	a0,$3E(a4)
+			move.l	a0,d0
+			bne.s	loc_12B1DC
+			move.w	$220,d6
+			tst.l	$E(a6)
+			bne.s	loc_12B1D4
+			move.l	(a3),-(sp)
+			jsr		_R25A4
+			tst.l	d0
+			addq.w	#4,sp
+			bne.s	loc_12B1D4
+			movea.l	a3,a0
+			_HUnlock
+loc_12B1D4
+			move.w	d6,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B1DC
+			lea		_R25B6,a0
+			movea.l	$3E(a4),a1
+			move.l	a0,6(a1)
+			movea.l	$3E(a4),a0
+			move.l	$12(a6),$16(a0)
+			movea.l	$3E(a4),a0
+			move.l	a4,$1A(a0)
+			moveq	#$1E,d0
+			_NewPtrSysClear
+			move.l	a0,$42(a4)
+			move.l	a0,d0
+			bne.s	loc_12B232
+			move.w	$220,d6
+			tst.l	$E(a6)
+			bne.s	loc_12B220
+			move.l	(a3),-(sp)
+			jsr		_R25A4
+			tst.l	d0
+			addq.w	#4,sp
+			bne.s	loc_12B220
+			movea.l	a3,a0
+			_HUnlock
+loc_12B220
+			movea.l	$3E(a4),a0
+			_DisposePtr
+			movea.l	a4,a0
+			_DisposePtr
+			move.w	d6,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B232
+			lea		_R25BC,a0
+			movea.l	$42(a4),a1
+			move.l	a0,6(a1)
+			movea.l	$42(a4),a0
+			move.l	$12(a6),$16(a0)
+			tst.l	$E(a6)
+			bne.s	loc_12B258
+			move.l	(a3),4(a4)
+			move.l	a3,$16(a4)
+			bra.s	loc_12B25E
+loc_12B258
+			move.l	$E(a6),4(a4)
+loc_12B25E
+			cmpi.w	#5,d7
+			bne.w	loc_12B300
+			jsr		_R2568
+			tst.w	d0
+			beq.w	loc_12B300
+			move.w	#$1A,-8(a6)
+			move.l	d5,-4(a6)
+			subq.l	#2,sp
+			moveq	#5,d0
+			move.w	d0,-(sp)
+			pea		-8(a6)
+			_SndControl
+			move.w	(sp)+,d6
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.w	-6(a6),d0
+			cmp.w	$16(a0),d0
+			ble.s	loc_12B2DA
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			moveq	#1,d0
+			cmp.w	4(a0),d0
+			bge.s	loc_12B2DA
+			tst.l	$E(a6)
+			bne.s	loc_12B2C0
+			move.l	(a3),-(sp)
+			jsr		_R25A4
+			tst.l	d0
+			addq.w	#4,sp
+			bne.s	loc_12B2C0
+			movea.l	a3,a0
+			_HUnlock
+loc_12B2C0
+			movea.l	$3E(a4),a0
+			_DisposePtr
+			movea.l	$42(a4),a0
+			_DisposePtr
+			movea.l	a4,a0
+			_DisposePtr
+			move.w	#$FF37,$16(a6)
+			bra.w	loc_12B3AE
+loc_12B2DA
+			move.w	#$1B,-8(a6)
+			move.l	d5,-4(a6)
+			subq.l	#2,sp
+			moveq	#5,d0
+			move.w	d0,-(sp)
+			pea		-8(a6)
+			_SndControl
+			move.w	(sp)+,d6
+			move.w	-6(a6),d0
+			ext.l	d0
+			move.l	d0,$68(a4)
+			move.l	d5,$64(a4)
+loc_12B300
+			move.w	#1,-8(a6)
+			move.l	d5,-4(a6)
+			move.l	a4,-(sp)
+			pea		-8(a6)
+			move.l	$12(a6),-(sp)
+			jsr		_R258C_OTHERNAME
+			moveq	#$FFFFFFFF,d0
+			cmp.l	-4(a6),d0
+			lea		$C(sp),sp
+			bne.s	loc_12B352
+			tst.l	$E(a6)
+			bne.s	loc_12B33A
+			move.l	(a3),-(sp)
+			jsr		_R25A4
+			tst.l	d0
+			addq.w	#4,sp
+			bne.s	loc_12B33A
+			movea.l	a3,a0
+			_HUnlock
+loc_12B33A
+			movea.l	$3E(a4),a0
+			_DisposePtr
+			movea.l	$42(a4),a0
+			_DisposePtr
+			movea.l	a4,a0
+			_DisposePtr
+			move.w	#$FF94,$16(a6)
+			bra.s	loc_12B3AE
+loc_12B352
+			movea.l	$3E(a4),a0
+			_InsXTime
+			movea.l	$42(a4),a0
+			_InsXTime
+			subq.l	#4,sp
+			move.w	#$A89F,-(sp)
+			moveq	#1,d0
+			move.b	d0,-(sp)
+			jsr		NGETTRAPADDRESS
+			subq.l	#4,sp
+			move.w	#$A88F,-(sp)
+			moveq	#1,d0
+			move.b	d0,-(sp)
+			jsr		NGETTRAPADDRESS
+			move.l	(sp)+,d0
+			cmp.l	(sp)+,d0
+			beq.s	loc_12B38E
+			subq.l	#2,sp
+			pea		$7C(a4)
+			move.w	#$37,-(sp)
+			_OSDispatch
+			addq.w	#2,sp
+loc_12B38E
+			jsr		_R255C
+			move.w	d0,d5
+			movea.l	$12(a6),a0
+			move.l	4(a0),(a4)
+			movea.l	$12(a6),a0
+			move.l	a4,4(a0)
+			ext.l	d5
+			move.l	d5,d0
+			move	d0,sr
+			clr.w	$16(a6)
+loc_12B3AE
+			movem.l	-$28(a6),d3-d7/a3-a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			lea		$E(sp),sp
+			jmp		(a0)
+
+
+__SNDSOUNDMANAGERVERSION	Proc	Export
+			link	a6,#0
+			move.l	#$2018000,8(a6)
+			unlk	a6
+			rts
+
+
+Version	Proc	Export
+			link	a6,#0
+			move.l	#$1018000,8(a6)
+			unlk	a6
+			rts
+
+
+__SNDCHANNELSTATUS	Proc	Export
+			Import	_R261C
+			Import	_R2634
+			Import	_R263A
+			Import	_UTOX
+
+			link	a6,#-$24
+			movem.l	a3-a4,-(sp)
+			movea.l	8(a6),a3
+			moveq	#$18,d0
+			cmp.w	$C(a6),d0
+			beq.s	loc_12B3FC
+			move.w	#$FFCE,$12(a6)
+			bra.w	loc_12B566
+loc_12B3FC
+			move.l	$E(a6),-(sp)
+			jsr		_R261C
+			tst.b	d0
+			addq.w	#4,sp
+			beq.s	loc_12B414
+			move.w	#$FF33,$12(a6)
+			bra.w	loc_12B566
+loc_12B414
+			move.l	$E(a6),-$1A(a6)
+			bne.s	loc_12B426
+			move.w	#$FF33,$12(a6)
+			bra.w	loc_12B566
+loc_12B426
+			movea.l	-$1A(a6),a0
+			movea.l	4(a0),a4
+			move.l	a4,d0
+			bne.s	loc_12B43E
+			move.w	#$FF33,$12(a6)
+			bra.w	loc_12B566
+loc_12B43C
+			movea.l	(a4),a4
+loc_12B43E
+			tst.l	(a4)
+			bne.s	loc_12B43C
+			moveq	#5,d0
+			cmp.b	$27E,d0
+			beq.s	loc_12B46C
+			move.l	#$FF,d0
+			and.l	8(a4),d0
+			move.b	d0,$C(a3)
+			clr.w	$E(a3)
+			moveq	#0,d0
+			move.l	d0,(a3)
+			move.l	d0,4(a3)
+			move.l	d0,8(a3)
+			bra.w	loc_12B54A
+loc_12B46C
+			move.l	8(a4),-8(a6)
+			beq.s	loc_12B48C
+			movea.l	-8(a6),a0
+			move.w	$11A(a0),d0
+			ext.l	d0
+			move.l	d0,-(sp)
+			jsr		_R2634
+			move.l	d0,$10(a3)
+			addq.w	#4,sp
+			bra.s	loc_12B492
+loc_12B48C
+			move.l	$64(a4),$10(a3)
+loc_12B492
+			movea.l	-8(a6),a0
+			move.l	(a0),-4(a6)
+			move.l	$68(a4),$14(a3)
+			move.l	-$1A(a6),-(sp)
+			jsr		_R263A
+			move.l	d0,-$16(a6)
+			movea.l	d0,a0
+			tst.b	(a0)
+			addq.w	#4,sp
+			bne.s	loc_12B4DA
+			movea.l	-4(a6),a0
+			tst.w	$1E(a0)
+			sne		d0
+			andi.w	#1,d0
+			ext.l	d0
+			move.b	d0,$C(a3)
+			clr.w	$E(a3)
+			moveq	#0,d0
+			move.l	d0,(a3)
+			move.l	d0,4(a3)
+			move.l	d0,8(a3)
+			bra.s	loc_12B54A
+loc_12B4DA
+			movea.l	-$16(a6),a0
+			movea.l	8(a0),a4
+			movea.l	-4(a6),a0
+			tst.w	$1E(a0)
+			sne		d0
+			andi.w	#1,d0
+			ext.l	d0
+			move.b	d0,$C(a3)
+			movea.l	-$16(a6),a0
+			move.b	3(a0),$E(a3)
+			clr.b	$F(a3)
+			move.l	$5E(a4),(a3)
+			move.l	$62(a4),4(a3)
+			pea		-$24(a6)
+			move.l	$72(a4),-(sp)
+			jsr		_UTOX
+			pea		$4C(a4)
+			pea		-$24(a6)
+			move.w	#6,-(sp)
+			_Pack4
+			lea		-$24(a6),a0
+			lea		-$12(a6),a1
+			move.l	(a0)+,(a1)+
+			move.l	(a0)+,(a1)+
+			move.w	(a0)+,(a1)+
+			subq.l	#4,sp
+			pea		-$12(a6)
+			_X2Fix
+			move.l	$62(a4),d0
+			sub.l	(sp)+,d0
+			move.l	d0,8(a3)
+			addq.w	#8,sp
+loc_12B54A
+			movea.l	$E(a6),a0
+			moveq	#$20,d0
+			and.w	$1C(a0),d0
+			beq.s	loc_12B55E
+			move.b	#1,$D(a3)
+			bra.s	loc_12B562
+loc_12B55E
+			clr.b	$D(a3)
+loc_12B562
+			clr.w	$12(a6)
+loc_12B566
+			movem.l	-$2C(a6),a3-a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			lea		$A(sp),sp
+			jmp		(a0)
+
+
+__SNDMANAGERSTATUS	Proc	Export
+			link	a6,#-4
+			movem.l	d3/d6-d7/a3-a4,-(sp)
+			moveq	#6,d0
+			cmp.w	$C(a6),d0
+			beq.s	loc_12B590
+			move.w	#$FFCE,$E(a6)
+			bra.w	loc_12B654
+loc_12B590
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	8(a6),a1
+			move.w	4(a0),2(a1)
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	8(a6),a1
+			move.w	$16(a0),(a1)
+			movea.l	8(a6),a0
+			clr.w	4(a0)
+			clr.w	d6
+			clr.w	d7
+			moveq	#5,d0
+			cmp.b	$27E,d0
+			bne.s	loc_12B622
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	(a0),a3
+			bra.s	loc_12B604
+loc_12B5D2
+			movea.l	4(a3),a4
+			move.l	a4,d0
+			beq.s	loc_12B602
+			bra.s	loc_12B5DE
+loc_12B5DC
+			movea.l	(a4),a4
+loc_12B5DE
+			tst.l	(a4)
+			bne.s	loc_12B5DC
+			move.l	8(a4),-4(a6)
+			beq.s	loc_12B602
+			subq.l	#2,sp
+			movea.l	-4(a6),a0
+			move.w	$11A(a0),-(sp)
+			move.l	#$240008,d0
+			_SoundDispatch
+			add.w	(sp)+,d7
+			move.w	d6,d0
+			addq.w	#1,d6
+loc_12B602
+			movea.l	(a3),a3
+loc_12B604
+			move.l	a3,d0
+			bne.s	loc_12B5D2
+			subq.l	#2,sp
+			move.w	d6,-(sp)
+			move.l	#$280008,d0
+			_SoundDispatch
+			move.w	(sp)+,d0
+			add.w	d7,d0
+			movea.l	8(a6),a0
+			move.w	d0,4(a0)
+			bra.s	loc_12B650
+loc_12B622
+			moveq	#1,d0
+			cmp.b	$27E,d0
+			bne.s	loc_12B636
+			movea.l	8(a6),a0
+			move.w	#$64,4(a0)
+			bra.s	loc_12B650
+loc_12B636
+			moveq	#3,d0
+			cmp.b	$27E,d0
+			bne.s	loc_12B650
+			movea.l	8(a6),a0
+			moveq	#$19,d0
+			muls.w	2(a0),d0
+			movea.l	8(a6),a0
+			move.w	d0,4(a0)
+loc_12B650
+			clr.w	$E(a6)
+loc_12B654
+			movem.l	-$18(a6),d3/d6-d7/a3-a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			addq.w	#6,sp
+			jmp		(a0)
+
+
+__SNDGETSYSBEEPSTATE	Proc	Export
+			link	a6,#0
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	8(a6),a1
+			move.w	$18(a0),(a1)
+			unlk	a6
+			move.l	(sp)+,(sp)
+			rts
+
+
+__SNDSETSYSBEEPSTATE	Proc	Export
+			link	a6,#0
+			move.l	d7,-(sp)
+			move.w	8(a6),d7
+			blt.s	loc_12B68E
+			cmpi.w	#1,d7
+			ble.s	loc_12B696
+loc_12B68E
+			move.w	#$FFCE,$A(a6)
+			bra.s	loc_12B6A6
+loc_12B696
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.w	d7,$18(a0)
+			clr.w	$A(a6)
+loc_12B6A6
+			move.l	-4(a6),d7
+			unlk	a6
+			movea.l	(sp)+,a0
+			addq.w	#2,sp
+			jmp		(a0)
+
+
+_R261C	Proc	Export
+			link	a6,#0
+			movem.l	d3/a3-a4,-(sp)
+			movea.l	8(a6),a3
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	(a0),a4
+			moveq	#0,d3
+			bra.s	loc_12B6D6
+loc_12B6CC
+			cmpa.l	a3,a4
+			bne.s	loc_12B6D4
+			moveq	#0,d0
+			bra.s	loc_12B6DC
+loc_12B6D4
+			movea.l	(a4),a4
+loc_12B6D6
+			cmp.l	a4,d3
+			bne.s	loc_12B6CC
+			moveq	#1,d0
+loc_12B6DC
+			movem.l	-$C(a6),d3/a3-a4
+			unlk	a6
+			rts
+
+
+__SNDPLAYDOUBLEBUFFER	Proc	Export
+			Import	_R261C
+
+			link	a6,#-8
+			movem.l	d7/a4,-(sp)
+			movea.l	$C(a6),a4
+			move.l	a4,-(sp)
+			jsr		_R261C
+			tst.b	d0
+			addq.w	#4,sp
+			beq.s	loc_12B706
+			move.w	#$FF33,$10(a6)
+			bra.s	loc_12B72A
+loc_12B706
+			move.w	#$54,-8(a6)
+			clr.w	-6(a6)
+			move.l	8(a6),-4(a6)
+			subq.l	#2,sp
+			move.l	a4,-(sp)
+			pea		-8(a6)
+			moveq	#0,d0
+			move.b	d0,-(sp)
+			_SndDoCommand
+			move.w	(sp)+,d7
+			move.w	d7,$10(a6)
+loc_12B72A
+			movem.l	-$10(a6),d7/a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			addq.w	#8,sp
+			jmp		(a0)
+
+
+__SND_NotSure	Proc	Export
+			Import	_R2550
+
+			link	a6,#0
+			movem.l	d7/a3-a4,-(sp)
+			move.w	8(a6),d7
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			tst.l	$E(a0)
+			bne.s	loc_12B794
+			subq.l	#4,sp
+			move.l	#'bst#',-(sp)
+			moveq	#1,d0
+			move.w	d0,-(sp)
+			_GetResource
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.l	(sp)+,$E(a0)
+			bne.s	loc_12B778
+			subq.l	#2,sp
+			_ResError
+			move.w	(sp)+,$A(a6)
+			bra.s	loc_12B7F0
+loc_12B778
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			move.l	$E(a0),-(sp)
+			_DetachResource
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	$E(a0),a0
+			_HLock
+loc_12B794
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	$E(a0),a3
+			movea.l	(a3),a4
+			addq.w	#2,a4
+			bra.s	loc_12B7E6
+loc_12B7A6
+			cmp.w	(a4),d7
+			bne.s	loc_12B7E2
+			moveq	#0,d0
+			move.w	$C(a4),d0
+			moveq	#$64,d1
+			cmp.l	d0,d1
+			bne.s	loc_12B7D2
+			subq.l	#2,sp
+			moveq	#1,d0
+			move.w	d0,-(sp)
+			move.l	#$280008,d0
+			_SoundDispatch
+			move.w	(sp)+,d0
+			ext.l	d0
+			moveq	#$64,d1
+			sub.l	d0,d1
+			move.w	d1,$A(a6)
+			bra.s	loc_12B7F0
+loc_12B7D2
+			pea		$C(a4)
+			jsr		_R2550
+			move.w	d0,$A(a6)
+			addq.w	#4,sp
+			bra.s	loc_12B7F0
+loc_12B7E2
+			lea		$14(a4),a4
+loc_12B7E6
+			tst.l	2(a4)
+			bne.s	loc_12B7A6
+			clr.w	$A(a6)
+loc_12B7F0
+			movem.l	-$C(a6),d7/a3-a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			addq.w	#2,sp
+			jmp		(a0)
+
+
+__SND_NotSure2	Proc	Export
+			link	a6,#0
+			movem.l	d6-d7/a4,-(sp)
+			move.w	8(a6),d7
+			movea.l	$2B6,a0
+			movea.l	$110(a0),a0
+			movea.l	$1A(a0),a4
+			move.l	a4,d0
+			beq.s	loc_12B85C
+			tst.w	d7
+			beq.s	loc_12B85C
+			move.w	(a4),d6
+			cmpi.w	#5,d7
+			bge.s	loc_12B838
+			ext.l	d6
+			ext.l	d7
+			move.l	d6,d0
+			add.l	d7,d0
+			add.l	d0,d0
+			move.w	(a4,d0.l),$A(a6)
+			bra.s	loc_12B860
+loc_12B838
+			ext.l	d6
+			move.l	d6,d0
+			addq.l	#5,d0
+			add.l	d0,d0
+			move.w	d7,d1
+			muls.w	(a4,d0.l),d1
+			ext.l	d6
+			move.l	d6,d0
+			addq.l	#6,d0
+			add.l	d0,d0
+			move.w	(a4,d0.l),d0
+			ext.l	d0
+			add.l	d1,d0
+			move.w	d0,$A(a6)
+			bra.s	loc_12B860
+loc_12B85C
+			clr.w	$A(a6)
+loc_12B860
+			movem.l	-$C(a6),d6-d7/a4
+			unlk	a6
+			movea.l	(sp)+,a0
+			addq.w	#2,sp
+			jmp		(a0)
+
+
+_R2634	Proc	Export
+			link	a6,#0
+			movem.l	d6-d7,-(sp)
+			move.w	$A(a6),d6
+			moveq	#3,d0
+			and.w	d6,d0
+			add.w	d0,d0
+			move.w	jtbl(d0),d0
+jtblbase	equ		*+2
+			jmp		jtblbase(d0)
+jtbl		dc.w	loc_12B890-jtblbase
+			dc.w	loc_12B898-jtblbase
+			dc.w	loc_12B8A0-jtblbase
+			dc.w	loc_12B8A8-jtblbase
+loc_12B890
+			move.l	#$80,d7
+			bra.s	loc_12B8AE
+loc_12B898
+			move.l	#$C0,d7
+			bra.s	loc_12B8AE
+loc_12B8A0
+			move.l	#$82,d7
+			bra.s	loc_12B8AE
+loc_12B8A8
+			move.l	#$83,d7
+loc_12B8AE
+			moveq	#4,d0
+			and.w	d6,d0
+			beq.s	loc_12B8BA
+			ori.l	#4,d7
+loc_12B8BA
+			moveq	#8,d0
+			and.w	d6,d0
+			beq.s	loc_12B8C6
+			ori.l	#8,d7
+loc_12B8C6
+			ext.l	d6
+			move.w	#$FF00,d0
+			and.w	d6,d0
+			moveq	#0,d1
+			move.w	d0,d1
+			or.l	d1,d7
+			move.l	d7,d0
+			movem.l	-8(a6),d6-d7
+			unlk	a6
+			rts
+
+
+_R263A	Proc	Export
+			link	a6,#0
+			movem.l	a3-a4,-(sp)
+			movea.l	8(a6),a0
+			movea.l	4(a0),a4
+			bra.s	loc_12B8F4
+loc_12B8F2
+			movea.l	(a4),a4
+loc_12B8F4
+			tst.l	(a4)
+			bne.s	loc_12B8F2
+			lea		$1A(a4),a3
+			move.l	a3,d0
+			movem.l	-8(a6),a3-a4
+			unlk	a6
+			rts
+
+
+			END
diff --git a/Toolbox/SoundMgr/SoundMgrPatch.a.idump b/Toolbox/SoundMgr/SoundMgrPatch.a.idump
new file mode 100644
--- /dev/null
+++ b/Toolbox/SoundMgr/SoundMgrPatch.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Toolbox/SoundMgr/Tables.3.a b/Toolbox/SoundMgr/Tables.3.a
new file mode 100644
--- /dev/null
+++ b/Toolbox/SoundMgr/Tables.3.a
@@ -0,0 +1,302 @@
+			CASE	OBJ
+
+
+;31:2b9d0
+Table_1	Proc	Export
+			dc.w	$4000,$3D44,$3AA6,$3825,$35BF,$3373,$3140,$2F26
+			dc.w	$2D22,$2B34,$295C,$2797,$25E6,$2448,$22BB,$213F
+			dc.w	$1FD4,$1E78,$1D2A,$1BEB,$1ABA,$1996,$187E,$1772
+			dc.w	$1672,$157C,$1491,$13B0,$12D9,$120B,$1145,$1089
+			dc.w	$0FD4,$0F27,$0E81,$0DE2,$0D4B,$0CB9,$0C2E,$0BA9
+			dc.w	$0B29,$0AAF,$0A3A,$09CB,$095F,$08F9,$0897,$0839
+			dc.w	$07DF,$0789,$0737,$06E8,$069C,$0654,$060F,$05CC
+			dc.w	$058D,$0550,$0516,$04DF,$04A9,$0476,$0446,$0417
+			dc.w	$03EA,$03BF,$0396,$036F,$034A,$0326,$0303,$02E2
+			dc.w	$02C3,$02A5,$0288,$026C,$0252,$0238,$0220,$0209
+			dc.w	$01F2,$01DD,$01C9,$01B5,$01A3,$0191,$0180,$016F
+			dc.w	$0160,$0151,$0142,$0134,$0127,$011B,$010F,$0103
+			dc.w	$00F8,$00ED,$00E3,$00DA,$00D0,$00C7,$00BF,$00B7
+			dc.w	$00AF,$00A7,$00A0,$009A,$0093,$008D,$0087,$0081
+			dc.w	$007B,$0076,$0071,$006C,$0068,$0063,$005F,$005B
+			dc.w	$0057,$0053,$0050,$004C,$0049,$0046,$0043,$0040
+
+
+;31:2bad0
+		Export	Table_2
+Table_2
+			dc.w	$FFEE,$008C,$008C,$FFEE,$0000,$0000,$0000,$0000
+
+
+;31:2bae0
+		Export	Table_3
+Table_3
+			dc.w	$0040,$00D8,$FF27,$FFBF,$0000,$0000,$0000,$0000
+			dc.w	$0043,$00E2,$FF1D,$FFBC,$0000,$0000,$0000,$0000
+			dc.w	$0046,$00EC,$FF13,$FFB9,$0000,$0000,$0000,$0000
+			dc.w	$004A,$00F6,$FF09,$FFB5,$0000,$0000,$0000,$0000
+			dc.w	$004D,$0101,$FEFE,$FFB2,$0000,$0000,$0000,$0000
+			dc.w	$0050,$010C,$FEF3,$FFAF,$0000,$0000,$0000,$0000
+			dc.w	$0054,$0118,$FEE7,$FFAB,$0000,$0000,$0000,$0000
+			dc.w	$0058,$0126,$FED9,$FFA7,$0000,$0000,$0000,$0000
+			dc.w	$005C,$0133,$FECC,$FFA3,$0000,$0000,$0000,$0000
+			dc.w	$0060,$0141,$FEBE,$FF9F,$0000,$0000,$0000,$0000
+			dc.w	$0064,$014E,$FEB1,$FF9B,$0000,$0000,$0000,$0000
+			dc.w	$0068,$015E,$FEA1,$FF97,$0000,$0000,$0000,$0000
+			dc.w	$006D,$016D,$FE92,$FF92,$0000,$0000,$0000,$0000
+			dc.w	$0072,$017E,$FE81,$FF8D,$0000,$0000,$0000,$0000
+			dc.w	$0077,$018F,$FE70,$FF88,$0000,$0000,$0000,$0000
+			dc.w	$007C,$01A0,$FE5F,$FF83,$0000,$0000,$0000,$0000
+			dc.w	$0082,$01B2,$FE4D,$FF7D,$0000,$0000,$0000,$0000
+			dc.w	$0088,$01C6,$FE39,$FF77,$0000,$0000,$0000,$0000
+			dc.w	$008E,$01DB,$FE24,$FF71,$0000,$0000,$0000,$0000
+			dc.w	$0094,$01EF,$FE10,$FF6B,$0000,$0000,$0000,$0000
+			dc.w	$009B,$0207,$FDF8,$FF64,$0000,$0000,$0000,$0000
+			dc.w	$00A2,$021D,$FDE2,$FF5D,$0000,$0000,$0000,$0000
+			dc.w	$00A9,$0234,$FDCB,$FF56,$0000,$0000,$0000,$0000
+			dc.w	$00B0,$024E,$FDB1,$FF4F,$0000,$0000,$0000,$0000
+			dc.w	$00B9,$0269,$FD96,$FF46,$0000,$0000,$0000,$0000
+			dc.w	$00C1,$0284,$FD7B,$FF3E,$0000,$0000,$0000,$0000
+			dc.w	$00C9,$02A1,$FD5E,$FF36,$0000,$0000,$0000,$0000
+			dc.w	$00D2,$02BF,$FD40,$FF2D,$0000,$0000,$0000,$0000
+			dc.w	$00DC,$02DF,$FD20,$FF23,$0000,$0000,$0000,$0000
+			dc.w	$00E6,$02FF,$FD00,$FF19,$0000,$0000,$0000,$0000
+			dc.w	$00F0,$0321,$FCDE,$FF0F,$0000,$0000,$0000,$0000
+			dc.w	$00FB,$0346,$FCB9,$FF04,$0000,$0000,$0000,$0000
+			dc.w	$0106,$036C,$FC93,$FEF9,$0000,$0000,$0000,$0000
+			dc.w	$0112,$0392,$FC6D,$FEED,$0000,$0000,$0000,$0000
+			dc.w	$011E,$03BB,$FC44,$FEE1,$0000,$0000,$0000,$0000
+			dc.w	$012B,$03E5,$FC1A,$FED4,$0000,$0000,$0000,$0000
+			dc.w	$0138,$0411,$FBEE,$FEC7,$0000,$0000,$0000,$0000
+			dc.w	$0146,$0441,$FBBE,$FEB9,$0000,$0000,$0000,$0000
+			dc.w	$0155,$0472,$FB8D,$FEAA,$0000,$0000,$0000,$0000
+			dc.w	$0164,$04A4,$FB5B,$FE9B,$0000,$0000,$0000,$0000
+			dc.w	$0174,$04D9,$FB26,$FE8B,$0000,$0000,$0000,$0000
+			dc.w	$0184,$0511,$FAEE,$FE7B,$0000,$0000,$0000,$0000
+			dc.w	$0196,$054A,$FAB5,$FE69,$0000,$0000,$0000,$0000
+			dc.w	$01A8,$0587,$FA78,$FE57,$0000,$0000,$0000,$0000
+			dc.w	$01BB,$05C6,$FA39,$FE44,$0000,$0000,$0000,$0000
+			dc.w	$01CE,$0608,$F9F7,$FE31,$0000,$0000,$0000,$0000
+			dc.w	$01E3,$064D,$F9B2,$FE1C,$0000,$0000,$0000,$0000
+			dc.w	$01F9,$0694,$F96B,$FE06,$0000,$0000,$0000,$0000
+			dc.w	$020F,$06E0,$F91F,$FDF0,$0000,$0000,$0000,$0000
+			dc.w	$0227,$072E,$F8D1,$FDD8,$0000,$0000,$0000,$0000
+			dc.w	$0240,$0781,$F87E,$FDBF,$0000,$0000,$0000,$0000
+			dc.w	$0259,$07D7,$F828,$FDA6,$0000,$0000,$0000,$0000
+			dc.w	$0274,$0831,$F7CE,$FD8B,$0000,$0000,$0000,$0000
+			dc.w	$0290,$088E,$F771,$FD6F,$0000,$0000,$0000,$0000
+			dc.w	$02AE,$08F0,$F70F,$FD51,$0000,$0000,$0000,$0000
+			dc.w	$02CC,$0955,$F6AA,$FD33,$0000,$0000,$0000,$0000
+			dc.w	$02EC,$09C0,$F63F,$FD13,$0000,$0000,$0000,$0000
+			dc.w	$030D,$0A2F,$F5D0,$FCF2,$0000,$0000,$0000,$0000
+			dc.w	$0330,$0AA4,$F55B,$FCCF,$0000,$0000,$0000,$0000
+			dc.w	$0355,$0B1E,$F4E1,$FCAA,$0000,$0000,$0000,$0000
+			dc.w	$037B,$0B9D,$F462,$FC84,$0000,$0000,$0000,$0000
+			dc.w	$03A2,$0C20,$F3DF,$FC5D,$0000,$0000,$0000,$0000
+			dc.w	$03CC,$0CAB,$F354,$FC33,$0000,$0000,$0000,$0000
+			dc.w	$03F8,$0D3D,$F2C2,$FC07,$0000,$0000,$0000,$0000
+			dc.w	$0425,$0DD3,$F22C,$FBDA,$0000,$0000,$0000,$0000
+			dc.w	$0454,$0E72,$F18D,$FBAB,$0000,$0000,$0000,$0000
+			dc.w	$0486,$0F16,$F0E9,$FB79,$0000,$0000,$0000,$0000
+			dc.w	$04B9,$0FC3,$F03C,$FB46,$0000,$0000,$0000,$0000
+			dc.w	$04F0,$1078,$EF87,$FB0F,$0000,$0000,$0000,$0000
+			dc.w	$0528,$1133,$EECC,$FAD7,$0000,$0000,$0000,$0000
+			dc.w	$0563,$11F7,$EE08,$FA9C,$0000,$0000,$0000,$0000
+			dc.w	$05A1,$12C6,$ED39,$FA5E,$0000,$0000,$0000,$0000
+			dc.w	$05E1,$139B,$EC64,$FA1E,$0000,$0000,$0000,$0000
+			dc.w	$0624,$147C,$EB83,$F9DB,$0000,$0000,$0000,$0000
+			dc.w	$066A,$1565,$EA9A,$F995,$0000,$0000,$0000,$0000
+			dc.w	$06B3,$165A,$E9A5,$F94C,$0000,$0000,$0000,$0000
+			dc.w	$0700,$175A,$E8A5,$F8FF,$0000,$0000,$0000,$0000
+			dc.w	$0750,$1865,$E79A,$F8AF,$0000,$0000,$0000,$0000
+			dc.w	$07A3,$197A,$E685,$F85C,$0000,$0000,$0000,$0000
+			dc.w	$07FB,$1A9D,$E562,$F804,$0000,$0000,$0000,$0000
+			dc.w	$0856,$1BCE,$E431,$F7A9,$0000,$0000,$0000,$0000
+			dc.w	$08B5,$1D0C,$E2F3,$F74A,$0000,$0000,$0000,$0000
+			dc.w	$0919,$1E57,$E1A8,$F6E6,$0000,$0000,$0000,$0000
+			dc.w	$0980,$1FB2,$E04D,$F67F,$0000,$0000,$0000,$0000
+			dc.w	$09ED,$211D,$DEE2,$F612,$0000,$0000,$0000,$0000
+			dc.w	$0A5F,$2296,$DD69,$F5A0,$0000,$0000,$0000,$0000
+			dc.w	$0AD5,$2422,$DBDD,$F52A,$0000,$0000,$0000,$0000
+			dc.w	$0B51,$25BF,$DA40,$F4AE,$0000,$0000,$0000,$0000
+			dc.w	$0BD2,$276E,$D891,$F42D,$0000,$0000,$0000,$0000
+			dc.w	$0C5A,$2932,$D6CD,$F3A5,$0000,$0000,$0000,$0000
+			dc.w	$0CE7,$2B08,$D4F7,$F318,$0000,$0000,$0000,$0000
+			dc.w	$0D7A,$2CF4,$D30B,$F285,$0000,$0000,$0000,$0000
+			dc.w	$0E14,$2EF4,$D10B,$F1EB,$0000,$0000,$0000,$0000
+			dc.w	$0EB5,$310C,$CEF3,$F14A,$0000,$0000,$0000,$0000
+			dc.w	$0F5D,$333E,$CCC1,$F0A2,$0000,$0000,$0000,$0000
+			dc.w	$100C,$3587,$CA78,$EFF3,$0000,$0000,$0000,$0000
+			dc.w	$10C4,$37EB,$C814,$EF3B,$0000,$0000,$0000,$0000
+			dc.w	$1183,$3A69,$C596,$EE7C,$0000,$0000,$0000,$0000
+			dc.w	$124B,$3D05,$C2FA,$EDB4,$0000,$0000,$0000,$0000
+			dc.w	$131C,$3FBE,$C041,$ECE3,$0000,$0000,$0000,$0000
+			dc.w	$13F7,$4296,$BD69,$EC08,$0000,$0000,$0000,$0000
+			dc.w	$14DB,$458F,$BA70,$EB24,$0000,$0000,$0000,$0000
+			dc.w	$15C9,$48AA,$B755,$EA36,$0000,$0000,$0000,$0000
+			dc.w	$16C2,$4BE9,$B416,$E93D,$0000,$0000,$0000,$0000
+			dc.w	$17C6,$4F4C,$B0B3,$E839,$0000,$0000,$0000,$0000
+			dc.w	$18D6,$52D5,$AD2A,$E729,$0000,$0000,$0000,$0000
+			dc.w	$19F2,$5688,$A977,$E60D,$0000,$0000,$0000,$0000
+			dc.w	$1B1A,$5A65,$A59A,$E4E5,$0000,$0000,$0000,$0000
+			dc.w	$1C50,$5E6D,$A192,$E3AF,$0000,$0000,$0000,$0000
+			dc.w	$1D93,$62A4,$9D5B,$E26C,$0000,$0000,$0000,$0000
+			dc.w	$1EE5,$670C,$98F3,$E11A,$0000,$0000,$0000,$0000
+			dc.w	$2046,$6BA5,$945A,$DFB9,$0000,$0000,$0000,$0000
+			dc.w	$21B7,$7072,$8F8D,$DE48,$0000,$0000,$0000,$0000
+			dc.w	$2338,$7578,$8A87,$DCC7,$0000,$0000,$0000,$0000
+			dc.w	$24CB,$7AB5,$854A,$DB34,$0000,$0000,$0000,$0000
+			dc.w	$266F,$7FFF,$8000,$D990,$0000,$0000,$0000,$0000
+			dc.w	$2826,$7FFF,$8000,$D7D9,$0000,$0000,$0000,$0000
+			dc.w	$29F1,$7FFF,$8000,$D60E,$0000,$0000,$0000,$0000
+			dc.w	$2BD0,$7FFF,$8000,$D42F,$0000,$0000,$0000,$0000
+			dc.w	$2DC5,$7FFF,$8000,$D23A,$0000,$0000,$0000,$0000
+			dc.w	$2FD0,$7FFF,$8000,$D02F,$0000,$0000,$0000,$0000
+			dc.w	$31F2,$7FFF,$8000,$CE0D,$0000,$0000,$0000,$0000
+			dc.w	$342C,$7FFF,$8000,$CBD3,$0000,$0000,$0000,$0000
+			dc.w	$3681,$7FFF,$8000,$C97E,$0000,$0000,$0000,$0000
+			dc.w	$38F0,$7FFF,$8000,$C70F,$0000,$0000,$0000,$0000
+			dc.w	$3B7A,$7FFF,$8000,$C485,$0000,$0000,$0000,$0000
+			dc.w	$3E22,$7FFF,$8000,$C1DD,$0000,$0000,$0000,$0000
+			dc.w	$40E7,$7FFF,$8000,$BF18,$0000,$0000,$0000,$0000
+
+
+;31:2c2e0
+		Export	Table_4
+Table_4
+			dc.w	$FFF3,$0008,$004C,$00DE,$00DE,$004C,$0008,$FFF3
+
+
+;31:2c2f0
+		Export	Table_5
+Table_5
+			dc.w	$0025,$0074,$00CE,$014A,$FEB5,$FF31,$FF8B,$FFDA
+			dc.w	$0027,$0079,$00D8,$015A,$FEA5,$FF27,$FF86,$FFD8
+			dc.w	$0029,$007F,$00E1,$0169,$FE96,$FF1E,$FF80,$FFD6
+			dc.w	$002A,$0084,$00EB,$0179,$FE86,$FF14,$FF7B,$FFD5
+			dc.w	$002C,$0089,$00F5,$0188,$FE77,$FF0A,$FF76,$FFD3
+			dc.w	$002E,$0090,$0100,$019A,$FE65,$FEFF,$FF6F,$FFD1
+			dc.w	$0030,$0096,$010B,$01AC,$FE53,$FEF4,$FF69,$FFCF
+			dc.w	$0033,$009D,$0118,$01C1,$FE3E,$FEE7,$FF62,$FFCC
+			dc.w	$0035,$00A5,$0125,$01D6,$FE29,$FEDA,$FF5A,$FFCA
+			dc.w	$0037,$00AC,$0132,$01EA,$FE15,$FECD,$FF53,$FFC8
+			dc.w	$003A,$00B3,$013F,$01FF,$FE00,$FEC0,$FF4C,$FFC5
+			dc.w	$003C,$00BB,$014D,$0216,$FDE9,$FEB2,$FF44,$FFC3
+			dc.w	$003F,$00C3,$015C,$022D,$FDD2,$FEA3,$FF3C,$FFC0
+			dc.w	$0042,$00CD,$016C,$0247,$FDB8,$FE93,$FF32,$FFBD
+			dc.w	$0045,$00D6,$017C,$0261,$FD9E,$FE83,$FF29,$FFBA
+			dc.w	$0048,$00DF,$018C,$027B,$FD84,$FE73,$FF20,$FFB7
+			dc.w	$004B,$00E9,$019E,$0297,$FD68,$FE61,$FF16,$FFB4
+			dc.w	$004F,$00F4,$01B1,$02B6,$FD49,$FE4E,$FF0B,$FFB0
+			dc.w	$0052,$00FE,$01C5,$02D5,$FD2A,$FE3A,$FF01,$FFAD
+			dc.w	$0056,$0109,$01D8,$02F4,$FD0B,$FE27,$FEF6,$FFA9
+			dc.w	$005A,$0116,$01EF,$0318,$FCE7,$FE10,$FEE9,$FFA5
+			dc.w	$005E,$0122,$0204,$033A,$FCC5,$FDFB,$FEDD,$FFA1
+			dc.w	$0062,$012F,$021A,$035E,$FCA1,$FDE5,$FED0,$FF9D
+			dc.w	$0066,$013C,$0232,$0385,$FC7A,$FDCD,$FEC3,$FF99
+			dc.w	$006B,$014B,$024C,$03AE,$FC51,$FDB3,$FEB4,$FF94
+			dc.w	$0070,$0159,$0266,$03D7,$FC28,$FD99,$FEA6,$FF8F
+			dc.w	$0075,$0169,$0281,$0403,$FBFC,$FD7E,$FE96,$FF8A
+			dc.w	$007A,$0179,$029E,$0432,$FBCD,$FD61,$FE86,$FF85
+			dc.w	$007F,$018A,$02BD,$0463,$FB9C,$FD42,$FE75,$FF80
+			dc.w	$0085,$019B,$02DC,$0494,$FB6B,$FD23,$FE64,$FF7A
+			dc.w	$008B,$01AE,$02FC,$04C8,$FB37,$FD03,$FE51,$FF74
+			dc.w	$0091,$01C1,$031F,$0500,$FAFF,$FCE0,$FE3E,$FF6E
+			dc.w	$0098,$01D5,$0343,$0539,$FAC6,$FCBC,$FE2A,$FF67
+			dc.w	$009F,$01EA,$0368,$0575,$FA8A,$FC97,$FE15,$FF60
+			dc.w	$00A6,$0200,$038F,$05B3,$FA4C,$FC70,$FDFF,$FF59
+			dc.w	$00AD,$0217,$03B7,$05F3,$FA0C,$FC48,$FDE8,$FF52
+			dc.w	$00B5,$022E,$03E1,$0636,$F9C9,$FC1E,$FDD1,$FF4A
+			dc.w	$00BD,$0248,$040E,$067F,$F980,$FBF1,$FDB7,$FF42
+			dc.w	$00C5,$0262,$043D,$06CA,$F935,$FBC2,$FD9D,$FF3A
+			dc.w	$00CE,$027D,$046D,$0717,$F8E8,$FB92,$FD82,$FF31
+			dc.w	$00D7,$0299,$049F,$0767,$F898,$FB60,$FD66,$FF28
+			dc.w	$00E1,$02B7,$04D5,$07BC,$F843,$FB2A,$FD48,$FF1E
+			dc.w	$00EB,$02D6,$050B,$0814,$F7EB,$FAF4,$FD29,$FF14
+			dc.w	$00F6,$02F7,$0545,$0871,$F78E,$FABA,$FD08,$FF09
+			dc.w	$0101,$0318,$0581,$08D1,$F72E,$FA7E,$FCE7,$FEFE
+			dc.w	$010C,$033C,$05C0,$0935,$F6CA,$FA3F,$FCC3,$FEF3
+			dc.w	$0118,$0361,$0602,$099F,$F660,$F9FD,$FC9E,$FEE7
+			dc.w	$0125,$0387,$0646,$0A0C,$F5F3,$F9B9,$FC78,$FEDA
+			dc.w	$0132,$03B0,$068E,$0A80,$F57F,$F971,$FC4F,$FECD
+			dc.w	$013F,$03DA,$06D9,$0AF7,$F508,$F926,$FC25,$FEC0
+			dc.w	$014E,$0406,$0728,$0B75,$F48A,$F8D7,$FBF9,$FEB1
+			dc.w	$015D,$0434,$077A,$0BF9,$F406,$F885,$FBCB,$FEA2
+			dc.w	$016C,$0464,$07CF,$0C82,$F37D,$F830,$FB9B,$FE93
+			dc.w	$017C,$0496,$0828,$0D10,$F2EF,$F7D7,$FB69,$FE83
+			dc.w	$018E,$04CB,$0886,$0DA6,$F259,$F779,$FB34,$FE71
+			dc.w	$019F,$0501,$08E6,$0E41,$F1BE,$F719,$FAFE,$FE60
+			dc.w	$01B2,$053B,$094C,$0EE3,$F11C,$F6B3,$FAC4,$FE4D
+			dc.w	$01C5,$0576,$09B6,$0F8E,$F071,$F649,$FA89,$FE3A
+			dc.w	$01D9,$05B5,$0A26,$1040,$EFBF,$F5D9,$FA4A,$FE26
+			dc.w	$01EF,$05F6,$0A9A,$10FA,$EF05,$F565,$FA09,$FE10
+			dc.w	$0205,$063A,$0B13,$11BC,$EE43,$F4EC,$F9C5,$FDFA
+			dc.w	$021C,$0681,$0B91,$1285,$ED7A,$F46E,$F97E,$FDE3
+			dc.w	$0234,$06CC,$0C15,$1359,$ECA6,$F3EA,$F933,$FDCB
+			dc.w	$024D,$071A,$0CA0,$1437,$EBC8,$F35F,$F8E5,$FDB2
+			dc.w	$0267,$076A,$0D2F,$151D,$EAE2,$F2D0,$F895,$FD98
+			dc.w	$0283,$07C0,$0DC7,$160F,$E9F0,$F238,$F83F,$FD7C
+			dc.w	$029F,$0818,$0E63,$170A,$E8F5,$F19C,$F7E7,$FD60
+			dc.w	$02BD,$0874,$0F08,$1811,$E7EE,$F0F7,$F78B,$FD42
+			dc.w	$02DD,$08D5,$0FB4,$1926,$E6D9,$F04B,$F72A,$FD22
+			dc.w	$02FE,$093A,$1067,$1A44,$E5BB,$EF98,$F6C5,$FD01
+			dc.w	$0320,$09A3,$1122,$1B70,$E48F,$EEDD,$F65C,$FCDF
+			dc.w	$0344,$0A12,$11E7,$1CAB,$E354,$EE18,$F5ED,$FCBB
+			dc.w	$0369,$0A84,$12B2,$1DF0,$E20F,$ED4D,$F57B,$FC96
+			dc.w	$0390,$0AFD,$1389,$1F48,$E0B7,$EC76,$F502,$FC6F
+			dc.w	$03B8,$0B7A,$1467,$20AC,$DF53,$EB98,$F485,$FC47
+			dc.w	$03E3,$0BFE,$1551,$2223,$DDDC,$EAAE,$F401,$FC1C
+			dc.w	$040F,$0C87,$1645,$23A9,$DC56,$E9BA,$F378,$FBF0
+			dc.w	$043E,$0D16,$1744,$2541,$DABE,$E8BB,$F2E9,$FBC1
+			dc.w	$046E,$0DAB,$184C,$26E8,$D917,$E7B3,$F254,$FB91
+			dc.w	$04A1,$0E47,$1961,$28A4,$D75B,$E69E,$F1B8,$FB5E
+			dc.w	$04D6,$0EEA,$1A84,$2A75,$D58A,$E57B,$F115,$FB29
+			dc.w	$050D,$0F95,$1BB3,$2C5B,$D3A4,$E44C,$F06A,$FAF2
+			dc.w	$0547,$1046,$1CEF,$2E55,$D1AA,$E310,$EFB9,$FAB8
+			dc.w	$0583,$1100,$1E3A,$3066,$CF99,$E1C5,$EEFF,$FA7C
+			dc.w	$05C2,$11C3,$1F94,$3292,$CD6D,$E06B,$EE3C,$FA3D
+			dc.w	$0604,$128E,$20FC,$34D2,$CB2D,$DF03,$ED71,$F9FB
+			dc.w	$0649,$1362,$2275,$372E,$C8D1,$DD8A,$EC9D,$F9B6
+			dc.w	$0690,$143F,$23FF,$39A4,$C65B,$DC00,$EBC0,$F96F
+			dc.w	$06DC,$1527,$259A,$3C37,$C3C8,$DA65,$EAD8,$F923
+			dc.w	$072A,$1619,$2749,$3EE8,$C117,$D8B6,$E9E6,$F8D5
+			dc.w	$077C,$1715,$2909,$41B6,$BE49,$D6F6,$E8EA,$F883
+			dc.w	$07D1,$181D,$2ADF,$44A6,$BB59,$D520,$E7E2,$F82E
+			dc.w	$082B,$1930,$2CC7,$47B4,$B84B,$D338,$E6CF,$F7D4
+			dc.w	$0888,$1A50,$2EC6,$4AE7,$B518,$D139,$E5AF,$F777
+			dc.w	$08EA,$1B7D,$30DE,$4E40,$B1BF,$CF21,$E482,$F715
+			dc.w	$094F,$1CB7,$330C,$51BE,$AE41,$CCF3,$E348,$F6B0
+			dc.w	$09BA,$1DFF,$3554,$5565,$AA9A,$CAAB,$E200,$F645
+			dc.w	$0A29,$1F55,$37B4,$5932,$A6CD,$C84B,$E0AA,$F5D6
+			dc.w	$0A9D,$20BC,$3A31,$5D2E,$A2D1,$C5CE,$DF43,$F562
+			dc.w	$0B16,$2231,$3CC9,$6156,$9EA9,$C336,$DDCE,$F4E9
+			dc.w	$0B95,$23B8,$3F80,$65AF,$9A50,$C07F,$DC47,$F46A
+			dc.w	$0C19,$2551,$4256,$6A39,$95C6,$BDA9,$DAAE,$F3E6
+			dc.w	$0CA4,$26FB,$454C,$6EF7,$9108,$BAB3,$D904,$F35B
+			dc.w	$0D34,$28B8,$4864,$73EB,$8C14,$B79B,$D747,$F2CB
+			dc.w	$0DCB,$2A8A,$4B9F,$7918,$86E7,$B460,$D575,$F234
+			dc.w	$0E68,$2C6F,$4EFE,$7E7E,$8181,$B101,$D390,$F197
+			dc.w	$0F0D,$2E6B,$5285,$7FFF,$8000,$AD7A,$D194,$F0F2
+			dc.w	$0FB9,$307E,$5635,$7FFF,$8000,$A9CA,$CF81,$F046
+			dc.w	$106D,$32A7,$5A0D,$7FFF,$8000,$A5F2,$CD58,$EF92
+			dc.w	$1128,$34EA,$5E12,$7FFF,$8000,$A1ED,$CB15,$EED7
+			dc.w	$11ED,$3747,$6245,$7FFF,$8000,$9DBA,$C8B8,$EE12
+			dc.w	$12B9,$39BF,$66A8,$7FFF,$8000,$9957,$C640,$ED46
+			dc.w	$138F,$3C52,$6B3C,$7FFF,$8000,$94C3,$C3AD,$EC70
+			dc.w	$146F,$3F04,$7006,$7FFF,$8000,$8FF9,$C0FB,$EB90
+			dc.w	$1558,$41D3,$7505,$7FFF,$8000,$8AFA,$BE2C,$EAA7
+			dc.w	$164C,$44C3,$7A3E,$7FFF,$8000,$85C1,$BB3C,$E9B3
+			dc.w	$174B,$47D5,$7FB3,$7FFF,$8000,$804C,$B82A,$E8B4
+			dc.w	$1855,$4B0A,$7FFF,$7FFF,$8000,$8000,$B4F5,$E7AA
+			dc.w	$196B,$4E63,$7FFF,$7FFF,$8000,$8000,$B19C,$E694
+			dc.w	$1A8D,$51E3,$7FFF,$7FFF,$8000,$8000,$AE1C,$E572
+			dc.w	$1BBD,$558B,$7FFF,$7FFF,$8000,$8000,$AA74,$E442
+			dc.w	$1CFA,$595C,$7FFF,$7FFF,$8000,$8000,$A6A3,$E305
+			dc.w	$1E45,$5D59,$7FFF,$7FFF,$8000,$8000,$A2A6,$E1BA
+			dc.w	$1F9F,$6184,$7FFF,$7FFF,$8000,$8000,$9E7B,$E060
+			dc.w	$2108,$65DE,$7FFF,$7FFF,$8000,$8000,$9A21,$DEF7
+			dc.w	$2281,$6A6A,$7FFF,$7FFF,$8000,$8000,$9595,$DD7E
+			dc.w	$240C,$6F29,$7FFF,$7FFF,$8000,$8000,$90D6,$DBF3
+			dc.w	$25A7,$741F,$7FFF,$7FFF,$8000,$8000,$8BE0,$DA58
+
+
+			END
diff --git a/Toolbox/SoundMgr/Tables.3.a.idump b/Toolbox/SoundMgr/Tables.3.a.idump
new file mode 100644
--- /dev/null
+++ b/Toolbox/SoundMgr/Tables.3.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Toolbox/StandardFile/StandardFilePACK.a b/Toolbox/StandardFile/StandardFilePACK.a
--- a/Toolbox/StandardFile/StandardFilePACK.a
+++ b/Toolbox/StandardFile/StandardFilePACK.a
@@ -10,9 +10,6 @@
 ;	Change History (most recent first):
 ;
 ;	   <SM6>	 11/6/92	SWC		Changed PackMacs.a->Packages.a.
-;		<SM5>	10/14/92	CSS		Change some branch short instructions to branches. Also,
-;									check for .NewAge driver and display the proper icon if
-;									present.
 ;		<11>	 8/25/92	DTY		Always use the popup CDEF. Get rid of usePopUpCDEF conditional.
 ;		<10>	  7/5/92	csd		#1034877 <gbm>: Reversed some of change <9> because the code to
 ;									rebuild the popup menu gets called multiple times. If it doesn’t
@@ -4811,7 +4808,7 @@ CallActivate
 			_TEDeactivate						; deactivate the TE 
 		; mark the dialog as not having active TE field
 			move.w	#-1,editField(a3)
-			bra 	@checkFileList				;<SM5> CSS
+			bra.s	@checkFileList
 @TEActivate
 		; switch to new item's text handle
 			move.l	teHandle(a3),a0
@@ -7873,8 +7870,6 @@ GetVolIcon	move.l	a0,-(sp)					; don't trash a0
 			move.w	#floppyIconResource,d0
 			cmp.l	#'Sony',(a0)					; .Sony means use floppy icon
 			beq.s	@done
-			cmp.l	#'NewA',(a0)					; .NewAge means use floppy icon <SM5> CSS 
-			beq.s	@done
 			move.w	#genericFileServerIconResource,d0
 			cmp.l	#'AFPT',(a0)					; .AFPTranslator means use fileserver icon
 			beq.s	@done
diff --git a/Toolbox/TextEdit/TextEdit.a b/Toolbox/TextEdit/TextEdit.a
--- a/Toolbox/TextEdit/TextEdit.a
+++ b/Toolbox/TextEdit/TextEdit.a
@@ -18,7 +18,6 @@
 ;									teHandle from a RecoverHandle on the tePtr
 ;	   <SM8>	 6/28/93	kc		Init TEDoText,TERecal and TEWdBreak at TEGlobalInit time so work
 ;									around a QuickTime bug. (Movies containing text as StartupItems)
-;	   <SM7>	10/22/92	CSS		Change some branch short instructions to word branches.
 ;	   <SM6>	 10/6/92	PN		# 1040150 Get rid of Sysvers conditionals and bring the code to
 ;									the current state (7.1)
 ;		<50>	 8/11/92	SMB		#1036481 <gbm>: #1036481 <gbm>: Removed font/keyboard
@@ -1234,7 +1233,6 @@ TextEdit	Proc		Export
 			
 ; sets up vectors to be used for patching TextEdit and clears ExpandMem TE globals <28June89smb>
 			Export		GestaltTEVersion					; <13>
-			Export		TEGlobalInit					; <13>
 ;-------------------------------------------------------------------------------------------------
 
 AddrTable	DC.W		iTEStylPaste-AddrTable				; 0
@@ -1255,92 +1253,6 @@ AddrTable	DC.W		iTEStylPaste-AddrTable				; 0
 			DC.W		iTENumStyles-AddrTable				; 13
 			DC.W		iTEFeatureFlag-AddrTable			; 14
 
-;-------------------------------------------------------------------------------------------------
-
-; Add new vectors <28June89smb>
-; EMVectorTable contains the offset in ExpandMemRec which holds the routine address
-; and the offset to the routine from here.
-
-EMVectorTable
-			with	ExpandMemRec
-			dc.w	vDoErase,			xDoErase-EMVectorTable
-			dc.w	vCaretDisplay,		xCaretDisplay-EMVectorTable
-			dc.w	vGetLRPosition,		xGetLRPosition-EMVectorTable
-			dc.w	vGetRLPosition,		xGetRLPosition-EMVectorTable
-			dc.w	vOnLineEnd,			xOnLineEnd-EMVectorTable
-			dc.w	vCaretInsideRun,	xCaretInsideRun-EMVectorTable
-			
-			dc.w	vSetDirection,		xSetDirection-EMVectorTable
-			dc.w	vGetDirection,		xGetDirection-EMVectorTable
-			
-			dc.w	vGetStylesInOrder,	xGetStylesInOrder-EMVectorTable			
-			dc.w	vteGetFormatOrder,	xteGetFormatOrder-EMVectorTable
-			
-			dc.w	vGetWidth,			xGetWidth-EMVectorTable
-			dc.w	vGetCurScript,		xGetCurScript-EMVectorTable
-
-			dc.w	vOnSameLine,		xOnSameLine-EMVectorTable
-			dc.w	vMeasureWidth,		xMeasureWidth-EMVectorTable
-			dc.w	vMeasureWholeRun,	xMeasureWholeRun-EMVectorTable
-			dc.w	vHiliteLineEnds,	xHiliteLineEnds-EMVectorTable
-			dc.w	vInvrtRectangle,	xInvrtRectangle-EMVectorTable
-			dc.w	vPixelWidths,		xPixelWidths-EMVectorTable
-			
-			dc.w	vTEBufferText,		xTEBufferText-EMVectorTable
-			dc.w	vDumpBuffer,		xDumpBuffer-EMVectorTable
-			
-			dc.w	vCursorMovement,	xCursorMovement-EMVectorTable
-			dc.w	vTestRunDirection,	xTestRunDirection-EMVectorTable
-			
-			dc.w	vBufferChar,		xBufferChar-EMVectorTable
-			
-			dc.w	vSetFont2Keyboard,	xSetFont2Keyboard-EMVectorTable
-			dc.w	vSetKeyboard2Font,	xSetKeyboard2Font-EMVectorTable
-			
-			dc.w	vStyleGuts,			xStyleGuts-EMVectorTable
-			dc.w	vConcatRuns,		xConcatRuns-EMVectorTable
-			dc.w	0,0
-
-;formFeed
-;----------------------------------------------------------------------
-;
-;			PROCEDURE TEGlobalInit
-;			<27June89smb>
-;
-;			To be called from StartInit, in order to assign vectors 
-;			and clear expandMem globals only once.
-;
-;----------------------------------------------------------------------
-TEGlobalInit
-			movem.l	a2/a3,-(sp)
-												;							<SM8>
-			Lea 		XDoText,A0				; set up doText hook		<SM8>
-			Move.L		A0,TEDoText				;							<SM8>
-			Lea 		XReCalLines,A0			; set up recal hook			<SM8>
-			Move.L		A0,TERecal				;							<SM8>
-			Lea 		DefWordBrk,A0			; get default word break	<SM8>
-			Move.L		A0,TEWdBreak			;							<SM8>
-												;							<SM8>
-; initialize expandMem with my TE vectors
-			lea		EMVectorTable,a0			; base address of vector table
-			move.l	a0,a1					
-			move.l	ExpandMem,a2				; get pointer to expandMem
-VectorLoop
-			move.l	(a1)+,d0					; get routine offset from EMVectorTable
-			beq.s	LoopXit
-			lea		0(a0,d0.w),a3				; get routine address
-			swap	d0							; get expandMem offset (vector place holder)
-			move.l	a3,0(a2,d0.w)				; load into expandMem
-			bra.s	VectorLoop
-LoopXit
-			movem.l	(sp)+,a2/a3
-			
-; when TextEdit 3.0 is ptch0, need this code			
-			move.l	#gestaltTextEditVersion, d0	; <8Aug89smb>
-			lea		GestaltTEVersion, a0
-			_NewGestalt
-			rts
-
 ;----------------------------------------------------------------------
 ;			PROCEDURE GestaltTEVersion
 ;			<8Aug89smb>
@@ -2883,7 +2795,7 @@ waitLoop
 			Beq.S		noClikProc
 			Move.L		D0,A0
 			Jsr 		(A0)
-			Beq			done1					; if returns zero abort drag						<SM7> CSS 
+			Beq.s		done1					; if returns zero abort drag
 
 noClikProc
 			Clr 		-(SP)					; make room for result
@@ -3146,7 +3058,7 @@ DoSearch
 			MoveQ		#1,D2					; just 1 style
 			Move.W		D3,D1					; start of line
 			Move.W		D6,D0					; whole line
-			Bra			@DoMeasure
+			Bra.s		@DoMeasure
 
 @StyledRecord
 			sf			useOldMethod(a6)		; flag for getting style runs <28Sept88smb>
@@ -7963,8 +7875,22 @@ StyleTrap
 
 DontSet
 		
+;;	If forRAM THEN
+	If (Not ForROM) THEN						; <19Feb89smb>
+			BTst		#14,ROM85				; color QD around?					<C971/RWW112487>
+			Bnz.S		@1						; nope								<C971/RWW112487>
+			Move.W		teMode(A3),txMode(A0)	; 									<C971/RWW112487>
+			_GetForeColor						; 									<C971/RWW112487>
+			Bra.S		@2						; 									<C971/RWW112487>
+@1			Bsr			GetForeColor			; 									<C971/RWW112487>
+@2
+;;	ElseIf onNuMac|onMvMac THEN					; <C914/29Oct87> rwh
+	ElseIf hasCQD THEN							; <19Feb89smb> 
 			Move.W		teMode(A3),txMode(A0)	; do set the mode		** <C815/13feb87/MBK **
 			_GetForeColor						; for Ikki				** <C182/6oct86/MBK> **
+	Else
+			Bsr			GetForeColor			; for Alladin			** <C182/6oct86/MBK> **
+	EndIf
 
 			Move.L		teTextH(A3),A0			; get handle size
 
@@ -9868,7 +9794,7 @@ iLineLoop
 
 			SubQ		#2,A0					; got over-incremented
 			Move.L		A0,savePtr(A6)			; save it
-			Bra 		iStage3					; on to stage 3 		<SM7> CSS 
+			Bra.s		iStage3					; on to stage 3
 
 @3
 ; D5 (temp lineStart array) may be greater than the old number of lines, so skip the
@@ -10568,7 +10494,7 @@ DoPaste
 			_HLock								; lock text scrap		** MBK 6/20/86 **
 			Move.L		(A0),D6					; ptr to scrap			** MBK 6/20/86 **
 
-			Bsr 		PasteGuts				; go paste the scrap	<C971/RWW102887>NO <SM7> CSS 
+			Bsr.s		PasteGuts				; go paste the scrap	<C971/RWW102887>NO
 
 @1			Move.L		(SP)+,A0				; temp scrap handle		** MBK 6/20/86 **
 			_DisposHandle						; get rid of it			** MBK 6/20/86 **
@@ -13449,11 +13375,7 @@ scrollEm
 			move.w		#1,-(sp)				; itemsVisible = smallest possible (1)		<4>
 			move		d4,-(sp)				; pass dh
 			move		d1,-(sp)				; pass dv
-
-			movea.l		a3, a0					; Grab Text Edit pointer from A3			<sm9>
-			_RecoverHandle						; Recover the tehandle						<sm9>
-			move.l		a0,-(sp)				; slam tehandle onto stack					<sm9>
-
+			move.l		8(a6),-(sp)				; slam tehandle onto stack
 			subq.l		#4,sp					;											<4>
 			_TickCount							; Get a time stamp.							<4>
 			move.l		(sp)+,d1				; Copy it into D1.							<4>
diff --git a/Toolbox/WindowMgr/LayerMgr.c b/Toolbox/WindowMgr/LayerMgr.c
--- a/Toolbox/WindowMgr/LayerMgr.c
+++ b/Toolbox/WindowMgr/LayerMgr.c
@@ -24,17 +24,6 @@
 																protect CubeE and System builds)
 									<68>	 4/10/92	DC		Put in conditional changes to WindowMgrPatches.a and LayerMgr.c
 																for implementing layerless apps.
-		<SM2>	 5/22/92	FM		
-		<SM2>	  5/7/92	FM		renamed the romXXX routines as XXXXGlue since thats what they are highlevel interfaces for
-									register based routines. The windowmgrpatches file in reality will need to be changed to reflect this.
-
-									renamed oldXXXX routines as XXXXGuts. These are assembly core routines that the
-									LayerMgr is building on (originally in the form of a tail patch.)
-
-									renamed __BeginUpdate as BeginUpdateOfLayersChildren to reflect the funstion of this
-									routine. It is now called from WindowMgr.a in BeginUpdate. I did this to replace the 
-									sick, fragmented jumping around that used to be done in the patch file.
-
 		<67>	 10/4/91	JSM		Change PsychoticFarmerOrLater conditionals to TheFuture.
 		<66>	 9/22/91	DTY		Change PsychoticFarmerAndLater to PsychoticFarmerOrLater.
 		<65>	 9/13/91	dba		Fix the bug where a window which is created with a nil
@@ -316,16 +305,17 @@ short ShortDiv(short, short)
 #define	layerProc	layerWDEF*16
 
 #if	!hasLayerlessAppsINIT
-pascal void			InitWindowsGuts(void);
+pascal void			oldInitWindows(void);
 #endif
-pascal void			ClipAboveGuts(WindowPeek);
-pascal void			PaintOneGuts(WindowPeek, RgnHandle);
-pascal void			CloseWindowGuts(WindowPtr);
-pascal void			InsertWindow(WindowPtr, WindowPtr);
-pascal void			MakeDeactiveGlue(WindowPtr);
-pascal void			CallWindowGlue(WindowPeek, short, long);
-pascal void			CallWindowDrawGlue(WindowPeek);
-pascal void			CallWindowCalcGlue(WindowPeek);
+pascal void			oldClipAbove(WindowPeek);
+pascal void			oldPaintOne(WindowPeek, RgnHandle);
+pascal void			oldCloseWindow(WindowPtr);
+pascal void			oldBeginUpdate(WindowPtr);
+pascal void			romInsertWindow(WindowPtr, WindowPtr);
+pascal void			romMakeDeactive(WindowPtr);
+pascal void			romCallWindow(WindowPeek, short, long);
+pascal void			romCallWindowDraw(WindowPeek);
+pascal void			romCallWindowCalc(WindowPeek);
 
 pascal void			PaintDesk(void);
 pascal void			ValidateMenuBar(void);
@@ -473,7 +463,7 @@ void GetNewStructRect(Rect *newStruct, WindowPeek whichWindow, Rect *thePort)
 
 	//	call the WDEF with the wCalcRgns message in this new faked up state.
 
-	CallWindowCalcGlue(whichWindow);
+	romCallWindowCalc(whichWindow);
 
 	//	get the bounding box of the structure rgn.
 
@@ -487,7 +477,7 @@ void GetNewStructRect(Rect *newStruct, WindowPeek whichWindow, Rect *thePort)
 
 	SetPort(curPort);
 
-	CallWindowCalcGlue(whichWindow);
+	romCallWindowCalc(whichWindow);
 }
 
 #define staggerIncrement 20
@@ -1120,7 +1110,7 @@ NewWindowCommon(register Ptr wStorage, register const Rect *boundsRect, const St
 			((WindowPeek) wStorage)->nextWindow = WindowList;
 			WindowList = ((WindowPeek) wStorage);
 		} else
-			InsertWindow((WindowPtr) wStorage, behind);
+			romInsertWindow((WindowPtr) wStorage, behind);
 
 		/* Get the WDEF.  If the one we’re looking for doesn’t exist, get id = 0. */
 		{
@@ -1188,7 +1178,7 @@ NewWindowCommon(register Ptr wStorage, register const Rect *boundsRect, const St
 			WindowPtr newFront = ActiveWindow();
 			if (newFront != oldFront) {
 				if (oldFront != nil)
-					MakeDeactiveGlue(oldFront);
+					romMakeDeactive(oldFront);
 				if (newFront != nil)
 					((WindowPeek) newFront)->hilited = true;
 					CurActivate = (WindowPeek) newFront;
@@ -1220,7 +1210,7 @@ NewWindowCommon(register Ptr wStorage, register const Rect *boundsRect, const St
 			((WindowPeek) wStorage)->titleWidth = StringWidth(title);
 		}
 
-		CallWindowGlue((WindowPeek) wStorage, wNew, 0);
+		romCallWindow((WindowPeek) wStorage, wNew, 0);
 
 		if (autoPosition) {
 			struct	AutoWindowPosition *info = (struct AutoWindowPosition *) &(boundsRect->left);
@@ -1245,7 +1235,7 @@ NewWindowCommon(register Ptr wStorage, register const Rect *boundsRect, const St
 	 * If it is a visible window, it can also affect the structure of the layers it is contained in
 	 * and needs to be drawn and obscure other windows.
 	 */
-	CallWindowCalcGlue((WindowPeek) wStorage);
+	romCallWindowCalc((WindowPeek) wStorage);
 	if (visible && !FastIsLayer(wStorage)) {
 		ActivatePalette((WindowPtr) wStorage);
 		PaintOne((WindowPeek) wStorage, ((WindowPeek) wStorage)->strucRgn);
@@ -1520,7 +1510,7 @@ __InitLayers(void)
 #if hasLayerlessAppsINIT
 	InitWindows();
 #else
-	InitWindowsGuts();
+	oldInitWindows();
 #endif
 
 	/* Create the two layers (one for system stuff). */
@@ -1572,7 +1562,7 @@ CalcAncestorRgns(WindowPtr window)
 	{
 		LayerPeek layer = __GetParent(window);
 		while (layer != nil) {
-			CallWindowCalcGlue((WindowPeek) layer);
+			romCallWindowCalc((WindowPeek) layer);
 			layer = layer->parent;
 		}
 	}
@@ -1638,13 +1628,14 @@ __CheckUpdate(EventRecord *event)
 
 /* If window is a layer, BeginUpdate will correctly paint and calculate visRgns for its children. */
 pascal void
-BeginUpdateOfLayersChildren(WindowPtr window)
+__BeginUpdate(WindowPtr window)
 {
 	if (FastIsLayer(window)) {
 		PaintOne((WindowPeek) window, ((WindowPeek) window)->updateRgn);
 		/* Note that only the children of window really need CalcVis. */
 		CalcVis((WindowPeek) window);
 	}
+	oldBeginUpdate((WindowPeek) window);
 }
 
 #if !hasLayerlessApps
@@ -1668,7 +1659,7 @@ __ClipAbove(WindowPeek window)
 
 		/* Call the old ClipAbove (set the current layer for it). */
 		__SetCurLayer(parent);
-		ClipAboveGuts(window);
+		oldClipAbove(window);
 
 		/* Jump up a layer. */
 		window = (WindowPeek) parent;
@@ -1757,7 +1748,7 @@ PaintAction(WindowPeek window, LayerPeek, PaintInfoPtr paintInfo)
 		/* Call the old PaintOne for real windows only in normal loops and when a palette update
 		 * is necessary.
 		 */
-		PaintOneGuts(window, paintInfo->clobberedRgn);
+		oldPaintOne(window, paintInfo->clobberedRgn);
 	}
 
 	return noErr;
@@ -1770,11 +1761,11 @@ PaintAction(WindowPeek window, LayerPeek, PaintInfoPtr paintInfo)
  */
 void CalcAncestorRgnsForPaintActions(WindowPtr window)
 {
-	ExpandMemRec *emRec = ExpandMem;
-	if (GetExpandMemAncestorRgnsCalced() == 0)
+	ExpandMemRec *emRec = GetExpandMem();
+	if (emRec->emAncestorRgnsCalced == 0)
 		CalcAncestorRgns(window);		// calculate the regions if the one-shot is off
 	else
-		SetExpandMemAncestorRgnsCalced(0);		// reset the one-shot
+		emRec->emAncestorRgnsCalced = 0;		// reset the one-shot
 }
 #endif
 
@@ -2078,7 +2069,7 @@ __CloseWindow(WindowPtr window)
 	}
 
 	/* Call the old CloseWindow. */
-	CloseWindowGuts(window);
+	oldCloseWindow(window);
 
 	/* Restore the current layer. */
 	__SetCurLayer(saveLayer);
@@ -2105,9 +2096,9 @@ ShowWindowAction(WindowPeek window, LayerPeek layer, PaintInfoPtr)
 	if (!window->visible)
 		return skipChildren;
 	if (!FastIsLayer(window)) {
-		CallWindowCalcGlue(window);
+		romCallWindowCalc(window);
 		if (window->nextWindow == nil)					/* calculate parent only after the last child of a layer */
-			CallWindowCalcGlue((WindowPeek) layer);
+			romCallWindowCalc((WindowPeek) layer);
 	}
 	return noErr;
 }
diff --git a/Toolbox/WindowMgr/StandardWDEF.a b/Toolbox/WindowMgr/StandardWDEF.a
--- a/Toolbox/WindowMgr/StandardWDEF.a
+++ b/Toolbox/WindowMgr/StandardWDEF.a
@@ -11,18 +11,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM5>	 5/27/93	SAM		Rereintroduced the change made in <34>.  Now after all these
-;									years, Paul W. can finally sleep at night.
-;	   <SM4>	12/16/92	HI		Removed the the instruction which sets ROMMapInsert to mapTrue before
-;									GetResource() for 'wctb'. 'wctb' resource is modified by
-;									programs such as Color CDEV and the StandardWDEF should read
-;									the modified 'wctb' instead of the unmodifiable one from the
-;									ROM. Previously, this prevented changing the window colors.
-;									(Hoon Im)
-;	   <SM3>	11/19/92	RB		Set ROMMapInsert to mapTrue before doing GetResource calls to
-;									look in ROM first.
-;		<SM1>	 10/22/92	CSS		Changed some short branches to regular branches as ROM direct
-;									trap calling expanded code.
 ;		<37>	 10/6/91	DTY		#1005945: Put <34> back into the WDEF, conditionalized for
 ;									TheFuture.
 ;		<36>	 3/26/91	KSM		jdr+vl,#84033: To check for zoom flag, you MUST: (1) Decide that
@@ -446,7 +434,7 @@ IsNoZoom
 
 			move.l	WMgrPort,-(SP)		; B&W, set to window manager port
 			_SetPort					;
-			bra		@CommonSys			; done for the B&W environment <SM1> CSS
+			bra.s	@CommonSys			; done for the B&W environment
 
 ; ------------- doin it with color -------------
 ; when using the WMgrCPort, it is the defproc’s responsibility to reconcile
@@ -538,8 +526,7 @@ IsNoZoom
 			subq.l	#4, SP					; room for a PixMapHandle
 			move.l	#'pmap', -(SP)			; the Pixmap resource type
 			move.w	#kPixmapID, -(SP)		; ID of working pixmap
-			move.w	#MapTrue,RomMapInsert	;												<SM3> rb
-			_GetResource					; look in ROM first								<SM3> rb
+			_GetResource					; look
 			move.l	(SP)+, workPixmap(A6)	; save it for later
 			move.l	#16,D0					; allocate a bogus ctab 						<21>
 			_NewHandle	,SYS,CLEAR			;	in sys heap with 0 entries					<21>
@@ -1663,11 +1650,8 @@ WDefDrawGIcon
 			move.l	portRect+botRight(windowReg),(rectReg)	; botRight=topLeft
 			move.l	(rectReg),botRight(rectReg)				; copy into botRight, too
 
-			add.w	d4,left(rectReg)						; <SM5> 	reintroduced from <34>
-			add.w	d4,right(rectReg)						; <SM5>
-			swap	d4										; <SM5>
-			add.w	d4,top(rectReg)							; <SM5>
-			add.w	d4,bottom(rectReg)						; <SM5>
+			add.l	d4,topLeft(a4)							; offset the grow icon
+			add.l	d4,botRight(a4)
 
 			sub.w	#scrollBarSize-2,top(rectReg)			; remove scroll area
 			sub.w	#scrollBarSize-2,left(rectReg)
@@ -2309,7 +2293,7 @@ SetUpColor
 			subq.l	#4,SP								; leave space for results				<22>
 			move.l	#'wctb',-(SP)						; try to get the system wctb			<22>
 			clr.w	-(SP)								;										<22>
-			_GetResource								; look in ROM first						<22><SM3> rb
+			_GetResource								;										<22>
 			move.l	(SP)+,A0							; get the wctb resource					<22>
 			move.w	(SP)+,D0							; retrieve the index					<22>
 			cmp.l	#0,A0								; did we really get the wctb resource	<22>
@@ -2359,7 +2343,6 @@ SetupColorPict
 			move.w	(A2, D0.w), -(SP)					; push the resource ID
 			cmpi.w	#kHighlightPix,(sp)
 			seq		gadgetHighlight(a6)					; Set if we’re highlighting
-			move.w	#MapTrue,RomMapInsert				;										<SM3> rb
 			_GetResource								; look in ROM first						<SM3> rb
 			move.l	(SP)+, A0							; pixels handle
 			_HLock										; don’t want it to move
diff --git a/Toolbox/WindowMgr/WindowList.a b/Toolbox/WindowMgr/WindowList.a
--- a/Toolbox/WindowMgr/WindowList.a
+++ b/Toolbox/WindowMgr/WindowList.a
@@ -10,8 +10,6 @@
 ;
 ;	Change History (most recent first):
 ;
-;	   <SM3>	 6/17/93	KW		(LW2 fau) Changed the clearing of DragFlag to be a word, instead
-;									of a byte.
 ;		<12>	 6/25/92	DC		fixed patch on SetTrapAddress to preserve A1 and D1.
 ;		<11>	  6/9/92	DC		Fixed PointInMenuBar for Non-ColorQD machines.
 ;		<10>	  6/8/92	DC		Added startup icon.  Fixed PtInMenuBar for Plus and SE
@@ -258,7 +256,7 @@ DoOld				MOVE.L		(SP)+, A1
 wlBringToFront		PatchProc	_BringToFront
 
 					MOVE.L		4(SP), -(SP)
-					CLR.W		DragFlag										<LW2>
+					CLR.B		DragFlag
 					IMPORT		BringToFrontGuts
 					LEA			BringToFrontGuts, A0
 					IMPORT		TwoByFour
diff --git a/Toolbox/WindowMgr/WindowMgr.a b/Toolbox/WindowMgr/WindowMgr.a
--- a/Toolbox/WindowMgr/WindowMgr.a
+++ b/Toolbox/WindowMgr/WindowMgr.a
@@ -723,7 +723,7 @@ InsertWindow	Proc	Export
 
 InsertLast		
 				MOVEQ	#0,D0					;find the last one
-				BSR.S	PREVWINDOW				;find last window in list
+				BSR		PREVWINDOW				;find last window in list
 				MOVE.L	D1,NEXTWINDOW(A0)		;insert the window in the list
 ;
 
@@ -3369,15 +3369,15 @@ Exit			BSR 	RestorePort 			;restore the users port
 BeginUpdate 	Proc	Export
 				Import	PortToBitMap
 				Import	NegWords
-				IMPORT	BeginUpdateOfLayersChildren
+;				IMPORT	BeginUpdateOfLayersChildren
 				
 				MOVEM.L D3-D4/A3,-(SP)			;save working registers
 				MOVE.L	16(SP),A3				;get the windowPtr
 				
-				MOVE.L	A3,WMgrUpdate			; Copy the window pointer to a safe place.<SM16> FM
+;				MOVE.L	A3,WMgrUpdate			; Copy the window pointer to a safe place.<SM16> FM
 				
-				MOVE.L	A3,-(SP)						; Check is this window is a layer <SM16> FM
-				JSR		BeginUpdateOfLayersChildren		; And update its children if so…  <SM16> FM
+;				MOVE.L	A3,-(SP)						; Check is this window is a layer <SM16> FM
+;				JSR		BeginUpdateOfLayersChildren		; And update its children if so…  <SM16> FM
 
 				MOVE.L	A3,A0					;get port pointer						<C106 EHB>
 				BSR		PortToBitMap				;convert to bit/pixmap pointer			<C106 EHB>
@@ -3638,8 +3638,8 @@ FrameSize			equ		*
 DragTheRgn		LINK	A6,#FrameSize 			;make room for savePenState
 				MOVEM.L D3-D7/A3-A4,-(SP)		;reserve work registers
 				
-				MOVE.L	ExpandMem,A0			;get ExpandMem globals		<SM23>
-				ST		ExpandMemRec.emIsDragging(A0)	;we're dragging		<SM23>
+				;MOVE.L	ExpandMem,A0			;get ExpandMem globals		<SM23>
+				;ST		ExpandMemRec.emIsDragging(A0)	;we're dragging		<SM23>
 
 				LEA 	DMPoint(A6),A0			;point to parameters
 				MOVE.L	(A0)+,D3				;get the mousePt
@@ -3911,8 +3911,8 @@ ItsClear
 				move.l	a4,-(sp)
 				_DisposRgn						; Dispose of secondary dragging region
 
-				MOVE.L	ExpandMem,A0			;get ExpandMem globals			<SM23>
-				CLR.B	ExpandMemRec.emIsDragging(A0)	;we're done dragging	<SM23>
+				;MOVE.L	ExpandMem,A0			;get ExpandMem globals			<SM23>
+				;CLR.B	ExpandMemRec.emIsDragging(A0)	;we're done dragging	<SM23>
 				
 				MOVEM.L (SP)+,D3-D7/A3-A4		;restore work registers
 				UNLK	A6						;deallocate stack frame
@@ -4001,7 +4001,7 @@ DrawDraggedRgn
 
 @dragThumb
 				move.l	ExpandMem,a0
-				move.L	ExpandMemRec.emControlHandle(a0),d1	; get control handle saved for us in _DragControl
+				;move.L	ExpandMemRec.emControlHandle(a0),d1	; get control handle saved for us in _DragControl
 				beq.s	@paintnormal		; do the normal painting if there's no controldefhandle.  <LW11>
 				move.l	d1,a0
 				move.l	(a0),a0				; get the ptr to control record
