From: Horst Beepmanh <>
Subject: Brave attempt

---
diff --git a/AmphibianDNA/Beep.lib b/AmphibianDNA/Beep.lib
new file mode 100644
index 0000000000000000000000000000000000000000..3fc2443acab9236d465e4cd840eee8b61c35090a
GIT binary patch
literal 6
NcmZQ%U|?cm0000M00sa6

literal 0
HcmV?d00001

diff --git a/AmphibianDNA/Beep.lib.idump b/AmphibianDNA/Beep.lib.idump
new file mode 100644
--- /dev/null
+++ b/AmphibianDNA/Beep.lib.idump
@@ -0,0 +1 @@
+OBJ MPS 
\ No newline at end of file
diff --git a/AmphibianDNA/PPCDsp.c.o b/AmphibianDNA/PPCDsp.c.o
new file mode 100644
index 0000000000000000000000000000000000000000..3fc2443acab9236d465e4cd840eee8b61c35090a
GIT binary patch
literal 6
NcmZQ%U|?cm0000M00sa6

literal 0
HcmV?d00001

diff --git a/AmphibianDNA/PPCDsp.c.o.idump b/AmphibianDNA/PPCDsp.c.o.idump
new file mode 100644
--- /dev/null
+++ b/AmphibianDNA/PPCDsp.c.o.idump
@@ -0,0 +1 @@
+OBJ MPS 
\ No newline at end of file
diff --git a/AmphibianDNA/SoundMgr.lib b/AmphibianDNA/SoundMgr.lib
new file mode 100644
index 0000000000000000000000000000000000000000..3fc2443acab9236d465e4cd840eee8b61c35090a
GIT binary patch
literal 6
NcmZQ%U|?cm0000M00sa6

literal 0
HcmV?d00001

diff --git a/AmphibianDNA/SoundMgr.lib.idump b/AmphibianDNA/SoundMgr.lib.idump
new file mode 100644
--- /dev/null
+++ b/AmphibianDNA/SoundMgr.lib.idump
@@ -0,0 +1 @@
+OBJ MPS 
\ No newline at end of file
diff --git a/AmphibianDNA/StartTest.lib b/AmphibianDNA/StartTest.lib
new file mode 100644
index 0000000000000000000000000000000000000000..3fc2443acab9236d465e4cd840eee8b61c35090a
GIT binary patch
literal 6
NcmZQ%U|?cm0000M00sa6

literal 0
HcmV?d00001

diff --git a/AmphibianDNA/StartTest.lib.idump b/AmphibianDNA/StartTest.lib.idump
new file mode 100644
--- /dev/null
+++ b/AmphibianDNA/StartTest.lib.idump
@@ -0,0 +1 @@
+OBJ MPS 
\ No newline at end of file
diff --git a/DeclData/DeclVideo/ATI/ATI.h b/DeclData/DeclVideo/ATI/ATI.h
new file mode 100644
--- /dev/null
+++ b/DeclData/DeclVideo/ATI/ATI.h
@@ -0,0 +1,122 @@
+#ifdef _ATI_H_
+#else
+#define _ATI_H_
+
+#include "Diamond.h"
+
+void ATIReset68800 (void);
+void ATISetSyncRegisters (void);
+
+#define k4MegAperture 0
+#define kADVFUNC_CNTL 0
+#define kAPERTURE_CNTL 0
+#define kATIDeviceID 0
+#define kATIVendorID 0
+#define kATIVRAMAddr 0
+#define kBT485Reg0 0
+#define kBT485Reg1 0
+#define kBT485Reg2 0
+#define kBT485Reg3 0
+#define kCLOCK_SEL 0
+#define kCLOCK_SELECT 0
+#define kCLOCK_SELECT_COMPOSITE_SYNC 0
+#define kCLOCK_SELECT_DIV_2 0
+#define kCLOCK_SELECT_ENABLE_8514 0
+#define kCOLOR_SRC_FG 0
+#define kConfigAddressReg 0
+#define kConfigDataReg 0
+#define kCPUIDReg 0
+#define kCRT_OFFSET_HIGH 0
+#define kCRT_OFFSET_LOW 0
+#define kCRT_PITCH 0
+#define kCURSOR_OFFSET_HIGH 0
+#define kDAC_DATA 0
+#define kDAC_MASK 0
+#define kDAC_R_INDEX 0
+#define kDAC_W_INDEX 0
+#define kDEST_CMP_FN 0
+#define kDiamondDeviceID 0
+#define kDiamondDrawMode 0
+#define kDiamondFBBase 0
+#define kDiamondHorzBlankFallingEdge 0
+#define kDiamondHorzBlankRisingEdge 0
+#define kDiamondHorzCounterPreload 0
+#define kDiamondHorzLength 0
+#define kDiamondHorzSyncRisingEdge 0
+#define kDiamondInterruptEnable 0
+#define kDiamondIOAddr 0
+#define kDiamondMemConfig 0
+#define kDiamondPlaneMask 0
+#define kDiamondRasMax 0
+#define kDiamondRefreshPeriod 0
+#define kDiamondScreenRepaintTiming 0
+#define kDiamondSysConfig 0
+#define kDiamondVendorID 0
+#define kDiamondVertBlankFallingEdge 0
+#define kDiamondVertBlankRisingEdge 0
+#define kDiamondVertCounterPreload 0
+#define kDiamondVertLength 0
+#define kDiamondVertSyncRisingEdge 0
+#define kDiamondVRAMAddr 0
+#define kDiamondWindowMaximum 0
+#define kDiamondWindowMaximum 0
+#define kDiamondWindowMinimum 0
+#define kDISP_CNTL 0
+#define kDP_CONFIG 0
+#define kDP_CONFIG_BG_COLOR_SRC_BG 0
+#define kDP_CONFIG_DATA_WIDTH_16 0
+#define kDP_CONFIG_ENABLE_DRAW 0
+#define kDP_CONFIG_FG_COLOR_SRC_FG 0
+#define kDP_CONFIG_MONO_SRC_ALWAYS1 0
+#define kDP_CONFIG_MSB_FIRST 0
+#define kDP_CONFIG_POLY_FILL_DISABLE 0
+#define kDP_CONFIG_READ_MODE_COLOR_DATA 0
+#define kDP_CONFIG_WRITE 0
+#define kEXT_FIFO_STATUS 0
+#define kEXT_GE_CONFIG 0
+#define kFRGD_MIX 0
+#define kGE_BUSY 0
+#define kGE_OFFSET_HIGH 0
+#define kGE_OFFSET_LOW 0
+#define kGE_PITCH 0
+#define kGE_STAT_BUSY 0
+#define kH_DISP 0
+#define kH_SYNC_STRT 0
+#define kH_SYNC_WID 0
+#define kH_TOTAL 0
+#define kHORIZONTAL_OVERSCAN 0
+#define kLOCAL_CNTL 0
+#define kMEM_CFG 0
+#define kMISC_OPTIONS 0
+#define kMIX_FN_S 0
+#define kMULTIFUNC_CNTL 0
+#define kNORMAL_GE 0
+#define kOVERSCAN_COLOR_8_BLUE 0
+#define kOVERSCAN_COLOR_GREEN_RED 0
+#define kPCIBaseReg1Offset 0
+#define kPCIBaseReg2Offset 0
+#define kPCICommandOffset 0
+#define kPCIVendorIDOffset 0
+#define kPixelMask 0
+#define kRamWrite 0
+#define kRESET_GE 0
+#define kSCISSOR_BOTTOM 0
+#define kSCISSOR_LEFT 0
+#define kSCISSOR_RIGHT 0
+#define kSCISSOR_TOP 0
+#define kSecondPCISlot 0
+#define kSHADOW_CTL 0
+#define kSHADOW_SET 0
+#define kSRC_Y_DIR 0
+#define kSUBSYS_CNTL 0
+#define kV_DISP 0
+#define kV_SYNC_STRT 0
+#define kV_SYNC_WID 0
+#define kV_TOTAL 0
+#define kVERTICAL_OVERSCAN 0
+#define kWRT_MASK 0
+#define NEGATIVE 0
+#define PCI_CNTL 0
+#define POSITIVE 0
+
+#endif
\ No newline at end of file
diff --git a/DeclData/DeclVideo/ATI/ATI.h.idump b/DeclData/DeclVideo/ATI/ATI.h.idump
new file mode 100644
--- /dev/null
+++ b/DeclData/DeclVideo/ATI/ATI.h.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Interfaces/AIncludes/Sound.a b/Interfaces/AIncludes/Sound.a
new file mode 100755
--- /dev/null
+++ b/Interfaces/AIncludes/Sound.a
@@ -0,0 +1 @@
+; Version: 3.24
; Created: Friday, October 20, 1989 at 9:54:13 PM
;
; File: Sound.a
;
; Assembler Interface to the Macintosh Libraries
; Copyright Apple Computer, Inc. 1986-1991
; All Rights Reserved
;
;--------------------------------------------------------------------

	IF &TYPE('__IncludingSound__') = 'UNDEFINED' THEN
__IncludingSound__	SET	1


; _______________________________________________________________________
; 
; Sound Driver
; 
; _______________________________________________________________________

swMode 			EQU -1
ftMode 			EQU 1
ffMode 			EQU 0

FFSynthRec		RECORD 0
mode			DS.W 1
count			DS.L 1
waveBytes		DS.B 30001
				ENDR

Tone			RECORD 0
count			DS.W 1
amplitude		DS.W 1
duration		DS.W 1
toneRecSize		EQU *
				ENDR

SWSynthRec		RECORD 0
mode			DS.W 1
triplets		DS.B 5001*Tone.toneRecSize
				ENDR

FTSoundRec		RECORD 0
duration		DS.W 1
sound1Rate		DS.L 1
sound1Phase		DS.L 1
sound2Rate		DS.L 1
sound2Phase		DS.L 1
sound3Rate		DS.L 1
sound3Phase		DS.L 1
sound4Rate		DS.L 1
sound4Phase		DS.L 1
sound1Wave		DS.L 1
sound2Wave		DS.L 1
sound3Wave		DS.L 1
sound4Wave		DS.L 1
				ENDR

FTSynthRec		RECORD 0
mode			DS.W 1
sndRec			DS.L 1
				ENDR
; _______________________________________________________________________
; 
; Sound Manager constants
; 
; _______________________________________________________________________

synthCodeRsrc 			EQU 'snth'
soundListRsrc 			EQU 'snd '

rate22khz				EQU $56EE8BA3		; 22254.54545
rate11khz				EQU $2B7745D1		; 11127.27273

; synthesizer numbers for SndNewChannel

squareWaveSynth 		EQU 1			; square wave synthesizer
waveTableSynth 			EQU 3 			; wave table synthesizer
sampledSynth 			EQU 5			; sampled sound synthesizer

; Command Numbers

nullCmd 				EQU 0
initCmd 				EQU 1
freeCmd 				EQU 2
quietCmd 				EQU 3
flushCmd 				EQU 4
reInitCmd 				EQU 5

waitCmd 				EQU 10
pauseCmd 				EQU 11
resumeCmd 				EQU 12
callBackCmd 			EQU 13
syncCmd 				EQU 14
emptyCmd 				EQU 15

tickleCmd 				EQU 20
requestNextCmd 			EQU 21
howOftenCmd 			EQU 22
wakeUpCmd 				EQU 23
availableCmd 			EQU 24
versionCmd 				EQU 25
totalLoadCmd 			EQU 26
loadCmd 				EQU 27

scaleCmd 				EQU 30
tempoCmd 				EQU 31

freqDurationCmd 		EQU 40
restCmd 				EQU 41
freqCmd 				EQU 42
ampCmd 					EQU 43
timbreCmd 				EQU 44
getAmpCmd				EQU 45
waveTableCmd 			EQU 60
phaseCmd 				EQU 61

soundCmd 				EQU 80
bufferCmd 				EQU 81
rateCmd 				EQU 82
continueCmd 			EQU 83
doubleBufferCmd 		EQU 84
getRateCmd 				EQU 85

sizeCmd 				EQU 90
convertCmd 				EQU 91

stdQLength 				EQU 128
dataOffsetFlag	 		EQU $8000

waveInitChannelMask		EQU $07
waveInitChannel0		EQU $04
waveInitChannel1		EQU $05
waveInitChannel2		EQU $06
waveInitChannel3		EQU $07

; channel initialization parameters

initPanMask				EQU $0003		; mask for right/left pan values
initSRateMask 			EQU $0030		; mask for sample rate values
initStereoMask 			EQU $00C0		; mask for mono/stereo values
initCompMask			EQU $FF00		; mask for compression IDs

initChanLeft 			EQU $0002		; left stereo channel
initChanRight 			EQU $0003		; right stereo channel
initSRate22k 			EQU $0020		; 22k sampling rate
initMono 				EQU $0080		; monophonic channel
initStereo 				EQU $00C0		; stereo channel
initNoInterp 			EQU $0004		; no linear interpolation
initNoDrop				EQU $0008		; no drop-sample conversion
initMACE3 				EQU $0300		; MACE 3:1
initMACE6 				EQU $0400		; MACE 6:1

initChan0 				EQU $0004		; channel 0 - wave table only
initChan1 				EQU $0005		; channel 1 - wave table only
initChan2 				EQU $0006		; channel 2 - wave table only
initChan3 				EQU $0007		; channel 3 - wave table only

stdSH 					EQU $0
extSH 					EQU $FF
cmpSH 					EQU $FE

notCompressed 			EQU 0
twoToOne 				EQU 1
eightToThree 			EQU 2
threeToOne 				EQU 3
sixToOne 				EQU 4

outsideCmpSH 			EQU 0
insideCmpSH 			EQU 1
aceSuccess 				EQU 0
aceMemFull 				EQU 1
aceNilBlock 			EQU 2
aceBadComp 				EQU 3
aceBadEncode 			EQU 4
aceBadDest 				EQU 5
aceBadCmd 				EQU 6
sixToOnePacketSize 		EQU 8
threeToOnePacketSize 	EQU 16
stateBlockSize 			EQU 64
leftOverBlockSize 		EQU 32

firstSoundFormat 		EQU 1
secondSoundFormat 		EQU 2

dbBufferReady 			EQU $00000001
dbLastBuffer 			EQU $00000004

sysBeepDisable			EQU $0000
sysBeepEnable			EQU $0001

unitTypeNoSelection		EQU $FFFF
unitTypeSeconds			EQU $0000


noneCompType			EQU 'NONE'		; use no compression on samples
MACE3CompType			EQU 'MAC3'		; use MACE 3:1 compression on samples
MACE6CompType			EQU 'MAC6'		; use MACE 6:1 compression on samples


; _______________________________________________________________________
; 
; Sound Manager structures
; 
; _______________________________________________________________________

SndCommand			RECORD 0
cmd   				DS.W 1         	; INTEGER
param1				DS.W 1         	; INTEGER
param2				DS.L 1         	; LONGINT
sndCSize  			EQU *         	; size of SndCommand
  					ENDR

SndChannel			RECORD 0
nextChan  			DS.L 1         	; ^SndChannel
firstMod  			DS.L 1         	; Ptr
callBack  			DS.L 1         	; ProcPtr
userInfo  			DS.L 1

; The following is for internal Sound Manager use only.

wait  				DS.L 1         	; Time [LONGINT]
cmdInProgress 		DS SndCommand 
flags 				DS.W 1         	; INTEGER
qLength   			DS.W 1         	; INTEGER
qHead 				DS.W 1         	; INTEGER
qTail 				DS.W 1         	; INTEGER
queue 				DS.B stdQLength*SndCommand.sndCSize
sndChSize 			EQU *         	; size of SndChannel
  					ENDR

SoundHeader   		RECORD 0
samplePtr 			DS.L 1         	; Ptr - if NIL then samples are in sampleArea
length				DS.L 1         	; LONGINT
sampleRate			DS.L 1         	; Fixed
loopStart 			DS.L 1         	; LONGINT
loopEnd   			DS.L 1         	; LONGINT
baseFrequency  		DS.W 1         	; INTEGER
sampleArea			EQU	 * 			; PACKED ARRAY [0..0] OF Byte
  					ENDR

SMStatus			RECORD 0
smMaxCPULoad		DS.W 1
smNumChannels		DS.W 1
smCurCPULoad		DS.W 1
					ENDR

SCStatus			RECORD 0
scStartTime			DS.L 1
scEndTime			DS.L 1
scCurrentTime		DS.L 1
scChannelBusy		DS.B 1
scChannelDisposed	DS.B 1
scChannelPaused		DS.B 1
scUnused			DS.B 1
scChannelAttributes	DS.L 1
scCPULoad			DS.L 1
					ENDR

AudioSelection		RECORD 0
unitType			DS.L 1
selStart			DS.L 1		; Fixed; 
selEnd				DS.L 1		; Fixed; 
					ENDR

SndDoubleBuffer		RECORD 0
dbNumFrames			DS.L 1
dbFlags				DS.L 1
dbUserInfo			DS.L 2
dbSoundData			EQU *						
					ENDR

SndDoubleBufferHeader	RECORD 0
dbhNumChannels			DS.W 1
dbhSampleSize			DS.W 1
dbhCompressionID		DS.W 1
dbhPacketSize			DS.W 1
dbhSampleRate			DS.L 1
dbhBufferPtr			DS.L 2
dbhDoubleBack			DS.L 1
SndDoubleBufferHeaderSz	EQU  *						
						ENDR

; _______________________________________________________________________
; 
; MACE structures
; 
; _______________________________________________________________________


LeftOverBlock		RECORD 0
count				DS.L 1
sampleArea			DS.B leftOverBlockSize
					ENDR

CmpSoundHeader 		RECORD 0
samplePtr			DS.L 1			; if NIL then samples are in sampleArea
numChannels			DS.L 1			; number of channels  mono = 1
sampleRate			DS.L 1			; sample rate in Apples Fixed point representation
loopStart			DS.L 1			; loopStart of sound before compression
loopEnd				DS.L 1			; loopEnd of sound before compression
encode				DS.B 1			; data structure used ,  stdSH, extSH, or cmpSH
baseFrequency		DS.B 1			; same meaning as regular SoundHeader
numFrames			DS.L 1			; length in frames	( packetFrames or sampleFrames
AIFFSampleRate		DS.B 10			; IEEE sample rate EXTENDED number
markerChunk			DS.L 1			; sync track
futureUse1			DS.L 1			; reserved by Apple
futureUse2			DS.L 1			; reserved by Apple
stateVars			DS.L 1			; pointer to State Block
leftOverSamples		DS.L 1			; used to save truncated samples between compression calls
compressionID		DS.W 1			; 0 means no compression, non zero means compressionID
packetSize			DS.W 1			; number of bits in compressed sample packet
snthID				DS.W 1			; Resource ID of Sound Manager snth that contains NRT C/E
sampleSize			DS.W 1			; number of bits in non-compressed sample
sampleArea			EQU	 *			; space for when samples follow directly
					ENDR

ExtSoundHeader 		RECORD 0
samplePtr			DS.L 1			; if NIL then samples are in sampleArea
numChannels			DS.L 1			; number of channels  mono = 1
sampleRate			DS.L 1			; sample rate in Apples Fixed point representation
loopStart			DS.L 1			; loopStart of sound before compression
loopEnd				DS.L 1			; loopEnd of sound before compression
encode				DS.B 1			; data structure used ,  stdSH, extSH, or cmpSH
baseFrequency		DS.B 1			; same meaning as regular SoundHeader
numFrames			DS.L 1			; length in total number of frames
AIFFSampleRate		DS.B 10			; IEEE sample rate
markerChunk			DS.L 1			; sync track
instrumentChunks	DS.L 1
AESRecording		DS.L 1
sampleSize			DS.W 1			; number of bits in sample
futureUse1			DS.W 1			; reserved by Apple
futureUse2			DS.L 1			; reserved by Apple
futureUse3			DS.L 1			; reserved by Apple
futureUse4			DS.L 1			; reserved by Apple
sampleArea			EQU	 *			; space for when samples follow directly
					ENDR

; _______________________________________________________________________
; 
; Sound Input
; 
; _______________________________________________________________________

siDeviceIsConnected		EQU 1			; input device is connected and ready for input
siDeviceNotConnected	EQU 0			; input device is not connected
siDontKnowIfConnected	EQU -1			; can't tell if input device is connected


; Info Selectors for the SPBGetDeviceInfo and SPBSetDeviceInfo calls

siDeviceConnected		EQU 'dcon'		; input device connection status
siAGCOnOff				EQU 'agc '		; automatic gain control state
siPlayThruOnOff			EQU 'plth'		; playthrough state
siTwosComplementOnOff	EQU 'twos'		; two's complement state
siLevelMeterOnOff		EQU 'lmet'		; level meter state
siRecordingQuality		EQU 'qual'		; recording quality
siVoxRecordInfo			EQU 'voxr'		; VOX record parameters
siVoxStopInfo			EQU 'voxs'		; VOX stop parameters
siNumberChannels		EQU 'chan'		; current number of channels
siSampleSize			EQU 'ssiz'		; current sample size
siSampleRate			EQU 'srat'		; current sample rate
siCompressionType		EQU 'comp'		; current compression type
siCompressionFactor		EQU 'cmfa'		; current compression factor
siCompressionHeader		EQU 'cmhd'		; return compression header
siDeviceName			EQU 'name'		; input device name
siDeviceIcon			EQU 'icon'		; input device icon
siDeviceBufferInfo		EQU 'dbin'		; size of interrupt buffer
siSampleSizeAvailable	EQU 'ssav'		; sample sizes available
siSampleRateAvailable	EQU 'srav'		; sample rates available
siCompressionAvailable	EQU 'cmav'		; compression types available
siChannelAvailable		EQU 'chav'		; number of channels available
siAsync					EQU 'asyn'		; asynchronous capability
siOptionsDialog			EQU 'optd'		; display options dialog
siContinuous			EQU 'cont'		; continous recording
siActiveChannels		EQU 'chac'		; active channels
siActiveLevels			EQU 'lmac'		; active meter levels
siInputSource			EQU 'sour'		; input source selector
siInitializeDriver		EQU 'init'		; reserved for internal use only
siCloseDriver			EQU 'clos'		; reserved for internal use only
siPauseRecording		EQU 'paus'		; reserved for internal use only
siUserInterruptProc		EQU 'user'		; reserved for internal use only

; Quality Selectors for the SndRecord and SndRecordToFile calls

siBestQuality			EQU 'best'
siBetterQuality			EQU 'betr'
siGoodQuality			EQU 'good'

; Sound Input Parameter Block (SPB)

SInParam			RECORD 0
inRefNum			DS.L 1			; pointer to Application Reference Block
count				DS.L 1			; the # of bytes to read
milliseconds		DS.L 1			; the # of ms of sound to read
bufferLength		DS.L 1			; length of input buffer
inputBuffer			DS.L 1			; pointer to input buffer
completionRoutine	DS.L 1			; procPtr to the user completion routine
interruptRoutine	DS.L 1			; procPtr to the user interrupt routine
userLong			DS.L 1			; reserved for user data
error				DS.W 1			; OSErr will be returned to asynch routines
unused1				DS.L 1			; reserved for future expansion - must be zero
SInPARAMSize		EQU *			; size of SInParam
					ENDR


	ENDIF	; ...already included
\ No newline at end of file
diff --git a/Interfaces/AIncludes/Sound.a.idump b/Interfaces/AIncludes/Sound.a.idump
new file mode 100644
--- /dev/null
+++ b/Interfaces/AIncludes/Sound.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
diff --git a/Interfaces/CIncludes/Sound.h b/Interfaces/CIncludes/Sound.h
new file mode 100644
--- /dev/null
+++ b/Interfaces/CIncludes/Sound.h
@@ -0,0 +1,521 @@
+
+/************************************************************
+
+Created: Monday, December 2, 1991 at 5:07 PM
+ Sound.h
+ C Interface to the Macintosh Libraries
+
+
+  Copyright Apple Computer, Inc. 1986-1991
+  All rights reserved
+
+************************************************************/
+
+
+#ifndef __SOUND__
+#define __SOUND__
+
+#ifndef __TYPES__
+#include <Types.h>
+#endif
+
+#ifndef __FILES__
+#include <Files.h>
+#endif
+
+
+enum {
+
+ swMode = -1,								/* Sound Driver modes */
+ ftMode = 1,
+ ffMode = 0,
+
+
+#define synthCodeRsrc 'snth'				/* Resource types used by Sound Manager */
+#define soundListRsrc 'snd '
+
+#define twelfthRootTwo 1.05946309434
+
+ rate22khz = 0x56EE8BA3,					/* 22254.54545 in fixed-point */
+ rate11khz = 0x2B7745D1,					/* 11127.27273 in fixed-point */
+
+/* synthesizer numbers for SndNewChannel */
+ squareWaveSynth = 1,						/*square wave synthesizer*/
+ waveTableSynth = 3,						/*wave table synthesizer*/
+ sampledSynth = 5,							/*sampled sound synthesizer*/
+
+/* old Sound Manager MACE synthesizer numbers */
+ MACE3snthID = 11,
+ MACE6snthID = 13,
+
+/* command numbers for SndDoCommand and SndDoImmediate */
+ nullCmd = 0,
+ initCmd = 1,
+ freeCmd = 2,
+ quietCmd = 3,
+ flushCmd = 4,
+ reInitCmd = 5,
+
+ waitCmd = 10,
+ pauseCmd = 11,
+ resumeCmd = 12,
+ callBackCmd = 13
+};
+enum {
+ syncCmd = 14,
+ emptyCmd = 15,
+
+ tickleCmd = 20,
+ requestNextCmd = 21,
+ howOftenCmd = 22,
+ wakeUpCmd = 23,
+ availableCmd = 24,
+ versionCmd = 25,
+ totalLoadCmd = 26,
+ loadCmd = 27,
+
+ scaleCmd = 30,
+ tempoCmd = 31,
+
+ freqDurationCmd = 40,
+ restCmd = 41,
+ freqCmd = 42,
+ ampCmd = 43,
+ timbreCmd = 44,
+ getAmpCmd = 45,
+
+ volumeCmd                     = 46,   /*sound manager 3.0 or later only*/
+ getVolumeCmd                  = 47,   /*sound manager 3.0 or later only*/
+ clockComponentCmd             = 50,   /*sound manager 3.2.1 or later only*/
+ getClockComponentCmd          = 51,   /*sound manager 3.2.1 or later only*/
+ scheduledSoundCmd             = 52,   /*sound manager 3.3 or later only*/
+ linkSoundComponentsCmd        = 53,   /*sound manager 3.3 or later only*/
+
+ waveTableCmd = 60,
+ phaseCmd = 61
+};
+enum {
+
+ soundCmd = 80,
+ bufferCmd = 81,
+ rateCmd = 82,
+ continueCmd = 83,
+ doubleBufferCmd = 84,
+ getRateCmd = 85,
+ rateMultiplierCmd             = 86,
+ getRateMultiplierCmd          = 87,
+
+ sizeCmd = 90,
+ convertCmd = 91,
+
+ stdQLength = 128,
+ dataOffsetFlag = 0x8000,
+
+ waveInitChannelMask = 0x07,
+ waveInitChannel0 = 0x04,
+ waveInitChannel1 = 0x05,
+ waveInitChannel2 = 0x06,
+ waveInitChannel3 = 0x07,
+
+/* channel initialization parameters */
+ initPanMask = 0x0003,						/* mask for right/left pan values */
+ initSRateMask = 0x0030,					/* mask for sample rate values */
+ initStereoMask = 0x00C0,					/* mask for mono/stereo values */
+ initCompMask = 0xFF00,						/* mask for compression IDs */
+
+ initChanLeft = 0x0002						/* left stereo channel */
+};
+enum {
+ initChanRight = 0x0003,					/* right stereo channel */
+ initNoInterp = 0x0004,						/* no linear interpolation */
+ initNoDrop = 0x0008,						/* no drop-sample conversion */
+ initMono = 0x0080,							/* monophonic channel */
+ initStereo = 0x00C0,						/* stereo channel */
+ initMACE3 = 0x0300,						/* MACE 3:1 */
+ initMACE6 = 0x0400,						/* MACE 6:1 */
+
+ initChan0 = 0x0004,						/* channel 0 - wave table only */
+ initChan1 = 0x0005,						/* channel 1 - wave table only */
+ initChan2 = 0x0006,						/* channel 2 - wave table only */
+ initChan3 = 0x0007,						/* channel 3 - wave table only */
+
+ stdSH = 0x00,								/* Standard sound header encode value */
+ extSH = 0xFF,								/* Extended sound header encode value */
+ cmpSH = 0xFE,								/* Compressed sound header encode value */
+
+ notCompressed = 0,							/* compression ID's */
+ twoToOne = 1,
+ eightToThree = 2,
+ threeToOne = 3,
+ sixToOne = 4,
+
+ outsideCmpSH = 0							/* MACE constants */
+};
+enum {
+ insideCmpSH = 1,
+ aceSuccess = 0,
+ aceMemFull = 1,
+ aceNilBlock = 2,
+ aceBadComp = 3,
+ aceBadEncode = 4,
+ aceBadDest = 5,
+ aceBadCmd = 6,
+ sixToOnePacketSize = 8,
+ threeToOnePacketSize = 16,
+ stateBlockSize = 64,
+ leftOverBlockSize = 32,
+
+ firstSoundFormat = 0x0001,					/* general sound format */
+ secondSoundFormat = 0x0002,				/* special sampled sound format (HyperCard) */
+
+ dbBufferReady = 0x00000001,				/* double buffer is filled */
+ dbLastBuffer = 0x00000004,					/* last double buffer to play */
+
+ sysBeepDisable = 0x0000,					/* SysBeep() enable flags */
+ sysBeepEnable = 0x0001,
+
+ unitTypeNoSelection = 0xFFFF,				/* unitTypes for AudioSelection.unitType */
+ unitTypeSeconds = 0x0000
+};
+
+
+/*   Structures for Sound Driver   */
+
+
+typedef unsigned char FreeWave[30001];
+
+struct FFSynthRec {
+ short mode;
+ Fixed count;
+ FreeWave waveBytes;
+};
+
+typedef struct FFSynthRec FFSynthRec;
+typedef FFSynthRec *FFSynthPtr;
+
+struct Tone {
+ short count;
+ short amplitude;
+ short duration;
+};
+
+typedef struct Tone Tone;
+
+
+typedef Tone Tones[5001];
+
+struct SWSynthRec {
+ short mode;
+ Tones triplets;
+};
+
+typedef struct SWSynthRec SWSynthRec;
+typedef SWSynthRec *SWSynthPtr;
+
+
+typedef unsigned char Wave[256];
+typedef Wave *WavePtr;
+
+struct FTSoundRec {
+ short duration;
+ Fixed sound1Rate;
+ long sound1Phase;
+ Fixed sound2Rate;
+ long sound2Phase;
+ Fixed sound3Rate;
+ long sound3Phase;
+ Fixed sound4Rate;
+ long sound4Phase;
+ WavePtr sound1Wave;
+ WavePtr sound2Wave;
+ WavePtr sound3Wave;
+ WavePtr sound4Wave;
+};
+
+typedef struct FTSoundRec FTSoundRec;
+typedef FTSoundRec *FTSndRecPtr;
+
+struct FTSynthRec {
+ short mode;
+ FTSndRecPtr sndRec;
+};
+
+typedef struct FTSynthRec FTSynthRec;
+typedef FTSynthRec *FTSynthPtr;
+
+
+typedef pascal void (*SndCompletionProcPtr)(void);
+
+/*   Structures for Sound Manager   */
+
+struct SndCommand {
+ unsigned short cmd;
+ short param1;
+ long param2;
+};
+
+typedef struct SndCommand SndCommand;
+
+
+typedef long Time;							/* in half milliseconds */
+
+
+
+typedef struct SndChannel SndChannel;
+typedef SndChannel *SndChannelPtr;
+
+
+typedef pascal void (*SndCallBackProcPtr)(SndChannelPtr chan, SndCommand cmd);
+
+struct SndChannel {
+    struct SndChannel *nextChan;
+    Ptr firstMod;                      		/* reserved for the Sound Manager */
+    SndCallBackProcPtr callBack;
+    long userInfo;
+    Time wait;                         		/* The following is for internal Sound Manager use only.*/
+    SndCommand cmdInProgress;
+    short flags;
+    short qLength;
+    short qHead;                       		/* next spot to read or -1 if empty */
+    short qTail;                       		/* next spot to write = qHead if full */
+    SndCommand queue[stdQLength];
+};
+
+/* MACE structures */
+struct StateBlock {
+ short stateVar[stateBlockSize];
+};
+
+typedef struct StateBlock StateBlock;
+typedef StateBlock *StateBlockPtr;
+
+struct LeftOverBlock {
+ unsigned long count;
+ char sampleArea[leftOverBlockSize];
+};
+
+typedef struct LeftOverBlock LeftOverBlock;
+typedef LeftOverBlock *LeftOverBlockPtr;
+
+struct ModRef {
+ unsigned short modNumber;
+ long modInit;
+};
+
+typedef struct ModRef ModRef;
+
+struct SndListResource {
+ short format;
+ short numModifiers;
+ ModRef modifierPart[1];					/*This is a variable length array*/
+ short numCommands;
+ SndCommand commandPart[1];					/*This is a variable length array*/
+ char dataPart[1];							/*This is a variable length array*/
+};
+
+typedef struct SndListResource SndListResource;
+typedef SndListResource *SndListPtr;
+
+struct SoundHeader {
+ Ptr samplePtr;								/* if NIL then samples are in sampleArea */
+ unsigned long length;						/* length of sound in bytes */
+ Fixed sampleRate;							/* sample rate for this sound */
+ unsigned long loopStart;					/* start of looping portion */
+ unsigned long loopEnd;						/* end of looping portion */
+ unsigned char encode;						/* header encoding */
+ unsigned char baseFrequency;				/* baseFrequency value */
+ char sampleArea[1];
+};
+
+typedef struct SoundHeader SoundHeader;
+typedef SoundHeader *SoundHeaderPtr;
+
+struct CmpSoundHeader {
+ Ptr samplePtr;								/* if nil then samples are in sample area */
+ unsigned long numChannels;					/* number of channels i.e. mono = 1 */
+ Fixed sampleRate;							/* sample rate in Apples Fixed point representation */
+ unsigned long loopStart;					/* loopStart of sound before compression */
+ unsigned long loopEnd;						/* loopEnd of sound before compression */
+ unsigned char encode;						/* data structure used , stdSH, extSH, or cmpSH */
+ unsigned char baseFrequency;				/* same meaning as regular SoundHeader */
+ unsigned long numFrames;					/* length in frames ( packetFrames or sampleFrames ) */
+ extended80 AIFFSampleRate;					/* IEEE sample rate */
+ Ptr markerChunk;							/* sync track */
+ Ptr futureUse1;							/* reserved by Apple */
+ Ptr futureUse2;							/* reserved by Apple */
+ StateBlockPtr stateVars;					/* pointer to State Block */
+ LeftOverBlockPtr leftOverSamples;			/* used to save truncated samples between compression calls */
+ unsigned short compressionID;				/* 0 means no compression, non zero means compressionID */
+ unsigned short packetSize;					/* number of bits in compressed sample packet */
+ unsigned short snthID;						/* resource ID of Sound Manager snth that contains NRT C/E */
+ unsigned short sampleSize;					/* number of bits in non-compressed sample */
+ char sampleArea[1];						/* space for when samples follow directly */
+};
+
+typedef struct CmpSoundHeader CmpSoundHeader;
+typedef CmpSoundHeader *CmpSoundHeaderPtr;
+
+struct ExtSoundHeader {
+ Ptr samplePtr;								/* if nil then samples are in sample area */
+ unsigned long numChannels;					/* number of channels,  ie mono = 1 */
+ Fixed sampleRate;							/* sample rate in Apples Fixed point representation */
+ unsigned long loopStart;					/* same meaning as regular SoundHeader */
+ unsigned long loopEnd;						/* same meaning as regular SoundHeader */
+ unsigned char encode;						/* data structure used , stdSH, extSH, or cmpSH */
+ unsigned char baseFrequency;				/* same meaning as regular SoundHeader */
+ unsigned long numFrames;					/* length in total number of frames */
+ extended80 AIFFSampleRate;					/* IEEE sample rate */
+ Ptr markerChunk;							/* sync track */
+ Ptr instrumentChunks;						/* AIFF instrument chunks */
+ Ptr AESRecording;
+ unsigned short sampleSize;					/* number of bits in sample */
+ unsigned short futureUse1;					/* reserved by Apple */
+ unsigned long futureUse2;					/* reserved by Apple */
+ unsigned long futureUse3;					/* reserved by Apple */
+ unsigned long futureUse4;					/* reserved by Apple */
+ char sampleArea[1];						/* space for when samples follow directly */
+};
+
+typedef struct ExtSoundHeader ExtSoundHeader;
+typedef ExtSoundHeader *ExtSoundHeaderPtr;
+
+struct ConversionBlock {
+ short destination;
+ short unused;
+ CmpSoundHeaderPtr inputPtr;
+ CmpSoundHeaderPtr outputPtr;
+};
+
+typedef struct ConversionBlock ConversionBlock;
+typedef ConversionBlock *ConversionBlockPtr;
+
+struct SMStatus {
+ short smMaxCPULoad;
+ short smNumChannels;
+ short smCurCPULoad;
+};
+
+typedef struct SMStatus SMStatus;
+typedef SMStatus *SMStatusPtr;
+
+struct SCStatus {
+ Fixed scStartTime;
+ Fixed scEndTime;
+ Fixed scCurrentTime;
+ Boolean scChannelBusy;
+ Boolean scChannelDisposed;
+ Boolean scChannelPaused;
+ Boolean scUnused;
+ unsigned long scChannelAttributes;
+ long scCPULoad;
+};
+
+typedef struct SCStatus SCStatus;
+typedef SCStatus *SCStatusPtr;
+
+struct AudioSelection {
+ long unitType;
+ Fixed selStart;
+ Fixed selEnd;
+};
+
+typedef struct AudioSelection AudioSelection;
+typedef AudioSelection *AudioSelectionPtr;
+
+struct SndDoubleBuffer {
+ long dbNumFrames;
+ long dbFlags;
+ long dbUserInfo[2];
+ char dbSoundData[1];
+};
+
+typedef struct SndDoubleBuffer SndDoubleBuffer;
+typedef SndDoubleBuffer *SndDoubleBufferPtr;
+
+
+typedef pascal void (*SndDoubleBackProcPtr) (SndChannelPtr channel,
+           SndDoubleBufferPtr doubleBufferPtr);
+
+struct SndDoubleBufferHeader {
+ short dbhNumChannels;
+ short dbhSampleSize;
+ short dbhCompressionID;
+ short dbhPacketSize;
+ Fixed dbhSampleRate;
+ SndDoubleBufferPtr dbhBufferPtr[2];
+ SndDoubleBackProcPtr dbhDoubleBack;
+};
+
+typedef struct SndDoubleBufferHeader SndDoubleBufferHeader;
+typedef SndDoubleBufferHeader *SndDoubleBufferHeaderPtr;
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+pascal OSErr SndDoCommand(SndChannelPtr chan,const SndCommand *cmd,Boolean noWait)
+ = 0xA803; 
+pascal OSErr SndDoImmediate(SndChannelPtr chan,const SndCommand *cmd)
+ = 0xA804; 
+pascal OSErr SndNewChannel(SndChannelPtr *chan,short synth,long init,SndCallBackProcPtr userRoutine)
+ = 0xA807; 
+pascal OSErr SndDisposeChannel(SndChannelPtr chan,Boolean quietNow)
+ = 0xA801; 
+pascal OSErr SndPlay(SndChannelPtr chan,Handle sndHdl,Boolean async)
+ = 0xA805; 
+pascal OSErr SndAddModifier(SndChannelPtr chan,ProcPtr modifier,short id,
+ long init)
+ = 0xA802; 
+pascal OSErr SndControl(short id,SndCommand *cmd)
+ = 0xA806; 
+
+pascal void SetSoundVol(short level); 
+#pragma parameter GetSoundVol(__A0)
+pascal void GetSoundVol(short *level)
+ = {0x4218,0x10B8,0x0260}; 
+pascal void StartSound(const void *synthRec,long numBytes,SndCompletionProcPtr completionRtn); 
+pascal void StopSound(void); 
+pascal Boolean SoundDone(void); 
+
+pascal NumVersion SndSoundManagerVersion(void)
+ = {0x203C,0x000C,0x0008,0xA800}; 
+pascal OSErr SndStartFilePlay(SndChannelPtr chan,short fRefNum,short resNum,
+ long bufferSize,void *theBuffer,AudioSelectionPtr theSelection,ProcPtr theCompletion,
+ Boolean async)
+ = {0x203C,0x0D00,0x0008,0xA800}; 
+pascal OSErr SndPauseFilePlay(SndChannelPtr chan)
+ = {0x203C,0x0204,0x0008,0xA800}; 
+pascal OSErr SndStopFilePlay(SndChannelPtr chan,Boolean async)
+ = {0x203C,0x0308,0x0008,0xA800}; 
+pascal OSErr SndChannelStatus(SndChannelPtr chan,short theLength,SCStatusPtr theStatus)
+ = {0x203C,0x0010,0x0008,0xA800}; 
+pascal OSErr SndManagerStatus(short theLength,SMStatusPtr theStatus)
+ = {0x203C,0x0014,0x0008,0xA800}; 
+pascal void SndGetSysBeepState(short *sysBeepState)
+ = {0x203C,0x0018,0x0008,0xA800}; 
+pascal OSErr SndSetSysBeepState(short sysBeepState)
+ = {0x203C,0x001C,0x0008,0xA800}; 
+pascal OSErr SndPlayDoubleBuffer(SndChannelPtr chan,SndDoubleBufferHeaderPtr theParams)
+ = {0x203C,0x0020,0x0008,0xA800}; 
+pascal OSErr GetSysBeepVolume(long *level)
+ = {0x203C,0x0224,0x0018,0xA800};
+
+pascal NumVersion MACEVersion(void)
+ = {0x203C,0x0000,0x0010,0xA800}; 
+pascal void Comp3to1(const void *inBuffer,void *outBuffer,unsigned long cnt,
+ const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+ = {0x203C,0x0004,0x0010,0xA800}; 
+pascal void Exp1to3(const void *inBuffer,void *outBuffer,unsigned long cnt,
+ const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+ = {0x203C,0x0008,0x0010,0xA800}; 
+pascal void Comp6to1(const void *inBuffer,void *outBuffer,unsigned long cnt,
+ const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+ = {0x203C,0x000C,0x0010,0xA800}; 
+pascal void Exp1to6(const void *inBuffer,void *outBuffer,unsigned long cnt,
+ const void *inState,void *outState,unsigned long numChannels,unsigned long whichChannel)
+ = {0x203C,0x0010,0x0010,0xA800}; 
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/Interfaces/CIncludes/Sound.h.idump b/Interfaces/CIncludes/Sound.h.idump
new file mode 100644
--- /dev/null
+++ b/Interfaces/CIncludes/Sound.h.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Interfaces/CIncludes/Sound.h.rdump b/Interfaces/CIncludes/Sound.h.rdump
new file mode 100644
--- /dev/null
+++ b/Interfaces/CIncludes/Sound.h.rdump
@@ -0,0 +1,45 @@
+#if 0
+data '????' (0, "Header as fake resource (not for Rez)") {
+	$"0002 0031 0032 0002 0031 005A 000F 0061"            /* ...1.2...1.Z...a */
+	$"6D70 436D 6420 4551 5520 3433 2000 0055"            /* mpCmd EQU 43 ..U */
+	$"0753 6F75 6E64 2E68 0200 0000 5445 5854"            /* .Sound.h....TEXT */
+	$"4D50 5320 0000 0000 0000 0000 0000 014D"            /* MPS ...........M */
+	$"0000 5445 5854 4D50 5320 0000 0000 0000"            /* ..TEXTMPS ...... */
+	$"0000 0000 0000 0000 0000 0000 0000 0000"            /* ................ */
+	$"0000 A664 D9C0 0000 0000 0000 021B 0000"            /* ...d............ */
+	$"0000 01C0 4341 5244 0000 3B1E 0000 0000"            /* ....CARD..;..... */
+	$"0000 0000 0000 0000 0000 0000 0000 0000"            /* ................ */
+	$"0000 202A 0000 122E 0000 0000 0000 0000"            /* .. *............ */
+	$"001A 0000 0160 0009 0011 0031 322F 3131"            /* .....`.....12/11 */
+	$"2F38 3720 353A 3533 2041 4D00 0002 0006"            /* /87 5:53 AM..... */
+	$"0053 6F75 6E64 0003 000A 0074 696D 6272"            /* .Sound.....timbr */
+	$"6543 6D64 0004 0003 0034 3400 0005 0006"            /* eCmd.....44..... */
+	$"0024 3030 3332 000C 000C 0052 6F6E 204D"            /* .$0032.....Ron M */
+};
+#endif
+
+data 'vers' (1) {
+	$"0321 8000 0000 0533 2E32 2E31 2833 2E32"            /* .!.....3.2.1(3.2 */
+	$"2E31 2C20 A920 4170 706C 6520 436F 6D70"            /* .1, . Apple Comp */
+	$"7574 6572 2C20 496E 632E 2031 3938 352D"            /* uter, Inc. 1985- */
+	$"3139 3932 2E"                                       /* 1992. */
+};
+
+data 'vers' (2, purgeable) {
+	$"0330 8000 0000 0333 2E33 074D 5057 2033"            /* .0.....3.3.MPW 3 */
+	$"2E33"                                               /* .3 */
+};
+
+data 'MPSR' (1005) {
+	$"0009 4D6F 6E61 636F 00FF 001F 01E1 01E2"            /* ..Monaco........ */
+	$"7FFF 015E 0009 000A 7FFF 015F 000A 01E2"            /* ...^......._.... */
+	$"7FFF 0006 0004 0031 000A 015D 01E0 0031"            /* .......1...]...1 */
+	$"000A 015D 01E0 A664 D9C0 0000 0000 0000"            /* ...]...d........ */
+	$"0000 0000 0000 0100"                                /* ........ */
+};
+
+data 'MPSR' (1008) {
+	$"0031 000A 015D 01E0 0031 000A 015D 01E0"            /* .1...]...1...].. */
+	$"0000 0000 0000 0000 0000 0000 0000"                 /* .............. */
+};
+
diff --git a/Interfaces/PInterfaces/Sound.p b/Interfaces/PInterfaces/Sound.p
new file mode 100644
--- /dev/null
+++ b/Interfaces/PInterfaces/Sound.p
@@ -0,0 +1,455 @@
+
+{
+Created: Monday, December 2, 1991 at 5:09 PM
+ Sound.p
+ Pascal Interface to the Macintosh Libraries
+
+  Copyright Apple Computer, Inc. 1986-1991
+  All rights reserved
+}
+
+
+{$IFC UNDEFINED UsingIncludes}
+{$SETC UsingIncludes := 0}
+{$ENDC}
+
+{$IFC NOT UsingIncludes}
+ UNIT Sound;
+ INTERFACE
+{$ENDC}
+
+{$IFC UNDEFINED UsingSound}
+{$SETC UsingSound := 1}
+
+{$I+}
+{$SETC SoundIncludes := UsingIncludes}
+{$SETC UsingIncludes := 1}
+{$IFC UNDEFINED UsingTypes}
+{$I $$Shell(PInterfaces)Types.p}
+{$ENDC}
+{$IFC UNDEFINED UsingFiles}
+{$I $$Shell(PInterfaces)Files.p}
+{$ENDC}
+{$SETC UsingIncludes := SoundIncludes}
+
+CONST
+swMode = -1;								{ Sound Driver modes }
+ftMode = 1;
+ffMode = 0;
+
+synthCodeRsrc = 'snth';						{ Resource types used by Sound Manager }
+soundListRsrc = 'snd ';
+
+twelfthRootTwo = 1.05946309434;
+rate22khz = $56EE8BA3;						{ 22254.54545 in fixed-point }
+rate11khz = $2B7745D1;						{ 11127.27273 in fixed-point }
+
+{ synthesizer numbers for SndNewChannel }
+squareWaveSynth = 1;						{square wave synthesizer}
+waveTableSynth = 3;							{wave table synthesizer}
+sampledSynth = 5;							{sampled sound synthesizer}
+
+{ old Sound Manager MACE synthesizer numbers }
+MACE3snthID = 11;
+MACE6snthID = 13;
+
+{ command numbers for SndDoCommand and SndDoImmediate }
+nullCmd = 0;
+initCmd = 1;
+freeCmd = 2;
+quietCmd = 3;
+flushCmd = 4;
+reInitCmd = 5;
+
+waitCmd = 10;
+pauseCmd = 11;
+resumeCmd = 12;
+callBackCmd = 13;
+syncCmd = 14;
+emptyCmd = 15;
+
+tickleCmd = 20;
+requestNextCmd = 21;
+howOftenCmd = 22;
+wakeUpCmd = 23;
+availableCmd = 24;
+versionCmd = 25;
+totalLoadCmd = 26;
+loadCmd = 27;
+
+scaleCmd = 30;
+tempoCmd = 31;
+
+freqDurationCmd = 40;
+restCmd = 41;
+freqCmd = 42;
+ampCmd = 43;
+timbreCmd = 44;
+getAmpCmd = 45;
+
+waveTableCmd = 60;
+phaseCmd = 61;
+
+soundCmd = 80;
+bufferCmd = 81;
+rateCmd = 82;
+continueCmd = 83;
+doubleBufferCmd = 84;
+getRateCmd = 85;
+
+sizeCmd = 90;
+convertCmd = 91;
+
+stdQLength = 128;
+dataOffsetFlag = $8000;
+
+waveInitChannelMask = $07;
+waveInitChannel0 = $04;
+waveInitChannel1 = $05;
+waveInitChannel2 = $06;
+waveInitChannel3 = $07;
+
+{ channel initialization parameters }
+initPanMask = $0003;						{ mask for right/left pan values }
+initSRateMask = $0030;						{ mask for sample rate values }
+initStereoMask = $00C0;						{ mask for mono/stereo values }
+initCompMask = $FF00;						{ mask for compression IDs }
+
+initChanLeft = $0002;						{ left stereo channel }
+initChanRight = $0003;						{ right stereo channel }
+initNoInterp = $0004;						{ no linear interpolation }
+initNoDrop = $0008;							{ no drop-sample conversion }
+initMono = $0080;							{ monophonic channel }
+initStereo = $00C0;							{ stereo channel }
+initMACE3 = $0300;							{ MACE 3:1 }
+initMACE6 = $0400;							{ MACE 6:1 }
+
+initChan0 = $0004;							{ channel 0 - wave table only }
+initChan1 = $0005;							{ channel 1 - wave table only }
+initChan2 = $0006;							{ channel 2 - wave table only }
+initChan3 = $0007;							{ channel 3 - wave table only }
+
+stdSH = $00;								{ Standard sound header encode value }
+extSH = $FF;								{ Extended sound header encode value }
+cmpSH = $FE;								{ Compressed sound header encode value }
+
+notCompressed = 0;							{ compression ID's }
+twoToOne = 1;
+eightToThree = 2;
+threeToOne = 3;
+sixToOne = 4;
+
+outsideCmpSH = 0;							{ MACE constants }
+insideCmpSH = 1;
+aceSuccess = 0;
+aceMemFull = 1;
+aceNilBlock = 2;
+aceBadComp = 3;
+aceBadEncode = 4;
+aceBadDest = 5;
+aceBadCmd = 6;
+sixToOnePacketSize = 8;
+threeToOnePacketSize = 16;
+stateBlockSize = 64;
+leftOverBlockSize = 32;
+
+firstSoundFormat = $0001;					{ general sound format }
+secondSoundFormat = $0002;					{ special sampled sound format (HyperCard) }
+
+dbBufferReady = $00000001;					{ double buffer is filled }
+dbLastBuffer = $00000004;					{ last double buffer to play }
+
+sysBeepDisable = $0000;						{ SysBeep() enable flags }
+sysBeepEnable = $0001;
+
+unitTypeNoSelection = $FFFF;				{ unitTypes for AudioSelection.unitType }
+unitTypeSeconds = $0000;
+
+TYPE
+{   Structures for Sound Driver   }
+
+
+FreeWave = PACKED ARRAY [0..30000] OF Byte;
+
+FFSynthPtr = ^FFSynthRec;
+FFSynthRec = RECORD
+ mode: INTEGER;
+ count: Fixed;
+ waveBytes: FreeWave;
+ END;
+
+Tone = RECORD
+ count: INTEGER;
+ amplitude: INTEGER;
+ duration: INTEGER;
+ END;
+
+
+Tones = ARRAY [0..5000] OF Tone;
+
+SWSynthPtr = ^SWSynthRec;
+SWSynthRec = RECORD
+ mode: INTEGER;
+ triplets: Tones;
+ END;
+
+
+Wave = PACKED ARRAY [0..255] OF Byte;
+WavePtr = ^Wave;
+
+FTSndRecPtr = ^FTSoundRec;
+FTSoundRec = RECORD
+ duration: INTEGER;
+ sound1Rate: Fixed;
+ sound1Phase: LONGINT;
+ sound2Rate: Fixed;
+ sound2Phase: LONGINT;
+ sound3Rate: Fixed;
+ sound3Phase: LONGINT;
+ sound4Rate: Fixed;
+ sound4Phase: LONGINT;
+ sound1Wave: WavePtr;
+ sound2Wave: WavePtr;
+ sound3Wave: WavePtr;
+ sound4Wave: WavePtr;
+ END;
+
+FTSynthPtr = ^FTSynthRec;
+FTSynthRec = RECORD
+ mode: INTEGER;
+ sndRec: FTSndRecPtr;
+ END;
+
+{   Structures for Sound Manager   }
+
+SndCommand = PACKED RECORD
+ cmd: INTEGER;
+ param1: INTEGER;
+ param2: LONGINT;
+ END;
+
+
+Time = LONGINT;								{ in half milliseconds }
+
+
+
+SndChannelPtr = ^SndChannel;
+SndChannel = PACKED RECORD
+ nextChan: SndChannelPtr;
+ firstMod: Ptr;								{ reserved for the Sound Manager }
+ callBack: ProcPtr;
+ userInfo: LONGINT;
+ wait: Time;								{ The following is for internal Sound Manager use only.}
+ cmdInProgress: SndCommand;
+ flags: INTEGER;
+ qLength: INTEGER;
+ qHead: INTEGER;							{ next spot to read or -1 if empty }
+ qTail: INTEGER;							{ next spot to write = qHead if full }
+ queue: ARRAY [0..stdQLength - 1] OF SndCommand;
+ END;
+
+{ MACE structures }
+StateBlockPtr = ^StateBlock;
+StateBlock = RECORD
+ stateVar: ARRAY [0..stateBlockSize - 1] OF INTEGER;
+ END;
+
+LeftOverBlockPtr = ^LeftOverBlock;
+LeftOverBlock = RECORD
+ count: LONGINT;
+ sampleArea: PACKED ARRAY [0..leftOverBlockSize - 1] OF Byte;
+ END;
+
+ModRef = RECORD
+ modNumber: INTEGER;
+ modInit: LONGINT;
+ END;
+
+SndListPtr = ^SndListResource;
+SndListResource = RECORD
+ format: INTEGER;
+ numModifiers: INTEGER;
+ modifierPart: ARRAY [0..0] OF ModRef;		{This is a variable length array}
+ numCommands: INTEGER;
+ commandPart: ARRAY [0..0] OF SndCommand;	{This is a variable length array}
+ dataPart: PACKED ARRAY [0..0] OF Byte;		{This is a variable length array}
+ END;
+
+SoundHeaderPtr = ^SoundHeader;
+SoundHeader = PACKED RECORD
+ samplePtr: Ptr;							{ if NIL then samples are in sampleArea }
+ length: LONGINT;							{ length of sound in bytes }
+ sampleRate: Fixed;							{ sample rate for this sound }
+ loopStart: LONGINT;						{ start of looping portion }
+ loopEnd: LONGINT;							{ end of looping portion }
+ encode: Byte;								{ header encoding }
+ baseFrequency: Byte;						{ baseFrequency value }
+ sampleArea: PACKED ARRAY [0..0] OF Byte;
+ END;
+
+CmpSoundHeaderPtr = ^CmpSoundHeader;
+CmpSoundHeader = PACKED RECORD
+ samplePtr: Ptr;							{ if nil then samples are in sample area }
+ numChannels: LONGINT;						{ number of channels i.e. mono = 1 }
+ sampleRate: Fixed;							{ sample rate in Apples Fixed point representation }
+ loopStart: LONGINT;						{ loopStart of sound before compression }
+ loopEnd: LONGINT;							{ loopEnd of sound before compression }
+ encode: Byte;								{ data structure used , stdSH, extSH, or cmpSH }
+ baseFrequency: Byte;						{ same meaning as regular SoundHeader }
+ numFrames: LONGINT;						{ length in frames ( packetFrames or sampleFrames ) }
+ AIFFSampleRate: Extended80;				{ IEEE sample rate }
+ markerChunk: Ptr;							{ sync track }
+ futureUse1: Ptr;							{ reserved by Apple }
+ futureUse2: Ptr;							{ reserved by Apple }
+ stateVars: StateBlockPtr;					{ pointer to State Block }
+ leftOverSamples: LeftOverBlockPtr;			{ used to save truncated samples between compression calls }
+ compressionID: INTEGER;					{ 0 means no compression, non zero means compressionID }
+ packetSize: INTEGER;						{ number of bits in compressed sample packet }
+ snthID: INTEGER;							{ resource ID of Sound Manager snth that contains NRT C/E }
+ sampleSize: INTEGER;						{ number of bits in non-compressed sample }
+ sampleArea: PACKED ARRAY [0..0] OF Byte;	{ space for when samples follow directly }
+ END;
+
+ExtSoundHeaderPtr = ^ExtSoundHeader;
+ExtSoundHeader = PACKED RECORD
+ samplePtr: Ptr;							{ if nil then samples are in sample area }
+ numChannels: LONGINT;						{ number of channels,  ie mono = 1 }
+ sampleRate: Fixed;							{ sample rate in Apples Fixed point representation }
+ loopStart: LONGINT;						{ same meaning as regular SoundHeader }
+ loopEnd: LONGINT;							{ same meaning as regular SoundHeader }
+ encode: Byte;								{ data structure used , stdSH, extSH, or cmpSH }
+ baseFrequency: Byte;						{ same meaning as regular SoundHeader }
+ numFrames: LONGINT;						{ length in total number of frames }
+ AIFFSampleRate: Extended80;				{ IEEE sample rate }
+ markerChunk: Ptr;							{ sync track }
+ instrumentChunks: Ptr;						{ AIFF instrument chunks }
+ AESRecording: Ptr;
+ sampleSize: INTEGER;						{ number of bits in sample }
+ futureUse1: INTEGER;						{ reserved by Apple }
+ futureUse2: LONGINT;						{ reserved by Apple }
+ futureUse3: LONGINT;						{ reserved by Apple }
+ futureUse4: LONGINT;						{ reserved by Apple }
+ sampleArea: PACKED ARRAY [0..0] OF Byte;	{ space for when samples follow directly }
+ END;
+
+ConversionBlockPtr = ^ConversionBlock;
+ConversionBlock = RECORD
+ destination: INTEGER;
+ unused: INTEGER;
+ inputPtr: CmpSoundHeaderPtr;
+ outputPtr: CmpSoundHeaderPtr;
+ END;
+
+SMStatusPtr = ^SMStatus;
+SMStatus = PACKED RECORD
+ smMaxCPULoad: INTEGER;
+ smNumChannels: INTEGER;
+ smCurCPULoad: INTEGER;
+ END;
+
+SCStatusPtr = ^SCStatus;
+SCStatus = RECORD
+ scStartTime: Fixed;
+ scEndTime: Fixed;
+ scCurrentTime: Fixed;
+ scChannelBusy: BOOLEAN;
+ scChannelDisposed: BOOLEAN;
+ scChannelPaused: BOOLEAN;
+ scUnused: BOOLEAN;
+ scChannelAttributes: LONGINT;
+ scCPULoad: LONGINT;
+ END;
+
+AudioSelectionPtr = ^AudioSelection;
+AudioSelection = PACKED RECORD
+ unitType: LONGINT;
+ selStart: Fixed;
+ selEnd: Fixed;
+ END;
+
+SndDoubleBufferPtr = ^SndDoubleBuffer;
+SndDoubleBuffer = PACKED RECORD
+ dbNumFrames: LONGINT;
+ dbFlags: LONGINT;
+ dbUserInfo: ARRAY [0..1] OF LONGINT;
+ dbSoundData: PACKED ARRAY [0..0] OF Byte;
+ END;
+
+SndDoubleBufferHeaderPtr = ^SndDoubleBufferHeader;
+SndDoubleBufferHeader = PACKED RECORD
+ dbhNumChannels: INTEGER;
+ dbhSampleSize: INTEGER;
+ dbhCompressionID: INTEGER;
+ dbhPacketSize: INTEGER;
+ dbhSampleRate: Fixed;
+ dbhBufferPtr: ARRAY [0..1] OF SndDoubleBufferPtr;
+ dbhDoubleBack: ProcPtr;
+ END;
+
+
+FUNCTION SndDoCommand(chan: SndChannelPtr;cmd: SndCommand;noWait: BOOLEAN): OSErr;
+ INLINE $A803;
+FUNCTION SndDoImmediate(chan: SndChannelPtr;cmd: SndCommand): OSErr;
+ INLINE $A804;
+FUNCTION SndNewChannel(VAR chan: SndChannelPtr;synth: INTEGER;init: LONGINT;
+ userRoutine: ProcPtr): OSErr;
+ INLINE $A807;
+FUNCTION SndDisposeChannel(chan: SndChannelPtr;quietNow: BOOLEAN): OSErr;
+ INLINE $A801;
+FUNCTION SndPlay(chan: SndChannelPtr;sndHdl: Handle;async: BOOLEAN): OSErr;
+ INLINE $A805;
+FUNCTION SndAddModifier(chan: SndChannelPtr;modifier: ProcPtr;id: INTEGER;
+ init: LONGINT): OSErr;
+ INLINE $A802;
+FUNCTION SndControl(id: INTEGER;VAR cmd: SndCommand): OSErr;
+ INLINE $A806;
+
+PROCEDURE SetSoundVol(level: INTEGER);
+PROCEDURE GetSoundVol(VAR level: INTEGER);
+PROCEDURE StartSound(synthRec: Ptr;numBytes: LONGINT;completionRtn: ProcPtr);
+PROCEDURE StopSound;
+FUNCTION SoundDone: BOOLEAN;
+
+FUNCTION SndSoundManagerVersion: NumVersion;
+ INLINE $203C,$000C,$0008,$A800;
+FUNCTION SndStartFilePlay(chan: SndChannelPtr;fRefNum: INTEGER;resNum: INTEGER;
+ bufferSize: LONGINT;theBuffer: Ptr;theSelection: AudioSelectionPtr;theCompletion: ProcPtr;
+ async: BOOLEAN): OSErr;
+ INLINE $203C,$0D00,$0008,$A800;
+FUNCTION SndPauseFilePlay(chan: SndChannelPtr): OSErr;
+ INLINE $203C,$0204,$0008,$A800;
+FUNCTION SndStopFilePlay(chan: SndChannelPtr;async: BOOLEAN): OSErr;
+ INLINE $203C,$0308,$0008,$A800;
+FUNCTION SndChannelStatus(chan: SndChannelPtr;theLength: INTEGER;theStatus: SCStatusPtr): OSErr;
+ INLINE $203C,$0010,$0008,$A800;
+FUNCTION SndManagerStatus(theLength: INTEGER;theStatus: SMStatusPtr): OSErr;
+ INLINE $203C,$0014,$0008,$A800;
+PROCEDURE SndGetSysBeepState(VAR sysBeepState: INTEGER);
+ INLINE $203C,$0018,$0008,$A800;
+FUNCTION SndSetSysBeepState(sysBeepState: INTEGER): OSErr;
+ INLINE $203C,$001C,$0008,$A800;
+FUNCTION SndPlayDoubleBuffer(chan: SndChannelPtr;theParams: SndDoubleBufferHeaderPtr): OSErr;
+ INLINE $203C,$0020,$0008,$A800;
+
+FUNCTION MACEVersion: NumVersion;
+ INLINE $203C,$0000,$0010,$A800;
+PROCEDURE Comp3to1(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$0004,$0010,$A800;
+PROCEDURE Exp1to3(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$0008,$0010,$A800;
+PROCEDURE Comp6to1(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$000C,$0010,$A800;
+PROCEDURE Exp1to6(inBuffer: Ptr;outBuffer: Ptr;cnt: LONGINT;inState: Ptr;
+ outState: Ptr;numChannels: LONGINT;whichChannel: LONGINT);
+ INLINE $203C,$0010,$0010,$A800;
+
+
+{$ENDC} { UsingSound }
+
+{$IFC NOT UsingIncludes}
+ END.
+{$ENDC}
+
diff --git a/Interfaces/PInterfaces/Sound.p.idump b/Interfaces/PInterfaces/Sound.p.idump
new file mode 100644
--- /dev/null
+++ b/Interfaces/PInterfaces/Sound.p.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Internal/Asm/SoundPrivate.a b/Internal/Asm/SoundPrivate.a
new file mode 100644
--- /dev/null
+++ b/Internal/Asm/SoundPrivate.a
@@ -0,0 +1,18 @@
+ASCFIFOCONTROL equ 0
+ASCFIFOINT equ 0
+ASCMODE equ 0
+ASCPLAYRECA equ 0
+ASCTESTREG equ 0
+ASCVERSION equ 0
+ASCVOLCONTROL equ 0
+BMFIFOCONTROLA equ 0
+BMFIFOCONTROLB equ 0
+BMINTCONTROLA equ 0
+BMINTCONTROLB equ 0
+BMLEFTSCALEA equ 0
+BMLEFTSCALEB equ 0
+BMRIGHTSCALEA equ 0
+BMRIGHTSCALEB equ 0
+BMSRCTIMEINCRA equ 0
+BMSRCTIMEINCRB equ 0
+RATE11025HZ equ 0
diff --git a/Internal/Asm/SoundPrivate.a.idump b/Internal/Asm/SoundPrivate.a.idump
new file mode 100644
--- /dev/null
+++ b/Internal/Asm/SoundPrivate.a.idump
@@ -0,0 +1 @@
+TEXTMPS 
\ No newline at end of file
diff --git a/Make/MainCode.Make b/Make/MainCode.Make
--- a/Make/MainCode.Make
+++ b/Make/MainCode.Make
@@ -119,7 +119,8 @@ MainCodeLibs = 												∂
 #	Vectorization
 #
 "{LibDir}MainCode.Lib"			ƒ	{MainCodeLibs} "{ObjDir}VectorTablePatch.a.o"
-	"{ToolDir}Vectorize" -w -v "{ObjDir}VectorTablePatch.a.o" -log "{TextDir}MainCode.Sym" {StdVOpts} -o "{Targ}" {MainCodeLibs}
+	Lib -o "{Targ}".blob {MainCodeLibs}
+	"{ToolDir}Vectorize" -w -v "{ObjDir}VectorTablePatch.a.o" -log "{TextDir}MainCode.Sym" {StdVOpts} -o "{Targ}" "{Targ}".blob
 
 "{ObjDir}VectorTablePatch.a.o"	ƒ	"{Sources}Make:VectorTable.a" "{IntAIncludes}VectorTablePatch.a"
 	Asm -case on {StdAOpts} -o "{Targ}" "{IntAIncludes}VectorTablePatch.a" -d &VectorTable="∂'{Sources}Make:VectorTable.a∂'" -d ROMBASE={RomBase}
diff --git a/Make/RISC.make b/Make/RISC.make
--- a/Make/RISC.make
+++ b/Make/RISC.make
@@ -270,50 +270,9 @@ Features		=	hasRISCV0ResMgrPatches					∂
 					ForROM
 
 
-ResourceFiles	=	"{RsrcDir}ATBoot.RSRC"					∂
-					"{MiscDir}AppleTalk.ROM.rsrc"			∂
-					"{RsrcDir}AppleEventMgr.rsrc"			∂
-					"{RsrcDir}CQD.rsrc"						∂
-					"{RsrcDir}ColorPicker.rsrc"				∂
-					"{RsrcDir}CommToolbox.rsrc"				∂
-					"{RsrcDir}ControlMgr.rsrc"				∂
-					"{RsrcDir}DataAccessMgr.rsrc"			∂
-					"{RsrcDir}DictionaryMgr.rsrc"			∂
-					"{RsrcDir}DeclData"						∂
-					"{RsrcDir}EDisk.rsrc"					∂
-					"{RsrcDir}EditionMgr.rsrc"				∂
-					"{RsrcDir}Gibbly.rsrc"					∂
-					"{MiscDir}GoNativeResources"			∂
-					"{MiscDir}EmulatorAccelerations.rsrc"	∂
-					"{RsrcDir}HelpMgr.rsrc"					∂
-					"{RsrcDir}InSane.rsrc"					∂
-					"{RsrcDir}I2CC.rsrc"					∂
-					"{RsrcDir}I2CT.rsrc"					∂
-					"{RsrcDir}ListMgr.rsrc"					∂
+ResourceFiles	=	"{RsrcDir}DeclData"						∂
 					"{RsrcDir}MainCode.Rsrc"				∂
-					"{RsrcDir}MenuMgr.rsrc"					∂
-					"{RsrcDir}MiscROMRsrcs.rsrc" 			∂
-					"{RsrcDir}NetBoot.rsrc"					∂
-					"{RsrcDir}PDMENET.rsrc"					∂
-					"{RsrcDir}PPC.rsrc"						∂
-					"{RsrcDir}PictUtilities.rsrc"			∂
-					"{RsrcDir}ROMApple2Fonts.rsrc"			∂
-					"{RsrcDir}ROMFonts.rsrc" 				∂
 					"{RsrcDir}RomLayout.Rsrc"				∂
-					"{RsrcDir}SCCIOP.rsrc"					∂
-					"{RsrcDir}SWIMIOP.rsrc"					∂
-					"{RsrcDir}InSaneNFPU.rsrc" 				∂
-					"{RsrcDir}Sane.rsrc" 					∂
-					"{RsrcDir}Serial.rsrc"					∂
-					"{RsrcDir}SerialDMA.rsrc"				∂
-					"{RsrcDir}Sony.rsrc" 					∂
-					"{RsrcDir}SoundMgr.rsrc" 				∂
-					"{RsrcDir}StandardFile.rsrc" 			∂
-					"{RsrcDir}VDigC.rsrc"					∂
-					"{RsrcDir}VDigT.rsrc"					∂
-					"{MiscDir}VM.RSRC"						∂
-					"{RsrcDir}WindowMgr.rsrc"				∂
-					"{RsrcDir}kbd.rsrc"
 
 
 RomMondo						ƒ	FeatureSet "{ImageDir}RomMondo"
diff --git a/OS/IoPrimitives/ImmgPrimitives.a b/OS/IoPrimitives/ImmgPrimitives.a
--- a/OS/IoPrimitives/ImmgPrimitives.a
+++ b/OS/IoPrimitives/ImmgPrimitives.a
@@ -79,6 +79,7 @@
 		INCLUDE	'IntModemMgrPrivEqu.a'
 		INCLUDE	'PowerPrivEqu.a'
 		INCLUDE	'Sound.a'
+		INCLUDE	'SoundPrivate.a'
 
 		MACHINE	MC68020									; <H3>
 
-- 
2.18.0

